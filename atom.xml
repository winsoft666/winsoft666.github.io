<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CodeSilo</title>
  
  
  <link href="https://jiangxueqiao.com/atom.xml" rel="self"/>
  
  <link href="https://jiangxueqiao.com/"/>
  <updated>2024-03-02T06:08:22.958Z</updated>
  <id>https://jiangxueqiao.com/</id>
  
  <author>
    <name>Jiang Xueqiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node插件开发(2)-不同的调用方式</title>
    <link href="https://jiangxueqiao.com/post/235943795.html"/>
    <id>https://jiangxueqiao.com/post/235943795.html</id>
    <published>2024-03-02T05:26:54.000Z</published>
    <updated>2024-03-02T06:08:22.958Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍如何在Node-API中实现不同的类型的接口，如：</p><ul><li>同步调用</li><li>基于Napi::AsyncWorker的异步调用，通过回调函数返回</li><li>异步调用，返回Promise</li><li>基于Napi::ThreadSafeFunction的异步调用，通过回调函数返回</li></ul><span id="more"></span><h2 id="一、同步调用"><a href="#一、同步调用" class="headerlink" title="一、同步调用"></a>一、同步调用</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Napi::Number <span class="title">Add</span><span class="params">(<span class="type">const</span> Napi::CallbackInfo&amp; info)</span> </span>{</span><br><span class="line">    Napi::Env env = info.<span class="built_in">Env</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.<span class="built_in">Length</span>() != <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">throw</span> Napi::TypeError::<span class="built_in">New</span>(env, <span class="string">"Wrong number of arguments"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!info[<span class="number">0</span>].<span class="built_in">IsNumber</span>() || !info[<span class="number">1</span>].<span class="built_in">IsNumber</span>())</span><br><span class="line">        <span class="keyword">throw</span> Napi::TypeError::<span class="built_in">New</span>(env, <span class="string">"Wrong arguments"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ret = info[<span class="number">0</span>].<span class="built_in">ToNumber</span>().<span class="built_in">Int32Value</span>() + info[<span class="number">1</span>].<span class="built_in">ToNumber</span>().<span class="built_in">Int32Value</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Napi::Number::<span class="built_in">New</span>(env, ret);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二、基于Napi-AsyncWorker的异步回调"><a href="#二、基于Napi-AsyncWorker的异步回调" class="headerlink" title="二、基于Napi::AsyncWorker的异步回调"></a>二、基于Napi::AsyncWorker的异步回调</h2><p>在Node-API中，不能在本地线程中直接调用JavaScript函数，可以借助Napi::AsyncWorker在子线程中执行任务，并在<code>OnOK</code>或<code>OnError</code>中执行回调函数返回结果到JavaScript。</p><p>以异步计算正整数N的10次方为例，通过回调函数返回计算结果。</p><p>与Node.js官方模块的接口一样，回调函数有2个参数callback(err, result)，失败err不为Null，成功则err为Null。</p><p>继承自Napi::AsyncWorker，重写<code>Execute</code>虚函数实现任务逻辑，重写<code>OnOK</code>虚函数执行回调函数返回成功结果，重写<code>OnError</code>虚函数执行回调函数返回失败。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Power10AsyncWorker</span> : <span class="keyword">public</span> Napi::AsyncWorker {</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Power10AsyncWorker</span>(<span class="type">const</span> Napi::Function&amp; callback, <span class="type">int32_t</span> n) :</span><br><span class="line">        Napi::<span class="built_in">AsyncWorker</span>(callback),</span><br><span class="line">        <span class="built_in">n_</span>(n) {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (n_ &lt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// N小于0则返回错误</span></span><br><span class="line">            <span class="built_in">SetError</span>(<span class="string">"N must larger than 0"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        result_ = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">// 每次暂停10ms，模拟耗时操作</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">            result_ *= n_;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnOK</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="built_in">Callback</span>().<span class="built_in">Call</span>({<span class="built_in">Env</span>().<span class="built_in">Null</span>(), Napi::Value::<span class="built_in">From</span>(<span class="built_in">Env</span>(), result_)});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnError</span><span class="params">(<span class="type">const</span> Napi::Error&amp; e)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="built_in">Callback</span>().<span class="built_in">Call</span>({e.<span class="built_in">Value</span>(), <span class="built_in">Env</span>().<span class="built_in">Null</span>()});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int32_t</span> n_ = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int32_t</span> result_ = <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>定义接口<code>GetPower10</code>，支持2个参数：整数N和回调函数。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetPower10</span><span class="params">(<span class="type">const</span> Napi::CallbackInfo&amp; info)</span> </span>{</span><br><span class="line">    Napi::Env env = info.<span class="built_in">Env</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.<span class="built_in">Length</span>() != <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">throw</span> Napi::TypeError::<span class="built_in">New</span>(env, <span class="string">"Wrong number of arguments"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!info[<span class="number">0</span>].<span class="built_in">IsNumber</span>() || !info[<span class="number">1</span>].<span class="built_in">IsFunction</span>())</span><br><span class="line">        <span class="keyword">throw</span> Napi::TypeError::<span class="built_in">New</span>(env, <span class="string">"Wrong arguments"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> n = info[<span class="number">0</span>].<span class="built_in">ToNumber</span>().<span class="built_in">Int32Value</span>();</span><br><span class="line">    Napi::Function callback = info[<span class="number">1</span>].<span class="built_in">As</span>&lt;Napi::Function&gt;();</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">new</span> <span class="built_in">Power10AsyncWorker</span>(callback, n))-&gt;<span class="built_in">Queue</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="三、基于Napi-AsyncWorker返回Promise"><a href="#三、基于Napi-AsyncWorker返回Promise" class="headerlink" title="三、基于Napi::AsyncWorker返回Promise"></a>三、基于Napi::AsyncWorker返回Promise</h2><p>以异步计算正整数N的20次方为例，返回Promise对象，当N小于0时，Promise设置为reject状态。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Power20AsyncWorker</span> : <span class="keyword">public</span> Napi::AsyncWorker {</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Power20AsyncWorker</span>(<span class="type">const</span> Napi::Env&amp; env, <span class="type">const</span> Napi::Promise::Deferred&amp; deferred, <span class="type">int32_t</span> n) :</span><br><span class="line">        Napi::<span class="built_in">AsyncWorker</span>(env),</span><br><span class="line">        <span class="built_in">deferred_</span>(deferred),</span><br><span class="line">        <span class="built_in">n_</span>(n) {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (n_ &lt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 小于0时返回错误</span></span><br><span class="line">            <span class="built_in">SetError</span>(<span class="string">"N must larger than 0"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        result_ = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">            <span class="comment">// 每次暂停10ms，模拟耗时操作</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">            result_ *= n_;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnOK</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        deferred_.<span class="built_in">Resolve</span>(Napi::Number::<span class="built_in">New</span>(<span class="built_in">Env</span>(), result_));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnError</span><span class="params">(<span class="type">const</span> Napi::Error&amp; e)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        deferred_.<span class="built_in">Reject</span>(e.<span class="built_in">Value</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    Napi::Promise::Deferred deferred_;</span><br><span class="line">    <span class="type">int32_t</span> n_ = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int32_t</span> result_ = <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Napi::Value <span class="title">GetPower20</span><span class="params">(<span class="type">const</span> Napi::CallbackInfo&amp; info)</span> </span>{</span><br><span class="line">    Napi::Env env = info.<span class="built_in">Env</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.<span class="built_in">Length</span>() != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> Napi::TypeError::<span class="built_in">New</span>(env, <span class="string">"Wrong number of arguments"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!info[<span class="number">0</span>].<span class="built_in">IsNumber</span>())</span><br><span class="line">        <span class="keyword">throw</span> Napi::TypeError::<span class="built_in">New</span>(env, <span class="string">"Wrong arguments"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> n = info[<span class="number">0</span>].<span class="built_in">ToNumber</span>().<span class="built_in">Int32Value</span>();</span><br><span class="line">    Napi::Function callback = info[<span class="number">1</span>].<span class="built_in">As</span>&lt;Napi::Function&gt;();</span><br><span class="line"></span><br><span class="line">    Napi::Promise::Deferred deferred = Napi::Promise::Deferred::<span class="built_in">New</span>(env);</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">new</span> <span class="built_in">Power20AsyncWorker</span>(env, deferred, n))-&gt;<span class="built_in">Queue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> deferred.<span class="built_in">Promise</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="四、基于Napi-ThreadSafeFunction的异步回调"><a href="#四、基于Napi-ThreadSafeFunction的异步回调" class="headerlink" title="四、基于Napi::ThreadSafeFunction的异步回调"></a>四、基于Napi::ThreadSafeFunction的异步回调</h2><p>前面的示例都没有启动本地子线程，而是通过Napi::AsyncWorker实现的异步调用，在本示例中我们使用<code>std::thread</code>开启子线程，在子线程中执行任务并调用回调函数返回结果。</p><p>以异步计算正整数N的30次方为例，通过回调函数返回计算结果。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetPower30</span><span class="params">(<span class="type">const</span> Napi::CallbackInfo&amp; info)</span> </span>{</span><br><span class="line">    Napi::Env env = info.<span class="built_in">Env</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.<span class="built_in">Length</span>() != <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">throw</span> Napi::TypeError::<span class="built_in">New</span>(env, <span class="string">"Wrong number of arguments"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!info[<span class="number">0</span>].<span class="built_in">IsNumber</span>() || !info[<span class="number">1</span>].<span class="built_in">IsFunction</span>())</span><br><span class="line">        <span class="keyword">throw</span> Napi::TypeError::<span class="built_in">New</span>(env, <span class="string">"Wrong arguments"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> n = info[<span class="number">0</span>].<span class="built_in">ToNumber</span>().<span class="built_in">Int32Value</span>();</span><br><span class="line">    Napi::Function callback = info[<span class="number">1</span>].<span class="built_in">As</span>&lt;Napi::Function&gt;();</span><br><span class="line"></span><br><span class="line">    std::thread* nativeThread = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Napi::ThreadSafeFunction tsfn = Napi::ThreadSafeFunction::<span class="built_in">New</span>(</span><br><span class="line">        env,</span><br><span class="line">        callback,</span><br><span class="line">        <span class="string">"Resource Name"</span>,             <span class="comment">// Name</span></span><br><span class="line">        <span class="number">0</span>,                           <span class="comment">// Unlimited queue</span></span><br><span class="line">        <span class="number">1</span>,                           <span class="comment">// Only one thread will use this initially</span></span><br><span class="line">        [nativeThread](Napi::Env) {  <span class="comment">// Finalizer used to clean threads up</span></span><br><span class="line">            <span class="keyword">if</span> (nativeThread &amp;&amp; nativeThread-&gt;<span class="built_in">joinable</span>()) {</span><br><span class="line">                nativeThread-&gt;<span class="built_in">join</span>();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">    nativeThread = <span class="keyword">new</span> std::<span class="built_in">thread</span>([n, tsfn]() {</span><br><span class="line">        <span class="keyword">struct</span> CallParam {</span><br><span class="line">            std::string error;</span><br><span class="line">            <span class="type">int32_t</span> result = <span class="number">0</span>;</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        CallParam* param = <span class="keyword">new</span> <span class="built_in">CallParam</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) {</span><br><span class="line">            param-&gt;result = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) {</span><br><span class="line">                param-&gt;result *= n;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            param-&gt;error = <span class="string">"N must larger than 0"</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> callback = [](Napi::Env env, Napi::Function jsCallback, CallParam* param) {</span><br><span class="line">            <span class="keyword">if</span> (jsCallback &amp;&amp; param) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">if</span> (param-&gt;error.<span class="built_in">empty</span>()) {</span><br><span class="line">                        jsCallback.<span class="built_in">Call</span>({env.<span class="built_in">Null</span>(), Napi::Number::<span class="built_in">New</span>(env, param-&gt;result)});</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        Napi::Error err = Napi::Error::<span class="built_in">New</span>(env, param-&gt;error);</span><br><span class="line">                        jsCallback.<span class="built_in">Call</span>({err.<span class="built_in">Value</span>(), env.<span class="built_in">Null</span>()});</span><br><span class="line">                    }</span><br><span class="line">                } <span class="built_in">catch</span> (std::exception&amp; e) {</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (defined _WIN32 || defined WIN32)</span></span><br><span class="line">                    <span class="built_in">OutputDebugStringA</span>(e.<span class="built_in">what</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (param) {</span><br><span class="line">                <span class="keyword">delete</span> param;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        napi_status status = tsfn.<span class="built_in">BlockingCall</span>(param, callback);</span><br><span class="line">        <span class="keyword">if</span> (status != napi_ok) {</span><br><span class="line">            <span class="comment">// TODO How to handle error</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        tsfn.<span class="built_in">Release</span>();</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>完整的示例代码以上传自Github：<a class="link" href="https://github.com/winsoft666/node-addon-sample">https://github.com/winsoft666/node-addon-sample<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍如何在Node-API中实现不同的类型的接口，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步调用&lt;/li&gt;
&lt;li&gt;基于Napi::AsyncWorker的异步调用，通过回调函数返回&lt;/li&gt;
&lt;li&gt;异步调用，返回Promise&lt;/li&gt;
&lt;li&gt;基于Napi::ThreadSafeFunction的异步调用，通过回调函数返回&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="④ Electron" scheme="https://jiangxueqiao.com/categories/%E2%91%A3-Electron/"/>
    
    
  </entry>
  
  <entry>
    <title>ABI兼容性</title>
    <link href="https://jiangxueqiao.com/post/529732738.html"/>
    <id>https://jiangxueqiao.com/post/529732738.html</id>
    <published>2024-03-01T05:29:04.000Z</published>
    <updated>2024-03-01T07:30:43.195Z</updated>
    
    <content type="html"><![CDATA[<p>ABI是 Application Binary Interface 的缩写，当我们以二进制形式（非源码形式）发布我们的动态库时，就需要关心ABI兼容（也称二进制兼容）。</p><p>对于静态库，更新静态库始终都需要该库的使用方重新编译，因此不存在ABI兼容的说法。</p><span id="more"></span><h1 id="一、什么是ABI兼容"><a href="#一、什么是ABI兼容" class="headerlink" title="一、什么是ABI兼容"></a>一、什么是ABI兼容</h1><p>假设我们开发了某个动态库（名为something），以动态库的形式提供：something.h、something.lib、something.dll。</p><p>有人使用该动态库开发了程序w（w可以是可执行程序，也可以是库），即程序w链接了动态库something，并将程序w打包交付给终端用户，打包文件包含：w.exe、something.dll。</p><p>something库是否具有ABI兼容性决定了在更新something.dll时，是否需要重新编译w.exe？</p><p>如果不需要重新编译w.exe，则something库是二进制兼容的，否则就不是的。</p><blockquote><p>Microsoft C++（MSVC）编译器工具集在 Visual Studio 2015 之前未实现ABI兼容，但在 Visual Studio 2015（含）之后实现了ABI兼容。</p><p>详见之前文章：<a href="/post/3437796039.html" title="MSVC版本的二进制兼容性">MSVC版本的二进制兼容性</a></p></blockquote><h1 id="二、与ABI有关的知识"><a href="#二、与ABI有关的知识" class="headerlink" title="二、与ABI有关的知识"></a>二、与ABI有关的知识</h1><p>在理解哪些行为是否会破坏ABI兼容性之前，我们需要预先了解一些C++基础知识。</p><h2 id="2-1-类如何访问成员变量"><a href="#2-1-类如何访问成员变量" class="headerlink" title="2.1 类如何访问成员变量"></a>2.1 类如何访问成员变量</h2><p>在C++中，struct 和 class 是通过偏移量来访问成员变量的，如果改变了成员变量的顺序，偏移量也会相应改变。</p><h2 id="2-2-虚函数表"><a href="#2-2-虚函数表" class="headerlink" title="2.2 虚函数表"></a>2.2 虚函数表</h2><p>虚函数是通过虚函数表来管理和访问的，改变虚函数顺序、新增/删除虚函数都会改变虚函数表，可以参考之前有关虚函数的文章：<a href="/post/3162890435.html" title="深入理解C++虚函数">深入理解C++虚函数</a></p><h2 id="2-3-Name-Mangling"><a href="#2-3-Name-Mangling" class="headerlink" title="2.3 Name Mangling"></a>2.3 Name Mangling</h2><p>C++编译器会把函数的名字、参数等信息（或者叫函数签名）编码成一个唯一的字符串，用作链接符号，这样就能在编译期完成检查，从而避免运行时报错，这种行为称作<code>Name Mangling</code>，例如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> wikipedia </span><br><span class="line">{</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">article</span> {</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function">std::string <span class="title">format</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>format 函数经过 Name Mangling 之后变成了：_ZN9wikipedia7article6formatEv</p><blockquote><p>Name Mangling使用的算法是可逆的，<a class="link" href="http://demangler.com/">http://demangler.com/<i class="fas fa-external-link-alt"></i></a>网站提供了通过新函数名逆向推演出原有函数名的功能。</p></blockquote><h2 id="2-4-类如何访问成员函数"><a href="#2-4-类如何访问成员函数" class="headerlink" title="2.4 类如何访问成员函数"></a>2.4 类如何访问成员函数</h2><p>C++编译器在编译成员函数时会根据它所在的命名空间、所属类、以及参数等信息，通过Name Mangling生成一个新的函数名。</p><p><strong>类的成员函数最终被编译成与对象无关的全局函数</strong>，为了使该全局函数可以访问类的其他成员函数和变量，编译器在编译成员函数时会额外添加一个参数，把当前对象的指针传递进去，通过指针来访问成员变量/成员函数。</p><h2 id="2-5-头文件的作用"><a href="#2-5-头文件的作用" class="headerlink" title="2.5 头文件的作用"></a>2.5 头文件的作用</h2><p>在C/C++中，动态链接库通常会附带头文件，这个头文件可以理解成动态库的“使用说明书”，库的使用者会按照头文件使用该库，编译器会根据该头文件生成二进制代码，然后在运行的时候通过装载器(loader)把可执行文件和动态库绑到一起。</p><h1 id="3-破坏ABI兼容性的行为"><a href="#3-破坏ABI兼容性的行为" class="headerlink" title="3. 破坏ABI兼容性的行为"></a>3. 破坏ABI兼容性的行为</h1><p>如何判断一个改动是不是二进制兼容，主要看老版的头文件能否与新版本的动态库的实际使用方法兼容。因为新的库必然有新的头文件，但是现有的二进制可执行文件还是按旧的头文件来调用动态库。</p><p>总结起来，ABI不兼容主要是因为：</p><ul><li>sizeof(class)大小改变</li><li>数据成员偏移量发生改变</li><li>虚函数表发生改变</li><li>Name Mangling名发生改变</li></ul><p>下面列举了会破坏ABI兼容性的操作。</p><h2 id="3-1-添加或删除非静态成员变量"><a href="#3-1-添加或删除非静态成员变量" class="headerlink" title="3.1 添加或删除非静态成员变量"></a>3.1 添加或删除非静态成员变量</h2><p>因为sizeof(class)大小发生改变，如之前占用8个字节，新增一个成员变量后占用12字节，但外部代码new class时仍然只分配了8字节，所以会出问题。</p><p>但是，如果动态库提供了创建对象的方法，始终在动态库内部创建对象，则没有该问题，如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EXPORT_API</span> Koi {</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">EXPORT_API Koi* <span class="title">GetKoi</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>也可以通过Impl设计模式来解决该问题。</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EXPORT_API</span> Koi {</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Impl</span>;</span><br><span class="line">    Impl* impl_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态库内部</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Koi</span>::Impl {</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a_;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-2-改变非静态成员变量的顺序"><a href="#3-2-改变非静态成员变量的顺序" class="headerlink" title="3.2 改变非静态成员变量的顺序"></a>3.2 改变非静态成员变量的顺序</h2><p>改变了非静态成员变量的顺序就改变了变量的内存偏移，会导致变量读写出错，因此破坏了ABI兼容性。</p><p>这个问题也可通过上面3.1节的方式来解决。</p><h2 id="3-3-修改函数的名称"><a href="#3-3-修改函数的名称" class="headerlink" title="3.3 修改函数的名称"></a>3.3 修改函数的名称</h2><p>这个导致会Name Mangling名发生改变，因此ABI不兼容。</p><h2 id="3-4-添加默认的模板类型参数"><a href="#3-4-添加默认的模板类型参数" class="headerlink" title="3.4 添加默认的模板类型参数"></a>3.4 添加默认的模板类型参数</h2><p>如<code>Foo&lt;T&gt;</code> 改为 <code>Foo&lt;T, Alloc=alloc&lt;T&gt; &gt;</code>，这个导致会Name Mangling名发生改变，因此不ABI兼容。</p><h2 id="3-5-为函数添加默认参数"><a href="#3-5-为函数添加默认参数" class="headerlink" title="3.5 为函数添加默认参数"></a>3.5 为函数添加默认参数</h2><p>现有的动态库使用方（可执行程序或另外一个动态库）是基于老的头文件进行编译的，无法传递该默认参数给新的动态库，因此不ABI兼容。</p><h2 id="3-6-修改函数参数传递方式"><a href="#3-6-修改函数参数传递方式" class="headerlink" title="3.6 修改函数参数传递方式"></a>3.6 修改函数参数传递方式</h2><p>如__cdecl修改为__stdcall。函数参数的传递方式有多种，如压栈方式、寄存器方式。如果选择压栈方式，在维持栈平衡上有分调用者维持、函数自身维持，在参数的传递顺序也有多种，从左到右，还是从右到左。</p><p>具体介绍可以参考之前的文章：<a href="/post/4168021185.html" title="从汇编的角度分析函数调用过程">从汇编的角度分析函数调用过程</a></p><h2 id="3-7-添加虚函数"><a href="#3-7-添加虚函数" class="headerlink" title="3.7 添加虚函数"></a>3.7 添加虚函数</h2><p>添加虚函数会导致虚函数表发生了变化，即便是在最尾端添加虚函数也可能不行，因为当前类可能已经被其他类继承了。</p><h2 id="3-8-不同系统的动态库"><a href="#3-8-不同系统的动态库" class="headerlink" title="3.8 不同系统的动态库"></a>3.8 不同系统的动态库</h2><p>不同操作系统所支持的动态库的二进制格式不一样，因此不同系统的动态库肯定是无法兼容的。</p><h1 id="四、不破坏ABI兼容性的行为"><a href="#四、不破坏ABI兼容性的行为" class="headerlink" title="四、不破坏ABI兼容性的行为"></a>四、不破坏ABI兼容性的行为</h1><p>下面的操作不会破坏ABI兼容性：</p><ul><li>添加新的类</li><li>修改成员变量的名称</li><li>更改非虚成员函数的顺序</li></ul><h1 id="五、Windows-COM实现ABI兼容的方式"><a href="#五、Windows-COM实现ABI兼容的方式" class="headerlink" title="五、Windows COM实现ABI兼容的方式"></a>五、Windows COM实现ABI兼容的方式</h1><p>很多时候，由于功能更新，对接口的修改不可避免的，既然接口已经发生大改动，那显然很难满足ABI兼容性，此时可以通过版本管理的方式来保证ABI兼容性，如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> API <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Interface* <span class="title">CreateInterface</span><span class="params">(<span class="type">int</span> version)</span></span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Interface2</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> API <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message, <span class="type">int</span> messageSize)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Interface2* <span class="title">CreateInterface</span><span class="params">(<span class="type">int</span> version)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>上面方式也是COM实现ABI兼容性的方式，需要在动态库中仍要保留老的接口和实现，以实现向前兼容，这种方式有个弊端就是会存在很多版本的接口，如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IDirect3D7, IDirect3D8, IDirect3D9, ID3D10*, ID3D11*</span><br><span class="line">IXMLDOMDocument, IXMLDOMDocument2, IXMLDOMDocument3</span><br></pre></td></tr></tbody></table></figure><blockquote><p>本文参考了：<br><a class="link" href="https://www.cppblog.com/Solstice/archive/2011/03/09/141401.html">C++ 工程实践(4)：二进制兼容性<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;ABI是 Application Binary Interface 的缩写，当我们以二进制形式（非源码形式）发布我们的动态库时，就需要关心ABI兼容（也称二进制兼容）。&lt;/p&gt;
&lt;p&gt;对于静态库，更新静态库始终都需要该库的使用方重新编译，因此不存在ABI兼容的说法。&lt;/p&gt;</summary>
    
    
    
    <category term="② C++" scheme="https://jiangxueqiao.com/categories/%E2%91%A1-C/"/>
    
    
    <category term="ABI" scheme="https://jiangxueqiao.com/tags/ABI/"/>
    
  </entry>
  
  <entry>
    <title>Node插件开发(1)-快速入门</title>
    <link href="https://jiangxueqiao.com/post/819381949.html"/>
    <id>https://jiangxueqiao.com/post/819381949.html</id>
    <published>2024-02-27T15:54:54.000Z</published>
    <updated>2024-03-02T05:25:50.050Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Electron开发客户端时，如果现有Node模块所提供的功能无法满足需求，我们可以使用C++开发自定义的Node模块，也称插件（addon）。</p><p>Node.js插件的扩展名为<code>.node</code>，是二进制文件，其本质上是动态链接库重命名而来，在Windows平台是.dll文件，Linux/Unix平台是.so文件。</p><span id="more"></span><h1 id="1-选择Node-API"><a href="#1-选择Node-API" class="headerlink" title="1. 选择Node-API"></a>1. 选择Node-API</h1><p>开发Node.js扩展的方式有三种：</p><ul><li>Node-API（以前叫N-API）</li><li>nan</li><li>直接使用v8、libuv等库进行开发</li></ul><p>除非是为了使用 Node-API 未公开的接口，否则建议使用 Node-API 进行开发。</p><p>因为Node-API是二进制（ABI）兼容的，它将底层JavaScript引擎与上层插件隔离开了，JavaScripty引擎的修改不会影响我们开发的上层插件，我们基于某个版本编译的插件在不需要重新编译的情况下，就可以运行在其他版本的Node.js中。</p><h1 id="2-安装编译环境"><a href="#2-安装编译环境" class="headerlink" title="2. 安装编译环境"></a>2. 安装编译环境</h1><p>Node插件使用C++开发，因此在不同的系统上采用不同的编译环境。<br>在Linux环境通常使用GCC和LLVM；</p><p>Mac环境通常使用Xcode；</p><p>Windows环境通常使用Visual Studio，如果不想安装完整的Visual Studio，可以使用如下命令仅安装必要的工具链：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global windows-build-tools </span><br></pre></td></tr></tbody></table></figure><p>Node插件通常使用node-gyp进行编译，node-gyp基于Google的gyp-next构建系统，node-gyp已经与npm捆绑在一起，但我们在使用node-gyp之前还需要先安装Python。</p><p>至此Node插件开发的环境已经搭建完成。</p><h1 id="3-搭建工程"><a href="#3-搭建工程" class="headerlink" title="3.搭建工程"></a>3.搭建工程</h1><blockquote><p><strong>本文以在Windows下开发Node插件为例，其他系统环境在编译选项方面略有不同</strong></p></blockquote><h2 id="3-1-package-json"><a href="#3-1-package-json" class="headerlink" title="3.1 package.json"></a>3.1 package.json</h2><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"node-addson-sample"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"version"</span><span class="punctuation">:</span> <span class="string">"1.0.0"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"private"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"A sample node addson sample"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"dependencies"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"bindings"</span><span class="punctuation">:</span> <span class="string">"^1.5.0"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"node-addon-api"</span><span class="punctuation">:</span> <span class="string">"^7.1.0"</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"scripts"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"build-debug"</span><span class="punctuation">:</span> <span class="string">"node-gyp --debug --arch=x64 configure rebuild"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"build-release"</span><span class="punctuation">:</span> <span class="string">"node-gyp --release --arch=x64 configure rebuild"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"test"</span><span class="punctuation">:</span> <span class="string">"node test.js"</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>使用<code>npm install</code>安装依赖项。</p></blockquote><p>各个依赖项的作用如下：</p><ul><li><p><code>node-addon-api</code>用于提供了Node-API相关的头文件；</p></li><li><p><code>bindings</code>用于帮助插件开发者快速导入编译后的.node插件，方便调试，这个依赖是非必须；</p></li></ul><p><code>build-debug</code>和<code>build-release</code>脚本分别用于编译Debug和Release版本的插件；</p><p><code>test</code>脚本用于执行测试用例；</p><h3 id="32位插件"><a href="#32位插件" class="headerlink" title="32位插件"></a>32位插件</h3><p>指定arch为ia32（<code>--arch=ia32</code>）就可以编译32位版本的Node插件。</p><p>需要注意：64位版本Node.js只能加载64位的Node插件，32位版本的Node.js也只能加载32位的Node插件，否则会报错：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: \\?\D:\node-addon-sample\build\Debug\node-addon-sample.node is not a valid Win32 application.</span><br></pre></td></tr></tbody></table></figure><h2 id="3-2-编译脚本"><a href="#3-2-编译脚本" class="headerlink" title="3.2 编译脚本"></a>3.2 编译脚本</h2><p>新建<code>binding.gyp</code>文件，内容如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"targets"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="string">"target_name"</span>: <span class="string">"node-addson-sample"</span>, # ***.<span class="property">node</span></span><br><span class="line">      <span class="string">"cflags!"</span>: [ <span class="string">"-fno-exceptions"</span> ],</span><br><span class="line">      <span class="string">"cflags_cc!"</span>: [ <span class="string">"-fno-exceptions"</span> ],</span><br><span class="line">      # 指定需要编译的源文件</span><br><span class="line">      <span class="string">"sources"</span>: [ <span class="string">"main.cpp"</span> ],</span><br><span class="line">      <span class="string">"include_dirs"</span>: [</span><br><span class="line">        <span class="string">"&lt;!@(node -p \"require('node-addon-api').include\")"</span></span><br><span class="line">      ],</span><br><span class="line">      # 预编译宏</span><br><span class="line">      <span class="string">"defines"</span>: [ </span><br><span class="line">        <span class="string">"NAPI_CPP_EXCEPTIONS"</span>, # 在<span class="title class_">Node</span>-<span class="variable constant_">API</span>中启用C++异常</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"conditions"</span>: [</span><br><span class="line">        [</span><br><span class="line">          # <span class="title class_">Windows</span>平台编译选项</span><br><span class="line">          <span class="string">"OS == 'win'"</span>, {</span><br><span class="line">            <span class="string">"configurations"</span>: {</span><br><span class="line">              # <span class="title class_">Debug</span>编译选项</span><br><span class="line">              <span class="string">"Debug"</span>: {</span><br><span class="line">                # 预编译宏</span><br><span class="line">                <span class="string">"defines"</span>: [ <span class="string">"DEBUG"</span>, <span class="string">"_DEBUG"</span> ],</span><br><span class="line">                <span class="string">"cflags"</span>: [ <span class="string">"-g"</span>, <span class="string">"-O0"</span> ],</span><br><span class="line">                <span class="string">"conditions"</span>: [</span><br><span class="line">                  [</span><br><span class="line">                    <span class="string">"target_arch=='x64'"</span>, {</span><br><span class="line">                      <span class="string">"msvs_configuration_platform"</span>: <span class="string">"x64"</span>,</span><br><span class="line">                    }</span><br><span class="line">                  ],</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">"msvs_settings"</span>: {</span><br><span class="line">                  <span class="string">"VCCLCompilerTool"</span>: {</span><br><span class="line">                    <span class="string">"RuntimeLibrary"</span>: <span class="number">1</span>, # /<span class="title class_">MTd</span></span><br><span class="line">                    <span class="string">"Optimization"</span>: <span class="number">0</span>, # /<span class="title class_">Od</span>, no optimization</span><br><span class="line">                    <span class="string">"MinimalRebuild"</span>: <span class="string">"false"</span>,</span><br><span class="line">                    <span class="string">"OmitFramePointers"</span>: <span class="string">"false"</span>,</span><br><span class="line">                    <span class="string">"BasicRuntimeChecks"</span>: <span class="number">3</span>, # /<span class="title class_">RTC1</span></span><br><span class="line">                    <span class="string">"AdditionalOptions"</span>: [</span><br><span class="line">                      <span class="string">"/EHsc"</span></span><br><span class="line">                    ],</span><br><span class="line">                  },</span><br><span class="line">                  <span class="string">"VCLinkerTool"</span>: {</span><br><span class="line">                    <span class="string">"LinkIncremental"</span>: <span class="number">2</span>, # <span class="title class_">Enable</span> incremental linking</span><br><span class="line">                    # 附加依赖库</span><br><span class="line">                    <span class="string">"AdditionalDependencies"</span>: [</span><br><span class="line">                    ],</span><br><span class="line">                  },</span><br><span class="line">                },</span><br><span class="line">                # 附加包含目录</span><br><span class="line">                <span class="string">"include_dirs"</span>: [</span><br><span class="line">                ],</span><br><span class="line">              },</span><br><span class="line">              # <span class="title class_">Debug</span>编译选项</span><br><span class="line">              <span class="string">"Release"</span>: {</span><br><span class="line">                # 预编译宏</span><br><span class="line">                <span class="string">"defines"</span>: [ <span class="string">"NDEBUG"</span> ],</span><br><span class="line">                <span class="string">"msvs_settings"</span>: {</span><br><span class="line">                  <span class="string">"VCCLCompilerTool"</span>: {</span><br><span class="line">                    <span class="string">"RuntimeLibrary"</span>: <span class="number">0</span>, # /<span class="variable constant_">MT</span></span><br><span class="line">                    <span class="string">"Optimization"</span>: <span class="number">3</span>, # /<span class="title class_">Ox</span>, full optimization</span><br><span class="line">                    <span class="string">"FavorSizeOrSpeed"</span>: <span class="number">1</span>, # /<span class="title class_">Ot</span>, favour speed over size</span><br><span class="line">                    <span class="string">"InlineFunctionExpansion"</span>: <span class="number">2</span>, # /<span class="title class_">Ob2</span>, inline anything eligible</span><br><span class="line">                    <span class="string">"WholeProgramOptimization"</span>: <span class="string">"false"</span>, # <span class="title class_">Dsiable</span> /<span class="variable constant_">GL</span>, whole program optimization, needed <span class="keyword">for</span> <span class="variable constant_">LTCG</span></span><br><span class="line">                    <span class="string">"OmitFramePointers"</span>: <span class="string">"true"</span>,</span><br><span class="line">                    <span class="string">"EnableFunctionLevelLinking"</span>: <span class="string">"true"</span>,</span><br><span class="line">                    <span class="string">"EnableIntrinsicFunctions"</span>: <span class="string">"true"</span>,</span><br><span class="line">                    <span class="string">"RuntimeTypeInfo"</span>: <span class="string">"false"</span>,</span><br><span class="line">                    <span class="string">"ExceptionHandling"</span>: <span class="string">"2"</span>, # /<span class="title class_">EHsc</span></span><br><span class="line">                    <span class="string">"AdditionalOptions"</span>: [</span><br><span class="line">                      <span class="string">"/MP"</span>, # compile across multiple <span class="title class_">CPUs</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="string">"DebugInformationFormat"</span>: <span class="number">3</span>,</span><br><span class="line">                    <span class="string">"AdditionalOptions"</span>: [</span><br><span class="line">                    ],</span><br><span class="line">                  },</span><br><span class="line">                  <span class="string">"VCLibrarianTool"</span>: {</span><br><span class="line">                    <span class="string">"AdditionalOptions"</span>: [</span><br><span class="line">                      <span class="string">"/LTCG"</span>, # link time code generation</span><br><span class="line">                    ],</span><br><span class="line">                  },</span><br><span class="line">                  <span class="string">"VCLinkerTool"</span>: {</span><br><span class="line">                    <span class="string">"LinkTimeCodeGeneration"</span>: <span class="number">1</span>, # link-time code generation</span><br><span class="line">                    <span class="string">"OptimizeReferences"</span>: <span class="number">2</span>, # /<span class="attr">OPT</span>:<span class="variable constant_">REF</span></span><br><span class="line">                    <span class="string">"EnableCOMDATFolding"</span>: <span class="number">2</span>, # /<span class="attr">OPT</span>:<span class="variable constant_">ICF</span></span><br><span class="line">                    <span class="string">"LinkIncremental"</span>: <span class="number">1</span>, # disable incremental linking</span><br><span class="line">                    # 附加依赖库</span><br><span class="line">                    <span class="string">"AdditionalDependencies"</span>: [</span><br><span class="line">                    ],</span><br><span class="line">                  },</span><br><span class="line">                },</span><br><span class="line">                # 附加包含目录</span><br><span class="line">                <span class="string">"include_dirs"</span>: [</span><br><span class="line">                ],</span><br><span class="line">              }</span><br><span class="line">            }</span><br><span class="line">          },</span><br><span class="line">        ]</span><br><span class="line">      ]</span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>binding.gyp中的编译选项大多与特定平台的编译器有关，具体可以查阅相关编译器文档，如Windows平台可以查询<a class="link" href="https://learn.microsoft.com/en-us/cpp/build/reference/compiler-options-listed-by-category?view=msvc-170">MSVC文档<i class="fas fa-external-link-alt"></i></a>。</p><p>node-gyp官方提供了一些示例，我们可以从这些示例中获取不少灵感：</p><p><a class="link" href="https://github.com/nodejs/node-gyp/blob/main/docs/binding.gyp-files-in-the-wild.md">binding.gyp-files-in-the-wild<i class="fas fa-external-link-alt"></i></a></p><p>GYP官方文档：</p><p><a class="link" href="https://gyp.gsrc.io/docs/UserDocumentation.md">https://gyp.gsrc.io/docs/UserDocumentation.md<i class="fas fa-external-link-alt"></i></a></p><h2 id="3-3-第一个API"><a href="#3-3-第一个API" class="headerlink" title="3.3 第一个API"></a>3.3 第一个API</h2><p>现在新建<code>main.cpp</code>，在该文件中定义我们的第一个API，API名为<code>Add</code>，支持传入2个整数参数，返回整数相加的和。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;napi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步调用</span></span><br><span class="line"><span class="comment">// 计算两个整数相加结果并返回</span></span><br><span class="line"><span class="function">Napi::Number <span class="title">Add</span><span class="params">(<span class="type">const</span> Napi::CallbackInfo&amp; info)</span> </span>{</span><br><span class="line">    Napi::Env env = info.<span class="built_in">Env</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.<span class="built_in">Length</span>() != <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">throw</span> Napi::TypeError::<span class="built_in">New</span>(env, <span class="string">"Wrong number of arguments"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!info[<span class="number">0</span>].<span class="built_in">IsNumber</span>() || !info[<span class="number">1</span>].<span class="built_in">IsNumber</span>())</span><br><span class="line">        <span class="keyword">throw</span> Napi::TypeError::<span class="built_in">New</span>(env, <span class="string">"Wrong arguments"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ret = info[<span class="number">0</span>].<span class="built_in">ToNumber</span>().<span class="built_in">Int32Value</span>() + info[<span class="number">1</span>].<span class="built_in">ToNumber</span>().<span class="built_in">Int32Value</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Napi::Number::<span class="built_in">New</span>(env, ret);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在定义完API之后，还需要将API导出，在文件末尾添加如下代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出函数</span></span><br><span class="line"><span class="function">Napi::Object <span class="title">Init</span><span class="params">(Napi::Env env, Napi::Object exports)</span> </span>{</span><br><span class="line">    exports.<span class="built_in">Set</span>(Napi::String::<span class="built_in">New</span>(env, <span class="string">"Add"</span>), Napi::Function::<span class="built_in">New</span>(env, Add));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exports;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">NODE_API_MODULE</span>(addon, Init)</span><br></pre></td></tr></tbody></table></figure><p>如果忘记导出API，加载Node插件时会报错：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Module did not self-register: '\\?\D:\node-addson-sample\build\Debug\node-addson-sample.node'.</span><br></pre></td></tr></tbody></table></figure><p>现在执行<code>npm run build-debug</code>编译Debug版本插件，编译生成的node插件路径为<code>build\Debug\node-addson-sample.node</code>。</p><h2 id="3-4-测试用例"><a href="#3-4-测试用例" class="headerlink" title="3.4 测试用例"></a>3.4 测试用例</h2><p>新建<code>test.js</code>，测试代码如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sample = <span class="built_in">require</span>(<span class="string">"bindings"</span>)(<span class="string">"node-addson-sample.node"</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sample.<span class="title class_">Add</span>(<span class="number">100</span>, <span class="number">200</span>)); <span class="comment">// 输出300</span></span><br></pre></td></tr></tbody></table></figure><p>使用<code>bindings</code>模块可以不用考虑插件的具体位置，该模块会自动帮我们在项目目录下遍历查找。</p><h1 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4. 数据类型"></a>4. 数据类型</h1><p>在<code>napi.h</code>头文件中声明很多继承自<code>Napi::Value</code>的子类，这些类分别对应JavaScript中的数据类型，如：</p><ul><li>Napi::Boolean -&gt; Boolean</li><li>Napi::Number -&gt; Number</li><li>Napi::String -&gt; String</li><li>Napi::Function -&gt; Function</li><li>Napi::Symbol -&gt; Symbol</li><li>Napi::Array -&gt; Array</li><li>Napi::Object -&gt; Object</li></ul><p>Node-Api还定义Promise、Date、Buffer等数据类型。</p><h2 id="4-1-Null和Undefined"><a href="#4-1-Null和Undefined" class="headerlink" title="4.1 Null和Undefined"></a>4.1 Null和Undefined</h2><p>Null和Undefined比较特殊，没有定义专门的类，需要使用<code>Env</code>类的成员函数返回。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env.<span class="built_in">Null</span>()</span><br><span class="line"></span><br><span class="line">env.<span class="built_in">Undefined</span>()</span><br></pre></td></tr></tbody></table></figure><h2 id="4-2-创建对象"><a href="#4-2-创建对象" class="headerlink" title="4.2 创建对象"></a>4.2 创建对象</h2><p>可以通过下面两种方式创建指定类型的对象，以创建Boolean类型为例：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Napi::Boolean::<span class="built_in">New</span>(env, <span class="literal">true</span>)</span><br><span class="line">Napi::Value::<span class="built_in">From</span>(env, <span class="literal">false</span>)</span><br></pre></td></tr></tbody></table></figure><p>以创建一个对象数组为例介绍对象和数组的使用方法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Napi::Array result = Napi::Array::<span class="built_in">New</span>(env);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</span><br><span class="line">    Napi::Object obj = Napi::Object::<span class="built_in">New</span>(env);</span><br><span class="line">    obj.<span class="built_in">Set</span>(Napi::String::<span class="built_in">New</span>(env, <span class="string">"filePath"</span>), Napi::String::<span class="built_in">New</span>(env, <span class="string">"/root/"</span> + std::<span class="built_in">to_string</span>(i) + <span class="string">".txt"</span>));</span><br><span class="line">    obj.<span class="built_in">Set</span>(Napi::String::<span class="built_in">New</span>(env, <span class="string">"fileSize"</span>), Napi::Number::<span class="built_in">New</span>(env, i * <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    result.<span class="built_in">Set</span>(Napi::Number::<span class="built_in">New</span>(env, i), obj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-3-类型校验"><a href="#4-3-类型校验" class="headerlink" title="4.3 类型校验"></a>4.3 类型校验</h2><p><code>Napi::Value</code>提供了若干方法用于判断当前对象是否为指定类型，如：</p><ul><li>IsUndefined</li><li>IsNull</li><li>IsBoolean</li><li>IsNumber</li><li>IsString</li><li>IsSymbol</li><li>IsArray</li><li>IsObject</li><li>IsFunction</li><li>IsPromise</li><li>IsBuffer</li></ul><h1 id="5-异常"><a href="#5-异常" class="headerlink" title="5. 异常"></a>5. 异常</h1><p>可以在编译脚本<code>binding.gyp</code>中通过预编译宏指定是否启用C++异常：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAPI_CPP_EXCEPTIONS</span><br><span class="line"></span><br><span class="line">NAPI_DISABLE_CPP_EXCEPTIONS</span><br></pre></td></tr></tbody></table></figure><p>如果启用C++异常，则<code>Napi::Error</code>会继承自std::exception。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Error</span> : <span class="keyword">public</span> ObjectReference</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NAPI_CPP_EXCEPTIONS</span></span><br><span class="line">    ,</span><br><span class="line">              <span class="keyword">public</span> std::exception</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// NAPI_CPP_EXCEPTIONS</span></span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>在启动C++异常的情况下，从Node插件抛出异常的方式如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> Napi::TypeError::<span class="built_in">New</span>(env, <span class="string">"Wrong number of arguments"</span>);</span><br></pre></td></tr></tbody></table></figure><p>当前函数throw语句后面的流程将会中断执行。</p><p>TypeError继承自Error，通常用于表示与类型错误相关的异常。类似的错误类型还有<code>RangeError</code>等，也可以直接抛出<code>Error</code>类型的错误：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> Napi::Error::<span class="built_in">New</span>(env, <span class="string">"Wrong number of arguments"</span>);</span><br></pre></td></tr></tbody></table></figure><p>在没有启动C++异常的情况下，从Node插件抛出异常的方式如下，抛出异常后需要使用return语句终止下面流程的执行：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Napi::TypeError::<span class="built_in">New</span>(env, <span class="string">"Wrong number of arguments"</span>).<span class="built_in">ThrowAsJavaScriptException</span>();</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Node-API官方文档：<a class="link" href="https://github.com/nodejs/node-addon-api/blob/main/doc/README.md">node-addon-api doc<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用Electron开发客户端时，如果现有Node模块所提供的功能无法满足需求，我们可以使用C++开发自定义的Node模块，也称插件（addon）。&lt;/p&gt;
&lt;p&gt;Node.js插件的扩展名为&lt;code&gt;.node&lt;/code&gt;，是二进制文件，其本质上是动态链接库重命名而来，在Windows平台是.dll文件，Linux/Unix平台是.so文件。&lt;/p&gt;</summary>
    
    
    
    <category term="④ Electron" scheme="https://jiangxueqiao.com/categories/%E2%91%A3-Electron/"/>
    
    
  </entry>
  
  <entry>
    <title>产品级的Electron项目模板</title>
    <link href="https://jiangxueqiao.com/post/946276004.html"/>
    <id>https://jiangxueqiao.com/post/946276004.html</id>
    <published>2024-02-25T05:53:19.000Z</published>
    <updated>2024-02-25T05:38:45.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最初选择使用Electron来开发客户端产品，主要是看重了Web开发的高效率，但进入到实际开发流程很多问题就都暴露出来了。</p><p>和开发人员有关的问题主要集中在Web开发人员缺少对客户端的认识，系统编程方面的知识就更不用提了。</p><p>Web开发大多喜欢使用模板搭建项目，大多数开发人员离开模板寸步难行，在模板选择方面也遇到了一些问题，有的模板项目（如Electron-vite）功能很强大，但项目过于复杂，甚至远远超过了我们需要开发的项目本身，这样一旦遇到问题，团队将很难上手进行修改，而有的模板项目又过于简单，使用的技术也比较老了，属于Demo类型，不适合用在产品开发中。</p><p>基于上述问题，我着手开发了一个基于Vue3+Vite的Electron模板项目，在开发这个模板时，我一直遵循稳定、易于维护的初衷。而且在Web开发方面，我属于新手级别，因此我相信这个项目大多数人都是可以上手的。</p><p>项目地址：<br><a class="link" href="https://github.com/winsoft666/electron-vue3-template">https://github.com/winsoft666/electron-vue3-template<i class="fas fa-external-link-alt"></i></a></p><span id="more"></span><h1 id="1-项目介绍"><a href="#1-项目介绍" class="headerlink" title="1. 项目介绍"></a>1. 项目介绍</h1><p>基于<strong>Vue3</strong> + <strong>Electron</strong> + <strong>TypeScript</strong>的客户端程序模板，使用<strong>Vite</strong>和<strong>Electron Forge</strong>构建和打包。</p><p>真正做到开箱即用，面向跨平台客户端设计，产品级的项目模板。</p><h2 id="1-1-特性"><a href="#1-1-特性" class="headerlink" title="1.1 特性"></a>1.1 特性</h2><ul><li>使用<a class="link" href="https://vitejs.dev/">ViteJS<i class="fas fa-external-link-alt"></i></a>构建和驱动前端页面，支持热加载（HMR），使开发和调试变得更加高效 ⚡</li><li>支持Vue3多页面，提供页面创建指令，适合客户端开发场景 💖</li><li>支持Electron窗口创建指令，并且可隔离不同窗口的IPC事件 💖</li><li>封装简化了IPC的调用方式，并提供了IPC函数快速创建指令，主进程与渲染进程的相互调用从未如此简单 👍</li><li>主进程和渲染进程支持热加载 ⚡</li><li>精选依赖包，提升项目稳定性</li><li>代码简洁，易掌控，可定制性强</li><li>日志文件，主进程和渲染进程可以直接写文件日志</li><li>配置文件</li><li>主进程和渲染进程均支持axios HTTP请求</li><li>文件下载（含哈希校验、进度反馈），渲染进程可直接异步调用 👍</li><li>功能完善的无边框窗口</li><li>托盘图标和右键菜单，窗口关闭时程序最小化到托盘</li><li>客户端程序单实例</li><li>基于ESLint的代码规范和自动格式化</li><li>使用Electron官方推荐的<a class="link" href="https://www.electronforge.io/">Electron Forge<i class="fas fa-external-link-alt"></i></a>进行客户端构建和打包</li><li>支持NSIS安装包 😎</li><li>……</li></ul><h2 id="1-2-快速开始-🌈"><a href="#1-2-快速开始-🌈" class="headerlink" title="1.2 快速开始 🌈"></a>1.2 快速开始 🌈</h2><p>点击右上角绿色的 <strong>Use this template</strong> 按钮，使用该模板创建一个新的仓库并克隆到本地。</p><p><strong>或者..</strong></p><p>直接克隆该项目: <code>git clone https://github.com/winsoft666/electron-vue3-template.git</code></p><h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><p>推荐使用<code>Visual Studio Code</code>进行项目开发，并安装如下插件：</p><ul><li>ESLint</li><li>Vue Language Features (Volar)</li></ul><h3 id="安装依赖-⏬"><a href="#安装依赖-⏬" class="headerlink" title="安装依赖 ⏬"></a>安装依赖 ⏬</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></tbody></table></figure><h3 id="开发-⚒️"><a href="#开发-⚒️" class="headerlink" title="开发 ⚒️"></a>开发 ⚒️</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run dev</span><br></pre></td></tr></tbody></table></figure><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yarn run dev <span class="comment"># 启动应用并支持热加载</span></span><br><span class="line">yarn run build <span class="comment"># 构建应用，可发布的包位于"out\make"目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">yarn run build:win32 <span class="comment"># 构建Windows平台 32位应用</span></span><br><span class="line">yarn run build:win64 <span class="comment"># 构建Windows平台 64位应用</span></span><br><span class="line">yarn run build:mac <span class="comment"># 构建macOS平台应用</span></span><br><span class="line">yarn run build:linux <span class="comment"># 构建Linux平台应用</span></span><br><span class="line"></span><br><span class="line">yarn run new:page  <span class="comment"># 创建新的Vue页面</span></span><br><span class="line">yarn run new:window <span class="comment"># 创建新的Electron窗口</span></span><br></pre></td></tr></tbody></table></figure><p>更多的可选配置项可以参考 <a class="link" href="https://www.electronforge.io/cli">Electron Forge CLI docs<i class="fas fa-external-link-alt"></i></a>。</p><h3 id="NSIS安装包-🪟"><a href="#NSIS安装包-🪟" class="headerlink" title="NSIS安装包 🪟"></a>NSIS安装包 🪟</h3><p>需要先手动下载和安装NSIS：<br><a class="link" href="https://nsis.sourceforge.io/Download">https://nsis.sourceforge.io/Download<i class="fas fa-external-link-alt"></i></a></p><p>使用如下命令构建Windows平台 32位应用（如需构建64位应用，则需要手动修改<code>win-setup-x86.nsi</code>脚本）：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run build:win32</span><br></pre></td></tr></tbody></table></figure><p>运行NSIS安装目录内的<code>makensisw.exe</code>。</p><p>依次点击<code>File -&gt; Load Script...</code>，选择并加载本项目的<code>setup\NSIS\win-setup-x86.nsi</code>脚本。</p><p>最后，执行<code>Recompile</code>命令即可编译生成安装包。</p><p><img lazyload="" alt="image" data-src="https://blog-static.jiangxueqiao.com/blog/img/nsis-setup-1.jpg"></p><h1 id="2-项目介绍"><a href="#2-项目介绍" class="headerlink" title="2. 项目介绍"></a>2. 项目介绍</h1><h2 id="2-1-工程结构-🌳"><a href="#2-1-工程结构-🌳" class="headerlink" title="2.1 工程结构 🌳"></a>2.1 工程结构 🌳</h2><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">scripts/</span>         <span class="comment"># 该目录中的脚本用构建应用程序和驱动前端页面</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">screenshots</span>      <span class="comment"># 本文档中用到的截图</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">setup/</span>            <span class="comment"># 存储编译和构建相关文件</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">NSIS/</span>                <span class="comment"># NSIS安装包脚本</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">exe.ico</span>             <span class="comment"># 构建后的可执行文件图标（非安装包图标）</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">install.ico</span>        <span class="comment"># NSIS安装包图标</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">uninstall.ico</span>      <span class="comment"># NSIS卸载程序图标</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">src/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">lib/</span>            <span class="comment"># 公共库，为了方便修改，未做成独立的包</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">file-download/</span>    <span class="comment"># 文件下载库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span>                 <span class="comment"># 仅供主进程使用</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">renderer</span>            <span class="comment"># 仅供渲染进程使用</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shared</span>               <span class="comment"># 主进程和渲染进程都可以使用</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">utils/</span>            <span class="comment"># 公共代码库</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">main/</span>           <span class="comment"># 主进程的代码 (Electron)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">static/</span>          <span class="comment"># 静态资源</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">windows/</span>         <span class="comment"># 多窗口文件夹 (每个子目录表示一个窗口)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">primary/</span>          <span class="comment"># 主窗口（客户端通常都会有一个主窗口）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">frameless/</span>        <span class="comment"># 无边框示例窗口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">...</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">renderer/</span>      <span class="comment"># 渲染进程的代码 (VueJS)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">public</span>           <span class="comment"># 静态资源</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pages/</span>           <span class="comment"># 多页面目录 (强制约定：每个子目录代表一个页面)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">primary/</span>          <span class="comment"># 主窗口页面</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">frameless/</span>        <span class="comment"># 无边框示例窗口的页面</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">...</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">typings/</span>         <span class="comment"># ts声明文件</span></span><br></pre></td></tr></tbody></table></figure><h2 id="2-2-使用静态文件"><a href="#2-2-使用静态文件" class="headerlink" title="2.2 使用静态文件"></a>2.2 使用静态文件</h2><ul><li><code>src/main/static</code>目录存放主进程使用的静态文件。</li><li><code>src/renderer/public</code>目录存放渲染进程使用的静态文件。</li></ul><h4 id="在主进程中引用静态文件"><a href="#在主进程中引用静态文件" class="headerlink" title="在主进程中引用静态文件"></a>在主进程中引用静态文件</h4><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 src/main/static/tray.ico 文件存在</span></span><br><span class="line"><span class="comment">// 使用 appState.mainStaticPath 属性获取主进程的静态文件存储目录</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">"path"</span>;</span><br><span class="line"><span class="keyword">import</span> appState <span class="keyword">from</span> <span class="string">"./app-state"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iconPath = path.<span class="title function_">join</span>(appState.<span class="property">mainStaticPath</span>, <span class="string">"tray.ico"</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-AppState对象"><a href="#2-3-AppState对象" class="headerlink" title="2.3 AppState对象"></a>2.3 AppState对象</h2><p>为了方便在主进程中跨模块访问某些对象（如<code>primaryWindow</code>、<code>tray</code>、<code>cfgStore</code>等）和应用配置（如<code>onlyAllowSingleInstance</code>等），我们定义了单实例对象AppState来存储这些数据。</p><p>使用方法如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> appState <span class="keyword">from</span> <span class="string">"./app-state"</span>;</span><br><span class="line"></span><br><span class="line">appState.<span class="property">primaryWindow</span>?.<span class="title function_">show</span>();</span><br></pre></td></tr></tbody></table></figure><h2 id="2-4-快速创建Vue页面"><a href="#2-4-快速创建Vue页面" class="headerlink" title="2.4 快速创建Vue页面"></a>2.4 快速创建Vue页面</h2><p>执行如下命令，输入页面名称后将自动在<code>renderer/pages</code>目录创建子页面，每个子页面的相关代码位于单独的目录中，目录名为我们指定的页面名称（小写）。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run new:page</span><br></pre></td></tr></tbody></table></figure><p>创建的子页面在代码中通过以下方式访问：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开发环境</span></span><br><span class="line"><span class="keyword">const</span> rendererPort = process.<span class="property">argv</span>[<span class="number">2</span>];</span><br><span class="line">primaryWindow.<span class="title function_">loadURL</span>(<span class="string">`http://localhost:<span class="subst">${rendererPort}</span>/pages/&lt;PAGE-NAME&gt;/index.html`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非开发环境</span></span><br><span class="line">primaryWindow.<span class="title function_">loadFile</span>(path.<span class="title function_">join</span>(app.<span class="title function_">getAppPath</span>(), <span class="string">"build/renderer/pages/&lt;PAGE-NAME&gt;/index.html"</span>));</span><br></pre></td></tr></tbody></table></figure><h2 id="2-5-快速创建Electron窗口"><a href="#2-5-快速创建Electron窗口" class="headerlink" title="2.5 快速创建Electron窗口"></a>2.5 快速创建Electron窗口</h2><p>虽然直接构造Electron的BrowerWindow对象就可以创建新的Electron窗口，但为了方便代码管理和ipcMain消息隔离，本模板中的每个窗口都继承自<code>WindowBase</code>对象，每个窗口的相关代码位于<code>src\main\windows\</code>的不同子目录中，目录名为我们指定的窗口名称（小写）。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run new:window</span><br></pre></td></tr></tbody></table></figure><p>创建的子窗口默认会访问同名的子页面，可以手动修改代码访问其他页面：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">"development"</span>){</span><br><span class="line">  <span class="keyword">const</span> rendererPort = process.<span class="property">argv</span>[<span class="number">2</span>];</span><br><span class="line">  primaryWindow.<span class="title function_">loadURL</span>(<span class="string">`http://localhost:<span class="subst">${rendererPort}</span>/pages/primary/index.html`</span>);</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">  primaryWindow.<span class="title function_">loadFile</span>(path.<span class="title function_">join</span>(app.<span class="title function_">getAppPath</span>(), <span class="string">"build/renderer/pages/primary/index.html"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>创建窗口后，需要在<code>registerIpcMainHandler</code>方法中注册该窗口的ipcMain事件及处理函数。</p><p>如果多个窗口注册了同名的事件，当渲染进程发送该名称的事件到主进程时，所有窗口对象都会收到该事件，为了避免这种情况，我们可以在事件处理函数中使用<code>isIpcMainEventBelongMe</code>方法来过滤非本窗口的事件。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ipcMain.<span class="title function_">on</span>(<span class="string">"message"</span>, <span class="function">(<span class="params">event, message</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="title function_">isIpcMainEventBelongMe</span>(event))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h2 id="2-6-快速创建IPC函数"><a href="#2-6-快速创建IPC函数" class="headerlink" title="2.6 快速创建IPC函数"></a>2.6 快速创建IPC函数</h2><p>在<code>src\renderer\pages\primary\App.vue</code>中获取文件MD5的代码如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">onGetFileMd5</span>(<span class="params"></span>){</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> utils.<span class="title function_">showOpenDialog</span>({</span><br><span class="line">    <span class="attr">properties</span>: [ <span class="string">"openFile"</span> ],</span><br><span class="line">    <span class="attr">filters</span>: [</span><br><span class="line">      { <span class="attr">name</span>: <span class="string">"All Files"</span>, <span class="attr">extensions</span>: [ <span class="string">"*"</span> ] }</span><br><span class="line">    ]</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(result.<span class="property">filePaths</span>.<span class="property">length</span> &gt; <span class="number">0</span>){</span><br><span class="line">    utils.<span class="title function_">getFileMd5</span>(result.<span class="property">filePaths</span>[<span class="number">0</span>])</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">md5</span>) =&gt;</span> {</span><br><span class="line">        message.<span class="title function_">success</span>(md5);</span><br><span class="line">      }).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> {</span><br><span class="line">        message.<span class="title function_">error</span>(<span class="title class_">GetErrorMessage</span>(e));</span><br><span class="line">      });</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码通过调用Utils库的<code>showOpenDialog</code>、<code>getFileMd5</code>函数轻松实现了通知主进程选择文件、计算文件MD5并获取相应结果的操作，代码非常简洁。</p><p>但是Utils只预置了部分常用的功能，预置功能肯定无法满足我们产品开发的所有需求。在此情况下，我们可以向Utils库中添加自定义的功能函数，该如何添加了？</p><p>不用担心，本模板已经提供了IPC函数快速创建指令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run new:ipc</span><br></pre></td></tr></tbody></table></figure><p>执行上面指令后，会出现如下提示：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Create syntax: CallWay,FunctionName,FunctionType</span><br><span class="line">Call Way:</span><br><span class="line">        rm = Renderer process call the function of main process</span><br><span class="line">        mr = Main process call the function of renderer process (Ignore FunctionType)</span><br><span class="line">Function Name:</span><br><span class="line">        xxx-xxx-xxx</span><br><span class="line">Function Type:</span><br><span class="line">        a = Asynchronous call without result</span><br><span class="line">        ap = Asynchronous call with promise result</span><br><span class="line">        s = Synchronous call with result</span><br></pre></td></tr></tbody></table></figure><p>参数1（CallWay）表示函数调用方向：</p><ul><li>rm 表示渲染进程调用主进程的函数，可以支持同步调用、异步调用，并且可以返回Promise结果。</li><li>mr 表示主进程调用渲染进程的函数，该方向只能是异步调用，而且不支持返回结果，会忽略第三个参数（FunctionType）。</li></ul><p>参数2（FunctionName）表示函数名称，函数名称的单词间使用<code>-</code>分隔，如<code>GetFileSha256</code>需要指定为<code>get-file-sha256</code>。</p><p>参数3（FunctionType）函数类型：</p><ul><li>a 表示不返回结果的异步函数</li><li>ap 表示返回Promise结果的异步函数</li><li>s 表示同步函数</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>依次输入如下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn run new:ipc</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line"><span class="built_in">rm</span>,get-file-sha256,ap</span><br></pre></td></tr></tbody></table></figure><p>命令执行成功后，会自动在<code>src\lib\utils\renderer\index.ts</code>生成<code>Utils.getFileSha256</code>函数：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">async</span> <span class="title function_">getFileSha256</span>(<span class="params"></span>){</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> (<span class="variable language_">window</span> <span class="keyword">as</span> any).<span class="property">__ElectronUtils__</span>.<span class="title function_">getFileSha256</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自动生成的函数都没有指定参数和返回值，需要我们手动添加，如修改后的函数如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">async</span> <span class="title function_">getFileSha256</span>(<span class="attr">filePath</span>: string) : string {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> (<span class="variable language_">window</span> <span class="keyword">as</span> any).<span class="property">__ElectronUtils__</span>.<span class="title function_">getFileSha256</span>(filePath) <span class="keyword">as</span> string;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在渲染进程中（如App.vue）中可以直接调用该函数：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">"../../../lib/utils/renderer"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sha256 = <span class="keyword">await</span> utils.<span class="title function_">getFileSha256</span>(<span class="string">"file-path.txt"</span>);</span><br></pre></td></tr></tbody></table></figure><p>IPC函数创建指令只会创建函数骨架，不会为我们实现具体的功能，我们还需要在主进程ipcMain处理函数中实现计算文件SHA256的具体功能。</p><p>自动生成的主进程ipcMain处理函数如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipcMain.<span class="title function_">handle</span>(<span class="string">"electron-utils-get-file-sha256"</span>, <span class="title function_">async</span>(event) =&gt; {</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>手动添加参数、返回值，及具体的功能代码（此处省略）：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipcMain.<span class="title function_">handle</span>(<span class="string">"electron-utils-get-file-sha256"</span>, <span class="title function_">async</span>(event, <span class="attr">filePath</span>: string) : <span class="title class_">Promise</span>&lt;string&gt; =&gt; {</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h1 id="3-代码规范"><a href="#3-代码规范" class="headerlink" title="3. 代码规范"></a>3. 代码规范</h1><p>本项目使用ESLint进行代码检查和格式化，没有使用Prettier进行代码格式化。</p><p>原因大体如下：</p><ol><li><p>需要额外的插件和配置来避免ESLint和Prettier的规则冲突。</p></li><li><p>Prettier的<code>printWidth</code>配置项会损害代码和Git Diff的可读性。<br><img lazyload="" alt="image" data-src="https://blog-static.jiangxueqiao.com/blog/img/why-not-prettier-1.jpg"></p></li></ol><p><img lazyload="" alt="image" data-src="https://blog-static.jiangxueqiao.com/blog/img/why-not-prettier-2.jpg"></p><p><a class="link" href="https://prettier.io/playground/#N4Igxg9gdgLgprEAuc0DOMAEBXNcBOamAvJgNoA6UmmwOe+AkgCZKYCMANPQVAIYBbOGwogAggBsAZgEs4mAMJ98QiTJh9RmAL6cqNOrgIs2AJm5H8-ISJABxGf0wAlCGgAWfKFt37aPJlZMAGYLBmthTFEAZXdsAHNMADk+ACNsHz1qf0sTTAAWMN5BSNFnPncBL0wAMXw+Bky-QwY8gFYiqxLbABU3d3kAGQBPbFSEJuyW4yCANk6I22iCeJkIZJkJCCllSYBdAG4qEE4QCAAHGDWoNGRQZXwIAHcABWUEW5Q+CSe+YdvTql6mAANZwGDREqDRxwZA7CR4QHAsEQ858MCOeLIGD4bBwU5wATjZjMODMQZeeLYPjxOA1CAqPgwK5QLFfbAwCAnEDuGACCQAdXc6jgaDRYDgyxu6hkADd1MNkOA0ACQI4GDAXvV4lU4d9ESAAFZoAAe0UxEjgAEVsBB4HqEfiQGjCAQlak0nAJNzzvhHDABTJmDB3Mh8uZnY88AL6uclb7RQRZbDTgBHW3wLUXT4gBoAWigcDJZO5+Dg6ZkZa1NN1SHhBrwAhk2NxTrQFutGdhdf1To0qUDwdDSAjOL4m0xCggAlrIFFbW5Rh6aU+9adsrxjCgpNg0TAfsuYm30Rgw0tDrw2m0QA">在线演示<i class="fas fa-external-link-alt"></i></a></p><h1 id="4-依赖包-🎈"><a href="#4-依赖包-🎈" class="headerlink" title="4. 依赖包 🎈"></a>4. 依赖包 🎈</h1><h2 id="4-1-基本原则"><a href="#4-1-基本原则" class="headerlink" title="4.1 基本原则"></a>4.1 基本原则</h2><blockquote><p>一个构建在众多不稳定性因素下的项目，是没有稳定性可言的。</p></blockquote><p>为了保证项目的稳定性，本模板项目只使用具有知名度、稳定性强的依赖包（库），如<code>electron-log</code>等。</p><p>对于作者自己写的库（如<code>file-download</code>等），统一以源码形式提供在<code>src\lib\</code>目录，方便模板使用者进行bug修复和功能扩充，在使用时直接采用相对路径进行导入即可。</p><h2 id="4-2-dependencies和devDependencies的区别"><a href="#4-2-dependencies和devDependencies的区别" class="headerlink" title="4.2 dependencies和devDependencies的区别"></a>4.2 dependencies和devDependencies的区别</h2><p>由于Electron Forge会将<code>dependencies</code>中的所有依赖项都进行打包，因此为了减少安装包的体积，我们只将主进程需要使用的依赖安装到<code>dependencies</code>项下，而其他的依赖均安装到<code>devDependencies</code>。</p><p>如将vue作为开发依赖进行安装：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D vue</span><br></pre></td></tr></tbody></table></figure><h2 id="4-3-依赖包说明"><a href="#4-3-依赖包说明" class="headerlink" title="4.3 依赖包说明"></a>4.3 依赖包说明</h2><blockquote><p>作为开发者，应知晓每个依赖包的用途，避免node_modules黑洞的产生。</p></blockquote><ul><li><p>unplugin-vue-components<br>实现自动按需引入AntDesign-Vue组件。</p></li><li><p>electron-log<br>提供本地日志文件的打印和输出。</p></li><li><p>electron-store<br>提供本地配置文件的读取和写入功能。</p></li><li><p>@fortawesome-*<br>提供对FontAwesome图标字体的支持。</p></li><li><p>uuid<br>使用uuid字符串，在file-download库中使用。</p></li><li><p>chalk<br>用于在命令行终端输出带颜色样式的字符串，仅在<code>scripts\*.js</code>中使用。</p></li><li><p>chokidar<br>轻量级的文件监控组件，用于实现热加载，仅在<code>scripts\*.js</code>中使用。</p></li><li><p>@electron-forge/*<br>与Electron Forge构建和打包相关的依赖包，除了<code>@electron-forge/cli</code>是必须的，其他的可以根据<code>forge.config.js -&gt; makers</code>的配置按需引用。</p></li><li><p>axios<br>异步HTTP网络请求组件</p></li></ul><h1 id="5-客户端版本号"><a href="#5-客户端版本号" class="headerlink" title="5. 客户端版本号"></a>5. 客户端版本号</h1><p>使用<code>package.json</code>文件的<code>version</code>字段标识客户端的版本号，在主进程内可以通过<code>appState.appVersion</code>属性获取。</p><p>💡 不需要设置<code>forge.config.js</code>文件的<code>appVersion</code>字段。</p><p>在渲染进程可以直接使用<code>utils.getAppVersion()</code>获取版本号。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">"../../../lib/utils/renderer"</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(utils.<span class="title function_">getAppVersion</span>());</span><br></pre></td></tr></tbody></table></figure><h1 id="6-期待你的反馈-🥳"><a href="#6-期待你的反馈-🥳" class="headerlink" title="6. 期待你的反馈 🥳"></a>6. 期待你的反馈 🥳</h1><p>个人能力有限，代码不免有错误和不足之处，欢迎在Github中提交issue和PR。</p><p>如果这个项目对你有帮助，请点击Github右上角的Star ⭐让我知道。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最初选择使用Electron来开发客户端产品，主要是看重了Web开发的高效率，但进入到实际开发流程很多问题就都暴露出来了。&lt;/p&gt;
&lt;p&gt;和开发人员有关的问题主要集中在Web开发人员缺少对客户端的认识，系统编程方面的知识就更不用提了。&lt;/p&gt;
&lt;p&gt;Web开发大多喜欢使用模板搭建项目，大多数开发人员离开模板寸步难行，在模板选择方面也遇到了一些问题，有的模板项目（如Electron-vite）功能很强大，但项目过于复杂，甚至远远超过了我们需要开发的项目本身，这样一旦遇到问题，团队将很难上手进行修改，而有的模板项目又过于简单，使用的技术也比较老了，属于Demo类型，不适合用在产品开发中。&lt;/p&gt;
&lt;p&gt;基于上述问题，我着手开发了一个基于Vue3+Vite的Electron模板项目，在开发这个模板时，我一直遵循稳定、易于维护的初衷。而且在Web开发方面，我属于新手级别，因此我相信这个项目大多数人都是可以上手的。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;br&gt;&lt;a class=&quot;link&quot; href=&quot;https://github.com/winsoft666/electron-vue3-template&quot;&gt;https://github.com/winsoft666/electron-vue3-template&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="③ Power By Me" scheme="https://jiangxueqiao.com/categories/%E2%91%A2-Power-By-Me/"/>
    
    
  </entry>
  
  <entry>
    <title>🐉2024龙行龘龘</title>
    <link href="https://jiangxueqiao.com/post/1391804423.html"/>
    <id>https://jiangxueqiao.com/post/1391804423.html</id>
    <published>2024-02-20T01:25:38.000Z</published>
    <updated>2024-02-20T01:34:52.415Z</updated>
    
    <content type="html"><![CDATA[<p>写下这一行预示着2024年的工作开始了，加油！</p><hr><p>物来顺应，未来不迎。</p><p>当时不杂，既过不恋。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写下这一行预示着2024年的工作开始了，加油！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;物来顺应，未来不迎。&lt;/p&gt;
&lt;p&gt;当时不杂，既过不恋。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="⑭ 杂念" scheme="https://jiangxueqiao.com/categories/%E2%91%AD-%E6%9D%82%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>开源库spdlog使用备忘</title>
    <link href="https://jiangxueqiao.com/post/2185523635.html"/>
    <id>https://jiangxueqiao.com/post/2185523635.html</id>
    <published>2023-12-21T13:48:55.000Z</published>
    <updated>2024-01-16T09:52:58.721Z</updated>
    
    <content type="html"><![CDATA[<p><code>spdlog</code>是一个高性能C++日志库，支持仅头文件（header-only）模式使用。</p><blockquote><p>官网地址： <a class="link" href="https://github.com/gabime/spdlog">https://github.com/gabime/spdlog<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>spdlog是线程安全的，但不是进程安全的，可以多个线程同时使用一个spdlog对象输出日志，但不能多个进程同时往一个文件写入日志。</p><p>在spdlog内部使用<a class="link" href="https://github.com/fmtlib/fmt">fmt<i class="fas fa-external-link-alt"></i></a>进行字符串的格式化，因此spdlog字符串格式的方式与fmt库相同，如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">critical</span>(<span class="string">"Support for int: {0:d};  hex: {0:x};  oct: {0:o}; bin: {0:b}"</span>, <span class="number">42</span>);</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h1 id="一、日志级别"><a href="#一、日志级别" class="headerlink" title="一、日志级别"></a>一、日志级别</h1><p>大多数日志库都有日志级别的概念，通过设定日志级别可以动态控制我们需要打印输出的日志，spdlog支持如下日志级别：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trace = SPDLOG_LEVEL_TRACE   // 最低级</span><br><span class="line">debug = SPDLOG_LEVEL_DEBUG</span><br><span class="line">info = SPDLOG_LEVEL_INFO</span><br><span class="line">warn = SPDLOG_LEVEL_WARN</span><br><span class="line">err = SPDLOG_LEVEL_ERROR</span><br><span class="line">critical = SPDLOG_LEVEL_CRITICAL // 最高级    </span><br></pre></td></tr></tbody></table></figure><p>如下代码设置日志级别为<code>info</code>，此时只会打印输出info及比info级别高的日志：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">set_level</span>(spdlog::level::info);</span><br></pre></td></tr></tbody></table></figure><h1 id="二、Logger和Sink"><a href="#二、Logger和Sink" class="headerlink" title="二、Logger和Sink"></a>二、Logger和Sink</h1><p>spdlog主要由Logger(记录器)和Sink(输出位置)两部分组成，spdlog的高可拓展性体现在Logger和Sink的可以由用户自定义方面。</p><p>每个程序可以创建多个Logger对象，而每个Logger对象又可以包含多个Sink（也就是可以同时输出到多个位置）。</p><h2 id="2-1-创建Sink"><a href="#2-1-创建Sink" class="headerlink" title="2.1 创建Sink"></a>2.1 创建Sink</h2><p>在介绍Logger的创建方法前，我们先看看如何创建Sink对象。</p><p>每个Sink都是一个<code>std::shared_ptr&lt;spdlog::sink&gt;</code>对象，创建Sink方法如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_sink_mt&gt;();</span><br></pre></td></tr></tbody></table></figure><p>spdlog有<code>_mt</code>（multi threaded）和<code>_st</code>（single threaded）两类后缀的sink对象，用于区分是否线程安全。单线程(<code>_st</code>后缀)的sink是非线程安全的，不能被多个线程使用。</p><p>spdlog内置了多种不同的sink类型，如可以输出到文件、控制台、tcp/udp端口、Windows事件日志、mongo数据库等。完整的sink可以查看源代码的<a class="link" href="https://github.com/gabime/spdlog/tree/v1.x/include/spdlog/sinks/">sinks目录<i class="fas fa-external-link-alt"></i></a>，通常一个文件对应一个sink。</p><p>虽然内置的Sink可以满足我们的大多数需求，但spdlog依然支持自定义Sink，具体方法参考官方文档：<a class="link" href="https://github.com/gabime/spdlog/wiki/4.-Sinks#implementing-your-own-sink">implementing-your-own-sink<i class="fas fa-external-link-alt"></i></a></p><p>下面介绍几种常用内置sink的创建方法。</p><h3 id="simple-file-sink"><a href="#simple-file-sink" class="headerlink" title="simple_file_sink"></a>simple_file_sink</h3><p>一个简单的文件接收器，将日志写入到给定的日志文件，没有任何的限制。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"spdlog/sinks/basic_file_sink.h"</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">auto</span> logger = spdlog::<span class="built_in">basic_logger_mt</span>(<span class="string">"mylogger"</span>, <span class="string">"log.txt"</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>关于日志的输出目录，如上面的<code>data/logs</code>目录，从splog 1.5.0版本开始，spdlog将自动创建包含日志文件的目录。但在此之前，必须手动创建目录。</strong></p><h3 id="rotating-file-sink"><a href="#rotating-file-sink" class="headerlink" title="rotating_file_sink"></a>rotating_file_sink</h3><p>当达到最大文件大小时，关闭文件，并重命名，然后创建一个新的文件。最大文件大小和最大文件数都可以在构造函数中配置。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"spdlog/sinks/rotating_file_sink.h"</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> file_logger = spdlog::<span class="built_in">rotating_logger_mt</span>(<span class="string">"file_logger"</span>, <span class="string">"data/logs/mylogfile.log"</span>, <span class="number">1048576</span> * <span class="number">5</span>, <span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="daily-file-sink"><a href="#daily-file-sink" class="headerlink" title="daily_file_sink"></a>daily_file_sink</h3><p>每天在指定的时间创建一个新的日志文件，并在文件名后附加一个时间戳。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"spdlog/sinks/daily_file_sink.h"</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">auto</span> daily_logger = spdlog::<span class="built_in">daily_logger_mt</span>(<span class="string">"daily_logger"</span>, <span class="string">"logs/daily"</span>, <span class="number">14</span>, <span class="number">55</span>);</span><br></pre></td></tr></tbody></table></figure><p>上面代码将创建一个线程安全的sink，该sink将在每天14:55创建一个新的日志文件。</p><h3 id="stdout-sink"><a href="#stdout-sink" class="headerlink" title="stdout_sink"></a>stdout_sink</h3><p>输出到控制台。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"spdlog/sinks/stdout_sinks.h"</span></span></span><br><span class="line"><span class="keyword">auto</span> sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_sink_mt&gt;();</span><br></pre></td></tr></tbody></table></figure><h3 id="stdout-sink-with-colors"><a href="#stdout-sink-with-colors" class="headerlink" title="stdout_sink with colors"></a>stdout_sink with colors</h3><p>输出到控制台，并带颜色标记。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"spdlog/sinks/stdout_sinks.h"</span></span></span><br><span class="line"><span class="keyword">auto</span> sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_color_sink_mt&gt;();</span><br></pre></td></tr></tbody></table></figure><h3 id="msvc-sink"><a href="#msvc-sink" class="headerlink" title="msvc_sink"></a>msvc_sink</h3><p>输出到Windows调试接收器（如DbgView）,在spdlog内部实际使用<code>OutputDebugStringA</code>进行日志输出。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"spdlog/sinks/msvc_sink.h"</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">auto</span> sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::msvc_sink_mt&gt;(<span class="literal">false</span>);</span><br></pre></td></tr></tbody></table></figure><p><code>msvc_sink</code>的构造函数支持<code>check_debugger_present</code>参数，如果该参数为true，则仅在调试环境输出日志到Windows调试接收器。</p><h3 id="dup-filter-sink"><a href="#dup-filter-sink" class="headerlink" title="dup_filter_sink"></a>dup_filter_sink</h3><p>在日志输出时移除重复的日志。如果日志与前一条日志相同，并且间隔时间小于<code>max_skip_duration</code>，则跳过输出该日志。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"spdlog/sinks/dup_filter_sink.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> dup_filter = std::<span class="built_in">make_shared</span>&lt;dup_filter_sink_mt&gt;(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="function">spdlog::logger <span class="title">l</span><span class="params">(<span class="string">"logger"</span>, dup_filter)</span></span>;</span><br><span class="line">l.<span class="built_in">info</span>(<span class="string">"Hello"</span>);</span><br><span class="line">l.<span class="built_in">info</span>(<span class="string">"Hello"</span>);</span><br><span class="line">l.<span class="built_in">info</span>(<span class="string">"Hello"</span>);</span><br><span class="line">l.<span class="built_in">info</span>(<span class="string">"Different Hello"</span>);</span><br></pre></td></tr></tbody></table></figure><p>上面示例输出的日志如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[2019-06-25 17:50:56.511] [logger] [info] Hello</span><br><span class="line">[2019-06-25 17:50:56.512] [logger] [info] Skipped 3 duplicate messages..</span><br><span class="line">[2019-06-25 17:50:56.512] [logger] [info] Different Hello</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2-创建Logger"><a href="#2-2-创建Logger" class="headerlink" title="2.2 创建Logger"></a>2.2 创建Logger</h2><p>在创建完Sink对象后，就可以使用这些Sink来创建Logger对象。</p><p>下面示例创建了名为<code>mylogger</code>的同步Logger对象，为该对象配置了2个sink。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> file_sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::rotating_file_sink_mt&gt;(<span class="string">"logs/app.log"</span>, <span class="number">1048576</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> msvc_sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::msvc_sink_mt&gt;(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">std::vector&lt;spdlog::sink_ptr&gt; sinks = {file_sink, msvc_sink};</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> logger = std::<span class="built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="string">"mylogger"</span>,</span><br><span class="line">                                                sinks.<span class="built_in">begin</span>(),</span><br><span class="line">                                                sinks.<span class="built_in">end</span>());</span><br></pre></td></tr></tbody></table></figure><p>spdlog内部为每个进程都维护一张全局的Logger记录表，记载了每个进程中通过工厂方法创建的Logger实例(某些情况需要用户手动注册)。因而，在使用时只需要知道创建时指定的名称即可获取Logger对象：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> logger = spdlog::<span class="built_in">get</span>(<span class="string">"mylogger"</span>);</span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"some things want to say."</span>);</span><br></pre></td></tr></tbody></table></figure><h1 id="三、自定义日志格式"><a href="#三、自定义日志格式" class="headerlink" title="三、自定义日志格式"></a>三、自定义日志格式</h1><p>日志格式作用在Sink对象上，每个Sink都有一个格式化程序，spdlog的默认日志记录格式为：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2014-10-31 23:46:59.678] [my_loggername] [info] Some message</span><br></pre></td></tr></tbody></table></figure><p>我们可以通过下面方式为当前进程的所有Logger对象的所有Sink都统一设置日志格式：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">set_pattern</span>(<span class="string">"*** [%H:%M:%S %z] [thread %t] %v ***"</span>);</span><br></pre></td></tr></tbody></table></figure><p>也可以通过下面方式为指定的Logger对象的所有Sink设置日志格式：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_logger-&gt;<span class="built_in">set_pattern</span>(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br></pre></td></tr></tbody></table></figure><p>当然可以针对具体的Sink来设置日志格式：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">some_logger-&gt;<span class="built_in">sinks</span>()[<span class="number">0</span>]-&gt;<span class="built_in">set_pattern</span>(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">some_logger-&gt;<span class="built_in">sinks</span>()[<span class="number">1</span>]-&gt;<span class="built_in">set_pattern</span>(<span class="string">".."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">some_sink-&gt;<span class="built_in">set_pattern</span>(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br></pre></td></tr></tbody></table></figure><p>在设置日志格式时，spdlog都会对格式进程预编译，避免每次输出日志都进程格式解析，提升日志性能。</p><h2 id="3-1-格式标记"><a href="#3-1-格式标记" class="headerlink" title="3.1 格式标记"></a>3.1 格式标记</h2><p>下面列出了spdlog的pattern字符串支持的格式标记（类似<code>%flag</code>）。</p><table><thead><tr><th>标记</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>%v</td><td>实际的日志文本</td><td>some user text</td></tr><tr><td>%t</td><td>线程ID</td><td>1232</td></tr><tr><td>%P</td><td>进程ID</td><td>3456</td></tr><tr><td>%n</td><td>日志名称</td><td>some logger name</td></tr><tr><td>%l</td><td>日志等级全称</td><td>debug、info等</td></tr><tr><td>%L</td><td>日志等级简写</td><td>D、I等</td></tr><tr><td>%a</td><td>简写星期名称</td><td>Thu</td></tr><tr><td>%A</td><td>星期名称全程</td><td>Thursday</td></tr><tr><td>%b</td><td>简写月份名称</td><td>Aug</td></tr><tr><td>%B</td><td>月份名称全程</td><td>August</td></tr><tr><td>%c</td><td>日期和时间</td><td>Thu Aug 23 15:35:46 2014</td></tr><tr><td>%C</td><td>两位数表示年份</td><td>2014输出14</td></tr><tr><td>%Y</td><td>四位数表示年份</td><td>2014</td></tr><tr><td>%D</td><td>MM/DD/YY格式的日期</td><td>08/23/14</td></tr><tr><td>%m</td><td>月份（01-12）</td><td>11</td></tr><tr><td>%d</td><td>天（01-31）</td><td>29</td></tr><tr><td>%H</td><td>24小时制的小时(00-23)</td><td>23</td></tr><tr><td>%I</td><td>12小时制的小时(01-12)</td><td>11</td></tr><tr><td>%M</td><td>分钟（00-59）</td><td>59</td></tr><tr><td>%S</td><td>秒（00-59）</td><td>58</td></tr><tr><td>%e</td><td>毫秒</td><td>678</td></tr><tr><td>%f</td><td>微妙</td><td>056789</td></tr><tr><td>%F</td><td>纳秒</td><td>256789123</td></tr><tr><td>%p</td><td>AM/PM</td><td>AM</td></tr><tr><td>%r</td><td>12小时制时间</td><td>02:55:02 PM</td></tr><tr><td>%R</td><td>24小时制时间，等同于 %H:%M</td><td>23:55</td></tr><tr><td>%T或%X</td><td>ISO 8601时间格式，等同于%H:%M:%S</td><td>23:55:59</td></tr><tr><td>%z</td><td>ISO 8601时间格式，时区偏移 ([+/-]HH:MM)</td><td>如中国是东8区，+08:00</td></tr><tr><td>%E</td><td>时间戳</td><td>1528834770</td></tr><tr><td>%%</td><td>输出%</td><td>%</td></tr><tr><td>%+</td><td>spdlog默认格式</td><td>[2014-10-31 23:46:59.678] [mylogger] [info] Some message</td></tr><tr><td>%^</td><td>开始颜色标记（只能使用一次）</td><td>[mylogger] [info(green)] Some message</td></tr><tr><td>%$</td><td>结束颜色标记(如%^[+++]%$ %v) (只能使用一次)</td><td>[+++] Some message</td></tr><tr><td>%@</td><td>源文件路径和所在行数，等同于%g:%#</td><td>/some/dir/my_file.cpp:123</td></tr><tr><td>%s</td><td>源文件名</td><td>my_file.cpp</td></tr><tr><td>%g</td><td>源文件的完整路径或相对路径，等同于__FILE__宏</td><td>/some/dir/my_file.cpp</td></tr><tr><td>%#</td><td>源码所在行数</td><td>123</td></tr><tr><td>%!</td><td>源码所在函数名</td><td>my_func</td></tr><tr><td>%o</td><td>与上条日志的间隔时间（毫秒）</td><td>456</td></tr><tr><td>%i</td><td>与上条日志的间隔时间（微秒）</td><td>456</td></tr><tr><td>%u</td><td>与上条日志的间隔时间（纳秒）</td><td>11456</td></tr><tr><td>%O</td><td>与上条日志的间隔时间（秒）</td><td>4</td></tr></tbody></table><p>使用示例：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> file_sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::rotating_file_sink_mt&gt;(<span class="string">"logs/app.log"</span>, <span class="number">1048576</span>, <span class="number">7</span>);</span><br><span class="line">file_sink-&gt;<span class="built_in">set_pattern</span>(<span class="string">"%Y-%m-%d %H:%M:%S.%e %z %-10n %-8l [%P %t] %v"</span>);</span><br></pre></td></tr></tbody></table></figure><p>输出日志格式如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023-12-21 09:34:45.691 +08:00 Dock1703122417075610 info     [15460 6948] this is log text</span><br></pre></td></tr></tbody></table></figure><h3 id="源码位置标记"><a href="#源码位置标记" class="headerlink" title="源码位置标记"></a>源码位置标记</h3><p>如果需要使用源码位置标记，如<code>%s</code>, <code>%g</code>, <code>%#</code>, <code>%!</code>，需要在包含spdlog头文件之前，定义如下宏：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_TRACE</span></span><br></pre></td></tr></tbody></table></figure><h2 id="3-2-对齐"><a href="#3-2-对齐" class="headerlink" title="3.2 对齐"></a>3.2 对齐</h2><p>每个格式标记可以通过预先添加宽度标记来实现对齐。</p><p>使用<code>-</code>（左对齐）或<code>=</code>（中间对齐）控制对齐方向：</p><table><thead><tr><th>对齐</th><th>含义</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>%<width><flag></flag></width></td><td>右对齐</td><td>%8l</td><td>“    info”</td></tr><tr><td>%-<width><flag></flag></width></td><td>左对齐</td><td>%-8l</td><td>“info    “</td></tr><tr><td>%=<width><flag></flag></width></td><td>中间对齐</td><td>%=8l</td><td>“  info  “</td></tr></tbody></table><h2 id="3-3-截断"><a href="#3-3-截断" class="headerlink" title="3.3 截断"></a>3.3 截断</h2><p>还可以通过添加<code>!</code>标记来进行数据截断，如果宽度超过指定的宽度，则截断结果：</p><table><thead><tr><th>对齐</th><th>含义</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>%<width>!<flag></flag></width></td><td>右对齐并长度超过3个后截断</td><td>%3!l</td><td>“inf”</td></tr><tr><td>%-<width>!<flag></flag></width></td><td>左对齐并长度超过2个后截断</td><td>%-2!l</td><td>“in”</td></tr><tr><td>%=<width>!<flag></flag></width></td><td>中间对齐并长度超过1个后截断</td><td>%=1!l</td><td>“i”</td></tr></tbody></table><h1 id="四、输出策略-Flush-policy"><a href="#四、输出策略-Flush-policy" class="headerlink" title="四、输出策略(Flush policy)"></a>四、输出策略(Flush policy)</h1><p>基于性能考虑，spdlog不会立即输出日志，而是在内部通过日志队列的方式缓存日志，在合适的时候进行批量输出。</p><p>如果需要让spdlog立即输出队列中的日志，可以通过下面的几种方式实现。</p><h2 id="4-1-手动操作"><a href="#4-1-手动操作" class="headerlink" title="4.1 手动操作"></a>4.1 手动操作</h2><p>我们可以单独调用Sink的<code>flush</code>函数立即输出队列中的日志，也可以调用Logger对象的<code>flush</code>函数让该对象下的所有sink立即输出。</p><p>如果是异步日志，调用flush函数只会给日志队列发送一个flush消息，不会立即刷新。</p><p>在程序退出前，spdlog会确保队列中的所有日志都输出完成。如果想手动确保所有日志输出完成后退出程序，可以调用<code>spdlog::shutdown()</code>函数。</p><h2 id="4-2-基于日志等级的输出"><a href="#4-2-基于日志等级的输出" class="headerlink" title="4.2 基于日志等级的输出"></a>4.2 基于日志等级的输出</h2><p>您可以设置将触发自动输出的最低日志级别。例如，每当记录错误或更严重的消息时，这将触发立即输出：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_logger-&gt;<span class="built_in">flush_on</span>(spdlog::level::err); </span><br></pre></td></tr></tbody></table></figure><h2 id="4-3-定时输出"><a href="#4-3-定时输出" class="headerlink" title="4.3 定时输出"></a>4.3 定时输出</h2><p>所有已注册的Logger每5秒的定期输出：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">flush_every</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br></pre></td></tr></tbody></table></figure><p>这种方式只能使用在线程安全的sink上（即<code>_mt</code>后缀），因为定时输出任务执行在不同的线程上。</p><h1 id="五、异常"><a href="#五、异常" class="headerlink" title="五、异常"></a>五、异常</h1><p>spdlog在其文档中关于异常的说明，spdlog只会在构造Logger和Sink错误时主动抛出异常，因为spdlog认为这个错误是致命的，但这个并不可信，最多只能认为spdlog在其他情况下不会主动抛出异常，但不能保证其依赖的库（如fmt）不会抛出异常。</p><p>而且如果多个进程向同一个文件写入日志，当文件达到最大大小时，spdlog会自动重命名当前文件，并新建一个新的日志文件。如果多个进程向同一个文件写入日志，会导致重命名日志文件失败，splog会将该失败认为是致命错误，并抛出异常。</p><p>如果在打印日志时出现了spdlog能够预料的错误（非预料的及三方库抛出的异常仍然会传递到外部），spdlog默认将向<code>stderr</code>打印错误消息，为了避免错误消息充斥屏幕，每个Logger的错误消息输出速率限制为1条消息/分钟。</p><p>spdlog提供了错误处理方法，来让用户自定义如何处理错误信息，我们可以通过<code>set_error_handler</code>函数来自定义错误处理方法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局为每个Logger注册错误处理方法</span></span><br><span class="line">spdlog::<span class="built_in">set_error_handler</span>([](<span class="type">const</span> std::string&amp; msg) {</span><br><span class="line">      std::cerr &lt;&lt; <span class="string">"my err handler: "</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别为特定的Logger注册错误处理方法</span></span><br><span class="line">critical_logger-&gt;<span class="built_in">set_error_handler</span>([](<span class="type">const</span> std::string&amp; msg) {</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(msg);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>spdlog不是异常安全的，在使用spdlog时一定要注意异常捕获，否则可能因为一个格式化标记写错导致程序崩溃，本来是想通过日志来排除问题的，结果却因为日志导致程序崩溃，如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导致程序崩溃</span></span><br><span class="line">logger-&gt;<span class="built_in">error</span>(<span class="string">"create device enumerator failed, hr: {#x}"</span>, hr);</span><br></pre></td></tr></tbody></table></figure><h1 id="六、宽窄字符"><a href="#六、宽窄字符" class="headerlink" title="六、宽窄字符"></a>六、宽窄字符</h1><p>spdlog内部将字符作为<code>char</code>类型处理，如果需要输出<code>wchar_t</code>类型的字符串，需要将其转换为char类型，spdlog仅将char类型字符串原样输出，不做字符编码判断和处理，需要调用者来觉得字符串的编码，建议统一日志字符串的编码格式为UTF-8或ANSI。</p><h1 id="七、日志格式"><a href="#七、日志格式" class="headerlink" title="七、日志格式"></a>七、日志格式</h1><p>spdlog日志字符串的格式化处理使用的是开源<a class="link" href="https://github.com/fmtlib/fmt">fmt库<i class="fas fa-external-link-alt"></i></a>，其详细语法见：<a class="link" href="https://fmt.dev/latest/syntax.html">Format String Syntax<i class="fas fa-external-link-alt"></i></a>。</p><p>下面列举了常用的日志格式化方法。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出char字符串:{}"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 输出char字符串:hello</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出std::string:{}"</span>, std::<span class="built_in">string</span>(<span class="string">"hello"</span>));</span><br><span class="line"><span class="comment">// 输出std::string:hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 输出最小长度的字符串，如果长度不足则用固定字符填充，但超出不会截断字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出左对齐字符串(最小长度10，空格填充):{:&lt;10}"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 输出左对齐字符串(最小长度10，空格填充):hello     </span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出左对齐字符串(最小长度10):{:&lt;10}"</span>, <span class="string">"hello my world"</span>);</span><br><span class="line"><span class="comment">// 输出左对齐字符串(最小长度10):hello my world</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出右对齐字符串(最小长度10，空格填充):{:&gt;10}"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 输出右对齐字符串(最小长度10，空格填充):     hello</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出居中对齐字符串(最小长度10，空格填充):{:^10}"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 输出居中对齐字符串(最小长度10，空格填充):  hello   </span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出居中对齐字符串(最小长度10，*填充):{:*^10}"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 输出居中对齐字符串(最小长度10，*填充):**hello***</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出整型:{}"</span>, <span class="number">1234</span>);</span><br><span class="line"><span class="comment">// 输出整型:1234</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出布尔类型:{}"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 输出布尔类型:true</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出float:{}"</span>, <span class="number">3.1415936f</span>);</span><br><span class="line"><span class="comment">// 输出float:3.1415937</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出double:{}"</span>, <span class="number">3.1415936</span>);</span><br><span class="line"><span class="comment">// 输出double:3.1415936</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 输出最小位数（含小数点）的浮点型</span></span><br><span class="line"><span class="comment">* 小数点前部的最小位数=总位数-后部固定位数-1，位数不足默认填充空格，超过不截断；</span></span><br><span class="line"><span class="comment">* 小数点后部的位数始终固定，位数不足则在尾部添加0，超出则四舍五入后截断；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出浮点型(含小数点最小位数6位（左边填充空格），小数点后始终3位):{:6.3f}"</span>, <span class="number">3.1415936</span>);</span><br><span class="line"><span class="comment">// 输出浮点型(含小数点最小位数6位（左边填充空格），小数点后始终3位): 3.142</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出浮点型(含小数点最小位数6位（左边填充空格），小数点后始终3位):{:6.2f}"</span>, <span class="number">31415926.1</span>);</span><br><span class="line"><span class="comment">// 输出浮点型(含小数点最小位数6位（左边填充空格），小数点后始终3位):31415926.10</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出小写十六进制:{:x}"</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// 输出小写十六进制:7b</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出大写十六进制:{:X}"</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// 输出大写十六进制:7B</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出小写十六进制(带0x前缀):{:#x}"</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// 输出小写十六进制(带0x前缀):0x7b</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出大写十六进制(带0x前缀):{:#X}"</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// 输出大写十六进制(带0x前缀):0X7B</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出小写十六进制(固定8位，不足补0):{:08x}"</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// 输出小写十六进制(固定8位，不足补0):0000007b</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出小写十六进制(带0x前缀，固定8位，不足补0):{:#010x}"</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// 输出小写十六进制(带0x前缀，固定8位，不足补0):0x0000007b</span></span><br><span class="line"></span><br><span class="line">HRESULT hr = E_FAIL;</span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出HRESULT:{:#010x}"</span>, (<span class="type">unsigned</span> <span class="type">long</span>)hr);</span><br><span class="line"><span class="comment">// 输出HRESULT:0x80004005</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;spdlog&lt;/code&gt;是一个高性能C++日志库，支持仅头文件（header-only）模式使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官网地址： &lt;a class=&quot;link&quot; href=&quot;https://github.com/gabime/spdlog&quot;&gt;https://github.com/gabime/spdlog&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;spdlog是线程安全的，但不是进程安全的，可以多个线程同时使用一个spdlog对象输出日志，但不能多个进程同时往一个文件写入日志。&lt;/p&gt;
&lt;p&gt;在spdlog内部使用&lt;a class=&quot;link&quot; href=&quot;https://github.com/fmtlib/fmt&quot;&gt;fmt&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;进行字符串的格式化，因此spdlog字符串格式的方式与fmt库相同，如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;spdlog::&lt;span class=&quot;built_in&quot;&gt;critical&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Support for int: {0:d};  hex: {0:x};  oct: {0:o}; bin: {0:b}&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="⑪ 开源库" scheme="https://jiangxueqiao.com/categories/%E2%91%AA-%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>C/C++不同整数类型的区别</title>
    <link href="https://jiangxueqiao.com/post/2418701368.html"/>
    <id>https://jiangxueqiao.com/post/2418701368.html</id>
    <published>2023-12-15T13:20:06.000Z</published>
    <updated>2023-12-15T07:10:23.063Z</updated>
    
    <content type="html"><![CDATA[<p>在C/C++中涉及的整数相关的类型大致有如下几种：</p><ul><li>char、unsigned char</li><li>short、unsigned short</li><li>int、unsigned int</li><li>long、unsigned long</li><li>long long、unsigned long long</li><li>int8_t、uint8_t</li><li>int32_t、uint32_t</li><li>int64_t、uint64_t</li><li>DWORD</li><li>DWORD32、DWORD64</li><li>size_t、ssize_t</li><li>SIZE_T、SSIZE_T</li></ul><span id="more"></span><h2 id="一、原生数据类型"><a href="#一、原生数据类型" class="headerlink" title="一、原生数据类型"></a>一、原生数据类型</h2><p>以下数据类型C/C++语言中的原生整数类型，其长度取决于所使用的计算机系统和编译器：</p><ul><li>short、unsigned short</li><li>int、unsigned int</li><li>long、unsigned long</li><li>long long、unsigned long long</li></ul><p>如果需要开发跨平台的、具有良好可移植性的程序，请不要使用这些数据类型。<strong>通常情况下</strong>，这些数据类型所占字节数如下表所示：</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>范围</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>-128 ~ 127</td></tr><tr><td>unsigned char</td><td>1</td><td>0 ~ 255</td></tr><tr><td>short</td><td>2</td><td>-32,768 ~ 32,767</td></tr><tr><td>unsigned short</td><td>2</td><td>0 ~ 65,535</td></tr><tr><td>int</td><td>4</td><td>-2,147,483,648 ~ 2,147,483,647</td></tr><tr><td>unsigned int</td><td>0</td><td>0 ~ 4,294,967,295</td></tr><tr><td>long</td><td>4</td><td>-2,147,483,648 ~ 2,147,483,647</td></tr><tr><td>unsigned long</td><td>4</td><td>0 ~ 4,294,967,295</td></tr><tr><td>long long</td><td>8</td><td>-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807</td></tr><tr><td>unsigned long long</td><td>8</td><td>0 ~ 18,446,744,073,709,551,615</td></tr></tbody></table><h2 id="二、int-t数据类型"><a href="#二、int-t数据类型" class="headerlink" title="二、int*_t数据类型"></a>二、int*_t数据类型</h2><p><code>int*_t</code>格式的数据类型是使用typedef重新定义的数据类型。通过在不同的编译环境进行重定义，确保其所占用的字节数始终相同（即数据范围也相同）。</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>范围</th></tr></thead><tbody><tr><td>int8_t</td><td>1</td><td>-128 ~ 127</td></tr><tr><td>uint8_t</td><td>1</td><td>0 ~ 255</td></tr><tr><td>int32_t</td><td>4</td><td>-2,147,483,648 ~ 2,147,483,647</td></tr><tr><td>uint32_t</td><td>4</td><td>0 ~ 4,294,967,295</td></tr><tr><td>int64_t</td><td>8</td><td>-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807</td></tr><tr><td>uint64_t</td><td>8</td><td>0 ~ 18,446,744,073,709,551,615</td></tr></tbody></table><h2 id="三、size-t和std-size-t"><a href="#三、size-t和std-size-t" class="headerlink" title="三、size_t和std::size_t"></a>三、size_t和std::size_t</h2><p>size_t和std::size_t是不同的数据类型，size_t是定义在C语言的头文件，而std::size_t定义在C++标准库的<code>&lt;cstddef&gt;</code>头文件中。</p><p>虽然二者是不同的数据类型，但std::size_t在实现上兼容size_t了，二者所占的字节数始终相同。</p><p>size_t和std::size_t都是无符号整型，它们在32位编译环境占用4字节，64位编译环境占8字节。</p><p>如果需要使用有符号的size_t类型，在Linux上可以使用<code>ssize_t</code>类型，Windows上可以使用<code>SSIZE_T</code>类型。</p><h2 id="四、DWORD和DWORD32、DWORD64"><a href="#四、DWORD和DWORD32、DWORD64" class="headerlink" title="四、DWORD和DWORD32、DWORD64"></a>四、DWORD和DWORD32、DWORD64</h2><p>DWORD是32位无符号整型（范围<code>0 ~ 4,294,967,295</code>）</p><p><code>DWORD32</code>是32位无符号整型（范围<code>0 ~ 4,294,967,295</code>）,<code>DWORD64</code>是64位无符号整型（范围<code>0 ~ 18,446,744,073,709,551,615</code>）。</p><p>而<code>DWORD</code>也是32位无符号整型（范围<code>0 ~ 4,294,967,295</code>），可能微软在设计之初是打算让DWORD在不同的编译环境具有不同的位数，但从目前情况来看，这种希望已然破灭，<code>DWORD</code>将永远是32位的无符号整型。</p><h2 id="五、一点点建议"><a href="#五、一点点建议" class="headerlink" title="五、一点点建议"></a>五、一点点建议</h2><p>为了保证程序的可移植性，请在开发中只使用固定字节数的数据类型，如int8_t、int32_t、int64_t。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在C/C++中涉及的整数相关的类型大致有如下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;char、unsigned char&lt;/li&gt;
&lt;li&gt;short、unsigned short&lt;/li&gt;
&lt;li&gt;int、unsigned int&lt;/li&gt;
&lt;li&gt;long、unsigned long&lt;/li&gt;
&lt;li&gt;long long、unsigned long long&lt;/li&gt;
&lt;li&gt;int8_t、uint8_t&lt;/li&gt;
&lt;li&gt;int32_t、uint32_t&lt;/li&gt;
&lt;li&gt;int64_t、uint64_t&lt;/li&gt;
&lt;li&gt;DWORD&lt;/li&gt;
&lt;li&gt;DWORD32、DWORD64&lt;/li&gt;
&lt;li&gt;size_t、ssize_t&lt;/li&gt;
&lt;li&gt;SIZE_T、SSIZE_T&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="② C++" scheme="https://jiangxueqiao.com/categories/%E2%91%A1-C/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows窗口调试利器-WinSpyPlus</title>
    <link href="https://jiangxueqiao.com/post/1533480858.html"/>
    <id>https://jiangxueqiao.com/post/1533480858.html</id>
    <published>2023-11-26T11:07:09.000Z</published>
    <updated>2023-11-28T10:44:39.886Z</updated>
    
    <content type="html"><![CDATA[<p>在Windows平台进行客户端开发时，不可避免的会遇到需要调试窗口的情况，如查看窗口句柄、窗口位置/尺寸、监听窗口消息等。虽然微软随Visual Stuido一同发布了Microsoft Spy++工具，但该工具的功能更新缓慢，这么多年过去了基本没有什么变化，比如：</p><ul><li>一直未提供单独的安装包。</li><li>强制以管理员权限启动，虽然以管理员权限启动可以避免很多问题（如无法监听管理员权限进程窗口的消息等），但这让用户失去了选择非管理员的权力。</li><li>不能通过标题或类名来查找窗口。</li><li>查找到的窗口不能自动定位到窗口树中。</li><li>不能过滤是否显示隐藏窗口、是否显示无标题窗口。</li><li>不能查看Message-Only窗口。</li><li>不能定时导出窗口树到文件中，以便做后续的对比分析。</li><li>默认启动的时32位进程，无法监听64位进程窗口的消息，监听失败时也未能提示用户。</li><li>未提供对窗口的快速操作指令，如显示/隐藏、最大化/最小化/还原、置顶/置底等。</li></ul><span id="more"></span><p>基于Microsoft Spy++的以上缺陷或不足，我开发了一个款为<code>WinSpyPlus</code>的工具，该工具解决了上述所有问题，而且功能特性还在不断扩充中。</p><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><ul><li><p>Github（更新及时）:</p><p><a class="link" href="https://github.com/winsoft666/winspyplus-bin">https://github.com/winsoft666/winspyplus-bin<i class="fas fa-external-link-alt"></i></a></p></li><li><p>奶牛快传（更新可能延后）：</p><p><a class="link" href="https://cowtransfer.com/s/aa5ab9c1ef2e46">https://cowtransfer.com/s/aa5ab9c1ef2e46<i class="fas fa-external-link-alt"></i></a></p></li></ul><h2 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h2><p><img lazyload="" alt="image" data-src="https://blog-static.jiangxueqiao.com/blog/img/winspyplus-screenshot-1-TinyTu.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Windows平台进行客户端开发时，不可避免的会遇到需要调试窗口的情况，如查看窗口句柄、窗口位置/尺寸、监听窗口消息等。虽然微软随Visual Stuido一同发布了Microsoft Spy++工具，但该工具的功能更新缓慢，这么多年过去了基本没有什么变化，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一直未提供单独的安装包。&lt;/li&gt;
&lt;li&gt;强制以管理员权限启动，虽然以管理员权限启动可以避免很多问题（如无法监听管理员权限进程窗口的消息等），但这让用户失去了选择非管理员的权力。&lt;/li&gt;
&lt;li&gt;不能通过标题或类名来查找窗口。&lt;/li&gt;
&lt;li&gt;查找到的窗口不能自动定位到窗口树中。&lt;/li&gt;
&lt;li&gt;不能过滤是否显示隐藏窗口、是否显示无标题窗口。&lt;/li&gt;
&lt;li&gt;不能查看Message-Only窗口。&lt;/li&gt;
&lt;li&gt;不能定时导出窗口树到文件中，以便做后续的对比分析。&lt;/li&gt;
&lt;li&gt;默认启动的时32位进程，无法监听64位进程窗口的消息，监听失败时也未能提示用户。&lt;/li&gt;
&lt;li&gt;未提供对窗口的快速操作指令，如显示/隐藏、最大化/最小化/还原、置顶/置底等。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="③ Power By Me" scheme="https://jiangxueqiao.com/categories/%E2%91%A2-Power-By-Me/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows API的不同返回状态</title>
    <link href="https://jiangxueqiao.com/post/2510508225.html"/>
    <id>https://jiangxueqiao.com/post/2510508225.html</id>
    <published>2023-11-26T09:39:23.000Z</published>
    <updated>2023-11-26T10:54:12.122Z</updated>
    
    <content type="html"><![CDATA[<p>在Windows编程中，我们经常接触到的Windows API返回值类型有：</p><ul><li>BOOL</li><li>HRESULT</li><li>LSTATUS</li></ul><span id="more"></span><h1 id="1-错误码"><a href="#1-错误码" class="headerlink" title="1. 错误码"></a>1. 错误码</h1><p>BOOL类型通常是0表示失败，非0表示成功，在BOOL类型返回失败时，通常还可以通过<code>GetLastError</code>函数获取错误码。错误码与调用线程相关联，每个线程的错误码是独立的，在调用完Windows API后，如下获取错误码，则需要立即获取，否则可能会被后面调用API所设置的错误码所覆盖。</p><p>应用程序也可以通过<code>SetLastError</code>函数来设置错误码。</p><p>Windows API通常在没有错误发生时，将错误码设置为0，有错误发生时，视具体错误而设置为其他非0值。</p><blockquote><p>微软官方文档：<a class="link" href="https://learn.microsoft.com/en-us/windows/win32/debug/system-error-codes">Debug system error codes<i class="fas fa-external-link-alt"></i></a></p></blockquote><h2 id="常见的错误码"><a href="#常见的错误码" class="headerlink" title="常见的错误码"></a>常见的错误码</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR_SUCCESS = <span class="number">0</span>  <span class="comment">// 成功</span></span><br><span class="line">ERROR_OUTOFMEMORY  <span class="comment">// 内存不足</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h1 id="2-HRESULT"><a href="#2-HRESULT" class="headerlink" title="2. HRESULT"></a>2. HRESULT</h1><h2 id="2-1-HRESULT结构"><a href="#2-1-HRESULT结构" class="headerlink" title="2.1 HRESULT结构"></a>2.1 HRESULT结构</h2><p>HRESULT是COM返回的错误码，总共32位，它由三个基本部分组成：</p><ul><li>高1位表示成功或失败（0表示成功，1表示失败）。</li><li>中间11位编码指示错误来源的设施/设备。</li><li>低16位编码错误编号。</li></ul><p>0~32位的作用分别如下：<br><img lazyload="" alt="image" data-src="https://blog-static.jiangxueqiao.com/blog/img/hresult-bit.png"></p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">S - 严重度 - 表示成功/失败</span><br><span class="line"></span><br><span class="line">    0 - 成功</span><br><span class="line">    1 - 失败 (COERROR)</span><br><span class="line"></span><br><span class="line">R - reserved portion of the facility code, corresponds to NT's second severity bit.</span><br><span class="line"></span><br><span class="line">C - reserved portion of the facility code, corresponds to NT's C field.</span><br><span class="line"></span><br><span class="line">N - reserved portion of the facility code. Used to indicate a mapped NT status value.</span><br><span class="line"></span><br><span class="line">r - reserved portion of the facility code. Reserved for internal</span><br><span class="line">        use. Used to indicate HRESULT values that are not status</span><br><span class="line">        values, but are instead message ids for display strings.</span><br><span class="line"></span><br><span class="line">Facility - 设备/设施码</span><br><span class="line"></span><br><span class="line">Code - 设备/设施的状态码</span><br></pre></td></tr></tbody></table></figure><p>在实际开发中，通常不需要关心其每一位的具体作用，我们使用更多的是下面的几个宏：</p><ul><li>使用<code>SUCCEEDED(hr)</code>宏判断是否成功（即hr&gt;= 0），<code>FAILED(hr)</code>判断是否失败(即hr&lt; 0)。</li><li>使用<code>HRESULT_CODE(hr)</code>宏获取错误码。</li><li>使用<code>HRESULT_FACILITY(hr)</code>宏获取设备码。</li></ul><blockquote><p>4字节（32位）整数能表示的最大正整数为<code>7FFF FFFFF</code>（最高位为0），当最高位为1时，则为负数。所以HRESULT能通过是否为负数来判断成功与否。</p></blockquote><h2 id="2-2-常见的HRESULT值"><a href="#2-2-常见的HRESULT值" class="headerlink" title="2.2 常见的HRESULT值"></a>2.2 常见的HRESULT值</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S_OK     <span class="comment">// 成功</span></span><br><span class="line">S_FALSE  <span class="comment">// 失败</span></span><br><span class="line">E_FAIL   <span class="comment">// 失败</span></span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-API错误码与HRESULT"><a href="#2-3-API错误码与HRESULT" class="headerlink" title="2.3 API错误码与HRESULT"></a>2.3 API错误码与HRESULT</h2><p>我们可以使用<code>HRESULT_FROM_WIN32</code>宏将上一节介绍的“Windows API的错误码”转成HRESULT。</p><h1 id="3-LSTATUS"><a href="#3-LSTATUS" class="headerlink" title="3. LSTATUS"></a>3. LSTATUS</h1><p>在Windows API中对LSTATUS的定义比较模糊，比如注册表API（如RegCreateEx等）返回的LSTATUS实际就是第一节介绍的Windows错误码。</p><p>所以当遇到返回LSTATUS类型的API时，需要参考API的文档说明。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Windows编程中，我们经常接触到的Windows API返回值类型有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BOOL&lt;/li&gt;
&lt;li&gt;HRESULT&lt;/li&gt;
&lt;li&gt;LSTATUS&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="① 专栏集锦" scheme="https://jiangxueqiao.com/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/"/>
    
    <category term="Windows核心编程" scheme="https://jiangxueqiao.com/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Qt自定义和美化菜单</title>
    <link href="https://jiangxueqiao.com/post/711494356.html"/>
    <id>https://jiangxueqiao.com/post/711494356.html</id>
    <published>2023-11-07T06:00:00.000Z</published>
    <updated>2023-11-07T04:17:59.270Z</updated>
    
    <content type="html"><![CDATA[<p>在Qt中可以通过QSS对菜单进行样式设置，而且对于非标准菜单项我也可以通过自定义Widget的方法来实现，本文讲述在Qt中菜单的这些常用方法。</p><span id="more"></span><h2 id="一、菜单基本使用方法"><a href="#一、菜单基本使用方法" class="headerlink" title="一、菜单基本使用方法"></a>一、菜单基本使用方法</h2><p>下面示例演示了右键菜单的创建方法，该菜单包含了图标、选中/未选中状态、二级菜单、互斥选择等常用菜单特性，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QIcon <span class="title">settingIcon</span><span class="params">(<span class="string">":/MenuBeauty/setting.png"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Actions</span></span><br><span class="line">QAction* action1 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">"动作1"</span>);</span><br><span class="line">QAction* action2 = <span class="keyword">new</span> <span class="built_in">QAction</span>(settingIcon, <span class="string">"动作2 有图标"</span>);</span><br><span class="line"></span><br><span class="line">QAction* action3 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">"动作3 [未选中]"</span>);</span><br><span class="line">action3-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">action3-&gt;<span class="built_in">setChecked</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">connect</span>(action3, &amp;QAction::triggered, <span class="keyword">this</span>, [action3](<span class="type">bool</span> checked) {</span><br><span class="line">    action3-&gt;<span class="built_in">setText</span>(checked ? <span class="string">"动作3 [选中]"</span> : <span class="string">"动作3 [未选中]"</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">QAction* action4 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">"Action4 动作四测试"</span>);</span><br><span class="line"></span><br><span class="line">QAction* action5 = <span class="keyword">new</span> <span class="built_in">QAction</span>(settingIcon, <span class="string">"动作5 禁用"</span>);</span><br><span class="line">action5-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">QAction* action6 = <span class="keyword">new</span> <span class="built_in">QAction</span>(settingIcon, <span class="string">"动作6 子菜单"</span>);</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 动作6的子动作</span></span><br><span class="line">    QAction* action6_1 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">"动作6.1"</span>);</span><br><span class="line">    action6_1-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    QAction* action6_2 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">"动作6.1"</span>);</span><br><span class="line">    action6_2-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    QAction* action6_3 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">"动作6.1"</span>);</span><br><span class="line">    action6_3-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动作6的子菜单</span></span><br><span class="line">    QMenu* action6SubMenu = <span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    action6SubMenu-&gt;<span class="built_in">addAction</span>(action6_1);</span><br><span class="line">    action6SubMenu-&gt;<span class="built_in">addAction</span>(action6_2);</span><br><span class="line">    action6SubMenu-&gt;<span class="built_in">addAction</span>(action6_3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥子菜单项，同时只能选择一个</span></span><br><span class="line">    QActionGroup* action6Group = <span class="keyword">new</span> <span class="built_in">QActionGroup</span>(<span class="keyword">this</span>);</span><br><span class="line">    action6Group-&gt;<span class="built_in">setExclusive</span>(<span class="literal">true</span>);</span><br><span class="line">    action6Group-&gt;<span class="built_in">addAction</span>(action6_1);</span><br><span class="line">    action6Group-&gt;<span class="built_in">addAction</span>(action6_2);</span><br><span class="line">    action6Group-&gt;<span class="built_in">addAction</span>(action6_3);</span><br><span class="line"></span><br><span class="line">    action6-&gt;<span class="built_in">setMenu</span>(action6SubMenu);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义菜单</span></span><br><span class="line">QMenu* menu = <span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加Action</span></span><br><span class="line">menu-&gt;<span class="built_in">addActions</span>({action1, action2, action3});</span><br><span class="line">menu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">menu-&gt;<span class="built_in">addActions</span>({action4, action5, action6});</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标右键弹出菜单</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::CustomContextMenu);</span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;QWidget::customContextMenuRequested, <span class="keyword">this</span>, [<span class="keyword">this</span>, menu](<span class="type">const</span> QPoint&amp; pos) {</span><br><span class="line">    menu-&gt;<span class="built_in">exec</span>(<span class="keyword">this</span>-&gt;<span class="built_in">mapToGlobal</span>(pos));</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>上述菜单未经过任何美化，样式如下图所示：<br><img lazyload="" alt="image" data-src="https://blog-static.jiangxueqiao.com/blog/img/default-menu-style.png"></p><h2 id="二、使用QSS美化菜单"><a href="#二、使用QSS美化菜单" class="headerlink" title="二、使用QSS美化菜单"></a>二、使用QSS美化菜单</h2><p>现在我们使用如下QSS对上面创建的菜单进行美化，可以美化的项包含背景、文本颜色、边距、图标等。</p><p>为了使大家不被颜色值所困扰，下面QSS中的颜色统一使用颜色名称表示。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 菜单的属性 */</span></span><br><span class="line">QMenu {</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solod red;</span><br><span class="line">    <span class="comment">/* 圆角生效的前提是菜单窗口背景透明 */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"Microsoft YaHei"</span>;</span><br><span class="line">    <span class="comment">/* 设置菜单项最小宽度，此处有bug：虽可自动增长但实际宽度比所需宽度小 */</span></span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">160px</span>;</span><br><span class="line">    <span class="comment">/* 菜单内容上下边距为10px，预留圆角区域 */</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">0px</span> <span class="number">10px</span> <span class="number">0px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜单项的属性 */</span></span><br><span class="line">QMenu::item {</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="comment">/* 设置菜单项最小高度，可以让菜单项的高适应内容自动增长 */</span></span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="comment">/* 设置菜单项最小宽度，此处有bug：虽可自动增长但实际宽度比所需宽度小 */</span></span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">160px</span>;</span><br><span class="line">    <span class="comment">/* 使菜单项之间及菜单项和图标之间保持一定间隔，设置上下左右边距为8px，此处不能用margin */</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">8px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜单项-鼠标移入时的属性 */</span></span><br><span class="line">QMenu::item:selected {</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜单项-禁用时的属性 */</span></span><br><span class="line">QMenu::item:disabled {</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分割线的属性 */</span></span><br><span class="line">QMenu::separator {</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="comment">/* 左右边距：6px */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>x <span class="number">6px</span> <span class="number">0px</span> <span class="number">6px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图标的属性 */</span></span><br><span class="line">QMenu::icon {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="comment">/* 左边距：12px */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指示器的属性 */</span></span><br><span class="line"><span class="comment">/* 这里将互斥和非互斥Action的指示器样式设置为一样的，也可以设置为不一样 */</span></span><br><span class="line">QMenu::indicator:non-exclusive:checked, QMenu::indicator:exclusive:checked {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="comment">/* 左边距：8px */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span>;</span><br><span class="line">    image: <span class="built_in">url</span>(<span class="string">:/MenuBeauty/check.png</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">QMenu::indicator:non-exclusive:unchecked, QMenu::indicator:exclusive:unchecked {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="comment">/* 左边距：8px */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span>;</span><br><span class="line">    image: <span class="built_in">url</span>(<span class="string">:/MenuBeauty/unchecked.png</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了使菜单的圆角生效，我们还需要移除菜单的边框、阴影，并将背景设置为透明，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">menu-&gt;<span class="built_in">setWindowFlags</span>(action6SubMenu-&gt;<span class="built_in">windowFlags</span>() |</span><br><span class="line">                                Qt::FramelessWindowHint |   <span class="comment">// 无边框</span></span><br><span class="line">                                Qt::NoDropShadowWindowHint  <span class="comment">// 移除系统阴影</span></span><br><span class="line">);</span><br><span class="line">menu-&gt;<span class="built_in">setAttribute</span>(Qt::WA_TranslucentBackground); <span class="comment">// 背景透明</span></span><br></pre></td></tr></tbody></table></figure><p>美化后的菜单如下图所示：<br><img lazyload="" alt="image" data-src="https://blog-static.jiangxueqiao.com/blog/img/after-qss-menu-style.png"></p><h3 id="QSS可定制的QMenu部分"><a href="#QSS可定制的QMenu部分" class="headerlink" title="QSS可定制的QMenu部分"></a>QSS可定制的QMenu部分</h3><p>QMenu支持QSS盒子模型，其通用属性如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">border</span><br><span class="line">border-radius</span><br><span class="line">margin</span><br><span class="line">padding</span><br><span class="line">background</span><br><span class="line">color</span><br><span class="line">font</span><br><span class="line">border-image</span><br></pre></td></tr></tbody></table></figure><p>QSS还可以对QMenu的子控件进行设置，支持QMenu子控件如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">item</span><br><span class="line">indicator</span><br><span class="line">separator</span><br><span class="line">right-arrow</span><br><span class="line">left-arrow</span><br><span class="line">scroller</span><br><span class="line">tearoff</span><br></pre></td></tr></tbody></table></figure><p>QMenu不支持伪状态，只有其子控件支持伪状态，支持的伪状态如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default</span><br><span class="line">selected</span><br><span class="line">exclusive</span><br><span class="line">non-exclusive</span><br></pre></td></tr></tbody></table></figure><p>具体的子控件和伪状态的含义，可以参考 <a href="/post/749849405.html" title="QSS基本使用方法">QSS基本使用方法</a> 文章。</p><h2 id="三、自定义菜单项"><a href="#三、自定义菜单项" class="headerlink" title="三、自定义菜单项"></a>三、自定义菜单项</h2><p>大多数情况，上述常规的菜单项就可以满足要求，但有些情况下，我们的菜单项可能是更加复杂的Widget组合，比如下面播放器的菜单：<br><img lazyload="" alt="image" data-src="https://blog-static.jiangxueqiao.com/blog/img/music-menu-sample.png"></p><p>我们可以使用<code>QWidgetAction</code>来实现上述菜单效果，<code>QWidgetAction</code>可以将一个QWidget放入菜单项的容器内，从而实现自定义菜单项。</p><p>下面代码定义了一个包含3个按钮的菜单项，点击按钮会弹出对话框：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">QWidgetAction* action7 = <span class="keyword">new</span> <span class="built_in">QWidgetAction</span>(<span class="keyword">this</span>);</span><br><span class="line">{</span><br><span class="line">    QWidget* widget = <span class="keyword">new</span> <span class="built_in">QWidget</span>();</span><br><span class="line">    QHBoxLayout* hl = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>(widget);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> createPushButtonFn = [<span class="keyword">this</span>](QString title) {</span><br><span class="line">        QPushButton* btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(title);</span><br><span class="line">        <span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [<span class="keyword">this</span>]() {</span><br><span class="line">            QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">"Clicked"</span>, ((QPushButton*)<span class="built_in">sender</span>())-&gt;<span class="built_in">text</span>());</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> btn;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    hl-&gt;<span class="built_in">addWidget</span>(<span class="built_in">createPushButtonFn</span>(<span class="string">"Button1"</span>));</span><br><span class="line">    hl-&gt;<span class="built_in">addWidget</span>(<span class="built_in">createPushButtonFn</span>(<span class="string">"Button2"</span>));</span><br><span class="line">    hl-&gt;<span class="built_in">addWidget</span>(<span class="built_in">createPushButtonFn</span>(<span class="string">"Button3"</span>));</span><br><span class="line"></span><br><span class="line">    action7-&gt;<span class="built_in">setDefaultWidget</span>(widget);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">menu-&gt;<span class="built_in">addAction</span>(action7);</span><br></pre></td></tr></tbody></table></figure><p>效果如图所示：<br><img lazyload="" alt="image" data-src="https://blog-static.jiangxueqiao.com/blog/img/qwidgetaction-menu-sample.png"></p><p>我们也可以使用QSS对菜单项内的控件进行样式设置，如：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QMenu QPushButton {</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Qt中可以通过QSS对菜单进行样式设置，而且对于非标准菜单项我也可以通过自定义Widget的方法来实现，本文讲述在Qt中菜单的这些常用方法。&lt;/p&gt;</summary>
    
    
    
    <category term="② C++" scheme="https://jiangxueqiao.com/categories/%E2%91%A1-C/"/>
    
    <category term="Qt" scheme="https://jiangxueqiao.com/categories/%E2%91%A1-C/Qt/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么SetParent会失败</title>
    <link href="https://jiangxueqiao.com/post/3832058229.html"/>
    <id>https://jiangxueqiao.com/post/3832058229.html</id>
    <published>2023-11-02T05:45:13.000Z</published>
    <updated>2023-11-07T04:20:02.252Z</updated>
    
    <content type="html"><![CDATA[<p>SetParent是Windows提供的设置窗口父窗体的API，函数原型比较简单：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">SetParent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           HWND hWndChild,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] HWND hWndNewParent</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p>我们通常的使用方法是：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">SetParent</span>(hChild, hParent)) {</span><br><span class="line">  <span class="comment">// Failed</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种使用方法在大多情况下不会失败，但有时却会失败。究其原因，其在微软官方文档中已有说明<a class="link" href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setparent">SetParent Doc<i class="fas fa-external-link-alt"></i></a>。</p><p>由于兼容性问题，SetParent函数不会修改hWndChild窗口的<code>WS_CHILD</code>和<code>WS_POPUP</code>样式，因此：</p><ul><li>如果hWndNewParent为NULL，你需要在调用SetParent函数<strong>后</strong>清除<code>WS_CHILD</code>并设置<code>WS_POPUP</code>样式。</li><li>如果hWndNewParent不为NULL并且hWndChild之前是桌面的子窗口，你需要在调用SetParent函数<strong>前</strong>清除<code>WS_POPUP</code>并设置<code>WS_CHILD</code>样式。</li></ul><p>总结上述原因，SetParent的正确使用方法如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SetWinParent</span><span class="params">(HWND hChild, HWND hNewParent)</span> </span>{</span><br><span class="line">    HWND hOldParent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (hNewParent) {</span><br><span class="line">        LONG newStyle = <span class="built_in">GetWindowLong</span>(hChild, GWL_STYLE);</span><br><span class="line"></span><br><span class="line">        newStyle &amp;= ~WS_POPUP;</span><br><span class="line">        newStyle |= WS_CHILD;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">SetWindowLong</span>(hChild, GWL_STYLE, newStyle);</span><br><span class="line"></span><br><span class="line">        hOldParent = ::<span class="built_in">SetParent</span>(hChild, hNewParent);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        hOldParent = ::<span class="built_in">SetParent</span>(hChild, hNewParent);</span><br><span class="line"></span><br><span class="line">        LONG newStyle = <span class="built_in">GetWindowLong</span>(hChild, GWL_STYLE);</span><br><span class="line"></span><br><span class="line">        newStyle &amp;= ~WS_CHILD;</span><br><span class="line">        newStyle |= WS_POPUP;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">SetWindowLong</span>(hChild, GWL_STYLE, newStyle);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> !!hOldParent;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;SetParent是Windows提供的设置窗口父窗体的API，函数原型比较简单：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;HWND &lt;span class=&quot;title&quot;&gt;SetParent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;function&quot;&gt;  [in]           HWND hWndChild,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;function&quot;&gt;  [in, optional] HWND hWndNewParent&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;function&quot;&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="① 专栏集锦" scheme="https://jiangxueqiao.com/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/"/>
    
    <category term="Windows核心编程" scheme="https://jiangxueqiao.com/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>窗口如何逃脱显示桌面指令</title>
    <link href="https://jiangxueqiao.com/post/2065788833.html"/>
    <id>https://jiangxueqiao.com/post/2065788833.html</id>
    <published>2023-10-31T15:55:23.000Z</published>
    <updated>2023-11-14T04:18:32.939Z</updated>
    
    <content type="html"><![CDATA[<p>在Windows系统中，在按下Win+D快捷键等操作执行“显示桌面”时，会将桌面上的所有窗口都最小化到任务栏，再次按下还原窗口。在显示桌面时，有些窗口仍然保持显示状态，不被最小话，即称之为逃脱显示桌面指令。</p><p>实现逃脱显示桌面的方式有三种，每种方式有不同的应用场景。</p><span id="more"></span><h2 id="一、置顶窗口的方式"><a href="#一、置顶窗口的方式" class="headerlink" title="一、置顶窗口的方式"></a>一、置顶窗口的方式</h2><p>首先创建WS_EX_TOOLWINDOW风格的窗口，WS_EX_TOOLWINDOW风格的窗口不会出现在任务栏，而且按<code>ALT+TAB</code>时也不会显示，然后为该窗口设置WS_EX_TOPMOST样式，使其始终置顶。</p><p>可以在创建窗口时通过扩展样式来指定WS_EX_TOOLWINDOW和WS_EX_TOPMOST样式：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HWND hWnd = <span class="built_in">CreateWindowExW</span>(</span><br><span class="line">    WS_EX_TOOLWINDOW | WS_EX_TOPMOST,</span><br><span class="line">    szWindowClass,</span><br><span class="line">    szTitle,</span><br><span class="line">    WS_OVERLAPPEDWINDOW,</span><br><span class="line">    CW_USEDEFAULT,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    CW_USEDEFAULT,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    hInstance,</span><br><span class="line">    <span class="literal">nullptr</span>);</span><br></pre></td></tr></tbody></table></figure><p>也可以先创建窗口，然后修改窗口样式：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LONG_PTR oldStyle = <span class="built_in">GetWindowLongPtr</span>(hWnd, GWL_EXSTYLE);</span><br><span class="line">oldStyle |= WS_EX_TOOLWINDOW;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetWindowLongPtr</span>(hWnd, GWL_EXSTYLE, oldStyle);</span><br></pre></td></tr></tbody></table></figure><p>并通过SetWindowPos函数来置顶窗口：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetWindowPos</span>(hWnd, HWND_TOPMOST, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, SWP_NOSIZE | SWP_NOMOVE);</span><br></pre></td></tr></tbody></table></figure><p>这种方式对系统的兼容性比较好，经测试可以支持Windows XP/7/8/10/11系统。但这种方式会导致窗口一直置顶显示，对于不需要置顶显示的窗口，这种方式就不适用了。</p><h2 id="二、改变窗口所有者的方式"><a href="#二、改变窗口所有者的方式" class="headerlink" title="二、改变窗口所有者的方式"></a>二、改变窗口所有者的方式</h2><p>在执行显示桌面指令时，桌面仍然会显示，因此我们可以将窗口的所有者设置为桌面窗口，来确保窗口不受“显示桌面”指令的影响。</p><h3 id="2-1-查找桌面窗口"><a href="#2-1-查找桌面窗口" class="headerlink" title="2.1 查找桌面窗口"></a>2.1 查找桌面窗口</h3><p>在Win7及之前的系统中，桌面窗口是Program Manager窗口的子窗口，如下图所示：<br><img lazyload="" alt="image" data-src="https://blog-static.jiangxueqiao.com/blog/img/win7-shelldll-defview-TinyTu.png"></p><p>而在Win8及以后的系统，桌面窗口变成了WorkerW窗口的子窗口，如下图所示：<br><img lazyload="" alt="image" data-src="https://blog-static.jiangxueqiao.com/blog/img/win11-shelldll-defview.png"></p><p>因此在查找桌面窗口句柄时，需要根据不同的系统环境采用不同的查找方式。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">FindShellDefViewWnd</span><span class="params">()</span> </span>{</span><br><span class="line">    HWND hShellDefView = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try Win7 and later</span></span><br><span class="line">    HWND hProgmanWnd = <span class="built_in">FindWindowW</span>(<span class="string">L"Progman"</span>, <span class="string">L"Program Manager"</span>);</span><br><span class="line">    <span class="keyword">if</span> (hProgmanWnd) {</span><br><span class="line">        hShellDefView = <span class="built_in">FindWindowExW</span>(hProgmanWnd, <span class="literal">NULL</span>, <span class="string">L"SHELLDLL_DefView"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try &gt; Win7</span></span><br><span class="line">    <span class="keyword">if</span> (!hShellDefView) {</span><br><span class="line">        <span class="comment">// When this fails, then look for the WorkerW windows list to get the correct desktop list handle.</span></span><br><span class="line">        HWND hDesktop = <span class="built_in">GetDesktopWindow</span>();</span><br><span class="line">        HWND hWorkerW = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            hWorkerW = <span class="built_in">FindWindowExW</span>(hDesktop, hWorkerW, <span class="string">L"WorkerW"</span>, <span class="literal">NULL</span>);</span><br><span class="line">            hShellDefView = <span class="built_in">FindWindowExW</span>(hWorkerW, <span class="literal">NULL</span>, <span class="string">L"SHELLDLL_DefView"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        } <span class="keyword">while</span> (hShellDefView == <span class="literal">NULL</span> &amp;&amp; hWorkerW != <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> hShellDefView;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-设置窗口拥有者"><a href="#2-2-设置窗口拥有者" class="headerlink" title="2.2 设置窗口拥有者"></a>2.2 设置窗口拥有者</h3><p>现在我们将窗口的拥有者设置为SHELLDLL_DefView窗口即可逃脱显示桌面的指令了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EscapeShowDesktop</span><span class="params">(HWND hWnd)</span> </span>{</span><br><span class="line">    HWND hShellDefView = <span class="built_in">FindShellDefViewWnd</span>();</span><br><span class="line">    <span class="keyword">if</span> (hShellDefView) {</span><br><span class="line">        <span class="built_in">SetWindowLongPtr</span>(hWnd, GWL_HWNDPARENT, (LONG_PTR)hShellDefView);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>需要注意：</strong> </p><p>采用这种方式可能会导致当前的活动桌面发生改变，这个行为会对某些Windows API产生影响，如会导致<code>GetAsyncKeyState</code>失效。</p></blockquote><h2 id="三、使用Appbar机制实现"><a href="#三、使用Appbar机制实现" class="headerlink" title="三、使用Appbar机制实现"></a>三、使用Appbar机制实现</h2><p>Windows提供了API来使应用程序具有模拟系统任务栏的能力，通常将模拟系统任务栏的程序成为Appbar（application desktop toolbar）。<br>Appbar窗口不受显示桌面指令的控制，但该窗口会和任务栏一样占据一部分桌面可用空间，可以通过API控制占用空间的大小和位置。</p><p>关于如何使用Appbar的API，可以参考Windows官方文档:<br><a class="link" href="https://learn.microsoft.com/en-us/previous-versions//bb776821(v=vs.85)?redirectedfrom=MSDN">Using Application Desktop Toolbars<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Windows系统中，在按下Win+D快捷键等操作执行“显示桌面”时，会将桌面上的所有窗口都最小化到任务栏，再次按下还原窗口。在显示桌面时，有些窗口仍然保持显示状态，不被最小话，即称之为逃脱显示桌面指令。&lt;/p&gt;
&lt;p&gt;实现逃脱显示桌面的方式有三种，每种方式有不同的应用场景。&lt;/p&gt;</summary>
    
    
    
    <category term="① 专栏集锦" scheme="https://jiangxueqiao.com/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/"/>
    
    <category term="Windows核心编程" scheme="https://jiangxueqiao.com/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>认识Windows顶级(top-level)窗口</title>
    <link href="https://jiangxueqiao.com/post/1431775047.html"/>
    <id>https://jiangxueqiao.com/post/1431775047.html</id>
    <published>2023-10-24T05:55:23.000Z</published>
    <updated>2023-11-01T03:55:13.555Z</updated>
    
    <content type="html"><![CDATA[<p>在Windows API中经常会出现关于顶级窗口的描述，如EnumWindows：</p><p>Enumerates all <strong>top-level</strong> windows on the screen by passing the handle to each window, in turn, to an application-defined callback function. EnumWindows continues until the last top-level window is enumerated or the callback function returns FALSE.</p><p>那么什么样的窗口才算得上是顶级窗口了？</p><p>简而言之，没有<code>WM_CHILD</code>属性的窗口都可以称为顶级窗口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Windows API中经常会出现关于顶级窗口的描述，如EnumWindows：&lt;/p&gt;
&lt;p&gt;Enumerates all &lt;strong&gt;top-level&lt;/strong&gt; windows on the screen by passing the handle to</summary>
      
    
    
    
    <category term="① 专栏集锦" scheme="https://jiangxueqiao.com/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/"/>
    
    <category term="Windows核心编程" scheme="https://jiangxueqiao.com/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Qt中图片按九宫格模式缩放</title>
    <link href="https://jiangxueqiao.com/post/333631906.html"/>
    <id>https://jiangxueqiao.com/post/333631906.html</id>
    <published>2023-10-22T15:12:21.000Z</published>
    <updated>2023-11-01T03:53:42.579Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，我们在缩放图片时没办法保持原图的长宽比，如保持图片高度不变仅拉伸宽度等，此时在不保持长宽比的情况进行图片缩放会导致图片变形。为了解决这种问题，我们可以考虑使用九宫格模式进行图片的缩放。</p><p>九宫格模式就是将图片切分为九块，不强制等分，如下图所示，在图片缩放时，我们通常保持1、3、7、9四个顶点位置的图片不变，对2、4、5、6、8五个区域进行缩放。</p><p><img lazyload="" alt="image" data-src="https://blog-static.jiangxueqiao.com/blog/img/jiugongge.png"></p><span id="more"></span><h2 id="1-使用QSS实现"><a href="#1-使用QSS实现" class="headerlink" title="1. 使用QSS实现"></a>1. 使用QSS实现</h2><p>在Qt中实现图片按九宫格缩放最简单的方法是使用QSS的<code>border-image</code>属性来实现，通过上下左右四个边框的宽度或高度来设置1、3、7、9四个顶点的大小。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">:/Sample/image/NinePatchTest.png</span>);</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">210px</span>;</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">180px</span>;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">227px</span>;</span><br></pre></td></tr></tbody></table></figure><p>为了便于测试，我制作了一个九宫格测试图片（整个图片宽高为1280*720）：</p><p><img lazyload="" alt="image" data-src="https://blog-static.jiangxueqiao.com/blog/img/NinePatchTest.png"></p><p>通过这种方法实现的九宫格缩放有一个弊端：</p><p>该方案会始终保持1、3、7、9四个区域图片的宽高不变，如1号区域是<code>210*180</code>，当我们对图片进行放大时，这个行为是没有问题的，但当我们缩小图片时，缩小后的图片宽高不足以容纳4个顶角图片时，缩小操作就会出现非预期的行为，可能如下图所示：</p><p><img lazyload="" alt="image" data-src="https://blog-static.jiangxueqiao.com/blog/img/feiyuqitupiansuofang-1.png"></p><p>这种弊端还会体现在支持高DPI缩放的Qt程序中，例如在一个支持DPI缩放的程序中，对一个宽高为<code>640*360</code>的QWidget设置背景图片，我们知道不同的<code>devicePixelRatio</code>会导致实际渲染的图片宽高不同，如devicePixelRatio为1时图片渲染区域为<code>640*360</code>， 而devicePixelRatio为2时渲染区域为<code>1280*720</code>，为了保证程序在不同DPI的环境下都有比较好的界面呈现，我们通常简单得（当然也可以使用SVG或为不同DPI支持不同的图片）指定一个倍图（如2倍图）让程序自动进行图片缩放。而使用<code>border-left</code>等属性指定的宽度是固定的，顶点图片无法参与到自动缩放中来，从而会导致这一DPI适配机制失效。下一节介绍的方法可以解决这一弊端。</p><h2 id="2-使用代码实现九宫格缩放"><a href="#2-使用代码实现九宫格缩放" class="headerlink" title="2. 使用代码实现九宫格缩放"></a>2. 使用代码实现九宫格缩放</h2><p>本节介绍使用代码实现图片九宫格模式缩放，实现原理大致是：</p><p>提取九个区域的图片，保持1、3、7、9四个图片不变，对2、4、5、6、8五个区域图片进行缩放，分别得到新的图片，最后再将九个区域的图片合并成一张图。</p><h3 id="如何解决上述QSS方案的弊端？"><a href="#如何解决上述QSS方案的弊端？" class="headerlink" title="如何解决上述QSS方案的弊端？"></a>如何解决上述QSS方案的弊端？</h3><p>为了解决上述QSS方案的弊端，我们可以采取先将图片在保持长宽比的情况缩放到相应尺寸：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPixmap keepRatioScaledPix = src.<span class="built_in">scaled</span>(destSize, Qt::KeepAspectRatio, Qt::SmoothTransformation);</span><br></pre></td></tr></tbody></table></figure><p>由于keepRatioScaledPix实际尺寸肯定与我们想要得到的destSize不匹配，所以我们再把keepRatioScaledPix图片按九宫格模式缩放。</p><p>具体实现代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">ScaleByNinePatch</span><span class="params">(<span class="type">const</span> QPixmap&amp; src, <span class="comment">// 原图</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         QSize destSize, <span class="comment">// 目标尺寸</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">bool</span> keepVertexImageSize,  <span class="comment">// 是否保持1、3、7、9顶点图片大小不变，设置为true则与QSS方式效果类似（仅类似，因为该函数是直接返回原图）</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int</span> pos1Width, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int</span> pos1Height, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int</span> pos3Width, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int</span> pos7Height, </span></span></span><br><span class="line"><span class="params"><span class="function">                        Qt::TransformationMode mode = Qt::SmoothTransformation)</span> </span>{</span><br><span class="line">    <span class="comment">// 参数校准</span></span><br><span class="line">    pos1Width = <span class="built_in">qMax</span>(pos1Width, <span class="number">0</span>);</span><br><span class="line">    pos1Height = <span class="built_in">qMax</span>(pos1Height, <span class="number">0</span>);</span><br><span class="line">    pos3Width = <span class="built_in">qMax</span>(pos3Width, <span class="number">0</span>);</span><br><span class="line">    pos7Height = <span class="built_in">qMax</span>(pos7Height, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> handlePixW = <span class="number">0</span>, handlePixH = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> QPixmap* handlePix = <span class="literal">nullptr</span>;</span><br><span class="line">    QPixmap keepRatioScaledPix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (keepVertexImageSize) {</span><br><span class="line">        <span class="comment">// 保持顶点图片大小不变的情况，如果顶点图片宽或高已经大于了目标宽高，则直接返回原图</span></span><br><span class="line">        <span class="keyword">if</span> (pos1Width + pos3Width &gt; destSize.<span class="built_in">width</span>() || pos1Height + pos7Height &gt; destSize.<span class="built_in">height</span>())</span><br><span class="line">            <span class="keyword">return</span> src;</span><br><span class="line"></span><br><span class="line">        handlePixW = src.<span class="built_in">width</span>();</span><br><span class="line">        handlePixH = src.<span class="built_in">height</span>();</span><br><span class="line">        handlePix = &amp;src;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">const</span> qreal srcW = src.<span class="built_in">width</span>();</span><br><span class="line">        <span class="type">const</span> qreal srcH = src.<span class="built_in">height</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先等比缩放到适合的尺寸</span></span><br><span class="line">        keepRatioScaledPix = src.<span class="built_in">scaled</span>(destSize, Qt::KeepAspectRatio, mode);</span><br><span class="line">        handlePixW = keepRatioScaledPix.<span class="built_in">width</span>();</span><br><span class="line">        handlePixH = keepRatioScaledPix.<span class="built_in">height</span>();</span><br><span class="line">        qreal krsPixWidth = handlePixW;</span><br><span class="line">        qreal krsPixHeight = handlePixH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照之前的比例获取新顶点图片的大小</span></span><br><span class="line">        pos1Width = krsPixWidth * (qreal)pos1Width / srcW;</span><br><span class="line">        pos1Height = krsPixHeight * (qreal)pos1Height / srcH;</span><br><span class="line">        pos3Width = krsPixWidth * (qreal)pos3Width / srcW;</span><br><span class="line">        pos7Height = krsPixHeight * (qreal)pos7Height / srcH;</span><br><span class="line"></span><br><span class="line">        handlePix = &amp;keepRatioScaledPix;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提前各个区域图片</span></span><br><span class="line">    QPixmap pix1 = handlePix-&gt;<span class="built_in">copy</span>(<span class="number">0</span>, <span class="number">0</span>, pos1Width, pos1Height);</span><br><span class="line">    QPixmap pix2 = handlePix-&gt;<span class="built_in">copy</span>(pos1Width, <span class="number">0</span>, <span class="built_in">qMax</span>(handlePixW - pos1Width - pos3Width, <span class="number">0</span>), pos1Height);</span><br><span class="line">    QPixmap pix3 = handlePix-&gt;<span class="built_in">copy</span>(<span class="built_in">qMax</span>(handlePixW - pos3Width, <span class="number">0</span>), <span class="number">0</span>, pos3Width, pos1Height);</span><br><span class="line">    QPixmap pix4 = handlePix-&gt;<span class="built_in">copy</span>(<span class="number">0</span>, pos1Height, pos1Width, <span class="built_in">qMax</span>(handlePixH - pos1Height - pos7Height, <span class="number">0</span>));</span><br><span class="line">    QPixmap pix5 = handlePix-&gt;<span class="built_in">copy</span>(pos1Width, pos1Height, <span class="built_in">qMax</span>(handlePixW - pos1Width - pos3Width, <span class="number">0</span>), <span class="built_in">qMax</span>(handlePixH - pos1Height - pos7Height, <span class="number">0</span>));</span><br><span class="line">    QPixmap pix6 = handlePix-&gt;<span class="built_in">copy</span>(<span class="built_in">qMax</span>(handlePixW - pos3Width, <span class="number">0</span>), pos1Height, pos3Width, <span class="built_in">qMax</span>(handlePixH - pos1Height - pos7Height, <span class="number">0</span>));</span><br><span class="line">    QPixmap pix7 = handlePix-&gt;<span class="built_in">copy</span>(<span class="number">0</span>, <span class="built_in">qMax</span>(handlePixH - pos7Height, <span class="number">0</span>), pos1Width, pos7Height);</span><br><span class="line">    QPixmap pix8 = handlePix-&gt;<span class="built_in">copy</span>(pos1Width, <span class="built_in">qMax</span>(handlePixH - pos7Height, <span class="number">0</span>), <span class="built_in">qMax</span>(handlePixW - pos1Width - pos3Width, <span class="number">0</span>), pos7Height);</span><br><span class="line">    QPixmap pix9 = handlePix-&gt;<span class="built_in">copy</span>(<span class="built_in">qMax</span>(handlePixW - pos3Width, <span class="number">0</span>), <span class="built_in">qMax</span>(handlePixH - pos7Height, <span class="number">0</span>), pos3Width, pos7Height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对2、4、5、6、8区域图片进行缩放</span></span><br><span class="line">    pix2 = pix2.<span class="built_in">scaled</span>(<span class="built_in">qMax</span>(destSize.<span class="built_in">width</span>() - pos1Width - pos3Width, <span class="number">0</span>), pos1Height, Qt::IgnoreAspectRatio, mode);</span><br><span class="line">    pix4 = pix4.<span class="built_in">scaled</span>(pos1Width, <span class="built_in">qMax</span>(destSize.<span class="built_in">height</span>() - pos1Height - pos7Height, <span class="number">0</span>), Qt::IgnoreAspectRatio, mode);</span><br><span class="line">    pix5 = pix5.<span class="built_in">scaled</span>(<span class="built_in">qMax</span>(destSize.<span class="built_in">width</span>() - pos1Width - pos3Width, <span class="number">0</span>), <span class="built_in">qMax</span>(destSize.<span class="built_in">height</span>() - pos1Height - pos7Height, <span class="number">0</span>), Qt::IgnoreAspectRatio, mode);</span><br><span class="line">    pix6 = pix6.<span class="built_in">scaled</span>(pos3Width, <span class="built_in">qMax</span>(destSize.<span class="built_in">height</span>() - pos1Height - pos7Height, <span class="number">0</span>), Qt::IgnoreAspectRatio, mode);</span><br><span class="line">    pix8 = pix8.<span class="built_in">scaled</span>(<span class="built_in">qMax</span>(destSize.<span class="built_in">width</span>() - pos1Width - pos3Width, <span class="number">0</span>), pos7Height, Qt::IgnoreAspectRatio, mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接新的图片</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">dest</span><span class="params">(destSize)</span></span>;</span><br><span class="line">    dest.<span class="built_in">fill</span>(Qt::transparent); <span class="comment">// 使用透明色填充图片</span></span><br><span class="line"></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(&amp;dest)</span></span>;</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, <span class="number">0</span>, pix1);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(pos1Width, <span class="number">0</span>, pix2);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="built_in">qMax</span>(destSize.<span class="built_in">width</span>() - pos3Width, <span class="number">0</span>), <span class="number">0</span>, pix3);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, pos1Height, pix4);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(pos1Width, pos1Height, pix5);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="built_in">qMax</span>(destSize.<span class="built_in">width</span>() - pos3Width, <span class="number">0</span>), pos1Height, pix6);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, <span class="built_in">qMax</span>(destSize.<span class="built_in">height</span>() - pos7Height, <span class="number">0</span>), pix7);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(pos1Width, <span class="built_in">qMax</span>(destSize.<span class="built_in">height</span>() - pos7Height, <span class="number">0</span>), pix8);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="built_in">qMax</span>(destSize.<span class="built_in">width</span>() - pos3Width, <span class="number">0</span>), <span class="built_in">qMax</span>(destSize.<span class="built_in">height</span>() - pos7Height, <span class="number">0</span>), pix9);</span><br><span class="line">    painter.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>调试小技巧：</p><p>可以把每个区域的图片保存到本地，查看图片是否正确，如：<br>    </p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pix1.<span class="built_in">save</span>(<span class="string">"D:\\1.png"</span>);</span><br><span class="line">pix2.<span class="built_in">save</span>(<span class="string">"D:\\2.png"</span>);</span><br><span class="line">pix3.<span class="built_in">save</span>(<span class="string">"D:\\3.png"</span>);</span><br><span class="line">pix4.<span class="built_in">save</span>(<span class="string">"D:\\4.png"</span>);</span><br><span class="line">pix5.<span class="built_in">save</span>(<span class="string">"D:\\5.png"</span>);</span><br><span class="line">pix6.<span class="built_in">save</span>(<span class="string">"D:\\6.png"</span>);</span><br><span class="line">pix7.<span class="built_in">save</span>(<span class="string">"D:\\7.png"</span>);</span><br><span class="line">pix8.<span class="built_in">save</span>(<span class="string">"D:\\8.png"</span>);</span><br><span class="line">pix9.<span class="built_in">save</span>(<span class="string">"D:\\9.png"</span>);</span><br></pre></td></tr></tbody></table></figure><p></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;有时候，我们在缩放图片时没办法保持原图的长宽比，如保持图片高度不变仅拉伸宽度等，此时在不保持长宽比的情况进行图片缩放会导致图片变形。为了解决这种问题，我们可以考虑使用九宫格模式进行图片的缩放。&lt;/p&gt;
&lt;p&gt;九宫格模式就是将图片切分为九块，不强制等分，如下图所示，在图片缩放时，我们通常保持1、3、7、9四个顶点位置的图片不变，对2、4、5、6、8五个区域进行缩放。&lt;/p&gt;
&lt;p&gt;&lt;img lazyload=&quot;&quot; alt=&quot;image&quot; data-src=&quot;https://blog-static.jiangxueqiao.com/blog/img/jiugongge.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="② C++" scheme="https://jiangxueqiao.com/categories/%E2%91%A1-C/"/>
    
    <category term="Qt" scheme="https://jiangxueqiao.com/categories/%E2%91%A1-C/Qt/"/>
    
    
  </entry>
  
  <entry>
    <title>《Windows套接字I/O模型》</title>
    <link href="https://jiangxueqiao.com/post/3383048230.html"/>
    <id>https://jiangxueqiao.com/post/3383048230.html</id>
    <published>2023-10-10T12:14:07.000Z</published>
    <updated>2023-11-01T04:10:46.336Z</updated>
    
    <content type="html"><![CDATA[<p>本栏目主要介绍Windows网络编程中涉及的一些网络模型，如WSAEventSelect模型，WSAAsyncSelect模型，完成端口模型等。</p><span id="more"></span><p>文章列表：</p><ul><li><a href="/post/2937580891.html" title="Windows套接字I/O模型(1)-阻塞模型">Windows套接字I/O模型(1)-阻塞模型</a></li><li><a href="/post/640627104.html" title="Windows套接字I/O模型(2)-Select模型">Windows套接字I/O模型(2)-Select模型</a></li><li><a href="/post/2544551173.html" title="Windows套接字I/O模型(3)-WSAAsyncSelect模型">Windows套接字I/O模型(3)-WSAAsyncSelect模型</a></li><li><a href="/post/547434843.html" title="Windows套接字I/O模型(4)-WSAEventSelect模型">Windows套接字I/O模型(4)-WSAEventSelect模型</a></li><li><a href="/post/326824759.html" title="Windows套接字I/O模型(5)-完成端口模型">Windows套接字I/O模型(5)-完成端口模型</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本栏目主要介绍Windows网络编程中涉及的一些网络模型，如WSAEventSelect模型，WSAAsyncSelect模型，完成端口模型等。&lt;/p&gt;</summary>
    
    
    
    <category term="① 专栏集锦" scheme="https://jiangxueqiao.com/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/"/>
    
    <category term="Windows套接字I/O模型" scheme="https://jiangxueqiao.com/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E5%A5%97%E6%8E%A5%E5%AD%97I-O%E6%A8%A1%E5%9E%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>小懒【转载】</title>
    <link href="https://jiangxueqiao.com/post/2501563677.html"/>
    <id>https://jiangxueqiao.com/post/2501563677.html</id>
    <published>2023-10-08T13:30:24.000Z</published>
    <updated>2024-03-01T07:49:37.367Z</updated>
    
    <content type="html"><![CDATA[<p>人生于世，一味勤，不见得是好事。</p><p>与人处，得小懒。管头管脚，大到原则问题，小至鸡毛蒜皮，样样都想插一手。这样的相处模式，除了惹人厌，再难有其他结果。容他人藏点隐私，给彼此留点空间，这样的小懒，比起所谓的无微不至更令人欣赏。</p><p>与人言，也得小懒。话不能说得太满，意犹未尽之处，于人于已都是余地。留有这样的余地，日后才好转圜。同样的意思，横冲直撞与婉转留余，可能带来不同的结果。留一线，好相见，这样的留，自然是小懒。</p><span id="more"></span><p>言语中的小懒，还在于倾听。话不说满，这满是话意，也是话频。一味照着自己的频率说，不顾对方的感受，也不理会对方的想法。这种单方面的所谓沟通，比起无言的槛尬，更令人心生庆烦。话不能说得太满，也不能说得太勤，时时带着点小懒，关注对方的心思，给对方表达的机会，这才是两相宜的沟通方式。</p><p>独处，也得带点小懒。忙忙碌碌，俗务缠身，这是很多人的常态。但再忙，总得有那么一些时光，一个人，一本书，一盏茶，静享闲暇之乐。紧绷与小懒，劳与逸，两相结合，人生的路才能走得更远。</p><p>养儿育女，其实也需要小懒。能干的父母，容易养出懒情的儿女。事无巨细，大包大揽，自然会让儿女养成依赖的习惯。久而久之，习惯就成了本性。到那时，再怎么怨叹，也无济于事。</p><p>人生的小懒，不同于彻底躺平的大懒，也不是任由本性的放纵。一路奔跑之余，总得留有那么一点儿时光，来放任自己的小懒。这样的小懒，如春日的阳光，又似秋日的微风，不多不少，却刚刚好。</p><blockquote><p>作者：郭华悦</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;人生于世，一味勤，不见得是好事。&lt;/p&gt;
&lt;p&gt;与人处，得小懒。管头管脚，大到原则问题，小至鸡毛蒜皮，样样都想插一手。这样的相处模式，除了惹人厌，再难有其他结果。容他人藏点隐私，给彼此留点空间，这样的小懒，比起所谓的无微不至更令人欣赏。&lt;/p&gt;
&lt;p&gt;与人言，也得小懒。话不能说得太满，意犹未尽之处，于人于已都是余地。留有这样的余地，日后才好转圜。同样的意思，横冲直撞与婉转留余，可能带来不同的结果。留一线，好相见，这样的留，自然是小懒。&lt;/p&gt;</summary>
    
    
    
    <category term="⑬ 美文赏析" scheme="https://jiangxueqiao.com/categories/%E2%91%AC-%E7%BE%8E%E6%96%87%E8%B5%8F%E6%9E%90/"/>
    
    
    <category term="转载" scheme="https://jiangxueqiao.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>MSVC版本的二进制兼容性</title>
    <link href="https://jiangxueqiao.com/post/3437796039.html"/>
    <id>https://jiangxueqiao.com/post/3437796039.html</id>
    <published>2023-10-07T14:41:03.000Z</published>
    <updated>2024-02-29T10:04:29.554Z</updated>
    
    <content type="html"><![CDATA[<p>Visual Studio 2013 及更早版本中的 Microsoft C++ (MSVC) 编译器工具集<strong>不保证</strong>主版本间的二进制兼容性，无法链接由不同版本工具集生成的对象文件、静态库、动态库和可执行文件，因为ABI、对象格式和运行时库不兼容。</p><p>微软在 Visual Studio 2015 及更高版本中改变了这个行为。对于自 Visual Studio 2015 以来的所有版本（<strong>该版本号都以 14 开头</strong>，如Visual Studio 2015、2017、2019 和 2022工具集的版本分别为 v140、v141、v142 和 v143）由其中任一版本编译器编译的运行时库和应用都具有二进制兼容性。</p><p>假设你使用 Visual Studio 2015 生成第三方库，你仍可在 Visual Studio 2017、2019 或 2022 生成的应用程序中使用它们，无需使用匹配工具集重新编译。 同时最新版本的 Microsoft Visual C++ 可再发行程序包（运行时库）也兼容所有老版本，无需为不同版本安装不同的运行时库，统一安装最新版本即可。</p><span id="more"></span><h2 id="对二进制兼容性的限制"><a href="#对二进制兼容性的限制" class="headerlink" title="对二进制兼容性的限制"></a>对二进制兼容性的限制</h2><p>v140、v141、v142 和 v143 工具集与次要版本号更新之间的二进制兼容性方面存在三个重要限制：</p><ul><li><p>你可以混合使用由 v140、v141、v142 和 v143 工具集的不同版本生成的二进制文件。 但是，<strong>必须使用至少与应用中最新二进制文件同样新的工具集进行链接</strong>。 下面是一个示例：可以将使用任何版本的v141工具集（版本 15.0 到 15.9）编译的应用链接到使用 Visual Studio 2019 版本 16.2 (v142) 编译的静态库。 只是必须使用版本 16.2 或更高版本工具集链接它们。只要使用 16.4 或更高版本工具集，便可以将版本 16.2 库链接到版本 16.4 应用。</p></li><li><p>应用使用的可再发行程序包具有类似的二进制兼容性限制。 混合使用由工具集的不同受支持版本生成的二进制文件时，可再发行程序包版本必须至少与任何应用组件使用的最新工具集一样新。</p></li><li><p>使用 <a class="link" href="https://learn.microsoft.com/zh-cn/cpp/build/reference/gl-whole-program-optimization?view=msvc-170">/GL<i class="fas fa-external-link-alt"></i></a><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/build/reference/gl-whole-program-optimization?view=msvc-170">（全程序优化）<i class="fas fa-external-link-alt"></i></a>编译器开关编译或是使用 <a class="link" href="https://learn.microsoft.com/zh-cn/cpp/build/reference/ltcg-link-time-code-generation?view=msvc-170">/LTCG<i class="fas fa-external-link-alt"></i></a><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/build/reference/ltcg-link-time-code-generation?view=msvc-170">（链接时间代码生成）<i class="fas fa-external-link-alt"></i></a>链接的静态库或对象文件不在各个版本间二进制兼容（包括次要版本更新）。</p><p>使用 <code>/GL</code> 和 <code>/LTCG</code> 编译的所有对象文件和库必须将完全相同的工具集用于编译和最终链接。 例如，使用 Visual Studio 2019 版本 16.7 工具集中的 <code>/GL</code> 生成的代码无法链接到使用 Visual Studio 2019 版本 16.8 工具集中的 <code>/GL</code>生成的代码。 编译器会发出<a class="link" href="https://learn.microsoft.com/zh-cn/cpp/error-messages/compiler-errors-1/fatal-error-c1047?view=msvc-170">错误 C1047<i class="fas fa-external-link-alt"></i></a>。</p></li></ul><h2 id="从-Visual-Studio-2015-及更高版本升级-Microsoft-Visual-C-可再发行程序包"><a href="#从-Visual-Studio-2015-及更高版本升级-Microsoft-Visual-C-可再发行程序包" class="headerlink" title="从 Visual Studio 2015 及更高版本升级 Microsoft Visual C++ 可再发行程序包"></a>从 Visual Studio 2015 及更高版本升级 Microsoft Visual C++ 可再发行程序包</h2><p>对于 Visual Studio 2015、2017、2019 和 2022，微软将 Microsoft Visual C++ 可再发行程序包的主版本号保持一致。 这意味着我们一次只能安装可再发行程序包的一个实例。 较新版本会覆盖已安装的任何较旧版本。 例如，一个应用可能会从 Visual Studio 2015 安装可再发行程序包。 随后另一个应用从 Visual Studio 2022 安装可再发行程序包。 2022 版本会覆盖较旧版本，但由于它们具有二进制兼容性，早期应用仍可正常工作。 微软确保最新版本的可再发行程序包具有所有最新的功能、安全更新和 bug 修补程序。 这便是为什么微软始终建议升级到最新可用版本。</p><p>同样，已安装了较新版本时，无法安装较旧的可再发行程序包。 如果尝试，则安装程序会报告错误。 如果在已具有 2022 版本的计算机上安装 2017 或 2019 可再发行程序，则会看到如下所示的错误：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x80070666 - Another version of this product is already installed. Installation of this version cannot continue. To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel.</span><br></pre></td></tr></tbody></table></figure><p>此错误是微软故意这样设计的，以确保Microsoft Visual C++ 可再发行程序包为最新版本。 </p><blockquote><p>本文参考：<a class="link" href="https://learn.microsoft.com/zh-cn/cpp/porting/binary-compat-2015-2017?view=msvc-170">Visual Studio 版本之间的 C++ 二进制兼容性<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Visual Studio 2013 及更早版本中的 Microsoft C++ (MSVC) 编译器工具集&lt;strong&gt;不保证&lt;/strong&gt;主版本间的二进制兼容性，无法链接由不同版本工具集生成的对象文件、静态库、动态库和可执行文件，因为ABI、对象格式和运行时库不兼容。&lt;/p&gt;
&lt;p&gt;微软在 Visual Studio 2015 及更高版本中改变了这个行为。对于自 Visual Studio 2015 以来的所有版本（&lt;strong&gt;该版本号都以 14 开头&lt;/strong&gt;，如Visual Studio 2015、2017、2019 和 2022工具集的版本分别为 v140、v141、v142 和 v143）由其中任一版本编译器编译的运行时库和应用都具有二进制兼容性。&lt;/p&gt;
&lt;p&gt;假设你使用 Visual Studio 2015 生成第三方库，你仍可在 Visual Studio 2017、2019 或 2022 生成的应用程序中使用它们，无需使用匹配工具集重新编译。 同时最新版本的 Microsoft Visual C++ 可再发行程序包（运行时库）也兼容所有老版本，无需为不同版本安装不同的运行时库，统一安装最新版本即可。&lt;/p&gt;</summary>
    
    
    
    <category term="⑩ 编程基础" scheme="https://jiangxueqiao.com/categories/%E2%91%A9-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Vcpkg使用仓库最新代码</title>
    <link href="https://jiangxueqiao.com/post/2065175920.html"/>
    <id>https://jiangxueqiao.com/post/2065175920.html</id>
    <published>2023-10-04T22:56:36.000Z</published>
    <updated>2023-11-01T03:48:39.396Z</updated>
    
    <content type="html"><![CDATA[<p>在向Vcpkg提交port时，我们会不断地对仓库进行修改和调试。如果采用<code>REF</code>方式指定源码版本，则需要不断地修改REF和SHA512，我们可以采用<code>HEAD_REF</code>的方式来简化调试流程。</p><p>在<code>portfile.cmake</code>文件中指定<code>HEAD_REF</code>，如：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vcpkg_from_github(</span><br><span class="line">    OUT_SOURCE_PATH SOURCE_PATH</span><br><span class="line">    REPO winsoft666/ashe</span><br><span class="line">    HEAD_REF main</span><br><span class="line">    AUTHORIZATION_TOKEN $ENV{GITHUB_TOKEN}</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>安装时指定<code>--head</code>参数：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg <span class="keyword">install</span> ashe:x64-windows-static --head</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在向Vcpkg提交port时，我们会不断地对仓库进行修改和调试。如果采用&lt;code&gt;REF&lt;/code&gt;方式指定源码版本，则需要不断地修改REF和SHA512，我们可以采用&lt;code&gt;HEAD_REF&lt;/code&gt;的方式来简化调试流程。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;port</summary>
      
    
    
    
    <category term="⑩ 编程基础" scheme="https://jiangxueqiao.com/categories/%E2%91%A9-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    <category term="CMake" scheme="https://jiangxueqiao.com/categories/%E2%91%A9-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/CMake/"/>
    
    
    <category term="Vcpkg" scheme="https://jiangxueqiao.com/tags/Vcpkg/"/>
    
    <category term="Github" scheme="https://jiangxueqiao.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>CMake按目录层级进行分组</title>
    <link href="https://jiangxueqiao.com/post/1531265402.html"/>
    <id>https://jiangxueqiao.com/post/1531265402.html</id>
    <published>2023-10-04T00:09:36.000Z</published>
    <updated>2023-10-27T04:54:07.994Z</updated>
    
    <content type="html"><![CDATA[<p>为了提高项目的可维护性，我们通常会将不同用途的代码文件放到不同的文件夹中，如头文件放到include目录，源文件放到src目录，第三方库放到3rd目录等。</p><p>当使用CMake生成Visual Studio工程时，我们亦希望在Visual Studio中能看到这样的文件结构。当然，我们可以使用<code>source_group</code>指令进行添加，但当目录和层级很多时，这样添加起来就显得比较繁琐了，本文介绍一种懒人方法。</p><span id="more"></span><p>函数<code>group_sources</code>用于遍历传入文件并根据文件所在目录添加<code>source_group</code>指令。</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(group_sources)</span><br><span class="line">  <span class="keyword">foreach</span>(_source IN ITEMS <span class="variable">${ARGN}</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">IS_ABSOLUTE</span> <span class="string">"${_source}"</span>)</span><br><span class="line">        <span class="keyword">file</span>(RELATIVE_PATH _source_rel <span class="string">"${CMAKE_CURRENT_SOURCE_DIR}"</span> <span class="string">"${_source}"</span>)</span><br><span class="line">    <span class="keyword">else</span>()</span><br><span class="line">        <span class="keyword">set</span>(_source_rel <span class="string">"${_source}"</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取文件所在目录</span></span><br><span class="line">    <span class="keyword">get_filename_component</span>(_source_path <span class="string">"${_source_rel}"</span> PATH)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 替换为Windows路径样式</span></span><br><span class="line">    <span class="keyword">string</span>(REPLACE <span class="string">"/"</span> <span class="string">"\\"</span> _source_path_msvc <span class="string">"${_source_path}"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">source_group</span>(<span class="string">"${_source_path_msvc}"</span> FILES <span class="string">"${_source}"</span>)</span><br><span class="line">  <span class="keyword">endforeach</span>()</span><br><span class="line"><span class="keyword">endfunction</span>(group_sources)</span><br></pre></td></tr></tbody></table></figure><p>函数<code>group_sources</code>支持传入多个参数，使用方法如下：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE HEADER_FILES       ./<span class="keyword">include</span>/*.hpp ./<span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCE_FILES       ./src/*.cc ./src/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装目录层级对${HEADER_FILES}和${SOURCE_FILES}中的文件进行分组</span></span><br><span class="line">group_sources(<span class="variable">${HEADER_FILES}</span> <span class="variable">${SOURCE_FILES}</span>)</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了提高项目的可维护性，我们通常会将不同用途的代码文件放到不同的文件夹中，如头文件放到include目录，源文件放到src目录，第三方库放到3rd目录等。&lt;/p&gt;
&lt;p&gt;当使用CMake生成Visual Studio工程时，我们亦希望在Visual Studio中能看到这样的文件结构。当然，我们可以使用&lt;code&gt;source_group&lt;/code&gt;指令进行添加，但当目录和层级很多时，这样添加起来就显得比较繁琐了，本文介绍一种懒人方法。&lt;/p&gt;</summary>
    
    
    
    <category term="⑩ 编程基础" scheme="https://jiangxueqiao.com/categories/%E2%91%A9-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    <category term="CMake" scheme="https://jiangxueqiao.com/categories/%E2%91%A9-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/CMake/"/>
    
    
  </entry>
  
  <entry>
    <title>做人做事做管理</title>
    <link href="https://jiangxueqiao.com/post/1719474789.html"/>
    <id>https://jiangxueqiao.com/post/1719474789.html</id>
    <published>2023-09-27T11:35:10.000Z</published>
    <updated>2023-10-27T04:54:07.924Z</updated>
    
    <content type="html"><![CDATA[<p>大道至简，越是根源和基本的问题，道理实际上越简单。关于如何做人、做事、做管理的书很多，我看得不多，但是我觉得这些书更多是侧重技术和实现细节上的，而很少从人的思想和观念去讲。从实际根本上去说，如何做人做事是世界观的问题，也是一个哲学话题。很多人和我一样，已经到了30的年纪，是需要去思考一下应该如何做人如何做事的，也需要一套简单、有效、完整的体系来指导自己，而这套体系将是让自己安身立命于这个世界的基石。</p><span id="more"></span><h1 id="职场上如何做人"><a href="#职场上如何做人" class="headerlink" title="职场上如何做人"></a>职场上如何做人</h1><p>关于在职场上如何做人，我只谨记两个字－－服务。</p><p>你要把自己当成一个品牌去爱惜，当成一家公司去经营，你要牢牢记住你之所以能在一家公司立足，是因为公司需要你的服务。</p><p>我们经常会抱怨某某银行的工作人员服务态度不好、某某商品的售后服务不好，但从来不去思考自己对公司的服务好不好？公司的任务有没有如期完成，有没有哪个任务是提前完成的，是否所有任务都拖到“最后期限”？工作完成的够不够彻底，是不是答复已经完成了，结果后面又出状况？完成后有没有向上级反馈，是不是等到上级问你完成了没有，你才去报告进度？拖延的任务有没有持续跟进，是不是上级不追了这个任务最后就不了了之了？上面这些问题我都是反复遇见，其实根本原因就是没有意识到你其实在做一项服务，你在公司的发展前景，全都取决你对公司的服务够不够好。设想一下，如果交给你的每件事情都可以迎刃而解、化险为夷，让人感觉稳妥、放心、踏实，你自然会收到更多更重要的“订单”。当你的单多到你忙不过来的时候怎么办？招下属啊，呵呵，恭喜你，你已经是领导了（当然我们也要排除极少数的任人唯亲的公司，大局面是积极向上的）。反之，如果给你一件事情你要拖延，给你一件事情你办不好，给你一件事情就没了下文了，让人不放心，久而久之你就“无单可做”了，那么公司重新请一个人就可以了，干嘛非要用你呢？</p><p>服务不光是对于自己供职的公司，对于公司的客户也是一样的。每一次去客户那里出差前，我总是再三叮嘱自己，我此次之行是为客户做服务的，是去为客户解决问题的。这个心态非常重要，我们做软件系统的，去见客户除了做演示、做培训，很多时候就是处理现场问题，难免遇到客户对系统的投诉，比如系统速度慢、bug多等问题。当你有了这样的心态，你就会谦虚地接受客户的批评，细致地记录客户提出的问题，然后一项项地去思考如何解决，并且应该给客户一份详尽的解决方案。有了这样的心态，你会不自觉地、自然而然地与客户站在一边，让他感到你是在为他着想，帮助他去解决问题的。在你面对客户时，应该有这样一个虔诚的信念：我是去为客户服务的，为他解决他所解决不了的问题的。如果你没有这样的心态，面对投诉很可能就会产生厌烦，而且容易为自己的问题进行辩解。这种做法给客户的感觉就是你竭力在证明你是对的他是错的，这样你就站在客户的对面了。</p><p>在客户面前的表现对你的职场发展也是非常有好处的，尤其是接触到一些跨国企业时，你优良的职业素养会为你赢来客户的认同与尊敬。这样当你哪天希望寻找更高的平台，只要放个口风出去，立即就会有Offer了。所以认真服务好客户只赚不赔。</p><h1 id="职场上如何做事"><a href="#职场上如何做事" class="headerlink" title="职场上如何做事"></a>职场上如何做事</h1><p>关于如何做事，也有很多的理论，比如要事第一，把事情分为紧急、重要等等，这些我都不讨论了，我只就我自己的经验来谈一谈。</p><p>对于如何做事，我也恪守一个信条：不焦不燥，把心沉下去，将注意力集中于要解决的问题上。</p><p>我看过这样一个故事，是说从前有一户人家，家里的菜园中有一块大石头，经常会有人不小心撞到；儿子就问：为什么不把他挖走呢？他的爸爸说：这个石头爷爷的时代就有了，就是因为它那么大，不好挖才一直在那里；又过了一代人，家里的一个媳妇实在受不了，就扛着锄头去挖了，她已经做好了心理准备要挖几天的时间，结果一天就挖完了… …原来那个石头的中间是空的。</p><p>我们遇到的很多事情也是一样的，看似棘手、难以解决，实际上只要你认真地去分析、去思考，然后放手去做，往往并没有想象中的那么困难。你需要克服心中的顽石。我发现一些人遇到问题后，很轻易地就会说：这个我做不了，这个实现不了，这个我也没办法。其实就好像看到这块大石头一样，被它的“外表”吓住了，而放弃了应有的行动。</p><p>而且我发现了一个有趣的现象，不管多么困难的问题，只要你沉下心去思考如何解决，就好像在冥冥之中上苍在看着你一样，当你拼到最后就要打算认输的时候，往往会出现新的契机和方法。</p><p>另外，我发现有些人遇到问题的时候，他想的是这件事如何困难如何难以完成，这样的思维方式是有问题的，是一种保守且退缩的思维；遇到问题的时候，想的应该是如何才能够完成。我一般采取这样几个步骤：1、列出所有的可能性；2、分析各种可能性；3、选择一种实现起来最简单、快速的可能性；4、去实现。</p><p>除此以外，我发现一些人在做事的时候，会以“这样做很麻烦”来作为不采纳方案的理由，而不是“这样是否必要”或者“这样是否更好”来作为标准，实际上“麻烦”应该是排在“是否必要”、“是否更好”后面进行考虑的。如果一种实现方式，虽然麻烦，但是很有必要，且对客户来说更好，那么就算麻烦也要去做。但是程序员往往关心的是会不会很麻烦，是不是要修改很多地方，是不是给自己带来很多工作量… …告诉你，你关心的这些不是最重要的。</p><h1 id="职场上如何做管理"><a href="#职场上如何做管理" class="headerlink" title="职场上如何做管理"></a>职场上如何做管理</h1><p>和上面一样，做管理也有很多的细节，我也都不谈了，因为这些都是一本书一本书的讲，而我觉得要简单、有效、好操作，所以我也只说三点。</p><p>我觉得做好一个技术经理，只要下面的三点就好了：</p><h2 id="1、德行"><a href="#1、德行" class="headerlink" title="1、德行"></a>1、德行</h2><p>德行其实就是品德，简单地讲就是要善良、诚恳。最重要的，你做事的出发点要是好的，对别人是没有坏心的。</p><p>为什么说出发点一定要是好的呢？我们还是以服务客户的例子来说，在为客户解决问题的时候，如果我们的出发点是好的，是站在客户一边尽心尽力去为客户解决问题的，那么即便由于方法、能力、条件等各方面的原因，事情搞砸了或者没有做好，也很容易获得客户的理解和原谅。很可能的情形是，你就算做失败了也一样赢得客户；相反，如果你的出发点是“省麻烦”，“赶紧交差了事”，“完成任务”，如果事情做成了也就算了，一旦失败了，你看看客户会怎么样？告诉你，好的客户会批评你、投诉你，因为他对你还有期望；更多的客户是什么话也不说，直接换个供应商就是了，才懒得理你。</p><p>记住永远不要把客户当成傻瓜，你是如何做事情的，客户是很容易感受得到的。所以，面对和服务客户没有那么多的技巧，你不需要有多好的口才和魅力，也用不着忽悠和夸大其词(我发现很多销售人员都是这样，你可以骗客户一次，但就没有第二次了)，你只需要放下身段，兢兢业业地为客户着想，设身处地地解决他的问题就可以。对待下属也是一样的，你对他的奖励也好，惩罚也好，出发点一定要是好的。我对待下属遵循的原则就是：我是在帮助你，帮你把工作做的更好，帮你获得更大的提高，而不是说找你茬儿，跟你过意不去，或者是挤兑你压迫你。德行是基本的，有一个好的德行，至少可以保证你的下属不会讨厌你。</p><blockquote><p>这一点放在做产品上仍然有效，做一个好的产品同样不需要那么多的技巧和花样，从用户实际需求出发，想用户所想，做用户想要的，用户自然买单，盈利也是水到渠成的事情。</p></blockquote><h2 id="2、敬业"><a href="#2、敬业" class="headerlink" title="2、敬业"></a>2、敬业</h2><p>如果有人问我，下属和经理的区别是什么。我会告诉他：下属等着别人交代事情做，经理想着还有哪些事情可以做。</p><p>这其实是一个积极心态的问题，作为一个中层干部，你需要将公司的事情当成自己家的事情来处理，当你有这样的心态，你就是再怎么加班都不会有怨言的，即便分文不取… （有谁见过给自己家装修叫苦不迭的？）如果你可以长期保持这样的状态，你的这种献身精神和敬业精神，会很轻易地感染你的下属和你的同事，你会感觉到在公司左右逢源，而且你也会更有话语权，大家会更重视你的意见，同事和下属也会对你报以更多的信任。当这种情况出现时，管理起下属还会困难吗？但需要注意的是，你的敬业精神不是说体现在无休止的加班上，工作异常繁忙、经常性加班其实是工作没有做好的表现之一，加班只应该出现在紧急情况发生的时候，而不应该是一种常态。</p><h2 id="3、技术"><a href="#3、技术" class="headerlink" title="3、技术"></a>3、技术</h2><p>如果有人问我，技术人员和其他人员最大的区别是什么。我会告诉他：技术人员个个自以为是，认为别人的技术都不如自己。</p><p>可能大家不爱听，但我观察到的现象就是这样的，而且往往那些自认为懂得很多的人，实际是还没敲开知识的大门。</p><p>很少有人愿意去读别人的代码，彼此都觉得写得好烂。所以，如果想赢得技术人员的钦佩，你需要有压倒性的技术能力。这个压倒性的优势，不是下属70分，你80分，而是下属70分，你要做到100分；下属100分，你要做到150分。所以，缺乏技术能力的人去管理技术人员往往是吃力不讨好的，可能下属表面上服从你，心里根本不当你一回事儿，这样管理起来就存在障碍了。当然，如果你的德行非常好，也非常敬业，技术就显得不那么重要了；而如果你已经满足了前面两条，同时技术也很精湛，那自然是锦上添花了。</p><p>上面就是一点点心得，欢迎交流。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大道至简，越是根源和基本的问题，道理实际上越简单。关于如何做人、做事、做管理的书很多，我看得不多，但是我觉得这些书更多是侧重技术和实现细节上的，而很少从人的思想和观念去讲。从实际根本上去说，如何做人做事是世界观的问题，也是一个哲学话题。很多人和我一样，已经到了30的年纪，是需要去思考一下应该如何做人如何做事的，也需要一套简单、有效、完整的体系来指导自己，而这套体系将是让自己安身立命于这个世界的基石。&lt;/p&gt;</summary>
    
    
    
    <category term="⑧ 软件架构" scheme="https://jiangxueqiao.com/categories/%E2%91%A7-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
</feed>
