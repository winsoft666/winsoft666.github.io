<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>独钓寒江雪</title>
  
  
  <link href="https://jiangxueqiao.com/atom.xml" rel="self"/>
  
  <link href="https://jiangxueqiao.com/"/>
  <updated>2025-02-22T09:43:35.059Z</updated>
  <id>https://jiangxueqiao.com/</id>
  
  <author>
    <name>江雪桥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Wireshark过滤器规则速学</title>
    <link href="https://jiangxueqiao.com/post/556603567.html"/>
    <id>https://jiangxueqiao.com/post/556603567.html</id>
    <published>2025-02-22T09:28:55.000Z</published>
    <updated>2025-02-22T09:43:35.059Z</updated>
    
    <content type="html"><![CDATA[<p>Wireshark 中有两种过滤器：</p><ul><li>捕获过滤器：用于在数据包捕获阶段过滤数据包，只捕获符合条件的数据包，这样可以减少捕获不必要的数据包，从而提高性能。</li><li>显示过滤器：用于在已经捕获的数据包中过滤出符合条件的数据包进行显示，它使用的是 Wireshark 自己的语法。</li></ul><span id="more"></span><h2 id="一、捕获过滤器"><a href="#一、捕获过滤器" class="headerlink" title="一、捕获过滤器"></a>一、捕获过滤器</h2><p>在 Wireshark 的开始页面或者在捕获选型页面中选择需要捕获的网络适配器，然后输入捕获过滤器规则，设置完成之后，点击“开始”按钮即可使用该规则在对应适配器上进行网络流量抓取。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/gDR0RLia7m-TinyTu.png"></p><h3 id="1-1-BPF语法"><a href="#1-1-BPF语法" class="headerlink" title="1.1 BPF语法"></a>1.1 BPF语法</h3><p>捕获过滤器使用的是 BPF（Berkeley Packet Filter）语法，BPF语法规则如下：</p><ol><li>一个过滤表达式（expression）由一个或多个原语（primitives）组成。</li><li>一个原语（primitive）由一个或多个限定词（qualifiers）组成，限定词之间使用空格分隔。</li><li>每组限定词最后跟着值，表示最后的计算结果<strong>等于</strong>该值时条件成立，而不支持大于、小于等其他比较运算符。</li><li>原语之间使用逻辑操作符（operators）连接，逻辑操作符可以使用 and、or、not 表示，也可以使用 &amp;&amp;、||、!。</li></ol><p>如下图所示：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/kam9z21sA3-TinyTu.png"></p><p>如下面的捕获过滤器表示：只捕获源 IP地址 为 192.168.1.100 且目的 TCP 端口为 80 的数据包。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip src 192.168.1.100 and tcp dst port 80</span><br></pre></td></tr></table></figure><p>Wireshark是非常遵守网络协议的，在过滤器中的ip表示的是ip协议，而不是我们通常认为的ip地址。</p><p>各个限定词出现的先后顺序也是按照网络协议的规则而来的，比如IP协议有源地址和目标地址之说，因此针对源地址和目标地址的捕获表达式分别如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip src 192.168.1.100</span><br><span class="line">ip dest 192.168.1.101</span><br></pre></td></tr></table></figure><p>捕获过滤器不支持直接过滤应用层的协议，如http、ftp等，因为为了保证效率，在捕获时还未进行协议解析。</p><h3 id="1-2-常用捕获过滤规则"><a href="#1-2-常用捕获过滤规则" class="headerlink" title="1.2 常用捕获过滤规则"></a>1.2 常用捕获过滤规则</h3><p><strong>地址过滤</strong></p><ul><li><code>host 192.168.1.33</code>：捕获与 192.168.1.33 这个 IPv4 地址相关的所有流量。</li><li><code>host 2308:8277:420:152a:819:41f0:28fa:8862</code>： 捕获与这个 IPv6 地址相关的所有流量。</li><li><code>host www.baidu.com</code>： 捕获与域名 <a href="http://www.baidu.com/">www.baidu.com</a> 相关的所有流量。</li><li><code>ether host 52:54:99:2f:37:b1</code>： 捕获与这个 MAC 地址相关的所有流量。</li><li><code>src host 192.168.1.33</code>：只捕获<strong>源地址</strong>为 192.168.1.33 的流量。</li><li><code>dest host 192.168.1.33</code>：只捕获<strong>目标地址</strong>为 192.168.1.33 的流量。</li></ul><p><strong>端口过滤</strong></p><ul><li><code>port 8080</code>：捕获 8080 端口的流量，包括流入或流出的，这里无关使用的是哪一种传输层协议，tcp、udp还是其他，只要端口为8080就都捕获。</li><li><code>!src port 8080</code> 不捕获掉<strong>源端口</strong>为 8080 流量。</li></ul><p><strong>协议过滤</strong></p><ul><li><code>icmp</code>：只捕获 icmp 协议产生的流量。</li><li><code>!ip6</code>: 不捕获 IPv6 的流量。</li></ul><h2 id="二、显示过滤器"><a href="#二、显示过滤器" class="headerlink" title="二、显示过滤器"></a>二、显示过滤器</h2><p>显示过滤器的规则与捕获过滤器类似，但有些地方不一样。</p><p>显示过滤器的限定词之间使用<code>.</code>进行分割，而捕获过滤器使用的是空格；</p><p>捕获过滤器只支持等于这一种比较运算符，而显示过滤器支持更多的比较运算符，如<code>==</code>、<code>&gt;</code>、<code>&lt;</code>、<code>!=</code>、<code>&gt;=</code>、<code>&lt;=</code>。</p><p>虽然逻辑运算符与捕获过滤器类似，但多了一种异或运算符，使用 <code>xor</code> 表示。</p><p>下面示例表示：捕获ip源地址不等于192.168.1.1，并且tcp协议端口号为80的流量。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.src != 192.168.1.1 and tcp.port &gt; 80</span><br></pre></td></tr></table></figure><p>不同于捕获过滤器，显示过滤器的规则需要更加地明确，如：</p><ul><li>对端口号的指定需要加上协议限定词，如<code>tcp.port == 80</code>，而不能像捕获过滤器那样不管协议，只要是该端口就捕获，如 <code>port 80</code>。</li><li>显示过滤器不能使用<code>host</code>，因为 host 太笼统了，既可以表示ip源&#x2F;目标地址，也可以表示域名，在显示过滤器中可以使用 <code>ip.src</code> 、<code>ip.dest</code>或<code>http.host</code> 替代。</li></ul><h2 id="2-1-小技巧"><a href="#2-1-小技巧" class="headerlink" title="2.1 小技巧"></a>2.1 小技巧</h2><p>显示过滤器规则有很多，我们都需要记住吗？记不住，也没必要，我们只需要记住常用的规则就可以了。</p><p>在使用Wireshark抓包时，我们可以选择报文中的某一项，点击右键，选择“作为过滤器应用”即可使用该项作为过滤器，如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wirkshark_select_filter-TinyTu.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Wireshark 中有两种过滤器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;捕获过滤器：用于在数据包捕获阶段过滤数据包，只捕获符合条件的数据包，这样可以减少捕获不必要的数据包，从而提高性能。&lt;/li&gt;
&lt;li&gt;显示过滤器：用于在已经捕获的数据包中过滤出符合条件的数据包进行显示，它使用的是 Wireshark 自己的语法。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="编程基础" scheme="https://jiangxueqiao.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Wireshark" scheme="https://jiangxueqiao.com/tags/Wireshark/"/>
    
  </entry>
  
  <entry>
    <title>2025蛇来运转</title>
    <link href="https://jiangxueqiao.com/post/2721888631.html"/>
    <id>https://jiangxueqiao.com/post/2721888631.html</id>
    <published>2025-01-20T09:20:00.000Z</published>
    <updated>2025-01-20T09:29:04.757Z</updated>
    
    <content type="html"><![CDATA[<p>写下这一行预示着2024年的工作即将结束，农历蛇年即将到来。</p><p>蛇，象征着智慧与灵动，蜿蜒前行，希望在新的一年里，面对生活的曲折，也能够以灵活的姿态应对，凭借智慧化解难题。</p><p>愿2025年蛇来运转！</p><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/shenianhongyun.png" width="100%" /></div><p>物来顺应，未来不迎。</p><p>当时不杂，既过不恋。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写下这一行预示着2024年的工作即将结束，农历蛇年即将到来。&lt;/p&gt;
&lt;p&gt;蛇，象征着智慧与灵动，蜿蜒前行，希望在新的一年里，面对生活的曲折，也能够以灵活的姿态应对，凭借智慧化解难题。&lt;/p&gt;
&lt;p&gt;愿2025年蛇来运转！&lt;/p&gt;
&lt;div style=&quot;text-alig</summary>
      
    
    
    
    <category term="杂念" scheme="https://jiangxueqiao.com/categories/%E6%9D%82%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows系统各版本占比对技术选型的影响</title>
    <link href="https://jiangxueqiao.com/post/2306363290.html"/>
    <id>https://jiangxueqiao.com/post/2306363290.html</id>
    <published>2024-11-05T05:35:00.000Z</published>
    <updated>2025-01-09T06:57:21.963Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="无法校验文章哈希">  <script id="hbeData" type="hbeData" data-hmacdigest="8fb760eff8ab7ad5612184f809df14c2d58d21227db3626892e3a94593e0fe05">49420f43dcd4ffad5e1774efbcfcadee1df58b08bd2027afeeff190f6d3914caa3f5046f3f5bad5b765f8cbb26ace04d6965f94871d34eafdab6cc28b4206ec5923d3968c22469732531493518815210892145cff461ac8a8fb2a237750d7842771878571b9008bad5d5f30e6d3ad86bb644fda522166f202c972259dfc028974b69f095caa8d5b77cd27cdedaa4ac899377d20a00be9995f7881bcd106590837ff386be93f1c195600fc5a244fd5242024464d283358d629d5a87c4d0eaae5e2d740a0e2aae6c40dc2854859529b59faa10704c399588f138db6097f16f67d8ac1d14d3755bdbe14e4f91356508b7329982a479767417beddd0509fe77f57e029a43c689b1e52663654395e320c1d3047615969ebe89793a7eee4b630f2928de8b6a63a88a3871cf91937634430faa3b86745ddbad29154a6101df9c75a082356c4cf0de32adb1676f79e344339db3cf8d1c7f5cefc092d1cedfad1c16fae5864b31085efe02d77010801d8224cb3857e2de8719e70fc6734ec47b69b186d05cccfa011002cbdb47fc6eaaa799cf078bdeb6073fd16d37c8bcd216992edd1ebba4011707a8f4e6fcd4df8811be78bf8b8109f72b2cc90e495bc3649b5bce9fe8b87a3fcdb8ccfd7466844ebe65cd6a71ae3d2263a72987685f523b9fd1b4c69e9a5ddf49f747d2883e99cc0d7c797eb8be5255189ee61942373f0c7e26bc64583ab28ff5cc4d44802597c55b5600724c3e398eef5520ca68ddb2decf045814518c6596eab4f5ffac9ebb52f5ab8ba2a00b60f9c3c7ba49e997437fc1af88ce660abcf4f30f627411f1f04d3829b3460d3cb1e911e8cee55f6f32f06ec7926dd1a4630d6f9fd6f91da9041b184aa77e4aadd053a291b668369c924df2550bf585d4986ba62ed656faef12906d6308a6450bd5846aeb2eb40ee66ee11dc855cc536717270ff5dcaaf2dd8a5723c7613dc3729f575052e867914f89ff0c8f5dff4bbe457f0cca56215e0208654f0ebfb1b12d23a5f4dc28287e6d2825ddc8de1e50302cc8d366e9d1137d85dca5de87a88e145834a99e420527fc26e89b865267dba5f54741f4a87441293edb964bd28e53f26eace6bc1aac24ba98942b99b8052b7cfbd6b94f3ef499fad333134768d2d0ae0374b3f1483e13cb514ecdc32aa6f1a07529adf59f5cdcde3eac413bb95c4afef5b4719cfa2835342b0064043f0555afbb93fcda255a99bbd3ec3acba8ad41d7525218f3c13f3d1eea5972c6eaf74edfe2313e9dde97df19291fcaf7deaaeaac0ea1581881750e8f1f4c10fe14f359a73e73158bd08c17a52704de5dfa78669d34e7d30adfb5e3ffbf7a0a243ed7d1855ae899603be66d43cc45243489399683d020e2501a9af0aaa6a86ec4b35b8a41517f27f71429de269e262baa4345e9115c08e41210c999b7a7cec809d3c088b075503f5a6732cd96b4d65821557df8242080e3882c43b1e34d3394facdd7508c3b43c682417d8a1da4b8a7304719b0da91ff0fb37576bb16a68ce296532df6c89504dedfed221055fca8fa34b164d69b9f18f6d11d2da4c921ac51501b152590b2bca2e1cda04883baa2d65f93ead7ee4e39d312f38d0fde8246dea9ec789501d96dd7f710b85a209300199d070771e77e5789dc40e61eea41a38d5d4a0881dc2972177aeb49472d660dd32e3ec9a83bc122d9d63c48c53f2d77bdd5bf0032861835bdf2d5cf0b0e1a0f8443c5380001e6d75dad4c08382d9bd23bd07bf336d4753bc7cd743034c874216f736f6d0489855e9cd2f8f50eada41f25616949c6f3ffc070ddedadb81f2224acedf7ee4c6b7f78e2a295dc950849b557bb0ba4385c910fa0fb1791c71c12c6c4205625977431fa78e3c542543e49a00390db01dd7d2b3ae7e50a9f63a96fcc1dd40e52c126a4c2c548217ef9367e1d58a87eb5b5ee841fbf9d8f391e624c050d5f9444a11fe1ec36f7b242e29494e65555b996aa1a0f766ba960794d864577ec73e7810fb6c2fc36ca3d75fb2076ef2c849593c6d7b1067316333d2577259ba84eacec00f7f46a7c6c329941cb12c0e381622c2bf42be6d747192550cafd5499ca8b8203d68f59eaf464945a4fe5a8ebbbb9259411a89dbb3f2aef3a1deb1ca7b8c5b83713aa5daa94de6d65f13b73f974e179818dcbb4f6913d483456f1d501a5b6d60c96f761619ad6bc54bd34c99985d3008253e388c138c5bc18ff2435c83ae31d49e341f28f6fbecdcacc1a4935b1bd4b1cc690f417c6526759be6acaf41b4362873822ca0272bdaf75d8b20a498f73e249730ab34565e1454fe7a0581a1be17cf2e893c13e54fd56e2eae382718ffcf21cffd3ce7fadade6ab72119ef219b7c02578a4f21e82a8091f76fde822870429e0d1bfd3e6d6946863afe2d1e89944cce59be41a228d96b6c78808a57a951c8804529f52e64c898339e3c055b165eb4f1f7bd17eb6bddc894e0ec706693e07ff251603b4d2b1bc9db6c3a24a1d7796fa3acd39076b484bfa9539f535e4bf6dbda98b8fe5840621914e9f306184b5460ae34f6eb2a5efef86e3d5c449bb494bb84</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">文章已被加密，请联系作者获取密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">文章已被加密</summary>
    
    
    
    <category term="项目管理" scheme="https://jiangxueqiao.com/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Modern CMake 简明教程（下）</title>
    <link href="https://jiangxueqiao.com/post/201509401.html"/>
    <id>https://jiangxueqiao.com/post/201509401.html</id>
    <published>2024-10-18T02:34:36.000Z</published>
    <updated>2025-01-10T12:14:42.347Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cmake.org/">CMake</a> 是一个开源、跨平台的构建系统生成器（Build-system Generator）。</p><p>本文是 Modern CMake 简明教程系列的下篇，上篇请移步至 <a href="/post/3678619994.html" title="Modern CMake 简明教程（上）">《Modern CMake 简明教程（上）》</a>，中篇请移步至 <a href="/post/2304457467.html" title="Modern CMake 简明教程（中）">《Modern CMake 简明教程（中）》</a>。</p><p>本教程默认 CMake 最低版本为 3.16，即 <code>cmake_minimum_required(VERSION 3.16)</code>。</p><span id="more"></span><h1 id="一、集成第三方库"><a href="#一、集成第三方库" class="headerlink" title="一、集成第三方库"></a>一、集成第三方库</h1><p>在项目中集成第三方库是一种非常常见的需求，CMake 提供了两种方式来集成第三方库。</p><p><strong>第一种：直接集成第三方库的源码。</strong></p><p>说到集成第三方库的源码，我们第一时间想到的可能就是将其源码直接拷贝到项目目录中，然后提交到 git 仓库，更加高级一点可能会使用 git submodule 的方式。但我以为这两种方式都不够优雅，无法很好的管理、更新依赖库，特别是在项目的依赖库的比较多时。</p><p>CMake 提供了两个模块（两种方式）来集成第三方库的源码：</p><ul><li>FetchContent<br>该模块支持在 CMake 生成项目时就下载第三方库，还会自动将第三方库添加到项目中，不需要手动调用 add_subdirectory。</li><li>ExternalProject<br>该模板支持在构建（编译）项目时下载第三方库。显然 ExternalProject 的下载时机要晚于 FetchContent 。</li></ul><p><strong>第二种：使用预编译好的第三方库。</strong></p><p>这种方式需要先单独编译安装第三方库，然后使用 find_package 查找该库，最后设置目标的相关属性，如包含目录、依赖库等。</p><h2 id="1-1-FetchContent"><a href="#1-1-FetchContent" class="headerlink" title="1.1 FetchContent"></a>1.1 FetchContent</h2><p><a href="https://cmake.org/cmake/help/latest/module/FetchContent.html">FetchContent</a> 的使用大致分为两个步骤。</p><p><strong>步骤一：</strong> 使用 FetchContent_Declare 命令记录要获取的内容，可以多次调用 FetchContent_Declare 命令来记录获取多个内容。</p><p>FetchContent_Declare 的定义如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FetchContent_Declare(</span><br><span class="line">  &lt;name&gt;</span><br><span class="line">  &lt;contentOptions&gt;...</span><br><span class="line">  [EXCLUDE_FROM_ALL]</span><br><span class="line">  [SYSTEM]</span><br><span class="line">  [OVERRIDE_FIND_PACKAGE |</span><br><span class="line">   FIND_PACKAGE_ARGS args...]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;name&gt;</code> 可以是任何不带空格的字符串，并且该名称不区分大小写，但通常我们仅使用字母、数字和下划线。</p><p>下面示例分别演示了如何从 Git 仓库、https链接、SVN仓库获取内容：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FetchContent_Declare(</span><br><span class="line">  googletest</span><br><span class="line">  GIT_REPOSITORY https://github.com/google/googletest.git</span><br><span class="line">  GIT_TAG        <span class="number">703</span>bd9caab50b139428cea1aaff9974ebee5742e <span class="comment"># release-1.10.0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  myCompanyIcons</span><br><span class="line">  URL      https://intranet.mycompany.com/assets/iconset_1.<span class="number">12</span>.tar.gz  <span class="comment"># 下载完后，会自动解压</span></span><br><span class="line">  URL_HASH MD5=<span class="number">5588</span>a7b18261c20068beabfb4f530b87</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  myCompanyCertificates</span><br><span class="line">  SVN_REPOSITORY svn+ssh://svn.mycompany.com/srv/svn/trunk/certs</span><br><span class="line">  SVN_REVISION   -r12345</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>步骤二：</strong> 调用 FetchContent_MakeAvailable 命令开始获取上面声明的内容。</p><p>如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FetchContent_MakeAvailable(googletest myCompanyIcons myCompanyCertificates)</span><br></pre></td></tr></table></figure><h3 id="1-1-1-结果"><a href="#1-1-1-结果" class="headerlink" title="1.1.1 结果"></a>1.1.1 结果</h3><p>如果 FetchContent 执行成功，下面几个变量会设置：</p><ul><li><code>&lt;lowercaseName&gt;_POPULATED</code><br>始终被设置为 TRUE</li><li><code>&lt;lowercaseName&gt;_SOURCE_DIR</code><br>目标内容的源码目录</li><li><code>&lt;lowercaseName&gt;_BINARY_DIR</code><br>目标内容的构建目录</li></ul><h3 id="1-1-2-使用代理"><a href="#1-1-2-使用代理" class="headerlink" title="1.1.2 使用代理"></a>1.1.2 使用代理</h3><p>限于国内的网络环境，在获取内容时，很可能出现下载失败的情况，此时可以尝试使用 http 和 https 代理来解决该问题。</p><p>通过设置相应的环境变量即可设置 http(s) 代理，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENV&#123;http_proxy&#125; <span class="string">&quot;http://127.0.0.1:7890&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(ENV&#123;https_proxy&#125; <span class="string">&quot;http://127.0.0.1:7890&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="1-2-find-package"><a href="#1-2-find-package" class="headerlink" title="1.2 find_package"></a>1.2 find_package</h2><p>find_package 用于查找已经安装到本机的包，将查找结果存储在 <code>&lt;PackageName&gt;_FOUND</code> 变量中（查找到包，值为 1，否则 为 0），包的安装路径存储在 <code>&lt;PackageName&gt;_DIR</code> 变量中，通常还会定义一些变量来指明包的版本、头文件目录的路径、.lib 或 .a 文件的路径等，这些变量名称的格式会根据查找方式的不同、包的不同而不同。</p><p>find_package 使用起来比较简单，通常我们只需要使用它的基础定义：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(&lt;PackageName&gt; [&lt;version&gt;] [REQUIRED] [COMPONENTS &lt;components&gt;...])</span><br></pre></td></tr></table></figure><ul><li><code>&lt;PackageName&gt;</code><br>指定包的名称，是唯一的必选参数。</li><li><code>&lt;version&gt;</code><br>指定需要查找包的版本，<code>major[.minor[.patch[.tweak]]]</code>，支持多种形式的版本，如 3、3.1、3.1.2 等，可以指定匹配大版本还是小版本匹配等，也可以通过指定 EXACT 选项来要求版本完全一致，当然也可以完全省略版本约束。</li><li>REQUIRED<br>参数用于指定该包是必须找到，如果没有找到则停止执行该 CMake 脚本。</li></ul><blockquote><p>find_package 的完整定义可以见：<a href="https://cmake.org/cmake/help/latest/command/find_package.html#full-signature">full-signature</a></p></blockquote><p>下面示例用于查找大版本为 3 的 OpenCV 包：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenCV <span class="number">3</span> REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;OpenCV_DIR = $&#123;OpenCV_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;OpenCV_INCLUDE_DIRS = $&#123;OpenCV_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;OpenCV_LIBS = $&#123;OpenCV_LIBS&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="不同的查找模式"><a href="#不同的查找模式" class="headerlink" title="不同的查找模式"></a>不同的查找模式</h3><p>find_package 有两种查找包的方式，优先使用 Module 模式，如果 Module 模式没有查找到，再使用 Config 模式查找。</p><h4 id="Module-模式"><a href="#Module-模式" class="headerlink" title="Module 模式"></a>Module 模式</h4><p>find_package 使用 Module 模式查找包就是查找 <code>Find&lt;PackageName&gt;.cmake</code> 文件的过程，会尝试在下面位置中查找该文件，优先级从高到低依次为：</p><ul><li>CMAKE_PREFIX_PATH<br>该变量是以分号分隔的列表，默认为空，由用户设置；也可以定义环境变量 CMAKE_PREFIX_PATH，环境变量 $ENV{CMAKE_PREFIX_PATH} 定义的列表会附加到 ${CMAKE_PREFIX_PATH} 变量的后面。</li><li>CMAKE_MODULE_PATH<br> 该变量也是以分号分隔的列表，默认为空，由用户设置。</li></ul><p><strong>Find&lt;PackageName&gt;.cmake 文件从何而来？</strong></p><p>如果你是库的开发者，你是不需要提供 <code>Find&lt;PackageName&gt;.cmake</code> 文件的，你只需要按照文章 <a href="/post/2304457467.html" title="Modern CMake 简明教程（中）">Modern CMake 简明教程（中）</a> “安装导出依赖项”章节介绍的那样，在安装时生成 <code>&lt;PackageName&gt;Config.cmake</code>（或 <code>&lt;lowercasePackageName&gt;-config.cmake</code> 文件）即可，该文件可以用于 find_package 的 Config 模式查找。</p><p>对于那些没有按照规范提供上述 Config 文件的库，才需要使用者来编写 <code>Find&lt;PackageName&gt;.cmake</code>，辅助查找包的安装路径。</p><h4 id="Config-模式"><a href="#Config-模式" class="headerlink" title="Config 模式"></a>Config 模式</h4><p>find_package 指令在大多情况下都是通过 Config 模式来查找到包的具体位置的。</p><p>find_package 使用 Config 模式查找包就是查找 <code>&lt;PackageName&gt;Config.cmake</code>或 <code>&lt;lowercasePackageName&gt;-config.cmake</code> 文件的过程。</p><p>在 Config 模式下，<code>&lt;PackageName&gt;</code> 可以通过 NAMES 参数来指定多个需要匹配查找的包名（PackageName），例如下面查找 Qt5 或 Qt6 的方式：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(QT NAMES Qt6 Qt5 REQUIRED COMPONENTS Widgets)</span><br></pre></td></tr></table></figure><p>而且在该模式下，find_package 查找 config 文件的步骤也非常复杂，尤其是可以根据不同开关来查找不同的路径，下面介绍几个常用的查找 config 文件的位置（完整的见官方文档），按优先级从高到低依次为：</p><ol><li>&lt;PackageName&gt;_DIR 变量或环境变量所指定的目录，默认为空。</li><li>CMAKE_PREFIX_PATH、CMAKE_FRAMEWORK_PATH、CMAKE_APPBUNDLE_PATH 变量或环境变量所指定的目录，该变量是以分号分隔的列表，默认为空。</li><li>PATH 环境变量所指定的目录，该变量是以分号分隔的列表，默认为系统 PATH 环境变量的值。如果该变量中的路径以 bin 或 sbin 结尾，则自动回退到上一级目录进行查找。</li></ol><p>与 Module 模式不同的是，在上述几个位置中，除了第 1 个指定的目录是“根目录”，CMake 只会在该目录的根目录下查找 <code>&lt;PackageName&gt;Config.cmake</code>或 <code>&lt;lowercasePackageName&gt;-config.cmake</code> 文件，不会进入其子目录中查找，如设置 OpenCV_DIR 为 <code>/home/jack</code>，CMake 只会查验如下文件：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/jack/OpenCVConfig.cmake</span><br><span class="line">/home/jack/opencv-config.cmake</span><br></pre></td></tr></table></figure><p>而第 2、3 所指定的目录都是“路径前缀”，CMake 不仅会在根目录下查找 <code>&lt;PackageName&gt;Config.cmake</code>或 <code>&lt;lowercasePackageName&gt;-config.cmake</code> 文件，还会进入其子目录内查找。当然 CMake 不会无脑的遍历所有子目录，而且只在特定的子目录内进行查找，不同系统环境下所查找的子目录也不同，具体如下表所示。</p><table><thead><tr><th>查找路径</th><th>系统环境</th></tr></thead><tbody><tr><td><code>&lt;prefix&gt;/(cmake|CMake)/</code></td><td>Windows</td></tr><tr><td><code>&lt;prefix&gt;/&lt;name&gt;*/</code></td><td>Windows</td></tr><tr><td><code>&lt;prefix&gt;/&lt;name&gt;*/(cmake|CMake)/</code></td><td>Windows</td></tr><tr><td><code>&lt;prefix&gt;/&lt;name&gt;*/(cmake|CMake)/&lt;name&gt;*/</code></td><td>Windows</td></tr><tr><td><code>&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/</code></td><td>Uninx</td></tr><tr><td><code>&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/</code></td><td>Uninx</td></tr><tr><td><code>&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/(cmake|CMake)/</code></td><td>Uninx</td></tr><tr><td><code>&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/</code></td><td>Windows、Uninx</td></tr><tr><td><code>&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/</code></td><td>Windows、Uninx</td></tr><tr><td><code>&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/(cmake|CMake)/</code></td><td>Windows、Uninx</td></tr></tbody></table><p>在上表中，<code>&lt;prefix&gt;</code>就是第 2、3 项所指定的路径前缀；<code>&lt;name&gt;</code> 为包名，不区分大小写，<code>&lt;name&gt;*</code> 的意思是包名后面还可以接一些字符，如 OpenCV-3.0。</p><h3 id="结果获取"><a href="#结果获取" class="headerlink" title="结果获取"></a>结果获取</h3><p>无论是哪种查找模式，我们都需要获取查找的结果。目前我能确定的是，这两种查找模式都会定义 <code>&lt;PackageName&gt;_FOUND</code> 和 <code>&lt;PackageName&gt;_DIR</code> 变量，对于不同的库还会定义不同的变量，如何知道他们到底定义了哪些变量呢？</p><p>我有一个粗暴但好用的方法：在调试时，遍历当前 CMake 中的所有变量。</p><p>下面 dump_all_variables 函数会输出当前 CMake 的所有变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(dump_all_variables)</span><br><span class="line">    <span class="keyword">get_cmake_property</span>(_VARS VARIABLES)</span><br><span class="line">    <span class="keyword">foreach</span> (_V <span class="variable">$&#123;_VARS&#125;</span>)</span><br><span class="line">        <span class="keyword">message</span>(STATUS <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; $&#123;_V&#125; = $&#123;$&#123;_V&#125;&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">endforeach</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump_all_variables()</span><br></pre></td></tr></table></figure><h2 id="1-3-集成-Qt"><a href="#1-3-集成-Qt" class="headerlink" title="1.3 集成 Qt"></a>1.3 集成 Qt</h2><p>在项目中集成 Qt 库需要先使用 find_package 查找 Qt 的安装位置。对于 Qt4， CMake 使用 Module 模式进行查找（<a href="https://cmake.org/cmake/help/latest/module/FindQt4.html#module:FindQt4">FindQt4.cmake</a> 由 CMake 提供），而 对于 Qt5、Qt6，则是使用 Config 模式进行查找，相应的 config 文件位于类似下面的目录中 <code>D:\Qt\5.15.2\msvc2019\lib\cmake</code>。</p><p>具体从哪些位置查找 Qt，参见上面的“find_package”章节。</p><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Qt6 COMPONENTS Widgets DBus REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(publisher publisher.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(publisher Qt6::Widgets Qt6::DBus)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Qt5 COMPONENTS Gui DBus REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(subscriber1 subscriber1.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(subscriber1 Qt5::Gui Qt5::DBus)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Qt4 REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(subscriber2 subscriber2.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(subscriber2 Qt4::QtGui Qt4::QtDBus)</span><br></pre></td></tr></table></figure><p>众所周知，编译 Qt 代码需要依赖 Qt 提供的一些工具来生成相关的 C++ 代码，如：</p><ul><li>moc<br>元对象编译器，将 Qt 扩展的 C++ 语法（如 Q_OBJECT）转换成标准 C++ 语法。</li><li>rcc<br>把 .qrc 资源文件编译成标准 C++ 代码。</li><li>uic<br>把 .ui 文件编译成标准 C++ 代码。</li></ul><p>在 CMake 中要使用这些工具并不复杂，只需要提前开启相关特性，CMake 就会自动调用相关工具。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><p>下面是一个简单的 CMake Qt 项目示例，该示例仅使用了 Qt 的 QWidget 模块。</p><p>源文件结构如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMakeLists.txt</span><br><span class="line">main.cpp</span><br><span class="line">mainwindow.cpp</span><br><span class="line">mainwindow.h</span><br><span class="line">mainwindow.ui</span><br></pre></td></tr></table></figure><p>CMakeLists.txt 内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(hello_qt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Qt5 REQUIRED COMPONENTS Widgets)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(hello_qt</span><br><span class="line">    main.cpp</span><br><span class="line">    mainwindow.cpp</span><br><span class="line">    mainwindow.h</span><br><span class="line">    mainwindow.ui</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello_qt PRIVATE Qt5::Widgets)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(MSVC)</span><br><span class="line">    <span class="keyword">target_compile_options</span>(hello_qt PRIVATE /execution-charset:utf-<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set_target_properties</span>(hello_qt PROPERTIES</span><br><span class="line">        WIN32_EXECUTABLE <span class="keyword">TRUE</span></span><br><span class="line">        VS_DEBUGGER_ENVIRONMENT <span class="string">&quot;PATH=$&#123;Qt5_DIR&#125;/../../../bin;%PATH%&quot;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(TARGETS hello_qt)</span><br></pre></td></tr></table></figure><p>在上面示例中，设置了可执行字符集为 utf-8，这种方式可以防止 Qt 在 MSVC 环境下出现中文乱码，详见之前的文章 <a href="/post/1337290471.html" title="拨开字符编码的迷雾(2)--编译器处理文件编码">拨开字符编码的迷雾(2)--编译器处理文件编码</a>。</p><p>设置 WIN32_EXECUTABLE 属性是为了让链接器使用 <code>/SUBSYSTEM:WINDOWS</code> 子系统，如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/XPxCxaXyn9-TinyTu.png"></p><p>而设置 VS_DEBUGGER_ENVIRONMENT 属性是为了设置 Visual Studio 的调试环境（如下图所示），确保在调试时能找到 Qt 的相关 dll 文件。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/BkDqAJGTBd-TinyTu.png"></p><blockquote><p>在之前的 <a href="/post/3678619994.html" title="Modern CMake 简明教程（上）">Modern CMake 简明教程（上）</a> 中已经介绍了目标属性的设置。</p></blockquote><h1 id="二、MSVC"><a href="#二、MSVC" class="headerlink" title="二、MSVC"></a>二、MSVC</h1><h2 id="2-1-设置-MSVC-运行库"><a href="#2-1-设置-MSVC-运行库" class="headerlink" title="2.1 设置 MSVC 运行库"></a>2.1 设置 MSVC 运行库</h2><p>MSVC 的运行库有 MD &#x2F; MDd 和 MT &#x2F; MTd 之分，下图是 Visual Studio 中设置运行库的界面。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/J0bRwZPcTf-TinyTu.png"></p><p>CMake 针对 MSVC 环境默认使用的是 MD &#x2F; MDd 运行库，通过下面的方式可以将运行库设置为 MT &#x2F; MTd：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要 CMake 3.15 及以上版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_MSVC_RUNTIME_LIBRARY <span class="string">&quot;MultiThreaded$&lt;$&lt;CONFIG:Debug&gt;:Debug&gt;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-2-预编译头文件"><a href="#2-2-预编译头文件" class="headerlink" title="2.2 预编译头文件"></a>2.2 预编译头文件</h2><p>CMake 在 3.16 版本中提供了 <a href="https://cmake.org/cmake/help/latest/command/target_precompile_headers.html">target_precompile_headers</a> 指令来添加预编译头文件，语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target_precompile_headers(&lt;<span class="keyword">target</span>&gt;</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [header1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [header2...] ...])</span><br></pre></td></tr></table></figure><p>在 3.16 版本之前，需要支持预编译头，可以参考网络上的解决方案：</p><p>定义 USE_MSVC_PCH 宏：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span>(USE_MSVC_PCH PCH_TARGET PCH_HEADER_FILE PCH_SOURCE_FILE)</span><br><span class="line">    <span class="keyword">if</span>(MSVC)</span><br><span class="line">        <span class="comment"># 获取预编译头文件的文件名，通常是stdafx</span></span><br><span class="line">        <span class="keyword">get_filename_component</span>(PCH_NAME <span class="variable">$&#123;PCH_HEADER_FILE&#125;</span> NAME_WE)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 生成预编译文件的路径</span></span><br><span class="line">        <span class="keyword">if</span>(CMAKE_CONFIGURATION_TYPES)</span><br><span class="line">            <span class="comment"># 如果有配置选项（Debug/Release），路径添加以及配置选项</span></span><br><span class="line">            <span class="keyword">SET</span>(PCH_DIR <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/PCH/$&#123;CMAKE_CFG_INTDIR&#125;&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>()</span><br><span class="line">            <span class="keyword">SET</span>(PCH_DIR <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/PCH&quot;</span>)</span><br><span class="line">        <span class="keyword">endif</span>()</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 创建预编译文件的路径</span></span><br><span class="line">        <span class="keyword">file</span>(<span class="keyword">MAKE_DIRECTORY</span> <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/PCH)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 设置项目属性，使用预编译头文件</span></span><br><span class="line">        <span class="keyword">set_target_properties</span>(<span class="variable">$&#123;PCH_TARGET&#125;</span> PROPERTIES COMPILE_FLAGS </span><br><span class="line">            <span class="string">&quot;/Yu$&#123;PCH_HEADER_FILE&#125; /FI$&#123;PCH_HEADER_FILE&#125; /Fp$&#123;PCH_DIR&#125;/$&#123;PCH_NAME&#125;.pch&quot;</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 预编译源文件（stdafx.cpp）设置属性，创建预编译文件</span></span><br><span class="line">        <span class="keyword">set_source_files_properties</span>(<span class="variable">$&#123;PCH_SOURCE_FILE&#125;</span> PROPERTIES COMPILE_FLAGS</span><br><span class="line">            <span class="string">&quot;/Yc$&#123;PCH_HEADER_FILE&#125;&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 把预编译文件寄到清除列表</span></span><br><span class="line">        <span class="keyword">set_directory_properties</span>(PROPERTIES</span><br><span class="line">            ADDITIONAL_MAKE_CLEAN_FILES <span class="variable">$&#123;PCH_DIR&#125;</span>/<span class="variable">$&#123;PCH_NAME&#125;</span>.pch)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br></pre></td></tr></table></figure><p>然后使用该宏添加预编译头文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE_MSVC_PCH(test_app stdafx.h stdafx.cpp)</span><br></pre></td></tr></table></figure><h1 id="三、相关资料"><a href="#三、相关资料" class="headerlink" title="三、相关资料"></a>三、相关资料</h1><p><a href="https://github.com/ttroy50/cmake-examples">https://github.com/ttroy50/cmake-examples</a></p><p><a href="https://github.com/Akagi201/learning-cmake">https://github.com/Akagi201/learning-cmake</a></p><p><a href="https://github.com/KDE/extra-cmake-modules">https://github.com/KDE/extra-cmake-modules</a></p><p><a href="https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1</a></p><p><a href="https://hsf-training.github.io/hsf-training-cmake-webpage/aio/index.html">https://hsf-training.github.io/hsf-training-cmake-webpage/aio/index.html</a></p><p><a href="https://github.com/rpavlik/cmake-modules">https://github.com/rpavlik/cmake-modules</a></p><p><a href="https://github.com/onqtam/awesome-cmake">https://github.com/onqtam/awesome-cmake</a></p><p><a href="https://github.com/Lectem/cpp-boilerplate">https://github.com/Lectem/cpp-boilerplate</a></p><p><a href="https://github.com/CLIUtils/modern_cmake">https://github.com/CLIUtils/modern_cmake</a></p><p><a href="https://github.com/dev-cafe/cmake-cookbook">https://github.com/dev-cafe/cmake-cookbook</a></p><p><a href="https://github.com/BrightXiaoHan/CMakeTutorial">https://github.com/BrightXiaoHan/CMakeTutorial</a></p><p><a href="https://cliutils.gitlab.io/modern-cmake/">https://cliutils.gitlab.io/modern-cmake/</a></p><p><a href="https://cgold.readthedocs.io/en/latest/">https://cgold.readthedocs.io/en/latest/</a></p><p><a href="https://www.siliceum.com/en/blog/post/cmake_01_cmake-basics">https://www.siliceum.com/en/blog/post/cmake_01_cmake-basics</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://cmake.org/&quot;&gt;CMake&lt;/a&gt; 是一个开源、跨平台的构建系统生成器（Build-system Generator）。&lt;/p&gt;
&lt;p&gt;本文是 Modern CMake 简明教程系列的下篇，上篇请移步至 &lt;a href=&quot;/post/3678619994.html&quot; title=&quot;Modern CMake 简明教程（上）&quot;&gt;《Modern CMake 简明教程（上）》&lt;/a&gt;，中篇请移步至 &lt;a href=&quot;/post/2304457467.html&quot; title=&quot;Modern CMake 简明教程（中）&quot;&gt;《Modern CMake 简明教程（中）》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本教程默认 CMake 最低版本为 3.16，即 &lt;code&gt;cmake_minimum_required(VERSION 3.16)&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="CMake" scheme="https://jiangxueqiao.com/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://jiangxueqiao.com/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>Modern CMake 简明教程（中）</title>
    <link href="https://jiangxueqiao.com/post/2304457467.html"/>
    <id>https://jiangxueqiao.com/post/2304457467.html</id>
    <published>2024-10-11T09:34:36.000Z</published>
    <updated>2025-01-11T09:29:15.415Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cmake.org/">CMake</a> 是一个开源、跨平台的构建系统生成器（Build-system Generator）。</p><p>本文是 Modern CMake 简明教程系列的中篇，上篇请移步 <a href="/post/3678619994.html" title="Modern CMake 简明教程（上）">《Modern CMake 简明教程（上）》</a></p><p>本教程默认 CMake 最低版本为 3.16，即 <code>cmake_minimum_required(VERSION 3.16)</code>。</p><span id="more"></span><h1 id="一、生成器表达式"><a href="#一、生成器表达式" class="headerlink" title="一、生成器表达式"></a>一、生成器表达式</h1><p>不知你是否思考过这样一个问题：我们在编译项目时，通常有不同的配置，如 Debug 和 Release，如何在不同的配置中定义不同的预编译宏、包含不同的目录、依赖不同的库呢？</p><p>其实要解决这个问题，并不困难，只需要使用到 CMake 中的 <a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html">生成器表达式</a>。我们在开源项目的 CMake 脚本中经常看到的 <code>$&lt;...&gt;</code> 这样的表达式就是生成器表达式，但通常都会嵌套使用，如 <code>$&lt;$&lt;...&gt;:...&gt;</code>。</p><p>生成器表达式通常有下面几种形式：</p><ul><li><code>$&lt;condition:true_string&gt;</code></li><li><code>$&lt;IF:condition,true_string,false_string&gt;</code></li><li><code>$&lt;BOOL:string&gt;</code></li><li>特定的语法形式，如 <code>$&lt;CONFIG:cfgs&gt;</code> 表示当前配置存在于 cfgs 列表中时，表达式结果为 1，否则为 0。</li></ul><p>前三种形式比较简单，最后一种形式虽然有多种类型，但我们通常只需要记忆几种常用的，有需要时查阅<a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#generator-expression-reference">官方文档</a>。</p><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1 $&lt;condition:true_string&gt;"></a>1.1 $&lt;condition:true_string&gt;</h2><p>condition 只允许为 0 或 1，其他任何值都会报错。</p><p>当 condition 为 1 时，表达式返回 true_string；</p><p>当 condition 为 0 时，表达式返回空字符串。</p><p>如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENABLE_JSONCPP <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(</span><br><span class="line">    my_lib PUBLIC </span><br><span class="line">    $&lt;<span class="variable">$&#123;ENABLE_JSONCPP&#125;</span>:<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/jsoncpp/<span class="keyword">include</span>&gt;  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2 $&lt;IF:condition,true_string,false_string&gt;"></a>1.2 $&lt;IF:condition,true_string,false_string&gt;</h2><p>condition 只允许为 0 或 1，其他任何值都会报错。</p><p>当 condition 为 1 时，表达式返回 true_string；</p><p>当 condition 为 0 时，表达式返回 false_string。</p><p>如下面示例，当设置了 ENABLE_JSONCPP 为 1 时，包含 jsoncpp 头文件，否则包含 rapidjson 头文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENABLE_JSONCPP <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(</span><br><span class="line">    my_lib PUBLIC </span><br><span class="line">    $&lt;<span class="keyword">IF</span>:<span class="variable">$&#123;ENABLE_JSONCPP&#125;</span>,<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/jsoncpp/<span class="keyword">include</span>,<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/rapidjson/<span class="keyword">include</span>&gt;  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="1-3"><a href="#1-3" class="headerlink" title="1.3 $&lt;BOOL:string&gt;"></a>1.3 $&lt;BOOL:string&gt;</h2><p>前面 2 种形式的 condition 都只允许为 0 或 1，这种限制未免有些呆板，如果 ENABLE_JSONCPP 的值不是 1 ，而是 ON 时，该怎么办呢？</p><p>此时可以使用 <code>$&lt;BOOL:string&gt;</code> 将其转换成 0 或 1。</p><p>何时转换成 0，何时转换成 1？可以参考前面的<a href="/post/3678619994.html" title="Modern CMake 简明教程（上）">《Modern CMake 简明教程（上）》</a> 的“条件判断”章节，在该章节中介绍的所有为假的情况都会转换成 0，其他情况则转换成 1。</p><p>该表达式的作用注定了其单独使用意义不大，通常都是和其他表达式一起使用，如将上面示例中的 ENABLE_JSONCPP 设置为 ON：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENABLE_JSONCPP <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(</span><br><span class="line">    my_lib PUBLIC </span><br><span class="line">    $&lt;<span class="keyword">IF</span>:$&lt;BOOL:<span class="variable">$&#123;ENABLE_JSONCPP&#125;</span>&gt;,<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/jsoncpp/<span class="keyword">include</span>,<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/rapidjson/<span class="keyword">include</span>&gt;  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="1-4-逻辑运算"><a href="#1-4-逻辑运算" class="headerlink" title="1.4 逻辑运算"></a>1.4 逻辑运算</h2><p>运算符表达式也支持与、或、非三种逻辑运算，语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$&lt;<span class="keyword">AND</span>:conditions&gt;</span><br><span class="line"></span><br><span class="line">$&lt;<span class="keyword">OR</span>:conditions&gt;</span><br><span class="line"></span><br><span class="line">$&lt;<span class="keyword">NOT</span>:condition&gt;</span><br></pre></td></tr></table></figure><p>其中，condition 都只允许是 0 或 1，conditions（复数形式）表示可以是由逗号分割的多个条件列表。</p><h2 id="1-5-其他常见表达式条件"><a href="#1-5-其他常见表达式条件" class="headerlink" title="1.5 其他常见表达式条件"></a>1.5 其他常见表达式条件</h2><p>CMake 还支持很多类型的生成器表达式，下面列举了一些常见的表达式，这些表达式通常都是用来作为上面介绍的表达式中的条件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串比较，string1 与 string2 相等则为 1，反之为 0</span></span><br><span class="line">$&lt;<span class="keyword">STREQUAL</span>:string1,string2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数值比较，相等为 1，反之为 0</span></span><br><span class="line">$&lt;<span class="keyword">EQUAL</span>:value1,value2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本比较，v1 小于 v2 时为 1，反之为 0</span></span><br><span class="line">$&lt;<span class="keyword">VERSION_LESS</span>:v1,v2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他版本比较</span></span><br><span class="line">$&lt;<span class="keyword">VERSION_GREATER</span>:v1,v2&gt;</span><br><span class="line">$&lt;<span class="keyword">VERSION_EQUAL</span>:v1,v2&gt;</span><br><span class="line">$&lt;<span class="keyword">VERSION_LESS_EQUAL</span>:v1,v2&gt;</span><br><span class="line">$&lt;<span class="keyword">VERSION_GREATER_EQUAL</span>:v1,v2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># string 存在于 list列表中时为 1，反之为 0</span></span><br><span class="line">$&lt;<span class="keyword">IN_LIST</span>:<span class="keyword">string</span>,<span class="keyword">list</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前配置名称</span></span><br><span class="line">$&lt;CONFIG&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前配置存在于cfgs列表中时为 1，反之为 0</span></span><br><span class="line">$&lt;CONFIG:cfgs&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平台ID，见 CMAKE_SYSTEM_NAME</span></span><br><span class="line">$&lt;PLATFORM_ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前平台ID存在于 platform_ids 列表中时为 1，反之为 0</span></span><br><span class="line">$&lt;PLATFORM_ID:platform_ids&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># C++编译器版本</span></span><br><span class="line">$&lt;CXX_COMPILER_VERSION&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># C++编译器版本与 version 匹配时为 1，反之为 0</span></span><br><span class="line"><span class="comment"># $&lt;CXX_COMPILER_VERSION:version&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前的C++编译器ID</span></span><br><span class="line">$&lt;CXX_COMPILER_ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前的C++编译器ID存在于 compiler_ids 列表中时为 1，反之为 0</span></span><br><span class="line">$&lt;CXX_COMPILER_ID:compiler_ids&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标存在时为 1，反之为 0</span></span><br><span class="line">$&lt;TARGET_EXISTS:tgt&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回tgt目标的prop属性的值，如果未设置该属性，则返回空字符串</span></span><br><span class="line">$&lt;TARGET_PROPERTY:tgt,prop&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回正在计算表达式的目标上的prop属性的值，如果未设置该属性，则返回空字符串</span></span><br><span class="line">$&lt;TARGET_PROPERTY:prop&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当使用 install(EXPORT) 导出属性时，返回 ... 内容，否则返回空</span></span><br><span class="line">$&lt;INSTALL_INTERFACE:...&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当使用 export()导出属性或者被同一构建系统内的另一个目标使用时，返回 ... 内容，否则返回空</span></span><br><span class="line">$&lt;BUILD_INTERFACE:...&gt;</span><br></pre></td></tr></table></figure><h2 id="1-6-转义字符"><a href="#1-6-转义字符" class="headerlink" title="1.6 转义字符"></a>1.6 转义字符</h2><p>在生成器表达式中如果需要使用特殊字符，可以使用其转移字符。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt;</span></span><br><span class="line">$&lt;ANGLE-R&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ,</span></span><br><span class="line">$&lt;COMMA&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ;</span></span><br><span class="line">$&lt;SEMICOLON&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;</span></span><br><span class="line"><span class="comment"># 需要 CMake &gt;= 3.30</span></span><br><span class="line">$&lt;QUOTE&gt;</span><br></pre></td></tr></table></figure><h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><p>侠义的“安装”是将<strong>目标编译生成的文件</strong>拷贝到<strong>指定位置</strong>，CMake 中的安装包含但不限于拷贝文件，还可以执行脚本、修改权限等操作。</p><p>上面这句话中，涉及到了2个术语，有必要解释一下。</p><p>“目标编译生成的文件”在 CMake 中有个学名，叫 <a href="https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#output-artifacts">Output Artifacts</a>，直译为输出工件，我更愿意将其翻译为“输出品”，不同类型的目标有不同的输出品，例如在 Windows 平台上，可执行程序输出 .exe 文件，动态库输出 .dll 文件（也可能包含 .lib 文件），静态库输出 .lib 文件…..</p><blockquote><p>请牢记 Artifacts 这个单词，在后面的很多定义中都会出现该词。</p></blockquote><p>“指定位置”，顾名思义，我们可以指定一个安装位置。CMake 会从 <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html">CMAKE_INSTALL_PREFIX</a> 变量中读取安装位置，该变量有默认值，我们也可以修改该变量来改变安装位置。</p><p>在不同的操作系统上，CMAKE_INSTALL_PREFIX 的默认值不同：</p><ul><li>Windows 系统：<code>C:/Program Files/$&#123;PROJECT_NAME&#125;</code><br>写入该目录需要管理员权限，因此如果安装失败，请检查是否具有管理员权限。</li><li>UNIX 系统：<code>/usr/local</code></li></ul><p>CMAKE_INSTALL_PREFIX 指定的位置是安装目录的根目录，不同类型的输出品会存放在其不同的子目录中，如 .lib 文件存放在 lib 目录，.dll 和 .exe 文件存放在 bin 目录，头文件存放在 include 目录，这些子目录的具体名称可以通过 <a href="https://cmake.org/cmake/help/latest/module/GNUInstallDirs.html">GNUInstallDirs</a> 提供的若干变量来获取，如 <code>CMAKE_INSTALL_BINDIR</code>、<code>CMAKE_INSTALL_LIBDIR</code>、<code>CMAKE_INSTALL_INCLUDEDIR</code> 等。</p><p>CMake 定义了下列常用的输出品种类（artifact-kind），这些种类在后面的 install 选项中会使用到：</p><ul><li>ARCHIVE<br>这种类型的输出品包含下列文件（默认位于 lib 目录）：   <ul><li>静态库，Windows 上是 .lib 文件，Linux 上是 .a 文件，但在 macOS 上标记为 FRAMEWORK 的除外。</li><li>动态库的导入库，如 .lib 文件。</li><li>在macOS系统上，为启用 ENABLE_EXPORTS 的共享库所创建的链接器导入文件（但标记为 FRAMEWORK 的情况除外）。</li></ul></li><li>LIBRARY<br>这种类型的输出品很少用到。</li><li>RUNTIME<br>这种类型的输出品包含下来文件（默认位于 bin 目录）：   <ul><li>各个系统所支持的可执行文件，如 Windows 上的 .exe。</li><li>动态库，如 .dll 和 .so 文件。</li></ul></li><li>OBJECTS<br>与对象库（使用<code>add_library(&lt;name&gt; OBJECT ...)</code>方式定义）关联的对象文件。</li><li>FRAMEWORK<br>在 macOS 上，标有 FRAMEWORK 属性的静态库和共享库都被视为 FRAMEWORK 类型。</li><li>BUNDLE<br>在 macOS 上，标有 MACOSX_BUNDLE 属性的可执行文件被视为 BUNDLE 类型。</li><li>PUBLIC_HEADER  </li><li>PRIVATE_HEADER</li></ul><h2 id="2-1-install"><a href="#2-1-install" class="headerlink" title="2.1 install"></a>2.1 install</h2><p>使用 <a href="https://cmake.org/cmake/help/latest/command/install.html">install</a> 指令可以定义在安装时需要执行的操作，install 可以定义很多类型的操作，包含但不限于拷贝输出品到指定位置、执行脚本等。</p><p>下面是 install 指令支持的调用形式：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS &lt;<span class="keyword">target</span>&gt;... [...])</span><br><span class="line"><span class="keyword">install</span>(IMPORTED_RUNTIME_ARTIFACTS &lt;<span class="keyword">target</span>&gt;... [...])</span><br><span class="line"><span class="keyword">install</span>(&#123;FILES | PROGRAMS&#125; &lt;<span class="keyword">file</span>&gt;... [...])</span><br><span class="line"><span class="keyword">install</span>(DIRECTORY &lt;dir&gt;... [...])</span><br><span class="line"><span class="keyword">install</span>(SCRIPT &lt;<span class="keyword">file</span>&gt; [...])</span><br><span class="line"><span class="keyword">install</span>(CODE &lt;code&gt; [...])</span><br><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> &lt;<span class="keyword">export</span>-name&gt; [...])</span><br><span class="line"><span class="keyword">install</span>(RUNTIME_DEPENDENCY_SET &lt;<span class="keyword">set</span>-name&gt; [...])</span><br></pre></td></tr></table></figure><p>通过执行 <code>make install</code> 命令或者编译 CMake 生成的 INSTALL 项目，就可以执行 install 指令预先定义的安装操作。</p><h2 id="2-2-不同的安装命令"><a href="#2-2-不同的安装命令" class="headerlink" title="2.2 不同的安装命令"></a>2.2 不同的安装命令</h2><h3 id="2-2-1-安装-Target"><a href="#2-2-1-安装-Target" class="headerlink" title="2.2.1 安装 Target"></a>2.2.1 安装 Target</h3><p>所谓安装 Target 就是将目标的输出品及其关联文件拷贝到指定位置。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS &lt;<span class="keyword">target</span>&gt;... [<span class="keyword">EXPORT</span> &lt;<span class="keyword">export</span>-name&gt;]</span><br><span class="line">        [RUNTIME_DEPENDENCIES &lt;arg&gt;...|RUNTIME_DEPENDENCY_SET &lt;<span class="keyword">set</span>-name&gt;]</span><br><span class="line">        [&lt;artifact-<span class="keyword">option</span>&gt;...]</span><br><span class="line">        [&lt;artifact-kind&gt; &lt;artifact-<span class="keyword">option</span>&gt;...]...</span><br><span class="line">        [INCLUDES DESTINATION [&lt;dir&gt; ...]]</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><code>&lt;artifact-option&gt;</code> 用于指定与输出品相关的选项，可以是下面选项中的一个或多个（常用的选项主要是 DESTINATION 和 PERMISSIONS）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[DESTINATION &lt;dir&gt;]</span><br><span class="line">[PERMISSIONS &lt;permission&gt;...]</span><br><span class="line">[CONFIGURATIONS &lt;config&gt;...]</span><br><span class="line">[COMPONENT &lt;component&gt;]</span><br><span class="line">[NAMELINK_COMPONENT &lt;component&gt;]</span><br><span class="line">[OPTIONAL] [EXCLUDE_FROM_ALL]</span><br><span class="line">[NAMELINK_ONLY|NAMELINK_SKIP]</span><br></pre></td></tr></table></figure><p>第一组 <code>&lt;artifact-option&gt;</code> 所设置的选项应用于在本次调用中没有指定输出品类型时。</p><p>我们通常会为不同类型的输出品指定不同的选项，如下面示例为不同类型的输出品指定了不同的安装位置：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(hello_cmake PROPERTIES PUBLIC_HEADER <span class="keyword">include</span>/my_lib.h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(TARGETS hello_cmake</span><br><span class="line">    ARCHIVE DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>  <span class="comment"># 仅为演示，这样写多此一举</span></span><br><span class="line">    RUNTIME DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span>  <span class="comment"># 仅为演示，这样写多此一举</span></span><br><span class="line">    PUBLIC_HEADER DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span>/my_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>在实际项目中，我们不会使用 PUBLIC_HEADER 来安装头文件，而是使用下面介绍的 <code>install(DIRECTORY ... )</code> 命令。</p></blockquote><h4 id="EXPORT选项"><a href="#EXPORT选项" class="headerlink" title="EXPORT选项"></a>EXPORT选项</h4><p><code>EXPORT</code> 是一个非常有用的选项，当我们的项目需要作为库被第三方使用时，为了让第三方能够通过 find_package 所查找到所安装的库，就需要在安装时生成 <code>xxxConfig.cmake</code> 文件。</p><p>当然，仅仅通过在此指定 EXPORT 选项还不够，此处的 EXPORT 选项仅仅表示将 Target 所安装的输出品绑定到 <code>&lt;export-name&gt;</code> 上，后面我们还需要使用单独的 <code>install(EXPORT ...)</code> 语句来生成 <code>xxxConfig.cmake</code> 文件，详见下面的 “安装导出依赖项” 节。</p><h3 id="2-2-2-拷贝目录"><a href="#2-2-2-拷贝目录" class="headerlink" title="2.2.2 拷贝目录"></a>2.2.2 拷贝目录</h3><p>拷贝目录到指定位置，语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY dirs...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br><span class="line">        [FILE_PERMISSIONS &lt;permission&gt;...]</span><br><span class="line">        [DIRECTORY_PERMISSIONS &lt;permission&gt;...]</span><br><span class="line">        [USE_SOURCE_PERMISSIONS] [OPTIONAL] [MESSAGE_NEVER]</span><br><span class="line">        [CONFIGURATIONS &lt;config&gt;...]</span><br><span class="line">        [COMPONENT &lt;component&gt;] [EXCLUDE_FROM_ALL]</span><br><span class="line">        [FILES_MATCHING]</span><br><span class="line">        [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]</span><br><span class="line">         [EXCLUDE] [PERMISSIONS &lt;permission&gt;...]] [...])</span><br></pre></td></tr></table></figure><p>可以使用 TYPE 或 DESTINATION 来指定目标路径，其中 TYPE 的取值来自于 <a href="https://cmake.org/cmake/help/latest/module/GNUInstallDirs.html">GNUInstallDirs</a> 提供的若干变量，如 BIN 等同于 CMAKE_INSTALL_BINDIR 变量。</p><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY ./common TYPE <span class="keyword">INCLUDE</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(DIRECTORY ./common DESTINATION <span class="string">&quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-3-拷贝文件"><a href="#2-2-3-拷贝文件" class="headerlink" title="2.2.3 拷贝文件"></a>2.2.3 拷贝文件</h3><p>拷贝文件到指定位置，语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(FILES &lt;<span class="keyword">file</span>&gt;...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br><span class="line">        [PERMISSIONS &lt;permission&gt;...]</span><br><span class="line">        [CONFIGURATIONS &lt;config&gt;...]</span><br><span class="line">        [COMPONENT &lt;component&gt;]</span><br><span class="line">        [RENAME &lt;name&gt;] [OPTIONAL] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure><h3 id="2-2-4-执行脚本"><a href="#2-2-4-执行脚本" class="headerlink" title="2.2.4 执行脚本"></a>2.2.4 执行脚本</h3><p>在安装时执行脚本文件或者脚本代码，语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>([[SCRIPT &lt;<span class="keyword">file</span>&gt;] [CODE &lt;code&gt;]]</span><br><span class="line">        [ALL_COMPONENTS | COMPONENT &lt;component&gt;]</span><br><span class="line">        [EXCLUDE_FROM_ALL] [...])</span><br></pre></td></tr></table></figure><p>如果脚本文件的路径是相对路径，则该路径相对于当前项目的根目录（即 CMAKE_SOURCE_DIR 变量存储的路径）。</p><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(SCRIPT <span class="string">&quot;./my_lib/helper.cmake&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(CODE <span class="string">&quot;message(\&quot;Sample install message.\&quot;)&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-5-安装导出依赖项"><a href="#2-2-5-安装导出依赖项" class="headerlink" title="2.2.5 安装导出依赖项"></a>2.2.5 安装导出依赖项</h3><p>如果在安装 Target（见上面的5.2.1节） 时已经指定了 EXPORT 选项，则可以通过 <code>install(EXPORT ...)</code> 的形式来安装需要导出的依赖性，即生成 <code>xxxConfig.cmake</code> 文件，该文件名不是固定的，可以通过 FILE 选项来指定其他名称，但必须是 <code>.cmake</code> 类型的文件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> &lt;<span class="keyword">export</span>-name&gt; DESTINATION &lt;dir&gt;</span><br><span class="line">        [NAMESPACE &lt;namespace&gt;] [<span class="keyword">FILE</span> &lt;name&gt;.cmake]</span><br><span class="line">        [PERMISSIONS &lt;permission&gt;...]</span><br><span class="line">        [CONFIGURATIONS &lt;config&gt;...]</span><br><span class="line">        [CXX_MODULES_DIRECTORY &lt;directory&gt;]</span><br><span class="line">        [EXPORT_LINK_INTERFACE_LIBRARIES]</span><br><span class="line">        [COMPONENT &lt;component&gt;]</span><br><span class="line">        [EXCLUDE_FROM_ALL]</span><br><span class="line">        [EXPORT_PACKAGE_DEPENDENCIES])</span><br></pre></td></tr></table></figure><p><code>&lt;export-name&gt;</code> 选项所指定的名称需要与在 <code>install(TARGET ... EXPORT ...)</code> 语句中指定名称一致。</p><p>通常为了防止和其他库命名冲突，我们会使用 NAMESPACE 添加命名空间。</p><p>在生成 <code>xxxConfig.cmake</code> 文件以后，就可以使用 <code>find_package</code> 来查找并引用依赖库了：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(MyLib REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(OtherApp PRIVATE my_lib::my_lib)</span><br></pre></td></tr></table></figure><h1 id="三、与-CMake-交互"><a href="#三、与-CMake-交互" class="headerlink" title="三、与 CMake 交互"></a>三、与 CMake 交互</h1><p>CMake 与构建项目交互的方式有两种:</p><ol><li>使用 <a href="https://cmake.org/cmake/help/latest/command/configure_file.html">configure_file</a> 指令动态生成配置文件，通过配置文件的方式来将数据传递给项目，如在 C&#x2F;C++ 项目中动态生成 .h 文件。</li><li>使用 <a href="https://cmake.org/cmake/help/latest/command/file.html">file</a> 指令创建配置文件，file 指令的功能非常强大，包含众多与文件相关的操作，如读写文件、下载上传文件、遍历目录等。</li></ol><p>本节只介绍 <a href="https://cmake.org/cmake/help/latest/command/configure_file.html">configure_file</a> 指令，该指令用于根据模板文件在指定位置生成新的文件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configure_file</span>(&lt;input&gt; &lt;output&gt;</span><br><span class="line">               [NO_SOURCE_PERMISSIONS | USE_SOURCE_PERMISSIONS |</span><br><span class="line">                FILE_PERMISSIONS &lt;permissions&gt;...]</span><br><span class="line">               [COPYONLY] [ESCAPE_QUOTES] [@ONLY]</span><br><span class="line">               [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])</span><br></pre></td></tr></table></figure><p>我们首先需要通过 <code>&lt;input&gt;</code> 选项来指定一个模板文件，虽然模板文件可以是任意的后缀名，但我们通常使用 <code>.in</code> 后缀名，例如我们需要通过模板文件生成 version.h 文件，则模板文件名为 <code>version.h.in</code>。</p><p>configure_file 指令会将 <code>&lt;input&gt;</code> 模板文件中的诸如 <code>@VAR@</code>、<code>$&#123;VAR&#125;</code>、<code>$CACHE&#123;VAR&#125;</code>、<code>$ENV&#123;VAR&#125;</code> 形式的变量都替换为对应变量的值，如果变量没有被定义，则替换为空字符串。</p><p>我们通常还会指定 <code>@ONLY</code> 选项，指定该选项后，就只有 <code>@VAR@</code> 形式的变量会被替换，而其他形式的变量会保留不变，这种方式虽然在生成 .h 文件时没有什么用途，但谁又说 configure_file 只能生成 .h 文件了？如果是生成 .cmake 文件，是不是就有作用了咧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version.h.in</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION_MAJOR @VERSION_MAJOR@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION_MINOR @VERSION_MINOR@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION_PATCH @VERSION_PATCH@</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUILD_TIMESTAMP <span class="string">&quot;@BUILD_TIMESTAMP@&quot;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span>(TIMESTAMP BUILD_TIMESTAMP <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(VERSION_MAJOR <span class="number">1</span>)</span><br><span class="line"><span class="keyword">set</span>(VERSION_MINOR <span class="number">0</span>)</span><br><span class="line"><span class="keyword">set</span>(VERSION_PATCH <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">configure_file</span> (</span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/include/version.h.in&quot;</span></span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/include/version.h&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行 CMake 脚本，动态生成的 version.h 内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION_MAJOR 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION_MINOR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION_PATCH 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUILD_TIMESTAMP <span class="string">&quot;2024-09-30 16:51:57&quot;</span></span></span><br></pre></td></tr></table></figure><p>上述变量替换的方式有一个弊端：虽然能动态替换模板语句中变量的值，但却不能控制语句是否存在。比如我们经常在 C&#x2F;C++ 项目中根据宏是否被定义来做判断，而不是根据宏的值来做判断：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> BUILD_SHARED_LIBS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个是时候就需要使用另外一个语法形式了：<code>#cmakedefine VAR ...</code>，在这种形式中是直接使用变量名的，而不需要使用 <code>@ @</code> 进行包裹。</p><p>当定义了 VAR 变量时，将替换为（…就是模板文件中 VAR 后面的内容）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VAR ...</span></span><br></pre></td></tr></table></figure><p>当没有定义 VAR 变量时，将替换为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* #undef VAR */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://cmake.org/&quot;&gt;CMake&lt;/a&gt; 是一个开源、跨平台的构建系统生成器（Build-system Generator）。&lt;/p&gt;
&lt;p&gt;本文是 Modern CMake 简明教程系列的中篇，上篇请移步 &lt;a href=&quot;/post/3678619994.html&quot; title=&quot;Modern CMake 简明教程（上）&quot;&gt;《Modern CMake 简明教程（上）》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本教程默认 CMake 最低版本为 3.16，即 &lt;code&gt;cmake_minimum_required(VERSION 3.16)&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="CMake" scheme="https://jiangxueqiao.com/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://jiangxueqiao.com/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>Modern CMake 简明教程（上）</title>
    <link href="https://jiangxueqiao.com/post/3678619994.html"/>
    <id>https://jiangxueqiao.com/post/3678619994.html</id>
    <published>2024-10-08T09:30:36.000Z</published>
    <updated>2025-01-10T12:14:48.299Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cmake.org/">CMake</a> 是一个开源、跨平台的构建系统生成器（Build-system Generator）。</p><p>CMake 是构建系统生成器，而不是构建系统，CMake 支持生成不同构建系统所支持的工程文件，如 Visual Studio，XCode，Makefile 等。</p><p>本教程作为 CMake 的简明教程，不会事无巨细的讲述 CMake 的每一个语法，而是以实用为目的，介绍 CMake 的基础语法和常用指令。</p><p>虽然只是简明教程，但通过本教程，你仍然可以掌握 CMake 的脉络，熟练应用 CMake 于项目中。</p><span id="more"></span><h1 id="一、Modern-CMake"><a href="#一、Modern-CMake" class="headerlink" title="一、Modern CMake"></a>一、Modern CMake</h1><p>CMake 距今已有 20 多年的历史，CMake 从 3.0 开始引入 Target 概念，有了 Target 和 Property 的定义，CMake 也就更加地现代化。</p><p>我们将引入 Target 概念之前（也就是 3.0 之前）的 CMake 称之为老式 CMake，之后的称之为现代 CMake（Modern CMake）。</p><p>现代 CMake 是围绕 Target 和 Property 来定义的，在现代 CMake 中不应该出现诸如下面的指令：</p><ul><li>add_compile_options</li><li>include_directories</li><li>link_directories</li><li>link_libraries</li></ul><p>因为这些指令都是目录级别的，在该目录（含子目录）上定义的所有目标都会继承这些属性，这样会导致出现很多隐藏依赖和多余属性的情况。</p><p>我们最好直接针对 Target 进行操作，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 老式写法</span></span><br><span class="line"><span class="keyword">include_directories</span>(./<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现代写法</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(hello PRIVATE ./<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p><strong>本文讲述的知识点只适用于现代 CMake，让我们脱掉沉重的历史包袱，轻装上阵吧！</strong></p><h1 id="二、基础概念"><a href="#二、基础概念" class="headerlink" title="二、基础概念"></a>二、基础概念</h1><p>所有的构建系统都需要通过某个入口点来定义项目（如 Visual Studio 的 .sln 文件），CMake 作为构建系统生成器也不例外，CMake 使用的是 <code>CMakeLists.txt</code> 的文件，该文件以 UTF-8 编码（也支持 UTF-8 BOM 文件头），其中存储了符合 CMake 语言规范的脚本代码。</p><h2 id="2-1-项目结构"><a href="#2-1-项目结构" class="headerlink" title="2.1 项目结构"></a>2.1 项目结构</h2><p>CMake 没有强制规定 CMakeLists.txt 文件的位置以及项目的目录结构，但目前大多数项目都会采用相似的目录结构。</p><p>如果项目名称为 my_project，且该项目包含一个名为 lib 的库和一个名为 app 的程序，则目录结构通常如下面所示：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- my_project</span><br><span class="line">  - .gitignore</span><br><span class="line">  - README.md</span><br><span class="line">  - LICENSE.md</span><br><span class="line">  - CMakeLists.txt</span><br><span class="line">  - cmake</span><br><span class="line">    - FindSomeLib.cmake</span><br><span class="line">    - something_else.cmake</span><br><span class="line">  - include</span><br><span class="line">    - my_project</span><br><span class="line">      - lib.h</span><br><span class="line">  - src</span><br><span class="line">    - CMakeLists.txt</span><br><span class="line">    - lib.cpp</span><br><span class="line">  - apps</span><br><span class="line">    - CMakeLists.txt</span><br><span class="line">    - app.cpp</span><br><span class="line">  - tests</span><br><span class="line">    - CMakeLists.txt</span><br><span class="line">    - testlib.cpp</span><br><span class="line">  - docs</span><br><span class="line">    - CMakeLists.txt</span><br><span class="line">  - extern</span><br><span class="line">    - googletest</span><br><span class="line">  - scripts</span><br><span class="line">    - helper.py</span><br></pre></td></tr></table></figure><p>当然，上面的名称并不是一成不变的，可以根据自己的喜好来定义，例如 my_project 可以是任意的项目名，如果不喜欢复数，可以将 tests 改成test，如果没有 python 代码，也可以移除 python 目录，cmake 目录则用于存放 CMake 辅助脚本。</p><p>从上面的目录结构可以看到，CMakeLists.txt 文件分散在各个子目录中，但在 include 目录中没有 CMakeList.txt 文件，这样是为了防止暴露不必要的文件给库的使用者，因为 include 目录中存放的是库的头文件，在安装时通常都会将该目录拷贝到指定位置（如Linux系统的 &#x2F;usr&#x2F;include）。</p><p>extern 目录用于存放第三方依赖库的源码，这些库可以通过 <code>git submodule</code> 的形式来管理，也可以直接将源码拷贝到此，并提交到项目 git 中。但无论使用哪种方式，依赖库最好能支持 CMake，这样可以方便的使用 <code>add_subdirectory</code> 命令将项目添加到工程中（如果你对 add_subdirectory 命令的具体用法还不了解，这没关系，现在你只需要知道该命令可以添加任何包含 CMakeLists.txt 的目录到项目中即可）。</p><h2 id="2-2-一个简单的示例"><a href="#2-2-一个简单的示例" class="headerlink" title="2.2 一个简单的示例"></a>2.2 一个简单的示例</h2><p>在学习 CMake 之前，我们先将 CMake 玩起来。我们先从一个简单的示例开始，了解 CMake 的基本玩法。</p><p>该示例是只包含一个 main.cpp 文件，我们期望编译该文件能生成 hello_cmake 程序。</p><p>目录结构如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- hello_cmake</span><br><span class="line">  - main.cpp</span><br><span class="line">  - CMakeLists.txt</span><br></pre></td></tr></table></figure><p>main.cpp 文件的内容非常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello cmake&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMakeLists.txt 内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 CMake 的最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目名称</span></span><br><span class="line"><span class="keyword">project</span> (hello_cmake)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个名为 hello_cmake 的目标</span></span><br><span class="line"><span class="comment"># 目标类型为可执行文件</span></span><br><span class="line"><span class="comment"># 使用 main.cpp 来编译生成 hello_cmake 可执行文件（如hello_cmake.exe）</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello_cmake main.cpp)</span><br></pre></td></tr></table></figure><p>完成上面步骤，我们就可以使用 CMake GUI 或命令行（当然你需要提前安装 CMake，这不在本文的介绍范围之内）就可以生成相应的工程了。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/n3oz6wn7Ke-TinyTu.png"></p><p>通过 CMake 命令行生成 Visual Studio 工程的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake.exe -G <span class="string">&quot;Visual Studio 15 2017&quot;</span> -S .\hello_cmake -B .\hello_cmake\build</span><br></pre></td></tr></table></figure><h2 id="2-3-源码外构建"><a href="#2-3-源码外构建" class="headerlink" title="2.3 源码外构建"></a>2.3 源码外构建</h2><p>我们通常会将构建目录指定到一个单独的子目录内，这个目录名称的通常是 <code>build</code>。如果不这样做，CMake 生成的工程文件和临时缓存文件会污染源码目录。这种方式有个学名叫“源码外构建” (out-of-source build)。</p><p>使用源码外构建时，我们通常还会将 build 目录添加到 .gitignore 文件中。</p><h2 id="2-4-工作流程"><a href="#2-4-工作流程" class="headerlink" title="2.4 工作流程"></a>2.4 工作流程</h2><p>编写 CMake 脚本的基本流程如下：</p><ol><li>在脚本第一行使用 cmake_minimum_required 指定运行当前脚本所需的 CMake 最低版本。</li><li>使用 project 指定项目名称。</li><li>使用 add_executable 或 add_library 创建目标。</li><li>为目标设置包含目录、链接库等属性（可选）。</li><li>安装（可选）。</li></ol><p>编写完 CMake 脚本以后，就可以使用 CMake GUI 或命令行来生成对应的工程文件了。以 Visual Studio 为例，对于有 my_lib 库 和 app 应用程序的项目，CMake 会生成如下图所示的 5 个项目：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/Qv1nk8g1ZA.png"></p><p>下面介绍 CMake 自动生成的一些项目的作用：</p><ul><li>编译 ALL_BUILD 项目会自动编译除 INSTALL 项目外的所有项目。</li><li>编译 INSTALL 项目会执行 CMake 脚本中指定的安装操作。</li><li>编译 ZERO_CHECK 项目会再次执行 CMake 脚本，重新生成项目。因此若 CMake 脚本有更新，既可以使用 CMake 工具来重新生成项目，也可以是重新编译 ZERO_CHECK 项目。</li></ul><h2 id="2-5-注释"><a href="#2-5-注释" class="headerlink" title="2.5 注释"></a>2.5 注释</h2><p>在 CMake 中使用 <code>#</code> 来声明单行注释，这是我们使用最多的注释方法。虽然也支持使用 <code>#[[ ]]</code> 来声明多行注释（也称块注释），但是使用的比较少，例如:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[[</span></span><br><span class="line"><span class="comment">  这是多行注释也称块注释</span></span><br><span class="line"><span class="comment">  你明白了吗？</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure><h2 id="2-6-CMake最低版本"><a href="#2-6-CMake最低版本" class="headerlink" title="2.6 CMake最低版本"></a>2.6 CMake最低版本</h2><p><a href="https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html">cmake_minimum_required</a> 是我们接触到第一个 CMake 指令，该指令用于指定编译该脚本所需的最低 CMake 版本。</p><p>你可以在 CMakeList.txt 文件的第一行都使用该指令来指定运行当前脚本需要的最低 CMake 版本，但我们通常只需要在主 CMakeList.txt （何为主 CMakeList.txt？见下面的“项目名称”小节） 中的第一行使用该指令即可。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION &lt;min&gt;[...&lt;policy_max&gt;] [FATAL_ERROR])</span><br></pre></td></tr></table></figure><p>如果运行 CMake 的版本低于<min>要求的版本，则将停止处理该脚本并返回错误。</p><p>我们始终应该选择一个比编译器晚发布的 CMake 版本，因为只有这样，CMake 才能支持新的编译器选项。但最低版本不应低于 3.0，实际项目中通常最低版本不会低于 3.16（该版本于2020年09月15日发布），本教程也是以此为标准进行讲解的。</p><h2 id="2-7-项目名称"><a href="#2-7-项目名称" class="headerlink" title="2.7 项目名称"></a>2.7 项目名称</h2><p>使用 <a href="https://cmake.org/cmake/help/latest/command/project.html">project</a> 指定项目名称。</p><p>项目名称区别于目标（Target）名称，以 Visual Studio 为例，project 指定的名称对应“解决方案名称”，而 add_executable 或 add_library 等指定的名称才对应具体项目名和生成的“目标文件名”。</p><p>设置项目名称后，CMake 会自动定义一些变量（<em>变量的具体用法会在稍后的“3.1 变量”小节进行介绍</em>）。为了方便介绍各个变量的含义，假设我们是通过如下命令来运行 CMake 的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake.exe -G <span class="string">&quot;Visual Studio 15 2017&quot;</span> -S D:\hello_cmake -B D:\hello_cmake\build</span><br></pre></td></tr></table></figure><p>下面列举了一些 CMake 自动定义的变量：</p><ul><li>PROJECT_NAME<br>项目名称，如 hello_cmake</li><li>CMAKE_PROJECT_NAME<br>如果 CMakeLists.txt 位于项目的顶级目录，还会定义 CMAKE_PROJECT_NAME 变量，值与 PROJECT_NAME 一致。</li><li>PROJECT_SOURCE_DIR<br>项目的根目录（绝对路径），即 <code>-S</code> 参数指定的目录，如 D:\hello_cmake</li><li>&lt;PROJECT-NAME&gt;_SOURCE_DIR<br>值与 PROJECT_SOURCE_DIR 相同，只是变量名不同，如 hello_cmake_SOURCE_DIR  </li><li>PROJECT_BINARY_DIR<br>项目的构建目录（绝对路径），即 <code>-B</code> 参数指定的目录，如 D:\hello_cmake\build</li><li>&lt;PROJECT-NAME&gt;_BINARY_DIR<br>值与 PROJECT_BINARY_DIR 相同，只是变量名不同，如 hello_cmake_BINARY_DIR</li></ul><h3 id="主CMakeLists-txt"><a href="#主CMakeLists-txt" class="headerlink" title="主CMakeLists.txt"></a>主CMakeLists.txt</h3><p>主 CMakeLists.txt 即项目根目录下的 CMakeLists.txt 文件。可以通过检查 CMAKE_PROJECT_NAME 与 PROJECT_NAME 变量是否相同来判断当前的 CMakeLists.txt 文件是否为主 CMakeLists.txt。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_PROJECT_NAME <span class="keyword">STREQUAL</span> PROJECT_NAME)</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h2 id="2-8-目标类型"><a href="#2-8-目标类型" class="headerlink" title="2.8 目标类型"></a>2.8 目标类型</h2><p>既然现代 CMake 是围绕目标（Target）工作的，Target 如此重要，那我们首先就需要创建一个 Target。</p><p>在 C&#x2F;C++ 开发中，常见的 Target 类型有：可执行文件、静态库、动态库，CMake 还额外提供了一个 MODULE 类型。</p><p>下面列举了不同类型的目标的创建方式。</p><h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><p>使用 <a href="https://cmake.org/cmake/help/latest/command/add_executable.html">add_executable</a> 指令可以创建可执行文件类型的目标。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(my_exe main.cpp)</span><br></pre></td></tr></table></figure><h3 id="动态库和静态库"><a href="#动态库和静态库" class="headerlink" title="动态库和静态库"></a>动态库和静态库</h3><p>通过为 <a href="https://cmake.org/cmake/help/latest/command/add_library.html">add_library</a> 指令指定不同的参数，可以创建动态库和静态库。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(&lt;name&gt; [&lt;type&gt;] [EXCLUDE_FROM_ALL] &lt;sources&gt;...)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(my_lib SHARED main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(my_lib STATIC main.cpp)</span><br></pre></td></tr></table></figure><p>我们也可以在 add_library 中不指定类型参数，改为通过设置 BUILD_SHARED_LIBS 变量来切换静态库和动态库。下面示例在脚本中设置了 BUILD_SHARED_LIBS 变量值为 ON （ON &#x2F; OFF 对应 CMake 中的开&#x2F;关）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (hello_cmake)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(BUILD_SHARED_LIBS <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(hello_cmake main.cpp)</span><br></pre></td></tr></table></figure><p>也可以通过命令行参数进行指定 BUILD_SHARED_LIBS 变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake.exe -G <span class="string">&quot;Visual Studio 15 2017&quot;</span> -DBUILD_SHARED_LIBS=ON -S .\hello_cmake -B .\hello_cmake\build</span><br></pre></td></tr></table></figure><p>亦可以在 GUI 界面上设置 BUILD_SHARED_LIBS 变量，如：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/nx0MX2PY7u-TinyTu.png"></p><h1 id="三、基础语法"><a href="#三、基础语法" class="headerlink" title="三、基础语法"></a>三、基础语法</h1><h2 id="3-1-变量"><a href="#3-1-变量" class="headerlink" title="3.1 变量"></a>3.1 变量</h2><h3 id="3-1-1-变量的定义"><a href="#3-1-1-变量的定义" class="headerlink" title="3.1.1 变量的定义"></a>3.1.1 变量的定义</h3><p>在 CMake 中使用 <a href="https://cmake.org/cmake/help/latest/command/set.html">set</a> 和 <code>unset</code> 命令来定义和取消定义变量。</p><p>CMake 的变量没有类型一说，因为其变量值始终是字符串类型。</p><p>基于上述原因，在 CMake 中不能直接使用 <code>+</code>、<code>-</code>、<code>*</code>、<code>\</code> 等操作符对变量进行数学运算，需要使用 <a href="https://cmake.org/cmake/help/latest/command/math.html">math</a> 指令，也不能直接使用 <code>&gt;</code>、<code>&lt;</code>、<code>==</code> 等操作符对变量进行逻辑运算，需要使用 LESS、EQUAL 进行判断，详见下面的“条件判断”章节。</p><p>CMake 的变量名是<strong>大小写敏感</strong>的，而且其变量名不像其他语言那样有各种限制，它可以包含任何字符，如空格、问号等，但如果变量名中包含<code>#</code>（该符号用于行注释），则需要使用 <code>\#</code> 进行转义。</p><p>下面的语句都是合法的：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(abc <span class="number">123</span>)</span><br><span class="line"><span class="keyword">set</span>(ABC <span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(<span class="string">&quot;ab c&quot;</span> <span class="string">&quot;456&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(<span class="string">&quot;ab?c&quot;</span> <span class="string">&quot;789&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(<span class="string">&quot;/usr/bin/bash&quot;</span> <span class="string">&quot;987&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(<span class="string">&quot;C:\\Program Files\\&quot;</span> <span class="string">&quot;654&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(<span class="string">&quot; &quot;</span> <span class="string">&quot;321&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(\<span class="comment"># &quot;321&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unset</span>(a)</span><br></pre></td></tr></table></figure><p>虽然 CMake 允许变量名为任意字符串，但我们仍然建议在变量名称中仅包含字母、数字、<code>-</code> 和 <code>_</code> ，而且字母为大写字母，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建议的命名方式</span></span><br><span class="line"><span class="keyword">set</span>(QT_VERSION <span class="string">&quot;5.15.2&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(LIB_NAME <span class="string">&quot;my_lib&quot;</span>)</span><br></pre></td></tr></table></figure><p>CMake 还会保留一些标识符，我们在定义变量时尽量不要使用这些名称（你执意要用，CMake 也不会报错）：</p><ul><li>以 <code>CMAKE_</code> 开头的。</li><li>以 <code>_CMAKE_</code> 开头的。</li><li>以 <code>_&lt;cmake command&gt;</code> 开头的，如 _file，完整的 command 列表见：<a href="https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html">cmake-commands</a>。</li></ul><p>在定义完变量以后，就可以通过 <code>$&#123;variable&#125;</code> 的形式进行引用了，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(QT_VERSION <span class="string">&quot;5.15.2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;QT_VERSION is $&#123;QT_VERSION&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>在 CMake 中，还可以通过引用变量的方式来定义新的变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(a <span class="string">&quot;xyz&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(b <span class="string">&quot;$&#123;a&#125;_321&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(<span class="variable">$&#123;a&#125;</span>_1 <span class="string">&quot;456&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(variable_<span class="variable">$&#123;a&#125;</span> <span class="string">&quot;$&#123;a&#125; + $&#123;b&#125; + 15&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;b: &#x27;$&#123;b&#125;&#x27;&quot;</span>) <span class="comment"># b: &#x27;xyz_321&#x27;</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;xyz_1: &#x27;$&#123;xyz_1&#125;&#x27;&quot;</span>) <span class="comment"># xyz_1: &#x27;456&#x27;</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;variable_xyz: &#x27;$&#123;variable_xyz&#125;&#x27;&quot;</span>) <span class="comment"># variable_xyz: &#x27;xyz + xyz_321 + 15&#x27;</span></span><br></pre></td></tr></table></figure><p>环境变量的引用方式有所不同，在下面的环境变量章节会详细介绍，而且在 if 条件中可以省略 <code>$&#123;&#125;</code>，直接使用变量名，如 <code>if(QT_VERSION)</code>。</p><p>CMake 还允许使用未定义的变量，未定义的变量的值为空字符串。</p><p>CMake 也允许重复定义变量，变量的值采用最后定义的值。</p><h3 id="3-1-2-调试输出"><a href="#3-1-2-调试输出" class="headerlink" title="3.1.2 调试输出"></a>3.1.2 调试输出</h3><h4 id="message"><a href="#message" class="headerlink" title="message"></a>message</h4><p>为了方便调试脚本，我们可以使用 <a href="https://cmake.org/cmake/help/latest/command/message.html">messsage</a> 指令来输出变量和调试信息。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>([&lt;mode&gt;] <span class="string">&quot;message text&quot;</span> ...)</span><br></pre></td></tr></table></figure><p><code>&lt;mode&gt;</code> 关键字是可选的，它用于指定消息的类型，消息类型会影响 CMake 对该消息的处理方式。</p><p>常用的消息类型有：</p><ul><li>FATAL_ERROR<br>致命错误（红色），只有该类型会导致脚本终止执行。</li><li>WARNING<br>警告（红色），脚本继续执行。</li><li><strong>NOTICE（默认）</strong><br>需要特别关注的消息（红色），脚本继续执行。</li><li>STATUS<br>普通输出，正常颜色，脚本也会继续执行。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;Current version is 1.0.0.1&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;BUILD_SHARED_LIBS value is $&#123;BUILD_SHARED_LIBS&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="cmake-print-variables"><a href="#cmake-print-variables" class="headerlink" title="cmake_print_variables"></a>cmake_print_variables</h4><p>如果只是单纯地想打印变量的值，使用 messsage 显得有些繁琐，我们可以使用 cmake_print_variables 函数来打印变量的值，该函数以 <code>variable=value</code> 格式输出每个变量的值，方便进行观察。</p><p>由于该函数由 CMake 的 CMakePrintHelpers 模块提供，因此在使用之前，需要先 <code>include(CMakePrintHelpers)</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(CMakePrintHelpers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(MY_NAME <span class="string">&quot;jack&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(MY_ADDRESS <span class="string">&quot;Hubei&quot;</span>)</span><br><span class="line"></span><br><span class="line">cmake_print_variables(MY_NAME MY_ADDRESS) <span class="comment"># MY_NAME=&quot;jack&quot; ; MY_ADDRESS=&quot;Hubei&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-3-列表"><a href="#3-1-3-列表" class="headerlink" title="3.1.3 列表"></a>3.1.3 列表</h3><p>列表就是简单地包含一系列值，使用空格分割每个值：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST a b <span class="string">&quot;c&quot;</span> <span class="number">1</span> <span class="number">2</span> <span class="variable">$&#123;MY_NAME&#125;</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>也可以使用 <code>;</code> 来代替空格：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST <span class="string">&quot;a;b;c;1;2;$&#123;MY_NAME&#125;;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(MY_LIST a;b;c;<span class="number">1</span>;<span class="number">2</span>;<span class="variable">$&#123;MY_NAME&#125;</span>;<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h4 id="list-命令"><a href="#list-命令" class="headerlink" title="list 命令"></a>list 命令</h4><p><a href="https://cmake.org/cmake/help/latest/command/list.html">list</a> 命令提供了众多针对列表的操作，如获取元素个数、查找、添加、删除、排序等。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取元素个数</span></span><br><span class="line"><span class="keyword">list</span>(LENGTH &lt;<span class="keyword">list</span>&gt; &lt;out-var&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定下标（可以指定多个下标）的元素</span></span><br><span class="line"><span class="keyword">list</span>(GET &lt;<span class="keyword">list</span>&gt; &lt;element index&gt; [&lt;index&gt; ...] &lt;out-var&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接2个列表</span></span><br><span class="line"><span class="keyword">list</span>(JOIN &lt;<span class="keyword">list</span>&gt; &lt;glue&gt; &lt;out-var&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定位置指定长度的一段列表</span></span><br><span class="line"><span class="keyword">list</span>(SUBLIST &lt;<span class="keyword">list</span>&gt; &lt;begin&gt; &lt;length&gt; &lt;out-var&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找，&lt;out-var&gt;中存储查找到的元素下标，如果没找到则为-1</span></span><br><span class="line"><span class="keyword">list</span>(FIND &lt;<span class="keyword">list</span>&gt; &lt;value&gt; &lt;out-var&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在列表尾部添加若干元素</span></span><br><span class="line"><span class="keyword">list</span>(APPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt;...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按条件过滤列表</span></span><br><span class="line"><span class="keyword">list</span>(FILTER &lt;<span class="keyword">list</span>&gt; &lt;<span class="keyword">INCLUDE</span>|EXCLUDE&gt; REGEX &lt;regular_expression&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在指定位置插入若干元素</span></span><br><span class="line"><span class="keyword">list</span>(INSERT &lt;<span class="keyword">list</span>&gt; &lt;index&gt; [&lt;element&gt;...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹出尾部的若干元素（如果没有指定&lt;out-var&gt;变量，则只弹出一个）</span></span><br><span class="line"><span class="keyword">list</span>(POP_BACK &lt;<span class="keyword">list</span>&gt; [&lt;out-var&gt;...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹出头部的若干元素（如果没有指定&lt;out-var&gt;变量，则只弹出一个）</span></span><br><span class="line"><span class="keyword">list</span>(POP_FRONT &lt;<span class="keyword">list</span>&gt; [&lt;out-var&gt;...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将若干元素插入到列表的头部，如果&lt;list&gt;没有被定义，则相当于创建了一个新的列表</span></span><br><span class="line"><span class="keyword">list</span>(PREPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt;...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除列表中的若干元素</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM &lt;<span class="keyword">list</span>&gt; &lt;value&gt;...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除列表中指定位置（可以指定多个）的元素</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_AT &lt;<span class="keyword">list</span>&gt; &lt;index&gt;...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除列表中的重复项目。保留项目的相对顺序，但如果遇到重复项，则仅保留第一个实例。</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_DUPLICATES &lt;<span class="keyword">list</span>&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照&lt;ACTION&gt;对列表元素进行转换</span></span><br><span class="line"><span class="keyword">list</span>(TRANSFORM &lt;<span class="keyword">list</span>&gt; &lt;ACTION&gt; [&lt;SELECTOR&gt;] [OUTPUT_VARIABLE &lt;output variable&gt;])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表反转</span></span><br><span class="line"><span class="keyword">list</span>(REVERSE &lt;<span class="keyword">list</span>&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表排序</span></span><br><span class="line"><span class="keyword">list</span>(SORT &lt;<span class="keyword">list</span>&gt; [COMPARE &lt;compare&gt;] [CASE &lt;case&gt;] [ORDER &lt;order&gt;])</span><br></pre></td></tr></table></figure><p>下面仅简单地演示 2 个列表功能的用法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(NAME_LIST jack jim jeff tom)</span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>(LENGTH NAME_LIST NAME_COUNT)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;name count: $&#123;NAME_COUNT&#125;&quot;</span>) <span class="comment"># name count: 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>(FIND NAME_LIST jim JIM_INDEX)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;jim at: $&#123;JIM_INDEX&#125;&quot;</span>) <span class="comment"># jim at: 1</span></span><br></pre></td></tr></table></figure><h4 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h4><p>可以使用 foreach 来遍历列表，下面示例演示了如何使用 foreach 遍历输出 MY_LIST 列表中每个元素，其中 _ITEM 变量的作用域仅限 foreach 代码块。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST hello world)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(_ITEM <span class="variable">$&#123;MY_LIST&#125;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;_ITEM&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><p>我们还可以使用 <a href="https://cmake.org/cmake/help/latest/command/while.html">while</a> 来遍历列表，详见下面的“循环”章节。</p><h3 id="3-1-4-双引号的作用"><a href="#3-1-4-双引号的作用" class="headerlink" title="3.1.4 双引号的作用"></a>3.1.4 双引号的作用</h3><p>学习到这里，也许你会感到困扰，在定义变量时，为什么有时候使用双引号把值包围起来，有时候又不使用呢？</p><p>我们已经学习完了列表的相关知识，现在就可以解释加不加引号的区别了。</p><p>在定义变量时，若变量值中包含空格，此时不使用双引号包裹，则等同于定义列表；使用双引号包裹，则等同于定义字符串变量。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义的MY_VAR为列表，包含2个元素：hello、world</span></span><br><span class="line"><span class="keyword">set</span>(MY_VAR hello world)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义的MY_VAR为字符串</span></span><br><span class="line"><span class="keyword">set</span>(MY_VAR <span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><p>对于列表类型的变量，在使用时是否使用双引号包裹也会有区别：有双引号包裹时，会将数组元素以分号作为分隔符进行拼接，否则会直接拼接各元素。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST hello world)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;MY_LIST&#125;&quot;</span>) <span class="comment"># hello;world</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="variable">$&#123;MY_LIST&#125;</span>) <span class="comment"># helloworld</span></span><br></pre></td></tr></table></figure><h3 id="3-1-5-三种不同的变量"><a href="#3-1-5-三种不同的变量" class="headerlink" title="3.1.5 三种不同的变量"></a>3.1.5 三种不同的变量</h3><p>CMake 中的变量分为普通变量、缓存变量和环境变量，三者都可以通过 <code>set</code> 指令进行定义。</p><h4 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h4><p>下面使用 <code>set</code> 定义的变量就是普通变量。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_NAME <span class="string">&quot;jack&quot;</span>)</span><br></pre></td></tr></table></figure><p>也可以在 CMake 命令行中通过 <code>-D</code> 参数定义普通变量，如下面示例定义了 BUILD_SHARED_LIBS 和 TEST 变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake.exe -G <span class="string">&quot;Visual Studio 15 2017&quot;</span> -DBUILD_SHARED_LIBS=ON -DTEST=123 -S .\hello_cmake -B .\hello_cmake\build</span><br></pre></td></tr></table></figure><h4 id="缓存变量"><a href="#缓存变量" class="headerlink" title="缓存变量"></a>缓存变量</h4><p>缓存变量也是通过 <code>set</code> 指令定义的，但需要添加额外的参数：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])</span><br></pre></td></tr></table></figure><p>下面示例定义了一个名为 LIB_VERSION 的缓存变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(LIB_VERSION <span class="string">&quot;1.0.0.1&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;the version of library&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (hello_cmake)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(hello_cmake main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;LIB_VERSION = $&#123;LIB_VERSION&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://blog-static.jiangxueqiao.com/blog/img/ycHxFOTmrG-TinyTu.png"></p><p>使用 CMake GUI 程序执行该脚本，可以看到界面上多出了一个名为 LIB_VERSION 的文本输入框，而且输入框有默认值 1.0.0.1。</p><p>将输入框中的文本修改为 1.0.0.2，再次执行该脚本，可以发现调试输出的内容是 <code>LIB_VERSION = 1.0.0.2</code>，而且无论我们执行多少次脚本，始终输出的都是该内容。</p><p>这是因为 CMake 会将缓存变量及其值存储到 “构建目录\CMakeCache.txt” 文件中，下次运行脚本时，会优先从该文件中加载变量，该文件内容格式大致如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># build\CMakeCache.txt 文件</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">//the version of library</span><br><span class="line">LIB_VERSION:STRING=1.0.0.2</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;type&gt;</code> 用于指定变量的输入类型。请注意，<code>&lt;type&gt;</code> 指定的不是变量的类型，因为 CMake 的所有变量都是字符串类型。<code>&lt;type&gt;</code> 指定的是输入类型，仅用于帮助 CMake GUI 程序显示不同的用户输入控件，如文本输入框、复选框、文件选择对话框等。 </p><p><code>&lt;type&gt;</code> 的取值必须是下面列表中的一个：</p><ul><li>BOOL<br>开关ON或OFF，在 CMake GUI 上提供一个复选框。</li><li>PATH<br>文件夹的路径，在 CMake GUI 上提供一个文本输入框和一个按钮来打开<strong>文件夹</strong>选择对话框。</li><li>FILEPATH<br>文件的路径，在 CMake GUI 上提供一个文本输入框和一个按钮来打开文件选择对话框。</li><li>STRING<br>文本字符串，在 CMake GUI 上提供一个文本输入框。</li><li>STRINGS<br>文本字符串，但在 CMake GUI 上会提供一个下拉列表选择框。</li><li>INTERNAL<br>虽然也是文本字符串，但不会显示在 CMake GUI 上，因此用户无法在界面上修改该变量的值。</li></ul><p>如果我们不希望某些缓存变量直接展示 CMake GUI 上，可以使用 <a href="https://cmake.org/cmake/help/latest/command/mark_as_advanced.html">mark_as_advanced</a> 指令将缓存变量设置为高级状态，这样除非用户打开了 “Show Advanced” 选项，否则高级变量不会显示在 CMake GUI 中。在脚本模式下，高级&#x2F;非高级状态是无效的。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(DEBUG_LIBNAME_SUFFIX <span class="string">&quot;-d&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;Optional suffix to append to the library name for a debug build&quot;</span>)</span><br><span class="line"><span class="keyword">mark_as_advanced</span>(DEBUG_LIBNAME_SUFFIX)</span><br></pre></td></tr></table></figure><h4 id="option"><a href="#option" class="headerlink" title="option"></a>option</h4><p>虽然 <a href="https://cmake.org/cmake/help/latest/command/option.html">option</a> 也可用于定义缓存变量，但其只能定义“开&#x2F;关”类型的变量。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span>(ENABLE_TEST <span class="string">&quot;enable test or not&quot;</span> <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><p>如果未指定初始值，默认为 OFF。</p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>环境变量的定义方式如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENV&#123;&lt;variable&gt;&#125; [&lt;value&gt;])</span><br></pre></td></tr></table></figure><p>环境变量在引用时，需要在前面添加 <code>ENV</code> 标识，如 <code>$ENV&#123;&lt;variable&gt;&#125;</code></p><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENV&#123;USER_NAME&#125; <span class="string">&quot;jack&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;User name is $ENV&#123;USER_NAME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>CMake 程序在启动时，会加载系统的环境变量，同时还会设置一些内置的环境变量，内置的环境变量见 <a href="https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html">cmake-env-variables</a>。</p><p>CMake 虽然会加载系统的环境变量，我们也可以修改该环境变量，但该修改操作不会影响到系统的环境变量。</p><p>定义或加载的环境变量只会作用于当前的 CMake 进程，而且对当前进程所运行的所有脚本都可见，但不会影响到其他 CMake 进程和系统中的其他进程。</p><h3 id="3-1-6-变量作用域"><a href="#3-1-6-变量作用域" class="headerlink" title="3.1.6 变量作用域"></a>3.1.6 变量作用域</h3><p>在上面介绍三种不同的变量时，我一直在竭力避免讨论一个话题，那就是变量的作用域。事实上，上面三种变量还有个不同之处就是作用域的不同。</p><p>缓存变量和环境变量都是全局的，它们可以跨文件、目录、函数进行读写，因此作用域主要针对普通变量而言。</p><p>CMake 中作用域分为“目录级别作用域”和“函数作用域”（也可以使用 <a href="https://cmake.org/cmake/help/latest/command/block.html">block()</a> 来显式的创建一个作用域，但这种使用方式非常少）。</p><p>函数有自己的作用域，在函数中定义的变量只能在函数体中使用，函数体外无法访问。除非在定义变量时添加 <code>PARENT_SCOPE</code> 来将变量作用域设置为上一级目录。</p><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>使用 <a href="https://cmake.org/cmake/help/latest/command/include.html">include</a> 指令可以加载和执行其他 CMake 脚本文件（名称通常为 <code>*.cmake</code>），include 会在 <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html">CMAKE_MODULE_PATH</a> 变量指定的目录列表中搜索指定文件。</p><p>使用 include 指令加载cmake文件时，无需指定 <code>.cmake</code> 后缀，指定文件名即可，假设在 A（CMakeLists.txt或*.cmake）中调用 <code>include(B)</code> 加载 B.cmake ，则 A 和 B 之间可以相互读写彼此的变量（包含普通变量、缓存变量和环境变量）。</p><p>当然，在 <code>B.cmake</code> 文件中也可以使用 include 指令加载执行其他的 cmake 文件。</p><h4 id="add-subdirectory"><a href="#add-subdirectory" class="headerlink" title="add_subdirectory"></a>add_subdirectory</h4><p>使用 <a href="https://cmake.org/cmake/help/latest/command/add_subdirectory.html">add_subdirectory</a> 指令可以添加一个子目录到项目构建中，但是被添加的子目录中必须包含 CMakeLists.txt 文件。</p><p>假设在 A (CMakeLists.txt文件) 中调用 <code>add_subdirectory(lib)</code> 添加了 lib 子目录，则 lib 目录中的 CMakeLists.txt 可以读写 A 中的普通变量，但 A 不能读写 lib 目录 CMakeLists.txt 的普通变量。但可以在定义变量时添加 <code>PARENT_SCOPE</code> 选项来突破该限制，将变量作用域设置为上一级作用域，即父目录的作用域，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lib\CMakeLists.txt 文件</span></span><br><span class="line"><span class="keyword">set</span>(LIB_NAME <span class="string">&quot;MyTestLib&quot;</span> PARENT_SCOPE)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以访问 LIB_NAME 变量</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;LIB_NAME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="3-2-数学运算"><a href="#3-2-数学运算" class="headerlink" title="3.2 数学运算"></a>3.2 数学运算</h2><p>在前面章节已经提到了 CMake 中的值都是以字符串类型存储的，不能直接使用数学运算符符进行运算，需要使用 <a href="https://cmake.org/cmake/help/latest/command/math.html">math</a> 指令进行数学运算。</p><p>math 的语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">math</span>(EXPR &lt;variable&gt; <span class="string">&quot;&lt;expression&gt;&quot;</span> [OUTPUT_FORMAT &lt;format&gt;])</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;variable&gt;</code>变量如果没有定义，math 会自动定义该变量；</p><p>OUTPUT_FORMAT 选项用于指定计算结果的进制（十六进制或十进制）：</p><ul><li>HEXADECIMAL  十六进制</li><li>DECIMAL 十进制（默认）</li></ul><p>math 支持如下运算符：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ - * / % | &amp; ^ ~ &lt;&lt; &gt;&gt;  (...)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># value 等于 &quot;300&quot;</span></span><br><span class="line"><span class="keyword">math</span>(EXPR value <span class="string">&quot;100 * 3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># value 等于 &quot;1000&quot;</span></span><br><span class="line"><span class="keyword">math</span>(EXPR value <span class="string">&quot;100 * 0xA&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># value 等于 &quot;0x12c&quot;</span></span><br><span class="line"><span class="keyword">math</span>(EXPR value <span class="string">&quot;100 * 3&quot;</span> OUTPUT_FORMAT HEXADECIMAL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(value <span class="number">3</span>)</span><br><span class="line"><span class="keyword">math</span>(EXPR value <span class="string">&quot;100 * $&#123;value&#125;&quot;</span>)   <span class="comment"># value 等于 &quot;300&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># value 等于 &quot;306&quot;</span></span><br><span class="line"><span class="keyword">math</span>(EXPR value <span class="string">&quot;(100 + 2) * 3&quot;</span>)      </span><br></pre></td></tr></table></figure><h2 id="3-3-条件判断"><a href="#3-3-条件判断" class="headerlink" title="3.3 条件判断"></a>3.3 条件判断</h2><p>在 CMake 中，使用 <a href="https://cmake.org/cmake/help/latest/command/if.html">if</a> 进行条件判断，语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;condition&gt;)</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">elseif</span>(&lt;condition&gt;) <span class="comment"># 可选的，可以有多个</span></span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">else</span>()              <span class="comment"># 可选的</span></span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>与众多语言中的 if 一样，当括号中的条件为真时，才执行指定的 commands。</p><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(a <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">LESS</span> <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;a &lt; 10&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;a &gt;= 10&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>else() 和 endif() 括号中的内容可以为空，但如果需要指定，则就必须与 if 中的条件完全一致，如下面示例所示：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(a <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">LESS</span> <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;a &lt; 10&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>(a <span class="keyword">LESS</span> <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;a &gt;= 10&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>(a <span class="keyword">LESS</span> <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>我们通常不在 else() 和 endif() 中指定条件，因为这样太繁琐了。</p><h3 id="3-3-1-真值与假值"><a href="#3-3-1-真值与假值" class="headerlink" title="3.3.1 真值与假值"></a>3.3.1 真值与假值</h3><p>何为真，何为假，人生真真假假，难以分辨，程序的真假却清清楚楚。</p><p>下列常量始终为真（不区分大小写）：</p><ul><li>1 和其他非零数字（包含浮点型），如 1、2、3.14</li><li>ON</li><li>YES</li><li>TRUE</li><li>Y</li></ul><p>下列常量始终为假（不区分大小写）：</p><ul><li>0</li><li>OFF</li><li>NO</li><li>FALSE</li><li>N</li><li>IGNORE</li><li>NOTFOUND</li><li>空字符串</li><li>被引号包裹的字符串（除始终为真的字符串外，如 TRUE、Y 等）</li></ul><h3 id="3-3-2-逻辑运算符"><a href="#3-3-2-逻辑运算符" class="headerlink" title="3.3.2 逻辑运算符"></a>3.3.2 逻辑运算符</h3><p>在 CMake 中，逻辑运算符的与、或、非分别使用 AND、OR、NOT 表示。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> &lt;condition&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(&lt;cond1&gt; <span class="keyword">AND</span> &lt;cond2&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(&lt;cond1&gt; <span class="keyword">OR</span> &lt;cond2&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((condition) <span class="keyword">AND</span> (condition <span class="keyword">OR</span> (condition)))</span><br></pre></td></tr></table></figure><h3 id="3-3-3-关系运算符"><a href="#3-3-3-关系运算符" class="headerlink" title="3.3.3 关系运算符"></a>3.3.3 关系运算符</h3><p>由于 CMake 变量都是以字符串类型存储的，因此即便是数字也不能直接使用 <code>&gt;</code>、<code>&lt;</code>、<code>==</code> 这样的运算符来直接比较。</p><p>针对数值类型，CMake 支持的关系运算符如下：</p><ul><li>LESS  小于</li><li>LESS_EQUAL  小于等于</li><li>GREATER  大于</li><li>GREATER_EQUAL  大于等于</li><li>EQUAL  等于</li></ul><p>CMake 还支持字符串比较，即从左到右依次比较字符串中的每个字符，出现不相同时立即返回，类似于 C 语言中的 strcmp 函数。</p><ul><li>STRLESS  </li><li>STRLESS_EQUAL </li><li>STRGREATER </li><li>STRGREATER_EQUAL </li><li>STREQUAL</li></ul><h3 id="3-3-4-存在性校验"><a href="#3-3-4-存在性校验" class="headerlink" title="3.3.4 存在性校验"></a>3.3.4 存在性校验</h3><p>CMake 提供了一些判断变量是否定义、目标是否创建、元素是否存在于列表中、文件&#x2F;目录是否存在等方法。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定名称是否是可以调用的指令</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">COMMAND</span> &lt;<span class="keyword">command</span>-name&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定名称是否是已创建的目标，即通过add_executable()、add_library() 或 add_custom_target() 命令创建</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">TARGET</span> &lt;<span class="keyword">target</span>-name&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定名称的普通变量、缓存变量、环境变量是否已定义</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">DEFINED</span> &lt;name&gt;|CACHE&#123;&lt;name&gt;&#125;|ENV&#123;&lt;name&gt;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定的元素是否包含在列表中</span></span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">IN_LIST</span> &lt;variable&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定的文件或目录是否存在</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">EXISTS</span> &lt;path-to-<span class="keyword">file</span>-<span class="keyword">or</span>-directory&gt;)</span><br></pre></td></tr></table></figure><h2 id="3-4-循环"><a href="#3-4-循环" class="headerlink" title="3.4 循环"></a>3.4 循环</h2><p>CMake 有两种循环方式：</p><ul><li><a href="https://cmake.org/cmake/help/latest/command/foreach.html">foreach</a>  </li><li><a href="https://cmake.org/cmake/help/latest/command/while.html">while</a></li></ul><p>二者都可以使用 break() 提前退出循环和 continue() 跳过本次循环。</p><h3 id="3-4-1-foreach"><a href="#3-4-1-foreach" class="headerlink" title="3.4.1 foreach"></a>3.4.1 foreach</h3><p>下面是 foreach 的基本语法形式，这种形式在之前的“遍历列表”章节已经使用到了：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; &lt;items&gt;)</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(_ITEM <span class="variable">$&#123;MY_LIST&#125;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;_ITEM&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><p>foreach 还支持下面两种语法形式，这两种形式都不需要指定列表 <code>&lt;items&gt;</code> 参数，作用类似于 C 语言中的 for 语句：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 循环 [0 ~ &lt;stop&gt;]，步长为 1</span></span><br><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; RANGE &lt;stop&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环 [&lt;start&gt; ~ &lt;stop&gt;]，步长为 &lt;step&gt;（可选）</span></span><br><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; RANGE &lt;start&gt; &lt;stop&gt; [&lt;step&gt;])</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(_I RANGE <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;_I&#125;&quot;</span>) <span class="comment"># 依次输出 0 1 2 3</span></span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(_I RANGE <span class="number">2</span> <span class="number">5</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;_I&#125;&quot;</span>) <span class="comment"># 依次输出 2 3 4 5</span></span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(_I RANGE <span class="number">2</span> <span class="number">5</span> <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;_I&#125;&quot;</span>) <span class="comment"># 依次输出 2 4</span></span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><h3 id="3-4-2-while"><a href="#3-4-2-while" class="headerlink" title="3.4.2 while"></a>3.4.2 while</h3><p>while 的语法形式如下，其中 <code>&lt;condition&gt;</code> 为真时（参考 if 条件判断章节），执行代码块中的 commands 命令。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(&lt;condition&gt;)</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endwhile</span>()</span><br></pre></td></tr></table></figure><p>下面示例演示了如何使用 while 来遍历列表：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line"><span class="keyword">list</span>(LENGTH MY_LIST LIST_COUNT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(INDEX <span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span>(INDEX <span class="keyword">LESS</span> LIST_COUNT)</span><br><span class="line">  <span class="keyword">list</span>(GET MY_LIST <span class="variable">$&#123;INDEX&#125;</span> VALUE) <span class="comment"># 获取 $&#123;INDEX&#125; 位置的元素</span></span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;element at $&#123;INDEX&#125; = $&#123;VALUE&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">math</span>(EXPR INDEX <span class="string">&quot;$&#123;INDEX&#125; + 1&quot;</span>) <span class="comment"># 自增 INDEX</span></span><br><span class="line"><span class="keyword">endwhile</span>()</span><br></pre></td></tr></table></figure><p>上面示例依次输出如下内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element at 0 = 1</span><br><span class="line">element at 1 = 2</span><br><span class="line">element at 2 = 3</span><br></pre></td></tr></table></figure><h2 id="3-5-函数和宏"><a href="#3-5-函数和宏" class="headerlink" title="3.5 函数和宏"></a>3.5 函数和宏</h2><h3 id="3-5-1-函数"><a href="#3-5-1-函数" class="headerlink" title="3.5.1 函数"></a>3.5.1 函数</h3><p>使用 <a href="https://cmake.org/cmake/help/latest/command/function.html">function</a> 定义函数：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(&lt;name&gt; [&lt;arg1&gt; ...])</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure><p>函数有自己的作用域，而宏没有自己的作用域，在函数体里面定义的普通变量默认只能在函数体中被访问，除非在定义时指定了 <code>PARENT_SCOPE</code> 选项，或者改为定义缓存变量、环境变量。</p><p>函数在被调用时，函数名是不区分大小写的，如我们定义了名为 <code>foo</code> 的函数，就可以使用 <code>foo()</code>、<code>Foo()</code>、<code>FOO()</code> 等形式来调用，但我们还是建议保持与函数定义时的名称一致。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>关于函数的参数，我们可以在定义函数时就指定各个参数的名称，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(my_func NAME AGE)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;name: $&#123;NAME&#125;&quot;</span>) <span class="comment"># name: jack </span></span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;age: $&#123;AGE&#125;&quot;</span>) <span class="comment"># age: 18</span></span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line">my_func(<span class="string">&quot;jack&quot;</span> <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>在调用函数时，调用参数（实参）的个数可以超过定义的参数个数（形参），但不能少于定义的参数个数，否则会报错。超出的参数，可以通过下面的形式获取：</p><ul><li>使用 <code>ARGV0</code>, <code>ARGV1</code>, <code>ARGV2</code>, <code>...</code> 变量获取函数的每个参数。</li><li>使用 <code>ARGV</code> 变量获取函数的参数列表，通过 <code>ARGN</code> 变量获取参数的个数。</li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>使用 <code>return()</code> 可以从函数体中提前返回，但不能直接使用 return() 带出返回值，需要借用 <code>set(&lt;variable&gt; &lt;value&gt; PARENT_SCOPE)</code> 方式，来间接的带出返回值。</p><p>下面示例演示了函数的定义、调用、参数的获取以及返回值的用法。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(my_func NAME AGE)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;name: $&#123;NAME&#125;&quot;</span>) <span class="comment"># name: jack</span></span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;parameter count: $&#123;ARGC&#125;&quot;</span>) <span class="comment"># parameter count: 3</span></span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;parameter list: $&#123;ARGV&#125;&quot;</span>) <span class="comment"># parameter list: jack;18;Hubei</span></span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;parameter 0: $&#123;ARGV0&#125;&quot;</span>) <span class="comment"># parameter 0: jack</span></span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;parameter 2: $&#123;ARGV1&#125;&quot;</span>) <span class="comment"># parameter 2: Hubei</span></span><br><span class="line">  <span class="keyword">set</span>(FUNC_RET <span class="string">&quot;OK&quot;</span> PARENT_SCOPE)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line">my_func(<span class="string">&quot;jack&quot;</span> <span class="number">18</span> <span class="string">&quot;Hubei&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;return value: $&#123;FUNC_RET&#125;&quot;</span>) <span class="comment"># return value: OK</span></span><br></pre></td></tr></table></figure><p>但在实际项目中，除需要传入不定个数的参数情况外，我们通常在定义函数时，就约定好了参数名称和返回参数的名称，如下面示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(my_func NAME AGE OUT_RET)</span><br><span class="line">  <span class="comment"># 使用 $&#123;NAME&#125; $&#123;AGE&#125; 访问参数</span></span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;name: $&#123;NAME&#125;&quot;</span>) <span class="comment"># name: jack</span></span><br><span class="line">  <span class="keyword">set</span>(OUT_RET <span class="string">&quot;OK&quot;</span> PARENT_SCOPE)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line">my_func(<span class="string">&quot;jack&quot;</span> <span class="number">18</span> OUT_RET)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;return value: $&#123;OUT_RET&#125;&quot;</span>) <span class="comment"># return value: OK</span></span><br></pre></td></tr></table></figure><h3 id="3-5-2-宏"><a href="#3-5-2-宏" class="headerlink" title="3.5.2 宏"></a>3.5.2 宏</h3><p>使用 <a href="https://cmake.org/cmake/help/latest/command/macro.html">macro</a> 定义宏：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span>(&lt;name&gt; [&lt;arg1&gt; ...])</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br></pre></td></tr></table></figure><p>CMake 中的宏和 C 语言中的宏一样，是在调用处进行语句替换后再执行，因此在宏中使用 <code>return()</code> 时要格外小心，可能会终止整个脚本的执行。</p><p>建议优先使用函数。</p><h2 id="3-6-字符串操作"><a href="#3-6-字符串操作" class="headerlink" title="3.6 字符串操作"></a>3.6 字符串操作</h2><p>字符串操作由 <a href="https://cmake.org/cmake/help/latest/command/string.html">string</a> 指令提供，详见官方文档。</p><h2 id="3-7-内置变量"><a href="#3-7-内置变量" class="headerlink" title="3.7 内置变量"></a>3.7 内置变量</h2><p>本节列举了在项目中经常用到的 CMake 内置变量。</p><ul><li><p>CMAKE_SOURCE_DIR<br>始终存储的是项目的根目录。</p></li><li><p>CMAKE_BINARY_DIR<br>始终存储的是项目的根构建目录。</p></li><li><p>PROJECT_SOURCE_DIR<br>与 CMAKE_SOURCE_DIR 一样，也始终存储的是项目的根目录，但该变量需要使用 project 创建项目以后，才会被定义。</p></li><li><p>PROJECT_BINARY_DIR<br>与 CMAKE_BINARY_DIR 一样，也始终存储的是项目的构建目录，但该变量需要使用 project 创建项目以后，才会被定义。</p></li><li><p>CMAKE_CURRENT_SOURCE_DIR<br>存储的是当前正在执行脚本所在的目录。</p></li><li><p>CMAKE_CURRENT_BINARY_DIR<br>一个工程中可能包括多个项目，每个项目的构建目录不同，该变量存储的是当前项目的构建目录。</p></li><li><p>CMAKE_CURRENT_LIST_FILE<br>当前脚本代码所在文件的完整路径。</p></li><li><p>CMAKE_CURRENT_LIST_LINE<br>当前脚本代码所在行数。</p></li><li><p>CMAKE_MODULE_PATH<br>通过设置改变变量，可以控制 CMake 查找 <code>.cmake</code> 文件的路径，在使用 <code>include</code> 时就可以直接使用文件名了。如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(utils)</span><br></pre></td></tr></table></figure><p>需要注意的是，当在 include 中仅指定了文件名时，不能再添加 <code>.cmake</code> 扩展名，否则会导致查找不到相应文件。</p></li><li><p>WIN32<br>在 Windows 系统上，定义该变量，值为 1。</p></li><li><p>APPLE<br>在 Apple 系统上，定义该变量，值为 1。</p></li><li><p>UNIX<br>在类 UNIX 系统上，定义该变量，值为 1。</p></li><li><p>CMAKE_SYSTEM_NAME<br>当前构建所选定目标系统，但该变量需要使用 project 创建项目以后，才会被定义。</p><p>该变量常见的值有：Android、iOS、Linux、FreeBSD、MSYS、Windows、Darwin，完整的列表见：<a href="https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_NAME.html">CMAKE_SYSTEM_NAME</a>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Linux&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;current platform: Linux &quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Windows&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;current platform: Windows&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;FreeBSD&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;current platform: FreeBSD&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Darwin&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;current platform: macOS&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Android&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;current platform: Android&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;iOS&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;current platform: iOS&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> ()</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;other platform: $&#123;CMAKE_SYSTEM_NAME&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></li><li><p>MSVC<br>当编译器是 Microsoft Visual C++ 的某个版本或模拟 Visual C++ cl 命令行语法的其他编译器时设置为 true。</p></li><li><p>MSVC_VERSION<br>正在使用的 Microsoft Visual C&#x2F;C++ 版本（如果有）。如果正在使用模拟 Visual C++ 的编译器，则此变量将设置为 _MSC_VER 预处理器定义所给定的模拟工具集版本。</p></li></ul><h1 id="四、目标的属性"><a href="#四、目标的属性" class="headerlink" title="四、目标的属性"></a>四、目标的属性</h1><h2 id="4-1-属性调试"><a href="#4-1-属性调试" class="headerlink" title="4.1 属性调试"></a>4.1 属性调试</h2><p>在介绍如何设置目标的属性之前，我们先学习一下如何调试输出目标属性，方便在开发中检查属性设置是否出错。</p><p>使用 CMakePrintHelpers 模块提供 <a href="https://cmake.org/cmake/help/latest/module/CMakePrintHelpers.html">cmake_print_properties</a> 函数可以打印输出目标的属性，该函数的原型如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_print_properties(&lt;TARGETS       [&lt;target1&gt; ...] |</span><br><span class="line">                        SOURCES       [&lt;source1&gt; ...] |</span><br><span class="line">                        DIRECTORIES   [&lt;dir1&gt; ...]    |</span><br><span class="line">                        TESTS         [&lt;test1&gt; ...]   |</span><br><span class="line">                        CACHE_ENTRIES [&lt;entry1&gt; ...]  &gt;</span><br><span class="line">                       PROPERTIES [&lt;prop1&gt; ...]         )</span><br></pre></td></tr></table></figure><p>以打印输出目标的“包含目录”属性为例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(hello_cmake main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(hello_cmake PRIVATE <span class="string">&quot;include&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(CMakePrintHelpers)</span><br><span class="line">cmake_print_properties(TARGETS hello_cmake PROPERTIES <span class="keyword">INCLUDE_DIRECTORIES</span>) </span><br></pre></td></tr></table></figure><p>输出： </p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Properties for TARGET hello_cmake:</span><br><span class="line">  hello_cmake.INCLUDE_DIRECTORIES = &quot;D:/cmake-sample/hello_cmake/include&quot;</span><br></pre></td></tr></table></figure><h2 id="4-2-包含目录"><a href="#4-2-包含目录" class="headerlink" title="4.2 包含目录"></a>4.2 包含目录</h2><p>使用 <a href="https://cmake.org/cmake/help/latest/command/target_include_directories.html">target_include_directories</a> 指定目标包含一个或多个目录。指定的目录路径可以是绝对路径也可以是相对路径，如果是相对路径，则该路径是相对于当前脚本文件的。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(&lt;<span class="keyword">target</span>&gt; [SYSTEM] [AFTER|BEFORE]</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br></pre></td></tr></table></figure><p>这就相当于在 Visual Studio 中设置“附加包含目录”。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/6zoF01MV26-TinyTu.png"></p><p>可以针对一个目标重复调用 target_include_directories，会按照调用顺序依次附加包含目录，也可以使用 BEFORE 选项，将本次设置的包含目录插入到最前面。</p><p>我们需要特别花精力理解 INTERFACE、PUBLIC、PRIVATE 三者的区别，这三者的区别，我们先按下不表，稍后介绍。</p><p>在使用 PUBLIC、PRIVATE 设置包含目录时，会自动设置 <code>INCLUDE_DIRECTORIES</code> 属性；在使用 INTERFACE 设置包含目录时，会自动设置 <code>INTERFACE_INCLUDE_DIRECTORIES</code> 属性。</p><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(hello_cmake </span><br><span class="line">  PUBLIC <span class="string">&quot;include&quot;</span></span><br><span class="line">  PRIVATE <span class="string">&quot;./extern/jsoncpp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(hello_cmake BEFORE</span><br><span class="line">  PUBLIC <span class="string">&quot;include&quot;</span></span><br><span class="line">  PRIVATE <span class="string">&quot;./extern/rpclib&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="4-3-预编译宏"><a href="#4-3-预编译宏" class="headerlink" title="4.3 预编译宏"></a>4.3 预编译宏</h2><p>使用 <a href="https://cmake.org/cmake/help/latest/command/target_compile_definitions.html">target_compile_definitions</a> 设置目标的预编译宏。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(&lt;<span class="keyword">target</span>&gt;</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br></pre></td></tr></table></figure><p>可以针对一个目标重复调用 target_compile_definitions，附加多个预编译宏。</p><p>使用 PUBLIC、PRIVATE 设置包含目录时，会自动设置 <code>COMPILE_DEFINITIONS</code> 属性；使用 INTERFACE 设置包含目录时，会自动设置 <code>INTERFACE_COMPILE_DEFINITIONS</code> 属性。</p><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义2个预编译宏</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(hello_cmake</span><br><span class="line">  PUBLIC USING_BOOST USING_THRIFT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再定义一个预编译宏</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(hello_cmake</span><br><span class="line">  INTERFACE USING_ZLIB)</span><br></pre></td></tr></table></figure><h2 id="4-4-依赖库"><a href="#4-4-依赖库" class="headerlink" title="4.4 依赖库"></a>4.4 依赖库</h2><p>使用 <a href="https://cmake.org/cmake/help/latest/command/target_link_libraries.html">target_link_libraries</a> 指令设置目标的依赖库，该指令有很多原型，但常用的原型有：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(&lt;<span class="keyword">target</span>&gt;</span><br><span class="line">                     [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]</span><br><span class="line">                     [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br></pre></td></tr></table></figure><p>item 可以是如下几种类型：</p><ul><li>lib 文件的绝对路径或相对路径，CMake 不会校验文件是否存在</li><li>其他的 CMake 目标。</li><li>表达式生成器（见“生成器表达式”章节）。</li><li>以 <code>-</code> 开头的链接标志，但从 CMake 3.13 版本开始，可以直接使用 <code>target_link_options()</code> 替代。</li></ul><p>可以针对一个目标重复调用 target_link_libraries，附加多个依赖库。</p><p><code>&lt;PRIVATE|PUBLIC|INTERFACE&gt;</code> 可以省略，如果省略，则默认为 PUBLIC。</p><p>使用 PUBLIC、PRIVATE 设置依赖库时，会自动设置 <code>LINK_LIBRARIES</code> 属性；使用 INTERFACE 设置依赖库时，会自动设置 <code>INTERFACE_LINK_LIBRARIES</code> 属性。</p><h2 id="4-5-INTERFACE、PUBLIC-和-PRIVATE"><a href="#4-5-INTERFACE、PUBLIC-和-PRIVATE" class="headerlink" title="4.5 INTERFACE、PUBLIC 和 PRIVATE"></a>4.5 INTERFACE、PUBLIC 和 PRIVATE</h2><p>INTERFACE、PUBLIC 和 PRIVATE 用于指定属性的可见性传递方案。</p><table><thead><tr><th>目标类型</th><th>可见性传递</th><th>自身是否应用该属性</th><th>使用者是否应用该属性</th></tr></thead><tbody><tr><td>可执行文件</td><td>INTERFACE</td><td>否</td><td>否（可执行文件不存在使用者）</td></tr><tr><td>可执行文件</td><td>PUBLIC</td><td>是</td><td>否（可执行文件不存在使用者）</td></tr><tr><td>可执行文件</td><td>PRIVATE</td><td>是</td><td>否（可执行文件不存在使用者）</td></tr><tr><td>库（动态或静态）</td><td>INTERFACE</td><td>否</td><td>是</td></tr><tr><td>库（动态或静态）</td><td>PUBLIC</td><td>是</td><td>是</td></tr><tr><td>库（动态或静态）</td><td>PRIVATE</td><td>是</td><td>否</td></tr></tbody></table><h2 id="4-6-编译和链接选项"><a href="#4-6-编译和链接选项" class="headerlink" title="4.6 编译和链接选项"></a>4.6 编译和链接选项</h2><p>通过 <a href="https://cmake.org/cmake/help/latest/command/target_compile_options.html">target_compile_options</a> 指令设置编译选项。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_options</span>(&lt;<span class="keyword">target</span>&gt; [BEFORE]</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br></pre></td></tr></table></figure><p>通过 <a href="https://cmake.org/cmake/help/latest/command/target_link_options.html">target_link_options</a> 指令设置链接选项。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_options</span>(&lt;<span class="keyword">target</span>&gt; [BEFORE]</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br></pre></td></tr></table></figure><p>这两个指令的用法与前面介绍的 target_include_directories 类似。</p><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译选项</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(my_lib PRIVATE /utf8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接选项</span></span><br><span class="line"><span class="keyword">target_link_options</span>(app PRIVATE /NOLOGO)</span><br></pre></td></tr></table></figure><h2 id="4-7-其他属性"><a href="#4-7-其他属性" class="headerlink" title="4.7 其他属性"></a>4.7 其他属性</h2><p>CMake 为目标还提供了其他属性，详见 <a href="https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html#target-properties">target-properties</a> ，总计约有 400 多个，涵盖了开发中会用到的绝大多数属性，例如其中以 VS_ 开头的属性是专门为 Visual Studio 所准备的。</p><p>针对这些属性，需要使用 <a href="https://cmake.org/cmake/help/latest/command/set_target_properties.html">set_target_properties</a> 指令进行设置。</p><p>例如，使用 OUTPUT_NAME 和 DEBUG_OUTPUT_NAME 设置目标的输出文件名。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(zoe PROPERTIES </span><br><span class="line">  OUTPUT_NAME Zoe</span><br><span class="line">  DEBUG_OUTPUT_NAME Zoe-d)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://cmake.org/&quot;&gt;CMake&lt;/a&gt; 是一个开源、跨平台的构建系统生成器（Build-system Generator）。&lt;/p&gt;
&lt;p&gt;CMake 是构建系统生成器，而不是构建系统，CMake 支持生成不同构建系统所支持的工程文件，如 Visual Studio，XCode，Makefile 等。&lt;/p&gt;
&lt;p&gt;本教程作为 CMake 的简明教程，不会事无巨细的讲述 CMake 的每一个语法，而是以实用为目的，介绍 CMake 的基础语法和常用指令。&lt;/p&gt;
&lt;p&gt;虽然只是简明教程，但通过本教程，你仍然可以掌握 CMake 的脉络，熟练应用 CMake 于项目中。&lt;/p&gt;</summary>
    
    
    
    <category term="CMake" scheme="https://jiangxueqiao.com/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://jiangxueqiao.com/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>开源库jerryscript使用备忘</title>
    <link href="https://jiangxueqiao.com/post/3353203242.html"/>
    <id>https://jiangxueqiao.com/post/3353203242.html</id>
    <published>2024-09-09T04:48:55.000Z</published>
    <updated>2024-11-08T05:56:06.385Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-static.jiangxueqiao.com/blog/img/jerryscript-LOGO.png"></p><p>前段时间研究了 JerryScript 库，也顺手给 JerryScript 提交了几个 PR 被采纳了，有幸成为顶级项目的 Contributor（就是玩儿 ^_^）。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/3udYdv0Ten.png"></p><p><a href="https://github.com/jerryscript-project/jerryscript">JerryScript</a> 是一个轻量级的 JavaScript 引擎，资源占用极少，它可以运行在资源受限制的设备上，如：</p><ul><li>只有几 KB RAM 能运行引擎的设备（&lt;64 KB RAM）</li><li>只能为代码引擎提供有限 ROM 空间的设备（&lt;200 KB ROM）</li></ul><p>JerryScript 使用 C 语言开发，跨平台。</p><span id="more"></span><h1 id="为什么没有选择-QuickJS？"><a href="#为什么没有选择-QuickJS？" class="headerlink" title="为什么没有选择 QuickJS？"></a>为什么没有选择 QuickJS？</h1><p>说起轻量级的 JavaScript 引擎，很多人都会想到 QuickJS。的确，我一开始也选择了 QuickJS，但一番研究之后，发现 QuickJS 在 Windows 环境下编译实在是不太友好，不仅需要安装 Mingw64，而且修改编译选项也不方便。可能是我能力的问题吧，我还未找到将 QuickJS 编译成 MT 运行库的静态库的方法。</p><p>一个库在编译方面做得都不够友好，何况 Windows 也不是冷门的系统，那就没必要委屈自己了，毕竟还有其他的选择。</p><p>反观 JerryScript，使用 CMake 进行构建，不需要进行任何修改，一路畅通。</p><h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><p>JerryScript 的接口比较简洁， 而且官方已经提供了丰富的示例，示例地址如下：</p><p><a href="https://jerryscript.net/api-example/">https://jerryscript.net/api-example/</a></p><p>下面是一个简单的示例，演示了如何暴露 C++ 的函数给 JS 进行调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;jerryscript.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 函数，用于暴露给 JS</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">jerry_value_t</span> <span class="title">print_handler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">jerry_call_info_t</span>* call_info_p,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">jerry_value_t</span> arguments[],</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">jerry_length_t</span> argument_count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有参数，只打印一个字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Print handler was called\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 undefined 给JS引擎</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">jerry_undefined</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">jerry_char_t</span> script[] = <span class="string">&quot;print ();&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">jerry_length_t</span> script_size = <span class="built_in">sizeof</span>(script) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化引擎</span></span><br><span class="line">    <span class="built_in">jerry_init</span>(JERRY_INIT_EMPTY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 print 方法到 JavaScript 的全局对象上</span></span><br><span class="line">    <span class="comment">// 在JS 中调用 print 方法时，会调用到 C++ print_handler 方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">jerry_value_t</span> global_object = <span class="built_in">jerry_current_realm</span>();</span><br><span class="line">        <span class="type">jerry_value_t</span> property_name_print = <span class="built_in">jerry_string_sz</span>(<span class="string">&quot;print&quot;</span>);</span><br><span class="line">        <span class="type">jerry_value_t</span> property_value_func = <span class="built_in">jerry_function_external</span>(print_handler);</span><br><span class="line">        <span class="type">jerry_value_t</span> set_result = <span class="built_in">jerry_object_set</span>(global_object, property_name_print, property_value_func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否有错误发生</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">jerry_value_is_exception</span>(set_result)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Failed to add the &#x27;print&#x27; property\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">jerry_value_free</span>(set_result);</span><br><span class="line">        <span class="built_in">jerry_value_free</span>(property_value_func);</span><br><span class="line">        <span class="built_in">jerry_value_free</span>(property_name_print);</span><br><span class="line">        <span class="built_in">jerry_value_free</span>(global_object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">jerry_value_t</span> parsed_code = <span class="built_in">jerry_parse</span>(script, script_size, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">jerry_value_is_exception</span>(parsed_code))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 执行 JS 代码</span></span><br><span class="line">        <span class="type">jerry_value_t</span> ret_value = <span class="built_in">jerry_run</span>(parsed_code);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放返回值</span></span><br><span class="line">        <span class="built_in">jerry_value_free</span>(ret_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">jerry_value_free</span>(parsed_code);</span><br><span class="line">    <span class="built_in">jerry_cleanup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://blog-static.jiangxueqiao.com/blog/img/jerryscript-LOGO.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;前段时间研究了 JerryScript 库，也顺手给 JerryScript 提交了几个 PR 被采纳了，有幸成为顶级项目的 Contributor（就是玩儿 ^_^）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-static.jiangxueqiao.com/blog/img/3udYdv0Ten.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jerryscript-project/jerryscript&quot;&gt;JerryScript&lt;/a&gt; 是一个轻量级的 JavaScript 引擎，资源占用极少，它可以运行在资源受限制的设备上，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有几 KB RAM 能运行引擎的设备（&amp;lt;64 KB RAM）&lt;/li&gt;
&lt;li&gt;只能为代码引擎提供有限 ROM 空间的设备（&amp;lt;200 KB ROM）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JerryScript 使用 C 语言开发，跨平台。&lt;/p&gt;</summary>
    
    
    
    <category term="开源库" scheme="https://jiangxueqiao.com/categories/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
    <category term="开源库" scheme="https://jiangxueqiao.com/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    <category term="jeffyscript" scheme="https://jiangxueqiao.com/tags/jeffyscript/"/>
    
  </entry>
  
  <entry>
    <title>禁用F12作为调试热键</title>
    <link href="https://jiangxueqiao.com/post/4077884774.html"/>
    <id>https://jiangxueqiao.com/post/4077884774.html</id>
    <published>2024-08-26T05:08:03.000Z</published>
    <updated>2024-08-26T05:00:44.953Z</updated>
    
    <content type="html"><![CDATA[<p>在Windows系统中，F12永远为调试器所预留，不能被用来注册为快捷键，如我们通常使用F12打开浏览器的调试工具。即便当前未调试应用程序，如果内核模式调试器或实时调试器有驻留，F12也会被预留。</p><p>详见：<br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms646309.aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms646309.aspx</a></p><p>可以通过修改注册表来指定其他的按键作为调试器预留快捷键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug] UserDebuggerHotKey=dword:00000000</span><br></pre></td></tr></table></figure><p>比如<code>0x13</code> (Pause键)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Windows系统中，F12永远为调试器所预留，不能被用来注册为快捷键，如我们通常使用F12打开浏览器的调试工具。即便当前未调试应用程序，如果内核模式调试器或实时调试器有驻留，F12也会被预留。&lt;/p&gt;
&lt;p&gt;详见：&lt;br&gt;&lt;a href=&quot;https://msdn.mi</summary>
      
    
    
    
    <category term="编程基础" scheme="https://jiangxueqiao.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Visual Studio" scheme="https://jiangxueqiao.com/tags/Visual-Studio/"/>
    
  </entry>
  
  <entry>
    <title>折腾开发环境的一天</title>
    <link href="https://jiangxueqiao.com/post/2133505170.html"/>
    <id>https://jiangxueqiao.com/post/2133505170.html</id>
    <published>2024-08-12T01:52:55.000Z</published>
    <updated>2025-01-09T07:08:37.822Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="无法校验文章哈希">  <script id="hbeData" type="hbeData" data-hmacdigest="1775f08d5aecb6bae980729bf8c3e01558299d4fdd4f246cc5510d5d692cf606">49420f43dcd4ffad5e1774efbcfcadee2bd7039b3241a2ee4fd438f9dcc74bffcb03be0a8e762c996d40e1cac9294e017a4b8e4c93e0474a33c860be2af036d6b41dfb03e04c3b63d0babc52787f6005bb27d44ce9321b20d2e4681608cedc232245320ce1cbfc16328fe36f3b98f22b4208e15d1b870be37373741bf4ec943ab781fa8f4adf3bb226440aa371c14ef2e9fd438e760d72281f3ce1b789ccae0d20a58c8967d6ce10813d5302534aaaa25b4052d4ea35cc3c302c7c203e1d75babaa48ee50227d02722b48076520c8c9e7c237a1f90e05ebd4f9ee16f4996a523a98ff0d7cdc2232dcc269599dd939258b78e114e59c634bec8e1ee687aed2631de401aefaeb931935be74c660be9ff57d37f62e6f0068fc6fe947ad344a442396321eebcdcc97939bb9b8cd88950c1292e8c4370a20f839d23161ed28f3964c49eb965a3260dd9157f117308d75780716151a2ef1af10b299065ff65a705eb541417eb92f9f51895c77b755cebb37e20ef3d74527752e84465ec3bbad4072ed6f24c685c30f49b831736aeb56b0bf0e809cbcca825eb1a2b089c356b156fdcb8768c60ea4d43b98a3ca21026fef2ab8ec25037af77e851e08747395387a2c2f5a202398ed5e61bce68bc63ec9fa62dddfd94393f4feca143f7830346fbbd7bed655a5d6633bc52fa89713efde23d0f491df76b5b674ba0d97cae76b253fd6dc4ac9872406ef294f2a1e8db48e76c7b51f6db23aaf564c5e1891577f3361c530ddf1a14f32d5d162cfb92393235b6d034f84c8e9a8c83a39345f6caeec3c611ee7cb44fd3a36969dc4d0fea09c72adea8c87103f2394c7d78b8b2ca8f03f306ba210db4b9971b8cdb45ccd2cb6cc81feb531f1f1fe144d7edf35802593fd01928bc23bd4f315cb94fb1c348eeda5b0cd3122917b05ee035e916dc31163697b02a490be92a8e39d4353a909c51ab5796629c0b72bb3941c6fe8538051c3ad0b188c5b7b6a0ee9494bbf7575f1fdd4ac3ebed599181351e119b90b0f39f9b2cf86e3e19bad469b87b99e71ca4be204901dff0e3d7c46900004b66344c2ac071bc305f3291ca2face27f90a1e6664c5dbd02f5ceb42975841dabc19eafb285b9c04ce9a6a32b850d1028ca698c3c11d4f12038f558beeddb7ea9b2518f74945801765d1e7045522fc36cb8707d90b3a087c29192bb423533d83dc1d8854ca985e28556c91fb87e595fb3eb7bd5bb75633660b0126fb4c27da3874e776eb161e92b980afa6cc0d16f7a7007cd0f77ed9ed4cc4c0f0ab60f47dc7ddced9afebd7938a92b111c4e08f1d6e1da2ad3710b26d67e712e676c73f325ff3bbc0955e532b15e1ef502ec1072284169b497024e53c70d8dd6cbb900a791d83e9a09864be7ff8a2ec03a41a33e4648570d511169d71818a1645f344332511b9f657d780cd30c4f41e74d6afd27b53c9bb6bbd2c10d8d4b11073b63b33137216f0650e28b7c110a913fab239057fcd1f7d26bc14af2d4f9e236c76785e0144e8b1bdf4c3c7fa493f20bb757650a0596729d34cb54a4d901b917d7062ddd265e222e063475e16bea5b47adcab7b0244a35919fe42b3b464096cc036f0567653e6052d4de5292f9f449fac35a906f0336e8011c9c8f01e900ac75366162b8f944fbce53a38366dc904450c7ff3609b5e28784bbad70fe626e011e948da063e944259070798e37b972be15794e9e9ebd684ac04c4625d28807a7790e5c6f0dc64015de2d91d68c77ddb10761bbadc0a8b3f20f9b0d71a55a8f1a364186fcea3396bcf6a0b8d45877d6bfcac863b89e2294db34adb6befbdfe8236b5f085b4bb7b5585696a7ed08726b1a1cd9bce641752628c1e95d21b85926c1d4cd0cff3485c25b76c56e39559d6cd2fd44eefc677e2848a142793b4a1f26845d30b44131505ad3c3fe8d2de878058c6d5e8200076fb63096bb890bf6a37ee9ceb406d8464ebb47f7ca7f064b723fde1c548207ec1366ea958b169de8f8bedebea2b8ca9f87d9dfa75d469edd637a116413d60139145c13195915905de90bb0bf3cd899844cb860262a35b2afcd3f1b653f9869a6db92e846e364f93867b89406dca0e340b70a4d5b7d84f3913d74f5e47639601a9ee56d9ebfd6041e6680208499e8dfbce57aa895de53b67aada102123835d967135f8b51120609d0d545aaece160a04bc7d27fa15266bbe07d42ad94f5224ad3c81a7cb7537739cb109262ef45ac8752bf1e5f8e005aa3ca83b0beb627080c9928e860d8acaa973133369bc1292a55a496bc725912904e457753e8a7335b556a3a966fed6be0b7b29a3ac7336dde38e6f4a8526c28646b3aebfb5d6cb77746b836f09159eff475e12f055583d6ff402935cf8d0f843b9258d0647e854f1e818cf2a29d66009a4601a604bf711d28399f5d56103b190cdf8aa4bfdac2bbf182449a4ddfe6189a1a7612540ad8c87f4bcba74d4bd293006b64692ff4a7eebff5c705f8244f5eee069db4d6abea34a28e04d2df538b513f05c7bc718ff68d4fd4d206fe1fae981d50829d8589a9f412fe37103b9e44d9138b0a3a7a6ec2f42d47d906a8674098e37e08045003a65ad09efcd693b629d9569ff43f1144791f24fbcf31372c6a9bf2a84b32dbfb83cf1d459efdd0433c92f5948671fc2612ffbb52387f679857059531b9ec864752b1d94848a8aafddd5c1a7f82126d417022aa1438a8240106fff9efb16d958d430a2f1bcbe5e0e875644ea5ebd74bef17269c11e836aface1303c82fb88d7a69c5e9b0b5100438815911f005df326b73856786974bda20c646c8dcd4c3971e4953294fd660ed9012d5376885aa75c0fc94fb0b4df54da3afecbb2eb31aabbca928055208548045b772f9b6d9cac88b72a96884d0bab35f360c84e1ffe21def4cfba527fdd61c7a9219d3fc79b0cfeb1e2448c64f6959de565fc82badc2bb9fa06140f4d9d5b1cba5ecc00f6e8941c47e245493aa267ddd3ba6c7517b3622cd0d6e8f3c36c337ac80aede6df57e4631a9717028971a81df7927b8aa99d3711eee98c83ed6a02faef28be604ba9c83d17f1d5a120f34448a202002e540c42fb7b814d7c7e3b1e8be122eb12665d6bd008b8adf0eeff05e3059422ed452f80b2b97634f4a577e080205b751aee21788585c48952ce4fc57856442db0d4bf2ae5cd5e5bbc2f3089dc5563e6c1607b3d529072b1e42ed3e017201cbdbe89914c4ae8eff21d791cdcd01b3ce9de223376af77b197b7bd2d2230a490603f349b4fb2b23771d38750fbdcb4898882d4fb01b2212bf93dcb171458d9e5da67aa442ac81731929024bfa56221781d68530a517450bbfd751c67f426a62cad6f3ddf019cc9611b336a6b851c5a192d3bdd82730103a920edc36273fc5327d018ffe36411be808e70250ee3b73117422021286e688a317e375eced4e28780195add46650e5d1a70a4b56dc90f93c766afde8e2678c502ca224de309e8a987749244dbbc8c721dfb38abeacca7a5337224eb9fbf9308b162faef0c2e80dfbb41fcc437a9a5b61cc8ae03767ee37b64633c019c381de343bde47825db52a4fea877e9660a93b336a28cb0690900dc7ffd2805e24703dc738e1721b07ab5dd11bfe3fe1a605dbd5207eaa159f2c3adadf5844e2fd0782683277e925ac7d337d2dfdafff253d28f67f386d9c2121a9f8decd6f9307be173ac15167727c5adf388c6b9638f43eb5f7efb4eb2c3f5a86e3ce4d1226aa53468f7325983face5111fe1935637c5b2b9f7298ff14f79c5d094a16ff1eca8a7cc47f293e97d8857a92c14d4e33d229d91badc61aff571b515335b0c1fb994c8be8577cf75499852369422a9eccdc985c050e2172837f9bc6df63e91a2b749042bf4c067c7c5549e1cee7508fbb7de31ea6f5a22b6b2cbb2e97db35c06f13ff7bc4fd2f1089aece1fb367ae77b7ba2f458cf4f37101cbc51b6895043d888fc92c87713d1b04c30b414c12448a56200039694af77f1f4a9182aab4edc290aeace0684b004aa41a12c329301b408fb69d19049c32afdb6f8cee92f1851560d433986bd2a53340146c83c45990a57fefc3f21c6b044cde0cfa62d9af6ec5aec644db012c93572cd1a654e2b8021cccc75acbcc91cbea561e3280cdb886465cca3eed3efc7c2566b9c23a3d545cb56e17db9b61c7c0f03da024bf416054803bd5c4168220f7d31e266b50cd515c2d77cfa9cc694d35d5c7ff021786758c261521c1227db902e3ccae49eafeabed61beefb83b94d68ae59d53816dc07af7f79562c02839a84eb41dc6e318e9f6d74f588a39ae71bbf5b143142d5d7431f64ebffcfcbd7ae7fe79af0ea7676303ccf39edab0f4cf64072c87d674feba4bb1d2b9a59a0dc49cf17beb9a0fc289a15c1f6546b7800e05dd7acdbe7ed0b984a902fedd806d9195084d39a36ce79d191fd3137fe285f39ffc8754176e3b988a6fce8934320b5160bbf30690adc3e90e2c955efe06c2293dc0e7a89725a5089c56e8d821bcb040276a33128c790ec20df310508ef12fd819b62b18756b7033c6c51651bfe3ad1d895e58bf76fdc6604fd09bb6ed916160971f20e2fb630713360826ac6bc56781db10e944ca578dedbd3d030ca55da65d11bc05b5b135d8f27ed55f7d95a46a9d1898a111fa9bef9fb179655136cbde7f413f900e5f6bc04ba9b2f93e13f1bdd0233fd1c1bd5f302504bdab42f93e9dea344372f139bf96ba5c47c9cfe132212009f002c46dd8033be350410b5e39f5158fb65392e85547cdf07abf844bdba2d276ad8a2dc89ae13ebe2228e8a28ef2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">文章已被加密，请联系作者获取密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">文章已被加密</summary>
    
    
    
    <category term="编程基础" scheme="https://jiangxueqiao.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Visual Studio" scheme="https://jiangxueqiao.com/tags/Visual-Studio/"/>
    
    <category term="Qt" scheme="https://jiangxueqiao.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>C99柔性数组</title>
    <link href="https://jiangxueqiao.com/post/2984623496.html"/>
    <id>https://jiangxueqiao.com/post/2984623496.html</id>
    <published>2024-07-21T08:00:03.000Z</published>
    <updated>2024-07-26T16:12:53.296Z</updated>
    
    <content type="html"><![CDATA[<p>在讲述柔性数组（Flexible Array）之前，首先要介绍一下不完整类型 (Incomplete Type)。不完全类型是暂时没有完全定义好的类型，缺乏足够的信息（例如长度、类型）去描述一个完整的类型。在C&#x2F;C++中不完全类型有三种不同形式：void、未指定长度的数组以及具有非指定内容的结构和类。</p><span id="more"></span><p>比如通过使用不完整类型可以在头文件中隐藏结构体定义的具体细节，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ring_buffer.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ring_buffer_type</span> <span class="title">ringbuf_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ring_buffer_create</span><span class="params">(<span class="type">ringbuf_t</span> **rcb, <span class="type">size_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ring_buffer_write</span><span class="params">(<span class="type">ringbuf_t</span> * rcb, <span class="type">uint8_t</span> *pdata, <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ring_buffer.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ring_buffer_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span>* data;</span><br><span class="line">    <span class="type">size_t</span>   size;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在C++中经常使用的“向前声明”也是不完整类型的具体应用。</p><p>关于柔性数组所使用的不完整类型则是“未指定长度的数组”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> str[];</span><br></pre></td></tr></table></figure><p>C99 将柔性数组纳入了标准之中，根据 C99 规定，柔性数组需要满足如下条件：</p><ol><li>柔性数组只应用在结构体中。</li><li>结构体中不能只有柔性数组一个成员，而且柔性数组必须是结构体的最后一个成员。</li><li>由于柔性数组没有指定大小，因此不占用存储空间。</li></ol><p>如下面结构体中的 data 数组就是柔性数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Package</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">char</span>* data[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 data 数组的长度为0，因此不占用存储空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(Package) == <span class="keyword">sizeof</span>(<span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>包含柔性数组成员的结构体需要使用 <code>malloc()</code> 函数进行内存的动态分配，并且分配的内存通常大于结构体的大小，多余的空间自动分配给了柔性数组，这样就可以用柔性数组来存储额外的数据了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> data[<span class="number">20</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dataLen = <span class="built_in">strlen</span>(data);</span><br><span class="line"></span><br><span class="line">Package* pck = (Package*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Package) + dataLen);</span><br><span class="line"><span class="keyword">if</span> (pck) &#123;</span><br><span class="line">    pck-&gt;len = dataLen;</span><br><span class="line">    <span class="built_in">memcpy</span>(pck-&gt;data, data, dataLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pck);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在讲述柔性数组（Flexible Array）之前，首先要介绍一下不完整类型 (Incomplete Type)。不完全类型是暂时没有完全定义好的类型，缺乏足够的信息（例如长度、类型）去描述一个完整的类型。在C&amp;#x2F;C++中不完全类型有三种不同形式：void、未指定长度的数组以及具有非指定内容的结构和类。&lt;/p&gt;</summary>
    
    
    
    <category term="C++语言" scheme="https://jiangxueqiao.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C99" scheme="https://jiangxueqiao.com/tags/C99/"/>
    
    <category term="柔性数组" scheme="https://jiangxueqiao.com/tags/%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>了解数字证书</title>
    <link href="https://jiangxueqiao.com/post/3462229631.html"/>
    <id>https://jiangxueqiao.com/post/3462229631.html</id>
    <published>2024-07-17T07:35:10.000Z</published>
    <updated>2025-02-17T09:42:51.677Z</updated>
    
    <content type="html"><![CDATA[<p>打开任何一个数字证书售卖网站都可以看到它们通常将数字证书分为两个大类：SSL证书和数字签名证书。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/Rg3jGGhwtv-TinyTu.png"></p><p>SSL证书的主要作用是对网站进行身份验证和传输数据加密；</p><p>数字签名主要用于验证信息的真实性和完整性，根据使用场景的不同大致分为如下几类：</p><ul><li>对客户端程序（.exe、.dll、.sys等文件）签名的代码签名证书。</li><li>对PDF等文档签名的文档签名证书。</li><li>对电子邮件及其附件签名和加密的邮件安全证书。</li></ul><span id="more"></span><h2 id="颁发机构"><a href="#颁发机构" class="headerlink" title="颁发机构"></a>颁发机构</h2><p>有很多机构都可以颁发数字证书，比如 GlobalSign、DigiCert、Geotrust、Sectigo、WoTrus、Entrust 等，有的机构只能颁发SSL证书，有的机构可以颁发所有类型的证书。</p><p>机构有大小之分，所颁发的证书也有知名度和认可度之分，价格也有高低之分。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/SCDi6zxPU5.png"></p><h2 id="DV、OV、EV的区别"><a href="#DV、OV、EV的区别" class="headerlink" title="DV、OV、EV的区别"></a>DV、OV、EV的区别</h2><p>首先介绍一下它们的全称：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DV = Domain Validation 域名验证</span><br><span class="line"></span><br><span class="line">OV = Organization Validation 机构验证</span><br><span class="line"></span><br><span class="line">EV = Extended Validation 扩展验证</span><br></pre></td></tr></table></figure><p>要了解 DV、OV 和 EV 这三类证书之间的区别，首先要了解 DigiCert 等证书颁发机构（CA）是如何颁发证书的。</p><p>CA 作为受信任的第三方，它通过验证申请者的几个细节来确定是否可以颁发证书。申请三种类型的证书所需要验证的条件从 DV -&gt; OV -&gt; EV 依次增加，这也就导致了三种类型的证书的可信度也是依次增加的。</p><p>在 DV 级别，验证流程相当短，只要求购买者证明其对域名的所有权。验证方式是CA向（WHOIS数据库所列的）域名所有者发送电子邮件。如果您立即需要证书，这算是一种便捷的验证方法，但这种只进行一项检查的验证形式是互联网中最低标准的验证形式，其相应的信任度也应该是最低的。由于 DV 证书只验证域名的所有权，因此 DV 类型的证书只存在于 SSL 证书中。</p><p>OV 和 EV 证书的区别在于获取证书所需要的额外的验证条件和步骤。对于EV和OV证书，CA必须验证域名所有者以及与证书相关联的企业的相关详细信息，包括名称、类型、状态和实际地址。</p><p>而要获得EV，还需要几个额外步骤，包括验证企业的对外电话号码、开展业务的年限、注册号和管辖权，以及域名欺诈检查、联系人黑名单检查并致电以验证申请者的就业情况。</p><blockquote><p>我们购买证书通常是通过CA机构在国内的代理商来申请和购买的，因此具体需要验证哪些材料，可以咨询代理商（如亚洲诚信、锐成信息、数安时代等等，多如牛毛），通常没有那么复杂，都是钱的事情。</p></blockquote><h2 id="SmartScreen"><a href="#SmartScreen" class="headerlink" title="SmartScreen"></a>SmartScreen</h2><p>在介绍 OV 和 EV 类型的代码签名证书的区别之前，我们有必要先了解一下 Windows 上的 SmartScreen 特性。</p><p>SmartScreen 全称 Microsoft Defender SmartScreen，是 Windows、Internet Explorer 和 Microsoft Edge 提供的一个可防止网络钓鱼、恶意软件网站、应用程序以及潜在恶意文件下载的安全功能。</p><p>SmartScreen 通过联机服务检查有关下载的应用程序的数字签名信息，以确定下载程序的信誉。如果此应用程序没有建立信誉，SmartScreen 会认为它是恶意程序的风险较高，就会向用户显示诸如“未知发布者”的警告。</p><p>下面是几种可能出现的 SmartScreen 警告的样式：</p><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/c5d108ee84859c278ff0d6e23dd19bc4.jpeg" width="600px" /></div><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/6f6d4e0ed662228932d96f34036f20b9.jpeg" width="600px" /></div><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/2UyXU94y7h.png" width="500px" /></div><p>对于此类警告，微软的建议是“使用代码签名对程序进行数字签名”，“使用属于 Windows 根证书计划的证书颁发机构(CA)颁发的代码签名证书”，以验证发布者的真实身份，确保应用程序代码的完整性。</p><p>使用 OV 类型证书签名的程序可能不会立即消除 SmartScreen 警告，需要累计一定的下载量后才会消除，微软没有公布具体的消除规则。但由于 EV 类型签名证书的审核规则更加严格，因此使用 EV 类型证书签名的程序可以立即消除该警告。</p><h2 id="代码签名证书OV和EV的区别"><a href="#代码签名证书OV和EV的区别" class="headerlink" title="代码签名证书OV和EV的区别"></a>代码签名证书OV和EV的区别</h2><p>下面列出了OV和EV类型的代码签名证书的不同之处。</p><blockquote><p>OV类型的代码签名证书也称之为普通或标准型代码签名证书。</p></blockquote><table><thead><tr><th>区别</th><th>OV代码签名证书</th><th>EV代码签名证书</th></tr></thead><tbody><tr><td>审核内容</td><td>企业信息</td><td>企业信息及其他的信息。<br/>绝大多数公司都是可以申请的，只是需要签署更多的材料而已</td></tr><tr><td>颁发周期</td><td>时间不固定，1周左右</td><td>时间不固定，1~2周左右</td></tr><tr><td>可签名的软件类型</td><td>只支持签名应用软件，<br/>如.exe、.dll、.cab、.ocx、.msi、.xpi，<br/>不能签名驱动程序</td><td>支持签名应用软件和驱动程序</td></tr><tr><td>Windows硬件认证<br/>（WHQL）<br/>亦称徽标认证</td><td>不支持</td><td>支持</td></tr><tr><td>SmartScreen即时信誉</td><td>通过累计获得信誉，<br/>但微软未公布具体规则</td><td>立即获得</td></tr></tbody></table><h2 id="如何区分OV和EV代码签名"><a href="#如何区分OV和EV代码签名" class="headerlink" title="如何区分OV和EV代码签名"></a>如何区分OV和EV代码签名</h2><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/sSqxH2uXQu-TinyTu.png" width="600px" /></div><p>从上图可以看出，EV证书比OV证书多了很多字段。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;打开任何一个数字证书售卖网站都可以看到它们通常将数字证书分为两个大类：SSL证书和数字签名证书。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-static.jiangxueqiao.com/blog/img/Rg3jGGhwtv-TinyTu.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;SSL证书的主要作用是对网站进行身份验证和传输数据加密；&lt;/p&gt;
&lt;p&gt;数字签名主要用于验证信息的真实性和完整性，根据使用场景的不同大致分为如下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对客户端程序（.exe、.dll、.sys等文件）签名的代码签名证书。&lt;/li&gt;
&lt;li&gt;对PDF等文档签名的文档签名证书。&lt;/li&gt;
&lt;li&gt;对电子邮件及其附件签名和加密的邮件安全证书。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="项目管理" scheme="https://jiangxueqiao.com/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="数字证书" scheme="https://jiangxueqiao.com/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
    
    <category term="代码签名" scheme="https://jiangxueqiao.com/tags/%E4%BB%A3%E7%A0%81%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>玩转Qt 2D绘图之仪表盘实例</title>
    <link href="https://jiangxueqiao.com/post/29874871.html"/>
    <id>https://jiangxueqiao.com/post/29874871.html</id>
    <published>2024-06-26T05:55:02.000Z</published>
    <updated>2024-06-26T04:32:36.466Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的《玩转 Qt 2D 绘图》系列文章中，已经介绍了 2D 绘图中常用的知识，本文主要通过一个汽车仪表盘的实例来综合应用前面所介绍知识点，并且还介绍了一些 Qt 绘图的常用技巧。</p><p>相关文章：</p><ul><li><a href="/post/847642761.html" title="玩转Qt 2D绘图之坐标系">玩转Qt 2D绘图之坐标系</a></li><li><a href="/post/1336811290.html" title="玩转Qt 2D绘图之画家的工具">玩转Qt 2D绘图之画家的工具</a></li><li><a href="/post/1967189103.html" title="玩转Qt 2D绘图之画家">玩转Qt 2D绘图之画家</a></li></ul><span id="more"></span><p>实例效果图如下：</p><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/Sample_E8gfEIPtUV.gif" width="360px"></div><p>本实例主要涉及如下知识点：</p><ul><li>坐标系的缩小、旋转、位移</li><li>绘制线条、圆、饼状图、多边形、文本</li><li>画笔、画刷的应用</li><li>三角函数的应用</li></ul><p>废话不多说，下面开始分布讲解仪表盘的绘制步骤。为了便于后面的描述，我们先将控件上的各个元素进行标注：</p><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/XXcXz2Xl7D-TinyTu.png" width="480px"></div><h2 id="1-坐标系设置"><a href="#1-坐标系设置" class="headerlink" title="1. 坐标系设置"></a>1. 坐标系设置</h2><h3 id="1-1-圆的半径"><a href="#1-1-圆的半径" class="headerlink" title="1.1 圆的半径"></a>1.1 圆的半径</h3><p>仪表盘是一个圆，因此需要先确定圆的中心点和半径，中心点位于 QWidget 的中心，而 QWidget 可能并不是正方形，因此只能以最短边来确定圆的半径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> qreal width = <span class="keyword">this</span>-&gt;<span class="built_in">width</span>();</span><br><span class="line"><span class="type">const</span> qreal height = <span class="keyword">this</span>-&gt;<span class="built_in">height</span>();</span><br><span class="line"><span class="type">const</span> qreal side = <span class="built_in">qMin</span>(width, height); <span class="comment">// 最短边</span></span><br><span class="line"><span class="type">const</span> qreal radius = side / <span class="number">2.0</span>; <span class="comment">// 半径</span></span><br></pre></td></tr></table></figure><h3 id="1-2-坐标系缩放"><a href="#1-2-坐标系缩放" class="headerlink" title="1.2 坐标系缩放"></a>1.2 坐标系缩放</h3><p>假设当外圆的半径为 100 时，我们将内圆的半径设计为 85，中心圆的半径设计为 45，刻度数字字体设计为 10px，等等。 </p><p>由于仪表板控件是一个通用型的控件，因此在实际应用中，其长宽并不固定为100px，其可以为任意值，为了保持美观和协调性，外圆、内圆、中心圆、数字字体等元素的大小都需要根据控件的大小而动态的改变。我们可以通过百分比的方式来设置各个元素的大小，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qreal r1 = side / <span class="number">2.0</span>; <span class="comment">// 外圆半径</span></span><br><span class="line">qreal r2 = r1 * <span class="number">0.85</span>; <span class="comment">// 内圆半径为外圆的85%</span></span><br><span class="line">qreal r3 = r1 * <span class="number">0.45</span>; <span class="comment">// 中心圆的半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字体大小则根据 半径100 -&gt; 10px 这个基础来缩小和放大</span></span><br><span class="line">qreal fz = <span class="number">10</span> * (r1 / <span class="number">100.0</span>);</span><br></pre></td></tr></table></figure><p>看了上面的代码，相信大家已经有了明显的感受：需要手动计算百分比，太繁琐了，而且字体大小的缩放也不够线性。</p><p>的确如此，针对这些问题，我们可以通过下面的方案来解决。</p><p>在实际项目开发中，控件的样式通常不是程序员自己凭空想象的，而是经过设计师或美工设计出来的，设计师通过蓝湖、figma 等工具将效果图交付给开发人员，这些工具都带有尺寸标注功能，开发人员可以方便的获取设计尺寸。我们在开发时可以直接以设计尺寸来进行开发，不再计算百分比，改为动态的对坐标系进行缩放来适应实际尺寸。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> qreal width = <span class="keyword">this</span>-&gt;<span class="built_in">width</span>();</span><br><span class="line"><span class="type">const</span> qreal height = <span class="keyword">this</span>-&gt;<span class="built_in">height</span>();</span><br><span class="line"><span class="type">const</span> qreal side = <span class="built_in">qMin</span>(width, height);</span><br><span class="line">painter.<span class="built_in">scale</span>(side / <span class="number">200.0</span>, side / <span class="number">200.0</span>);  <span class="comment">// 设计师所设计的的长宽为200*200</span></span><br></pre></td></tr></table></figure><h3 id="1-3-坐标系原点"><a href="#1-3-坐标系原点" class="headerlink" title="1.3 坐标系原点"></a>1.3 坐标系原点</h3><p>为了方便绘制，我们通常还将坐标系的原点移动到圆的中心点位置，当然这不是必须的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">translate</span>(width / <span class="number">2</span>, height / <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="2-绘制外圆"><a href="#2-绘制外圆" class="headerlink" title="2. 绘制外圆"></a>2. 绘制外圆</h2><p>控件是包含各种不同的元素，如外圆、内圆、刻度、指针等，一层一层的叠加在 QWidget 上面，从而组成了一个完整的控件。在绘制时，我们通常从最底层元素开始绘制，然后再一层一层地绘制上层元素。</p><p>本实例中，我们先绘制外圆，然后绘制内圆，一层一层的叠加（本文的章节顺序即为元素的绘制顺序）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制外圆</span></span><br><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">80</span>, <span class="number">80</span>, <span class="number">80</span>));</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPointF</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="number">100.0</span>, <span class="number">100.0</span>);</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/BOKo4yqRIC-TinyTu.png" width="300px"></div><h2 id="3-绘制内圆"><a href="#3-绘制内圆" class="headerlink" title="3. 绘制内圆"></a>3. 绘制内圆</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">60</span>, <span class="number">60</span>, <span class="number">60</span>));</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPointF</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="number">85.0</span>, <span class="number">85.0</span>);</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/WOJRb9auYy-TinyTu.png" width="300px"></div><h2 id="4-绘制三色饼状图"><a href="#4-绘制三色饼状图" class="headerlink" title="4. 绘制三色饼状图"></a>4. 绘制三色饼状图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startAngle_ 和 endAngle_ 起始和结束角度</span></span><br><span class="line"><span class="comment">// qreal startAngle_ = -30;</span></span><br><span class="line"><span class="comment">// qreal endAngle_ = 210;</span></span><br><span class="line"></span><br><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    qreal end = endAngle_;</span><br><span class="line">    qreal spanAngles = (endAngle_ - startAngle_) * <span class="number">0.7</span>;  <span class="comment">// 0 ~ 70%</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">24</span>, <span class="number">189</span>, <span class="number">155</span>));</span><br><span class="line">    painter.<span class="built_in">drawPie</span>(<span class="number">-55</span>, <span class="number">-55</span>, <span class="number">110</span>, <span class="number">110</span>, (end - spanAngles) * <span class="number">16</span>, spanAngles * <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    end -= spanAngles;</span><br><span class="line">    spanAngles = (endAngle_ - startAngle_) * <span class="number">0.15</span>;  <span class="comment">// 70% ~ 85%</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">218</span>, <span class="number">218</span>, <span class="number">0</span>));</span><br><span class="line">    painter.<span class="built_in">drawPie</span>(<span class="number">-55</span>, <span class="number">-55</span>, <span class="number">110</span>, <span class="number">110</span>, (end - spanAngles) * <span class="number">16</span>, spanAngles * <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    end -= spanAngles;</span><br><span class="line">    spanAngles = (endAngle_ - startAngle_) * <span class="number">0.15</span>;  <span class="comment">// 85% ~ 100%</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">107</span>, <span class="number">107</span>));</span><br><span class="line">    painter.<span class="built_in">drawPie</span>(<span class="number">-55</span>, <span class="number">-55</span>, <span class="number">110</span>, <span class="number">110</span>, (end - spanAngles) * <span class="number">16</span>, spanAngles * <span class="number">16</span>);</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/fMx4SF5KjH-TinyTu.png" width="300px"></div><h2 id="5-绘制中心圆"><a href="#5-绘制中心圆" class="headerlink" title="5. 绘制中心圆"></a>5. 绘制中心圆</h2><p>绘制中心圆，用于覆盖饼圆的中心。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPointF</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="number">45</span>, <span class="number">45</span>);</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/sl94DkqmCV-TinyTu.png" width="300px"></div><h2 id="6-绘制刻度线"><a href="#6-绘制刻度线" class="headerlink" title="6. 绘制刻度线"></a>6. 绘制刻度线</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// majorScaleNum_ 指定有多少个大刻度线</span></span><br><span class="line"><span class="comment">// scaleNumPerMajor_ 指定每2个大刻度线间隔内有多少个小刻度线</span></span><br><span class="line"><span class="comment">// int majorScaleNum_ = 10;</span></span><br><span class="line"><span class="comment">// int scaleNumPerMajor_ = 10;</span></span><br><span class="line"></span><br><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    QPen pen;</span><br><span class="line">    pen.<span class="built_in">setColor</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">    pen.<span class="built_in">setCapStyle</span>(Qt::RoundCap);</span><br><span class="line">    pen.<span class="built_in">setWidthF</span>(<span class="number">1.0</span>);</span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalScaleNum = majorScaleNum_ * scaleNumPerMajor_;</span><br><span class="line">    qreal angleStep = (endAngle_ - startAngle_) / (qreal)totalScaleNum;</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">rotate</span>(<span class="number">360</span> - endAngle_);  <span class="comment">// rotate 按顺时针方向旋转</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= totalScaleNum; i++) {</span><br><span class="line">        <span class="keyword">if</span> (i % scaleNumPerMajor_ == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 绘制大刻度</span></span><br><span class="line">            painter.<span class="built_in">drawLine</span>(<span class="built_in">QPointF</span>(<span class="number">57.0</span>, <span class="number">0.0</span>), <span class="built_in">QPointF</span>(<span class="number">72.0</span>, <span class="number">0.0</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 绘制小刻度</span></span><br><span class="line">            painter.<span class="built_in">drawLine</span>(<span class="built_in">QPointF</span>(<span class="number">57.0</span>, <span class="number">0.0</span>), <span class="built_in">QPointF</span>(<span class="number">64.0</span>, <span class="number">0.0</span>));</span><br><span class="line">        }</span><br><span class="line">        painter.<span class="built_in">rotate</span>(angleStep);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/gTjzwR61S4-TinyTu.png" width="300px"></div><h2 id="7-绘制刻度数字"><a href="#7-绘制刻度数字" class="headerlink" title="7. 绘制刻度数字"></a>7. 绘制刻度数字</h2><p>因为数字始终是从左到右的方向绘制的，而绘制刻度时会改变坐标轴的方向，因此数字不能与刻度一起绘制。</p><p>使用三角函数计算文字矩形区域下横线中间点位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    QPen pen;</span><br><span class="line">    pen.<span class="built_in">setColor</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line"></span><br><span class="line">    QFont font;</span><br><span class="line">    font.<span class="built_in">setPixelSize</span>(<span class="number">10</span>);</span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line"></span><br><span class="line">    <span class="function">QFontMetrics <span class="title">fm</span><span class="params">(font)</span></span>;</span><br><span class="line">    <span class="type">int</span> txtHeight = fm.<span class="built_in">height</span>();</span><br><span class="line"></span><br><span class="line">    qreal angleStep = (endAngle_ - startAngle_) / majorScaleNum_;</span><br><span class="line">    qreal stepNum = (maxValue_ - minValue_) / majorScaleNum_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= majorScaleNum_; i++) {</span><br><span class="line">        qreal angle = startAngle_ + i * angleStep;</span><br><span class="line">        qreal x = <span class="built_in">qCos</span>(<span class="built_in">qDegreesToRadians</span>(angle)) * <span class="number">74.0</span>;</span><br><span class="line">        qreal y = -<span class="built_in">qSin</span>(<span class="built_in">qDegreesToRadians</span>(angle)) * <span class="number">74.0</span>;  <span class="comment">// 纵坐标与数学坐标系相反</span></span><br><span class="line"></span><br><span class="line">        QString txt = QString::<span class="built_in">number</span>((<span class="type">int</span>)((majorScaleNum_ - i) * stepNum));  <span class="comment">// 大数在右边，小数在左边，先绘制大数</span></span><br><span class="line">        <span class="type">int</span> txtWidth = fm.<span class="built_in">horizontalAdvance</span>(txt);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IS_NEARLY_EQUAL</span>(x, <span class="number">0.0</span>)) {</span><br><span class="line">            painter.<span class="built_in">drawText</span>(<span class="built_in">QRectF</span>(x - txtWidth / <span class="number">2</span>, y - txtHeight, txtWidth, txtHeight), Qt::AlignCenter, txt);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IS_NEARLY_EQUAL</span>(y, <span class="number">0.0</span>)) {</span><br><span class="line">            painter.<span class="built_in">drawText</span>(<span class="built_in">QRectF</span>(x, y - txtHeight / <span class="number">2</span>, txtWidth, txtHeight), Qt::AlignVCenter | Qt::AlignLeft, txt);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">0.0</span>)</span><br><span class="line">                painter.<span class="built_in">drawText</span>(<span class="built_in">QRectF</span>(x, y - txtHeight / <span class="number">2</span>, txtWidth, txtHeight), Qt::AlignVCenter | Qt::AlignLeft, txt);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                painter.<span class="built_in">drawText</span>(<span class="built_in">QRectF</span>(x - txtWidth, y - txtHeight / <span class="number">2</span>, txtWidth, txtHeight), Qt::AlignVCenter | Qt::AlignRight, txt);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/jAexo1JyUu-TinyTu.png" width="300px"></div><h2 id="8-绘制当前指针"><a href="#8-绘制当前指针" class="headerlink" title="8. 绘制当前指针"></a>8. 绘制当前指针</h2><p>指针样式实际为三个点组成的三角形。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maxValue_ 和 minValue_ 为设置的刻度最大值和最小值</span></span><br><span class="line"><span class="comment">// qreal minValue_ = 0.0;</span></span><br><span class="line"><span class="comment">// qreal maxValue_ = 100.0;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> qreal anglePerValue = (endAngle_ - startAngle_) / (maxValue_ - minValue_);</span><br><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">107</span>, <span class="number">107</span>, <span class="number">204</span>));</span><br><span class="line"></span><br><span class="line">    QPolygon pts;</span><br><span class="line">    pts.<span class="built_in">setPoints</span>(<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">-5</span>, <span class="number">64</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    qreal rotateAngle = <span class="number">360.0</span> - endAngle_;</span><br><span class="line">    rotateAngle += anglePerValue * (curValue_ - minValue_);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">rotate</span>(rotateAngle);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">drawPolygon</span>(pts);</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/7ATgnp1HUv-TinyTu.png" width="300px"></div><h2 id="9-绘制中心小圆"><a href="#9-绘制中心小圆" class="headerlink" title="9. 绘制中心小圆"></a>9. 绘制中心小圆</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">    <span class="comment">// 红色圆</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">107</span>, <span class="number">107</span>));</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPointF</span>(<span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">20.0</span>, <span class="number">20.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 白色圆</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPointF</span>(<span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">16.0</span>, <span class="number">16.0</span>);</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/1aLsEMb30H-TinyTu.png" width="300px"></div><h2 id="10-绘制当前值"><a href="#10-绘制当前值" class="headerlink" title="10. 绘制当前值"></a>10. 绘制当前值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    QFont font = painter.<span class="built_in">font</span>();</span><br><span class="line">    font.<span class="built_in">setPixelSize</span>(<span class="number">14</span>);</span><br><span class="line">    font.<span class="built_in">setBold</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-16</span>, <span class="number">-16</span>, <span class="number">32</span>, <span class="number">32</span>, Qt::AlignCenter, QString::<span class="built_in">number</span>(curValue_));</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/c4Hmp4lcrz-TinyTu.png" width="300px"></div><p>至此，大功告成，齐活！</p><hr><p>控件演示程序下载地址：</p><p><a href="https://github.com/winsoft666/qt-custom-2d-controls">https://github.com/winsoft666/qt-custom-2d-controls</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面的《玩转 Qt 2D 绘图》系列文章中，已经介绍了 2D 绘图中常用的知识，本文主要通过一个汽车仪表盘的实例来综合应用前面所介绍知识点，并且还介绍了一些 Qt 绘图的常用技巧。&lt;/p&gt;
&lt;p&gt;相关文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/post/847642761.html&quot; title=&quot;玩转Qt 2D绘图之坐标系&quot;&gt;玩转Qt 2D绘图之坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/1336811290.html&quot; title=&quot;玩转Qt 2D绘图之画家的工具&quot;&gt;玩转Qt 2D绘图之画家的工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/1967189103.html&quot; title=&quot;玩转Qt 2D绘图之画家&quot;&gt;玩转Qt 2D绘图之画家&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Qt" scheme="https://jiangxueqiao.com/categories/Qt/"/>
    
    
    <category term="Qt" scheme="https://jiangxueqiao.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>互联网的黑话</title>
    <link href="https://jiangxueqiao.com/post/3924191794.html"/>
    <id>https://jiangxueqiao.com/post/3924191794.html</id>
    <published>2024-06-20T01:25:38.000Z</published>
    <updated>2024-07-09T01:58:18.313Z</updated>
    
    <content type="html"><![CDATA[<p>对于黑话我是拒绝的，但在这个圈子混，又不得不懂一些黑话，以防产生沟通障碍。关键时候说一两句黑话似乎还能显得有B格。</p><p>下面是在网上收集的一些黑话，进行了稍许整理，仅供娱乐，请勿当真。</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li><p>PM: 互联网产品经理，是互联网公司中的一种职能，负责互联网产品的计划和推广，以及互联网产品生命周期的演化。</p></li><li><p>RD：后端开发，属于软件研发工程师的一种，主要职责是后台系统设计与开发、接口设计和功能实现。</p></li><li><p>FE：前端开发，属于软件研发工程师的一种，使用 HTML、CSS、JavaScript 等专业技能和工具将产品UI设计稿实现成用户可视的app页面、网站页面等。</p></li><li><p>QA：测试工程师，属于软件测试工程师，工作职责包括：检查软件有没有缺陷（Bug）、测试软件是否具有稳定性（Robustness）、安全性、易操作性等性能。</p></li><li><p>UI：用户界面设计师，指从事对软件的人机交互、操作逻辑、界面美观的整体设计工作的人。</p></li><li><p>UE or UX：User Experience 用户体验，指以用户体验为中心的设计。</p></li><li><p>UED ：User Experience Design 用户体验设计，指以用户为中心的一种设计手段，以用户需求为目标而进行的设计。</p></li><li><p>HMI：Human Machine Interface 人机界面，人机界面是系统和用户之间进行交互和信息交换的媒介， 它实现信息的内部形式与人类可以接受形式之间的转换。</p></li><li><p>CLI：Command-line Interface 命令行界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。</p></li><li><p>CEO：Chief Executive Officer「首席执行官」</p></li><li><p>CTO：Chief Technology Officer「首席技术官」</p></li><li><p>COO：Chief Operations Officer「首席运营官」</p></li><li><p>CFO：首席财务官（Chief Financial Officer），负责公司的财务管理，包括财务报告、预算规划和资本投资决策。</p></li><li><p>HRBP：为Human Resource Business Partner（人力资源业务合作伙伴），是企业派驻到各个业务或事业部的人力资源管理者，主要协助各业务单元高层及经理在员工发展、人才发掘、能力培养等方面的工作。</p></li><li><p>SEM：Search Engine Marketing 搜索引擎营销。是一种网络营销形式，就是全面而有效的利用搜索引擎来进行网络营销和推广。</p></li><li><p>SEO：Search Engine Optimization 搜索引擎优化。利用搜索引擎的搜索规则来提高展示排名。</p></li><li><p>ASO：App Store Optimizatio 苹果应用商店搜索。指提升APP在各类APP苹果电子市场排行榜和搜索结果排名的过程。</p></li><li><p>UGC：User Generated Content 用户生成内容，用户将自己原创的内容在网上对他人呈现。</p></li><li><p>VC：Venture Capital 风险投资，大多是创业投资。</p></li><li><p>BP：Business Plan 商业计划书，是公司、企业或项目单位为了达到招商融资和其它发展目标，根据一定的格式和内容要求而编辑整理的一个向受众全面展示公司和项目目前状况、未来发展潜力的书面材料。</p></li><li><p>VR：Virtual Reality 虚拟现实，综合利用计算机图形系统和各种现实及控制等接口设备，在计算机上生成的，可交互的三维环境中提供沉浸感觉的技术。</p></li><li><p>AR：Augmented Reality 增强现实,它是一种将真实世界信息和虚拟世界信息“无缝”集成的新技术。真实的环境和虚拟的物体实时地叠加到了同一个画面或空间同时存在。</p></li><li><p>MR：Mediated Reality 介导现实，VR是纯虚拟数字画面，包括AR在内的Mixed Reality是虚拟数字画面+裸眼现实，MR是数字化现实+虚拟数字画面。</p></li><li><p>B2B：Business to Business 企业对企业的电子商务，如阿里巴巴。</p></li><li><p>B2C：Business to Customer 企业对个人的电子商务，如京东。</p></li><li><p>C2C：Customer to Customer 个人对个人的电子商务，如淘宝。</p></li><li><p>O2O：Online to Offline 线上对线下，线下商务与线上推广相结合。</p></li><li><p>新零售：未来电子商务平台即将消失，线上线下和物流结合在一起，才会产生新零售。线上是指云平台，线下是指销售门店或生产商，新物流消灭库存，减少囤货量。（电子商务平台消失是指，现有的电商平台分散，每个人都有自己的电商平台）</p></li><li><p>GMV: Gross Merchandise Volumn 商品总交易量。</p></li><li><p>CLV：每个客户在未来可能为企业带来的收益总和。</p></li><li><p>IAAS：Infrastructure-as-a-Service 基础设施即服务，消费者通过Internet 可以从完善的计算机基础设施获得服务。这类服务称为基础设施即服务。</p></li><li><p>PAAS：Platform-as-a-Service 平台即服务，把服务器平台作为一种服务提供的商业模式。</p></li><li><p>SAAS：Software-as-a-Service 软件即服务，一种通过Internet提供软件的模式，厂商将应用软件统一部署在自己的服务器上，客户可以根据自己实际需求，通过互联网向厂商定购所需的应用软件服务，按定购的服务多少和时间长短向厂商支付费用，并通过互联网获得厂商提供的服务。</p></li><li><p>ASP：Application Service provider 应用服务提供商，通过构建应用系统运行平台，然后再租给各个不同的用户使用。对用户来说，是以“月租”代替“购买”。</p></li><li><p>CRM：Customer Relationship Management 客户关系管理，指用计算机自动化分析销售、市场营销、客户服务以及应用等流程的软件系统</p></li><li><p>ERP：Enterprise Resource Planning 企业资源计划，企业资源计划是指建立在信息技术基础上，以系统化的管理思想，为企业决策层及员工提供决策运行手段的管理平台。</p></li><li><p>BPM：业务流程管理系统</p></li><li><p>MRD：Market Requirements Document 市场需求文档，常见的为竞品分析，一般用于立项，基于目前市场数据及竞品等进行项目提出，一般用于提案。</p></li><li><p>PRD：Product Requirement Document 产品需求文档，一般是说明实现的过程，较为详细。有些公司为了敏捷开发需要很多时候会直接在原型图上面通过注释方式进行更直观的展示。</p></li><li><p>PMD：Program Managment Document 项目管理文档，一般包括项目进度、项目资源、责任人和项目输出物，常规通过visio进行甘特图绘制管理。该文档一般贯穿整个项目全程，衡量项目进度。</p></li><li><p>BRD：Business Requirement Document 商业需求文档，是基于商业目标或价值所描述的产品需求内容文档（报告）。其核心的用途就是用于产品在投入研发之前，由企业高层作为决策评估的重要依据。其内容涉及市场分析，销售策略，盈利预测等，通常是供决策层们讨论的演示文档，一般比较短小精炼，没有产品细节。</p></li><li><p>DRD：Design Requirement Drawing 交互设计文档，一般用来承载交互说明，并交付给前端、测试以及开发工程师参考的文档。</p></li><li><p>FSD：Functional Specifications Document 功能详细说明，定义产品功能需求的全部细节。FSD一般通过一张张的截屏和一条条功能点来定义产品规格。这是一份可以直接让工程师创建产品的文档。</p></li><li><p>PSD：Product Specifications Document 产品规格文档，PSD是一个较不流行的缩写，但是在有这样一个文档的机构中，它大体和上面描述的功能规格文档（FSD）相同。</p></li><li><p>SRS：Software Requirements Specification 软件需求文档，软件需求文档（SRS）是另一较不流行的缩写，在创建SRS的机构中，它在内容和细节上和上面描述的PRD或FSD有些想像。</p></li><li><p>AARRR模型：Acquisition、Activation、Retention、Revenue、Refer 这个五个单词的缩写，分别对应这一款移动应用生命周期中的5个重要环节。分别为：获取用户、提高活跃度、提高留存率、获取收入、自传播。</p></li><li><p>RFM用户模型：R(Recency)表示客户最近一次购买的时间有多远，F(Frequency)表示客户在最近一段时间内购买的次数，M (Monetary)表示客户在最近一段时间内购买的金额。</p></li><li><p>用户增长的S型曲线、J型曲线：指大多数产品，在产品发展周期中，都会遵循S型曲线的增长方式；但有些产品，可能产生J型曲线无限增长。</p></li><li><p>用户金字塔模型：第一级是社区的管理人员。第二级是用户管理工具。第三级是有价值用户，基本就是在社区里面足够活跃，并且给你的社区贡献有效价值的那些用户。第四级一般性用户。</p></li><li><p>OO：Object Oriented 面向对象，是一种把面向对象的思想应用于软件开发过程中，指导开发活动的系统方法，是建立在“对象”概念基础上的方法学。</p></li><li><p>OOA：Object Oriented Analysis 面向对象分析，是确定需求或者业务的角度，按照面向对象的思想来分析业务。</p></li><li><p>OOD：Object Oriented Design 面向对象设计，是OO方法中一个中间过渡环节。其主要作用是对OOA分析的结果作进一步的规范化整理，以便能够被OOP直接接受。</p></li><li><p>OOP：Object Oriented Programming 面向对象程序设计，OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。</p></li><li><p>CMS：Content Management System 内容管理系统，是一种位于WEB 前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统。内容的创作人员、编辑人员、发布人员使用内容管理系统来提交、修改、审批、发布内容。</p></li><li><p>Adsens：Google AdSense 是一种获取收入的快速简便的方法，适合于各种规模的网站发布商。它可以在网站的内容网页上展示相关性较高的 Google广告，并且这些广告不会过分夸张醒目。</p></li><li><p>PPC：Pay Per Click 点击付费广告，规则是广告主只有当使用者实际上点击广告以拜访广告主的网站时，才需要支付费用。</p></li><li><p>DSP：Demand-Side Platform 需求方平台广告，它服务于广告主，帮助广告主在互联网或者移动互联网上进行广告投放，DSP可以使广告主更简单便捷地遵循统一的竞价和反馈方式，对位于多家广告交易平台的在线广告,以合理的价格实时购买高质量的广告库存。</p></li><li><p>SSP：Sell-Side Platform 供应方平台，通过这一平台，媒体主希望他们的库存广告可以获得最高的有效每千次展示费用，而不必以低价销售出去。</p></li><li><p>DMP：Data-Management Platform 数据管理平台，数据管理平台能够帮助所有涉及广告库存购买和出售的各方管理其数据、更方便地使用第三方数据、增强他们对所有这些数据的理解、传回数据或将定制数据传入某一平台，以进行更好地定位。</p></li><li><p>RTB：Real Time Bidding 实时竞价，RTB是一种技术为王的精准营销手段，当一个用户在全网浏览过某种商品，或点击过特殊类目的广告后，其浏览痕迹都会通过cookie记录在案，而通过广告交易平台，你在下一次浏览网页的时候，将被推送符合偏好的广告。</p></li><li><p>SPAM：搜索引擎垃圾技术，搜索引擎垃圾技术是利用不道德的技巧去提高自己搜索引擎上的排名。</p></li><li><p>CPC : 网络中最常见的一种广告形式，它是英文单词 Cost Per Click 的缩写意思就是每次点击付费广告。</p></li><li><p>CPM : Cost Per Thousand 广告投放过程中，1000次展现的费用。</p></li><li><p>CPA：Cost Per Action 每行动成本。指投放按广告实际效果，即按回应的有效问卷或定单来计费，而不限广告投放量。</p></li><li><p>CPR：每回应成本，Cost Per Response，以浏览者的每一个回应计费。</p></li><li><p>CPP: 每购买成本,Cost Per Purchase,广告主为规避广告费用风险，只有在网络用户点击旗帜广告并进行在线交易后，才按销售笔数付给广告站点费用。</p></li><li><p>CPS：Cost Per Sales 每销售成本，以实际销售产品数量来计算广告费用的广告，这种广告更多的适合购物类、导购类、网址导航类的网站，需要精准的流量才能带来转化。</p></li><li><p>CPT：Cost Per Time 按时间成本，这种方式的特点是按用户使用时长或使用周期计费，可以从根本上杜绝刷流量、激活作弊，是最真实的、有效的营销方式之一。</p></li><li><p>DAU：Daily Active User 日活跃用户数量，统计一日（统计日）之内，登录或使用了某个产品的用户数（去除重复登录的用户）。</p></li><li><p>WAU：Weekly Active Users 七天内登陆过产品的用户数。统计一周之内（统计日）之内，登录或使用了某个产品的用户数（去除重复登录的用户）。</p></li><li><p>MAU：Monthly Active User 月活跃用户量，统计一月之内（统计日）之内，登录或使用了某个产品的用户数（去除重复登录的用户）。</p></li><li><p>DOU：Day Old User 日老玩家用户，表示当天登录游戏的老玩家，指非当天新增的用户。</p></li><li><p>DNU：Day New User 日新增用户，表示当天的新增用户。</p></li><li><p>ACU：Average Concurrent Users 平均同时在线人数。</p></li><li><p>PCU：Peak Concurrent Users 最高同时在线人数。</p></li><li><p>UV：Unique Visitor 唯一访问量，可以理解为页面被多少人看过。</p></li><li><p>PV：Page View 页面浏览量，可以理解为页面被人看过的总次数。用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计。</p></li><li><p>RV: Repeat Visitors 重复访客。 </p></li><li><p>ARPU：Average Revenue Per User 平均每活跃用户收益。转化率：用户点击页面后，产生被期望的特定行为的数量，占总量的比。</p></li><li><p>ARPPU：Average Revenue Per Paying User 每付费用户平均收益。统计周期内，付费用户对产品产生的平均收入。</p></li><li><p>LTV：Life Time Value LTV 生命周期价值，是产品从用户所有的互动中所得到的全部经济收益的总和。</p></li><li><p>CAC：Customer Acquisition Cost 用户获取成本，获取用户所花费的成本。</p></li><li><p>KPI：Key Performance Indicator 关键绩效指标，是企业绩效考核的方法之一。</p></li><li><p>ROI：Return On Investment 投资回报率，投资回报率（ROI）&#x3D;利润总额&#x2F;投入成本总额×100%</p></li><li><p>抽离透传：“抽离主观感受”然后进行“透明传播”，就是说在传递信息时，不要传递带着你的情绪、判断，把你得到的信息透明地传递出去。</p></li><li><p>顶层设计：基本概念是运用系统论的方法，从全局的角度，对某项任务或者某个项目的各方面、各层次、各要素统筹规划，以集中有效资源，高效快捷地实现目标。</p></li><li><p>底层逻辑：即是哲学中所讲的事物发展的主要矛盾，策划方案中，多用与分析部分，指现象或者事件的根本原因 。</p></li><li><p>垂直领域：垂直领域，互联网行业术语，为限定群体提供特定服务，包括娱乐、医疗、环保、教育、体育等产业。</p></li><li><p>存量博弈：存量博弈是指在资源有限的情况下争夺市场份额</p></li><li><p>增量博弈：增量博弈是在做大蛋糕的过程中通过博弈获取更多或更少的份额，在营销中指在增量市场，抢占市场份额。</p></li><li><p>组合拳：本意是在拳法当中利用各种单一拳法的组合连续攻击，在营销策划中，指采用多种营销手段来达到最终营销诉求 。</p></li><li><p>击穿：比喻经受巨大的冲击导致效果显著。贬义上指承受不住冲击崩溃。</p></li><li><p>闭环：用来描述一个团队可以不借助外力完成一套完整的商业逻辑。</p></li><li><p>咬合：用来描述在跨部门项目上，部门人员之间的联动效果。</p></li><li><p>壁垒：古时候指战争中的防御工事，在策划案中，指品牌不可复制、不可超越的专属性优势，多用于战略和策略部分 。</p></li><li><p>提供情绪价值：拍马屁</p></li></ul><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">落地、沉淀、给到、响应、同步、对齐、对标、迭代、优化、跟进、升级、交付、聚焦、倒逼、复盘、梳理、</span><br><span class="line">输出、提炼、包装、上升、方案、摸索、踩坑、填坑、报备、串联、协同、联动、透传打通、打平、抹平、</span><br><span class="line">发力、兼容、量化、细分、重塑、蓄能、引爆、挖掘、背书、背锅、支持、支撑、协调、支援、加持、加速、</span><br><span class="line">共建、共创、融合、拉通、拉升、洞察、渗透、咬合、穿梭、辐射扩展、开拓、兜底、降级、容错、容灾、</span><br><span class="line">解耦、耦合、复用、封装、抽象、聚合、集成、拆解、抓包、观察、监控、上报、捕获、分发、分层、迁移、</span><br><span class="line">回溯、回归、回流、回跳、赋能、通晒、吃透、死磕、树立、跨界、共情、演绎、画饼、打造、反哺、输血、</span><br><span class="line">造血、造势、造市、造事、下沉、拉新、转化、留存、促活、付费、营收、盈利、获客、邀请、助力、激励、</span><br><span class="line">激活、推广、投放、导流看盖、曝光、裂变、增长、优秀、感恩、比心、笔芯、下跪、致敬、订阅、认证、</span><br><span class="line">推送、唤醒、流失、召回、授权、接入、铸造、构筑、构建、搭建、布局、组局、摸鱼、划水、众筹、收割、</span><br><span class="line">共享重组、收口、转型、围绕、出击、证言、确认、明确、评估、评审、务实、夯实、预判、预言、变迁、</span><br><span class="line">返佣、深入、打磨、攻坚、击穿、破冰、破题、解题、破圈、破局、定量、定性、制约、约束触及、触达、</span><br><span class="line">触发、操盘、思考、反思、精简、深耕、突围、补位、抽离、履约、进化、进军、起飞</span><br><span class="line"></span><br><span class="line">皮实、本分、重磅、垂直、真香、自治、精准、持续、灵活、稳定、可控、活跃</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">抓手、漏斗、中台、平台、闭环、风口、打法、玩法、矩阵、纽带、刺激、规模、场景、渠道、入口、维度、</span><br><span class="line">格局、形态、生态、体系、认知、体感、感知、心智、调性、战役、合力、心力、赛道基石、基因、因子、</span><br><span class="line">模型、通道、链路、水位、水准、姿态、卡点、卡位、头部、腰部、踝部、痛点、爽点、痒点、全域、公域、</span><br><span class="line">私域、本我、自我、超我、蓝海、红海、纵向、横向、上限、下限上游、下游、闽值、场域、架构、系统、</span><br><span class="line">标配、长尾、态势、锚点、标杆、壁垒、变量、期权、边界、品牌、阵地、高地、洼地、高空、革命、变革、</span><br><span class="line">内卷、外包、福报、脑暴、脑洞、圈层、层级段位、环节、闲局、话术、文案、议程、公关、PR稿、配称、</span><br><span class="line">力场、魔方、触点、势能、流量、资源、排期、延期、弹窗、浮层、引导、蒙层、幕帘、遮罩、埋点、坑位、</span><br><span class="line">楼层、按钮、推送、红包峰值、漏洞、风险、瓶颈、策略、价值、成本、复利、人性、利器、深度、玩家、</span><br><span class="line">小白、非菜、羊毛、福利、套路、情怀、标准、规范、报备、社群、产业、载体、服务、粘性、属性、</span><br><span class="line">地域、终端版本、口碑、指标、年框、试点、母体、空白、银弹</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对一下、碰一下、过一下、抢品类、卡认知、占场景、观行业、明竞争、洞自身、开场子、提调子、冷启动、秀肌肉、</span><br><span class="line">借东风、断舍离、婷羊毛、砍一刀、走出去、讲故事</span><br><span class="line"></span><br><span class="line">扁平化、差异化、平台化、结构化、精细化、短平快、常态化、强依赖、不可控</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">感知度、颗粒度、方法论、组合拳、引爆点、护城河、影响力、资源位、优先级、制高点、可用性</span><br><span class="line"></span><br><span class="line">易用性、稳定性、便捷性、耦合性、一致性、系统性、端到端、点对点、点线面、上半场、下半场</span><br><span class="line"></span><br><span class="line">主战场、基本面、基本盘、操盘手、进化论、解释权、最优解、执行力、驱动力、鄙视链人货场</span><br><span class="line"></span><br><span class="line">生态链、生态圈全渠道全方位、全媒体、流量池、天花板、传话筒、转化率生态位、全场景、</span><br><span class="line"></span><br><span class="line">新零售、新物种、新品牌、活跃度、颗粒感登云梯、冲击力、视觉锤、孵化器、新篇章、新局势</span><br><span class="line"></span><br><span class="line">新赛道、新势能、新国货、新国潮、新动力、同理心气氛组、竞争力、存在感、认同感、参与感</span><br><span class="line"></span><br><span class="line">归属感、使命感、忠诚度、预热期、高峰期、高潮期、上升期、瓶颈期、大数据、云计算.价值观、!</span><br><span class="line"></span><br><span class="line">区块链、比特币、虚拟币、天使轮、自媒体、新媒体、价格门、超预期、小前台、大中台、凝聚力、</span><br><span class="line"></span><br><span class="line">向心力</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">支棱起来、快速响应、小步快跑、价值转化、强化认知、资源置换、资源倾斜、资源配置、完善逻辑、去中心化、</span><br><span class="line">渠道下沉、用户下沉、降维打击、体验度量、高频触达、快速迭代、持续迭代、持续集成、持续交付、持续观察、</span><br><span class="line">躬身入局、顺势而为、打破结界、升维定位、有机结合、起承转合、存量维持、增量博弈、心智角逐、抽离透传、</span><br><span class="line">拨几参会、反复确认、综合评估、刻意练习、打破制约.绝境求生、品牌露出、拥抱变化、重新定义、借势营销、</span><br><span class="line">内容创业、归因分析、逻辑推理、建立范式、总结沉淀、解决问题、占领心智、高举高打、高开低走、高台跳水、</span><br><span class="line">深入产业、拉齐水位、全情投入、如何收口、全面封锁、协同作战、剑走偏锋、弹射起飞</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结果导向、业务导向、资源紧张、人力不足、体感不好、风险可控、逻辑自洽、品效合一、全球领先、</span><br><span class="line">人无我有/人有我优/人优我变、势如破竹、势不可挡、石破天惊</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">生命周期、复用打法、商业模式、平台战略、集团战略、战略引警、关键路径、决策路径、天使投资、盈利模式、</span><br><span class="line">底层逻辑、顶层设计、饥饿营销、行业壁垒、下沉市场、消费认知、人工智能、赛博明克、智慧城市、解决万案、</span><br><span class="line">知识付费、私域流量、交付价值、时间价值、共享经济、通证经济、中央厨房、先发优势、真实场景、临门一脚、</span><br><span class="line">真香定律、正态分布、幂律分布、二八定律、长尾理论叠加效应、马太效应、沉没成本、边际成本、机会成本、</span><br><span class="line">偏好植入、蚂蚁市场、场景占位、产业集群、产业服务、标杆市场、心动情境、利基市场、第二曲线、增长飞轮、</span><br><span class="line">垂直领域、可持续性、可替代性、认知优势、新增长点、颠覆态势、最高规制、三位一体、资深玩家、不破不立、</span><br><span class="line">精神SPA、用户心智、用户粘性、用户体验、用户认知、用户画像、用户调研、重度用户、沉默用户、活跃用户、</span><br><span class="line">用户黏性、千人千面、千人一面、信息茧房、流量红利、流量为王、价格歧视、意识形态、心理账户、情绪G点、</span><br><span class="line">品牌势能、服务产业、关键时期、沟通协作、战略合力、品牌航母、品类战舰、行军路线产品尖兵、拳头产品、</span><br><span class="line">超级符号、挽留弹窗、时间窗口、定性定量、战略支点、声音印记、社交货币、付费社群、神交已久、财务自由</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">大数据分析、大数据杀熟、延迟满足感、地毯式轰炸、饱和式攻击、四两拨千斤、开辟新路径、建立新习惯</span><br><span class="line"></span><br><span class="line">用户无感知、叫好又叫座、优先级很高、拉新成本高、打开率极高、留存率奇高、活跃度新高</span><br><span class="line"></span><br><span class="line">颠覆式创新、连续创业者、投入产出比、互联网思维、互联网红利、国民总时间、最后一公里、海豚湾模式、</span><br><span class="line">最大公约数、现象级事件、沉浸式体验、用户忠诚度、自媒体矩阵、病毒式营销、风口上的猪、战略性投资、</span><br><span class="line">战略性亏损、系统性风险</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于黑话我是拒绝的，但在这个圈子混，又不得不懂一些黑话，以防产生沟通障碍。关键时候说一两句黑话似乎还能显得有B格。&lt;/p&gt;
&lt;p&gt;下面是在网上收集的一些黑话，进行了稍许整理，仅供娱乐，请勿当真。&lt;/p&gt;
&lt;h2 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class</summary>
      
    
    
    
    <category term="杂念" scheme="https://jiangxueqiao.com/categories/%E6%9D%82%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>建立专属的账号密码体系</title>
    <link href="https://jiangxueqiao.com/post/737594544.html"/>
    <id>https://jiangxueqiao.com/post/737594544.html</id>
    <published>2024-06-03T04:53:19.000Z</published>
    <updated>2024-06-24T02:51:40.493Z</updated>
    
    <content type="html"><![CDATA[<p>在日常生活中，我们不仅需要记忆6位数字的银行卡密码，还需要记忆各式各样网站和应用的账号密码，可能我们自己也不记得曾经注册过多少个账号。账号和密码如此繁多，管理这些账号和密码，也是一个让人头疼的问题。</p><p>最原始的方法是将密码写纸上，放在一个安全的地方，但纸张存在丢失、损坏的风险，而且不方便存取。</p><p>改进版则是将纸张电子化，如 Excel，并辅以云盘实现多端同步，这样虽然存取便利性上有一定的改善，但安全性却降低了很多，如果云盘没有历史版本功能，在编辑时稍有失误，可能导致密码全部丢失，另外如果云盘密码泄露、电脑中毒或系统损坏，也可能导致密码泄露或丢失。如果某一天云盘软件突然倒闭了，该怎么办呢？</p><p>目前已经有很多账号密码管理软件，来帮助人们管理账号和密码，如 1Password、KeePass 等，但它们也或多或少存在一些缺陷：</p><span id="more"></span><ul><li>对系统和平台（Windows、Linux、macOS、安卓、iOS等）支持完善的工具大多需要收费，而且费用不便宜；免费的工具通常对系统和平台的支持不够完善，也不好用。</li><li>在多端同步方面，收费软件通常支持云端同步，但这样将账号密码存储在他人服务器总归不放心；免费软件通常不支持云端不同，需要自己使用云盘来同步，操作麻烦。</li><li>软件可能存在后门，导致账号密码泄露。</li><li>软件可能随时停止运营或无法打开。</li></ul><p>综上所述，我认为只有记在大脑中的密码才是最安全和方便的。那么，对于大多数没有什么密码学基础的普通人来说，如何形成一套自己的个人账号密码设置体系呢？</p><p>账号密码体系由账号和密码二者构成，一一对应，需要明确的是，我们可能忘记密码，同样我们也可能忘记账号，因此账号和密码同样重要。</p><h2 id="1-账号"><a href="#1-账号" class="headerlink" title="1. 账号"></a>1. 账号</h2><p>根据使用场景（国内、网站）和系统注册要求的不同，通常需要准备如下类型的账号。</p><h3 id="1-1-手机号码"><a href="#1-1-手机号码" class="headerlink" title="1.1 手机号码"></a>1.1 手机号码</h3><p>现在基本每个人都有手机号码，而且国内手机号都已实名认证，注册国内网站、应用时优先使用手机号码进行注册，如果支持短信验证码登录，则优先使用短信验证码登录。</p><h3 id="1-2-电子邮件"><a href="#1-2-电子邮件" class="headerlink" title="1.2 电子邮件"></a>1.2 电子邮件</h3><p>需要准备国内和国外两个电子邮件，分别用于注册国内、外的网站和应用。因为国外平台可能不支持国内的邮件服务商，而如果使用国外邮件服务注册国内平台，又可能导致邮件收取缓慢或无法收取，因此建议根据国内外应用分别使用不同的国内外邮件服务。</p><p>国内邮件服务推荐：</p><ul><li>163</li><li>QQ</li></ul><p>国外邮件服务推荐：</p><ul><li>Gmail</li><li>Outlook</li></ul><p>不建议使用小众邮箱，这些邮箱可能随时因为公司经营不善而倒闭或停止服务。</p><h3 id="1-3-英文数字账号"><a href="#1-3-英文数字账号" class="headerlink" title="1.3 英文数字账号"></a>1.3 英文数字账号</h3><p>有的网站支持使用“英文+数字”形式的账号进行注册（当然后期可能因为账号安全性，要求绑定手机号或邮箱），建议使用统一的、不暴露隐私的英文数字账号。</p><p>不建议在账号中使用中文、下划线、横线，因为虽然有些的网站支持这些特殊字符，但无法保证所有网站都支持这些字符。</p><h3 id="1-4-隐私性"><a href="#1-4-隐私性" class="headerlink" title="1.4 隐私性"></a>1.4 隐私性</h3><p>在注册国内网站&#x2F;应用时，不需要纠结使用国内手机号、邮箱的隐私性，因为根据国内目前的政策和现状，国内网站和应用基本没有隐私性可言。</p><h2 id="2-密码"><a href="#2-密码" class="headerlink" title="2. 密码"></a>2. 密码</h2><p>最安全的密码方案肯定是不同的网站和应用使用不同的随机字符串作为密码，但是这样不方便记忆，而且大多数情况下也不需要这么高强度的安全性。</p><p>下面是一种折中的密码生成方案，生成的密码可以符合绝大多数应用的要求，该方案可以在保证密码安全的前提下，方便记忆，如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/xCPR0qeOuY.png"></p><blockquote><p>该方案还有很多可改进之处，例如应用名称也可以通过某种固定规则来缩写等。</p></blockquote><p>固定前缀和特殊字符后缀需要根据自己喜好来设定，如固定字符前缀为“he”，特殊字符后缀为“?”。</p><p>混淆码则根据应用名称缩写长度（补零之前的长度）的不同而不同，需要自己定义一套规则，如：</p><table><thead><tr><th>长度</th><th>混淆码</th></tr></thead><tbody><tr><td>1 ~ 2</td><td>1111</td></tr><tr><td>3 ~ 4</td><td>2222</td></tr><tr><td>5 ~ 7</td><td>3333</td></tr><tr><td>8 ~ 10</td><td>4444</td></tr><tr><td>10 以上</td><td>5555</td></tr></tbody></table><blockquote><p>上表仅用作示例，抛砖引玉。</p></blockquote><p>根据上述示例规则，下面列举几个网站的密码示例。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">知乎</span><br><span class="line">heZ00H1111?</span><br><span class="line"></span><br><span class="line">今日头条</span><br><span class="line">heJrtT2222?</span><br><span class="line"></span><br><span class="line">Chrome</span><br><span class="line">heChromE3333?</span><br></pre></td></tr></table></figure><h2 id="3-不重要的账号密码"><a href="#3-不重要的账号密码" class="headerlink" title="3. 不重要的账号密码"></a>3. 不重要的账号密码</h2><p>为了防止账号和密码泄露，从而被他人猜测出密码的生成规则，因此在注册小型、非正规、不重要的网站和应用时，建议使用一个专门的账号和密码，即便密码泄露也无关紧要。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在日常生活中，我们不仅需要记忆6位数字的银行卡密码，还需要记忆各式各样网站和应用的账号密码，可能我们自己也不记得曾经注册过多少个账号。账号和密码如此繁多，管理这些账号和密码，也是一个让人头疼的问题。&lt;/p&gt;
&lt;p&gt;最原始的方法是将密码写纸上，放在一个安全的地方，但纸张存在丢失、损坏的风险，而且不方便存取。&lt;/p&gt;
&lt;p&gt;改进版则是将纸张电子化，如 Excel，并辅以云盘实现多端同步，这样虽然存取便利性上有一定的改善，但安全性却降低了很多，如果云盘没有历史版本功能，在编辑时稍有失误，可能导致密码全部丢失，另外如果云盘密码泄露、电脑中毒或系统损坏，也可能导致密码泄露或丢失。如果某一天云盘软件突然倒闭了，该怎么办呢？&lt;/p&gt;
&lt;p&gt;目前已经有很多账号密码管理软件，来帮助人们管理账号和密码，如 1Password、KeePass 等，但它们也或多或少存在一些缺陷：&lt;/p&gt;</summary>
    
    
    
    <category term="爱折腾" scheme="https://jiangxueqiao.com/categories/%E7%88%B1%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="密码" scheme="https://jiangxueqiao.com/tags/%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈Qt的布局技巧</title>
    <link href="https://jiangxueqiao.com/post/1495821570.html"/>
    <id>https://jiangxueqiao.com/post/1495821570.html</id>
    <published>2024-05-17T11:00:00.000Z</published>
    <updated>2024-05-28T01:40:28.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-手动拖放"><a href="#1-手动拖放" class="headerlink" title="1. 手动拖放"></a>1. 手动拖放</h1><p>通过在 Qt Designer 中手动拖放控件，可以快速实现界面布局，如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/5OlnDS5QGd-TinyTu.png"></p><p>这种方式对初学者非常友好，可以快速上手开发一个界面，增加成就感。但我们需要知道，拖放布局不是 Qt 布局的全部，这种方式仅适合简单的界面布局。</p><span id="more"></span><p>在实际的项目开发中，界面上的控件会比上面示例中的多得多，布局也会更加复杂，而且界面通常还需要反复地调整。在这种情况下，如果继续通过手动拖放的方式来进行布局，在每次界面调整时，我们都需要打破（分拆）原有的布局，并在修改完成之后重新进行布局，可能还需要重新设置布局的 Spacing 和 ContentsMargins，每一次修改都非常费劲。</p><blockquote><p>题外话：</p><p>手动拖放控件对手的稳定性要求较高，可能手稍一抖，整个布局就错乱了，又得还原了重新来。</p></blockquote><h1 id="2-代码布局"><a href="#2-代码布局" class="headerlink" title="2. 代码布局"></a>2. 代码布局</h1><p>我通常使用代码的方式来进行 Qt 界面布局，例如下面的代码实现了与上面示例一样的布局效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">QLabel* lblUserName = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;用户名: &quot;</span>);</span><br><span class="line">QLabel* lblPassword = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;密码: &quot;</span>);</span><br><span class="line">QLineEdit* editUserName = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>();</span><br><span class="line">QLineEdit* editPassword = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>();</span><br><span class="line">QPushButton* btnLogin = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;登录&quot;</span>);</span><br><span class="line">QPushButton* btnRegister = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;注册&quot;</span>);</span><br><span class="line"></span><br><span class="line">QHBoxLayout* hUserName = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">hUserName-&gt;<span class="built_in">addWidget</span>(lblUserName);</span><br><span class="line">hUserName-&gt;<span class="built_in">addWidget</span>(editUserName);</span><br><span class="line"></span><br><span class="line">QHBoxLayout* hPassword = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">hPassword-&gt;<span class="built_in">addWidget</span>(lblPassword);</span><br><span class="line">hPassword-&gt;<span class="built_in">addWidget</span>(editPassword);</span><br><span class="line"></span><br><span class="line">QHBoxLayout* hButton = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">hButton-&gt;<span class="built_in">addStretch</span>();</span><br><span class="line">hButton-&gt;<span class="built_in">addWidget</span>(btnRegister);</span><br><span class="line">hButton-&gt;<span class="built_in">addWidget</span>(btnLogin);</span><br><span class="line">hButton-&gt;<span class="built_in">addStretch</span>();</span><br><span class="line"></span><br><span class="line">QVBoxLayout* vMain = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>();</span><br><span class="line">vMain-&gt;<span class="built_in">addLayout</span>(hUserName);</span><br><span class="line">vMain-&gt;<span class="built_in">addLayout</span>(hPassword);</span><br><span class="line">vMain-&gt;<span class="built_in">addStretch</span>();</span><br><span class="line">vMain-&gt;<span class="built_in">addLayout</span>(hButton);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setLayout</span>(vMain);</span><br></pre></td></tr></table></figure><p>大家看到上面代码后，第一感觉肯定是“我的个老天，这么复杂”，这个可以理解。但这种方式的好处也非常明显，比如灵活性更大，后期调整、复用、维护也更加方便，而且对于自定义控件比较多的界面，这种方式可以直接创建对应类型的实例，不需要在设计器上进行类型提升。</p><h1 id="3-布局描述语言"><a href="#3-布局描述语言" class="headerlink" title="3. 布局描述语言"></a>3. 布局描述语言</h1><p>我在这里不是为了创造一种新的语言，而是受到了 Flutter 界面布局方式的启发，对 Qt 的布局进行了封装，简化了上述布局代码。</p><p>下面是上述示例简化后的布局代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> layout = <span class="built_in">VBox</span>(</span><br><span class="line">    <span class="built_in">HBox</span>(lblUserName, editUserName),</span><br><span class="line">    <span class="built_in">HBox</span>(lblPassword, editPassword),</span><br><span class="line">    <span class="built_in">Stretch</span>(),</span><br><span class="line">    <span class="built_in">HBox</span>(<span class="built_in">Stretch</span>(), btnRegister, btnLogin, <span class="built_in">Stretch</span>()));</span><br><span class="line"></span><br><span class="line"><span class="built_in">setLayout</span>(layout);</span><br></pre></td></tr></table></figure><p>从代码量来看，明显少了很多，而且我们还可以通过代码的层次结构快速看出界面的布局结构。</p><p>在此省略了 VBox、HBox 等类的实现代码，如果您对上述 Qt 布局方式的具体实现感兴趣，可以在下面留言或者联系我。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-手动拖放&quot;&gt;&lt;a href=&quot;#1-手动拖放&quot; class=&quot;headerlink&quot; title=&quot;1. 手动拖放&quot;&gt;&lt;/a&gt;1. 手动拖放&lt;/h1&gt;&lt;p&gt;通过在 Qt Designer 中手动拖放控件，可以快速实现界面布局，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-static.jiangxueqiao.com/blog/img/5OlnDS5QGd-TinyTu.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种方式对初学者非常友好，可以快速上手开发一个界面，增加成就感。但我们需要知道，拖放布局不是 Qt 布局的全部，这种方式仅适合简单的界面布局。&lt;/p&gt;</summary>
    
    
    
    <category term="Qt" scheme="https://jiangxueqiao.com/categories/Qt/"/>
    
    
    <category term="Qt" scheme="https://jiangxueqiao.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>C++异常之我所见</title>
    <link href="https://jiangxueqiao.com/post/1878135693.html"/>
    <id>https://jiangxueqiao.com/post/1878135693.html</id>
    <published>2024-05-13T05:30:05.000Z</published>
    <updated>2024-07-26T16:15:02.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-异常所带来的问题"><a href="#C-异常所带来的问题" class="headerlink" title="C++异常所带来的问题"></a>C++异常所带来的问题</h1><p>当我们在代码中写下一行 throw 语句时，我们就此埋下了一个祸根，从此以后，在该函数调用链中，必须至少有一个调用者需要提供相应的异常捕获，否则一旦异常被抛出，程序就会异常终止。</p><p>例如，函数 f() 调用 g()，而 g() 又调用 h()，并且 h() 抛出一个异常，则 g() 和 f()中必须有一个提供了相应的异常捕获，否则程序会异常终止。</p><p>由于异常会使代码的执行流程从任意地方跳出，因此我们还需要付出大量的精力来编写正确的异常安全代码，例如使用 RAII（资源获取即初始化）来保证资源正确释放。</p><p>如下面的示例，虽然我们在函数 f() 中捕获了异常，避免了程序的异常终止，但异常却中断了函数 g() 的正常执行流程，导致对象 m 没有被正确释放，从而出现了资源泄露。这种情况可能还会变相地增加了程序的调试难度。</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* m = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line">    <span class="built_in">h</span>();</span><br><span class="line">    <span class="keyword">delete</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">g</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启用异常还会在每个生成的二进制文件中添加额外的数据，从而增加编译时间（可能只是略微增加）并可能增加地址空间的使用。</p><p>异常的存在可能会导致开发人员滥用异常，在本不该（或不需要）抛出异常的地方抛出异常。例如，无效的用户输入就不应抛出异常。</p><p>即便我们捕获了异常，我们也很难从异常中恢复回来，因为我不能确定异常具体是从调用链的哪一步抛出的，也无法知晓每一步的实现逻辑，因此如果程序中使用了异常，我们除了做好必要的参数检查，尽量避免异常发生，在异常被抛出时，让程序自然的退出也是一个不错的选择。</p><h1 id="能完全避免使用异常吗？"><a href="#能完全避免使用异常吗？" class="headerlink" title="能完全避免使用异常吗？"></a>能完全避免使用异常吗？</h1><p>太难了，我们很难完全避免使用异常。</p><p>在 C++ 标准库（STL）中，大多数情况是通过抛出异常的形式来返回错误的，虽然我们可以使用诸如 <a href="https://github.com/electronicarts/EASTL">EASTL</a> 这样的库来替代 STL，但仍然很难避免程序使用的其他库不会使用 STL 以及抛出异常，比如常用的日志库 spldlog、boost库、rpclib库等都会抛出异常。</p><p>因此要完全的不使用异常，我们需要从头实现众多的基础组件，这是一个巨大的工作量。</p><h1 id="折中的办法"><a href="#折中的办法" class="headerlink" title="折中的办法"></a>折中的办法</h1><p>虽然我们很难完全避免异常，但我们还是可以努力远离异常的。</p><p>下面是我的一点点建议：</p><p>可以使用 <a href="https://github.com/electronicarts/EASTL">EASTL</a> 替代 STL，或者仅使用 STL 中不抛出异常的模块。</p><p>在选择第三方库时，尽量选择不使用异常的库，通常 C 语言开发的库不会使用异常，如 <a href="https://github.com/curl/curl">curl</a>、<a href="https://github.com/HardySimpson/zlog">zlog</a> 等，但需要留意有些 C 语言库可能会使用 exit 和 abort 函数，我觉得使用这两个函数比使用异常更可怕，异常导致程序崩溃至少有迹可循，而这两个函数退出程序时，通常很难排查定位。</p><p>保证自己编写的代码不主动抛出异常，例如函数通过返回值的形式返回错误，并且尽可能使用 C++ 17 中的<code>[[nodiscard]]</code>，强制调用者检查返回值。但应避免使用全局状态变量，如 Windows 的 LastError，因为这样会破坏函数调用的局部性。</p><p>构造函数也可能会失败，但我们不应使用异常来抛出错误。按照惯例，可以使用两步构造法，在构造函数中只做基本的、不会出错、不会抛出异常的操作或者直接使用空的构造函数，然后提供一个单独的 init 函数来进行初始化，并返回错误码。</p><p>异常捕获的粒度不宜太细，如果对每一行可能抛出异常的语句都进行异常捕获，这样会导致代码过于繁琐。如果粒度太粗，又会导致异常难于恢复，失去了捕获的意义。我们要做的是，在调用函数前，对参数进行充分地检查，尽量避免异常的发生，然后仅在关键代码位置进行异常捕获。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;C-异常所带来的问题&quot;&gt;&lt;a href=&quot;#C-异常所带来的问题&quot; class=&quot;headerlink&quot; title=&quot;C++异常所带来的问题&quot;&gt;&lt;/a&gt;C++异常所带来的问题&lt;/h1&gt;&lt;p&gt;当我们在代码中写下一行 throw 语句时，我们就此埋下了一个祸根，从此以后，在该函数调用链中，必须至少有一个调用者需要提供相应的异常捕获，否则一旦异常被抛出，程序就会异常终止。&lt;/p&gt;
&lt;p&gt;例如，函数 f() 调用 g()，而 g() 又调用 h()，并且 h() 抛出一个异常，则 g() 和 f()中必须有一个提供了相应的异常捕获，否则程序会异常终止。&lt;/p&gt;
&lt;p&gt;由于异常会使代码的执行流程从任意地方跳出，因此我们还需要付出大量的精力来编写正确的异常安全代码，例如使用 RAII（资源获取即初始化）来保证资源正确释放。&lt;/p&gt;
&lt;p&gt;如下面的示例，虽然我们在函数 f() 中捕获了异常，避免了程序的异常终止，但异常却中断了函数 g() 的正常执行流程，导致对象 m 没有被正确释放，从而出现了资源泄露。这种情况可能还会变相地增加了程序的调试难度。&lt;/p&gt;</summary>
    
    
    
    <category term="C++语言" scheme="https://jiangxueqiao.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://jiangxueqiao.com/tags/C/"/>
    
    <category term="异常" scheme="https://jiangxueqiao.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>有趣的Unicode表情符号</title>
    <link href="https://jiangxueqiao.com/post/3984616957.html"/>
    <id>https://jiangxueqiao.com/post/3984616957.html</id>
    <published>2024-04-28T04:53:19.000Z</published>
    <updated>2024-05-31T06:32:53.327Z</updated>
    
    <content type="html"><![CDATA[<p>本文了转载和收集了一些常用的 Unicode 表情符号，方便查阅。完整的 Unicode 表情符号可以查询下面的网站：</p><ul><li><a href="https://www.unicode.org/emoji/charts/emoji-list.html">unicode官网emoji列表</a></li><li><a href="https://en.wikipedia.org/wiki/List_of_emojis">wikipedia List_of_emojis</a></li></ul><hr><h2 id="几何图形"><a href="#几何图形" class="headerlink" title="几何图形"></a>几何图形</h2><p>🞀🞁🞂🞃🞄🞅🞇🞉🞌🞍🞑🞒🞓🞔🞕🞖🞗🞘🞚🞛🞜🞝🞞🞠🞡🞢🞣🞤🞥🞦🞧🞨🞩🞪🞫🞬🞭🞮❎✔✅☑︎<br>🞯🞰🞱🞲🞳🞴🞵🞶🞷🞸🞹🞺🞻🞼🞽🞾🞿🟀🟂🟃🟄🟆🟇🟈🟉🟊🟌🟍🟎🟐🟒🟔<br>🟠🟡🟢🟣🟤🟥🟦🟧🟨🟩🟪🟫</p><h2 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h2><p>🤗🤫🤣🙃🙂🥰🤩🤪🤑🤭🤔<br>🤐🤬🥱😩🥺🧐🤓😎🤠🥳😵‍💫<br>🤯🤧😷🤒🤕🤢🤮🥵🥶🥴🤤<br>🤥🤨🤖🤡💩</p><p>🙈 🙉 🙊</p><p>😀😁😂😃😄😅😆😉😊😋😎😍😘😗😙😚☺😇😐😑😶😏😣<br>😥😮😯😪😫😴😌😛😜😝😒😓😔😕😲😷😖😞😟😤😢😭😦<br>😧😨😬😰😱😳😵😡😠</p><h2 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h2><p>💋💯💢💥💫💦💨🕳💬👁️‍🗨️🗨🗯💭💤</p><h2 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h2><p>👦👧👨👩👴👵👶👱👮👲👳👷👸💂🎅👰👼💆💇🙍🙎🙅🙆💁🙋🙇<br>🙌🙏👤👥🚶🏃👯💃👫👬👭💏💑👪</p><h2 id="不同肤色、发型、性别的人"><a href="#不同肤色、发型、性别的人" class="headerlink" title="不同肤色、发型、性别的人"></a>不同肤色、发型、性别的人</h2><p>👴👴🏻👴🏼👴🏽👴🏾👴🏿<br>💇🦰🦱🦳🦲<br>🧑👨👩👫</p><h2 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h2><p>💪👈👉☝👆👇✌✋👌👍👎✊👊👋👏👐✍</p><h2 id="手机电话"><a href="#手机电话" class="headerlink" title="手机电话"></a>手机电话</h2><p>📱📲📶📳📴☎📞📟📠</p><h2 id="公共社会"><a href="#公共社会" class="headerlink" title="公共社会"></a>公共社会</h2><p>♻🏧🚮🚰♿🚹🚺🚻🚼🚾⚠🚸⛔🚫🚳🚭🚯🚱🚷🔞💈</p><h2 id="动物"><a href="#动物" class="headerlink" title="动物"></a>动物</h2><p>🙈🙉🙊🐵🐒🐶🐕🐩🐺🐱😺😸😹😻😼😽🙀😿😾🐈<br>🐯🐅🐆🐴🐎🐮🐂🐃🐄🐷🐖🐗🐽🐏🐑🐐🐪🐫🐘<br>🐭🐁🐀🐹🐰🐇🐻🐨🐼🐾🐔🐓🐣🐤🐥🐦🐧🐸<br>🐊🐢🐍🐲🐉🐳🐋🐬🐟🐠🐡🐙🐚🐌🐛🐜🐝🐞🦋</p><h2 id="植物"><a href="#植物" class="headerlink" title="植物"></a>植物</h2><p>💐🌸💮🌹🌺🌻🌼🌷🌱🌲🌳🌴🌵🌾🌿🍀🍁🍂🍃</p><h2 id="自然天气"><a href="#自然天气" class="headerlink" title="自然天气"></a>自然天气</h2><p>🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜<br>☀🌝🌞⭐🌟🌠☁⛅☔⚡❄🔥💧🌊🌈</p><h2 id="食物"><a href="#食物" class="headerlink" title="食物"></a>食物</h2><p>🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍅🍆🌽🍄🌰🍞<br>🍖🍗🍔🍟🍕🍳🍲🍱🍘🍙🍚🍛🍜🍝🍠🍢🍣🍤🍥🍡<br>🍦🍧🍨🍩🍪🎂🍰🍫🍬🍭🍮🍯🍼☕🍵🍶🍷🍸🍹🍺🍻🍴</p><h2 id="文体"><a href="#文体" class="headerlink" title="文体"></a>文体</h2><p>🎪🎭🎨🎰🚣🛀🎫🏆⚽⚾🏀🏈🏉🎾🎱🎳⛳🎣🎽🎿<br>🏂🏄🏇🏊🚴🚵🎯🎮🎲🎷🎸🎺🎻🎬</p><h2 id="恐怖"><a href="#恐怖" class="headerlink" title="恐怖"></a>恐怖</h2><p>😈👿👹👺💀☠👻👽👾💣</p><h2 id="十二生肖"><a href="#十二生肖" class="headerlink" title="十二生肖"></a>十二生肖</h2><p>🐁🐂🐅🐇🐉🐍🐎🐐🐒🐓🐕🐖</p><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>🕛🕧🕐🕜🕑🕝🕒🕞🕓🕟🕔🕠🕕🕡🕖🕢🕗🕣🕘🕤🕙🕥🕚🕦<br>⌛⏳⌚⏰⏱⏲🕰</p><h2 id="爱心"><a href="#爱心" class="headerlink" title="爱心"></a>爱心</h2><p>❤💌💝<br>❤️‍🔥<br>❤️‍🩹<br>🧡💛💚💙💜🤎🖤🤍<br>💘❤💓💔💕💖💗💙💚💛💜💝💞💟❣</p><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><p>🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕<br>🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚣🚤🚢✈💺🚁🚟🚠🚡🚀</p><h2 id="办公"><a href="#办公" class="headerlink" title="办公"></a>办公</h2><p>📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡📔📕<br>📖📗📘📙📚📓📃📜📄📰📑🔖💳✉📧📨📩📤📥📦📫📪📬📭📮<br>✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂🔒🔓🔏🔐🔑</p><h2 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h2><p>⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝</p><h2 id="八卦"><a href="#八卦" class="headerlink" title="八卦"></a>八卦</h2><p>☰☱☲☳☴☵☶☷</p><p>䷀䷁䷂䷃䷄䷅䷆䷇<br>䷈䷉䷊䷋䷌䷍䷎䷏<br>䷐䷑䷒䷓䷔䷕䷖䷗<br>䷘䷙䷚䷛䷜䷝䷞䷟<br>䷠䷡䷢䷣䷤䷥䷦䷧<br>䷨䷩䷪䷫䷬䷭䷮䷯<br>䷰䷱䷲䷳䷴䷵䷶䷷<br>䷸䷹䷺䷻䷼䷽䷾䷿</p><h2 id="扑克牌"><a href="#扑克牌" class="headerlink" title="扑克牌"></a>扑克牌</h2><p>🂠🂡🂢🂣🂤🂥🂦🂧🂨🂩🂪🂫🂬🂭🂮🂱🂲🂳🂴🂵🂶🂷🂸🂹🂺🂻🂼🂽🂾🂿<br>🃁🃂🃃🃄🃅🃆🃇🃈🃉🃊🃋🃌🃍🃎🃏🃑🃒🃓🃔🃕🃖🃗🃘🃙🃚🃛🃜🃝🃞🃟<br>🃠🃡🃢🃣🃤🃥🃦🃧🃨🃩🃪🃫🃬🃭🃮🃯🃰🃱🃲🃳🃴🃵</p><h2 id="麻将牌"><a href="#麻将牌" class="headerlink" title="麻将牌"></a>麻将牌</h2><p>🀀🀁🀂🀃🀄🀅🀆🀇🀈🀉🀊🀋🀌🀍🀎🀏🀐🀑🀒🀓🀔🀕🀖🀗🀘<br>🀙🀚🀛🀜🀝🀞🀟🀠🀡🀢🀣🀤🀥🀦🀧🀨🀩🀪🀫</p><h2 id="多米诺骨牌"><a href="#多米诺骨牌" class="headerlink" title="多米诺骨牌"></a>多米诺骨牌</h2><p>🀰🀱🀲🀳🀴🀵🀶🀷🀸🀹🀺🀻🀼🀽🀾🀿🁀🁁🁂🁃🁄🁅🁆🁇🁈🁉🁊<br>🁋🁌🁍🁎🁏🁐🁑🁒🁓🁔🁕🁖🁗🁘🁙🁚🁛🁜🁝🁞🁟🁠🁡<br>🁢🁣🁤🁥🁦🁧🁨🁩🁪🁫🁬🁭🁮🁯🁰🁱🁲🁳🁴🁵🁶🁷🁸🁹🁺<br>🁻🁼🁽🁾🁿🂀🂁🂂🂃🂄🂅🂆🂇🂈🂉🂊🂋🂌🂍🂎🂏🂐🂑🂒🂓</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文了转载和收集了一些常用的 Unicode 表情符号，方便查阅。完整的 Unicode 表情符号可以查询下面的网站：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.unicode.org/emoji/charts/emoji-list.html&quot;&gt;u</summary>
      
    
    
    
    <category term="爱折腾" scheme="https://jiangxueqiao.com/categories/%E7%88%B1%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="Unicode" scheme="https://jiangxueqiao.com/tags/Unicode/"/>
    
    <category term="Emoji" scheme="https://jiangxueqiao.com/tags/Emoji/"/>
    
  </entry>
  
  <entry>
    <title>生活家（转载）</title>
    <link href="https://jiangxueqiao.com/post/1485983255.html"/>
    <id>https://jiangxueqiao.com/post/1485983255.html</id>
    <published>2024-04-19T14:20:38.000Z</published>
    <updated>2024-06-14T04:08:15.918Z</updated>
    
    <content type="html"><![CDATA[<p>《红楼梦》第五十回中，一夜大雪后，贾府大观园的姐妹们一起作诗，众姐妹要王熙凤为即景联诗起个头。王熙凤虽只识得几个字，倒也不扭捏，笑道:“我想下雪必刮北风。昨夜听见了一夜的北风，我有了一句，就是‘一夜北风紧’，可使得?”众人听了，都相视笑道：“这句虽粗，不见底下的，这正是会作诗的起法。不但好，而且留了多少地步与后人”。</p><p>的确，与大观园里才女们的锦心绣口比起来，“一夜北风紧”甚至算不上诗。不过，凤姐说得没错。大雪将落之时，必是要刮北风的。她不是优秀的诗人，却是一位洞察世事的生活家。</p><p>成年后，我与父亲聊起凤姐的“一夜北风紧”，母亲突然问：“这个凤姐是不是一个厉害人物，掌管着整个家族事务?”我吃惊地点头，母亲视力不佳看不成戏文，更没有读过《红楼梦》，她是如何得知的呢？母亲解释:“你想啊，在深宅大院，熟睡的人根本听不到外面的动静。能听到一夜北风的人，肯定是日夜操劳、心里装着事的人啊!”</p><p>母亲的话让我想起小时候的无数个清晨，看到院子里有一摊摊水渍，我好奇地问父母:“昨晚下雨了吗？”，“又是刮风又是下雨的，凌晨四五点钟才停。”父母回答。当时我还纳闷儿：我怎么一点儿动静都没有听到呢？现在想来，那时年少无忧无虑，一觉酣睡到天亮，疾风骤雨都与自己无关。而父母为一家人的生计操劳，晚上听到风雨声，会惦记着衣服收了没有，已经结了穗的庄稼会不会被风雨打得七零八落，雨后道路泥泞是否影响出工……</p><p>终于，我懂得了父母，也读懂了凤姐。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;《红楼梦》第五十回中，一夜大雪后，贾府大观园的姐妹们一起作诗，众姐妹要王熙凤为即景联诗起个头。王熙凤虽只识得几个字，倒也不扭捏，笑道:“我想下雪必刮北风。昨夜听见了一夜的北风，我有了一句，就是‘一夜北风紧’，可使得?”众人听了，都相视笑道：“这句虽粗，不见底下的，这正是会作</summary>
      
    
    
    
    <category term="剪切板" scheme="https://jiangxueqiao.com/categories/%E5%89%AA%E5%88%87%E6%9D%BF/"/>
    
    
    <category term="红楼梦" scheme="https://jiangxueqiao.com/tags/%E7%BA%A2%E6%A5%BC%E6%A2%A6/"/>
    
  </entry>
  
  <entry>
    <title>玩转Qt 2D绘图之画家</title>
    <link href="https://jiangxueqiao.com/post/1967189103.html"/>
    <id>https://jiangxueqiao.com/post/1967189103.html</id>
    <published>2024-04-08T12:55:02.000Z</published>
    <updated>2025-02-25T05:19:17.610Z</updated>
    
    <content type="html"><![CDATA[<p>在 Qt 2D 世界中，图形基本都由点、线、矩形、多边形、椭圆、圆、折线、曲线、文本、贴图等基本元素辅以着色而构成，而且 QPainter 类已经提供了这些元素的绘制方法，花点时间掌握这些方法，也就掌握了 Qt 2D图形控件的制作，余下的就是勤学多练、孰能生巧了。</p><span id="more"></span><h1 id="一、点"><a href="#一、点" class="headerlink" title="一、点"></a>一、点</h1><p>在 Qt 中使用 QPoint 或 QPointF 类型表示一个点的坐标。</p><p>QPoint 和 QPointF 的区别在于：QPoint 使用整型表示 X 和 Y 坐标，而 QPointF 使用 qreal 浮点类型表示X和Y坐标。下面如无特殊说明，所介绍的方法都适用于两个类型。</p><p>QPoint 类型虽然提供了 <code>isNull</code> 方法来判断对象是否为空，在 X 和 Y 坐标均为 0 时，isNull 返回 true，其他情况返回 false。在使用 QPoint::isNull 方法时要留意这个情况。</p><p>可以使用 QPoint::manhattanLength 方法返回 x 和 y 坐标的绝对值之和（也叫曼哈顿距离），如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">pt</span><span class="params">(<span class="number">-2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">pt.<span class="built_in">manhattanLength</span>(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="1-1-两点距离"><a href="#1-1-两点距离" class="headerlink" title="1.1 两点距离"></a>1.1 两点距离</h2><p>使用两点间的距离公式可以快速计算两点的距离：</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.094ex;" xmlns="http://www.w3.org/2000/svg" width="33.12ex" height="4.208ex" role="img" focusable="false" viewBox="0 -1376.5 14639 1860"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mrow"><g data-mml-node="mo" transform="translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(1028,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mo" transform="translate(1787,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g></g><g data-mml-node="mo" transform="translate(2342.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msqrt" transform="translate(3398.6,0)"><g transform="translate(1020,0)"><g data-mml-node="msup"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(961,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1683.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(2683.4,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(3255.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(3755.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="mn" transform="translate(4177.4,477.1) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(4803.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="msup" transform="translate(5803.4,0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(879,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1601.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(2601.4,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(3091.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(3591.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="mn" transform="translate(4013.4,477.1) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g><g data-mml-node="mo" transform="translate(0,166.5)"><path data-c="221A" d="M1001 1150Q1017 1150 1020 1132Q1020 1127 741 244L460 -643Q453 -650 436 -650H424Q423 -647 423 -645T421 -640T419 -631T415 -617T408 -594T399 -560T385 -512T367 -448T343 -364T312 -259L203 119L138 41L111 67L212 188L264 248L472 -474L983 1140Q988 1150 1001 1150Z"></path></g><rect width="10220.4" height="60" x="1020" y="1256.5"></rect></g></g></g></svg></mjx-container></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtMath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">QPointF <span class="title">pt1</span><span class="params">(<span class="number">-2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">QPointF <span class="title">pt2</span><span class="params">(<span class="number">4</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">qreal distance = <span class="built_in">qSqrt</span>(<span class="built_in">qPow</span>(pt1.<span class="built_in">x</span>() - pt2.<span class="built_in">x</span>(), <span class="number">2.0</span>) + <span class="built_in">qPow</span>(pt1.<span class="built_in">y</span>() - pt2.<span class="built_in">y</span>(), <span class="number">2.0</span>)); <span class="comment">// 7.21</span></span><br></pre></td></tr></table></figure><h2 id="1-2-drawPoint-与-drawPoints"><a href="#1-2-drawPoint-与-drawPoints" class="headerlink" title="1.2 drawPoint 与 drawPoints"></a>1.2 drawPoint 与 drawPoints</h2><p>drawPoint 用于绘制单个点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawPoint</span><span class="params">(<span class="type">const</span> QPointF &amp;position)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawPoint</span><span class="params">(<span class="type">const</span> QPoint &amp;position)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawPoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br></pre></td></tr></table></figure><p>drawPoints 用于一次性绘制多个点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawPoints</span><span class="params">(<span class="type">const</span> QPointF *points, <span class="type">int</span> pointCount)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawPoints</span><span class="params">(<span class="type">const</span> QPolygonF &amp;points)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawPoints</span><span class="params">(<span class="type">const</span> QPoint *points, <span class="type">int</span> pointCount)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawPoints</span><span class="params">(<span class="type">const</span> QPolygon &amp;points)</span></span></span><br></pre></td></tr></table></figure><p><code>QPolygon</code>继承自 <code>QVector&lt;QPoint&gt;</code>，而<code>QPolygonF</code>继承自 <code>QVector&lt;QPointF&gt;</code>。</p><h1 id="二、折线"><a href="#二、折线" class="headerlink" title="二、折线"></a>二、折线</h1><p>折线是由多个点相连组成的非闭合线条（相邻的两个点连接成直线，但首位不相连）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawPolyline</span><span class="params">(<span class="type">const</span> QPointF *points, <span class="type">int</span> pointCount)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawPolyline</span><span class="params">(<span class="type">const</span> QPolygonF &amp;points)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawPolyline</span><span class="params">(<span class="type">const</span> QPoint *points, <span class="type">int</span> pointCount)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawPolyline</span><span class="params">(<span class="type">const</span> QPolygon &amp;points)</span></span></span><br></pre></td></tr></table></figure><p>下面示例演示了折线的一种绘制方法，为了使线条更加圆润，我们还设置了线条的起落笔样式和相交点样式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(Qt::red, <span class="number">6</span>, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));</span><br><span class="line"></span><br><span class="line">  QPolygon pg;</span><br><span class="line">  pg &lt;&lt; <span class="built_in">QPoint</span>(<span class="number">20</span>, <span class="number">200</span>) &lt;&lt; <span class="built_in">QPoint</span>(<span class="number">80</span>, <span class="number">10</span>) &lt;&lt; <span class="built_in">QPoint</span>(<span class="number">140</span>, <span class="number">200</span>) &lt;&lt; <span class="built_in">QPoint</span>(<span class="number">200</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">drawPolyline</span>(pg);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><img src="https://blog-static.jiangxueqiao.com/blog/img/62W7Gt1Q3h.png"></p><h1 id="三、多边形"><a href="#三、多边形" class="headerlink" title="三、多边形"></a>三、多边形</h1><p>多边形是在折线的基础上首尾相连而来，并且可以使用画刷对多边形的闭合区域进行填充。</p><p>仍然使用上面示例中定义的点来绘制多边形，设置 QPainter 画刷颜色为蓝色：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(Qt::red, <span class="number">6</span>, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));</span><br><span class="line"></span><br><span class="line">  QPolygon pg;</span><br><span class="line">  pg &lt;&lt; <span class="built_in">QPoint</span>(<span class="number">20</span>, <span class="number">200</span>) &lt;&lt; <span class="built_in">QPoint</span>(<span class="number">80</span>, <span class="number">10</span>) &lt;&lt; <span class="built_in">QPoint</span>(<span class="number">140</span>, <span class="number">200</span>) &lt;&lt; <span class="built_in">QPoint</span>(<span class="number">200</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">setBrush</span>(Qt::blue);</span><br><span class="line">  painter.<span class="built_in">drawPolygon</span>(pg);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><img src="https://blog-static.jiangxueqiao.com/blog/img/xbITvSAD7q.png"></p><h1 id="四、线"><a href="#四、线" class="headerlink" title="四、线"></a>四、线</h1><p>两点（QPoint 或 QPointF）可以确定一条直线，Qt 提供了 QLine 和 QLineF 类型来描述线段。</p><p>使用 drawLine 方法可以绘制一条直线，使用 drawLines 方法则可以一次性绘制多条直线。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLine</span><span class="params">(<span class="type">const</span> QLineF &amp;line)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLine</span><span class="params">(<span class="type">const</span> QLine &amp;line)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLine</span><span class="params">(<span class="type">const</span> QPoint &amp;p1, <span class="type">const</span> QPoint &amp;p2)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLine</span><span class="params">(<span class="type">const</span> QPointF &amp;p1, <span class="type">const</span> QPointF &amp;p2)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLines</span><span class="params">(<span class="type">const</span> QLineF *lines, <span class="type">int</span> lineCount)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLines</span><span class="params">(<span class="type">const</span> QVector&lt;QLineF&gt; &amp;lines)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLines</span><span class="params">(<span class="type">const</span> QPointF *pointPairs, <span class="type">int</span> lineCount)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLines</span><span class="params">(<span class="type">const</span> QVector&lt;QPointF&gt; &amp;pointPairs)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLines</span><span class="params">(<span class="type">const</span> QLine *lines, <span class="type">int</span> lineCount)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLines</span><span class="params">(<span class="type">const</span> QVector&lt;QLine&gt; &amp;lines)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLines</span><span class="params">(<span class="type">const</span> QPoint *pointPairs, <span class="type">int</span> lineCount)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLines</span><span class="params">(<span class="type">const</span> QVector&lt;QPoint&gt; &amp;pointPairs)</span></span></span><br></pre></td></tr></table></figure><h1 id="五、椭圆与圆"><a href="#五、椭圆与圆" class="headerlink" title="五、椭圆与圆"></a>五、椭圆与圆</h1><h2 id="5-1-椭圆"><a href="#5-1-椭圆" class="headerlink" title="5.1 椭圆"></a>5.1 椭圆</h2><p>椭圆有长轴、短轴、焦点等概念，建议在学习绘制椭圆之前先了解椭圆的这些概念，可以参考之前的文章 <a href="/post/66759332.html" title="回顾2D绘图的数学知识">回顾2D绘图的数学知识</a> 中的“椭圆”章节。</p><p>Qt提供了 QPainter::drawEllipse 方法绘制椭圆，方法原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawEllipse</span><span class="params">(<span class="type">const</span> QRectF &amp;rectangle)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawEllipse</span><span class="params">(<span class="type">const</span> QRect &amp;rectangle)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawEllipse</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawEllipse</span><span class="params">(<span class="type">const</span> QPointF &amp;center, qreal rx, qreal ry)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawEllipse</span><span class="params">(<span class="type">const</span> QPoint &amp;center, <span class="type">int</span> rx, <span class="type">int</span> ry)</span></span></span><br></pre></td></tr></table></figure><p>drawEllipse 方法虽然有5种重载形式，但总体来说，都是传递一个矩形区域给 drawEllipse方法，因为根据传入的矩形可以确定椭圆的长轴、短轴和焦点，其中长轴等于矩形的长，短轴等于矩形的高，2个焦点分别位于2个长半轴的中间。</p><p>下面示例先绘制了一个浅灰色的矩形（用于观察椭圆的绘制），然后在使用该矩形绘制椭圆。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  <span class="function">QRectF <span class="title">rect</span><span class="params">(<span class="number">50</span>, <span class="number">50</span>, <span class="number">300</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 浅灰色的矩形</span></span><br><span class="line">  painter.<span class="built_in">setPen</span>(Qt::lightGray);</span><br><span class="line">  painter.<span class="built_in">drawRect</span>(rect);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 红色椭圆</span></span><br><span class="line">  painter.<span class="built_in">setPen</span>(Qt::red);</span><br><span class="line">  painter.<span class="built_in">drawEllipse</span>(rect);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><img src="https://blog-static.jiangxueqiao.com/blog/img/cPTivgqulV-TinyTu.png"></p><h2 id="5-2-圆"><a href="#5-2-圆" class="headerlink" title="5.2 圆"></a>5.2 圆</h2><p>圆是椭圆的一种特殊情况，当椭圆的长轴等于短轴时，所绘制出来的就是圆了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 宽 = 高</span></span><br><span class="line">  <span class="function">QRectF <span class="title">rect</span><span class="params">(<span class="number">50</span>, <span class="number">50</span>, <span class="number">300</span>, <span class="number">300</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">drawEllipse</span>(rect);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="六、矩形"><a href="#六、矩形" class="headerlink" title="六、矩形"></a>六、矩形</h1><p>在 Qt中使用 QRect 和 QRectF 类型来表示矩形，在使用 QRect 时需要关注 QRect 的历史遗留问题，详见：<a href="/post/847642761.html" title="玩转Qt 2D绘图之坐标系">玩转Qt 2D绘图之坐标系</a> 的“QRect遗留问题”章节。</p><h2 id="6-1-矩形的合法性"><a href="#6-1-矩形的合法性" class="headerlink" title="6.1 矩形的合法性"></a>6.1 矩形的合法性</h2><p>QRect和QRectF类型均提供了isEmpty、isNull、isValid方法，但 QRect 由于历史遗留问题，官方文档中对各个方法的定义看起来比较怪异，进行逻辑下面对其进行了逻辑运算，方便理解。</p><p><strong>QRect</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isEmpty</span>() == <span class="built_in">left</span>() &gt; <span class="built_in">right</span>() || <span class="built_in">top</span>() &gt; <span class="built_in">bottom</span>()</span><br><span class="line">            == <span class="built_in">left</span>() &gt; <span class="built_in">left</span>() + <span class="built_in">width</span>() - <span class="number">1</span> || <span class="built_in">top</span>() &gt; <span class="built_in">top</span>() + <span class="built_in">height</span>() - <span class="number">1</span></span><br><span class="line">            == <span class="number">1</span> &gt; <span class="built_in">width</span>() || <span class="number">1</span> &gt; <span class="built_in">height</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">isNull</span>()  == (<span class="built_in">right</span>() == <span class="built_in">left</span>() - <span class="number">1</span> &amp;&amp; <span class="built_in">bottom</span>() == <span class="built_in">top</span>() - <span class="number">1</span>)</span><br><span class="line">            == (<span class="built_in">left</span>() + <span class="built_in">width</span>() - <span class="number">1</span> == <span class="built_in">left</span>() - <span class="number">1</span> &amp;&amp; <span class="built_in">top</span>() + <span class="built_in">height</span>() - <span class="number">1</span> == <span class="built_in">top</span>() - <span class="number">1</span>)</span><br><span class="line">            == (<span class="built_in">width</span>() == <span class="number">0</span> &amp;&amp; <span class="built_in">height</span>() == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">isValid</span>() == <span class="built_in">left</span>() &lt;= <span class="built_in">right</span>() &amp;&amp; <span class="built_in">top</span>() &lt;= <span class="built_in">bottom</span>()</span><br><span class="line">            == <span class="built_in">left</span>() &lt;= <span class="built_in">left</span>() + <span class="built_in">width</span>() - <span class="number">1</span> &amp;&amp; <span class="built_in">top</span>() &lt;= <span class="built_in">top</span>() + <span class="built_in">height</span>() - <span class="number">1</span></span><br><span class="line">            == <span class="number">1</span> &lt;= <span class="built_in">width</span>() &amp;&amp; <span class="number">1</span> &lt;= <span class="built_in">height</span>()</span><br></pre></td></tr></table></figure><p><strong>QRectF</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isEmpty</span>() == <span class="built_in">width</span>() &lt;= <span class="number">0</span> || <span class="built_in">height</span>() &lt;= <span class="number">0</span></span><br><span class="line"><span class="built_in">isNull</span>()  == <span class="built_in">width</span>() == <span class="number">0</span> &amp;&amp; <span class="built_in">height</span>() == <span class="number">0</span></span><br><span class="line"><span class="built_in">isValid</span>() == <span class="built_in">width</span>() &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">height</span>() &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>从上述定义可以发现，当前矩形的宽或高为负数时，isNull 返回的却是 false。</p><h2 id="6-2-drawRect-与-drawRects"><a href="#6-2-drawRect-与-drawRects" class="headerlink" title="6.2 drawRect 与 drawRects"></a>6.2 drawRect 与 drawRects</h2><p>使用 drawRect 方法绘制单个矩形，使用 drawRects 方法一次性绘制多个矩形。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawRect</span><span class="params">(<span class="type">const</span> QRectF &amp;rectangle)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawRect</span><span class="params">(<span class="type">const</span> QRect &amp;rectangle)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawRects</span><span class="params">(<span class="type">const</span> QRectF *rectangles, <span class="type">int</span> rectCount)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawRects</span><span class="params">(<span class="type">const</span> QVector&lt;QRectF&gt; &amp;rectangles)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawRects</span><span class="params">(<span class="type">const</span> QRect *rectangles, <span class="type">int</span> rectCount)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawRects</span><span class="params">(<span class="type">const</span> QVector&lt;QRect&gt; &amp;rectangles)</span></span></span><br></pre></td></tr></table></figure><p>下面是一个简单的使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">drawRect</span>(<span class="built_in">QRect</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">200</span>, <span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">setPen</span>(Qt::red);</span><br><span class="line"></span><br><span class="line">  QVector&lt;QRect&gt; rects;</span><br><span class="line">  rects &lt;&lt; <span class="built_in">QRect</span>(<span class="number">60</span>, <span class="number">60</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        &lt;&lt; <span class="built_in">QRect</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">  painter.<span class="built_in">drawRects</span>(rects);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><img src="https://blog-static.jiangxueqiao.com/blog/img/nMkJV3hBOE.png"></p><h2 id="6-3-圆角矩形"><a href="#6-3-圆角矩形" class="headerlink" title="6.3 圆角矩形"></a>6.3 圆角矩形</h2><p>上面绘制的矩形都不是圆角，在Qt中绘制圆角矩形有两种方式：</p><ul><li><p>QPainter::drawRoundedRect，本节主要介绍这种方法，这种方法绘制的圆角矩形的4个角的曲度一样。  </p><p>QPainter还提供了 drawRoundRect 方法也可以绘制圆角矩形，但该方法已经被标记为弃用，因此不建议继续使用。</p></li><li><p>QPainter::drawPath 通过路径的方式来绘制圆角矩形，这种方法绘制的圆角矩形的4个角的曲度可以不一样，该方法会在下面章节介绍。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::drawRoundedRect</span><span class="params">(<span class="type">const</span> QRectF &amp;rect, qreal xRadius, qreal yRadius, Qt::SizeMode mode = Qt::AbsoluteSize)</span></span></span><br></pre></td></tr></table></figure><p>下面示例为了演示圆角矩形和普通的直角矩形的不同，先绘制了一个浅灰色直角矩形，然后再相同区域绘制了一个红色圆角矩形。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  <span class="function">QRectF <span class="title">rect</span><span class="params">(<span class="number">50</span>, <span class="number">50</span>, <span class="number">300</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先绘制一个浅灰色的矩形</span></span><br><span class="line">  painter.<span class="built_in">setPen</span>(Qt::lightGray);</span><br><span class="line">  painter.<span class="built_in">drawRect</span>(rect);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后绘制一个红色圆角矩形</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  qreal xRadius = <span class="number">20</span>;</span><br><span class="line">  qreal yRadius = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(Qt::red, <span class="number">1</span>, Qt::DashDotLine));</span><br><span class="line">  painter.<span class="built_in">drawRoundedRect</span>(rect, xRadius, yRadius);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><img src="https://blog-static.jiangxueqiao.com/blog/img/JPvz0pEZK9.png"></p><h3 id="7-4-xRadius-与-yRadius"><a href="#7-4-xRadius-与-yRadius" class="headerlink" title="7.4 xRadius 与 yRadius"></a>7.4 xRadius 与 yRadius</h3><p>xRadius 与 yRadius 参数决定了圆角的曲度，drawRoundedRect 方法绘制的圆角矩形的四个角采用同一个曲度。那么 xRadius 与 yRadius 参数是如何决定圆角的曲度的呢？</p><p>xRadius 参数实际为椭圆的长半轴，yRadius 参数实际为椭圆的短半轴。</p><blockquote><p>关于椭圆的相关知识，可以参考之前的文章 <a href="/post/66759332.html" title="回顾2D绘图的数学知识">回顾2D绘图的数学知识</a> 中的“椭圆”章节。</p></blockquote><p>通过 xRadius 和 yRadius 参数确定了椭圆的长轴和短轴，那么在什么位置画椭圆呢？答案是：贴着四个顶角分别画 4 个椭圆来确定曲度。</p><p>下面代码在上面示例的基础上，分别在左上角和右下角位置画了2个深黄色的椭圆，可以看到椭圆与圆角是刚好重合的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  <span class="function">QRectF <span class="title">rect</span><span class="params">(<span class="number">50</span>, <span class="number">50</span>, <span class="number">300</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先绘制一个浅灰色的矩形</span></span><br><span class="line">  painter.<span class="built_in">setPen</span>(Qt::lightGray);</span><br><span class="line">  painter.<span class="built_in">drawRect</span>(rect);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后绘制一个红色圆角矩形</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  qreal xRadius = <span class="number">20</span>;</span><br><span class="line">  qreal yRadius = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(Qt::red, <span class="number">1</span>, Qt::DashDotLine));</span><br><span class="line">  painter.<span class="built_in">drawRoundedRect</span>(rect, xRadius, yRadius);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ~~~ 新增如下代码 ~~~</span></span><br><span class="line">  painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(Qt::darkYellow, <span class="number">1</span>, Qt::DashLine));</span><br><span class="line">  painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QRectF</span>(rect.<span class="built_in">left</span>(), rect.<span class="built_in">top</span>(), xRadius * <span class="number">2</span>, yRadius * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QRectF</span>(rect.<span class="built_in">right</span>() - xRadius * <span class="number">2</span>, rect.<span class="built_in">bottom</span>() - yRadius * <span class="number">2</span>, xRadius * <span class="number">2</span>, yRadius * <span class="number">2</span>));</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><img src="https://blog-static.jiangxueqiao.com/blog/img/CcDGmFkvxa.png"></p><h1 id="七、椭圆上的一段线"><a href="#七、椭圆上的一段线" class="headerlink" title="七、椭圆上的一段线"></a>七、椭圆上的一段线</h1><h2 id="7-1-弧线（Arc）"><a href="#7-1-弧线（Arc）" class="headerlink" title="7.1 弧线（Arc）"></a>7.1 弧线（Arc）</h2><p>使用 drawArc 方法可以绘制一段弧线：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawArc</span><span class="params">(<span class="type">const</span> QRectF &amp;rectangle, <span class="type">int</span> startAngle, <span class="type">int</span> spanAngle)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawArc</span><span class="params">(<span class="type">const</span> QRect &amp;rectangle, <span class="type">int</span> startAngle, <span class="type">int</span> spanAngle)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawArc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> startAngle, <span class="type">int</span> spanAngle)</span></span></span><br></pre></td></tr></table></figure><p>在前面介绍的椭圆绘制方法中，我们通过指定一个矩形区域就可以绘制一个椭圆，而 drawArc 方法绘制曲线的则是该椭圆上的某一段弧线。通过 startAngle 参数指定弧线的起始角度，spanAngle 参数指定弧线所跨越的角度。</p><p><strong>需要注意：</strong></p><p><strong>在 QPainter 的绘图函数中指定角度（不是弧度）时，以正三点钟方向为 0 度，角度按逆时针方向增长，整个圆按 5760 度计算（即 16 * 360）。</strong></p><p><strong>在 GDI+ 中，也是以正三点钟方向为 0 度，但角度是按顺时针方向增长的，且整个圆按 360 度计算。</strong></p><p>下面的示例绘制一段红色的弧线，弧线从 30 度方向开始，弧线跨越了 120 度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  <span class="function">QRectF <span class="title">rect</span><span class="params">(<span class="number">50</span>, <span class="number">50</span>, <span class="number">300</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 浅灰色的矩形</span></span><br><span class="line">  painter.<span class="built_in">setPen</span>(Qt::lightGray);</span><br><span class="line">  painter.<span class="built_in">drawRect</span>(rect);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 蓝色的椭圆</span></span><br><span class="line">  painter.<span class="built_in">setPen</span>(Qt::blue);</span><br><span class="line">  painter.<span class="built_in">drawEllipse</span>(rect);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 红色的弧线</span></span><br><span class="line">  painter.<span class="built_in">setPen</span>(Qt::red);</span><br><span class="line">  painter.<span class="built_in">drawArc</span>(rect, <span class="number">30</span> * <span class="number">16</span>, <span class="number">120</span> * <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>实际绘制效果如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/kbPavNdJMU-TinyTu.png"></p><p>从上图可以看到，弧线实际是椭圆上的某一段曲线。</p><h2 id="7-2-饼状图（Pie）"><a href="#7-2-饼状图（Pie）" class="headerlink" title="7.2 饼状图（Pie）"></a>7.2 饼状图（Pie）</h2><p>使用 drawPie 可以绘制饼状图，饼状图是在上面弧线（Arc）的基础上，分别将弧线的首尾与中心点相连而来，因此 drawPie 方法的参数也与 drawArc 方法一样。</p><p>QPainter 在绘制饼状图时，会使用当前的画刷填充饼状图。</p><p>下面的示例绘制了一个具有红色轮廓、黄色填充的饼状图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  <span class="function">QRectF <span class="title">rect</span><span class="params">(<span class="number">50</span>, <span class="number">50</span>, <span class="number">300</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 浅灰色的矩形</span></span><br><span class="line">  painter.<span class="built_in">setPen</span>(Qt::lightGray);</span><br><span class="line">  painter.<span class="built_in">drawRect</span>(rect);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 蓝色的椭圆</span></span><br><span class="line">  painter.<span class="built_in">setPen</span>(Qt::blue);</span><br><span class="line">  painter.<span class="built_in">drawEllipse</span>(rect);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 饼状图：红色的轮廓，黄色的填充</span></span><br><span class="line">  painter.<span class="built_in">setPen</span>(Qt::red);</span><br><span class="line">  painter.<span class="built_in">setBrush</span>(Qt::yellow);</span><br><span class="line">  painter.<span class="built_in">drawPie</span>(rect, <span class="number">30</span> * <span class="number">16</span>, <span class="number">120</span> * <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><img src="https://blog-static.jiangxueqiao.com/blog/img/2EEdcr6yvl-TinyTu.png"></p><h2 id="7-3-和弦图（Chrod）"><a href="#7-3-和弦图（Chrod）" class="headerlink" title="7.3 和弦图（Chrod）"></a>7.3 和弦图（Chrod）</h2><blockquote><p>此处将 Chrod 按照英文直译成“和弦”可能不太准确</p></blockquote><p>和弦图（Chrod）与饼状图（Pie）一样，也是在弧线的基础上变化而来，将弧线的首尾相接就可得到和弦图（Chrod）。</p><p>使用 drawChord 方法可以绘制和弦图，drawChord 方法的参数与 drawArc 一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  <span class="function">QRectF <span class="title">rect</span><span class="params">(<span class="number">50</span>, <span class="number">50</span>, <span class="number">300</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 浅灰色的矩形</span></span><br><span class="line">  painter.<span class="built_in">setPen</span>(Qt::lightGray);</span><br><span class="line">  painter.<span class="built_in">drawRect</span>(rect);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 蓝色的椭圆</span></span><br><span class="line">  painter.<span class="built_in">setPen</span>(Qt::blue);</span><br><span class="line">  painter.<span class="built_in">drawEllipse</span>(rect);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 和弦图：红色的轮廓，黄色的填充</span></span><br><span class="line">  painter.<span class="built_in">setPen</span>(Qt::red);</span><br><span class="line">  painter.<span class="built_in">setBrush</span>(Qt::yellow);</span><br><span class="line">  painter.<span class="built_in">drawChord</span>(rect, <span class="number">30</span> * <span class="number">16</span>, <span class="number">120</span> * <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><img src="https://blog-static.jiangxueqiao.com/blog/img/7IE8i958tn-TinyTu.png"></p><h1 id="八、路径"><a href="#八、路径" class="headerlink" title="八、路径"></a>八、路径</h1><p>前面介绍了线、矩形、椭圆、圆、弧线、饼状图等形状，路径则是由若干个这些形状（不限于这些形状）组成的一个集合，路径可以是闭合的，也可以不闭合。</p><p>在Qt中使用<a href="https://doc.qt.io/qt-6/qpainterpath.html">QPainterPath</a>对象来定义一个路径，并使用如下方法向路径中添加形状：</p><ul><li>addEllipse 添加一个椭圆或圆到路径中</li><li>addRect 添加一个矩形到路径中</li><li>addRoundedRect 添加一个圆角矩形到路径中</li><li>addText 将用指定字体绘制的文件所形成的闭合形状添加到路径中</li><li>lineTo 添加一条直线到路径中</li><li>arcTo 添加一段圆弧到路径中<br>arcTo 的原型如下，和 drawArc 方法类似，也需要指定起始角度和跨越角度，但与drawArc 方法不同的是，arcTo 方法指定的角度是以360度整圆计算的，因此不需要乘以 16。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainterPath::arcTo</span><span class="params">(<span class="type">const</span> QRectF &amp;rectangle, qreal startAngle, qreal sweepLength)</span></span></span><br></pre></td></tr></table></figure></li><li>cubicTo 添加一个三次贝塞尔曲线到路径中</li><li>quadTo 添加一个二次贝塞尔曲线到路径中</li></ul><p>在上面方法中，命名格式为“<em>To”的方法，如 lineTo、arcTo、quadTo 等，都是基于“当前位置”来添加形状的，默认的当前位置为当前的*<em>坐标原点</em></em> (0,0) 处，我们可以使用 <code>QPainterPath::currentPosition</code> 方法获取当前位置。</p><blockquote><p>我们知道可以通过 QPainter::translate 等方法变换逻辑坐标，QPainterPath 的当前位置也会受逻辑坐标变换的影响。</p></blockquote><p>在使用 lineTo 添加直线到路径中时，只有指定直线的结束点，会自动将当前位置与结束点相连，形成一条直线，并重设当前位置为该结束点。</p><p>在使用 arcTo、cubicTo、quadTo 添加曲线到到路径中时，会自动将当前位置与曲线起点相连，并重设当前位置为曲线结束点。</p><p>我们使用一个示例来说明当前位置和结束点的关系，下面示例先添加一条直线，然后添加一个曲线，最好再添加一条直线：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：当前位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  QPainterPath path;</span><br><span class="line">  path.<span class="built_in">lineTo</span>(<span class="number">80</span>, <span class="number">50</span>);</span><br><span class="line">  path.<span class="built_in">arcTo</span>(<span class="built_in">QRectF</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">300</span>, <span class="number">200</span>), <span class="number">30</span>, <span class="number">120</span>);</span><br><span class="line">  path.<span class="built_in">lineTo</span>(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">drawPath</span>(path);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>实际效果如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/AD2v1fc6Xg.png"></p><h2 id="8-1-填充规则"><a href="#8-1-填充规则" class="headerlink" title="8.1 填充规则"></a>8.1 填充规则</h2><p>路径可以是闭合的也可以是非闭合的，例如上面的当前位置示例中的路径是非闭合的，但如果为 QPainter 指定了画刷，QPainter 会自动使用一条直线连接该非闭合形状的首尾，使其闭合，进而使用画刷对其填充。</p><p>QPainterPath 有两种填充规则，可以通过<code>QPainterPath::setFillRule</code>方法来设置填充规则：</p><ul><li><p>Qt::OddEvenFill</p><p> 奇偶填充规则，从一点向图形外引一条水平线，该线和图形的边线相交，如果交点的个数为奇数，则该点在图形中。</p></li><li><p>Qt::WindingFill<br>非零弯曲规则，从一点向图形外引一条水平线，该线与图形的边线相交。如果边线是顺时针绘制的，则记为1，如果边线是逆时针绘制的，则记为-1。最后将所有结果相加的和为0则该点在图形中。（矩形和椭圆都按顺时针绘制）</p></li></ul><p><img src="https://blog-static.jiangxueqiao.com/blog/img/9201b1278bef4070ad39deed5a087825.png"></p><h1 id="九、文本"><a href="#九、文本" class="headerlink" title="九、文本"></a>九、文本</h1><p>文字有颜色、字体、样式等属性。</p><p>Qt 不仅可以绘制纯色的文本，还可以使用渐变色、图片等内容来填充文字，比如下面两种方式都可以用来绘制渐变色的文字：</p><ol><li>先将文字转变成路径（参考<code>QPainterPath::addText</code>），然后使用渐变画刷填充该路径。</li><li>直接为 QPen 设置渐变画刷。</li></ol><p>通过为 QPainter 设置 QFont 对象来修改字体，字体有字体族、字号、粗体、斜体、下划线、删除线等样式或效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QFont font;</span><br><span class="line">font.<span class="built_in">setFamilies</span>({<span class="string">"Microsoft YaHei"</span>, <span class="string">"Arial"</span>});  <span class="comment">// 字体族</span></span><br><span class="line">font.<span class="built_in">setPixelSize</span>(<span class="number">26</span>);                  <span class="comment">// 字号</span></span><br><span class="line">font.<span class="built_in">setBold</span>(<span class="literal">true</span>);                     <span class="comment">// 粗体</span></span><br><span class="line">font.<span class="built_in">setItalic</span>(<span class="literal">true</span>);                   <span class="comment">// 斜体</span></span><br><span class="line">font.<span class="built_in">setUnderline</span>(<span class="literal">true</span>);                <span class="comment">// 下划线</span></span><br><span class="line">font.<span class="built_in">setStrikeOut</span>(<span class="literal">true</span>);                <span class="comment">// 删除线</span></span><br><span class="line"></span><br><span class="line">painter.<span class="built_in">setFont</span>(font);</span><br></pre></td></tr></table></figure><p>使用 QPainter::drawText 方法绘制文本，该方法原型有很多种，但大多是通过下面2个原型进行重载而来的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::drawText</span><span class="params">(<span class="type">const</span> QRectF &amp;rectangle, <span class="type">int</span> flags, <span class="type">const</span> QString &amp;text, QRectF *boundingRect = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::drawText</span><span class="params">(<span class="type">const</span> QRectF &amp;rectangle, <span class="type">const</span> QString &amp;text, <span class="type">const</span> QTextOption &amp;option = QTextOption())</span></span></span><br></pre></td></tr></table></figure><h2 id="9-1-间距"><a href="#9-1-间距" class="headerlink" title="9.1 间距"></a>9.1 间距</h2><p>间距分为两种情况：</p><ul><li>每个字符的间距，如单个英文字母或单个汉字的间距，称为 Letter Spacing。</li><li>每个英文单词的间距，称为 Word Spacing。</li></ul><h3 id="9-1-1-单词间距"><a href="#9-1-1-单词间距" class="headerlink" title="9.1.1 单词间距"></a>9.1.1 单词间距</h3><p>使用 QFont::setWordSpacing 和 QFont::wordSpacing 方法设置和获取单词的间距。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QFont::setWordSpacing</span><span class="params">(qreal spacing)</span></span></span><br></pre></td></tr></table></figure><p>当 setWordSpacing 参数大于0时，单词间距增加相应的像素；小于0时，间距减少相应的像素。</p><h3 id="9-1-2-字符间距"><a href="#9-1-2-字符间距" class="headerlink" title="9.1.2 字符间距"></a>9.1.2 字符间距</h3><p>使用 QFont::setLetterSpacing 和 QFont::letterSpacing 方法设置和获取字符的间距。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QFont::setLetterSpacing</span><span class="params">(QFont::SpacingType type, qreal spacing)</span></span></span><br></pre></td></tr></table></figure><p>字符间距支持百分比和绝对值两种设置方法，通过QFont::SpacingType枚举类型指定。</p><ul><li><p>QFont::PercentageSpacing</p><p>百分比方式。值为100时表示不做任何改变，200表示间距扩大到原来的一倍，-200表示间距缩小到原来的一倍。</p></li><li><p>QFont::AbsoluteSpacing</p><p>绝对值方式，与设置单词间距的方式一样。</p></li></ul><h2 id="9-2-小型大写字母"><a href="#9-2-小型大写字母" class="headerlink" title="9.2 小型大写字母"></a>9.2 小型大写字母</h2><p>小型大写字母（英语：small capitals，简称 small caps）是西文字体设计中的一种字符形式。这些字母的形状（字形）和大写字母相同但尺寸较小，比如在表示键盘快捷键的时候也常用小型大写字母。</p><p>在 Qt 中通过设置 QFont 的 Capitalization 样式为 SmallCaps 风格来使用小型大写字母样式，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  QPen pen;</span><br><span class="line">  pen.<span class="built_in">setBrush</span>(Qt::red);</span><br><span class="line">  pen.<span class="built_in">setWidthF</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  QFont font;</span><br><span class="line">  font.<span class="built_in">setPixelSize</span>(<span class="number">26</span>);</span><br><span class="line">  font.<span class="built_in">setCapitalization</span>(QFont::SmallCaps);</span><br><span class="line">                            ^^^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">setFont</span>(font);</span><br><span class="line">  painter.<span class="built_in">drawText</span>(<span class="number">10</span>, <span class="number">30</span>, <span class="string">"The Keyboard Shortcut is Ctrl + Shift + K"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>效果如下图所示（留意全小写的“is”和其他首字母大写的单词）：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/1acIT3tRje-TinyTu.png"></p><p>Capitalization 还支持设置如下风格：</p><ul><li>QFont::MixedCase  默认，不做更改</li><li>QFont::AllUppercase 全部小写</li><li>QFont::AllLowercase 全部大写</li><li>QFont::Capitalize 首字母大写</li></ul><h2 id="9-3-计算绘制文本所需空间"><a href="#9-3-计算绘制文本所需空间" class="headerlink" title="9.3 计算绘制文本所需空间"></a>9.3 计算绘制文本所需空间</h2><p>有两种方式可以计算按指定字体绘制文本所需的空间。</p><p><strong>方式一：使用 QPainter::drawText</strong></p><p>使用如下函数原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::drawText</span><span class="params">(<span class="type">const</span> QRectF &amp;rectangle, <span class="type">int</span> flags, <span class="type">const</span> QString &amp;text, QRectF *boundingRect = <span class="literal">nullptr</span>)</span></span></span><br></pre></td></tr></table></figure><p>将参数 rectangle 的 宽和高都设置为 0，函数会通过 boundingRect 参数返回绘制文本所需要的宽和高。</p><p><strong>方式二：使用 QFontMetricsF</strong></p><p>QFontMetrics 或 QFontMetricsF 可以按照指定字体来计算给定字符和字符串的宽和高。</p><p>这种方式的弊端在于：不能将绘制风格（如居中对齐、多行文本）带入其中进行计算，只能计算给定的单行字符串按照指定的字体显示所需的宽高。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QFont font;</span><br><span class="line">font.<span class="built_in">setPixelSize</span>(<span class="number">36</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">QFontMetricsF <span class="title">fm</span><span class="params">(font)</span></span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fm.<span class="built_in">horizontalAdvance</span>(<span class="string">"Hello World"</span>); <span class="comment">// 字符串所占宽度</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fm.<span class="built_in">height</span>(); <span class="comment">// 字体的高度</span></span><br></pre></td></tr></table></figure><h1 id="十、贴图"><a href="#十、贴图" class="headerlink" title="十、贴图"></a>十、贴图</h1><p>QPainter 提供了 drawPixmap 和 drawImage 两个常用的贴图函数，drawPixmap 用于绘制 QPixmap 对象，而 drawImage 用于绘制 QImage 对象，QImage 与 QPixmap 间是可以相互转化，因此 drawPixmap 和 drawImage 方法的效果是一样的。</p><p>drawPixmap 方法在屏幕上绘制速度更快，而 drawImage 方法则在 QPrinter 和其他设备上绘制的更快。</p><p>需要注意：QPicture 对象用于记录绘制步骤，而 QPainter::drawPicture 方法用于重复 QPicture 对象所记录的步骤。</p><p>drawPixmap 和 drawImage 方法有多个重载的原型，其参数从左到右依次为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标区域 -&gt; QPixmap/QImage -&gt; 源区域</span><br></pre></td></tr></table></figure><p>目标区域会应用当前 QWidget 的 devicePixelRatio，而源区域则与 devicePixelRatio 无关，具体参考 <a href="/post/170290456.html" title="QPixmap使用要点">QPixmap使用要点</a></p><hr><blockquote><p>限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺</p><p>您可以通过在 <a href="https://github.com/winsoft666/blog-comment">blog-comment</a> 项目中提交Issue来间接地发表评论🍀</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Qt 2D 世界中，图形基本都由点、线、矩形、多边形、椭圆、圆、折线、曲线、文本、贴图等基本元素辅以着色而构成，而且 QPainter 类已经提供了这些元素的绘制方法，花点时间掌握这些方法，也就掌握了 Qt 2D图形控件的制作，余下的就是勤学多练、孰能生巧了。&lt;/p&gt;</summary>
    
    
    
    <category term="Qt" scheme="https://jiangxueqiao.com/categories/Qt/"/>
    
    
    <category term="Qt" scheme="https://jiangxueqiao.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>玩转Qt 2D绘图之画家的工具</title>
    <link href="https://jiangxueqiao.com/post/1336811290.html"/>
    <id>https://jiangxueqiao.com/post/1336811290.html</id>
    <published>2024-04-05T12:55:02.000Z</published>
    <updated>2024-05-15T02:04:23.121Z</updated>
    
    <content type="html"><![CDATA[<p>软件是对现实世界的抽象，在设计软件接口时通常也会参考现实世界来进行设计。</p><p>在现实世界中，画家使用画笔、画刷这些工具在宣纸上作画，而在 Qt 中，画家是 QPainter 对象（画家的大脑则是 QPaintEngine），纸张可以是 QPaintDevice 的任何子类对象，如 QWidget、QImage、QPixmap、QGLPixelBuffer 等；在 QPainter 选好纸张后，就可以使用画笔来勾勒物体的轮廓了，Qt 中的画笔是 QPen 对象；画完轮廓后，可能还需要使用画刷来填充轮廓，Qt 中的画刷是 QBrush 对象。</p><span id="more"></span><h1 id="一、QPaintDevice"><a href="#一、QPaintDevice" class="headerlink" title="一、QPaintDevice"></a>一、QPaintDevice</h1><p>本节介绍 QPaintDevice 的几个常用方法。</p><p><strong>devicePixelRatio() 与 devicePixelRatioF()</strong></p><p>用于获取DPI的缩放倍数，需要先在程序中开启DPI缩放特性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QGuiApplication::<span class="built_in">setAttribute</span>(Qt::AA_EnableHighDpiScaling);</span><br><span class="line">    QGuiApplication::<span class="built_in">setAttribute</span>(Qt::AA_UseHighDpiPixmaps);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5, 14, 0))</span></span><br><span class="line">    QGuiApplication::<span class="built_in">setHighDpiScaleFactorRoundingPolicy</span>(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>从 Qt 5.14 版本开始，Qt可以支持小数位的 DPI 缩放，如 1.25、1.75 等。如需获取小数位DPI值，需要先设置<code>Qt::HighDpiScaleFactorRoundingPolicy::PassThrough</code>策略，然后通过 devicePixelRatioF 方法获取。</p><p><strong>width() 与 height()</strong></p><p>用于获取 QPaintDevice 的宽和高，这个数值不会随着坐标系的改变而改变，而且也不会随着 DPI 的改变而改变。</p><p><strong>widthMM() 与 heightMM()</strong></p><p>用于获取 QPaintDevice 在屏幕上实际显示的宽和高，单位为毫米。</p><h1 id="二、QPen"><a href="#二、QPen" class="headerlink" title="二、QPen"></a>二、QPen</h1><p>画笔有宽度（width/widthF）、颜料（brush）、线条样式（Style）、一条线起笔和落笔的样式（CapStyle）、两条线相交处的样式（JoinStyle）等属性。</p><h2 id="2-1-宽度"><a href="#2-1-宽度" class="headerlink" title="2.1 宽度"></a>2.1 宽度</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPen::setWidth</span><span class="params">(<span class="type">int</span> width)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPen::setWidthF</span><span class="params">(qreal width)</span></span></span><br></pre></td></tr></table></figure><p>如果指定的宽度小于 0，将不会绘制任何内容；如果指定的宽度等于 0，将被视为 1 个像素宽度；如果指定的宽度大于等于 1，则按指定的宽度来绘制。</p><h2 id="2-2-QPen的画刷"><a href="#2-2-QPen的画刷" class="headerlink" title="2.2 QPen的画刷"></a>2.2 QPen的画刷</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPen::setBrush</span><span class="params">(<span class="type">const</span> QBrush &amp;brush)</span></span></span><br></pre></td></tr></table></figure><p>QPen 有画刷属性，QPainter 对象也画刷属性（下面章节会介绍），二者都有填充之意，QPen 的画刷是用来填充画笔所画的线条（可以理解为画笔的颜料）的，而QPainter 的画刷是用来填充画笔所画的轮廓区域的，如填充矩形里面的区域。</p><p>画刷可以是纯色、渐变色，也可以是图片。</p><h2 id="2-3-线条样式"><a href="#2-3-线条样式" class="headerlink" title="2.3 线条样式"></a>2.3 线条样式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPen::setStyle</span><span class="params">(Qt::PenStyle style)</span></span></span><br></pre></td></tr></table></figure><p><img src="https://blog-static.jiangxueqiao.com/blog/img/6MkjpX6lBG-TinyTu.png"></p><h2 id="2-4-起落笔样式"><a href="#2-4-起落笔样式" class="headerlink" title="2.4 起落笔样式"></a>2.4 起落笔样式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPen::setCapStyle</span><span class="params">(Qt::PenCapStyle style)</span></span></span><br></pre></td></tr></table></figure><p><img src="https://blog-static.jiangxueqiao.com/blog/img/2IXOuMMzxy-TinyTu.png"></p><h2 id="2-5-拐点样式"><a href="#2-5-拐点样式" class="headerlink" title="2.5 拐点样式"></a>2.5 拐点样式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPen::setJoinStyle</span><span class="params">(Qt::PenJoinStyle style)</span></span></span><br></pre></td></tr></table></figure><p><img src="https://blog-static.jiangxueqiao.com/blog/img/Oc0ypqQqIO-TinyTu.png"></p><h2 id="2-6-实例"><a href="#2-6-实例" class="headerlink" title="2.6 实例"></a>2.6 实例</h2><p>下面示例指定了画笔的如下属性：</p><ul><li>画笔的宽度为 70px</li><li>使用红色画刷</li><li>线条样式为通过若干空格分割的点线状</li><li>线条起笔和落笔处为圆形</li><li>线条拐点处也为圆形</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  QPen pen;</span><br><span class="line">  pen.<span class="built_in">setWidth</span>(<span class="number">70</span>);</span><br><span class="line">  pen.<span class="built_in">setBrush</span>(Qt::red);</span><br><span class="line">  pen.<span class="built_in">setStyle</span>(Qt::DotLine);</span><br><span class="line">  pen.<span class="built_in">setCapStyle</span>(Qt::RoundCap);</span><br><span class="line">  pen.<span class="built_in">setJoinStyle</span>(Qt::RoundJoin);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">drawLine</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">600</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">drawLine</span>(<span class="number">600</span>, <span class="number">50</span>, <span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>实际绘制出来的效果如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/9Vuvj96Gel.png"></p><p>上面画笔使用红色作为颜料，也可以使用渐变色作为颜料，当然还可以使用图片作为颜料。</p><p>下面我们将颜料更改为一个红色的心形♥图片：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  QPen pen;</span><br><span class="line">  pen.<span class="built_in">setWidth</span>(<span class="number">70</span>);</span><br><span class="line">  pen.<span class="built_in">setBrush</span>(<span class="built_in">QImage</span>(<span class="string">":/heart.png"</span>)); <span class="comment">// 仅修改了此行代码</span></span><br><span class="line">                    ~~~~~~~~~~~~~~</span><br><span class="line">  pen.<span class="built_in">setStyle</span>(Qt::DotLine);</span><br><span class="line">  pen.<span class="built_in">setCapStyle</span>(Qt::RoundCap);</span><br><span class="line">  pen.<span class="built_in">setJoinStyle</span>(Qt::RoundJoin);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">drawLine</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">600</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">drawLine</span>(<span class="number">600</span>, <span class="number">50</span>, <span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>绘制的效果如下：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/fGqs5DBAuF.png"></p><h1 id="三、QBrush"><a href="#三、QBrush" class="headerlink" title="三、QBrush"></a>三、QBrush</h1><p>QPen 与 QPainter 都有画刷属性，这里的 QBrush 是指的 QPainter 的画刷。虽然与 QPen 的画刷都为 QBrush 类型，但二者是有区别的，QPen 的画刷是用来填充画笔所画线条（可以理解为画笔的颜料）的，而 QPainter 的画刷是用来填充画笔所画的轮廓所包围的区域，如填充矩形里面的区域。</p><p>如下面示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  QPen pen;</span><br><span class="line">  pen.<span class="built_in">setWidth</span>(<span class="number">6</span>);</span><br><span class="line">  pen.<span class="built_in">setBrush</span>(Qt::red);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">  painter.<span class="built_in">setBrush</span>(Qt::blue);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">drawRect</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>实际绘制的矩形如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/U0528POfgW.png"></p><p>QBrush 有样式（Style）、颜色（Color）、渐变色（Gradient）、纹理图片（Texture）等属性。</p><h2 id="3-1-样式"><a href="#3-1-样式" class="headerlink" title="3.1 样式"></a>3.1 样式</h2><p>画刷的作用是填充区域，画刷的样式则是用来指定通过什么模式来填充区域的。</p><p>下图列出了 QBrush 支持的样式：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/79r3LYbpDc-TinyTu.png"></p><p>QBrush的初始样式是 Qt::NoBrush，即不做填充操作，该值显然是没有任何意义的，下面是一个错误的使用示例；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line">QBrush brush;</span><br><span class="line">brush.<span class="built_in">setColor</span>(Qt::red); <span class="comment">// 画刷仍然是 Qt::NoBrush样式，不会填充任何颜色</span></span><br></pre></td></tr></table></figure><p>我们可以通过构造函数和 setStyle 方法来设置样式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">QBrush</span>(Qt::BrushStyle style)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setStyle</span><span class="params">(Qt::BrushStyle style)</span></span></span><br></pre></td></tr></table></figure><p>当通过不同的方式构造 QBrush 对象时，QBrush 的样式也会自动被设置为不同的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 样式自动被设置为渐变样式：Qt::LinearGradientPattern, Qt::RadialGradientPattern 或 Qt::ConicalGradientPattern</span></span><br><span class="line"><span class="built_in">QBrush</span>(<span class="type">const</span> QGradient &amp;gradient) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 样式自动被设置为纹理样式Qt::TexturePattern</span></span><br><span class="line"><span class="built_in">QBrush</span>(<span class="type">const</span> QImage &amp;image)          </span><br><span class="line"><span class="built_in">QBrush</span>(<span class="type">const</span> QPixmap &amp;pixmap)</span><br><span class="line"><span class="built_in">QBrush</span>(Qt::GlobalColor color, <span class="type">const</span> QPixmap &amp;pixmap)</span><br><span class="line"><span class="built_in">QBrush</span>(<span class="type">const</span> QColor &amp;color, <span class="type">const</span> QPixmap &amp;pixmap)</span><br></pre></td></tr></table></figure><h2 id="3-2-纹理图片"><a href="#3-2-纹理图片" class="headerlink" title="3.2 纹理图片"></a>3.2 纹理图片</h2><p>上面2.6节的实例中，在设置心形图片作为QPen的画刷时，使用的就是纹理图片。</p><p>下面汇总了设置 QBrush 纹理图片的几种方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过构造函数</span></span><br><span class="line"><span class="built_in">QBrush</span>(<span class="type">const</span> QImage &amp;image)</span><br><span class="line"><span class="built_in">QBrush</span>(<span class="type">const</span> QPixmap &amp;pixmap)</span><br><span class="line"><span class="built_in">QBrush</span>(Qt::GlobalColor color, <span class="type">const</span> QPixmap &amp;pixmap)</span><br><span class="line"><span class="built_in">QBrush</span>(<span class="type">const</span> QColor &amp;color, <span class="type">const</span> QPixmap &amp;pixmap)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过成员方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTexture</span><span class="params">(<span class="type">const</span> QPixmap &amp;pixmap)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTextureImage</span><span class="params">(<span class="type">const</span> QImage &amp;image)</span></span></span><br></pre></td></tr></table></figure><p>通过上面方式设置纹理图片后，QBrush 样式会被自动修改为 Qt::TexturePattern，因为纹理图片只能与 Qt::TexturePattern 样式配合使用，否则纹理图片将失效。</p><h2 id="3-3-纯色"><a href="#3-3-纯色" class="headerlink" title="3.3 纯色"></a>3.3 纯色</h2><p>可以为画刷指定纯色或渐变色，纯色使用 QColor 对象表示。</p><p>常用的构造 QColor 对象的方式有如下几种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">QColor</span>(<span class="string">"#FFFFFF"</span>); <span class="comment">//  r g b</span></span><br><span class="line"><span class="built_in">QColor</span>(<span class="string">"#AAFFFFFF"</span>); <span class="comment">// a r g b</span></span><br><span class="line"><span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>); <span class="comment">// r g b a</span></span><br><span class="line"><span class="built_in">QColor</span>(Qt::red); <span class="comment">// Qt::GlobalColor 枚举值</span></span><br></pre></td></tr></table></figure><h2 id="3-4-渐变色"><a href="#3-4-渐变色" class="headerlink" title="3.4 渐变色"></a>3.4 渐变色</h2><p>QBrush 只提供了一种方式来指定渐变色：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">QBrush</span>(<span class="type">const</span> QGradient &amp;gradient)</span><br></pre></td></tr></table></figure><p>在Qt中，渐变色使用 QGradient 及其子类表示，目前Qt支持三种类型的渐变：</p><ul><li>线性渐变，对应 QLinearGradient 类。</li><li>锥形渐变，对应 QConicalGradient 类。</li><li>径向渐变，又分为简单径向渐变和扩展径向渐变，二者都对应 QRadialGradient 类。</li></ul><p>下图是一个从左到右，由白到黑的渐变过程：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/white-black-jianbian-TinyTu.png"></p><p>填充方向既然可以从左到右、从右到左的、从里到外，是可以360度旋转等等，不同的填充方向造就了不同类型的渐变，上述三种类型的渐变主要区别也在填充方向的不同。</p><h3 id="3-4-1-线性渐变"><a href="#3-4-1-线性渐变" class="headerlink" title="3.4.1 线性渐变"></a>3.4.1 线性渐变</h3><p>QLinearGradient 构造函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">QLinearGradient</span>(qreal x1, qreal y1, qreal x2, qreal y2)</span><br><span class="line"><span class="built_in">QLinearGradient</span>(<span class="type">const</span> QPointF &amp;start, <span class="type">const</span> QPointF &amp;finalStop)</span><br></pre></td></tr></table></figure><p>通过指定一个起点和一个终点就可以确定一条线段的长度及方向，这个方向就是填充方向，渐变范围基于该长度而确定（详见后面的“渐变范围”章节）。</p><p>线性渐变的方向可以是水平的，也可以是垂直的，还可以是斜着的，具体方向由线段与X轴的夹角来决定。</p><p>下面我们定义一个起点为(0,0)、终点为(0,400)，垂直方向的线性渐变，然后使用该渐变填充位置在 (0,0)，宽高为 200x400 的矩形（请注意矩形的位置和大小，这个与渐变的起止位置有关，后面会详细介绍）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  <span class="function">QLinearGradient <span class="title">linearGrad</span><span class="params">(QPointF(<span class="number">0</span>, <span class="number">0</span>), QPointF(<span class="number">0</span>, <span class="number">400</span>))</span></span>;</span><br><span class="line">  linearGrad.<span class="built_in">setColorAt</span>(<span class="number">0</span>, Qt::black);</span><br><span class="line">  linearGrad.<span class="built_in">setColorAt</span>(<span class="number">1</span>, Qt::white);</span><br><span class="line"></span><br><span class="line">  <span class="function">QBrush <span class="title">brush</span><span class="params">(linearGrad)</span></span>;</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">drawRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">400</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>效果如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/9ySVUiYR7i.png"></p><p>由于是垂直方面的渐变，所以渐变色从上到下变化的，颜色起始于黑色，终止于白色。</p><p>渐变色的起止颜色由<code>setColorAt</code>方法设置，该方法原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGradient::setColorAt</span><span class="params">(qreal position, <span class="type">const</span> QColor &amp;color)</span></span></span><br></pre></td></tr></table></figure><p>setColorAt 不仅接受颜色参数，还支持 postion 参数，position 参数的范围是<code>[0,1]</code>。线性渐变通过起止位置确定了一条带方向的线段，而 position 参数则用于确定线段上的一个<strong>具体位置</strong>，结合position和color参数就可以表示在某一位置的颜色值。</p><p>可以使用 setColorAt 方法指定多个在<code>[0,1]</code>之间的位置及该位置的颜色，Qt会自动在多个颜色之间插入过渡色，达到平滑过渡的效果。</p><p>现在我们在 0.3 位置插入一个骚气的红色，0.5位置插入黄色，其他都保持不变：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linearGrad.<span class="built_in">setColorAt</span>(<span class="number">0</span>, Qt::black);</span><br><span class="line">linearGrad.<span class="built_in">setColorAt</span>(<span class="number">0.3</span>, Qt::red);</span><br><span class="line">linearGrad.<span class="built_in">setColorAt</span>(<span class="number">0.8</span>, Qt::yellow);</span><br><span class="line">linearGrad.<span class="built_in">setColorAt</span>(<span class="number">1</span>, Qt::white);</span><br></pre></td></tr></table></figure><p>效果如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/mZ2gN4GO0n.png"></p><h3 id="3-4-2-渐变范围"><a href="#3-4-2-渐变范围" class="headerlink" title="3.4.2 渐变范围"></a>3.4.2 渐变范围</h3><p>在上面一节，我们强调了所绘制的矩形的位置/大小与渐变的起止位置有关，而且又强调了 position 参数所确定是线段上的具体位置。<strong>其根本原因就在于渐变是有位置和范围的。</strong></p><p>对于线性渐变而言，渐变的范围是起始点和终止点间的线段，但颜色在垂直于该线段的方向却是无限扩充的，下面示例可以很好的说明这一特性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Qt2DSample窗口长宽为600x600</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  <span class="function">QLinearGradient <span class="title">linearGrad</span><span class="params">(QPointF(<span class="number">150</span>, <span class="number">150</span>), QPointF(<span class="number">450</span>, <span class="number">450</span>))</span></span>;</span><br><span class="line">  linearGrad.<span class="built_in">setColorAt</span>(<span class="number">0</span>, Qt::yellow);</span><br><span class="line">  linearGrad.<span class="built_in">setColorAt</span>(<span class="number">0.5</span>, Qt::red);</span><br><span class="line">  linearGrad.<span class="built_in">setColorAt</span>(<span class="number">1</span>, Qt::white);</span><br><span class="line"></span><br><span class="line">  <span class="function">QBrush <span class="title">brush</span><span class="params">(linearGrad)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line">  painter.<span class="built_in">drawRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不使用画刷，绘制 左上角 -&gt; 右下角 为线性渐变起止点的矩形</span></span><br><span class="line">  painter.<span class="built_in">setBrush</span>(Qt::NoBrush);</span><br><span class="line">  painter.<span class="built_in">drawRect</span>(<span class="number">150</span>, <span class="number">150</span>, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>效果如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/x7tCsdiv7V-TinyTu.png"></p><p>从上图可以看到，渐变色在垂直于渐变线段（中间矩形的左上角和右下角连成的斜线）方向无限扩展，但为什么在渐变范围边界以外还有颜色呢？如左上角的黄色和右下角的白色，这个与渐变的另一个属性特性有关 – 渐变传播，后面章节有详细介绍。</p><h3 id="3-4-3-锥向渐变"><a href="#3-4-3-锥向渐变" class="headerlink" title="3.4.3 锥向渐变"></a>3.4.3 锥向渐变</h3><p>QConicalGradient 类的构造函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">QConicalGradient</span>(qreal cx, qreal cy, qreal angle)</span><br><span class="line"><span class="built_in">QConicalGradient</span>(<span class="type">const</span> QPointF &amp;center, qreal angle)</span><br></pre></td></tr></table></figure><p>锥向渐变通过中心点（center）和起始角度来（angle）来所连接的直线确定填充的初始方向，然后从该直线开始逆时针进行360度填充，而且每个角度的颜色都是无限向外传播的。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/DpOba08BDf-TinyTu.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Qt2DSample窗口长宽为200x200</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设定中心点刚好在窗口中心，起始角度为45度</span></span><br><span class="line">  <span class="function">QConicalGradient <span class="title">conicalGrad</span><span class="params">(QPointF(<span class="number">100</span>, <span class="number">100</span>), <span class="number">45</span>)</span></span>;</span><br><span class="line">  conicalGrad.<span class="built_in">setColorAt</span>(<span class="number">0</span>, Qt::yellow);</span><br><span class="line">  conicalGrad.<span class="built_in">setColorAt</span>(<span class="number">0.5</span>, Qt::red);</span><br><span class="line">  conicalGrad.<span class="built_in">setColorAt</span>(<span class="number">1</span>, Qt::white);</span><br><span class="line"></span><br><span class="line">  <span class="function">QBrush <span class="title">brush</span><span class="params">(conicalGrad)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绘制的矩形区域为整个窗口大小</span></span><br><span class="line">  painter.<span class="built_in">drawRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>效果如下图所示，渐变色从45度开始渐变，并且每个角度都无限向外传播，填充满了整个矩形：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/iXtwdxzf8d-TinyTu.png"></p><h3 id="3-4-5-径向渐变"><a href="#3-4-5-径向渐变" class="headerlink" title="3.4.5 径向渐变"></a>3.4.5 径向渐变</h3><p>径向渐变分为简单径向渐变和扩展径向渐变，在介绍二者的不同之前，我们先看看QRadialGradient 类的构造函数可以大致分为以下三类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定中心点、半径、焦点位置、焦半径</span></span><br><span class="line"><span class="built_in">QRadialGradient</span>(<span class="type">const</span> QPointF &amp;center, qreal centerRadius, <span class="type">const</span> QPointF &amp;focalPoint, qreal focalRadius)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅指定中心点、半径，此时焦点位置与中心点重合</span></span><br><span class="line"><span class="built_in">QRadialGradient</span>(<span class="type">const</span> QPointF &amp;center, qreal radius)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定中心点、半径、焦点位置</span></span><br><span class="line"><span class="built_in">QRadialGradient</span>(<span class="type">const</span> QPointF &amp;center, qreal radius, <span class="type">const</span> QPointF &amp;focalPoint)</span><br></pre></td></tr></table></figure><ul><li><p>中心点（center）和半径（centerRadius）组成了一个圆，记为圆A，径向渐变的范围只限于圆A以内，圆A以外的区域按照指定的渐变传播方式进行传播；</p></li><li><p>焦点（focalPoint）为平面上的的一个点，简单径向渐变和扩展径向渐变对焦点的位置有不同的要求，这个区别在后面会介绍；</p></li><li><p>焦半径（focalRadius）则是围绕焦点所作的另外一个圆（记为圆B）的半径。</p></li></ul><p>扩展径向渐变是在简单径向渐变的基础上额外使用了 <code>focalRadius</code>（焦点半径）这个参数。</p><h4 id="简单径向渐变"><a href="#简单径向渐变" class="headerlink" title="简单径向渐变"></a>简单径向渐变</h4><p>焦点和圆A圆弧上的每一个点都可以组成一条线段，如果按照1度取一个点，就有360个线段，简单径向渐变就是对这360个线段都进行线性渐变。</p><p>对于简单径向渐变而言，允许焦点位于圆弧上和圆外，如果焦点位于圆外，会自动将其退缩到圆弧上。</p><p>下面是一个简单径向渐变的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Qt2DSample窗口长宽为600x600</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 焦点位于圆内右上角部分</span></span><br><span class="line">  <span class="function">QRadialGradient <span class="title">radialGrad</span><span class="params">(QPointF(<span class="number">300</span>, <span class="number">300</span>), <span class="number">200</span>, QPointF(<span class="number">400</span>, <span class="number">200</span>))</span></span>;</span><br><span class="line">  radialGrad.<span class="built_in">setColorAt</span>(<span class="number">0</span>, Qt::white);</span><br><span class="line">  radialGrad.<span class="built_in">setColorAt</span>(<span class="number">1</span>, Qt::black);</span><br><span class="line"></span><br><span class="line">  <span class="function">QBrush <span class="title">brush</span><span class="params">(radialGrad)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">drawRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>效果如下图所示，径向渐变的范围只限于圆内，圆外的区域默认采用PadSpread方式传播：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/WUJFKPJWPc.png"></p><h4 id="扩展径向渐变"><a href="#扩展径向渐变" class="headerlink" title="扩展径向渐变"></a>扩展径向渐变</h4><p>扩展径向渐变使用焦点和焦半径又组成了一个圆B，与简单径向渐变类似，也是通过对圆A圆弧上的每个点的连线做线性渐变来实现，但这次不是焦点与圆A圆弧上的点进行连线，而是“圆B圆弧上的点”与“圆A圆弧上的点”的连线，对这些连线做线性渐变。</p><p>圆B始终填充起始颜色。</p><p>与简单径向渐变不同的是，圆B必须完全在圆A里面。</p><p>下面是一个扩展径向渐变的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Qt2DSample窗口长宽为600x600</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 焦点位于圆内右上角部分，焦半径为30</span></span><br><span class="line">  <span class="function">QRadialGradient <span class="title">radialGrad</span><span class="params">(QPointF(<span class="number">300</span>, <span class="number">300</span>), <span class="number">200</span>, QPointF(<span class="number">400</span>, <span class="number">200</span>), <span class="number">30</span>)</span></span>;</span><br><span class="line">  radialGrad.<span class="built_in">setColorAt</span>(<span class="number">0</span>, Qt::white);</span><br><span class="line">  radialGrad.<span class="built_in">setColorAt</span>(<span class="number">1</span>, Qt::black);</span><br><span class="line"></span><br><span class="line">  <span class="function">QBrush <span class="title">brush</span><span class="params">(radialGrad)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">drawRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>效果如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/cJLzQWuNsj.png"></p><h3 id="3-4-6-渐变传播"><a href="#3-4-6-渐变传播" class="headerlink" title="3.4.6 渐变传播"></a>3.4.6 渐变传播</h3><p>在Qt中通过 setSpread 方法设置渐变传播方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGradient::setSpread</span><span class="params">(QGradient::Spread method)</span></span></span><br></pre></td></tr></table></figure><p>QGradient::Spread枚举定义了三种传播方式：</p><ul><li>QGradient::PadSpread</li><li>QGradient::RepeatSpread</li><li>QGradient::ReflectSpread</li></ul><p>默认为传播方式为 QGradient::PadSpread，而且由锥向渐变的行为可知，锥向渐变是没有渐变传播一说的，因此它始终都是360度渐变。</p><p>下图形象说明了三种传播方式的差异：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/d4e6a2aa3e0b98bb2bacb9ea40d6185e.png"></p><ul><li>PadSpread 方式延续了起点与终点处各自的颜色，无限传播</li><li>RepeatSpread 方式不断重复渐变边界内的这一颜色的渐变模式</li><li>ReflectSpread 方式将渐变边界内的模式不断往外镜像反射</li></ul><h3 id="3-4-7-渐变主题"><a href="#3-4-7-渐变主题" class="headerlink" title="3.4.7 渐变主题"></a>3.4.7 渐变主题</h3><p>设计一个漂亮的渐变色并非易事，Qt提供了内置的渐变主题(Preset)，这些主题通过 QGradient::Preset 枚举类型提供（该枚举从 Qt 5.12 开始引入）。</p><blockquote><p>从Qt官方文档得知，QGradient::Preset预置渐变主题方案是基于<a href="https://webgradients.com/">https://webgradients.com/</a>实现的。</p></blockquote><p>QGradient 类支持通过QGradient::Preset 枚举类型直接构造：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QGradient::<span class="built_in">QGradient</span>(QGradient::Preset preset)</span><br></pre></td></tr></table></figure><p>下面是使用QGradient::Preset的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qt2DSample::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);</span><br><span class="line"></span><br><span class="line">  <span class="function">QGradient <span class="title">grad</span><span class="params">(QGradient::HealthyWater)</span></span>;</span><br><span class="line">  <span class="function">QBrush <span class="title">brush</span><span class="params">(grad)</span></span>;</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line"></span><br><span class="line">  painter.<span class="built_in">drawRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="3-4-8-网站推荐"><a href="#3-4-8-网站推荐" class="headerlink" title="3.4.8 网站推荐"></a>3.4.8 网站推荐</h3><p>下面几个网站也提供了漂亮的渐变色方案，可以用作参考：</p><ul><li><a href="https://www.grabient.com/">grabient.com</a></li><li><a href="https://uigradients.com/">uigradients.com</a></li><li><a href="https://webgradients.com/">webgradients.com</a></li></ul><hr><blockquote><p>限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺</p><p>您可以通过在 <a href="https://github.com/winsoft666/blog-comment">blog-comment</a> 项目中提交Issue来间接地发表评论🍀</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;软件是对现实世界的抽象，在设计软件接口时通常也会参考现实世界来进行设计。&lt;/p&gt;
&lt;p&gt;在现实世界中，画家使用画笔、画刷这些工具在宣纸上作画，而在 Qt 中，画家是 QPainter 对象（画家的大脑则是 QPaintEngine），纸张可以是 QPaintDevice 的任何子类对象，如 QWidget、QImage、QPixmap、QGLPixelBuffer 等；在 QPainter 选好纸张后，就可以使用画笔来勾勒物体的轮廓了，Qt 中的画笔是 QPen 对象；画完轮廓后，可能还需要使用画刷来填充轮廓，Qt 中的画刷是 QBrush 对象。&lt;/p&gt;</summary>
    
    
    
    <category term="Qt" scheme="https://jiangxueqiao.com/categories/Qt/"/>
    
    
    <category term="Qt" scheme="https://jiangxueqiao.com/tags/Qt/"/>
    
  </entry>
  
</feed>
