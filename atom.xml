<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>独钓寒江雪</title>
  
  
  <link href="https://jiangxueqiao.com/atom.xml" rel="self"/>
  
  <link href="https://jiangxueqiao.com/"/>
  <updated>2025-10-22T09:53:28.461Z</updated>
  <id>https://jiangxueqiao.com/</id>
  
  <author>
    <name>江雪桥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>x86架构常用寄存器及汇编指令</title>
    <link href="https://jiangxueqiao.com/post/470495318.html"/>
    <id>https://jiangxueqiao.com/post/470495318.html</id>
    <published>2025-10-22T08:31:00.000Z</published>
    <updated>2025-10-22T09:53:28.461Z</updated>
    
    <content type="html"><![CDATA[<p>x86架构作为个人计算机和服务器领域的主流计算架构，其汇编语言是理解计算机底层运行机制、进行逆向工程、性能优化及嵌入式开发的核心基础。本文将系统梳理x86架构中的常用寄存器​和常用汇编指令​，并结合实际应用场景说明其作用。</p><span id="more"></span><h1 id="x86常用寄存器（Registers）"><a href="#x86常用寄存器（Registers）" class="headerlink" title="x86常用寄存器（Registers）"></a>x86常用寄存器（Registers）</h1><p>寄存器是CPU内部的高速存储单元，用于临时存放数据、地址或控制信息。x86寄存器按功能可分为通用寄存器、段寄存器、标志寄存器、指令指针、控制寄存器、调试寄存器及浮点&#x2F;SIMD寄存器等类别。</p><h2 id="通用寄存器（General-Purpose-Registers-GPRs）"><a href="#通用寄存器（General-Purpose-Registers-GPRs）" class="headerlink" title="通用寄存器（General-Purpose Registers, GPRs）"></a>通用寄存器（General-Purpose Registers, GPRs）</h2><p>通用寄存器是最常用的寄存器，支持数据存储、算术运算、内存寻址及栈操作等功能。根据架构位宽（16&#x2F;32&#x2F;64位）扩展，以下为核心寄存器：</p><h3 id="32位通用寄存器（EAX-EBP-ESP）"><a href="#32位通用寄存器（EAX-EBP-ESP）" class="headerlink" title="32位通用寄存器（EAX-EBP&#x2F;ESP）"></a>32位通用寄存器（EAX-EBP&#x2F;ESP）</h3><table><thead><tr><th>缩写</th><th>英文全程</th><th>功能描述</th></tr></thead><tbody><tr><td>EAX</td><td>Extended Accumulator Reister</td><td>累加器，用于算术运算（如ADD、MUL）、函数返回值存储（如C语言eax存返回值）；高16位为AX，低8位AL，高8位AH。</td></tr><tr><td>EBX</td><td>Extended Base Register</td><td>基址寄存器，常用作内存访问的基地址（如数组索引），支持相对寻址（[ebx+offset]）；高16位BX，低8位BL，高8位BH。</td></tr><tr><td>ECX</td><td>Extended Counter Register</td><td>计数器，用于循环计数（如LOOP指令自动递减ECX）或字符串操作重复次数（REP MOVSB）；高16位CX，低8位CL（位移量常用）。</td></tr><tr><td>EDX</td><td>Extended Data Register</td><td>数据寄存器，与EAX配合完成大数运算（如32位MUL EDX:EAX得64位结果）；高16位DX，低8位DL，高8位DH。</td></tr><tr><td>ESI</td><td>Extended Source Index Register</td><td>源变址寄存器</td></tr><tr><td>EDI</td><td>Extended Distination Index Register</td><td>目的变址寄存器</td></tr><tr><td>EBP</td><td>Extended Base Pointer Register</td><td>基指针寄存器，指向当前栈帧基地址（[ebp+8]访问函数第一个参数）；高16位BP，无8位模式。</td></tr><tr><td>ESP</td><td>Extended Stack Pointer Register</td><td>栈指针寄存器，指向当前栈顶地址，随PUSH&#x2F;POP&#x2F;CALL自动调整；高16位SP，无8位模式。</td></tr></tbody></table><h3 id="64位通用寄存器（RAX-R15）"><a href="#64位通用寄存器（RAX-R15）" class="headerlink" title="64位通用寄存器（RAX-R15）"></a>64位通用寄存器（RAX-R15）</h3><p>x86-64（AMD64）扩展了8个64位寄存器（RAX-RDI）及新增8个（R8-R15），低32位兼容32位寄存器：</p><table><thead><tr><th>缩写</th><th>功能描述</th></tr></thead><tbody><tr><td>RAX ~ RDI</td><td>64位版本，低32位为EAX-EDI，用于64位运算或存储更大范围数据。</td></tr><tr><td>R8 ~ R15</td><td>新增寄存器，低32位为R8D-R15D，常用于64位模式函数参数传递（如Linux 64位前6个参数用RDI&#x2F;RSI&#x2F;RDX&#x2F;RCX&#x2F;R8&#x2F;R9）。</td></tr></tbody></table><h2 id="段寄存器（Segment-Registers）"><a href="#段寄存器（Segment-Registers）" class="headerlink" title="段寄存器（Segment Registers）"></a>段寄存器（Segment Registers）</h2><p>段寄存器存储内存段的基地址或选择子，在实模式和保护模式下作用不同：</p><h3 id="实模式（16位，如DOS）"><a href="#实模式（16位，如DOS）" class="headerlink" title="实模式（16位，如DOS）"></a>实模式（16位，如DOS）</h3><p>通过“段地址×16 + 偏移地址”计算20位物理地址：</p><h3 id="保护模式-长模式（32-64位）"><a href="#保护模式-长模式（32-64位）" class="headerlink" title="保护模式&#x2F;长模式（32&#x2F;64位）"></a>保护模式&#x2F;长模式（32&#x2F;64位）</h3><p>存储段选择子（16位），指向全局描述符表（GDT）&#x2F;局部描述符表（LDT）中的段描述符：</p><table><thead><tr><th>缩写</th><th>英文全程</th><th>功能描述</th></tr></thead><tbody><tr><td>CS</td><td>Code Segment Register</td><td>代码段寄存器</td></tr><tr><td>DS</td><td>Data Segment Register</td><td>数据段寄存器</td></tr><tr><td>ES</td><td>Extra Segment Register</td><td>附加段寄存器</td></tr><tr><td>SS</td><td>Stack Segment Register</td><td>栈段寄存器</td></tr><tr><td>FS</td><td>无严格全称</td><td></td></tr><tr><td>GS</td><td>无严格全称</td><td></td></tr></tbody></table><h2 id="标志寄存器（Flags-Registers）"><a href="#标志寄存器（Flags-Registers）" class="headerlink" title="标志寄存器（Flags Registers）"></a>标志寄存器（Flags Registers）</h2><p>记录运算状态或控制CPU行为，32位为EFLAGS，64位为RFLAGS（低32位兼容EFLAGS）。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/huibian-flags-register.png"></p><table><thead><tr><th>缩写</th><th>英文全程</th><th>功能描述</th></tr></thead><tbody><tr><td>CF</td><td>Carry Flag</td><td>进位标志</td></tr><tr><td>PF</td><td>Parity Flag</td><td>奇偶标志，结果低8位中1的个数为偶数时置1（用于校验）</td></tr><tr><td>AF</td><td>Auxiliary Carry Flag</td><td>辅助进位标志</td></tr><tr><td>ZF</td><td>Zero Flag</td><td>运算结果为0时置1（如CMP EAX, EBX后ZF&#x3D;1，表示EAX&#x3D;&#x3D;EBX）</td></tr><tr><td>SF</td><td>Sign Flag</td><td>结果最高位（符号位）为1时置1（表示负数）</td></tr><tr><td>TF</td><td>Trap Flag</td><td>置1时CPU进入单步调试模式（每条指令后触发中断）</td></tr><tr><td>IF</td><td>Interrupt Enable Flag</td><td>置1时允许外部可屏蔽中断（INTR）</td></tr><tr><td>DF</td><td>Direction Flag</td><td>控制字符串操作指针增减（CLD清零→递增；STD置1→递减）</td></tr><tr><td>OF</td><td>Overflow Flag</td><td>有符号运算溢出（如8位加法结果超-128~127）</td></tr></tbody></table><h2 id="指令指针寄存器（Instruction-Pointer-Registers）"><a href="#指令指针寄存器（Instruction-Pointer-Registers）" class="headerlink" title="指令指针寄存器（Instruction Pointer Registers）"></a>指令指针寄存器（Instruction Pointer Registers）</h2><table><thead><tr><th>缩写</th><th>英文全称</th><th>功能描述</th></tr></thead><tbody><tr><td>EIP</td><td>Extended Instruction Pointer</td><td>32位指令指针，存储下一条要执行的指令地址（程序计数器）。</td></tr><tr><td>RIP</td><td>Instruction Pointer (64-bit)</td><td>64位指令指针，存储下一条指令地址（R表示64位扩展）。</td></tr></tbody></table><h1 id="x86常用汇编指令（Instructions）"><a href="#x86常用汇编指令（Instructions）" class="headerlink" title="x86常用汇编指令（Instructions）"></a>x86常用汇编指令（Instructions）</h1><p>指令按功能分为数据传输、算术运算、逻辑操作、移位、比较与跳转等类别。多数指令会修改标志寄存器（如CF、ZF），少数例外（如PUSHF）。</p><h2 id="数据传输指令（Data-Transfer-Instructions）"><a href="#数据传输指令（Data-Transfer-Instructions）" class="headerlink" title="数据传输指令（Data Transfer Instructions）"></a>数据传输指令（Data Transfer Instructions）</h2><p>功能​：寄存器、内存或I&#x2F;O端口间数据移动，​通常不影响标志寄存器。</p><table><thead><tr><th>指令缩写</th><th>英文全称</th><th>功能描述</th><th>影响标志</th></tr></thead><tbody><tr><td>MOV</td><td>Move</td><td>寄存器&#x2F;内存与寄存器&#x2F;立即数传数据（如<code>MOV EAX, 1</code>）。</td><td>无</td></tr><tr><td>XCHG</td><td>Exchange</td><td>交换两个寄存器或寄存器与内存内容（如<code>XCHG EAX, EBX</code>）。</td><td>无</td></tr><tr><td>PUSH</td><td>Push onto Stack</td><td>操作数压入栈（ESP&#x2F;SP递减，如<code>PUSH EAX</code>）。</td><td>无（除非操作数是标志寄存器）</td></tr><tr><td>POP</td><td>Pop from Stack</td><td>从栈顶弹出数据到操作数（ESP&#x2F;SP递增，如<code>POP EBX</code>）。</td><td>无（除非操作数是标志寄存器）</td></tr><tr><td>LEA</td><td>Load Effective Address</td><td>加载有效地址到寄存器（计算地址但不访问内存，如<code>LEA EAX, [EBX+4]</code>）。</td><td>无</td></tr><tr><td>PUSHF(Push Flags)</td><td>Push Flags onto Stack</td><td>将标志寄存器（EFLAGS&#x2F;RFLAGS）压栈（如<code>PUSHF</code>）。</td><td>无</td></tr><tr><td>POPF(Pop Flags)</td><td>Pop Flags from Stack</td><td>从栈弹出数据到标志寄存器（直接修改所有标志，慎用！如<code>POPF</code>）。</td><td>修改所有标志</td></tr></tbody></table><h2 id="算术运算指令（Arithmetic-Instructions）"><a href="#算术运算指令（Arithmetic-Instructions）" class="headerlink" title="算术运算指令（Arithmetic Instructions）"></a>算术运算指令（Arithmetic Instructions）</h2><p>功能：加减乘除或带进位运算，<strong>显著修改状态标志</strong>（CF、ZF、OF等）。</p><table><thead><tr><th>指令缩写</th><th>英文全称</th><th>功能描述</th><th>影响标志</th></tr></thead><tbody><tr><td>ADD</td><td>Add</td><td>加法（dst &#x3D; dst + src，如<code>ADD EAX, EBX</code>）。</td><td>CF、ZF、OF、SF、PF、AF</td></tr><tr><td>SUB</td><td>Subtract</td><td>减法（dst &#x3D; dst - src，如<code>SUB ECX, 10</code>）。</td><td>同ADD</td></tr><tr><td>ADC</td><td>Add with Carry</td><td>带进位加法（dst &#x3D; dst + src + CF，如<code>ADC EDX, EAX</code>）。</td><td>同ADD</td></tr><tr><td>INC</td><td>Increment</td><td>加1（dst &#x3D; dst + 1，如<code>INC ESI</code>）。</td><td>ZF、OF、SF、PF（<strong>不影响CF</strong>）</td></tr><tr><td>MUL</td><td>Unsigned Multiply</td><td>无符号乘法（AL<em>r&#x2F;m8→AX；EAX</em>r&#x2F;m32→EDX:EAX）。</td><td>CF&#x3D;1或OF&#x3D;1（结果超寄存器宽度时置1，否则清零）；其他标志无定义</td></tr><tr><td>DIV</td><td>Unsigned Divide</td><td>无符号除法（被除数在AX&#x2F;EDX:EAX，商→AL&#x2F;EAX，余数→AH&#x2F;EDX）。</td><td>除数为0或商溢出时触发#DE异常；标志无定义</td></tr></tbody></table><h2 id="逻辑操作指令（Logical-Instructions）"><a href="#逻辑操作指令（Logical-Instructions）" class="headerlink" title="逻辑操作指令（Logical Instructions）"></a>逻辑操作指令（Logical Instructions）</h2><p>功能：按位与、或、异或等操作，<strong>影响ZF、SF、PF，清除CF&#x2F;OF</strong>。</p><table><thead><tr><th>指令缩写</th><th>英文全称</th><th>功能描述</th><th>影响标志</th></tr></thead><tbody><tr><td>AND</td><td>And</td><td>按位与（dst &#x3D; dst &amp; src，如<code>AND EDX, 0xFF</code>）。</td><td>ZF、SF、PF；<strong>CF&#x3D;0，OF&#x3D;0</strong></td></tr><tr><td>OR</td><td>Or</td><td>按位或（dst &#x3D; dst | src，如<code>OR EAX, 1</code>）。</td><td>同AND</td></tr><tr><td>XOR</td><td>Exclusive Or</td><td>按位异或（dst &#x3D; dst ^ src，如<code>XOR ECX, ECX</code>清零ECX）。</td><td>同AND</td></tr><tr><td>TEST</td><td>Test</td><td>测试位（dst &amp; src，不保存结果，如<code>TEST EAX, 0x80</code>检查最高位）。</td><td>同AND</td></tr></tbody></table><h2 id="移位与循环移位指令（Shift-Rotate-Instructions）"><a href="#移位与循环移位指令（Shift-Rotate-Instructions）" class="headerlink" title="移位与循环移位指令（Shift &amp; Rotate Instructions）"></a>移位与循环移位指令（Shift &amp; Rotate Instructions）</h2><p>功能：左移、右移或循环移位，<strong>影响CF、OF（单次移位）或ZF、SF、PF（多次移位）</strong>。</p><table><thead><tr><th>指令缩写</th><th>英文全称</th><th>功能描述</th><th>影响标志</th></tr></thead><tbody><tr><td>SHL</td><td>Shift Left Logical</td><td>逻辑左移（高位丢弃，低位补0，如<code>SHL EAX, 1</code>）。</td><td>单次：CF&#x3D;移出的最高位；ZF&#x2F;SF&#x2F;PF；OF&#x3D;符号位是否改变<br/>多次：CF&#x3D;最后移出的位；OF无定义</td></tr><tr><td>SHR</td><td>Shift Right Logical</td><td>逻辑右移（低位丢弃，高位补0，如<code>SHR EBX, 2</code>）。</td><td>同SHL</td></tr><tr><td>SAR</td><td>Shift Right Arithmetic</td><td>算术右移（低位丢弃，高位补符号位，如<code>SAR ECX, 1</code>保持符号）。</td><td>同SHL</td></tr><tr><td>ROL</td><td>Rotate Left</td><td>循环左移（高位移到低位，如<code>ROL EDX, 3</code>）。</td><td>单次：CF&#x3D;移出的最高位；<br/>多次：CF&#x3D;最后移出的位；OF无定义</td></tr><tr><td>RCL</td><td>Rotate Left with Carry</td><td>带进位循环左移（CF参与，最高位→CF→最低位，如<code>RCL EAX, 1</code>）。</td><td>单次：CF&#x3D;移出的最高位；<br/>多次：CF&#x3D;最后移出的位；OF无定义</td></tr></tbody></table><h2 id="比较与条件跳转指令（Compare-Conditional-Jump-Instructions）"><a href="#比较与条件跳转指令（Compare-Conditional-Jump-Instructions）" class="headerlink" title="比较与条件跳转指令（Compare &amp; Conditional Jump Instructions）"></a>比较与条件跳转指令（Compare &amp; Conditional Jump Instructions）</h2><p><code>CMP</code>和<code>TEST</code>通过隐含减法&#x2F;与操作设置标志，供条件跳转判断。</p><table><thead><tr><th>指令缩写</th><th>英文全称</th><th>功能描述</th><th>影响标志&#x2F;依赖标志</th></tr></thead><tbody><tr><td>CMP</td><td>Compare</td><td>比较（dst - src，如<code>CMP EAX, EBX</code>），<br/>等价于 SUB dst, src（不保存结果），<br/>通过设置标志寄存器反映大小关系。</td><td>dst &#x3D;&#x3D; src时，​ZF&#x3D;1 <br/> dst &gt; src时，ZF&#x3D;0 CF&#x3D;0 SF&#x3D;0 <br/> dst &lt; src时，ZF&#x3D;0 CF&#x3D;1 SF&#x3D;1</td></tr><tr><td>JE&#x2F;JZ</td><td>Jump if Equal&#x2F;Zero</td><td>ZF&#x3D;1（<code>dst == src</code>，或运算结果为0）</td><td>相等&#x2F;为零时跳转（如 <code>CMP EAX, EBX</code> 后 <code>JE Label</code> 表示 EAX&#x3D;EBX 时跳转）</td></tr><tr><td>JNE&#x2F;JNZ</td><td>Jump if Not Equal&#x2F;Not Zero</td><td>ZF&#x3D;0（<code>dst != src</code>，或运算结果非0）</td><td>不相等&#x2F;非零时跳转</td></tr><tr><td>JG&#x2F;JNLE</td><td>Jump if Greater&#x2F;Not Less or Equal</td><td>ZF&#x3D;0 且 SF&#x3D;OF（有符号比较：<code>dst &gt; src</code>，不包括等于）</td><td>有符号大于时跳转（如 <code>CMP EAX, EBX</code> 后 <code>JG Label</code> 表示 EAX&gt;EBX 时跳转）</td></tr><tr><td>JGE</td><td>Jump if Greater or Equal</td><td>SF&#x3D;OF（有符号比较：<code>dst ≥ src</code>，包括等于）</td><td>有符号大于等于时跳转（<code>dst == src</code> 时 ZF&#x3D;1，仍满足 SF&#x3D;OF）</td></tr><tr><td>JL</td><td>Jump if Less</td><td>SF≠OF（有符号比较：<code>dst &lt; src</code>）</td><td>有符号小于时跳转</td></tr><tr><td>JLE</td><td>Jump if Less or Equal</td><td>ZF&#x3D;1 或 SF!&#x3D;OF（有符号比较：<code>dst ≤ src</code>，包括等于）</td><td>有符号小于等于时跳转</td></tr><tr><td>JB&#x2F;JC</td><td>Jump if Below&#x2F;Jump if Carry</td><td>CF&#x3D;1（无符号比较：<code>dst &lt; src</code>，或减法产生借位）</td><td>无符号小于时跳转（如 <code>CMP AL, BL</code> 后 <code>JB Label</code> 表示 AL&lt;BL 时跳转）</td></tr><tr><td>JAE&#x2F;JNB</td><td>Jump if Above or Equal&#x2F;Jump if Not Below</td><td>CF&#x3D;0（无符号比较：<code>dst ≥ src</code>，或减法无借位）</td><td>无符号大于等于时跳转</td></tr><tr><td>JA</td><td>Jump if Above</td><td>CF&#x3D;0 且 ZF&#x3D;0（无符号比较：<code>dst &gt; src</code>）</td><td>无符号大于时跳转</td></tr><tr><td>CALL</td><td>Call Procedure</td><td>无（压返回地址到栈，跳转到子程序）</td><td>调用子函数（如 <code>CALL Func</code>）</td></tr><tr><td>RET</td><td>Return</td><td>无（弹出栈顶返回地址，返回调用处）</td><td>子函数返回</td></tr></tbody></table><blockquote><p>完整的指令文档可以参考：<a href="https://shell-storm.org/x86doc/">https://shell-storm.org/x86doc/</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;x86架构作为个人计算机和服务器领域的主流计算架构，其汇编语言是理解计算机底层运行机制、进行逆向工程、性能优化及嵌入式开发的核心基础。本文将系统梳理x86架构中的常用寄存器​和常用汇编指令​，并结合实际应用场景说明其作用。&lt;/p&gt;</summary>
    
    
    
    <category term="软件调试" scheme="https://jiangxueqiao.com/categories/%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95/"/>
    
    
    <category term="汇编" scheme="https://jiangxueqiao.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Visual Studio 断点高级使用指南</title>
    <link href="https://jiangxueqiao.com/post/966041457.html"/>
    <id>https://jiangxueqiao.com/post/966041457.html</id>
    <published>2025-09-22T11:39:49.000Z</published>
    <updated>2025-09-22T11:50:48.840Z</updated>
    
    <content type="html"><![CDATA[<p>Visual Studio 的断点系统远不止”在代码行上点击左侧边栏”那么简单。掌握其高级功能可以彻底改变你的调试体验，让你能精准定位问题，而不是在无尽的代码执行中盲目搜索。本文将带你全面了解 Visual Studio 断点系统的各项高级功能。</p><h1 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h1><p>条件断点允许你设置特定条件，只有满足这些条件时调试器才会暂停。</p><p>支持如下格式的表达式：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 基本条件</span><br><span class="line">i &gt; 100</span><br><span class="line">name == &quot;admin&quot;</span><br><span class="line"></span><br><span class="line">// 复合条件</span><br><span class="line">x &gt; 50 &amp;&amp; y &lt; 20 &amp;&amp; isValid == true</span><br><span class="line"></span><br><span class="line">// 字符串操作（C++）</span><br><span class="line">strcmp(filename, &quot;config.xml&quot;) == 0</span><br><span class="line">strlen(buffer) &gt; 255</span><br></pre></td></tr></table></figure><p>支持的内置函数如下：</p><ul><li>strlen(str)：获取字符串长度</li><li>strcmp(str1, str2)：比较两个字符串</li><li>strncmp(str1, str2, n)：比较前n个字符</li><li>strstr(haystack, needle)：查找子字符串</li><li>GetLastError()：获取系统错误代码</li></ul><h1 id="断点筛选器"><a href="#断点筛选器" class="headerlink" title="断点筛选器"></a>断点筛选器</h1><p>当调试多线程或分布式应用时，筛选器能确保断点只在特定环境中触发。</p><p>支持如下筛选字段：</p><ul><li>MachineName</li><li>ProcessId</li><li>ProcessName</li><li>ThreadId</li><li>ThreadName</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadId = 1234</span><br><span class="line">ProcessName = &quot;MyApp.exe&quot;</span><br><span class="line">MachineName = &quot;Development-PC&quot;</span><br><span class="line">ThreadName = &quot;WorkerThread&quot;</span><br></pre></td></tr></table></figure><p>筛选器的逻辑运算与条件断点有些不一样，逻辑等号使用<code>=</code>，逻辑与使用<code>&amp;</code>，逻辑或使用<code>||</code>，逻辑非使用<code>!</code>，没有不等号。</p><p>示例：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MachineName = &quot;MyPC&quot;</span><br><span class="line">ProcessId = 1234</span><br><span class="line">ThreadId = 1234 &amp; MachineName = &quot;DevPC&quot;</span><br><span class="line">ThreadId = 1234 || ProcessId = 4</span><br><span class="line">!ThreadId = 5678</span><br></pre></td></tr></table></figure><h1 id="跟踪器"><a href="#跟踪器" class="headerlink" title="跟踪器"></a>跟踪器</h1><p>在“断点”中选择“操作”，输入跟踪指令即可，通常，为了不影响程序执行流，建议同时勾选 ​​“继续执行”​，这样程序运行到此处时就不会中断，而是直接输出信息后继续运行。</p><p>支持如下格式的指令：</p><ul><li><p>直接输入字符串，例如 “循环到了这里”。</p></li><li><p>使用变量名，用大括号 {}括起来，例如 “当前 i 的值为: {i}”。输出时，{i}会被替换为变量 i的实际值。</p></li><li><p>使用一些预定义的关键字​（以 $开头），例如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ADDRESS- 当前指令地址</span><br><span class="line">$CALLER- 调用当前函数的函数名称</span><br><span class="line">$FUNCTION- 当前函数名称</span><br><span class="line">$TID- 当前线程 ID</span><br><span class="line">$PID- 当前进程 ID</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Visual Studio 的断点系统远不止”在代码行上点击左侧边栏”那么简单。掌握其高级功能可以彻底改变你的调试体验，让你能精准定位问题，而不是在无尽的代码执行中盲目搜索。本文将带你全面了解 Visual Studio 断点系统的各项高级功能。&lt;/p&gt;
&lt;h1 id=&quot;条</summary>
      
    
    
    
    <category term="软件调试" scheme="https://jiangxueqiao.com/categories/%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95/"/>
    
    
    <category term="Visual Studio" scheme="https://jiangxueqiao.com/tags/Visual-Studio/"/>
    
  </entry>
  
  <entry>
    <title>C++右值</title>
    <link href="https://jiangxueqiao.com/post/1144324523.html"/>
    <id>https://jiangxueqiao.com/post/1144324523.html</id>
    <published>2025-09-22T04:11:02.000Z</published>
    <updated>2025-09-22T06:08:11.802Z</updated>
    
    <content type="html"><![CDATA[<p>在C++98时代，我们经常会遇到这样的性能瓶颈：当需要返回或传递大型对象（如字符串、向量或自定义资源管理类）时，不得不进行昂贵的深拷贝操作。即使我们知道某些对象即将被销毁，也无法避免这种拷贝开销。</p><p>C++11引入的右值引用和移动语义彻底改变了这一局面，让C++程序员能够写出更高效、更现代的代码。</p><span id="more"></span><h1 id="基础概念-左值与右值"><a href="#基础概念-左值与右值" class="headerlink" title="基础概念 - 左值与右值"></a>基础概念 - 左值与右值</h1><p>左值（lvalue）​​ 是指具有持久状态的表达式，简单说就是有名字、有内存地址的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;           <span class="comment">// a是左值</span></span><br><span class="line"><span class="type">int</span>* ptr = &amp;a;        <span class="comment">// 可以取地址，是左值的特征</span></span><br><span class="line"></span><br><span class="line">std::string s = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// s是左值</span></span><br><span class="line">std::string&amp; ref = s;     <span class="comment">// 可以绑定到左值引用</span></span><br></pre></td></tr></table></figure><p>右值（rvalue）​​ 是指临时性的表达式，通常是短暂存在的中间结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="number">3</span> + <span class="number">4</span>;    <span class="comment">// 3+4是右值（计算结果）</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">getString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;temp&quot;</span>; &#125;</span><br><span class="line">std::string s = <span class="built_in">getString</span>(); <span class="comment">// getString()返回值是右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;           <span class="comment">// 10是右值（字面量）</span></span><br></pre></td></tr></table></figure><h1 id="问题根源-不必要的拷贝"><a href="#问题根源-不必要的拷贝" class="headerlink" title="问题根源 - 不必要的拷贝"></a>问题根源 - 不必要的拷贝</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyVector</span> &#123;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 拷贝构造函数 (深拷贝)</span></span><br><span class="line">    <span class="built_in">MyVector</span>(<span class="type">const</span> MyVector&amp; other) : <span class="built_in">size</span>(other.size) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data, other.data + size, data);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;深拷贝发生！成本: &quot;</span> &lt;&lt; <span class="function">size * <span class="title">sizeof</span><span class="params">(<span class="type">int</span>)</span> &lt;&lt; &quot; 字节\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyVector <span class="title">createLargeVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyVector <span class="title">vec</span><span class="params">(<span class="number">1000000</span>)</span></span>; <span class="comment">// 创建一个包含一百万个整数的向量</span></span><br><span class="line">    <span class="comment">// ... 填充 vec ...</span></span><br><span class="line">    <span class="keyword">return</span> vec; <span class="comment">// 返回时，理论上 vec 即将销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyVector v = <span class="built_in">createLargeVector</span>(); <span class="comment">// C++98: 触发深拷贝！拷贝一百万整数！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 createLargeVector()返回时，vec是一个即将被销毁的局部对象（本质上是右值）。它的内部资源（那个包含一百万个整数的数组）在 vec析构时会被释放掉。然而，在 main函数中构造 v时，我们却不得不进行代价高昂的深拷贝，将这一百万个整数完整地复制一份。这造成了双重浪费：</p><ul><li>深拷贝本身消耗大量 CPU 时间和内存带宽。</li><li>vec内部的资源最终会被销毁，我们本可以“直接拿来”给 v用，却选择了复制一份然后销毁原版。</li></ul><p><strong>注意：由于现代编译器的返回值优化（RVO）功能，上述示例无法按照期望运行，可以尝试禁用编译器优化。</strong></p><blockquote><p>返回值优化（Return Value Optimization, RVO）​​ 是 C++ 编译器的一项优化技术，它允许编译器在返回一个局部对象时，避免执行不必要的拷贝（或移动）构造函数，从而直接将对象构造在函数外部的目标内存位置。简单来说，它消除了函数返回时产生的临时对象。</p></blockquote><h1 id="解决方案-右值引用和移动语义"><a href="#解决方案-右值引用和移动语义" class="headerlink" title="解决方案 - 右值引用和移动语义"></a>解决方案 - 右值引用和移动语义</h1><p>C++11引入了右值引用，语法为T&amp;&amp;，它专门用于绑定到右值（临时对象）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">10</span> + <span class="number">20</span>;        <span class="comment">// 右值引用绑定到临时结果</span></span><br><span class="line">std::string&amp;&amp; sref = <span class="built_in">getString</span>(); <span class="comment">// 绑定到函数返回的临时对象</span></span><br></pre></td></tr></table></figure><p>有了右值引用，我们就可以对上述MyVector类进行改造，使其支持移动语义​。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyVector</span>(MyVector&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">    : <span class="built_in">data_</span>(other.data_), <span class="built_in">size_</span>(other.size_) &#123;</span><br><span class="line">  other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">  other.size_ = <span class="number">0</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;移动构造发生！成本: 0 字节\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyVector&amp; <span class="keyword">operator</span>=(MyVector&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] data_;</span><br><span class="line">    data_ = other.data_;</span><br><span class="line">    size_ = other.size_;</span><br><span class="line">    other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    other.size_ = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;移动赋值发生！成本: 0 字节\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于没有定义移动构造函数或移动赋值运算符的类使用std::move，会自动回退到使用拷贝构造函数或拷贝赋值运算符，而如果拷贝构造函数或拷贝赋值运算符也没定义，则会编译错误。</p><p>如果类成员是内置类型 (int, double, 指针等)、支持移动的类型（如std::string、std::vector等）,无需自定义移动构造函数或移动赋值运算符，编译器会自动支持移动操作。（见下面的Rule of Zero）</p><h1 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h1><h2 id="Rule-of-Zero"><a href="#Rule-of-Zero" class="headerlink" title="Rule of Zero"></a>Rule of Zero</h2><p>零法则，在现代C++中，鼓励通过使用标准库容器 (std::vector, std::string) 、智能指针 (std::unique_ptr, std::shared_ptr)等标准库提供的工具来管理资源，从而无需手动编写析构函数、拷贝构造函数和拷贝赋值运算符（C++11的“三个大”）。在这种情况下，编译器提供的默认版本已经足够且正确。这种方法不仅简化了代码，还能有效降低出错的可能性。</p><h2 id="Rule-of-Five"><a href="#Rule-of-Five" class="headerlink" title="Rule of Five"></a>Rule of Five</h2><p>如果一个类需要自定义实现以下五个特殊成员函数中的任何一个，那么它也需要为这五个函数都提供自定义实现，以确保资源管理的正确性和行为的一致性。</p><ul><li>析构函数</li><li>拷贝构造函数</li><li>拷贝赋值运算符</li><li>移动构造函数</li><li>移动赋值运算符</li></ul><p>C++ 编译器有一套明确的规则来决定何时自动生成特殊成员函数（拷贝构造、拷贝赋值、移动构造、移动赋值、析构）：</p><table><thead><tr><th>类中声明的成员函数</th><th>编译器自动生成的函数</th></tr></thead><tbody><tr><td>无特殊成员函数</td><td>所有：拷贝构造、拷贝赋值、移动构造、移动赋值、析构</td></tr><tr><td>有析构函数</td><td>拷贝构造、拷贝赋值（不生成移动操作）</td></tr><tr><td>有拷贝构造或拷贝赋值</td><td>析构（不生成移动操作）</td></tr><tr><td>有移动构造或移动赋值</td><td>不生成拷贝操作​（拷贝构造和拷贝赋值被删除）</td></tr></tbody></table><h1 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h1><p>std::move实际上只是一个静态类型转换​：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::<span class="type">remove_reference_t</span>&lt;T&gt;&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的唯一作用是将表达式转换为右值引用类型，告诉编译器：”这个对象可以被视为临时对象，允许移动其资源”。</p><p>如果一个类没有移动构造函数或移动赋值运算符，使用 std::move 仍然有效，但行为会有所不同：</p><ul><li>如果类有拷贝操作：编译器会退回到拷贝构造函数，因为右值引用可以绑定到const T&amp;参数。</li><li>如果类没有拷贝操作：如果满足自动生成移动操作，则使用默认的移动操作，否则代码无法编译。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在C++98时代，我们经常会遇到这样的性能瓶颈：当需要返回或传递大型对象（如字符串、向量或自定义资源管理类）时，不得不进行昂贵的深拷贝操作。即使我们知道某些对象即将被销毁，也无法避免这种拷贝开销。&lt;/p&gt;
&lt;p&gt;C++11引入的右值引用和移动语义彻底改变了这一局面，让C++程序员能够写出更高效、更现代的代码。&lt;/p&gt;</summary>
    
    
    
    <category term="C++语言" scheme="https://jiangxueqiao.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://jiangxueqiao.com/tags/C/"/>
    
    <category term="右值" scheme="https://jiangxueqiao.com/tags/%E5%8F%B3%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>绘制Windows的界面：探索窗口、GDI与GDI+的图形世界</title>
    <link href="https://jiangxueqiao.com/post/3832899600.html"/>
    <id>https://jiangxueqiao.com/post/3832899600.html</id>
    <published>2025-09-21T04:20:32.000Z</published>
    <updated>2025-09-22T03:15:13.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows图形编程的核心骨架"><a href="#Windows图形编程的核心骨架" class="headerlink" title="Windows图形编程的核心骨架"></a>Windows图形编程的核心骨架</h1><p>在深入探索Windows图形编程之前，让我们先了解一个最基本的Windows窗口程序骨架。这个骨架程序包含了创建窗口、处理消息和基本绘图的全部要素：</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明窗口过程函数</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序入口点</span></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ <span class="type">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 注册窗口类</span></span><br><span class="line">  <span class="type">const</span> <span class="type">wchar_t</span> CLASS_NAME[] = <span class="string">L&quot;SampleWindowClass&quot;</span>;</span><br><span class="line"></span><br><span class="line">  WNDCLASSEX wcex = &#123;&#125;;</span><br><span class="line">  wcex.cbSize = <span class="built_in">sizeof</span>(WNDCLASSEX);                 <span class="comment">// 结构体大小</span></span><br><span class="line">  wcex.lpfnWndProc = WindowProc;                    <span class="comment">// 窗口过程函数</span></span><br><span class="line">  wcex.hInstance = hInstance;                       <span class="comment">// 程序实例句柄</span></span><br><span class="line">  wcex.lpszClassName = CLASS_NAME;                  <span class="comment">// 窗口类名</span></span><br><span class="line">  wcex.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);       <span class="comment">// 光标样式</span></span><br><span class="line">  wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);  <span class="comment">// 窗口背景</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">RegisterClassEx</span>(&amp;wcex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 创建窗口</span></span><br><span class="line">  HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">      <span class="number">0</span>,                       <span class="comment">// 扩展样式</span></span><br><span class="line">      CLASS_NAME,              <span class="comment">// 窗口类名</span></span><br><span class="line">      <span class="string">L&quot;Windows图形编程示例&quot;</span>,  <span class="comment">// 窗口标题</span></span><br><span class="line">      WS_OVERLAPPEDWINDOW,     <span class="comment">// 窗口样式</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 位置和大小</span></span><br><span class="line">      CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">      <span class="number">800</span>, <span class="number">600</span>,</span><br><span class="line"></span><br><span class="line">      <span class="literal">NULL</span>,       <span class="comment">// 父窗口</span></span><br><span class="line">      <span class="literal">NULL</span>,       <span class="comment">// 菜单</span></span><br><span class="line">      hInstance,  <span class="comment">// 实例句柄</span></span><br><span class="line">      <span class="literal">NULL</span>        <span class="comment">// 附加数据</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hwnd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 显示窗口</span></span><br><span class="line">  <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">  <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 消息循环</span></span><br><span class="line">  MSG msg = &#123;&#125;;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">    <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">int</span>)msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口过程函数</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">      <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_PAINT: &#123;</span><br><span class="line">      PAINTSTRUCT ps;</span><br><span class="line">      HDC hdc = <span class="built_in">BeginPaint</span>(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在这里添加绘图代码</span></span><br><span class="line">      <span class="comment">// 例如: TextOut(hdc, 50, 50, L&quot;Hello, Windows!&quot;, 15);</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">EndPaint</span>(hwnd, &amp;ps);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个基础程序包含了Windows图形编程的核心要素：</p><ol><li>​WinMain入口点​ - Windows GUI应用程序的起点<br>​2. 窗口类注册​ - 定义窗口的基本特性<br>​3. 窗口创建​ - 根据注册的类创建窗口实例</li><li>​消息循环​ - Windows程序的心脏，负责接收和分发系统发送给窗口的各种消息<br>​5. 窗口过程函数​ - 可以在此处理发送到窗口的所有消息</li></ol><p>接下来，我们将深入探讨Windows窗口创建和图形绘制的各个方面。</p><h1 id="窗口类"><a href="#窗口类" class="headerlink" title="窗口类"></a>窗口类</h1><p>窗口类是窗口的模板，定义了窗口的基本特性，使用同一个窗口类创建的窗口拥有相同的特性，如背景色、光标样式等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASSEX wcex = &#123;&#125;;</span><br><span class="line">wcex.cbSize = <span class="built_in">sizeof</span>(WNDCLASSEX);     <span class="comment">// 必须设置结构体大小</span></span><br><span class="line">wcex.lpfnWndProc = WindowProc;        <span class="comment">// 窗口过程函数</span></span><br><span class="line">wcex.hInstance = hInstance;           <span class="comment">// 应用程序实例句柄</span></span><br><span class="line">wcex.lpszClassName = <span class="string">L&quot;MyWindowClass&quot;</span>; <span class="comment">// 窗口类名</span></span><br><span class="line">wcex.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW); <span class="comment">// 光标样式</span></span><br><span class="line">wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>); <span class="comment">// 背景画刷</span></span><br><span class="line">wcex.hIcon = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION); <span class="comment">// 主图标</span></span><br><span class="line">wcex.hIconSm = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_WINLOGO); <span class="comment">// 小图标（任务栏图标）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册窗口类</span></span><br><span class="line"><span class="built_in">RegisterClassEx</span>(&amp;wcex);</span><br></pre></td></tr></table></figure><p>窗口类名不区分大小写。</p><h2 id="系统预定义窗口类"><a href="#系统预定义窗口类" class="headerlink" title="系统预定义窗口类"></a>系统预定义窗口类</h2><p>Windows提供了一些预定义的窗口类，可以直接使用，如​Button、Edit、ListBox​、Static​、ComboBox、ScrollBar等。</p><p>详见：<a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/about-window-classes#system-classes">about-window-classes#system-classes</a></p><p>系统窗口类是由操作系统自动注册的用户进程的窗口类。操作系统会在用户进程首次调用Windows图形设备接口（GDI）函数时，为其注册相应的系统窗口类。</p><p>虽然将系统窗口类用来创建主窗口是被允许的，比如用Button窗口类来创建一个主窗口，但这样只会创建一个大大的按钮，没有实际意义，因此通常不将系统窗口类用来创建主窗口，仅用于创建子窗口（子控件）。</p><p>需要注意的是，无论是系统窗口类还是用户自定义的窗口类，都是是与进程相关联的，而不是线程，一旦窗口类被注册，进程内的所有线程都可以使用。</p><h2 id="自定义窗口类"><a href="#自定义窗口类" class="headerlink" title="自定义窗口类"></a>自定义窗口类</h2><p>自定义窗口类允许开发者完全控制窗口的行为和外观：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASSEX wcex = &#123;&#125;;</span><br><span class="line">wcex.cbSize = <span class="built_in">sizeof</span>(WNDCLASSEX);</span><br><span class="line">wcex.style = CS_HREDRAW | CS_VREDRAW; <span class="comment">// 窗口改变大小时重绘</span></span><br><span class="line">wcex.lpfnWndProc = WindowProc;</span><br><span class="line">wcex.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wcex.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">wcex.hInstance = hInstance;</span><br><span class="line">wcex.hIcon = <span class="built_in">LoadIcon</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDI_APPLICATION));</span><br><span class="line">wcex.hIconSm = <span class="built_in">LoadIcon</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDI_SMALL)); <span class="comment">// 小图标</span></span><br><span class="line">wcex.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">wcex.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(WHITE_BRUSH); <span class="comment">// 只能是HBRUSH画刷类型</span></span><br><span class="line">wcex.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wcex.lpszClassName = <span class="string">L&quot;CustomWindowClass&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RegisterClassEx</span>(&amp;wcex);</span><br></pre></td></tr></table></figure><h3 id="窗口类样式"><a href="#窗口类样式" class="headerlink" title="窗口类样式"></a>窗口类样式</h3><p>窗口类样式（WNDCLASSEX.style）是在注册窗口类时设置的，它定义了窗口类的一些通用行为，这些行为将应用于所有使用这个类创建的窗口。</p><p>窗口类样式主要影响窗口的行为（如重绘、双击等），而窗口的外观、边框、标题栏这些样式则有CreateWindow函数中的窗口样式所指定。</p><p>常见的类样式包括：</p><ul><li>CS_HREDRAW | CS_VREDRAW: 当窗口的宽度或高度改变时，重绘整个窗口。</li><li>CS_DBLCLKS: 允许窗口接收双击消息（WM_LBUTTONDBLCLK等）。</li><li>CS_OWNDC: 为每个窗口实例分配一个独有的设备上下文（DC）。</li><li>CS_CLASSDC: 为窗口类分配一个共享的设备上下文（DC）。</li><li>CS_NOCLOSE: 禁用（而非隐藏）窗口系统菜单中的关闭按钮。</li><li>CS_SAVEBITS: 将窗口图像保存为位图，以便在窗口被遮挡后快速重绘（常用于小窗口，如菜单）。</li><li>CS_GLOBALCLASS: 表示这个窗口类是应用程序全局的，可以被同一进程中的其他模块使用（通常在DLL中使用）。</li></ul><h3 id="窗口默认背景色"><a href="#窗口默认背景色" class="headerlink" title="窗口默认背景色"></a>窗口默认背景色</h3><p>WNDCLASSEX.hbrBackground用于指定窗口类的默认背景画刷。当窗口需要重绘背景时（收到 WM_ERASEBKGND消息），系统会自动使用这个画刷填充背景。我们也可以在WM_ERASEBKGND消息处理函数中使用自定义背景色进行填充。</p><p>由于窗口是先收到WM_ERASEBKGND消息，后收到WM_PAINT消息的，因此对于复杂界面，在背景擦除和内容绘制之间就可能出现人眼可见间隔（闪烁）。为了避免这种问题，我们通常采用如下方法：将WNDCLASSEX.hbrBackground 设置为NULL，并在WM_ERASEBKGND处理过程中直接返回TRUE（这里的返回值表示背景是否已经擦除，实际会影响PAINTSTRUCT.fErase的值），然后在WM_PAINT处理过程中采用双缓冲的方式绘制背景和内容。</p><p>WNDCLASSEX.hbrBackground是HBRUSH类型，创建HBRUSH类型的方式有几种。</p><p><strong>使用系统颜色常量创建</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用标准窗口背景色（通常是白色）</span></span><br><span class="line">wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>); <span class="comment">// 必须加 +1，这是 Windows API 的历史设计，表示使用系统颜色索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用按钮表面颜色（灰色）</span></span><br><span class="line">wcex.hbrBackground = (HBRUSH)(COLOR_BTNFACE + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用桌面背景色</span></span><br><span class="line">wcex.hbrBackground = (HBRUSH)(COLOR_BACKGROUND + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>使用内置画刷</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取白色画刷</span></span><br><span class="line">wcex.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(WHITE_BRUSH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取黑色画刷</span></span><br><span class="line">wcex.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(BLACK_BRUSH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取灰色画刷</span></span><br><span class="line">wcex.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(GRAY_BRUSH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取空画刷（透明背景）</span></span><br><span class="line">wcex.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(NULL_BRUSH);</span><br></pre></td></tr></table></figure><p><strong>创建自定义画刷</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建纯色画刷</span></span><br><span class="line">HBRUSH hBlueBrush = <span class="built_in">CreateSolidBrush</span>(<span class="built_in">RGB</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">wcex.hbrBackground = hBlueBrush;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建位图画刷</span></span><br><span class="line">HBITMAP hBmp = <span class="built_in">LoadBitmap</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDB_BACKGROUND));</span><br><span class="line">HBRUSH hPatternBrush = <span class="built_in">CreatePatternBrush</span>(hBmp);</span><br><span class="line">wcex.hbrBackground = hPatternBrush;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建阴影画刷</span></span><br><span class="line">HBRUSH hHatchBrush = <span class="built_in">CreateHatchBrush</span>(HS_CROSS, <span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// HS_CROSS表示横竖垂直交叉</span></span><br><span class="line">wcex.hbrBackground = hHatchBrush;</span><br></pre></td></tr></table></figure><h1 id="不同窗口样式的区别与应用"><a href="#不同窗口样式的区别与应用" class="headerlink" title="不同窗口样式的区别与应用"></a>不同窗口样式的区别与应用</h1><p>虽然窗口类中也包含样式，但窗口类样式主要对窗口的行为（如重绘、双击等）进行少量的设置，更多的窗口外观和功能都由窗口样式所指定。</p><p>我们通过CreateWindowEx函数中的dwStyle和dwExStyle参数指定窗口样式。</p><h2 id="dwStyle"><a href="#dwStyle" class="headerlink" title="dwStyle"></a>dwStyle</h2><p>dwStyle定义了窗口的基本外观和功能特性，是创建窗口时必须指定的参数。</p><p>窗口类型样式：</p><ul><li>WS_OVERLAPPED 有标题栏和边框，不能调整窗口大小，没有最大化、最小化、关闭按钮</li><li>WS_POPUP 弹窗，顶级窗口，不能指定父窗口，没有标题栏和边框</li><li>WS_CHILD 子窗口，必须指定父窗口</li><li>WS_OVERLAPPEDWINDOW 组合样式，创建的窗口包含：标题栏、边框、窗口菜单（系统菜单）、最小化按钮、最大化按钮、可调整大小的边框</li></ul><p>可见性（都是指定的初始可见性，后面可以通过程序改变）：</p><ul><li>WS_VISIBLE 窗口初始可见</li><li>WS_DISABLED 窗口初始禁用</li><li>WS_MINIMIZE 窗口初始最小化</li><li>WS_MAXIMIZE 窗口初始最大化</li></ul><p>边框与标题栏样式</p><ul><li>WS_BORDER   细边框，不能调整窗口大小</li><li>WS_DLGFRAME 对话框风格边框</li><li>WS_CAPTION  标题栏（包含WS_BORDER）</li><li>WS_THICKFRAME 可调整大小的边框</li><li>WS_SYSMENU  系统菜单</li><li>WS_MINIMIZEBOX 最小化按钮</li><li>WS_MAXIMIZEBOX 最大化按钮</li></ul><p>滚动条样式</p><ul><li>WS_HSCROLL 窗口始终有水平滚动条</li><li>WS_VSCROLL 窗口始终有垂直滚动条</li></ul><h2 id="dwExStyle"><a href="#dwExStyle" class="headerlink" title="dwExStyle"></a>dwExStyle</h2><p>dwExStyle定义了窗口的高级特性和特殊效果，通常用于实现更复杂的界面需求。</p><p>分层与透明度样式</p><ul><li>WS_EX_LAYERED 分层窗口（支持透明度）</li><li>WS_EX_TRANSPARENT 透明窗口（鼠标点击穿透）</li></ul><p>位置与行为样式</p><ul><li>WS_EX_TOPMOST 窗口始终置顶</li><li>WS_EX_TOOLWINDOW 工具窗口（不在任务栏显示）</li><li>WS_EX_NOACTIVATE 窗口激活时不带到前台</li><li>WS_EX_APPWINDOW 强制窗口在任务栏显示</li></ul><p>边框效果样式<br>WS_EX_WINDOWEDGE 凸起边框</p><ul><li>WS_EX_CLIENTEDGE 凹陷边框</li><li>WS_EX_STATICEDGE 静态边框（无3D效果）</li></ul><p>其他高级样式</p><ul><li>WS_EX_CONTEXTHELP 标题栏添加帮助按钮</li><li>WS_EX_ACCEPTFILES 接受文件拖放</li><li>WS_EX_COMPOSITED 双缓冲绘制所有子窗口，在启动了DWM的系统上没有效果，因为DWM已经支持桌面级的合成</li><li>WS_EX_RIGHT 窗口右对齐，比如在阿拉伯语等环境下比较有用</li><li>WS_EX_RTLREADING 从右到左显示文本，比如在阿拉伯语等环境下比较有用</li></ul><h2 id="运行时修改窗口样式"><a href="#运行时修改窗口样式" class="headerlink" title="运行时修改窗口样式"></a>运行时修改窗口样式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前样式</span></span><br><span class="line">LONG_PTR style = <span class="built_in">GetWindowLongPtr</span>(hWnd, GWL_STYLE);</span><br><span class="line">LONG_PTR exStyle = <span class="built_in">GetWindowLongPtr</span>(hWnd, GWL_EXSTYLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查窗口是否置顶</span></span><br><span class="line">BOOL isTopmost = exStyle &amp; WS_EX_TOPMOST;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新样式</span></span><br><span class="line">style |= WS_VISIBLE;</span><br><span class="line">exStyle |= WS_EX_TOPMOST;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除样式</span></span><br><span class="line">style &amp;= ~WS_MAXIMIZEBOX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用新样式</span></span><br><span class="line"><span class="built_in">SetWindowLongPtr</span>(hWnd, GWL_STYLE, style);</span><br><span class="line"><span class="built_in">SetWindowLongPtr</span>(hWnd, GWL_EXSTYLE, exStyle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重绘窗口</span></span><br><span class="line"><span class="built_in">SetWindowPos</span>(hWnd, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">             SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);</span><br></pre></td></tr></table></figure><h1 id="窗口消息处理过程"><a href="#窗口消息处理过程" class="headerlink" title="窗口消息处理过程"></a>窗口消息处理过程</h1><p>WNDCLASSEX.lpfnWndProc 函数指针指向应用程序定义的窗口过程函数，这个函数负责处理发送到该窗口类的所有消息。</p><p>我们通常会对一些常用的消息进行处理，对于未处理的消息则调用DefWindowProc函数使用默认的方式进行处理。</p><ul><li>WM_DESTROY 窗口销毁时发送，如果要退出程序，应在此处调用 PostQuitMessage</li><li>WM_CLOSE      窗口关闭前请发送，可在此取消窗口关闭操作</li><li>WM_CREATE     窗口已被创建，但还未可见时发送，可以在此处初始化资源</li><li>WM_PAINT      窗口需要绘制时发送，可以在此处进行窗口绘制</li></ul><p>窗口过程函数的返回值虽然为LRESULT类型，但却没有固定的值，需要根据消息的类型的不同，返回不同的值。</p><h1 id="GDI绘图基础"><a href="#GDI绘图基础" class="headerlink" title="GDI绘图基础"></a>GDI绘图基础</h1><p>GDI（Graphics Device Interface）是Windows的图形设备接口，其核心原理是通过一个抽象的“设备上下文”（DC）来屏蔽不同硬件设备的差异，实现设备无关的图形绘制，应用程序不需要直接操作物理设备。</p><p>可以将DC想象成一张画布，在开始绘画前，我们需要选择（SelectObject函数）画笔Pen、画刷Brush、字体Font、位图Bitmap等工具，然后进行绘制，绘制完成后需要删除创建的工具，并将老的工具选入到DC中。</p><h2 id="设备上下文"><a href="#设备上下文" class="headerlink" title="设备上下文"></a>设备上下文</h2><p>设备上下文（Device Context，DC）是GDI的核心概念，代表一个绘图表面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取设备上下文的几种方式</span></span><br><span class="line">HDC hdc = <span class="built_in">GetDC</span>(hWnd);           <span class="comment">// 获取窗口DC</span></span><br><span class="line">HDC hdc = <span class="built_in">BeginPaint</span>(hWnd, &amp;ps); <span class="comment">// 在WM_PAINT中获取DC</span></span><br><span class="line">HDC hdc = <span class="built_in">CreateDC</span>(<span class="string">L&quot;DISPLAY&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">// 创建显示设备DC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用后必须释放DC，否则会资源泄露</span></span><br><span class="line"><span class="built_in">ReleaseDC</span>(hWnd, hdc);</span><br><span class="line"><span class="built_in">EndPaint</span>(hWnd, &amp;ps);</span><br><span class="line"><span class="built_in">DeleteDC</span>(hdc);</span><br></pre></td></tr></table></figure><h2 id="基本绘图函数"><a href="#基本绘图函数" class="headerlink" title="基本绘图函数"></a>基本绘图函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制线条</span></span><br><span class="line"><span class="built_in">MoveToEx</span>(hdc, <span class="number">10</span>, <span class="number">10</span>, <span class="literal">NULL</span>);  <span class="comment">// 移动到起点</span></span><br><span class="line"><span class="built_in">LineTo</span>(hdc, <span class="number">100</span>, <span class="number">100</span>);        <span class="comment">// 画线到终点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制形状</span></span><br><span class="line"><span class="built_in">Rectangle</span>(hdc, <span class="number">50</span>, <span class="number">50</span>, <span class="number">150</span>, <span class="number">150</span>);  <span class="comment">// 矩形</span></span><br><span class="line"><span class="built_in">Ellipse</span>(hdc, <span class="number">50</span>, <span class="number">50</span>, <span class="number">150</span>, <span class="number">150</span>);    <span class="comment">// 椭圆</span></span><br><span class="line"><span class="built_in">RoundRect</span>(hdc, <span class="number">50</span>, <span class="number">50</span>, <span class="number">150</span>, <span class="number">150</span>, <span class="number">20</span>, <span class="number">20</span>); <span class="comment">// 圆角矩形</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充矩形</span></span><br><span class="line">RECT rc = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>&#125;;</span><br><span class="line">HBRUSH hbrWhite = <span class="built_in">CreateSolidBrush</span>(<span class="built_in">RGB</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line"><span class="built_in">FillRect</span>(hdc, &amp;rc, hbrWhite);</span><br><span class="line"><span class="built_in">DeleteObject</span>(hbrWhite);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制文本</span></span><br><span class="line"><span class="built_in">SetBkMode</span>(hdcMem, TRANSPARENT);        <span class="comment">// 透明背景</span></span><br><span class="line"><span class="built_in">SetTextColor</span>(hdcMem, <span class="built_in">RGB</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));  <span class="comment">// 蓝色文本</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">TextOut</span>(hdc, <span class="number">10</span>, <span class="number">10</span>, <span class="string">L&quot;Hello, GDI!&quot;</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">DrawText</span>(hdcMem, <span class="string">L&quot;Hello, GDI!&quot;</span>, <span class="number">-1</span>, &amp;rcClient, DT_CENTER | DT_VCENTER | DT_SINGLELINE);</span><br></pre></td></tr></table></figure><h2 id="GDI对象：画笔、画刷和字体"><a href="#GDI对象：画笔、画刷和字体" class="headerlink" title="GDI对象：画笔、画刷和字体"></a>GDI对象：画笔、画刷和字体</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建画笔（绘制线条）</span></span><br><span class="line">HPEN hPen = <span class="built_in">CreatePen</span>(PS_SOLID, <span class="number">1</span>, <span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 红色实线画笔</span></span><br><span class="line">HPEN hOldPen = (HPEN)<span class="built_in">SelectObject</span>(hdc, hPen); <span class="comment">// 选入DC并保存旧画笔</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建画刷（填充区域）</span></span><br><span class="line">HBRUSH hBrush = <span class="built_in">CreateSolidBrush</span>(<span class="built_in">RGB</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>)); <span class="comment">// 蓝色实心画刷</span></span><br><span class="line">HBRUSH hOldBrush = (HBRUSH)<span class="built_in">SelectObject</span>(hdc, hBrush);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用后恢复旧对象并删除新对象</span></span><br><span class="line"><span class="built_in">SelectObject</span>(hdc, hOldPen);</span><br><span class="line"><span class="built_in">SelectObject</span>(hdc, hOldBrush);</span><br><span class="line"><span class="built_in">DeleteObject</span>(hPen);</span><br><span class="line"><span class="built_in">DeleteObject</span>(hBrush);</span><br></pre></td></tr></table></figure><h2 id="双缓冲（GDI版）"><a href="#双缓冲（GDI版）" class="headerlink" title="双缓冲（GDI版）"></a>双缓冲（GDI版）</h2><p>双缓冲技术通过在内存中绘制再一次性显示来消除闪烁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GDI双缓冲实现</span></span><br><span class="line"><span class="keyword">case</span> WM_PAINT: &#123;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    HDC hdc = <span class="built_in">BeginPaint</span>(hWnd, &amp;ps);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建内存DC和位图</span></span><br><span class="line">    HDC hdcMem = <span class="built_in">CreateCompatibleDC</span>(hdc);</span><br><span class="line">    HBITMAP hbmMem = <span class="built_in">CreateCompatibleBitmap</span>(hdc, width, height);</span><br><span class="line">    <span class="built_in">SelectObject</span>(hdcMem, hbmMem);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在内存DC上绘制</span></span><br><span class="line">    <span class="comment">// ... 所有绘制操作都在hdcMem上进行 ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将内存位图拷贝到屏幕</span></span><br><span class="line">    <span class="built_in">BitBlt</span>(hdc, <span class="number">0</span>, <span class="number">0</span>, width, height, hdcMem, <span class="number">0</span>, <span class="number">0</span>, SRCCOPY);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="built_in">DeleteObject</span>(hbmMem);</span><br><span class="line">    <span class="built_in">DeleteDC</span>(hdcMem);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">EndPaint</span>(hWnd, &amp;ps);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GDI-绘图基础"><a href="#GDI-绘图基础" class="headerlink" title="GDI+绘图基础"></a>GDI+绘图基础</h1><p>GDI+是GDI的增强版，提供了更现代、更强大的绘图功能。GDI是面向过程的，有点OpenGL状态机的味道，而GDI+是面向对象的。</p><h2 id="初始化与清理"><a href="#初始化与清理" class="headerlink" title="初始化与清理"></a>初始化与清理</h2><p>在使用GDI+之前需要进行初始化，使用完之后进行清理，这些操作通常在程序启动和退出时进行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gdiplus.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Gdiplus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化GDI+</span></span><br><span class="line">ULONG_PTR gdiplusToken;</span><br><span class="line">GdiplusStartupInput gdiplusStartupInput;</span><br><span class="line"><span class="built_in">GdiplusStartup</span>(&amp;gdiplusToken, &amp;gdiplusStartupInput, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序退出时清理GDI+</span></span><br><span class="line"><span class="built_in">GdiplusShutdown</span>(gdiplusToken);</span><br></pre></td></tr></table></figure><h2 id="基本绘图操作"><a href="#基本绘图操作" class="headerlink" title="基本绘图操作"></a>基本绘图操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Graphics对象（相当于DC）</span></span><br><span class="line"><span class="function">Graphics <span class="title">graphics</span><span class="params">(hdc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启抗锯齿</span></span><br><span class="line">graphics.<span class="built_in">SetSmoothingMode</span>(SmoothingModeAntiAlias);</span><br><span class="line">graphics.<span class="built_in">SetTextRenderingHint</span>(TextRenderingHintAntiAlias);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建画笔和画刷</span></span><br><span class="line"><span class="function">Pen <span class="title">redPen</span><span class="params">(Color(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2.0f</span>)</span></span>;          <span class="comment">// 红色画笔，宽度2</span></span><br><span class="line"><span class="function">SolidBrush <span class="title">blueBrush</span><span class="params">(Color(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span></span>;      <span class="comment">// 蓝色画刷</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制图形</span></span><br><span class="line">graphics.<span class="built_in">DrawLine</span>(&amp;redPen, <span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);     <span class="comment">// 绘制直线</span></span><br><span class="line">graphics.<span class="built_in">DrawRectangle</span>(&amp;redPen, <span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">80</span>); <span class="comment">// 绘制矩形</span></span><br><span class="line">graphics.<span class="built_in">FillRectangle</span>(&amp;blueBrush, <span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">80</span>); <span class="comment">// 填充矩形</span></span><br><span class="line">graphics.<span class="built_in">DrawEllipse</span>(&amp;redPen, <span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">80</span>);   <span class="comment">// 绘制椭圆</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制文本</span></span><br><span class="line"><span class="function">Font <span class="title">font</span><span class="params">(<span class="string">L&quot;Arial&quot;</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line"><span class="function">SolidBrush <span class="title">blackBrush</span><span class="params">(Color(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">graphics.<span class="built_in">DrawString</span>(<span class="string">L&quot;Hello, GDI+!&quot;</span>, <span class="number">-1</span>, &amp;font, <span class="built_in">PointF</span>(<span class="number">10</span>, <span class="number">10</span>), &amp;blackBrush);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线性渐变画刷</span></span><br><span class="line"><span class="function">LinearGradientBrush <span class="title">linGrBrush</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Point(<span class="number">0</span>, <span class="number">0</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">    Point(<span class="number">100</span>, <span class="number">0</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">    Color(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>),   <span class="comment">// 红色</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Color(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>)     <span class="comment">// 蓝色</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用渐变画刷绘制</span></span><br><span class="line">graphics.<span class="built_in">FillRectangle</span>(&amp;linGrBrush, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载和显示图像</span></span><br><span class="line"><span class="function">Image <span class="title">image</span><span class="params">(<span class="string">L&quot;picture.jpg&quot;</span>)</span></span>;</span><br><span class="line">graphics.<span class="built_in">DrawImage</span>(&amp;image, <span class="number">10</span>, <span class="number">10</span>, image.<span class="built_in">GetWidth</span>(), image.<span class="built_in">GetHeight</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图像变换</span></span><br><span class="line">graphics.<span class="built_in">RotateTransform</span>(<span class="number">45.0f</span>);  <span class="comment">// 旋转45度</span></span><br><span class="line">graphics.<span class="built_in">DrawImage</span>(&amp;image, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">graphics.<span class="built_in">ResetTransform</span>();        <span class="comment">// 重置变换</span></span><br></pre></td></tr></table></figure><h2 id="双缓冲（GDI-）"><a href="#双缓冲（GDI-）" class="headerlink" title="双缓冲（GDI+）"></a>双缓冲（GDI+）</h2><p>在GDI+中仍然需要使用双缓冲技术来减少闪烁，提升绘制效率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GDI+双缓冲实现</span></span><br><span class="line"><span class="keyword">case</span> WM_PAINT: &#123;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    HDC hdc = <span class="built_in">BeginPaint</span>(hWnd, &amp;ps);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取客户区大小</span></span><br><span class="line">    RECT rc;</span><br><span class="line">    <span class="built_in">GetClientRect</span>(hWnd, &amp;rc);</span><br><span class="line">    <span class="type">int</span> width = rc.right - rc.left;</span><br><span class="line">    <span class="type">int</span> height = rc.bottom - rc.top;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建内存位图</span></span><br><span class="line">    <span class="function">Bitmap <span class="title">buffer</span><span class="params">(width, height)</span></span>;</span><br><span class="line">    Graphics* memGraphics = Graphics::<span class="built_in">FromImage</span>(&amp;buffer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在内存中绘制</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制到屏幕</span></span><br><span class="line">    <span class="function">Graphics <span class="title">screenGraphics</span><span class="params">(hdc)</span></span>;</span><br><span class="line">    screenGraphics.<span class="built_in">DrawImage</span>(&amp;buffer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="keyword">delete</span> memGraphics;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">EndPaint</span>(hWnd, &amp;ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Windows图形编程的核心骨架&quot;&gt;&lt;a href=&quot;#Windows图形编程的核心骨架&quot; class=&quot;headerlink&quot; title=&quot;Windows图形编程的核心骨架&quot;&gt;&lt;/a&gt;Windows图形编程的核心骨架&lt;/h1&gt;&lt;p&gt;在深入探索Windows图形编程之前，让我们先了解一个最基本的Windows窗口程序骨架。这个骨架程序包含了创建窗口、处理消息和基本绘图的全部要素：&lt;/p&gt;</summary>
    
    
    
    <category term="Windows核心编程" scheme="https://jiangxueqiao.com/categories/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="GDI" scheme="https://jiangxueqiao.com/tags/GDI/"/>
    
    <category term="GDI+" scheme="https://jiangxueqiao.com/tags/GDI/"/>
    
  </entry>
  
  <entry>
    <title>C++智能指针</title>
    <link href="https://jiangxueqiao.com/post/2579659560.html"/>
    <id>https://jiangxueqiao.com/post/2579659560.html</id>
    <published>2025-09-19T04:11:02.000Z</published>
    <updated>2025-10-20T07:21:37.706Z</updated>
    
    <content type="html"><![CDATA[<p>C++从C++11开始引入了智能指针（std::unique_ptr、std::shared_ptr、std::weak_ptr），并后面的各个版本中对智能指针进行了改进。</p><span id="more"></span><h1 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h1><p>unique_ptr为独占所有权的智能指针，不允许拷贝构造和赋值构造，仅支持std::move移动。</p><p>从C++14 起支持使用 std::make_unique 方式构造 unique_ptr，推荐使用std::make_unique 方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;Foo&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> Foo())</span></span>;</span><br><span class="line">unique_ptr&lt;Foo&gt; up2 = <span class="built_in">make_unique</span>&lt;Foo&gt;(); <span class="comment">// C++14 起支持 make_unique</span></span><br><span class="line">unique_ptr&lt;Foo&gt; up3 = std::<span class="built_in">move</span>(up1); <span class="comment">// 移动后，up1为nullptr</span></span><br><span class="line"></span><br><span class="line">unique_ptr&lt;Foo&gt; up4 = up3; <span class="comment">// 不允许拷贝，编译错误</span></span><br><span class="line"><span class="function">unique_ptr&lt;Foo&gt; <span class="title">up5</span><span class="params">(up1)</span></span>; <span class="comment">// 不允许拷贝，编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 get 方法获取原始指针</span></span><br><span class="line">Foo* f1 = up1.<span class="built_in">get</span>(); <span class="comment">// 因为up1为空，所以获取到的原始指针也为空</span></span><br><span class="line">Foo* f2 = up2.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><h2 id="删除器"><a href="#删除器" class="headerlink" title="删除器"></a>删除器</h2><p>std::unique_ptr的默认行为是使用 delete 或 delete[] 来释放其管理的资源。但当你需要管理非传统资源​（如文件句柄、数据库连接）或需要特殊的释放逻辑时，自定义删除器就变得至关重要。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_EXPORT_STD <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_Dx</span> <span class="comment">/* = default_delete&lt;_Ty&gt; */</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_ptr</span> &#123; <span class="comment">// non-copyable pointer to an object</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的unique_ptr模板类的定义可以知道，需要通过模板的第二个参数 _Dx 来指定自定义的删除器。unique_ptr的删除器通过模板参数指定，在编译期确定，这样做的好处是通常没有额外的运行时开销，但灵活性较差。</p><p>unique_ptr的删除器可以有多种指定方式，如函数对象、函数指针、std::function、lamada 表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FileCloser</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::FILE* fp)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">      std::<span class="built_in">fclose</span>(fp);</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;File closed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">customFileCloser</span><span class="params">(std::FILE* fp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">    std::<span class="built_in">fclose</span>(fp);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;File closed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::FILE* fp = std::<span class="built_in">fopen</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数对象方式，函数对象就是一个重载了 operator()的类或结构体</span></span><br><span class="line">  <span class="function">unique_ptr&lt;std::FILE, FileCloser&gt; <span class="title">up1</span><span class="params">(fp)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lamada方式，需要结合 decltype来获取 Lambda 的类型</span></span><br><span class="line">  <span class="keyword">auto</span> lamadaCloser = [](std::FILE* fp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">      std::<span class="built_in">fclose</span>(fp);</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;File closed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function">unique_ptr&lt;std::FILE, <span class="title">decltype</span><span class="params">(lamadaCloser)</span>&gt; <span class="title">up2</span><span class="params">(fp, lamadaCloser)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// std::function 方式</span></span><br><span class="line">  unique_ptr&lt;std::FILE, std::function&lt;<span class="type">void</span>(std::FILE*)&gt;&gt; <span class="built_in">up3</span>(fp, customFileCloser);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数指针方式</span></span><br><span class="line">  <span class="function">unique_ptr&lt;std::FILE, <span class="title">void</span> <span class="params">(*)</span><span class="params">(std::FILE*)</span>&gt; <span class="title">up4</span><span class="params">(fp, customFileCloser)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><p>std::shared_ptr 基于引用计数，允许多个 shared_ptr 共享同一对象的所有权。每当一个 shared_ptr 被拷贝时，引用计数加 1（可以使用<code>use_count</code>成员函数获取引用计数）。每当一个 shared_ptr 被销毁或重置时，引用计数就会减 1。当引用计数降为 0 时，所管理的对象会被自动删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 若在 new 和 shared_ptr构造间发生异常，可能出现内存泄漏</span></span><br><span class="line"><span class="function">shared_ptr&lt;Foo&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Foo())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用 make_shared，在一行代码中分配内存，效率更高，更安全</span></span><br><span class="line">shared_ptr&lt;Foo&gt; sp2 = <span class="built_in">make_shared</span>&lt;Foo&gt;(); </span><br><span class="line"></span><br><span class="line">Foo* p = sp2.<span class="built_in">get</span>(); <span class="comment">// 获取源指针</span></span><br><span class="line">sp1.<span class="built_in">reset</span>(); <span class="comment">// 将sp1置为空，sp1.use_count为0，但资源的总引用计数只会减1，此时管理的Foo不一定会被释放，取决于总引用计数是否减到0了</span></span><br><span class="line">sp2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Foo</span>()); <span class="comment">// 释放旧对象，并接管新对象的所有权</span></span><br></pre></td></tr></table></figure><p>只有在需要自定义删除器、对内存释放时机有极其苛刻的要求、处理私有构造函数或必须使用花括号初始化列表这些少数特定场景下，才考虑直接使用 new来构造 std::shared_ptr。</p><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>支持拷贝和移动，每拷贝一次，引用计数加 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Foo&gt; sp3 = sp1;  <span class="comment">// sp1和sp3共享所有权，引用计数加1</span></span><br></pre></td></tr></table></figure><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>支持使用 std::move 进行所有权移动，移动后，源 shared_ptr 变为 nullptr，但新shared_ptr的​引用计数与之前一样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;sp3 use_count: &quot;</span> &lt;&lt; sp3.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">auto</span> sp4 = std::<span class="built_in">move</span>(sp3);<span class="comment">// 转移所有权，sp3 变为空，引用计数不变</span></span><br><span class="line">cout &lt;&lt; std::boolalpha &lt;&lt; !!sp3 &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; !!sp4 &lt;&lt; endl; <span class="comment">// false, true</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sp4 use_count: &quot;</span> &lt;&lt; sp4.<span class="built_in">use_count</span>() &lt;&lt; endl;     <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="删除器-1"><a href="#删除器-1" class="headerlink" title="删除器"></a>删除器</h2><p>当需要自定义删除器时，只能使用 new 来构造shared_ptr，不能使用 make_shared。</p><p>shared_ptr 的删除器与unique_ptr不同，其不是通过模板参数指定的，而是通过函数参数指定的，因此是运行时动态存储的，虽然灵活性较高，但性能会有轻微影响。</p><p>shared_ptr 的删除器支持函数对象、lamada表达式、函数指针等形式，通过第2个参数指定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::FILE* fp = std::<span class="built_in">fopen</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> lamadaCloser = [](std::FILE* fp) &#123;</span><br><span class="line">  <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">    std::<span class="built_in">fclose</span>(fp);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;File closed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sp1 = <span class="built_in">shared_ptr</span>&lt;std::FILE&gt;(fp, lamadaCloser);</span><br></pre></td></tr></table></figure><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>当两个或多个对象互相持有对方的 shared_ptr，会导致引用计数永远无法归零，从而内存泄漏。如下面场景：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next; <span class="comment">// 使用 shared_ptr</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> node1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line"><span class="keyword">auto</span> node2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">node1-&gt;next = node2;</span><br><span class="line">node2-&gt;next = node1; <span class="comment">// 循环引用！引用计数永不归零。</span></span><br></pre></td></tr></table></figure><p>解决方案：将其中一个指针改为 std::weak_ptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  weak_ptr&lt;Node&gt; next;  <span class="comment">// 使用 weak_ptr 打破循环引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h1><p>std::weak_ptr 是 C++ 智能指针体系中一个非常独特的角色，其​必须从 std::shared_ptr 或另一个 std::weak_ptr创建，不能独立存在，主要用于解决共享所有权带来的循环引用问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 引用计数=1</span></span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">weakPtr</span><span class="params">(sharedPtr)</span></span>;      <span class="comment">// 从 shared_ptr 创建，引用计数仍为1</span></span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; anotherWeakPtr = weakPtr; <span class="comment">// 从另一个 weak_ptr 拷贝</span></span><br></pre></td></tr></table></figure><p>std::weak_ptr的核心价值在于它不拥有对象的所有权，不会增加引用计数。</p><p>使用weak_ptr可以解决shared_ptr带来的两个关键问题：</p><ul><li><p>​循环引用 (Circular Reference)​​：当两个或多个对象相互持有对方的 std::shared_ptr时，它们的引用计数永远无法降为零，导致内存泄漏。使用 std::weak_ptr替代其中一个引用可以打破循环。</p></li><li><p>​观察者模式 (Observer Pattern)​​：观察者不应控制被观察对象的生命周期。使用 std::weak_ptr允许观察者检查对象是否还存在，而不会阻止其被销毁。</p></li></ul><p><strong>必须使用 lock()方法来尝试获取一个有效的 std::shared_ptr，然后判断并使用。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> tempSharedPtr = weakPtr.<span class="built_in">lock</span>()) &#123; <span class="comment">// lock() 返回一个临时的 shared_ptr</span></span><br><span class="line">    <span class="comment">// 对象存在，可以安全使用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *tempSharedPtr &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对象已被释放</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Resource has been released.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++从C++11开始引入了智能指针（std::unique_ptr、std::shared_ptr、std::weak_ptr），并后面的各个版本中对智能指针进行了改进。&lt;/p&gt;</summary>
    
    
    
    <category term="C++语言" scheme="https://jiangxueqiao.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://jiangxueqiao.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>从C++11开始新增的常用关键字</title>
    <link href="https://jiangxueqiao.com/post/1914794883.html"/>
    <id>https://jiangxueqiao.com/post/1914794883.html</id>
    <published>2025-08-04T04:11:02.000Z</published>
    <updated>2025-09-22T03:15:43.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nullptr-C-11"><a href="#nullptr-C-11" class="headerlink" title="nullptr (C++11)"></a>nullptr (C++11)</h1><p>nullptr 专门用于表示空指针，旨在解决传统 NULL 或 0 在类型安全性和代码清晰度上的缺陷。</p><p>nullptr 的类型为 std::nullptr_t，只能隐式转换为指针类型（包括原生指针、智能指针、托管句柄等），​不能转换为整数类型，避免了与整型 0 的混淆。</p><p>而传统 NULL 是宏（通常定义为 0 或 (void*)0），可能被误解释为整数，导致类型错误。</p><span id="more"></span><p>在函数重载场景中，nullptr 可明确选择指针版本的重载函数，避免因 NULL 被解释为整数导致的错误调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;        <span class="comment">// 整型版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>*)</span></span>;       <span class="comment">// 指针版本</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(<span class="literal">nullptr</span>);         <span class="comment">// 正确调用指针版本</span></span><br></pre></td></tr></table></figure><p>而且在模板中可精确匹配指针类型，避免推导为整数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(T ptr)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;ptr type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(ptr).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">check</span>(<span class="literal">nullptr</span>);  <span class="comment">// ptr type: std::nullptr_t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="override-final-C-11"><a href="#override-final-C-11" class="headerlink" title="override&#x2F;final  (C++11)"></a>override&#x2F;final  (C++11)</h1><p>override 是一个用于显式标记派生类中重写（Override）基类虚函数的关键字。它通过强制编译器检查和增强代码可读性的方式，显著提升了继承体系的安全性和可维护性。</p><p>override 明确告知编译器和开发者：当前函数旨在重写基类的虚函数，若派生类函数签名（参数类型、const 限定、引用限定等）与基类虚函数不完全匹配，编译器会立即报错，避免隐蔽的错误。</p><p>final 关键字提供两种限制能力：</p><ul><li><p>​禁止类被继承</p><p>标记为 final 的类不可作为基类，编译时会阻止派生类继承它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">final</span> &#123; <span class="comment">/* ... */</span> &#125;; <span class="comment">// Base 类不可被继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; &#125;; <span class="comment">// ❌ 编译错误：Base 是 final 的</span></span><br></pre></td></tr></table></figure></li><li><p>禁止虚函数被重写</p><p>标记为 final 的虚函数在派生类中不可被覆盖，确保基类设计意图不被破坏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// func 不可被重写</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// ❌ 编译错误：func 是 final 的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>final 常与 override 配合使用：</p><ul><li>override：确保派生类函数正确重写基类虚函数（签名不匹配时报错）。</li><li>final：在派生类中进一步禁止后续重写。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span></span>; <span class="comment">// ✅ 重写基类函数，并禁止后续覆盖</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="constexpr-C-11"><a href="#constexpr-C-11" class="headerlink" title="constexpr (C++11)"></a>constexpr (C++11)</h1><p>constexpr 用于在编译时计算常量表达式，提升程序性能和安全性。其核心机制是将计算从运行时转移到编译时，减少运行时开销并支持编译期逻辑验证。</p><p>下面是一个在编译器计算斐波那契数列的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">factorial</span>(<span class="number">5</span>); <span class="comment">// 编译时计算结果为 120</span></span><br></pre></td></tr></table></figure><p>众所周知，在声明数组时，数组大小需要为常量，使用 constexpr 可以通过下面方式声明数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">getArraySize</span><span class="params">(<span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要C++14支持</span></span><br><span class="line">  <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">52</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> array[<span class="built_in">getArraySize</span>(<span class="number">1</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用 constexpr 时，有以下注意事项与技巧：</p><ul><li>必须用常量表达式初始化（字面值、其他 constexpr 变量等）。</li><li>constexpr 隐含 const 属性，也是常量，不可修改。</li><li>C++11 ​中函数体仅能包含单条 return 语句，但 ​C++14 以上​​可以支持循环、局部变量、条件分支、多个return等复杂逻辑。</li><li>使用 constexpr 声明的函数，仍然可以在运行时作为普通函数调用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">getArraySize</span><span class="params">(<span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">52</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> array[<span class="built_in">getArraySize</span>(<span class="number">1</span>)]; <span class="comment">// 这里的 getArraySize(1) 在编译时被求值，返回 42</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">getArraySize</span>(j) &lt;&lt; std::endl; <span class="comment">// 这里的 getArraySize(j) 在运行时被求值，返回 52</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>constexpr 也不是万能的灵丹妙药，在处理复杂计算时还需权衡编译时间成本。</li><li>可以结合使用 static_assert 来验证编译期结果，如：<code>static_assert(factorial(5) == 120, &quot;Error&quot;);</code></li></ul><h1 id="auto-C-11"><a href="#auto-C-11" class="headerlink" title="auto (C++11)"></a>auto (C++11)</h1><p>auto 用于在编译期根据初始化表达式自动推导变量类型，可以简化代码并提升可读性。</p><p>使用auto声明的变量​必须初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">42</span>;        <span class="comment">// 推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">3.14</span>;      <span class="comment">// 推导为 double</span></span><br><span class="line"><span class="keyword">auto</span> name = <span class="string">&quot;John&quot;</span>; <span class="comment">// 推导为 const char*</span></span><br></pre></td></tr></table></figure><h1 id="decltype-C-11"><a href="#decltype-C-11" class="headerlink" title="decltype (C++11)"></a>decltype (C++11)</h1><p>decltype用于查询表达式的类型，发生在编译期，且不会对表达式进行求值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) a; <span class="comment">// a 的类型为 int</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(vec.begin())</span> vectype</span>; <span class="comment">// 推导迭代器类型</span></span><br></pre></td></tr></table></figure><p>decltype在泛型编程中常用于追踪函数返回类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="thread-local-C-11"><a href="#thread-local-C-11" class="headerlink" title="thread_local (C++11)"></a>thread_local (C++11)</h1><p>thread_local用于声明线程局部存储变量，每个线程都有该变量的独立实例，线程之间不会相互干扰，从而无需额外的同步机制（如互斥锁）就能实现线程安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> counter = <span class="number">0</span>; <span class="comment">// 每个线程有自己的 counter</span></span><br></pre></td></tr></table></figure><p>根据声明thread_local变量时的作用域的不同，变量有不同的特性。</p><p>在全局作用域下声明的thread_local变量，变量是全局的，且每个线程都有该变量独立的副本。无论线程是否访问了该变量，都会在线程创建时声明该变量的副本，线程退出时释放该变量。</p><p>而在局部作用域（如函数内），虽然变量的存储期等于线程的生命周期，但链接性和作用域仍然受局部变量规则约束。这意味着它在每个线程中只初始化一次，并且在多次函数调用中保持其值，类似于 static 局部变量，但每个线程都有自己独立的一份。</p><h1 id="static-assert-C-11"><a href="#static-assert-C-11" class="headerlink" title="static_assert (C++11)"></a>static_assert (C++11)</h1><p>static_assert 编译时断言。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span> ( bool_constexpr , message )</span><br><span class="line"><span class="built_in">static_assert</span> ( bool_constexpr )    (C++<span class="number">17</span> 起)</span><br></pre></td></tr></table></figure><h1 id="noexcept-C-11"><a href="#noexcept-C-11" class="headerlink" title="noexcept (C++11)"></a>noexcept (C++11)</h1><p>noexcept用于指定函数是否可能抛出异常。它取代了 C++03 中动态异常规范 (throw())。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_func</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 表示此函数不会抛出异常</span></span><br></pre></td></tr></table></figure><p>如果 noexcept函数抛出了异常，程序会调用 std::terminate()终止。</p><p>noexcept也可以作为一个操作符，在模板中检查表达式是否可能抛出异常：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(T()))</span> </span>&#123;&#125; <span class="comment">// 根据T()是否抛出异常来决定</span></span><br></pre></td></tr></table></figure><h1 id="alignas-alignof-C-11"><a href="#alignas-alignof-C-11" class="headerlink" title="alignas&#x2F;alignof (C++11)"></a>alignas&#x2F;alignof (C++11)</h1><p>alignas用于指定变量或类型的对齐要求，而alignof用于获取类型的对齐要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alignas</span>(<span class="number">16</span>) <span class="type">int</span> arr[<span class="number">4</span>]; <span class="comment">// arr 按 16 字节对齐</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(<span class="type">int</span>) &lt;&lt; std::endl; <span class="comment">// 输出 int 的对齐值</span></span><br></pre></td></tr></table></figure><p>在 <a href="/post/4245522728.html" title="Windows内存体系(4)--内存对齐">《Windows内存体系(4)--内存对齐》</a> 中介绍了编译器的内存对齐规则，alignas允许你显式指定一个比编译器默认对齐要求更严格（更大）​​ 的对齐值。它并不能“减弱”或“改变”编译器固有的对齐规则，而是在此基础上增加新的约束。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;nullptr-C-11&quot;&gt;&lt;a href=&quot;#nullptr-C-11&quot; class=&quot;headerlink&quot; title=&quot;nullptr (C++11)&quot;&gt;&lt;/a&gt;nullptr (C++11)&lt;/h1&gt;&lt;p&gt;nullptr 专门用于表示空指针，旨在解决传统 NULL 或 0 在类型安全性和代码清晰度上的缺陷。&lt;/p&gt;
&lt;p&gt;nullptr 的类型为 std::nullptr_t，只能隐式转换为指针类型（包括原生指针、智能指针、托管句柄等），​不能转换为整数类型，避免了与整型 0 的混淆。&lt;/p&gt;
&lt;p&gt;而传统 NULL 是宏（通常定义为 0 或 (void*)0），可能被误解释为整数，导致类型错误。&lt;/p&gt;</summary>
    
    
    
    <category term="C++语言" scheme="https://jiangxueqiao.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://jiangxueqiao.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Lua杂记</title>
    <link href="https://jiangxueqiao.com/post/3843160677.html"/>
    <id>https://jiangxueqiao.com/post/3843160677.html</id>
    <published>2025-05-07T02:00:55.000Z</published>
    <updated>2025-09-22T03:16:30.757Z</updated>
    
    <content type="html"><![CDATA[<p>自从接触了 JerryScript（见<a href="/post/3353203242.html" title="开源库jerryscript使用备忘">开源库jerryscript使用备忘</a>），本以为再也不会用到 Lua 了，关于 Lua 的记忆已经逐渐在我的脑海中删除，但最近维护的几个老项目又都使用了 Lua，真是命运的捉弄啊。</p><p>来吧，刷新记忆！</p><span id="more"></span><h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><ul><li>Lua区分大小写</li><li>注释格式  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">块注释</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure></li><li>局部变量使用local声明, 其他的全部为全局变量，变量的默认值为nil</li><li>只有false和nil为假，其他的全部为真</li><li>Lua中字符串都是不可变的常量</li><li>使用<code>..</code>可以连接字符串</li><li>Lua没有整形，都是实数</li><li>可以在字符串前放置操作符<code>#</code>来获取字符串长度，某些情况下对table也适用</li><li>关系操作符: &lt; &gt; &#x3D;&#x3D; &gt;&#x3D; &lt;&#x3D;，不等于使用<code>~=</code>，而不是<code>!=</code></li><li>and, or, not 逻辑操作符返回的不一定是true和false，这点与C++不同，它返回的是对应表达式的运行结果</li><li>支持多重赋值<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- a为0， b为1， c为nil</span></span><br><span class="line">a,b,c = <span class="number">0</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li>控制结构<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">exp</span> <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- something</span></span><br><span class="line"><span class="keyword">elseif</span> <span class="built_in">exp</span> <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- something</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment">-- something</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;<span class="built_in">exp</span> is <span class="literal">true</span>&gt; <span class="keyword">do</span></span><br><span class="line">  <span class="comment">-- something</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span></span><br><span class="line">  <span class="comment">-- something</span></span><br><span class="line"><span class="keyword">until</span> &lt;<span class="built_in">exp</span> is <span class="literal">true</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var=exp1, exp2, exp3 <span class="keyword">do</span></span><br><span class="line">  <span class="comment">-- something</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">  <span class="comment">-- something</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">  <span class="comment">-- something</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h1><blockquote><p>函数也是值</p></blockquote><h2 id="2-1-多重返回值"><a href="#2-1-多重返回值" class="headerlink" title="2.1 多重返回值"></a>2.1 多重返回值</h2><p>Lua中函数可以返回多个值，但有下面的特殊情况：</p><ul><li>函数作为单独的语句时，会丢弃所有返回值</li><li>函数作为表达式的一部分时，只保留第一个返回值</li><li>在多重赋值中，函数作为最后一个表达式时，会保留尽可能多的返回值</li><li>将函数调用放在一对括号中，会迫使其只返回一个值</li></ul><h2 id="2-2-变长参数"><a href="#2-2-变长参数" class="headerlink" title="2.2 变长参数"></a>2.2 变长参数</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(...)</span></span></span><br><span class="line">  <span class="keyword">local</span> ret = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(&#123;...&#125;) <span class="keyword">do</span> <span class="comment">-- 或 for i,v in ipairs&#123;...&#125; do</span></span><br><span class="line">    ret = ret + v</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>))</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(...)</span></span></span><br><span class="line">  <span class="keyword">local</span> a,b,c = ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 跟踪函数foo的调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FooCallLog</span><span class="params">(...)</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Call foo:&quot;</span>, ...)</span><br><span class="line">  <span class="keyword">return</span> foo(...)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用函数select访问变长参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(...)</span></span></span><br><span class="line">  <span class="keyword">local</span> ret = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">select</span>(<span class="string">&quot;#&quot;</span>, ...) <span class="keyword">do</span> <span class="comment">-- select(&quot;#&quot;, ...)获取参数个数</span></span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">arg</span> = <span class="built_in">select</span>(i, ...) <span class="comment">-- select(n, ...) 获取第n个参数</span></span><br><span class="line">    ret = ret + <span class="built_in">arg</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure><h2 id="2-3-闭合（Closure）函数"><a href="#2-3-闭合（Closure）函数" class="headerlink" title="2.3 闭合（Closure）函数"></a>2.3 闭合（Closure）函数</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newCounter</span><span class="params">()</span></span> <span class="comment">-- 该函数返回一个匿名函数</span></span><br><span class="line">  <span class="keyword">local</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> <span class="comment">-- 在匿名函数内部，变量i是一个“非局部的变量”</span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">c1 = newCounter()</span><br><span class="line"><span class="built_in">print</span>(c1()) <span class="comment">-- 输出：1</span></span><br><span class="line"><span class="built_in">print</span>(c1()) <span class="comment">-- 输出：2</span></span><br><span class="line"></span><br><span class="line">c2 = newCounter()</span><br><span class="line"><span class="built_in">print</span>(c2()) <span class="comment">-- 输出：1</span></span><br></pre></td></tr></table></figure><h2 id="2-4-非全局函数"><a href="#2-4-非全局函数" class="headerlink" title="2.4 非全局函数"></a>2.4 非全局函数</h2><p>将一个函数存储到一个局部变量中，即得到了一个“局部函数”。 </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> lib=&#123;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span><span class="params">(x,y)</span></span></span><br><span class="line">  <span class="keyword">return</span> x + y </span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line">goo = <span class="function"><span class="keyword">function</span><span class="params">(x,y)</span></span> </span><br><span class="line">   <span class="keyword">return</span> x - y </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> lib=&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lib.foo</span><span class="params">(x,y)</span></span> <span class="keyword">return</span> x + y <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lib.goo</span><span class="params">(x,y)</span></span> <span class="keyword">return</span> x - y <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>对与递归程序等，为了防止局部函数为尚定义完毕，就要被编译，可以使用前置定义的方式:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> fact</span><br><span class="line">fact = <span class="function"><span class="keyword">function</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> fact(n<span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="三、编译、执行与错误"><a href="#三、编译、执行与错误" class="headerlink" title="三、编译、执行与错误"></a>三、编译、执行与错误</h1><h2 id="3-1-loadstring"><a href="#3-1-loadstring" class="headerlink" title="3.1 loadstring"></a>3.1 loadstring</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br><span class="line">f = <span class="built_in">loadstring</span>(<span class="string">&quot;local a = 10; print(a)&quot;</span>)</span><br><span class="line">f() <span class="comment">-- 输出：10</span></span><br></pre></td></tr></table></figure><h2 id="3-2-pcall"><a href="#3-2-pcall" class="headerlink" title="3.2 pcall"></a>3.2 pcall</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&quot;n need &gt; 0&quot;</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">pcall</span>(foo, <span class="number">-1</span>) <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>pcall也可以执行匿名函数。</p><h1 id="四、协同程序"><a href="#四、协同程序" class="headerlink" title="四、协同程序"></a>四、协同程序</h1><p>Lua将所有和协同程序相关的函数存储在名为“coroutine”的table中。一个协同程序可以有4种状态：suspended, running, dead, normal。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">0</span>, <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">error</span>(<span class="string">&quot;oh No.&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)) <span class="comment">-- 当创建协同程序时，其处于suspended状态</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)) <span class="comment">-- resume是在保护模式中运行的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co))</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[ 输出：</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">false D:\MyLua\Basic\coroutine.lua:5: oh No.</span></span><br><span class="line"><span class="comment">false cannot resume dead coroutine</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h1 id="五、元表与元方法"><a href="#五、元表与元方法" class="headerlink" title="五、元表与元方法"></a>五、元表与元方法</h1><p>Lua中每个值都有一个元表，table和userdata可以有各自独立的元表，而其他类型的值则共享其类型所属的单一元表。 Lua在创建新的table时不会创建元表。除了标准的字符串程序库外，其他的类型在默认情况下都没有元表。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t=&#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(t)) <span class="comment">--&gt;nil</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(<span class="string">&quot;hi&quot;</span>)) <span class="comment">--&gt; table: 0x80772e0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(<span class="number">10</span>)) <span class="comment">--&gt; nil</span></span><br></pre></td></tr></table></figure><p>可以在元表中定义的原方法(或字段)如下：</p><ul><li>__add 加</li><li>__sub 减</li><li>__mul 乘</li><li>__div 除</li><li>__unm 相反数</li><li>__mod 取模</li><li>__pow 乘幂</li><li>__eq 等于</li><li>__lt 小于</li><li>__le 大于</li><li>__concat 连接</li><li>__tostring 字符串转化</li><li>__metatable 保护元表<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line">mt.<span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line">  <span class="keyword">local</span> l = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    l[#l + <span class="number">1</span>] = e</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> .. <span class="built_in">table</span>.<span class="built_in">concat</span>(l, <span class="string">&quot;, &quot;</span>) .. <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ages = &#123;Jeff = <span class="number">18</span>, Jim = <span class="number">19</span>, Lucy = <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ages) <span class="comment">--&gt; table: 0x003286e8</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(ages, mt)</span><br><span class="line"><span class="built_in">print</span>(ages) <span class="comment">--&gt; &#123;Lucy, Jeff, Jim&#125;</span></span><br><span class="line"></span><br><span class="line">mt.<span class="built_in">__metatable</span> = <span class="string">&quot;not your business&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(ages)) <span class="comment">--&gt; not your business</span></span><br></pre></td></tr></table></figure></li><li>__index Table访问</li><li>__newindex Table更新<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 跟踪Table访问的示例</span></span><br><span class="line"><span class="keyword">local</span> index = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> mt=&#123;</span><br><span class="line"><span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, k)</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;*access to element %s, value %s&quot;</span>, k, t[index][k]))</span><br><span class="line">  <span class="keyword">return</span> t[index][k]</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line"><span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, k, v)</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;*update of element &quot;</span> .. <span class="built_in">tostring</span>(k) .. <span class="string">&quot;to &quot;</span> .. <span class="built_in">tostring</span>(v))</span><br><span class="line">  t[index][k] = v</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span><span class="params">(t)</span></span></span><br><span class="line">  <span class="keyword">local</span> proxy = &#123;&#125; <span class="comment">-- __index和__newindex都是在table中没有所需访问的index时才发挥作用</span></span><br><span class="line">  proxy[index] = t <span class="comment">-- 类似多维数组</span></span><br><span class="line">  <span class="built_in">setmetatable</span>(proxy, mt)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ages = &#123;Jeff = <span class="number">18</span>, Jim = <span class="number">19</span>, Lucy = <span class="number">20</span>&#125;</span><br><span class="line">ages = track(ages)</span><br><span class="line"><span class="built_in">print</span>(ages.Jeff)</span><br><span class="line"></span><br><span class="line">address = &#123;Jeff = <span class="string">&quot;WuHan&quot;</span>, Jim = <span class="string">&quot;Beijin&quot;</span>, Lucy = <span class="string">&quot;Taiyuan&quot;</span>&#125;</span><br><span class="line">address = track(address);</span><br><span class="line"><span class="built_in">print</span>(address.Jim)</span><br></pre></td></tr></table></figure></li></ul><h1 id="六、模块与包"><a href="#六、模块与包" class="headerlink" title="六、模块与包"></a>六、模块与包</h1><h2 id="6-1-模块搜索"><a href="#6-1-模块搜索" class="headerlink" title="6.1 模块搜索"></a>6.1 模块搜索</h2><p>对于require(“foo”)语句，Lua会先在预定路径中搜索foo.lua，如果没有搜索到才会搜索foo.DLL。 </p><p>require在搜索Lua文件时，会在变量<code>package.path</code>存放的路径中进行搜索，Lua启动后便以环境变量<code>LUA_PATH</code>的值来初始化该变量； 而搜索DLL文件的路径则存放在<code>package.cpath</code>中，同理，Lua启动后会用<code>LUA_CPATH</code>环境变量的值来初始化该变量。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">package</span>.<span class="built_in">path</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">;.\?.lua;C:\Program Files (x86)\ZeroBrane\bin\lua\?.lua;</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><p>require会用模块名来替换每个“?”，依次匹配搜索，直到搜索成功。</p><h2 id="6-2-基本模块编写"><a href="#6-2-基本模块编写" class="headerlink" title="6.2 基本模块编写"></a>6.2 基本模块编写</h2><p>编译一个模块最简单的方法就是：创建一个table，并将所有需要导出的函数放入其中，最后返回这个table。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- file: basic_mod.lua</span></span><br><span class="line">basicmod = &#123;&#125;</span><br><span class="line"></span><br><span class="line">basicmod.name = <span class="string">&quot;basic mod&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicmod.func1</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;func1&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> basicmod</span><br></pre></td></tr></table></figure><p>调用该模块：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;basic_mod&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(basicmod.name) <span class="comment">--&gt; basic mod</span></span><br><span class="line"><span class="built_in">print</span>(basicmod.func1()) <span class="comment">--&gt; func1</span></span><br></pre></td></tr></table></figure><p>但是上面的写法会导致模块中的每个函数或成员前面都带有该模块的名称，更改模块名称会牵一发而动全身，针对这个问题，可以进行如下改进：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- file: basic_mod.lua</span></span><br><span class="line"><span class="keyword">local</span> M = &#123;&#125; <span class="comment">-- 借用一个局部table变量</span></span><br><span class="line">basicmod = M</span><br><span class="line"></span><br><span class="line">M.name = <span class="string">&quot;basic mod&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.func1</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;func1&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> basicmod</span><br></pre></td></tr></table></figure><p>实际上，可以完全避免写模块名，因为require会将模块名作为参数传递给模块：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- file: basic_mod.lua</span></span><br><span class="line"><span class="keyword">local</span> modname = ...</span><br><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"><span class="built_in">_G</span>[modname] = M</span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">loaded</span>[modname] = M</span><br><span class="line"></span><br><span class="line">M.name = <span class="string">&quot;basic mod&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.func1</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;func1&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;basic_mod&quot;</span>) <span class="comment">-- 此时模块函数存储的table名称就是模块的文件名</span></span><br><span class="line"><span class="built_in">print</span>(basic_mod.name)</span><br><span class="line"><span class="built_in">print</span>(basic_mod.func1())</span><br></pre></td></tr></table></figure><p>在Lua5.1中，提供了一个新的函数module，简化模块的编写：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>(..., <span class="built_in">package</span>.<span class="built_in">seeall</span>)</span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;basic mod&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span><span class="params">()</span></span>  <span class="comment">-- 函数前不需要加入模块名限定</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;func1&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="七、面向对象"><a href="#七、面向对象" class="headerlink" title="七、面向对象"></a>七、面向对象</h1><p>使用this（或self）参数是所有面向对象语言的核心。大多数面向对象语言都能对程序员隐藏this参数，从而使得程序员不必显示的声明这个参数。 </p><p>Lua只需要使用冒号就能隐藏该参数，冒号的作用就是在一个方法的定义中添加一个额外的隐藏参数，以及在一个方法的调用中添加一个额外的实参，冒号只是一种语法便利，并没有引入任何新的东西。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Account = &#123;balance = <span class="number">0</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account.cost</span><span class="params">(v)</span></span></span><br><span class="line">  Account.balance = Account.balance - v <span class="comment">-- 只能针对全局名称Account来工作</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Account.cost(<span class="number">100</span>) <span class="comment">-- 调用正常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Account; Account = <span class="literal">nil</span></span><br><span class="line">a.cost(<span class="number">100</span>) <span class="comment">-- 错误：attempt to index global &#x27;Account&#x27; (a nil value)    </span></span><br></pre></td></tr></table></figure><p>改进如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Account = &#123;balance = <span class="number">0</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account.cost</span><span class="params">(self, v)</span></span></span><br><span class="line">  <span class="built_in">self</span>.balance = <span class="built_in">self</span>.balance - v</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Account.cost(Account, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">a = Account; Account = <span class="literal">nil</span></span><br><span class="line">a.cost(a, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>使用冒号改进：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Account = &#123;balance = <span class="number">0</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account:cost</span><span class="params">(v)</span></span></span><br><span class="line">  <span class="built_in">self</span>.balance = <span class="built_in">self</span>.balance - v</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Account:cost(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">a = Account; Account = <span class="literal">nil</span></span><br><span class="line">a:cost(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;自从接触了 JerryScript（见&lt;a href=&quot;/post/3353203242.html&quot; title=&quot;开源库jerryscript使用备忘&quot;&gt;开源库jerryscript使用备忘&lt;/a&gt;），本以为再也不会用到 Lua 了，关于 Lua 的记忆已经逐渐在我的脑海中删除，但最近维护的几个老项目又都使用了 Lua，真是命运的捉弄啊。&lt;/p&gt;
&lt;p&gt;来吧，刷新记忆！&lt;/p&gt;</summary>
    
    
    
    <category term="编程基础" scheme="https://jiangxueqiao.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Lua" scheme="https://jiangxueqiao.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>获取其他进程的命令行参数</title>
    <link href="https://jiangxueqiao.com/post/3666245140.html"/>
    <id>https://jiangxueqiao.com/post/3666245140.html</id>
    <published>2025-04-29T04:18:41.798Z</published>
    <updated>2025-02-17T09:34:13.147Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍如何根据进程 ID 获取进程命令行参数，使用 Windows NTDLL 提供的未公开 API 实现。</p><p>由于需要使用到 Windows 应用层未公开的 API，而且这些 API 在 Windows 头文件中未提供函数定义，因此我们需要使用 <code>GetProcessAddress</code> 动态地从 ntdll.dll 中获取函数地址。</p><p>动态获取函数地址本不是一件困难的事情，但是当涉及调用函数比较多时，这个操作就显得比较繁琐了，我们可以直接使用下面的库来简化上述操作。<br><a href="https://github.com/winsoft666/ntdll">https://github.com/winsoft666/ntdll</a></p><span id="more"></span><p>下面介绍如何使用<code>ntdll</code>库来根据进程 ID 获取进程命令行参数。</p><p>首先需要包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ntdll.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>并引入对应 lib：<code>x86\ntdll.lib</code>或<code>x64\ntdll.lib</code>。</p><h2 id="拿去用吧"><a href="#拿去用吧" class="headerlink" title="拿去用吧"></a>拿去用吧</h2><p>具体获取命令行参数的方式已封装到下面<code>GetProcessCommandLine</code>函数，方便读者食用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值为0表示成功</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetProcessCommandLine</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> pid, std::wstring&amp; strResult)</span> </span>&#123;</span><br><span class="line">    BOOL result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SetLastError</span>(<span class="number">0</span>);</span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line">    PPEB ppebCopy = <span class="literal">NULL</span>;</span><br><span class="line">    PRTL_USER_PROCESS_PARAMETERS pRtlProcParamCopy = <span class="literal">NULL</span>;</span><br><span class="line">    PWSTR wBufferCopy = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">        <span class="keyword">if</span> (!hProcess)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        PROCESS_BASIC_INFORMATION basicInfo;</span><br><span class="line">        <span class="built_in">ZeroMemory</span>(&amp;basicInfo, <span class="built_in">sizeof</span>(PROCESS_BASIC_INFORMATION));</span><br><span class="line"></span><br><span class="line">        NTSTATUS status = <span class="built_in">NtQueryInformationProcess</span>(hProcess,</span><br><span class="line">            ProcessBasicInformation,</span><br><span class="line">            &amp;basicInfo,</span><br><span class="line">            <span class="built_in">sizeof</span>(PROCESS_BASIC_INFORMATION),</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        PPEB ppeb = basicInfo.PebBaseAddress;</span><br><span class="line">        ppebCopy = (PPEB)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(PEB));</span><br><span class="line">        <span class="keyword">if</span> (!ppebCopy)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        result = <span class="built_in">ReadProcessMemory</span>(hProcess,</span><br><span class="line">            ppeb,</span><br><span class="line">            ppebCopy,</span><br><span class="line">            <span class="built_in">sizeof</span>(PEB),</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        PRTL_USER_PROCESS_PARAMETERS pRtlProcParam = ppebCopy-&gt;ProcessParameters;</span><br><span class="line">        pRtlProcParamCopy = (PRTL_USER_PROCESS_PARAMETERS)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(RTL_USER_PROCESS_PARAMETERS));</span><br><span class="line">        <span class="keyword">if</span> (!pRtlProcParamCopy)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        result = <span class="built_in">ReadProcessMemory</span>(hProcess,</span><br><span class="line">            pRtlProcParam,</span><br><span class="line">            pRtlProcParamCopy,</span><br><span class="line">            <span class="built_in">sizeof</span>(RTL_USER_PROCESS_PARAMETERS),</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        PWSTR wBuffer = pRtlProcParamCopy-&gt;CommandLine.Buffer;</span><br><span class="line">        USHORT len = pRtlProcParamCopy-&gt;CommandLine.Length;</span><br><span class="line">        wBufferCopy = (PWSTR)<span class="built_in">malloc</span>(len + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (!wBufferCopy)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(wBufferCopy, <span class="number">0</span>, len + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        result = <span class="built_in">ReadProcessMemory</span>(hProcess,</span><br><span class="line">            wBuffer,</span><br><span class="line">            wBufferCopy, <span class="comment">// command line goes here</span></span><br><span class="line">            len,</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result)</span><br><span class="line">            strResult = wBufferCopy;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    DWORD dwGLE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        dwGLE = <span class="built_in">GetLastError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ppebCopy)</span><br><span class="line">        <span class="built_in">free</span>(ppebCopy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pRtlProcParamCopy)</span><br><span class="line">        <span class="built_in">free</span>(pRtlProcParamCopy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wBufferCopy)</span><br><span class="line">        <span class="built_in">free</span>(wBufferCopy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hProcess)</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dwGLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍如何根据进程 ID 获取进程命令行参数，使用 Windows NTDLL 提供的未公开 API 实现。&lt;/p&gt;
&lt;p&gt;由于需要使用到 Windows 应用层未公开的 API，而且这些 API 在 Windows 头文件中未提供函数定义，因此我们需要使用 &lt;code&gt;GetProcessAddress&lt;/code&gt; 动态地从 ntdll.dll 中获取函数地址。&lt;/p&gt;
&lt;p&gt;动态获取函数地址本不是一件困难的事情，但是当涉及调用函数比较多时，这个操作就显得比较繁琐了，我们可以直接使用下面的库来简化上述操作。&lt;br&gt;&lt;a href=&quot;https://github.com/winsoft666/ntdll&quot;&gt;https://github.com/winsoft666/ntdll&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Windows编程" scheme="https://jiangxueqiao.com/categories/Windows%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="进程" scheme="https://jiangxueqiao.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="ntdll" scheme="https://jiangxueqiao.com/tags/ntdll/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark过滤器规则速学</title>
    <link href="https://jiangxueqiao.com/post/556603567.html"/>
    <id>https://jiangxueqiao.com/post/556603567.html</id>
    <published>2025-02-22T09:28:55.000Z</published>
    <updated>2025-10-20T06:25:38.496Z</updated>
    
    <content type="html"><![CDATA[<p>Wireshark 中有两种过滤器：</p><ul><li>捕获过滤器：用于在数据包捕获阶段过滤数据包，只捕获符合条件的数据包，这样可以减少捕获不必要的数据包，从而提高性能。</li><li>显示过滤器：用于在已经捕获的数据包中过滤出符合条件的数据包进行显示，它使用的是 Wireshark 自己的语法。</li></ul><span id="more"></span><h2 id="一、捕获过滤器"><a href="#一、捕获过滤器" class="headerlink" title="一、捕获过滤器"></a>一、捕获过滤器</h2><p>在 Wireshark 的开始页面或者在捕获选型页面中选择需要捕获的网络适配器，然后输入捕获过滤器规则，设置完成之后，点击“开始”按钮即可使用该规则在对应适配器上进行网络流量抓取。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/gDR0RLia7m-TinyTu.png"></p><h3 id="1-1-BPF语法"><a href="#1-1-BPF语法" class="headerlink" title="1.1 BPF语法"></a>1.1 BPF语法</h3><p>捕获过滤器使用的是 BPF（Berkeley Packet Filter）语法，BPF语法规则如下：</p><ol><li>一个过滤表达式（expression）由一个或多个原语（primitives）组成。</li><li>一个原语（primitive）由一个或多个限定词（qualifiers）组成，限定词之间使用空格分隔。</li><li>每组限定词最后跟着值，表示最后的计算结果<strong>等于</strong>该值时条件成立，而不支持大于、小于等其他比较运算符。</li><li>原语之间使用逻辑操作符（operators）连接，逻辑操作符可以使用 and、or、not 表示，也可以使用 &amp;&amp;、||、!。</li></ol><p>如下图所示：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/kam9z21sA3-TinyTu.png"></p><p>如下面的捕获过滤器表示：只捕获源 IP地址 为 192.168.1.100 且目的 TCP 端口为 80 的数据包。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip src 192.168.1.100 and tcp dst port 80</span><br></pre></td></tr></table></figure><p>Wireshark是非常遵守网络协议的，在过滤器中的ip表示的是ip协议，而不是我们通常认为的ip地址。</p><p>各个限定词出现的先后顺序也是按照网络协议的规则而来的，比如IP协议有源地址和目标地址之说，因此针对源地址和目标地址的捕获表达式分别如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip src 192.168.1.100</span><br><span class="line">ip dest 192.168.1.101</span><br></pre></td></tr></table></figure><p>捕获过滤器不支持直接过滤应用层的协议，如http、ftp等，因为为了保证效率，在捕获时还未进行协议解析。</p><h3 id="1-2-常用捕获过滤规则"><a href="#1-2-常用捕获过滤规则" class="headerlink" title="1.2 常用捕获过滤规则"></a>1.2 常用捕获过滤规则</h3><p><strong>地址过滤</strong></p><ul><li><code>host 192.168.1.33</code>：捕获与 192.168.1.33 这个 IPv4 地址相关的所有流量。</li><li><code>host 2308:8277:420:152a:819:41f0:28fa:8862</code>： 捕获与这个 IPv6 地址相关的所有流量。</li><li><code>host www.baidu.com</code>： 捕获与域名 <a href="http://www.baidu.com/">www.baidu.com</a> 相关的所有流量。</li><li><code>ether host 52:54:99:2f:37:b1</code>： 捕获与这个 MAC 地址相关的所有流量。</li><li><code>src host 192.168.1.33</code>：只捕获<strong>源地址</strong>为 192.168.1.33 的流量。</li><li><code>dest host 192.168.1.33</code>：只捕获<strong>目标地址</strong>为 192.168.1.33 的流量。</li></ul><p><strong>端口过滤</strong></p><ul><li><code>port 8080</code>：捕获 8080 端口的流量，包括流入或流出的，这里无关使用的是哪一种传输层协议，tcp、udp还是其他，只要端口为8080就都捕获。</li><li><code>!src port 8080</code> 不捕获掉<strong>源端口</strong>为 8080 流量。</li></ul><p><strong>协议过滤</strong></p><ul><li><code>icmp</code>：只捕获 icmp 协议产生的流量。</li><li><code>!ip6</code>: 不捕获 IPv6 的流量。</li></ul><h2 id="二、显示过滤器"><a href="#二、显示过滤器" class="headerlink" title="二、显示过滤器"></a>二、显示过滤器</h2><p>显示过滤器的规则与捕获过滤器类似，但有些地方不一样。</p><p>显示过滤器的限定词之间使用<code>.</code>进行分割，而捕获过滤器使用的是空格；</p><p>捕获过滤器只支持等于这一种比较运算符，而显示过滤器支持更多的比较运算符，如<code>==</code>、<code>&gt;</code>、<code>&lt;</code>、<code>!=</code>、<code>&gt;=</code>、<code>&lt;=</code>。</p><p>虽然逻辑运算符与捕获过滤器类似，但多了一种异或运算符，使用 <code>xor</code> 表示。</p><p>下面示例表示：捕获ip源地址不等于192.168.1.1，并且tcp协议端口号为80的流量。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.src != 192.168.1.1 and tcp.port &gt; 80</span><br></pre></td></tr></table></figure><p>不同于捕获过滤器，显示过滤器的规则需要更加地明确，如：</p><ul><li>对端口号的指定需要加上协议限定词，如<code>tcp.port == 80</code>，而不能像捕获过滤器那样不管协议，只要是该端口就捕获，如 <code>port 80</code>。</li><li>显示过滤器不能使用<code>host</code>，因为 host 太笼统了，既可以表示ip源&#x2F;目标地址，也可以表示域名，在显示过滤器中可以使用 <code>ip.src</code> 、<code>ip.dest</code>或<code>http.host</code> 替代。</li></ul><p>显示过滤器支持 contains 和 matches（正则表达式），而捕获过滤器则不支持：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 过滤HTTP请求中Host头包含&quot;baidu.com&quot;的流量</span><br><span class="line">http.host contains &quot;baidu.com&quot;</span><br><span class="line"></span><br><span class="line"># 过滤TCP负载中包含&quot;password&quot;的包</span><br><span class="line">tcp contains &quot;password&quot;</span><br><span class="line"></span><br><span class="line"># 匹配以 baidu.com结尾的 Host</span><br><span class="line">http.host matches &quot;.*baidu\\.com$&quot;</span><br></pre></td></tr></table></figure><h2 id="2-1-小技巧"><a href="#2-1-小技巧" class="headerlink" title="2.1 小技巧"></a>2.1 小技巧</h2><p>显示过滤器规则有很多，我们都需要记住吗？记不住，也没必要，我们只需要记住常用的规则就可以了。</p><p>在使用Wireshark抓包时，我们可以选择报文中的某一项，点击右键，选择“作为过滤器应用”即可使用该项作为过滤器，如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wirkshark_select_filter-TinyTu.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Wireshark 中有两种过滤器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;捕获过滤器：用于在数据包捕获阶段过滤数据包，只捕获符合条件的数据包，这样可以减少捕获不必要的数据包，从而提高性能。&lt;/li&gt;
&lt;li&gt;显示过滤器：用于在已经捕获的数据包中过滤出符合条件的数据包进行显示，它使用的是 Wireshark 自己的语法。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="编程基础" scheme="https://jiangxueqiao.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Wireshark" scheme="https://jiangxueqiao.com/tags/Wireshark/"/>
    
  </entry>
  
  <entry>
    <title>2025蛇来运转</title>
    <link href="https://jiangxueqiao.com/post/2721888631.html"/>
    <id>https://jiangxueqiao.com/post/2721888631.html</id>
    <published>2025-01-20T09:20:00.000Z</published>
    <updated>2025-01-20T09:29:04.757Z</updated>
    
    <content type="html"><![CDATA[<p>写下这一行预示着2024年的工作即将结束，农历蛇年即将到来。</p><p>蛇，象征着智慧与灵动，蜿蜒前行，希望在新的一年里，面对生活的曲折，也能够以灵活的姿态应对，凭借智慧化解难题。</p><p>愿2025年蛇来运转！</p><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/shenianhongyun.png" width="100%" /></div><p>物来顺应，未来不迎。</p><p>当时不杂，既过不恋。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写下这一行预示着2024年的工作即将结束，农历蛇年即将到来。&lt;/p&gt;
&lt;p&gt;蛇，象征着智慧与灵动，蜿蜒前行，希望在新的一年里，面对生活的曲折，也能够以灵活的姿态应对，凭借智慧化解难题。&lt;/p&gt;
&lt;p&gt;愿2025年蛇来运转！&lt;/p&gt;
&lt;div style=&quot;text-alig</summary>
      
    
    
    
    <category term="杂念" scheme="https://jiangxueqiao.com/categories/%E6%9D%82%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows系统各版本占比对技术选型的影响</title>
    <link href="https://jiangxueqiao.com/post/2306363290.html"/>
    <id>https://jiangxueqiao.com/post/2306363290.html</id>
    <published>2024-11-05T05:35:00.000Z</published>
    <updated>2025-01-09T06:57:21.963Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="无法校验文章哈希">  <script id="hbeData" type="hbeData" data-hmacdigest="8fb760eff8ab7ad5612184f809df14c2d58d21227db3626892e3a94593e0fe05">49420f43dcd4ffad5e1774efbcfcadee1df58b08bd2027afeeff190f6d3914caa3f5046f3f5bad5b765f8cbb26ace04d6965f94871d34eafdab6cc28b4206ec5923d3968c22469732531493518815210892145cff461ac8a8fb2a237750d7842771878571b9008bad5d5f30e6d3ad86bb644fda522166f202c972259dfc028974b69f095caa8d5b77cd27cdedaa4ac899377d20a00be9995f7881bcd106590837ff386be93f1c195600fc5a244fd5242024464d283358d629d5a87c4d0eaae5e2d740a0e2aae6c40dc2854859529b59faa10704c399588f138db6097f16f67d8ac1d14d3755bdbe14e4f91356508b7329982a479767417beddd0509fe77f57e029a43c689b1e52663654395e320c1d3047615969ebe89793a7eee4b630f2928de8b6a63a88a3871cf91937634430faa3b86745ddbad29154a6101df9c75a082356c4cf0de32adb1676f79e344339db3cf8d1c7f5cefc092d1cedfad1c16fae5864b31085efe02d77010801d8224cb3857e2de8719e70fc6734ec47b69b186d05cccfa011002cbdb47fc6eaaa799cf078bdeb6073fd16d37c8bcd216992edd1ebba4011707a8f4e6fcd4df8811be78bf8b8109f72b2cc90e495bc3649b5bce9fe8b87a3fcdb8ccfd7466844ebe65cd6a71ae3d2263a72987685f523b9fd1b4c69e9a5ddf49f747d2883e99cc0d7c797eb8be5255189ee61942373f0c7e26bc64583ab28ff5cc4d44802597c55b5600724c3e398eef5520ca68ddb2decf045814518c6596eab4f5ffac9ebb52f5ab8ba2a00b60f9c3c7ba49e997437fc1af88ce660abcf4f30f627411f1f04d3829b3460d3cb1e911e8cee55f6f32f06ec7926dd1a4630d6f9fd6f91da9041b184aa77e4aadd053a291b668369c924df2550bf585d4986ba62ed656faef12906d6308a6450bd5846aeb2eb40ee66ee11dc855cc536717270ff5dcaaf2dd8a5723c7613dc3729f575052e867914f89ff0c8f5dff4bbe457f0cca56215e0208654f0ebfb1b12d23a5f4dc28287e6d2825ddc8de1e50302cc8d366e9d1137d85dca5de87a88e145834a99e420527fc26e89b865267dba5f54741f4a87441293edb964bd28e53f26eace6bc1aac24ba98942b99b8052b7cfbd6b94f3ef499fad333134768d2d0ae0374b3f1483e13cb514ecdc32aa6f1a07529adf59f5cdcde3eac413bb95c4afef5b4719cfa2835342b0064043f0555afbb93fcda255a99bbd3ec3acba8ad41d7525218f3c13f3d1eea5972c6eaf74edfe2313e9dde97df19291fcaf7deaaeaac0ea1581881750e8f1f4c10fe14f359a73e73158bd08c17a52704de5dfa78669d34e7d30adfb5e3ffbf7a0a243ed7d1855ae899603be66d43cc45243489399683d020e2501a9af0aaa6a86ec4b35b8a41517f27f71429de269e262baa4345e9115c08e41210c999b7a7cec809d3c088b075503f5a6732cd96b4d65821557df8242080e3882c43b1e34d3394facdd7508c3b43c682417d8a1da4b8a7304719b0da91ff0fb37576bb16a68ce296532df6c89504dedfed221055fca8fa34b164d69b9f18f6d11d2da4c921ac51501b152590b2bca2e1cda04883baa2d65f93ead7ee4e39d312f38d0fde8246dea9ec789501d96dd7f710b85a209300199d070771e77e5789dc40e61eea41a38d5d4a0881dc2972177aeb49472d660dd32e3ec9a83bc122d9d63c48c53f2d77bdd5bf0032861835bdf2d5cf0b0e1a0f8443c5380001e6d75dad4c08382d9bd23bd07bf336d4753bc7cd743034c874216f736f6d0489855e9cd2f8f50eada41f25616949c6f3ffc070ddedadb81f2224acedf7ee4c6b7f78e2a295dc950849b557bb0ba4385c910fa0fb1791c71c12c6c4205625977431fa78e3c542543e49a00390db01dd7d2b3ae7e50a9f63a96fcc1dd40e52c126a4c2c548217ef9367e1d58a87eb5b5ee841fbf9d8f391e624c050d5f9444a11fe1ec36f7b242e29494e65555b996aa1a0f766ba960794d864577ec73e7810fb6c2fc36ca3d75fb2076ef2c849593c6d7b1067316333d2577259ba84eacec00f7f46a7c6c329941cb12c0e381622c2bf42be6d747192550cafd5499ca8b8203d68f59eaf464945a4fe5a8ebbbb9259411a89dbb3f2aef3a1deb1ca7b8c5b83713aa5daa94de6d65f13b73f974e179818dcbb4f6913d483456f1d501a5b6d60c96f761619ad6bc54bd34c99985d3008253e388c138c5bc18ff2435c83ae31d49e341f28f6fbecdcacc1a4935b1bd4b1cc690f417c6526759be6acaf41b4362873822ca0272bdaf75d8b20a498f73e249730ab34565e1454fe7a0581a1be17cf2e893c13e54fd56e2eae382718ffcf21cffd3ce7fadade6ab72119ef219b7c02578a4f21e82a8091f76fde822870429e0d1bfd3e6d6946863afe2d1e89944cce59be41a228d96b6c78808a57a951c8804529f52e64c898339e3c055b165eb4f1f7bd17eb6bddc894e0ec706693e07ff251603b4d2b1bc9db6c3a24a1d7796fa3acd39076b484bfa9539f535e4bf6dbda98b8fe5840621914e9f306184b5460ae34f6eb2a5efef86e3d5c449bb494bb84</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">文章已被加密，请联系作者获取密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">文章已被加密</summary>
    
    
    
    <category term="项目管理" scheme="https://jiangxueqiao.com/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Modern CMake 简明教程（下）</title>
    <link href="https://jiangxueqiao.com/post/201509401.html"/>
    <id>https://jiangxueqiao.com/post/201509401.html</id>
    <published>2024-10-18T02:34:36.000Z</published>
    <updated>2025-01-10T12:14:42.347Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cmake.org/">CMake</a> 是一个开源、跨平台的构建系统生成器（Build-system Generator）。</p><p>本文是 Modern CMake 简明教程系列的下篇，上篇请移步至 <a href="/post/3678619994.html" title="Modern CMake 简明教程（上）">《Modern CMake 简明教程（上）》</a>，中篇请移步至 <a href="/post/2304457467.html" title="Modern CMake 简明教程（中）">《Modern CMake 简明教程（中）》</a>。</p><p>本教程默认 CMake 最低版本为 3.16，即 <code>cmake_minimum_required(VERSION 3.16)</code>。</p><span id="more"></span><h1 id="一、集成第三方库"><a href="#一、集成第三方库" class="headerlink" title="一、集成第三方库"></a>一、集成第三方库</h1><p>在项目中集成第三方库是一种非常常见的需求，CMake 提供了两种方式来集成第三方库。</p><p><strong>第一种：直接集成第三方库的源码。</strong></p><p>说到集成第三方库的源码，我们第一时间想到的可能就是将其源码直接拷贝到项目目录中，然后提交到 git 仓库，更加高级一点可能会使用 git submodule 的方式。但我以为这两种方式都不够优雅，无法很好的管理、更新依赖库，特别是在项目的依赖库的比较多时。</p><p>CMake 提供了两个模块（两种方式）来集成第三方库的源码：</p><ul><li>FetchContent<br>该模块支持在 CMake 生成项目时就下载第三方库，还会自动将第三方库添加到项目中，不需要手动调用 add_subdirectory。</li><li>ExternalProject<br>该模板支持在构建（编译）项目时下载第三方库。显然 ExternalProject 的下载时机要晚于 FetchContent 。</li></ul><p><strong>第二种：使用预编译好的第三方库。</strong></p><p>这种方式需要先单独编译安装第三方库，然后使用 find_package 查找该库，最后设置目标的相关属性，如包含目录、依赖库等。</p><h2 id="1-1-FetchContent"><a href="#1-1-FetchContent" class="headerlink" title="1.1 FetchContent"></a>1.1 FetchContent</h2><p><a href="https://cmake.org/cmake/help/latest/module/FetchContent.html">FetchContent</a> 的使用大致分为两个步骤。</p><p><strong>步骤一：</strong> 使用 FetchContent_Declare 命令记录要获取的内容，可以多次调用 FetchContent_Declare 命令来记录获取多个内容。</p><p>FetchContent_Declare 的定义如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FetchContent_Declare(</span><br><span class="line">  &lt;name&gt;</span><br><span class="line">  &lt;contentOptions&gt;...</span><br><span class="line">  [EXCLUDE_FROM_ALL]</span><br><span class="line">  [SYSTEM]</span><br><span class="line">  [OVERRIDE_FIND_PACKAGE |</span><br><span class="line">   FIND_PACKAGE_ARGS args...]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;name&gt;</code> 可以是任何不带空格的字符串，并且该名称不区分大小写，但通常我们仅使用字母、数字和下划线。</p><p>下面示例分别演示了如何从 Git 仓库、https链接、SVN仓库获取内容：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FetchContent_Declare(</span><br><span class="line">  googletest</span><br><span class="line">  GIT_REPOSITORY https://github.com/google/googletest.git</span><br><span class="line">  GIT_TAG        <span class="number">703</span>bd9caab50b139428cea1aaff9974ebee5742e <span class="comment"># release-1.10.0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  myCompanyIcons</span><br><span class="line">  URL      https://intranet.mycompany.com/assets/iconset_1.<span class="number">12</span>.tar.gz  <span class="comment"># 下载完后，会自动解压</span></span><br><span class="line">  URL_HASH MD5=<span class="number">5588</span>a7b18261c20068beabfb4f530b87</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  myCompanyCertificates</span><br><span class="line">  SVN_REPOSITORY svn+ssh://svn.mycompany.com/srv/svn/trunk/certs</span><br><span class="line">  SVN_REVISION   -r12345</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>步骤二：</strong> 调用 FetchContent_MakeAvailable 命令开始获取上面声明的内容。</p><p>如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FetchContent_MakeAvailable(googletest myCompanyIcons myCompanyCertificates)</span><br></pre></td></tr></table></figure><h3 id="1-1-1-结果"><a href="#1-1-1-结果" class="headerlink" title="1.1.1 结果"></a>1.1.1 结果</h3><p>如果 FetchContent 执行成功，下面几个变量会设置：</p><ul><li><code>&lt;lowercaseName&gt;_POPULATED</code><br>始终被设置为 TRUE</li><li><code>&lt;lowercaseName&gt;_SOURCE_DIR</code><br>目标内容的源码目录</li><li><code>&lt;lowercaseName&gt;_BINARY_DIR</code><br>目标内容的构建目录</li></ul><h3 id="1-1-2-使用代理"><a href="#1-1-2-使用代理" class="headerlink" title="1.1.2 使用代理"></a>1.1.2 使用代理</h3><p>限于国内的网络环境，在获取内容时，很可能出现下载失败的情况，此时可以尝试使用 http 和 https 代理来解决该问题。</p><p>通过设置相应的环境变量即可设置 http(s) 代理，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENV&#123;http_proxy&#125; <span class="string">&quot;http://127.0.0.1:7890&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(ENV&#123;https_proxy&#125; <span class="string">&quot;http://127.0.0.1:7890&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="1-2-find-package"><a href="#1-2-find-package" class="headerlink" title="1.2 find_package"></a>1.2 find_package</h2><p>find_package 用于查找已经安装到本机的包，将查找结果存储在 <code>&lt;PackageName&gt;_FOUND</code> 变量中（查找到包，值为 1，否则 为 0），包的安装路径存储在 <code>&lt;PackageName&gt;_DIR</code> 变量中，通常还会定义一些变量来指明包的版本、头文件目录的路径、.lib 或 .a 文件的路径等，这些变量名称的格式会根据查找方式的不同、包的不同而不同。</p><p>find_package 使用起来比较简单，通常我们只需要使用它的基础定义：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(&lt;PackageName&gt; [&lt;version&gt;] [REQUIRED] [COMPONENTS &lt;components&gt;...])</span><br></pre></td></tr></table></figure><ul><li><code>&lt;PackageName&gt;</code><br>指定包的名称，是唯一的必选参数。</li><li><code>&lt;version&gt;</code><br>指定需要查找包的版本，<code>major[.minor[.patch[.tweak]]]</code>，支持多种形式的版本，如 3、3.1、3.1.2 等，可以指定匹配大版本还是小版本匹配等，也可以通过指定 EXACT 选项来要求版本完全一致，当然也可以完全省略版本约束。</li><li>REQUIRED<br>参数用于指定该包是必须找到，如果没有找到则停止执行该 CMake 脚本。</li></ul><blockquote><p>find_package 的完整定义可以见：<a href="https://cmake.org/cmake/help/latest/command/find_package.html#full-signature">full-signature</a></p></blockquote><p>下面示例用于查找大版本为 3 的 OpenCV 包：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenCV <span class="number">3</span> REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;OpenCV_DIR = $&#123;OpenCV_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;OpenCV_INCLUDE_DIRS = $&#123;OpenCV_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;OpenCV_LIBS = $&#123;OpenCV_LIBS&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="不同的查找模式"><a href="#不同的查找模式" class="headerlink" title="不同的查找模式"></a>不同的查找模式</h3><p>find_package 有两种查找包的方式，优先使用 Module 模式，如果 Module 模式没有查找到，再使用 Config 模式查找。</p><h4 id="Module-模式"><a href="#Module-模式" class="headerlink" title="Module 模式"></a>Module 模式</h4><p>find_package 使用 Module 模式查找包就是查找 <code>Find&lt;PackageName&gt;.cmake</code> 文件的过程，会尝试在下面位置中查找该文件，优先级从高到低依次为：</p><ul><li>CMAKE_PREFIX_PATH<br>该变量是以分号分隔的列表，默认为空，由用户设置；也可以定义环境变量 CMAKE_PREFIX_PATH，环境变量 $ENV{CMAKE_PREFIX_PATH} 定义的列表会附加到 ${CMAKE_PREFIX_PATH} 变量的后面。</li><li>CMAKE_MODULE_PATH<br> 该变量也是以分号分隔的列表，默认为空，由用户设置。</li></ul><p><strong>Find&lt;PackageName&gt;.cmake 文件从何而来？</strong></p><p>如果你是库的开发者，你是不需要提供 <code>Find&lt;PackageName&gt;.cmake</code> 文件的，你只需要按照文章 <a href="/post/2304457467.html" title="Modern CMake 简明教程（中）">Modern CMake 简明教程（中）</a> “安装导出依赖项”章节介绍的那样，在安装时生成 <code>&lt;PackageName&gt;Config.cmake</code>（或 <code>&lt;lowercasePackageName&gt;-config.cmake</code> 文件）即可，该文件可以用于 find_package 的 Config 模式查找。</p><p>对于那些没有按照规范提供上述 Config 文件的库，才需要使用者来编写 <code>Find&lt;PackageName&gt;.cmake</code>，辅助查找包的安装路径。</p><h4 id="Config-模式"><a href="#Config-模式" class="headerlink" title="Config 模式"></a>Config 模式</h4><p>find_package 指令在大多情况下都是通过 Config 模式来查找到包的具体位置的。</p><p>find_package 使用 Config 模式查找包就是查找 <code>&lt;PackageName&gt;Config.cmake</code>或 <code>&lt;lowercasePackageName&gt;-config.cmake</code> 文件的过程。</p><p>在 Config 模式下，<code>&lt;PackageName&gt;</code> 可以通过 NAMES 参数来指定多个需要匹配查找的包名（PackageName），例如下面查找 Qt5 或 Qt6 的方式：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(QT NAMES Qt6 Qt5 REQUIRED COMPONENTS Widgets)</span><br></pre></td></tr></table></figure><p>而且在该模式下，find_package 查找 config 文件的步骤也非常复杂，尤其是可以根据不同开关来查找不同的路径，下面介绍几个常用的查找 config 文件的位置（完整的见官方文档），按优先级从高到低依次为：</p><ol><li>&lt;PackageName&gt;_DIR 变量或环境变量所指定的目录，默认为空。</li><li>CMAKE_PREFIX_PATH、CMAKE_FRAMEWORK_PATH、CMAKE_APPBUNDLE_PATH 变量或环境变量所指定的目录，该变量是以分号分隔的列表，默认为空。</li><li>PATH 环境变量所指定的目录，该变量是以分号分隔的列表，默认为系统 PATH 环境变量的值。如果该变量中的路径以 bin 或 sbin 结尾，则自动回退到上一级目录进行查找。</li></ol><p>与 Module 模式不同的是，在上述几个位置中，除了第 1 个指定的目录是“根目录”，CMake 只会在该目录的根目录下查找 <code>&lt;PackageName&gt;Config.cmake</code>或 <code>&lt;lowercasePackageName&gt;-config.cmake</code> 文件，不会进入其子目录中查找，如设置 OpenCV_DIR 为 <code>/home/jack</code>，CMake 只会查验如下文件：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/jack/OpenCVConfig.cmake</span><br><span class="line">/home/jack/opencv-config.cmake</span><br></pre></td></tr></table></figure><p>而第 2、3 所指定的目录都是“路径前缀”，CMake 不仅会在根目录下查找 <code>&lt;PackageName&gt;Config.cmake</code>或 <code>&lt;lowercasePackageName&gt;-config.cmake</code> 文件，还会进入其子目录内查找。当然 CMake 不会无脑的遍历所有子目录，而且只在特定的子目录内进行查找，不同系统环境下所查找的子目录也不同，具体如下表所示。</p><table><thead><tr><th>查找路径</th><th>系统环境</th></tr></thead><tbody><tr><td><code>&lt;prefix&gt;/(cmake|CMake)/</code></td><td>Windows</td></tr><tr><td><code>&lt;prefix&gt;/&lt;name&gt;*/</code></td><td>Windows</td></tr><tr><td><code>&lt;prefix&gt;/&lt;name&gt;*/(cmake|CMake)/</code></td><td>Windows</td></tr><tr><td><code>&lt;prefix&gt;/&lt;name&gt;*/(cmake|CMake)/&lt;name&gt;*/</code></td><td>Windows</td></tr><tr><td><code>&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/</code></td><td>Uninx</td></tr><tr><td><code>&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/</code></td><td>Uninx</td></tr><tr><td><code>&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/(cmake|CMake)/</code></td><td>Uninx</td></tr><tr><td><code>&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/</code></td><td>Windows、Uninx</td></tr><tr><td><code>&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/</code></td><td>Windows、Uninx</td></tr><tr><td><code>&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/(cmake|CMake)/</code></td><td>Windows、Uninx</td></tr></tbody></table><p>在上表中，<code>&lt;prefix&gt;</code>就是第 2、3 项所指定的路径前缀；<code>&lt;name&gt;</code> 为包名，不区分大小写，<code>&lt;name&gt;*</code> 的意思是包名后面还可以接一些字符，如 OpenCV-3.0。</p><h3 id="结果获取"><a href="#结果获取" class="headerlink" title="结果获取"></a>结果获取</h3><p>无论是哪种查找模式，我们都需要获取查找的结果。目前我能确定的是，这两种查找模式都会定义 <code>&lt;PackageName&gt;_FOUND</code> 和 <code>&lt;PackageName&gt;_DIR</code> 变量，对于不同的库还会定义不同的变量，如何知道他们到底定义了哪些变量呢？</p><p>我有一个粗暴但好用的方法：在调试时，遍历当前 CMake 中的所有变量。</p><p>下面 dump_all_variables 函数会输出当前 CMake 的所有变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(dump_all_variables)</span><br><span class="line">    <span class="keyword">get_cmake_property</span>(_VARS VARIABLES)</span><br><span class="line">    <span class="keyword">foreach</span> (_V <span class="variable">$&#123;_VARS&#125;</span>)</span><br><span class="line">        <span class="keyword">message</span>(STATUS <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; $&#123;_V&#125; = $&#123;$&#123;_V&#125;&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">endforeach</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump_all_variables()</span><br></pre></td></tr></table></figure><h2 id="1-3-集成-Qt"><a href="#1-3-集成-Qt" class="headerlink" title="1.3 集成 Qt"></a>1.3 集成 Qt</h2><p>在项目中集成 Qt 库需要先使用 find_package 查找 Qt 的安装位置。对于 Qt4， CMake 使用 Module 模式进行查找（<a href="https://cmake.org/cmake/help/latest/module/FindQt4.html#module:FindQt4">FindQt4.cmake</a> 由 CMake 提供），而 对于 Qt5、Qt6，则是使用 Config 模式进行查找，相应的 config 文件位于类似下面的目录中 <code>D:\Qt\5.15.2\msvc2019\lib\cmake</code>。</p><p>具体从哪些位置查找 Qt，参见上面的“find_package”章节。</p><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Qt6 COMPONENTS Widgets DBus REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(publisher publisher.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(publisher Qt6::Widgets Qt6::DBus)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Qt5 COMPONENTS Gui DBus REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(subscriber1 subscriber1.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(subscriber1 Qt5::Gui Qt5::DBus)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Qt4 REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(subscriber2 subscriber2.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(subscriber2 Qt4::QtGui Qt4::QtDBus)</span><br></pre></td></tr></table></figure><p>众所周知，编译 Qt 代码需要依赖 Qt 提供的一些工具来生成相关的 C++ 代码，如：</p><ul><li>moc<br>元对象编译器，将 Qt 扩展的 C++ 语法（如 Q_OBJECT）转换成标准 C++ 语法。</li><li>rcc<br>把 .qrc 资源文件编译成标准 C++ 代码。</li><li>uic<br>把 .ui 文件编译成标准 C++ 代码。</li></ul><p>在 CMake 中要使用这些工具并不复杂，只需要提前开启相关特性，CMake 就会自动调用相关工具。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><p>下面是一个简单的 CMake Qt 项目示例，该示例仅使用了 Qt 的 QWidget 模块。</p><p>源文件结构如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMakeLists.txt</span><br><span class="line">main.cpp</span><br><span class="line">mainwindow.cpp</span><br><span class="line">mainwindow.h</span><br><span class="line">mainwindow.ui</span><br></pre></td></tr></table></figure><p>CMakeLists.txt 内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(hello_qt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Qt5 REQUIRED COMPONENTS Widgets)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(hello_qt</span><br><span class="line">    main.cpp</span><br><span class="line">    mainwindow.cpp</span><br><span class="line">    mainwindow.h</span><br><span class="line">    mainwindow.ui</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello_qt PRIVATE Qt5::Widgets)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(MSVC)</span><br><span class="line">    <span class="keyword">target_compile_options</span>(hello_qt PRIVATE /execution-charset:utf-<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set_target_properties</span>(hello_qt PROPERTIES</span><br><span class="line">        WIN32_EXECUTABLE <span class="keyword">TRUE</span></span><br><span class="line">        VS_DEBUGGER_ENVIRONMENT <span class="string">&quot;PATH=$&#123;Qt5_DIR&#125;/../../../bin;%PATH%&quot;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(TARGETS hello_qt)</span><br></pre></td></tr></table></figure><p>在上面示例中，设置了可执行字符集为 utf-8，这种方式可以防止 Qt 在 MSVC 环境下出现中文乱码，详见之前的文章 <a href="/post/1337290471.html" title="拨开字符编码的迷雾(2)--编译器处理文件编码">拨开字符编码的迷雾(2)--编译器处理文件编码</a>。</p><p>设置 WIN32_EXECUTABLE 属性是为了让链接器使用 <code>/SUBSYSTEM:WINDOWS</code> 子系统，如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/XPxCxaXyn9-TinyTu.png"></p><p>而设置 VS_DEBUGGER_ENVIRONMENT 属性是为了设置 Visual Studio 的调试环境（如下图所示），确保在调试时能找到 Qt 的相关 dll 文件。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/BkDqAJGTBd-TinyTu.png"></p><blockquote><p>在之前的 <a href="/post/3678619994.html" title="Modern CMake 简明教程（上）">Modern CMake 简明教程（上）</a> 中已经介绍了目标属性的设置。</p></blockquote><h1 id="二、MSVC"><a href="#二、MSVC" class="headerlink" title="二、MSVC"></a>二、MSVC</h1><h2 id="2-1-设置-MSVC-运行库"><a href="#2-1-设置-MSVC-运行库" class="headerlink" title="2.1 设置 MSVC 运行库"></a>2.1 设置 MSVC 运行库</h2><p>MSVC 的运行库有 MD &#x2F; MDd 和 MT &#x2F; MTd 之分，下图是 Visual Studio 中设置运行库的界面。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/J0bRwZPcTf-TinyTu.png"></p><p>CMake 针对 MSVC 环境默认使用的是 MD &#x2F; MDd 运行库，通过下面的方式可以将运行库设置为 MT &#x2F; MTd：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要 CMake 3.15 及以上版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_MSVC_RUNTIME_LIBRARY <span class="string">&quot;MultiThreaded$&lt;$&lt;CONFIG:Debug&gt;:Debug&gt;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-2-预编译头文件"><a href="#2-2-预编译头文件" class="headerlink" title="2.2 预编译头文件"></a>2.2 预编译头文件</h2><p>CMake 在 3.16 版本中提供了 <a href="https://cmake.org/cmake/help/latest/command/target_precompile_headers.html">target_precompile_headers</a> 指令来添加预编译头文件，语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target_precompile_headers(&lt;<span class="keyword">target</span>&gt;</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [header1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [header2...] ...])</span><br></pre></td></tr></table></figure><p>在 3.16 版本之前，需要支持预编译头，可以参考网络上的解决方案：</p><p>定义 USE_MSVC_PCH 宏：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span>(USE_MSVC_PCH PCH_TARGET PCH_HEADER_FILE PCH_SOURCE_FILE)</span><br><span class="line">    <span class="keyword">if</span>(MSVC)</span><br><span class="line">        <span class="comment"># 获取预编译头文件的文件名，通常是stdafx</span></span><br><span class="line">        <span class="keyword">get_filename_component</span>(PCH_NAME <span class="variable">$&#123;PCH_HEADER_FILE&#125;</span> NAME_WE)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 生成预编译文件的路径</span></span><br><span class="line">        <span class="keyword">if</span>(CMAKE_CONFIGURATION_TYPES)</span><br><span class="line">            <span class="comment"># 如果有配置选项（Debug/Release），路径添加以及配置选项</span></span><br><span class="line">            <span class="keyword">SET</span>(PCH_DIR <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/PCH/$&#123;CMAKE_CFG_INTDIR&#125;&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>()</span><br><span class="line">            <span class="keyword">SET</span>(PCH_DIR <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/PCH&quot;</span>)</span><br><span class="line">        <span class="keyword">endif</span>()</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 创建预编译文件的路径</span></span><br><span class="line">        <span class="keyword">file</span>(<span class="keyword">MAKE_DIRECTORY</span> <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/PCH)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 设置项目属性，使用预编译头文件</span></span><br><span class="line">        <span class="keyword">set_target_properties</span>(<span class="variable">$&#123;PCH_TARGET&#125;</span> PROPERTIES COMPILE_FLAGS </span><br><span class="line">            <span class="string">&quot;/Yu$&#123;PCH_HEADER_FILE&#125; /FI$&#123;PCH_HEADER_FILE&#125; /Fp$&#123;PCH_DIR&#125;/$&#123;PCH_NAME&#125;.pch&quot;</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 预编译源文件（stdafx.cpp）设置属性，创建预编译文件</span></span><br><span class="line">        <span class="keyword">set_source_files_properties</span>(<span class="variable">$&#123;PCH_SOURCE_FILE&#125;</span> PROPERTIES COMPILE_FLAGS</span><br><span class="line">            <span class="string">&quot;/Yc$&#123;PCH_HEADER_FILE&#125;&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 把预编译文件寄到清除列表</span></span><br><span class="line">        <span class="keyword">set_directory_properties</span>(PROPERTIES</span><br><span class="line">            ADDITIONAL_MAKE_CLEAN_FILES <span class="variable">$&#123;PCH_DIR&#125;</span>/<span class="variable">$&#123;PCH_NAME&#125;</span>.pch)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br></pre></td></tr></table></figure><p>然后使用该宏添加预编译头文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE_MSVC_PCH(test_app stdafx.h stdafx.cpp)</span><br></pre></td></tr></table></figure><h1 id="三、相关资料"><a href="#三、相关资料" class="headerlink" title="三、相关资料"></a>三、相关资料</h1><p><a href="https://github.com/ttroy50/cmake-examples">https://github.com/ttroy50/cmake-examples</a></p><p><a href="https://github.com/Akagi201/learning-cmake">https://github.com/Akagi201/learning-cmake</a></p><p><a href="https://github.com/KDE/extra-cmake-modules">https://github.com/KDE/extra-cmake-modules</a></p><p><a href="https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1</a></p><p><a href="https://hsf-training.github.io/hsf-training-cmake-webpage/aio/index.html">https://hsf-training.github.io/hsf-training-cmake-webpage/aio/index.html</a></p><p><a href="https://github.com/rpavlik/cmake-modules">https://github.com/rpavlik/cmake-modules</a></p><p><a href="https://github.com/onqtam/awesome-cmake">https://github.com/onqtam/awesome-cmake</a></p><p><a href="https://github.com/Lectem/cpp-boilerplate">https://github.com/Lectem/cpp-boilerplate</a></p><p><a href="https://github.com/CLIUtils/modern_cmake">https://github.com/CLIUtils/modern_cmake</a></p><p><a href="https://github.com/dev-cafe/cmake-cookbook">https://github.com/dev-cafe/cmake-cookbook</a></p><p><a href="https://github.com/BrightXiaoHan/CMakeTutorial">https://github.com/BrightXiaoHan/CMakeTutorial</a></p><p><a href="https://cliutils.gitlab.io/modern-cmake/">https://cliutils.gitlab.io/modern-cmake/</a></p><p><a href="https://cgold.readthedocs.io/en/latest/">https://cgold.readthedocs.io/en/latest/</a></p><p><a href="https://www.siliceum.com/en/blog/post/cmake_01_cmake-basics">https://www.siliceum.com/en/blog/post/cmake_01_cmake-basics</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://cmake.org/&quot;&gt;CMake&lt;/a&gt; 是一个开源、跨平台的构建系统生成器（Build-system Generator）。&lt;/p&gt;
&lt;p&gt;本文是 Modern CMake 简明教程系列的下篇，上篇请移步至 &lt;a href=&quot;/post/3678619994.html&quot; title=&quot;Modern CMake 简明教程（上）&quot;&gt;《Modern CMake 简明教程（上）》&lt;/a&gt;，中篇请移步至 &lt;a href=&quot;/post/2304457467.html&quot; title=&quot;Modern CMake 简明教程（中）&quot;&gt;《Modern CMake 简明教程（中）》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本教程默认 CMake 最低版本为 3.16，即 &lt;code&gt;cmake_minimum_required(VERSION 3.16)&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="CMake" scheme="https://jiangxueqiao.com/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://jiangxueqiao.com/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>Modern CMake 简明教程（中）</title>
    <link href="https://jiangxueqiao.com/post/2304457467.html"/>
    <id>https://jiangxueqiao.com/post/2304457467.html</id>
    <published>2024-10-11T09:34:36.000Z</published>
    <updated>2025-01-11T09:29:15.415Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cmake.org/">CMake</a> 是一个开源、跨平台的构建系统生成器（Build-system Generator）。</p><p>本文是 Modern CMake 简明教程系列的中篇，上篇请移步 <a href="/post/3678619994.html" title="Modern CMake 简明教程（上）">《Modern CMake 简明教程（上）》</a></p><p>本教程默认 CMake 最低版本为 3.16，即 <code>cmake_minimum_required(VERSION 3.16)</code>。</p><span id="more"></span><h1 id="一、生成器表达式"><a href="#一、生成器表达式" class="headerlink" title="一、生成器表达式"></a>一、生成器表达式</h1><p>不知你是否思考过这样一个问题：我们在编译项目时，通常有不同的配置，如 Debug 和 Release，如何在不同的配置中定义不同的预编译宏、包含不同的目录、依赖不同的库呢？</p><p>其实要解决这个问题，并不困难，只需要使用到 CMake 中的 <a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html">生成器表达式</a>。我们在开源项目的 CMake 脚本中经常看到的 <code>$&lt;...&gt;</code> 这样的表达式就是生成器表达式，但通常都会嵌套使用，如 <code>$&lt;$&lt;...&gt;:...&gt;</code>。</p><p>生成器表达式通常有下面几种形式：</p><ul><li><code>$&lt;condition:true_string&gt;</code></li><li><code>$&lt;IF:condition,true_string,false_string&gt;</code></li><li><code>$&lt;BOOL:string&gt;</code></li><li>特定的语法形式，如 <code>$&lt;CONFIG:cfgs&gt;</code> 表示当前配置存在于 cfgs 列表中时，表达式结果为 1，否则为 0。</li></ul><p>前三种形式比较简单，最后一种形式虽然有多种类型，但我们通常只需要记忆几种常用的，有需要时查阅<a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#generator-expression-reference">官方文档</a>。</p><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1 $&lt;condition:true_string&gt;"></a>1.1 $&lt;condition:true_string&gt;</h2><p>condition 只允许为 0 或 1，其他任何值都会报错。</p><p>当 condition 为 1 时，表达式返回 true_string；</p><p>当 condition 为 0 时，表达式返回空字符串。</p><p>如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENABLE_JSONCPP <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(</span><br><span class="line">    my_lib PUBLIC </span><br><span class="line">    $&lt;<span class="variable">$&#123;ENABLE_JSONCPP&#125;</span>:<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/jsoncpp/<span class="keyword">include</span>&gt;  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2 $&lt;IF:condition,true_string,false_string&gt;"></a>1.2 $&lt;IF:condition,true_string,false_string&gt;</h2><p>condition 只允许为 0 或 1，其他任何值都会报错。</p><p>当 condition 为 1 时，表达式返回 true_string；</p><p>当 condition 为 0 时，表达式返回 false_string。</p><p>如下面示例，当设置了 ENABLE_JSONCPP 为 1 时，包含 jsoncpp 头文件，否则包含 rapidjson 头文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENABLE_JSONCPP <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(</span><br><span class="line">    my_lib PUBLIC </span><br><span class="line">    $&lt;<span class="keyword">IF</span>:<span class="variable">$&#123;ENABLE_JSONCPP&#125;</span>,<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/jsoncpp/<span class="keyword">include</span>,<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/rapidjson/<span class="keyword">include</span>&gt;  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="1-3"><a href="#1-3" class="headerlink" title="1.3 $&lt;BOOL:string&gt;"></a>1.3 $&lt;BOOL:string&gt;</h2><p>前面 2 种形式的 condition 都只允许为 0 或 1，这种限制未免有些呆板，如果 ENABLE_JSONCPP 的值不是 1 ，而是 ON 时，该怎么办呢？</p><p>此时可以使用 <code>$&lt;BOOL:string&gt;</code> 将其转换成 0 或 1。</p><p>何时转换成 0，何时转换成 1？可以参考前面的<a href="/post/3678619994.html" title="Modern CMake 简明教程（上）">《Modern CMake 简明教程（上）》</a> 的“条件判断”章节，在该章节中介绍的所有为假的情况都会转换成 0，其他情况则转换成 1。</p><p>该表达式的作用注定了其单独使用意义不大，通常都是和其他表达式一起使用，如将上面示例中的 ENABLE_JSONCPP 设置为 ON：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENABLE_JSONCPP <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(</span><br><span class="line">    my_lib PUBLIC </span><br><span class="line">    $&lt;<span class="keyword">IF</span>:$&lt;BOOL:<span class="variable">$&#123;ENABLE_JSONCPP&#125;</span>&gt;,<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/jsoncpp/<span class="keyword">include</span>,<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/rapidjson/<span class="keyword">include</span>&gt;  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="1-4-逻辑运算"><a href="#1-4-逻辑运算" class="headerlink" title="1.4 逻辑运算"></a>1.4 逻辑运算</h2><p>运算符表达式也支持与、或、非三种逻辑运算，语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$&lt;<span class="keyword">AND</span>:conditions&gt;</span><br><span class="line"></span><br><span class="line">$&lt;<span class="keyword">OR</span>:conditions&gt;</span><br><span class="line"></span><br><span class="line">$&lt;<span class="keyword">NOT</span>:condition&gt;</span><br></pre></td></tr></table></figure><p>其中，condition 都只允许是 0 或 1，conditions（复数形式）表示可以是由逗号分割的多个条件列表。</p><h2 id="1-5-其他常见表达式条件"><a href="#1-5-其他常见表达式条件" class="headerlink" title="1.5 其他常见表达式条件"></a>1.5 其他常见表达式条件</h2><p>CMake 还支持很多类型的生成器表达式，下面列举了一些常见的表达式，这些表达式通常都是用来作为上面介绍的表达式中的条件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串比较，string1 与 string2 相等则为 1，反之为 0</span></span><br><span class="line">$&lt;<span class="keyword">STREQUAL</span>:string1,string2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数值比较，相等为 1，反之为 0</span></span><br><span class="line">$&lt;<span class="keyword">EQUAL</span>:value1,value2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本比较，v1 小于 v2 时为 1，反之为 0</span></span><br><span class="line">$&lt;<span class="keyword">VERSION_LESS</span>:v1,v2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他版本比较</span></span><br><span class="line">$&lt;<span class="keyword">VERSION_GREATER</span>:v1,v2&gt;</span><br><span class="line">$&lt;<span class="keyword">VERSION_EQUAL</span>:v1,v2&gt;</span><br><span class="line">$&lt;<span class="keyword">VERSION_LESS_EQUAL</span>:v1,v2&gt;</span><br><span class="line">$&lt;<span class="keyword">VERSION_GREATER_EQUAL</span>:v1,v2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># string 存在于 list列表中时为 1，反之为 0</span></span><br><span class="line">$&lt;<span class="keyword">IN_LIST</span>:<span class="keyword">string</span>,<span class="keyword">list</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前配置名称</span></span><br><span class="line">$&lt;CONFIG&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前配置存在于cfgs列表中时为 1，反之为 0</span></span><br><span class="line">$&lt;CONFIG:cfgs&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平台ID，见 CMAKE_SYSTEM_NAME</span></span><br><span class="line">$&lt;PLATFORM_ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前平台ID存在于 platform_ids 列表中时为 1，反之为 0</span></span><br><span class="line">$&lt;PLATFORM_ID:platform_ids&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># C++编译器版本</span></span><br><span class="line">$&lt;CXX_COMPILER_VERSION&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># C++编译器版本与 version 匹配时为 1，反之为 0</span></span><br><span class="line"><span class="comment"># $&lt;CXX_COMPILER_VERSION:version&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前的C++编译器ID</span></span><br><span class="line">$&lt;CXX_COMPILER_ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前的C++编译器ID存在于 compiler_ids 列表中时为 1，反之为 0</span></span><br><span class="line">$&lt;CXX_COMPILER_ID:compiler_ids&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标存在时为 1，反之为 0</span></span><br><span class="line">$&lt;TARGET_EXISTS:tgt&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回tgt目标的prop属性的值，如果未设置该属性，则返回空字符串</span></span><br><span class="line">$&lt;TARGET_PROPERTY:tgt,prop&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回正在计算表达式的目标上的prop属性的值，如果未设置该属性，则返回空字符串</span></span><br><span class="line">$&lt;TARGET_PROPERTY:prop&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当使用 install(EXPORT) 导出属性时，返回 ... 内容，否则返回空</span></span><br><span class="line">$&lt;INSTALL_INTERFACE:...&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当使用 export()导出属性或者被同一构建系统内的另一个目标使用时，返回 ... 内容，否则返回空</span></span><br><span class="line">$&lt;BUILD_INTERFACE:...&gt;</span><br></pre></td></tr></table></figure><h2 id="1-6-转义字符"><a href="#1-6-转义字符" class="headerlink" title="1.6 转义字符"></a>1.6 转义字符</h2><p>在生成器表达式中如果需要使用特殊字符，可以使用其转移字符。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt;</span></span><br><span class="line">$&lt;ANGLE-R&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ,</span></span><br><span class="line">$&lt;COMMA&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ;</span></span><br><span class="line">$&lt;SEMICOLON&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;</span></span><br><span class="line"><span class="comment"># 需要 CMake &gt;= 3.30</span></span><br><span class="line">$&lt;QUOTE&gt;</span><br></pre></td></tr></table></figure><h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><p>侠义的“安装”是将<strong>目标编译生成的文件</strong>拷贝到<strong>指定位置</strong>，CMake 中的安装包含但不限于拷贝文件，还可以执行脚本、修改权限等操作。</p><p>上面这句话中，涉及到了2个术语，有必要解释一下。</p><p>“目标编译生成的文件”在 CMake 中有个学名，叫 <a href="https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#output-artifacts">Output Artifacts</a>，直译为输出工件，我更愿意将其翻译为“输出品”，不同类型的目标有不同的输出品，例如在 Windows 平台上，可执行程序输出 .exe 文件，动态库输出 .dll 文件（也可能包含 .lib 文件），静态库输出 .lib 文件…..</p><blockquote><p>请牢记 Artifacts 这个单词，在后面的很多定义中都会出现该词。</p></blockquote><p>“指定位置”，顾名思义，我们可以指定一个安装位置。CMake 会从 <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html">CMAKE_INSTALL_PREFIX</a> 变量中读取安装位置，该变量有默认值，我们也可以修改该变量来改变安装位置。</p><p>在不同的操作系统上，CMAKE_INSTALL_PREFIX 的默认值不同：</p><ul><li>Windows 系统：<code>C:/Program Files/$&#123;PROJECT_NAME&#125;</code><br>写入该目录需要管理员权限，因此如果安装失败，请检查是否具有管理员权限。</li><li>UNIX 系统：<code>/usr/local</code></li></ul><p>CMAKE_INSTALL_PREFIX 指定的位置是安装目录的根目录，不同类型的输出品会存放在其不同的子目录中，如 .lib 文件存放在 lib 目录，.dll 和 .exe 文件存放在 bin 目录，头文件存放在 include 目录，这些子目录的具体名称可以通过 <a href="https://cmake.org/cmake/help/latest/module/GNUInstallDirs.html">GNUInstallDirs</a> 提供的若干变量来获取，如 <code>CMAKE_INSTALL_BINDIR</code>、<code>CMAKE_INSTALL_LIBDIR</code>、<code>CMAKE_INSTALL_INCLUDEDIR</code> 等。</p><p>CMake 定义了下列常用的输出品种类（artifact-kind），这些种类在后面的 install 选项中会使用到：</p><ul><li>ARCHIVE<br>这种类型的输出品包含下列文件（默认位于 lib 目录）：   <ul><li>静态库，Windows 上是 .lib 文件，Linux 上是 .a 文件，但在 macOS 上标记为 FRAMEWORK 的除外。</li><li>动态库的导入库，如 .lib 文件。</li><li>在macOS系统上，为启用 ENABLE_EXPORTS 的共享库所创建的链接器导入文件（但标记为 FRAMEWORK 的情况除外）。</li></ul></li><li>LIBRARY<br>这种类型的输出品很少用到。</li><li>RUNTIME<br>这种类型的输出品包含下来文件（默认位于 bin 目录）：   <ul><li>各个系统所支持的可执行文件，如 Windows 上的 .exe。</li><li>动态库，如 .dll 和 .so 文件。</li></ul></li><li>OBJECTS<br>与对象库（使用<code>add_library(&lt;name&gt; OBJECT ...)</code>方式定义）关联的对象文件。</li><li>FRAMEWORK<br>在 macOS 上，标有 FRAMEWORK 属性的静态库和共享库都被视为 FRAMEWORK 类型。</li><li>BUNDLE<br>在 macOS 上，标有 MACOSX_BUNDLE 属性的可执行文件被视为 BUNDLE 类型。</li><li>PUBLIC_HEADER  </li><li>PRIVATE_HEADER</li></ul><h2 id="2-1-install"><a href="#2-1-install" class="headerlink" title="2.1 install"></a>2.1 install</h2><p>使用 <a href="https://cmake.org/cmake/help/latest/command/install.html">install</a> 指令可以定义在安装时需要执行的操作，install 可以定义很多类型的操作，包含但不限于拷贝输出品到指定位置、执行脚本等。</p><p>下面是 install 指令支持的调用形式：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS &lt;<span class="keyword">target</span>&gt;... [...])</span><br><span class="line"><span class="keyword">install</span>(IMPORTED_RUNTIME_ARTIFACTS &lt;<span class="keyword">target</span>&gt;... [...])</span><br><span class="line"><span class="keyword">install</span>(&#123;FILES | PROGRAMS&#125; &lt;<span class="keyword">file</span>&gt;... [...])</span><br><span class="line"><span class="keyword">install</span>(DIRECTORY &lt;dir&gt;... [...])</span><br><span class="line"><span class="keyword">install</span>(SCRIPT &lt;<span class="keyword">file</span>&gt; [...])</span><br><span class="line"><span class="keyword">install</span>(CODE &lt;code&gt; [...])</span><br><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> &lt;<span class="keyword">export</span>-name&gt; [...])</span><br><span class="line"><span class="keyword">install</span>(RUNTIME_DEPENDENCY_SET &lt;<span class="keyword">set</span>-name&gt; [...])</span><br></pre></td></tr></table></figure><p>通过执行 <code>make install</code> 命令或者编译 CMake 生成的 INSTALL 项目，就可以执行 install 指令预先定义的安装操作。</p><h2 id="2-2-不同的安装命令"><a href="#2-2-不同的安装命令" class="headerlink" title="2.2 不同的安装命令"></a>2.2 不同的安装命令</h2><h3 id="2-2-1-安装-Target"><a href="#2-2-1-安装-Target" class="headerlink" title="2.2.1 安装 Target"></a>2.2.1 安装 Target</h3><p>所谓安装 Target 就是将目标的输出品及其关联文件拷贝到指定位置。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS &lt;<span class="keyword">target</span>&gt;... [<span class="keyword">EXPORT</span> &lt;<span class="keyword">export</span>-name&gt;]</span><br><span class="line">        [RUNTIME_DEPENDENCIES &lt;arg&gt;...|RUNTIME_DEPENDENCY_SET &lt;<span class="keyword">set</span>-name&gt;]</span><br><span class="line">        [&lt;artifact-<span class="keyword">option</span>&gt;...]</span><br><span class="line">        [&lt;artifact-kind&gt; &lt;artifact-<span class="keyword">option</span>&gt;...]...</span><br><span class="line">        [INCLUDES DESTINATION [&lt;dir&gt; ...]]</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><code>&lt;artifact-option&gt;</code> 用于指定与输出品相关的选项，可以是下面选项中的一个或多个（常用的选项主要是 DESTINATION 和 PERMISSIONS）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[DESTINATION &lt;dir&gt;]</span><br><span class="line">[PERMISSIONS &lt;permission&gt;...]</span><br><span class="line">[CONFIGURATIONS &lt;config&gt;...]</span><br><span class="line">[COMPONENT &lt;component&gt;]</span><br><span class="line">[NAMELINK_COMPONENT &lt;component&gt;]</span><br><span class="line">[OPTIONAL] [EXCLUDE_FROM_ALL]</span><br><span class="line">[NAMELINK_ONLY|NAMELINK_SKIP]</span><br></pre></td></tr></table></figure><p>第一组 <code>&lt;artifact-option&gt;</code> 所设置的选项应用于在本次调用中没有指定输出品类型时。</p><p>我们通常会为不同类型的输出品指定不同的选项，如下面示例为不同类型的输出品指定了不同的安装位置：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(hello_cmake PROPERTIES PUBLIC_HEADER <span class="keyword">include</span>/my_lib.h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(TARGETS hello_cmake</span><br><span class="line">    ARCHIVE DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>  <span class="comment"># 仅为演示，这样写多此一举</span></span><br><span class="line">    RUNTIME DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span>  <span class="comment"># 仅为演示，这样写多此一举</span></span><br><span class="line">    PUBLIC_HEADER DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span>/my_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>在实际项目中，我们不会使用 PUBLIC_HEADER 来安装头文件，而是使用下面介绍的 <code>install(DIRECTORY ... )</code> 命令。</p></blockquote><h4 id="EXPORT选项"><a href="#EXPORT选项" class="headerlink" title="EXPORT选项"></a>EXPORT选项</h4><p><code>EXPORT</code> 是一个非常有用的选项，当我们的项目需要作为库被第三方使用时，为了让第三方能够通过 find_package 所查找到所安装的库，就需要在安装时生成 <code>xxxConfig.cmake</code> 文件。</p><p>当然，仅仅通过在此指定 EXPORT 选项还不够，此处的 EXPORT 选项仅仅表示将 Target 所安装的输出品绑定到 <code>&lt;export-name&gt;</code> 上，后面我们还需要使用单独的 <code>install(EXPORT ...)</code> 语句来生成 <code>xxxConfig.cmake</code> 文件，详见下面的 “安装导出依赖项” 节。</p><h3 id="2-2-2-拷贝目录"><a href="#2-2-2-拷贝目录" class="headerlink" title="2.2.2 拷贝目录"></a>2.2.2 拷贝目录</h3><p>拷贝目录到指定位置，语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY dirs...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br><span class="line">        [FILE_PERMISSIONS &lt;permission&gt;...]</span><br><span class="line">        [DIRECTORY_PERMISSIONS &lt;permission&gt;...]</span><br><span class="line">        [USE_SOURCE_PERMISSIONS] [OPTIONAL] [MESSAGE_NEVER]</span><br><span class="line">        [CONFIGURATIONS &lt;config&gt;...]</span><br><span class="line">        [COMPONENT &lt;component&gt;] [EXCLUDE_FROM_ALL]</span><br><span class="line">        [FILES_MATCHING]</span><br><span class="line">        [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]</span><br><span class="line">         [EXCLUDE] [PERMISSIONS &lt;permission&gt;...]] [...])</span><br></pre></td></tr></table></figure><p>可以使用 TYPE 或 DESTINATION 来指定目标路径，其中 TYPE 的取值来自于 <a href="https://cmake.org/cmake/help/latest/module/GNUInstallDirs.html">GNUInstallDirs</a> 提供的若干变量，如 BIN 等同于 CMAKE_INSTALL_BINDIR 变量。</p><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY ./common TYPE <span class="keyword">INCLUDE</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(DIRECTORY ./common DESTINATION <span class="string">&quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-3-拷贝文件"><a href="#2-2-3-拷贝文件" class="headerlink" title="2.2.3 拷贝文件"></a>2.2.3 拷贝文件</h3><p>拷贝文件到指定位置，语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(FILES &lt;<span class="keyword">file</span>&gt;...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br><span class="line">        [PERMISSIONS &lt;permission&gt;...]</span><br><span class="line">        [CONFIGURATIONS &lt;config&gt;...]</span><br><span class="line">        [COMPONENT &lt;component&gt;]</span><br><span class="line">        [RENAME &lt;name&gt;] [OPTIONAL] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure><h3 id="2-2-4-执行脚本"><a href="#2-2-4-执行脚本" class="headerlink" title="2.2.4 执行脚本"></a>2.2.4 执行脚本</h3><p>在安装时执行脚本文件或者脚本代码，语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>([[SCRIPT &lt;<span class="keyword">file</span>&gt;] [CODE &lt;code&gt;]]</span><br><span class="line">        [ALL_COMPONENTS | COMPONENT &lt;component&gt;]</span><br><span class="line">        [EXCLUDE_FROM_ALL] [...])</span><br></pre></td></tr></table></figure><p>如果脚本文件的路径是相对路径，则该路径相对于当前项目的根目录（即 CMAKE_SOURCE_DIR 变量存储的路径）。</p><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(SCRIPT <span class="string">&quot;./my_lib/helper.cmake&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(CODE <span class="string">&quot;message(\&quot;Sample install message.\&quot;)&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-5-安装导出依赖项"><a href="#2-2-5-安装导出依赖项" class="headerlink" title="2.2.5 安装导出依赖项"></a>2.2.5 安装导出依赖项</h3><p>如果在安装 Target（见上面的5.2.1节） 时已经指定了 EXPORT 选项，则可以通过 <code>install(EXPORT ...)</code> 的形式来安装需要导出的依赖性，即生成 <code>xxxConfig.cmake</code> 文件，该文件名不是固定的，可以通过 FILE 选项来指定其他名称，但必须是 <code>.cmake</code> 类型的文件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> &lt;<span class="keyword">export</span>-name&gt; DESTINATION &lt;dir&gt;</span><br><span class="line">        [NAMESPACE &lt;namespace&gt;] [<span class="keyword">FILE</span> &lt;name&gt;.cmake]</span><br><span class="line">        [PERMISSIONS &lt;permission&gt;...]</span><br><span class="line">        [CONFIGURATIONS &lt;config&gt;...]</span><br><span class="line">        [CXX_MODULES_DIRECTORY &lt;directory&gt;]</span><br><span class="line">        [EXPORT_LINK_INTERFACE_LIBRARIES]</span><br><span class="line">        [COMPONENT &lt;component&gt;]</span><br><span class="line">        [EXCLUDE_FROM_ALL]</span><br><span class="line">        [EXPORT_PACKAGE_DEPENDENCIES])</span><br></pre></td></tr></table></figure><p><code>&lt;export-name&gt;</code> 选项所指定的名称需要与在 <code>install(TARGET ... EXPORT ...)</code> 语句中指定名称一致。</p><p>通常为了防止和其他库命名冲突，我们会使用 NAMESPACE 添加命名空间。</p><p>在生成 <code>xxxConfig.cmake</code> 文件以后，就可以使用 <code>find_package</code> 来查找并引用依赖库了：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(MyLib REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(OtherApp PRIVATE my_lib::my_lib)</span><br></pre></td></tr></table></figure><h1 id="三、与-CMake-交互"><a href="#三、与-CMake-交互" class="headerlink" title="三、与 CMake 交互"></a>三、与 CMake 交互</h1><p>CMake 与构建项目交互的方式有两种:</p><ol><li>使用 <a href="https://cmake.org/cmake/help/latest/command/configure_file.html">configure_file</a> 指令动态生成配置文件，通过配置文件的方式来将数据传递给项目，如在 C&#x2F;C++ 项目中动态生成 .h 文件。</li><li>使用 <a href="https://cmake.org/cmake/help/latest/command/file.html">file</a> 指令创建配置文件，file 指令的功能非常强大，包含众多与文件相关的操作，如读写文件、下载上传文件、遍历目录等。</li></ol><p>本节只介绍 <a href="https://cmake.org/cmake/help/latest/command/configure_file.html">configure_file</a> 指令，该指令用于根据模板文件在指定位置生成新的文件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configure_file</span>(&lt;input&gt; &lt;output&gt;</span><br><span class="line">               [NO_SOURCE_PERMISSIONS | USE_SOURCE_PERMISSIONS |</span><br><span class="line">                FILE_PERMISSIONS &lt;permissions&gt;...]</span><br><span class="line">               [COPYONLY] [ESCAPE_QUOTES] [@ONLY]</span><br><span class="line">               [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])</span><br></pre></td></tr></table></figure><p>我们首先需要通过 <code>&lt;input&gt;</code> 选项来指定一个模板文件，虽然模板文件可以是任意的后缀名，但我们通常使用 <code>.in</code> 后缀名，例如我们需要通过模板文件生成 version.h 文件，则模板文件名为 <code>version.h.in</code>。</p><p>configure_file 指令会将 <code>&lt;input&gt;</code> 模板文件中的诸如 <code>@VAR@</code>、<code>$&#123;VAR&#125;</code>、<code>$CACHE&#123;VAR&#125;</code>、<code>$ENV&#123;VAR&#125;</code> 形式的变量都替换为对应变量的值，如果变量没有被定义，则替换为空字符串。</p><p>我们通常还会指定 <code>@ONLY</code> 选项，指定该选项后，就只有 <code>@VAR@</code> 形式的变量会被替换，而其他形式的变量会保留不变，这种方式虽然在生成 .h 文件时没有什么用途，但谁又说 configure_file 只能生成 .h 文件了？如果是生成 .cmake 文件，是不是就有作用了咧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version.h.in</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION_MAJOR @VERSION_MAJOR@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION_MINOR @VERSION_MINOR@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION_PATCH @VERSION_PATCH@</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUILD_TIMESTAMP <span class="string">&quot;@BUILD_TIMESTAMP@&quot;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span>(TIMESTAMP BUILD_TIMESTAMP <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(VERSION_MAJOR <span class="number">1</span>)</span><br><span class="line"><span class="keyword">set</span>(VERSION_MINOR <span class="number">0</span>)</span><br><span class="line"><span class="keyword">set</span>(VERSION_PATCH <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">configure_file</span> (</span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/include/version.h.in&quot;</span></span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/include/version.h&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行 CMake 脚本，动态生成的 version.h 内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION_MAJOR 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION_MINOR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION_PATCH 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUILD_TIMESTAMP <span class="string">&quot;2024-09-30 16:51:57&quot;</span></span></span><br></pre></td></tr></table></figure><p>上述变量替换的方式有一个弊端：虽然能动态替换模板语句中变量的值，但却不能控制语句是否存在。比如我们经常在 C&#x2F;C++ 项目中根据宏是否被定义来做判断，而不是根据宏的值来做判断：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> BUILD_SHARED_LIBS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个是时候就需要使用另外一个语法形式了：<code>#cmakedefine VAR ...</code>，在这种形式中是直接使用变量名的，而不需要使用 <code>@ @</code> 进行包裹。</p><p>当定义了 VAR 变量时，将替换为（…就是模板文件中 VAR 后面的内容）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VAR ...</span></span><br></pre></td></tr></table></figure><p>当没有定义 VAR 变量时，将替换为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* #undef VAR */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://cmake.org/&quot;&gt;CMake&lt;/a&gt; 是一个开源、跨平台的构建系统生成器（Build-system Generator）。&lt;/p&gt;
&lt;p&gt;本文是 Modern CMake 简明教程系列的中篇，上篇请移步 &lt;a href=&quot;/post/3678619994.html&quot; title=&quot;Modern CMake 简明教程（上）&quot;&gt;《Modern CMake 简明教程（上）》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本教程默认 CMake 最低版本为 3.16，即 &lt;code&gt;cmake_minimum_required(VERSION 3.16)&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="CMake" scheme="https://jiangxueqiao.com/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://jiangxueqiao.com/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>Modern CMake 简明教程（上）</title>
    <link href="https://jiangxueqiao.com/post/3678619994.html"/>
    <id>https://jiangxueqiao.com/post/3678619994.html</id>
    <published>2024-10-08T09:30:36.000Z</published>
    <updated>2025-01-10T12:14:48.299Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cmake.org/">CMake</a> 是一个开源、跨平台的构建系统生成器（Build-system Generator）。</p><p>CMake 是构建系统生成器，而不是构建系统，CMake 支持生成不同构建系统所支持的工程文件，如 Visual Studio，XCode，Makefile 等。</p><p>本教程作为 CMake 的简明教程，不会事无巨细的讲述 CMake 的每一个语法，而是以实用为目的，介绍 CMake 的基础语法和常用指令。</p><p>虽然只是简明教程，但通过本教程，你仍然可以掌握 CMake 的脉络，熟练应用 CMake 于项目中。</p><span id="more"></span><h1 id="一、Modern-CMake"><a href="#一、Modern-CMake" class="headerlink" title="一、Modern CMake"></a>一、Modern CMake</h1><p>CMake 距今已有 20 多年的历史，CMake 从 3.0 开始引入 Target 概念，有了 Target 和 Property 的定义，CMake 也就更加地现代化。</p><p>我们将引入 Target 概念之前（也就是 3.0 之前）的 CMake 称之为老式 CMake，之后的称之为现代 CMake（Modern CMake）。</p><p>现代 CMake 是围绕 Target 和 Property 来定义的，在现代 CMake 中不应该出现诸如下面的指令：</p><ul><li>add_compile_options</li><li>include_directories</li><li>link_directories</li><li>link_libraries</li></ul><p>因为这些指令都是目录级别的，在该目录（含子目录）上定义的所有目标都会继承这些属性，这样会导致出现很多隐藏依赖和多余属性的情况。</p><p>我们最好直接针对 Target 进行操作，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 老式写法</span></span><br><span class="line"><span class="keyword">include_directories</span>(./<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现代写法</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(hello PRIVATE ./<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p><strong>本文讲述的知识点只适用于现代 CMake，让我们脱掉沉重的历史包袱，轻装上阵吧！</strong></p><h1 id="二、基础概念"><a href="#二、基础概念" class="headerlink" title="二、基础概念"></a>二、基础概念</h1><p>所有的构建系统都需要通过某个入口点来定义项目（如 Visual Studio 的 .sln 文件），CMake 作为构建系统生成器也不例外，CMake 使用的是 <code>CMakeLists.txt</code> 的文件，该文件以 UTF-8 编码（也支持 UTF-8 BOM 文件头），其中存储了符合 CMake 语言规范的脚本代码。</p><h2 id="2-1-项目结构"><a href="#2-1-项目结构" class="headerlink" title="2.1 项目结构"></a>2.1 项目结构</h2><p>CMake 没有强制规定 CMakeLists.txt 文件的位置以及项目的目录结构，但目前大多数项目都会采用相似的目录结构。</p><p>如果项目名称为 my_project，且该项目包含一个名为 lib 的库和一个名为 app 的程序，则目录结构通常如下面所示：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- my_project</span><br><span class="line">  - .gitignore</span><br><span class="line">  - README.md</span><br><span class="line">  - LICENSE.md</span><br><span class="line">  - CMakeLists.txt</span><br><span class="line">  - cmake</span><br><span class="line">    - FindSomeLib.cmake</span><br><span class="line">    - something_else.cmake</span><br><span class="line">  - include</span><br><span class="line">    - my_project</span><br><span class="line">      - lib.h</span><br><span class="line">  - src</span><br><span class="line">    - CMakeLists.txt</span><br><span class="line">    - lib.cpp</span><br><span class="line">  - apps</span><br><span class="line">    - CMakeLists.txt</span><br><span class="line">    - app.cpp</span><br><span class="line">  - tests</span><br><span class="line">    - CMakeLists.txt</span><br><span class="line">    - testlib.cpp</span><br><span class="line">  - docs</span><br><span class="line">    - CMakeLists.txt</span><br><span class="line">  - extern</span><br><span class="line">    - googletest</span><br><span class="line">  - scripts</span><br><span class="line">    - helper.py</span><br></pre></td></tr></table></figure><p>当然，上面的名称并不是一成不变的，可以根据自己的喜好来定义，例如 my_project 可以是任意的项目名，如果不喜欢复数，可以将 tests 改成test，如果没有 python 代码，也可以移除 python 目录，cmake 目录则用于存放 CMake 辅助脚本。</p><p>从上面的目录结构可以看到，CMakeLists.txt 文件分散在各个子目录中，但在 include 目录中没有 CMakeList.txt 文件，这样是为了防止暴露不必要的文件给库的使用者，因为 include 目录中存放的是库的头文件，在安装时通常都会将该目录拷贝到指定位置（如Linux系统的 &#x2F;usr&#x2F;include）。</p><p>extern 目录用于存放第三方依赖库的源码，这些库可以通过 <code>git submodule</code> 的形式来管理，也可以直接将源码拷贝到此，并提交到项目 git 中。但无论使用哪种方式，依赖库最好能支持 CMake，这样可以方便的使用 <code>add_subdirectory</code> 命令将项目添加到工程中（如果你对 add_subdirectory 命令的具体用法还不了解，这没关系，现在你只需要知道该命令可以添加任何包含 CMakeLists.txt 的目录到项目中即可）。</p><h2 id="2-2-一个简单的示例"><a href="#2-2-一个简单的示例" class="headerlink" title="2.2 一个简单的示例"></a>2.2 一个简单的示例</h2><p>在学习 CMake 之前，我们先将 CMake 玩起来。我们先从一个简单的示例开始，了解 CMake 的基本玩法。</p><p>该示例是只包含一个 main.cpp 文件，我们期望编译该文件能生成 hello_cmake 程序。</p><p>目录结构如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- hello_cmake</span><br><span class="line">  - main.cpp</span><br><span class="line">  - CMakeLists.txt</span><br></pre></td></tr></table></figure><p>main.cpp 文件的内容非常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello cmake&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMakeLists.txt 内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 CMake 的最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目名称</span></span><br><span class="line"><span class="keyword">project</span> (hello_cmake)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个名为 hello_cmake 的目标</span></span><br><span class="line"><span class="comment"># 目标类型为可执行文件</span></span><br><span class="line"><span class="comment"># 使用 main.cpp 来编译生成 hello_cmake 可执行文件（如hello_cmake.exe）</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello_cmake main.cpp)</span><br></pre></td></tr></table></figure><p>完成上面步骤，我们就可以使用 CMake GUI 或命令行（当然你需要提前安装 CMake，这不在本文的介绍范围之内）就可以生成相应的工程了。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/n3oz6wn7Ke-TinyTu.png"></p><p>通过 CMake 命令行生成 Visual Studio 工程的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake.exe -G <span class="string">&quot;Visual Studio 15 2017&quot;</span> -S .\hello_cmake -B .\hello_cmake\build</span><br></pre></td></tr></table></figure><h2 id="2-3-源码外构建"><a href="#2-3-源码外构建" class="headerlink" title="2.3 源码外构建"></a>2.3 源码外构建</h2><p>我们通常会将构建目录指定到一个单独的子目录内，这个目录名称的通常是 <code>build</code>。如果不这样做，CMake 生成的工程文件和临时缓存文件会污染源码目录。这种方式有个学名叫“源码外构建” (out-of-source build)。</p><p>使用源码外构建时，我们通常还会将 build 目录添加到 .gitignore 文件中。</p><h2 id="2-4-工作流程"><a href="#2-4-工作流程" class="headerlink" title="2.4 工作流程"></a>2.4 工作流程</h2><p>编写 CMake 脚本的基本流程如下：</p><ol><li>在脚本第一行使用 cmake_minimum_required 指定运行当前脚本所需的 CMake 最低版本。</li><li>使用 project 指定项目名称。</li><li>使用 add_executable 或 add_library 创建目标。</li><li>为目标设置包含目录、链接库等属性（可选）。</li><li>安装（可选）。</li></ol><p>编写完 CMake 脚本以后，就可以使用 CMake GUI 或命令行来生成对应的工程文件了。以 Visual Studio 为例，对于有 my_lib 库 和 app 应用程序的项目，CMake 会生成如下图所示的 5 个项目：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/Qv1nk8g1ZA.png"></p><p>下面介绍 CMake 自动生成的一些项目的作用：</p><ul><li>编译 ALL_BUILD 项目会自动编译除 INSTALL 项目外的所有项目。</li><li>编译 INSTALL 项目会执行 CMake 脚本中指定的安装操作。</li><li>编译 ZERO_CHECK 项目会再次执行 CMake 脚本，重新生成项目。因此若 CMake 脚本有更新，既可以使用 CMake 工具来重新生成项目，也可以是重新编译 ZERO_CHECK 项目。</li></ul><h2 id="2-5-注释"><a href="#2-5-注释" class="headerlink" title="2.5 注释"></a>2.5 注释</h2><p>在 CMake 中使用 <code>#</code> 来声明单行注释，这是我们使用最多的注释方法。虽然也支持使用 <code>#[[ ]]</code> 来声明多行注释（也称块注释），但是使用的比较少，例如:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[[</span></span><br><span class="line"><span class="comment">  这是多行注释也称块注释</span></span><br><span class="line"><span class="comment">  你明白了吗？</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure><h2 id="2-6-CMake最低版本"><a href="#2-6-CMake最低版本" class="headerlink" title="2.6 CMake最低版本"></a>2.6 CMake最低版本</h2><p><a href="https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html">cmake_minimum_required</a> 是我们接触到第一个 CMake 指令，该指令用于指定编译该脚本所需的最低 CMake 版本。</p><p>你可以在 CMakeList.txt 文件的第一行都使用该指令来指定运行当前脚本需要的最低 CMake 版本，但我们通常只需要在主 CMakeList.txt （何为主 CMakeList.txt？见下面的“项目名称”小节） 中的第一行使用该指令即可。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION &lt;min&gt;[...&lt;policy_max&gt;] [FATAL_ERROR])</span><br></pre></td></tr></table></figure><p>如果运行 CMake 的版本低于<min>要求的版本，则将停止处理该脚本并返回错误。</p><p>我们始终应该选择一个比编译器晚发布的 CMake 版本，因为只有这样，CMake 才能支持新的编译器选项。但最低版本不应低于 3.0，实际项目中通常最低版本不会低于 3.16（该版本于2020年09月15日发布），本教程也是以此为标准进行讲解的。</p><h2 id="2-7-项目名称"><a href="#2-7-项目名称" class="headerlink" title="2.7 项目名称"></a>2.7 项目名称</h2><p>使用 <a href="https://cmake.org/cmake/help/latest/command/project.html">project</a> 指定项目名称。</p><p>项目名称区别于目标（Target）名称，以 Visual Studio 为例，project 指定的名称对应“解决方案名称”，而 add_executable 或 add_library 等指定的名称才对应具体项目名和生成的“目标文件名”。</p><p>设置项目名称后，CMake 会自动定义一些变量（<em>变量的具体用法会在稍后的“3.1 变量”小节进行介绍</em>）。为了方便介绍各个变量的含义，假设我们是通过如下命令来运行 CMake 的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake.exe -G <span class="string">&quot;Visual Studio 15 2017&quot;</span> -S D:\hello_cmake -B D:\hello_cmake\build</span><br></pre></td></tr></table></figure><p>下面列举了一些 CMake 自动定义的变量：</p><ul><li>PROJECT_NAME<br>项目名称，如 hello_cmake</li><li>CMAKE_PROJECT_NAME<br>如果 CMakeLists.txt 位于项目的顶级目录，还会定义 CMAKE_PROJECT_NAME 变量，值与 PROJECT_NAME 一致。</li><li>PROJECT_SOURCE_DIR<br>项目的根目录（绝对路径），即 <code>-S</code> 参数指定的目录，如 D:\hello_cmake</li><li>&lt;PROJECT-NAME&gt;_SOURCE_DIR<br>值与 PROJECT_SOURCE_DIR 相同，只是变量名不同，如 hello_cmake_SOURCE_DIR  </li><li>PROJECT_BINARY_DIR<br>项目的构建目录（绝对路径），即 <code>-B</code> 参数指定的目录，如 D:\hello_cmake\build</li><li>&lt;PROJECT-NAME&gt;_BINARY_DIR<br>值与 PROJECT_BINARY_DIR 相同，只是变量名不同，如 hello_cmake_BINARY_DIR</li></ul><h3 id="主CMakeLists-txt"><a href="#主CMakeLists-txt" class="headerlink" title="主CMakeLists.txt"></a>主CMakeLists.txt</h3><p>主 CMakeLists.txt 即项目根目录下的 CMakeLists.txt 文件。可以通过检查 CMAKE_PROJECT_NAME 与 PROJECT_NAME 变量是否相同来判断当前的 CMakeLists.txt 文件是否为主 CMakeLists.txt。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_PROJECT_NAME <span class="keyword">STREQUAL</span> PROJECT_NAME)</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h2 id="2-8-目标类型"><a href="#2-8-目标类型" class="headerlink" title="2.8 目标类型"></a>2.8 目标类型</h2><p>既然现代 CMake 是围绕目标（Target）工作的，Target 如此重要，那我们首先就需要创建一个 Target。</p><p>在 C&#x2F;C++ 开发中，常见的 Target 类型有：可执行文件、静态库、动态库，CMake 还额外提供了一个 MODULE 类型。</p><p>下面列举了不同类型的目标的创建方式。</p><h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><p>使用 <a href="https://cmake.org/cmake/help/latest/command/add_executable.html">add_executable</a> 指令可以创建可执行文件类型的目标。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(my_exe main.cpp)</span><br></pre></td></tr></table></figure><h3 id="动态库和静态库"><a href="#动态库和静态库" class="headerlink" title="动态库和静态库"></a>动态库和静态库</h3><p>通过为 <a href="https://cmake.org/cmake/help/latest/command/add_library.html">add_library</a> 指令指定不同的参数，可以创建动态库和静态库。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(&lt;name&gt; [&lt;type&gt;] [EXCLUDE_FROM_ALL] &lt;sources&gt;...)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(my_lib SHARED main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(my_lib STATIC main.cpp)</span><br></pre></td></tr></table></figure><p>我们也可以在 add_library 中不指定类型参数，改为通过设置 BUILD_SHARED_LIBS 变量来切换静态库和动态库。下面示例在脚本中设置了 BUILD_SHARED_LIBS 变量值为 ON （ON &#x2F; OFF 对应 CMake 中的开&#x2F;关）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (hello_cmake)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(BUILD_SHARED_LIBS <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(hello_cmake main.cpp)</span><br></pre></td></tr></table></figure><p>也可以通过命令行参数进行指定 BUILD_SHARED_LIBS 变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake.exe -G <span class="string">&quot;Visual Studio 15 2017&quot;</span> -DBUILD_SHARED_LIBS=ON -S .\hello_cmake -B .\hello_cmake\build</span><br></pre></td></tr></table></figure><p>亦可以在 GUI 界面上设置 BUILD_SHARED_LIBS 变量，如：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/nx0MX2PY7u-TinyTu.png"></p><h1 id="三、基础语法"><a href="#三、基础语法" class="headerlink" title="三、基础语法"></a>三、基础语法</h1><h2 id="3-1-变量"><a href="#3-1-变量" class="headerlink" title="3.1 变量"></a>3.1 变量</h2><h3 id="3-1-1-变量的定义"><a href="#3-1-1-变量的定义" class="headerlink" title="3.1.1 变量的定义"></a>3.1.1 变量的定义</h3><p>在 CMake 中使用 <a href="https://cmake.org/cmake/help/latest/command/set.html">set</a> 和 <code>unset</code> 命令来定义和取消定义变量。</p><p>CMake 的变量没有类型一说，因为其变量值始终是字符串类型。</p><p>基于上述原因，在 CMake 中不能直接使用 <code>+</code>、<code>-</code>、<code>*</code>、<code>\</code> 等操作符对变量进行数学运算，需要使用 <a href="https://cmake.org/cmake/help/latest/command/math.html">math</a> 指令，也不能直接使用 <code>&gt;</code>、<code>&lt;</code>、<code>==</code> 等操作符对变量进行逻辑运算，需要使用 LESS、EQUAL 进行判断，详见下面的“条件判断”章节。</p><p>CMake 的变量名是<strong>大小写敏感</strong>的，而且其变量名不像其他语言那样有各种限制，它可以包含任何字符，如空格、问号等，但如果变量名中包含<code>#</code>（该符号用于行注释），则需要使用 <code>\#</code> 进行转义。</p><p>下面的语句都是合法的：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(abc <span class="number">123</span>)</span><br><span class="line"><span class="keyword">set</span>(ABC <span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(<span class="string">&quot;ab c&quot;</span> <span class="string">&quot;456&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(<span class="string">&quot;ab?c&quot;</span> <span class="string">&quot;789&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(<span class="string">&quot;/usr/bin/bash&quot;</span> <span class="string">&quot;987&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(<span class="string">&quot;C:\\Program Files\\&quot;</span> <span class="string">&quot;654&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(<span class="string">&quot; &quot;</span> <span class="string">&quot;321&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(\<span class="comment"># &quot;321&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unset</span>(a)</span><br></pre></td></tr></table></figure><p>虽然 CMake 允许变量名为任意字符串，但我们仍然建议在变量名称中仅包含字母、数字、<code>-</code> 和 <code>_</code> ，而且字母为大写字母，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建议的命名方式</span></span><br><span class="line"><span class="keyword">set</span>(QT_VERSION <span class="string">&quot;5.15.2&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(LIB_NAME <span class="string">&quot;my_lib&quot;</span>)</span><br></pre></td></tr></table></figure><p>CMake 还会保留一些标识符，我们在定义变量时尽量不要使用这些名称（你执意要用，CMake 也不会报错）：</p><ul><li>以 <code>CMAKE_</code> 开头的。</li><li>以 <code>_CMAKE_</code> 开头的。</li><li>以 <code>_&lt;cmake command&gt;</code> 开头的，如 _file，完整的 command 列表见：<a href="https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html">cmake-commands</a>。</li></ul><p>在定义完变量以后，就可以通过 <code>$&#123;variable&#125;</code> 的形式进行引用了，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(QT_VERSION <span class="string">&quot;5.15.2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;QT_VERSION is $&#123;QT_VERSION&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>在 CMake 中，还可以通过引用变量的方式来定义新的变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(a <span class="string">&quot;xyz&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(b <span class="string">&quot;$&#123;a&#125;_321&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(<span class="variable">$&#123;a&#125;</span>_1 <span class="string">&quot;456&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(variable_<span class="variable">$&#123;a&#125;</span> <span class="string">&quot;$&#123;a&#125; + $&#123;b&#125; + 15&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;b: &#x27;$&#123;b&#125;&#x27;&quot;</span>) <span class="comment"># b: &#x27;xyz_321&#x27;</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;xyz_1: &#x27;$&#123;xyz_1&#125;&#x27;&quot;</span>) <span class="comment"># xyz_1: &#x27;456&#x27;</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;variable_xyz: &#x27;$&#123;variable_xyz&#125;&#x27;&quot;</span>) <span class="comment"># variable_xyz: &#x27;xyz + xyz_321 + 15&#x27;</span></span><br></pre></td></tr></table></figure><p>环境变量的引用方式有所不同，在下面的环境变量章节会详细介绍，而且在 if 条件中可以省略 <code>$&#123;&#125;</code>，直接使用变量名，如 <code>if(QT_VERSION)</code>。</p><p>CMake 还允许使用未定义的变量，未定义的变量的值为空字符串。</p><p>CMake 也允许重复定义变量，变量的值采用最后定义的值。</p><h3 id="3-1-2-调试输出"><a href="#3-1-2-调试输出" class="headerlink" title="3.1.2 调试输出"></a>3.1.2 调试输出</h3><h4 id="message"><a href="#message" class="headerlink" title="message"></a>message</h4><p>为了方便调试脚本，我们可以使用 <a href="https://cmake.org/cmake/help/latest/command/message.html">messsage</a> 指令来输出变量和调试信息。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>([&lt;mode&gt;] <span class="string">&quot;message text&quot;</span> ...)</span><br></pre></td></tr></table></figure><p><code>&lt;mode&gt;</code> 关键字是可选的，它用于指定消息的类型，消息类型会影响 CMake 对该消息的处理方式。</p><p>常用的消息类型有：</p><ul><li>FATAL_ERROR<br>致命错误（红色），只有该类型会导致脚本终止执行。</li><li>WARNING<br>警告（红色），脚本继续执行。</li><li><strong>NOTICE（默认）</strong><br>需要特别关注的消息（红色），脚本继续执行。</li><li>STATUS<br>普通输出，正常颜色，脚本也会继续执行。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;Current version is 1.0.0.1&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;BUILD_SHARED_LIBS value is $&#123;BUILD_SHARED_LIBS&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="cmake-print-variables"><a href="#cmake-print-variables" class="headerlink" title="cmake_print_variables"></a>cmake_print_variables</h4><p>如果只是单纯地想打印变量的值，使用 messsage 显得有些繁琐，我们可以使用 cmake_print_variables 函数来打印变量的值，该函数以 <code>variable=value</code> 格式输出每个变量的值，方便进行观察。</p><p>由于该函数由 CMake 的 CMakePrintHelpers 模块提供，因此在使用之前，需要先 <code>include(CMakePrintHelpers)</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(CMakePrintHelpers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(MY_NAME <span class="string">&quot;jack&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(MY_ADDRESS <span class="string">&quot;Hubei&quot;</span>)</span><br><span class="line"></span><br><span class="line">cmake_print_variables(MY_NAME MY_ADDRESS) <span class="comment"># MY_NAME=&quot;jack&quot; ; MY_ADDRESS=&quot;Hubei&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-3-列表"><a href="#3-1-3-列表" class="headerlink" title="3.1.3 列表"></a>3.1.3 列表</h3><p>列表就是简单地包含一系列值，使用空格分割每个值：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST a b <span class="string">&quot;c&quot;</span> <span class="number">1</span> <span class="number">2</span> <span class="variable">$&#123;MY_NAME&#125;</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>也可以使用 <code>;</code> 来代替空格：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST <span class="string">&quot;a;b;c;1;2;$&#123;MY_NAME&#125;;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(MY_LIST a;b;c;<span class="number">1</span>;<span class="number">2</span>;<span class="variable">$&#123;MY_NAME&#125;</span>;<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h4 id="list-命令"><a href="#list-命令" class="headerlink" title="list 命令"></a>list 命令</h4><p><a href="https://cmake.org/cmake/help/latest/command/list.html">list</a> 命令提供了众多针对列表的操作，如获取元素个数、查找、添加、删除、排序等。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取元素个数</span></span><br><span class="line"><span class="keyword">list</span>(LENGTH &lt;<span class="keyword">list</span>&gt; &lt;out-var&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定下标（可以指定多个下标）的元素</span></span><br><span class="line"><span class="keyword">list</span>(GET &lt;<span class="keyword">list</span>&gt; &lt;element index&gt; [&lt;index&gt; ...] &lt;out-var&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接2个列表</span></span><br><span class="line"><span class="keyword">list</span>(JOIN &lt;<span class="keyword">list</span>&gt; &lt;glue&gt; &lt;out-var&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定位置指定长度的一段列表</span></span><br><span class="line"><span class="keyword">list</span>(SUBLIST &lt;<span class="keyword">list</span>&gt; &lt;begin&gt; &lt;length&gt; &lt;out-var&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找，&lt;out-var&gt;中存储查找到的元素下标，如果没找到则为-1</span></span><br><span class="line"><span class="keyword">list</span>(FIND &lt;<span class="keyword">list</span>&gt; &lt;value&gt; &lt;out-var&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在列表尾部添加若干元素</span></span><br><span class="line"><span class="keyword">list</span>(APPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt;...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按条件过滤列表</span></span><br><span class="line"><span class="keyword">list</span>(FILTER &lt;<span class="keyword">list</span>&gt; &lt;<span class="keyword">INCLUDE</span>|EXCLUDE&gt; REGEX &lt;regular_expression&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在指定位置插入若干元素</span></span><br><span class="line"><span class="keyword">list</span>(INSERT &lt;<span class="keyword">list</span>&gt; &lt;index&gt; [&lt;element&gt;...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹出尾部的若干元素（如果没有指定&lt;out-var&gt;变量，则只弹出一个）</span></span><br><span class="line"><span class="keyword">list</span>(POP_BACK &lt;<span class="keyword">list</span>&gt; [&lt;out-var&gt;...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹出头部的若干元素（如果没有指定&lt;out-var&gt;变量，则只弹出一个）</span></span><br><span class="line"><span class="keyword">list</span>(POP_FRONT &lt;<span class="keyword">list</span>&gt; [&lt;out-var&gt;...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将若干元素插入到列表的头部，如果&lt;list&gt;没有被定义，则相当于创建了一个新的列表</span></span><br><span class="line"><span class="keyword">list</span>(PREPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt;...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除列表中的若干元素</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM &lt;<span class="keyword">list</span>&gt; &lt;value&gt;...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除列表中指定位置（可以指定多个）的元素</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_AT &lt;<span class="keyword">list</span>&gt; &lt;index&gt;...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除列表中的重复项目。保留项目的相对顺序，但如果遇到重复项，则仅保留第一个实例。</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_DUPLICATES &lt;<span class="keyword">list</span>&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照&lt;ACTION&gt;对列表元素进行转换</span></span><br><span class="line"><span class="keyword">list</span>(TRANSFORM &lt;<span class="keyword">list</span>&gt; &lt;ACTION&gt; [&lt;SELECTOR&gt;] [OUTPUT_VARIABLE &lt;output variable&gt;])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表反转</span></span><br><span class="line"><span class="keyword">list</span>(REVERSE &lt;<span class="keyword">list</span>&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表排序</span></span><br><span class="line"><span class="keyword">list</span>(SORT &lt;<span class="keyword">list</span>&gt; [COMPARE &lt;compare&gt;] [CASE &lt;case&gt;] [ORDER &lt;order&gt;])</span><br></pre></td></tr></table></figure><p>下面仅简单地演示 2 个列表功能的用法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(NAME_LIST jack jim jeff tom)</span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>(LENGTH NAME_LIST NAME_COUNT)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;name count: $&#123;NAME_COUNT&#125;&quot;</span>) <span class="comment"># name count: 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>(FIND NAME_LIST jim JIM_INDEX)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;jim at: $&#123;JIM_INDEX&#125;&quot;</span>) <span class="comment"># jim at: 1</span></span><br></pre></td></tr></table></figure><h4 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h4><p>可以使用 foreach 来遍历列表，下面示例演示了如何使用 foreach 遍历输出 MY_LIST 列表中每个元素，其中 _ITEM 变量的作用域仅限 foreach 代码块。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST hello world)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(_ITEM <span class="variable">$&#123;MY_LIST&#125;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;_ITEM&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><p>我们还可以使用 <a href="https://cmake.org/cmake/help/latest/command/while.html">while</a> 来遍历列表，详见下面的“循环”章节。</p><h3 id="3-1-4-双引号的作用"><a href="#3-1-4-双引号的作用" class="headerlink" title="3.1.4 双引号的作用"></a>3.1.4 双引号的作用</h3><p>学习到这里，也许你会感到困扰，在定义变量时，为什么有时候使用双引号把值包围起来，有时候又不使用呢？</p><p>我们已经学习完了列表的相关知识，现在就可以解释加不加引号的区别了。</p><p>在定义变量时，若变量值中包含空格，此时不使用双引号包裹，则等同于定义列表；使用双引号包裹，则等同于定义字符串变量。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义的MY_VAR为列表，包含2个元素：hello、world</span></span><br><span class="line"><span class="keyword">set</span>(MY_VAR hello world)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义的MY_VAR为字符串</span></span><br><span class="line"><span class="keyword">set</span>(MY_VAR <span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><p>对于列表类型的变量，在使用时是否使用双引号包裹也会有区别：有双引号包裹时，会将数组元素以分号作为分隔符进行拼接，否则会直接拼接各元素。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST hello world)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;MY_LIST&#125;&quot;</span>) <span class="comment"># hello;world</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="variable">$&#123;MY_LIST&#125;</span>) <span class="comment"># helloworld</span></span><br></pre></td></tr></table></figure><h3 id="3-1-5-三种不同的变量"><a href="#3-1-5-三种不同的变量" class="headerlink" title="3.1.5 三种不同的变量"></a>3.1.5 三种不同的变量</h3><p>CMake 中的变量分为普通变量、缓存变量和环境变量，三者都可以通过 <code>set</code> 指令进行定义。</p><h4 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h4><p>下面使用 <code>set</code> 定义的变量就是普通变量。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_NAME <span class="string">&quot;jack&quot;</span>)</span><br></pre></td></tr></table></figure><p>也可以在 CMake 命令行中通过 <code>-D</code> 参数定义普通变量，如下面示例定义了 BUILD_SHARED_LIBS 和 TEST 变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake.exe -G <span class="string">&quot;Visual Studio 15 2017&quot;</span> -DBUILD_SHARED_LIBS=ON -DTEST=123 -S .\hello_cmake -B .\hello_cmake\build</span><br></pre></td></tr></table></figure><h4 id="缓存变量"><a href="#缓存变量" class="headerlink" title="缓存变量"></a>缓存变量</h4><p>缓存变量也是通过 <code>set</code> 指令定义的，但需要添加额外的参数：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])</span><br></pre></td></tr></table></figure><p>下面示例定义了一个名为 LIB_VERSION 的缓存变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(LIB_VERSION <span class="string">&quot;1.0.0.1&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;the version of library&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (hello_cmake)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(hello_cmake main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;LIB_VERSION = $&#123;LIB_VERSION&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://blog-static.jiangxueqiao.com/blog/img/ycHxFOTmrG-TinyTu.png"></p><p>使用 CMake GUI 程序执行该脚本，可以看到界面上多出了一个名为 LIB_VERSION 的文本输入框，而且输入框有默认值 1.0.0.1。</p><p>将输入框中的文本修改为 1.0.0.2，再次执行该脚本，可以发现调试输出的内容是 <code>LIB_VERSION = 1.0.0.2</code>，而且无论我们执行多少次脚本，始终输出的都是该内容。</p><p>这是因为 CMake 会将缓存变量及其值存储到 “构建目录\CMakeCache.txt” 文件中，下次运行脚本时，会优先从该文件中加载变量，该文件内容格式大致如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># build\CMakeCache.txt 文件</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">//the version of library</span><br><span class="line">LIB_VERSION:STRING=1.0.0.2</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;type&gt;</code> 用于指定变量的输入类型。请注意，<code>&lt;type&gt;</code> 指定的不是变量的类型，因为 CMake 的所有变量都是字符串类型。<code>&lt;type&gt;</code> 指定的是输入类型，仅用于帮助 CMake GUI 程序显示不同的用户输入控件，如文本输入框、复选框、文件选择对话框等。 </p><p><code>&lt;type&gt;</code> 的取值必须是下面列表中的一个：</p><ul><li>BOOL<br>开关ON或OFF，在 CMake GUI 上提供一个复选框。</li><li>PATH<br>文件夹的路径，在 CMake GUI 上提供一个文本输入框和一个按钮来打开<strong>文件夹</strong>选择对话框。</li><li>FILEPATH<br>文件的路径，在 CMake GUI 上提供一个文本输入框和一个按钮来打开文件选择对话框。</li><li>STRING<br>文本字符串，在 CMake GUI 上提供一个文本输入框。</li><li>STRINGS<br>文本字符串，但在 CMake GUI 上会提供一个下拉列表选择框。</li><li>INTERNAL<br>虽然也是文本字符串，但不会显示在 CMake GUI 上，因此用户无法在界面上修改该变量的值。</li></ul><p>如果我们不希望某些缓存变量直接展示 CMake GUI 上，可以使用 <a href="https://cmake.org/cmake/help/latest/command/mark_as_advanced.html">mark_as_advanced</a> 指令将缓存变量设置为高级状态，这样除非用户打开了 “Show Advanced” 选项，否则高级变量不会显示在 CMake GUI 中。在脚本模式下，高级&#x2F;非高级状态是无效的。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(DEBUG_LIBNAME_SUFFIX <span class="string">&quot;-d&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;Optional suffix to append to the library name for a debug build&quot;</span>)</span><br><span class="line"><span class="keyword">mark_as_advanced</span>(DEBUG_LIBNAME_SUFFIX)</span><br></pre></td></tr></table></figure><h4 id="option"><a href="#option" class="headerlink" title="option"></a>option</h4><p>虽然 <a href="https://cmake.org/cmake/help/latest/command/option.html">option</a> 也可用于定义缓存变量，但其只能定义“开&#x2F;关”类型的变量。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span>(ENABLE_TEST <span class="string">&quot;enable test or not&quot;</span> <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><p>如果未指定初始值，默认为 OFF。</p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>环境变量的定义方式如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENV&#123;&lt;variable&gt;&#125; [&lt;value&gt;])</span><br></pre></td></tr></table></figure><p>环境变量在引用时，需要在前面添加 <code>ENV</code> 标识，如 <code>$ENV&#123;&lt;variable&gt;&#125;</code></p><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENV&#123;USER_NAME&#125; <span class="string">&quot;jack&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;User name is $ENV&#123;USER_NAME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>CMake 程序在启动时，会加载系统的环境变量，同时还会设置一些内置的环境变量，内置的环境变量见 <a href="https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html">cmake-env-variables</a>。</p><p>CMake 虽然会加载系统的环境变量，我们也可以修改该环境变量，但该修改操作不会影响到系统的环境变量。</p><p>定义或加载的环境变量只会作用于当前的 CMake 进程，而且对当前进程所运行的所有脚本都可见，但不会影响到其他 CMake 进程和系统中的其他进程。</p><h3 id="3-1-6-变量作用域"><a href="#3-1-6-变量作用域" class="headerlink" title="3.1.6 变量作用域"></a>3.1.6 变量作用域</h3><p>在上面介绍三种不同的变量时，我一直在竭力避免讨论一个话题，那就是变量的作用域。事实上，上面三种变量还有个不同之处就是作用域的不同。</p><p>缓存变量和环境变量都是全局的，它们可以跨文件、目录、函数进行读写，因此作用域主要针对普通变量而言。</p><p>CMake 中作用域分为“目录级别作用域”和“函数作用域”（也可以使用 <a href="https://cmake.org/cmake/help/latest/command/block.html">block()</a> 来显式的创建一个作用域，但这种使用方式非常少）。</p><p>函数有自己的作用域，在函数中定义的变量只能在函数体中使用，函数体外无法访问。除非在定义变量时添加 <code>PARENT_SCOPE</code> 来将变量作用域设置为上一级目录。</p><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>使用 <a href="https://cmake.org/cmake/help/latest/command/include.html">include</a> 指令可以加载和执行其他 CMake 脚本文件（名称通常为 <code>*.cmake</code>），include 会在 <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html">CMAKE_MODULE_PATH</a> 变量指定的目录列表中搜索指定文件。</p><p>使用 include 指令加载cmake文件时，无需指定 <code>.cmake</code> 后缀，指定文件名即可，假设在 A（CMakeLists.txt或*.cmake）中调用 <code>include(B)</code> 加载 B.cmake ，则 A 和 B 之间可以相互读写彼此的变量（包含普通变量、缓存变量和环境变量）。</p><p>当然，在 <code>B.cmake</code> 文件中也可以使用 include 指令加载执行其他的 cmake 文件。</p><h4 id="add-subdirectory"><a href="#add-subdirectory" class="headerlink" title="add_subdirectory"></a>add_subdirectory</h4><p>使用 <a href="https://cmake.org/cmake/help/latest/command/add_subdirectory.html">add_subdirectory</a> 指令可以添加一个子目录到项目构建中，但是被添加的子目录中必须包含 CMakeLists.txt 文件。</p><p>假设在 A (CMakeLists.txt文件) 中调用 <code>add_subdirectory(lib)</code> 添加了 lib 子目录，则 lib 目录中的 CMakeLists.txt 可以读写 A 中的普通变量，但 A 不能读写 lib 目录 CMakeLists.txt 的普通变量。但可以在定义变量时添加 <code>PARENT_SCOPE</code> 选项来突破该限制，将变量作用域设置为上一级作用域，即父目录的作用域，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lib\CMakeLists.txt 文件</span></span><br><span class="line"><span class="keyword">set</span>(LIB_NAME <span class="string">&quot;MyTestLib&quot;</span> PARENT_SCOPE)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以访问 LIB_NAME 变量</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;LIB_NAME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="3-2-数学运算"><a href="#3-2-数学运算" class="headerlink" title="3.2 数学运算"></a>3.2 数学运算</h2><p>在前面章节已经提到了 CMake 中的值都是以字符串类型存储的，不能直接使用数学运算符符进行运算，需要使用 <a href="https://cmake.org/cmake/help/latest/command/math.html">math</a> 指令进行数学运算。</p><p>math 的语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">math</span>(EXPR &lt;variable&gt; <span class="string">&quot;&lt;expression&gt;&quot;</span> [OUTPUT_FORMAT &lt;format&gt;])</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;variable&gt;</code>变量如果没有定义，math 会自动定义该变量；</p><p>OUTPUT_FORMAT 选项用于指定计算结果的进制（十六进制或十进制）：</p><ul><li>HEXADECIMAL  十六进制</li><li>DECIMAL 十进制（默认）</li></ul><p>math 支持如下运算符：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ - * / % | &amp; ^ ~ &lt;&lt; &gt;&gt;  (...)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># value 等于 &quot;300&quot;</span></span><br><span class="line"><span class="keyword">math</span>(EXPR value <span class="string">&quot;100 * 3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># value 等于 &quot;1000&quot;</span></span><br><span class="line"><span class="keyword">math</span>(EXPR value <span class="string">&quot;100 * 0xA&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># value 等于 &quot;0x12c&quot;</span></span><br><span class="line"><span class="keyword">math</span>(EXPR value <span class="string">&quot;100 * 3&quot;</span> OUTPUT_FORMAT HEXADECIMAL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(value <span class="number">3</span>)</span><br><span class="line"><span class="keyword">math</span>(EXPR value <span class="string">&quot;100 * $&#123;value&#125;&quot;</span>)   <span class="comment"># value 等于 &quot;300&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># value 等于 &quot;306&quot;</span></span><br><span class="line"><span class="keyword">math</span>(EXPR value <span class="string">&quot;(100 + 2) * 3&quot;</span>)      </span><br></pre></td></tr></table></figure><h2 id="3-3-条件判断"><a href="#3-3-条件判断" class="headerlink" title="3.3 条件判断"></a>3.3 条件判断</h2><p>在 CMake 中，使用 <a href="https://cmake.org/cmake/help/latest/command/if.html">if</a> 进行条件判断，语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;condition&gt;)</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">elseif</span>(&lt;condition&gt;) <span class="comment"># 可选的，可以有多个</span></span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">else</span>()              <span class="comment"># 可选的</span></span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>与众多语言中的 if 一样，当括号中的条件为真时，才执行指定的 commands。</p><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(a <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">LESS</span> <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;a &lt; 10&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;a &gt;= 10&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>else() 和 endif() 括号中的内容可以为空，但如果需要指定，则就必须与 if 中的条件完全一致，如下面示例所示：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(a <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">LESS</span> <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;a &lt; 10&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>(a <span class="keyword">LESS</span> <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;a &gt;= 10&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>(a <span class="keyword">LESS</span> <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>我们通常不在 else() 和 endif() 中指定条件，因为这样太繁琐了。</p><h3 id="3-3-1-真值与假值"><a href="#3-3-1-真值与假值" class="headerlink" title="3.3.1 真值与假值"></a>3.3.1 真值与假值</h3><p>何为真，何为假，人生真真假假，难以分辨，程序的真假却清清楚楚。</p><p>下列常量始终为真（不区分大小写）：</p><ul><li>1 和其他非零数字（包含浮点型），如 1、2、3.14</li><li>ON</li><li>YES</li><li>TRUE</li><li>Y</li></ul><p>下列常量始终为假（不区分大小写）：</p><ul><li>0</li><li>OFF</li><li>NO</li><li>FALSE</li><li>N</li><li>IGNORE</li><li>NOTFOUND</li><li>空字符串</li><li>被引号包裹的字符串（除始终为真的字符串外，如 TRUE、Y 等）</li></ul><h3 id="3-3-2-逻辑运算符"><a href="#3-3-2-逻辑运算符" class="headerlink" title="3.3.2 逻辑运算符"></a>3.3.2 逻辑运算符</h3><p>在 CMake 中，逻辑运算符的与、或、非分别使用 AND、OR、NOT 表示。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> &lt;condition&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(&lt;cond1&gt; <span class="keyword">AND</span> &lt;cond2&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(&lt;cond1&gt; <span class="keyword">OR</span> &lt;cond2&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((condition) <span class="keyword">AND</span> (condition <span class="keyword">OR</span> (condition)))</span><br></pre></td></tr></table></figure><h3 id="3-3-3-关系运算符"><a href="#3-3-3-关系运算符" class="headerlink" title="3.3.3 关系运算符"></a>3.3.3 关系运算符</h3><p>由于 CMake 变量都是以字符串类型存储的，因此即便是数字也不能直接使用 <code>&gt;</code>、<code>&lt;</code>、<code>==</code> 这样的运算符来直接比较。</p><p>针对数值类型，CMake 支持的关系运算符如下：</p><ul><li>LESS  小于</li><li>LESS_EQUAL  小于等于</li><li>GREATER  大于</li><li>GREATER_EQUAL  大于等于</li><li>EQUAL  等于</li></ul><p>CMake 还支持字符串比较，即从左到右依次比较字符串中的每个字符，出现不相同时立即返回，类似于 C 语言中的 strcmp 函数。</p><ul><li>STRLESS  </li><li>STRLESS_EQUAL </li><li>STRGREATER </li><li>STRGREATER_EQUAL </li><li>STREQUAL</li></ul><h3 id="3-3-4-存在性校验"><a href="#3-3-4-存在性校验" class="headerlink" title="3.3.4 存在性校验"></a>3.3.4 存在性校验</h3><p>CMake 提供了一些判断变量是否定义、目标是否创建、元素是否存在于列表中、文件&#x2F;目录是否存在等方法。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定名称是否是可以调用的指令</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">COMMAND</span> &lt;<span class="keyword">command</span>-name&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定名称是否是已创建的目标，即通过add_executable()、add_library() 或 add_custom_target() 命令创建</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">TARGET</span> &lt;<span class="keyword">target</span>-name&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定名称的普通变量、缓存变量、环境变量是否已定义</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">DEFINED</span> &lt;name&gt;|CACHE&#123;&lt;name&gt;&#125;|ENV&#123;&lt;name&gt;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定的元素是否包含在列表中</span></span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">IN_LIST</span> &lt;variable&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定的文件或目录是否存在</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">EXISTS</span> &lt;path-to-<span class="keyword">file</span>-<span class="keyword">or</span>-directory&gt;)</span><br></pre></td></tr></table></figure><h2 id="3-4-循环"><a href="#3-4-循环" class="headerlink" title="3.4 循环"></a>3.4 循环</h2><p>CMake 有两种循环方式：</p><ul><li><a href="https://cmake.org/cmake/help/latest/command/foreach.html">foreach</a>  </li><li><a href="https://cmake.org/cmake/help/latest/command/while.html">while</a></li></ul><p>二者都可以使用 break() 提前退出循环和 continue() 跳过本次循环。</p><h3 id="3-4-1-foreach"><a href="#3-4-1-foreach" class="headerlink" title="3.4.1 foreach"></a>3.4.1 foreach</h3><p>下面是 foreach 的基本语法形式，这种形式在之前的“遍历列表”章节已经使用到了：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; &lt;items&gt;)</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(_ITEM <span class="variable">$&#123;MY_LIST&#125;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;_ITEM&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><p>foreach 还支持下面两种语法形式，这两种形式都不需要指定列表 <code>&lt;items&gt;</code> 参数，作用类似于 C 语言中的 for 语句：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 循环 [0 ~ &lt;stop&gt;]，步长为 1</span></span><br><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; RANGE &lt;stop&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环 [&lt;start&gt; ~ &lt;stop&gt;]，步长为 &lt;step&gt;（可选）</span></span><br><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; RANGE &lt;start&gt; &lt;stop&gt; [&lt;step&gt;])</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(_I RANGE <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;_I&#125;&quot;</span>) <span class="comment"># 依次输出 0 1 2 3</span></span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(_I RANGE <span class="number">2</span> <span class="number">5</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;_I&#125;&quot;</span>) <span class="comment"># 依次输出 2 3 4 5</span></span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(_I RANGE <span class="number">2</span> <span class="number">5</span> <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;_I&#125;&quot;</span>) <span class="comment"># 依次输出 2 4</span></span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><h3 id="3-4-2-while"><a href="#3-4-2-while" class="headerlink" title="3.4.2 while"></a>3.4.2 while</h3><p>while 的语法形式如下，其中 <code>&lt;condition&gt;</code> 为真时（参考 if 条件判断章节），执行代码块中的 commands 命令。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(&lt;condition&gt;)</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endwhile</span>()</span><br></pre></td></tr></table></figure><p>下面示例演示了如何使用 while 来遍历列表：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line"><span class="keyword">list</span>(LENGTH MY_LIST LIST_COUNT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(INDEX <span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span>(INDEX <span class="keyword">LESS</span> LIST_COUNT)</span><br><span class="line">  <span class="keyword">list</span>(GET MY_LIST <span class="variable">$&#123;INDEX&#125;</span> VALUE) <span class="comment"># 获取 $&#123;INDEX&#125; 位置的元素</span></span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;element at $&#123;INDEX&#125; = $&#123;VALUE&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">math</span>(EXPR INDEX <span class="string">&quot;$&#123;INDEX&#125; + 1&quot;</span>) <span class="comment"># 自增 INDEX</span></span><br><span class="line"><span class="keyword">endwhile</span>()</span><br></pre></td></tr></table></figure><p>上面示例依次输出如下内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element at 0 = 1</span><br><span class="line">element at 1 = 2</span><br><span class="line">element at 2 = 3</span><br></pre></td></tr></table></figure><h2 id="3-5-函数和宏"><a href="#3-5-函数和宏" class="headerlink" title="3.5 函数和宏"></a>3.5 函数和宏</h2><h3 id="3-5-1-函数"><a href="#3-5-1-函数" class="headerlink" title="3.5.1 函数"></a>3.5.1 函数</h3><p>使用 <a href="https://cmake.org/cmake/help/latest/command/function.html">function</a> 定义函数：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(&lt;name&gt; [&lt;arg1&gt; ...])</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure><p>函数有自己的作用域，而宏没有自己的作用域，在函数体里面定义的普通变量默认只能在函数体中被访问，除非在定义时指定了 <code>PARENT_SCOPE</code> 选项，或者改为定义缓存变量、环境变量。</p><p>函数在被调用时，函数名是不区分大小写的，如我们定义了名为 <code>foo</code> 的函数，就可以使用 <code>foo()</code>、<code>Foo()</code>、<code>FOO()</code> 等形式来调用，但我们还是建议保持与函数定义时的名称一致。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>关于函数的参数，我们可以在定义函数时就指定各个参数的名称，如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(my_func NAME AGE)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;name: $&#123;NAME&#125;&quot;</span>) <span class="comment"># name: jack </span></span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;age: $&#123;AGE&#125;&quot;</span>) <span class="comment"># age: 18</span></span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line">my_func(<span class="string">&quot;jack&quot;</span> <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>在调用函数时，调用参数（实参）的个数可以超过定义的参数个数（形参），但不能少于定义的参数个数，否则会报错。超出的参数，可以通过下面的形式获取：</p><ul><li>使用 <code>ARGV0</code>, <code>ARGV1</code>, <code>ARGV2</code>, <code>...</code> 变量获取函数的每个参数。</li><li>使用 <code>ARGV</code> 变量获取函数的参数列表，通过 <code>ARGN</code> 变量获取参数的个数。</li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>使用 <code>return()</code> 可以从函数体中提前返回，但不能直接使用 return() 带出返回值，需要借用 <code>set(&lt;variable&gt; &lt;value&gt; PARENT_SCOPE)</code> 方式，来间接的带出返回值。</p><p>下面示例演示了函数的定义、调用、参数的获取以及返回值的用法。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(my_func NAME AGE)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;name: $&#123;NAME&#125;&quot;</span>) <span class="comment"># name: jack</span></span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;parameter count: $&#123;ARGC&#125;&quot;</span>) <span class="comment"># parameter count: 3</span></span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;parameter list: $&#123;ARGV&#125;&quot;</span>) <span class="comment"># parameter list: jack;18;Hubei</span></span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;parameter 0: $&#123;ARGV0&#125;&quot;</span>) <span class="comment"># parameter 0: jack</span></span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;parameter 2: $&#123;ARGV1&#125;&quot;</span>) <span class="comment"># parameter 2: Hubei</span></span><br><span class="line">  <span class="keyword">set</span>(FUNC_RET <span class="string">&quot;OK&quot;</span> PARENT_SCOPE)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line">my_func(<span class="string">&quot;jack&quot;</span> <span class="number">18</span> <span class="string">&quot;Hubei&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;return value: $&#123;FUNC_RET&#125;&quot;</span>) <span class="comment"># return value: OK</span></span><br></pre></td></tr></table></figure><p>但在实际项目中，除需要传入不定个数的参数情况外，我们通常在定义函数时，就约定好了参数名称和返回参数的名称，如下面示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(my_func NAME AGE OUT_RET)</span><br><span class="line">  <span class="comment"># 使用 $&#123;NAME&#125; $&#123;AGE&#125; 访问参数</span></span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;name: $&#123;NAME&#125;&quot;</span>) <span class="comment"># name: jack</span></span><br><span class="line">  <span class="keyword">set</span>(OUT_RET <span class="string">&quot;OK&quot;</span> PARENT_SCOPE)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line">my_func(<span class="string">&quot;jack&quot;</span> <span class="number">18</span> OUT_RET)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;return value: $&#123;OUT_RET&#125;&quot;</span>) <span class="comment"># return value: OK</span></span><br></pre></td></tr></table></figure><h3 id="3-5-2-宏"><a href="#3-5-2-宏" class="headerlink" title="3.5.2 宏"></a>3.5.2 宏</h3><p>使用 <a href="https://cmake.org/cmake/help/latest/command/macro.html">macro</a> 定义宏：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span>(&lt;name&gt; [&lt;arg1&gt; ...])</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br></pre></td></tr></table></figure><p>CMake 中的宏和 C 语言中的宏一样，是在调用处进行语句替换后再执行，因此在宏中使用 <code>return()</code> 时要格外小心，可能会终止整个脚本的执行。</p><p>建议优先使用函数。</p><h2 id="3-6-字符串操作"><a href="#3-6-字符串操作" class="headerlink" title="3.6 字符串操作"></a>3.6 字符串操作</h2><p>字符串操作由 <a href="https://cmake.org/cmake/help/latest/command/string.html">string</a> 指令提供，详见官方文档。</p><h2 id="3-7-内置变量"><a href="#3-7-内置变量" class="headerlink" title="3.7 内置变量"></a>3.7 内置变量</h2><p>本节列举了在项目中经常用到的 CMake 内置变量。</p><ul><li><p>CMAKE_SOURCE_DIR<br>始终存储的是项目的根目录。</p></li><li><p>CMAKE_BINARY_DIR<br>始终存储的是项目的根构建目录。</p></li><li><p>PROJECT_SOURCE_DIR<br>与 CMAKE_SOURCE_DIR 一样，也始终存储的是项目的根目录，但该变量需要使用 project 创建项目以后，才会被定义。</p></li><li><p>PROJECT_BINARY_DIR<br>与 CMAKE_BINARY_DIR 一样，也始终存储的是项目的构建目录，但该变量需要使用 project 创建项目以后，才会被定义。</p></li><li><p>CMAKE_CURRENT_SOURCE_DIR<br>存储的是当前正在执行脚本所在的目录。</p></li><li><p>CMAKE_CURRENT_BINARY_DIR<br>一个工程中可能包括多个项目，每个项目的构建目录不同，该变量存储的是当前项目的构建目录。</p></li><li><p>CMAKE_CURRENT_LIST_FILE<br>当前脚本代码所在文件的完整路径。</p></li><li><p>CMAKE_CURRENT_LIST_LINE<br>当前脚本代码所在行数。</p></li><li><p>CMAKE_MODULE_PATH<br>通过设置改变变量，可以控制 CMake 查找 <code>.cmake</code> 文件的路径，在使用 <code>include</code> 时就可以直接使用文件名了。如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(utils)</span><br></pre></td></tr></table></figure><p>需要注意的是，当在 include 中仅指定了文件名时，不能再添加 <code>.cmake</code> 扩展名，否则会导致查找不到相应文件。</p></li><li><p>WIN32<br>在 Windows 系统上，定义该变量，值为 1。</p></li><li><p>APPLE<br>在 Apple 系统上，定义该变量，值为 1。</p></li><li><p>UNIX<br>在类 UNIX 系统上，定义该变量，值为 1。</p></li><li><p>CMAKE_SYSTEM_NAME<br>当前构建所选定目标系统，但该变量需要使用 project 创建项目以后，才会被定义。</p><p>该变量常见的值有：Android、iOS、Linux、FreeBSD、MSYS、Windows、Darwin，完整的列表见：<a href="https://cmake.org/cmake/help/latest/variable/CMAKE_SYSTEM_NAME.html">CMAKE_SYSTEM_NAME</a>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Linux&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;current platform: Linux &quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Windows&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;current platform: Windows&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;FreeBSD&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;current platform: FreeBSD&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Darwin&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;current platform: macOS&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Android&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;current platform: Android&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;iOS&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;current platform: iOS&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> ()</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;other platform: $&#123;CMAKE_SYSTEM_NAME&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></li><li><p>MSVC<br>当编译器是 Microsoft Visual C++ 的某个版本或模拟 Visual C++ cl 命令行语法的其他编译器时设置为 true。</p></li><li><p>MSVC_VERSION<br>正在使用的 Microsoft Visual C&#x2F;C++ 版本（如果有）。如果正在使用模拟 Visual C++ 的编译器，则此变量将设置为 _MSC_VER 预处理器定义所给定的模拟工具集版本。</p></li></ul><h1 id="四、目标的属性"><a href="#四、目标的属性" class="headerlink" title="四、目标的属性"></a>四、目标的属性</h1><h2 id="4-1-属性调试"><a href="#4-1-属性调试" class="headerlink" title="4.1 属性调试"></a>4.1 属性调试</h2><p>在介绍如何设置目标的属性之前，我们先学习一下如何调试输出目标属性，方便在开发中检查属性设置是否出错。</p><p>使用 CMakePrintHelpers 模块提供 <a href="https://cmake.org/cmake/help/latest/module/CMakePrintHelpers.html">cmake_print_properties</a> 函数可以打印输出目标的属性，该函数的原型如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_print_properties(&lt;TARGETS       [&lt;target1&gt; ...] |</span><br><span class="line">                        SOURCES       [&lt;source1&gt; ...] |</span><br><span class="line">                        DIRECTORIES   [&lt;dir1&gt; ...]    |</span><br><span class="line">                        TESTS         [&lt;test1&gt; ...]   |</span><br><span class="line">                        CACHE_ENTRIES [&lt;entry1&gt; ...]  &gt;</span><br><span class="line">                       PROPERTIES [&lt;prop1&gt; ...]         )</span><br></pre></td></tr></table></figure><p>以打印输出目标的“包含目录”属性为例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(hello_cmake main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(hello_cmake PRIVATE <span class="string">&quot;include&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(CMakePrintHelpers)</span><br><span class="line">cmake_print_properties(TARGETS hello_cmake PROPERTIES <span class="keyword">INCLUDE_DIRECTORIES</span>) </span><br></pre></td></tr></table></figure><p>输出： </p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Properties for TARGET hello_cmake:</span><br><span class="line">  hello_cmake.INCLUDE_DIRECTORIES = &quot;D:/cmake-sample/hello_cmake/include&quot;</span><br></pre></td></tr></table></figure><h2 id="4-2-包含目录"><a href="#4-2-包含目录" class="headerlink" title="4.2 包含目录"></a>4.2 包含目录</h2><p>使用 <a href="https://cmake.org/cmake/help/latest/command/target_include_directories.html">target_include_directories</a> 指定目标包含一个或多个目录。指定的目录路径可以是绝对路径也可以是相对路径，如果是相对路径，则该路径是相对于当前脚本文件的。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(&lt;<span class="keyword">target</span>&gt; [SYSTEM] [AFTER|BEFORE]</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br></pre></td></tr></table></figure><p>这就相当于在 Visual Studio 中设置“附加包含目录”。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/6zoF01MV26-TinyTu.png"></p><p>可以针对一个目标重复调用 target_include_directories，会按照调用顺序依次附加包含目录，也可以使用 BEFORE 选项，将本次设置的包含目录插入到最前面。</p><p>我们需要特别花精力理解 INTERFACE、PUBLIC、PRIVATE 三者的区别，这三者的区别，我们先按下不表，稍后介绍。</p><p>在使用 PUBLIC、PRIVATE 设置包含目录时，会自动设置 <code>INCLUDE_DIRECTORIES</code> 属性；在使用 INTERFACE 设置包含目录时，会自动设置 <code>INTERFACE_INCLUDE_DIRECTORIES</code> 属性。</p><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(hello_cmake </span><br><span class="line">  PUBLIC <span class="string">&quot;include&quot;</span></span><br><span class="line">  PRIVATE <span class="string">&quot;./extern/jsoncpp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(hello_cmake BEFORE</span><br><span class="line">  PUBLIC <span class="string">&quot;include&quot;</span></span><br><span class="line">  PRIVATE <span class="string">&quot;./extern/rpclib&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="4-3-预编译宏"><a href="#4-3-预编译宏" class="headerlink" title="4.3 预编译宏"></a>4.3 预编译宏</h2><p>使用 <a href="https://cmake.org/cmake/help/latest/command/target_compile_definitions.html">target_compile_definitions</a> 设置目标的预编译宏。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(&lt;<span class="keyword">target</span>&gt;</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br></pre></td></tr></table></figure><p>可以针对一个目标重复调用 target_compile_definitions，附加多个预编译宏。</p><p>使用 PUBLIC、PRIVATE 设置包含目录时，会自动设置 <code>COMPILE_DEFINITIONS</code> 属性；使用 INTERFACE 设置包含目录时，会自动设置 <code>INTERFACE_COMPILE_DEFINITIONS</code> 属性。</p><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义2个预编译宏</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(hello_cmake</span><br><span class="line">  PUBLIC USING_BOOST USING_THRIFT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再定义一个预编译宏</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(hello_cmake</span><br><span class="line">  INTERFACE USING_ZLIB)</span><br></pre></td></tr></table></figure><h2 id="4-4-依赖库"><a href="#4-4-依赖库" class="headerlink" title="4.4 依赖库"></a>4.4 依赖库</h2><p>使用 <a href="https://cmake.org/cmake/help/latest/command/target_link_libraries.html">target_link_libraries</a> 指令设置目标的依赖库，该指令有很多原型，但常用的原型有：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(&lt;<span class="keyword">target</span>&gt;</span><br><span class="line">                     [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]</span><br><span class="line">                     [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br></pre></td></tr></table></figure><p>item 可以是如下几种类型：</p><ul><li>lib 文件的绝对路径或相对路径，CMake 不会校验文件是否存在</li><li>其他的 CMake 目标。</li><li>表达式生成器（见“生成器表达式”章节）。</li><li>以 <code>-</code> 开头的链接标志，但从 CMake 3.13 版本开始，可以直接使用 <code>target_link_options()</code> 替代。</li></ul><p>可以针对一个目标重复调用 target_link_libraries，附加多个依赖库。</p><p><code>&lt;PRIVATE|PUBLIC|INTERFACE&gt;</code> 可以省略，如果省略，则默认为 PUBLIC。</p><p>使用 PUBLIC、PRIVATE 设置依赖库时，会自动设置 <code>LINK_LIBRARIES</code> 属性；使用 INTERFACE 设置依赖库时，会自动设置 <code>INTERFACE_LINK_LIBRARIES</code> 属性。</p><h2 id="4-5-INTERFACE、PUBLIC-和-PRIVATE"><a href="#4-5-INTERFACE、PUBLIC-和-PRIVATE" class="headerlink" title="4.5 INTERFACE、PUBLIC 和 PRIVATE"></a>4.5 INTERFACE、PUBLIC 和 PRIVATE</h2><p>INTERFACE、PUBLIC 和 PRIVATE 用于指定属性的可见性传递方案。</p><table><thead><tr><th>目标类型</th><th>可见性传递</th><th>自身是否应用该属性</th><th>使用者是否应用该属性</th></tr></thead><tbody><tr><td>可执行文件</td><td>INTERFACE</td><td>否</td><td>否（可执行文件不存在使用者）</td></tr><tr><td>可执行文件</td><td>PUBLIC</td><td>是</td><td>否（可执行文件不存在使用者）</td></tr><tr><td>可执行文件</td><td>PRIVATE</td><td>是</td><td>否（可执行文件不存在使用者）</td></tr><tr><td>库（动态或静态）</td><td>INTERFACE</td><td>否</td><td>是</td></tr><tr><td>库（动态或静态）</td><td>PUBLIC</td><td>是</td><td>是</td></tr><tr><td>库（动态或静态）</td><td>PRIVATE</td><td>是</td><td>否</td></tr></tbody></table><h2 id="4-6-编译和链接选项"><a href="#4-6-编译和链接选项" class="headerlink" title="4.6 编译和链接选项"></a>4.6 编译和链接选项</h2><p>通过 <a href="https://cmake.org/cmake/help/latest/command/target_compile_options.html">target_compile_options</a> 指令设置编译选项。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_options</span>(&lt;<span class="keyword">target</span>&gt; [BEFORE]</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br></pre></td></tr></table></figure><p>通过 <a href="https://cmake.org/cmake/help/latest/command/target_link_options.html">target_link_options</a> 指令设置链接选项。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_options</span>(&lt;<span class="keyword">target</span>&gt; [BEFORE]</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br></pre></td></tr></table></figure><p>这两个指令的用法与前面介绍的 target_include_directories 类似。</p><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译选项</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(my_lib PRIVATE /utf8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接选项</span></span><br><span class="line"><span class="keyword">target_link_options</span>(app PRIVATE /NOLOGO)</span><br></pre></td></tr></table></figure><h2 id="4-7-其他属性"><a href="#4-7-其他属性" class="headerlink" title="4.7 其他属性"></a>4.7 其他属性</h2><p>CMake 为目标还提供了其他属性，详见 <a href="https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html#target-properties">target-properties</a> ，总计约有 400 多个，涵盖了开发中会用到的绝大多数属性，例如其中以 VS_ 开头的属性是专门为 Visual Studio 所准备的。</p><p>针对这些属性，需要使用 <a href="https://cmake.org/cmake/help/latest/command/set_target_properties.html">set_target_properties</a> 指令进行设置。</p><p>例如，使用 OUTPUT_NAME 和 DEBUG_OUTPUT_NAME 设置目标的输出文件名。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(zoe PROPERTIES </span><br><span class="line">  OUTPUT_NAME Zoe</span><br><span class="line">  DEBUG_OUTPUT_NAME Zoe-d)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://cmake.org/&quot;&gt;CMake&lt;/a&gt; 是一个开源、跨平台的构建系统生成器（Build-system Generator）。&lt;/p&gt;
&lt;p&gt;CMake 是构建系统生成器，而不是构建系统，CMake 支持生成不同构建系统所支持的工程文件，如 Visual Studio，XCode，Makefile 等。&lt;/p&gt;
&lt;p&gt;本教程作为 CMake 的简明教程，不会事无巨细的讲述 CMake 的每一个语法，而是以实用为目的，介绍 CMake 的基础语法和常用指令。&lt;/p&gt;
&lt;p&gt;虽然只是简明教程，但通过本教程，你仍然可以掌握 CMake 的脉络，熟练应用 CMake 于项目中。&lt;/p&gt;</summary>
    
    
    
    <category term="CMake" scheme="https://jiangxueqiao.com/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://jiangxueqiao.com/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>开源库jerryscript使用备忘</title>
    <link href="https://jiangxueqiao.com/post/3353203242.html"/>
    <id>https://jiangxueqiao.com/post/3353203242.html</id>
    <published>2024-09-09T04:48:55.000Z</published>
    <updated>2025-05-07T02:40:34.036Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-static.jiangxueqiao.com/blog/img/jerryscript-LOGO.png"></p><p>以前嵌入脚本首选Lua，但有些年头没有用Lua了，语法也快忘记光了，这些年倒是对 JavaScript 语法愈发熟悉了，于是想看看有没有小巧的 JavaScript 引擎，可以嵌入到 C++程序中使用。嘿，还真有。花时间研究了下 JerryScript 库，也顺手给 JerryScript 提交了几个 PR 被采纳了，有幸成为顶级项目的 Contributor（就是玩儿 ^_^）。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/3udYdv0Ten.png"></p><p><a href="https://github.com/jerryscript-project/jerryscript">JerryScript</a> 是一个轻量级的 JavaScript 引擎，资源占用极少，它可以运行在资源受限制的设备上，如：</p><ul><li>只有几 KB RAM 能运行引擎的设备（&lt;64 KB RAM）</li><li>只能为代码引擎提供有限 ROM 空间的设备（&lt;200 KB ROM）</li></ul><p>JerryScript 使用 C 语言开发，跨平台。</p><span id="more"></span><h1 id="为什么没有选择-QuickJS？"><a href="#为什么没有选择-QuickJS？" class="headerlink" title="为什么没有选择 QuickJS？"></a>为什么没有选择 QuickJS？</h1><p>说起轻量级的 JavaScript 引擎，很多人都会想到 QuickJS。的确，我一开始也选择了 QuickJS，但一番研究之后，发现 QuickJS 在 Windows 环境下编译实在是不太友好，不仅需要安装 Mingw64，而且修改编译选项也不方便。可能是我能力的问题吧，我还未找到将 QuickJS 编译成 MT 运行库的静态库的方法。</p><p>一个库在编译方面做得都不够友好，何况 Windows 也不是冷门的系统，那就没必要委屈自己了，毕竟还有其他的选择。</p><p>反观 JerryScript，使用 CMake 进行构建，不需要进行任何修改，一路畅通。</p><h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><p>JerryScript 的接口比较简洁， 而且官方已经提供了丰富的示例，示例地址如下：</p><p><a href="https://jerryscript.net/api-example/">https://jerryscript.net/api-example/</a></p><p>下面是一个简单的示例，演示了如何暴露 C++ 的函数给 JS 进行调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;jerryscript.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 函数，用于暴露给 JS</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">jerry_value_t</span> <span class="title">print_handler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">jerry_call_info_t</span>* call_info_p,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">jerry_value_t</span> arguments[],</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">jerry_length_t</span> argument_count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有参数，只打印一个字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Print handler was called\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 undefined 给JS引擎</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">jerry_undefined</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">jerry_char_t</span> script[] = <span class="string">&quot;print ();&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">jerry_length_t</span> script_size = <span class="built_in">sizeof</span>(script) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化引擎</span></span><br><span class="line">    <span class="built_in">jerry_init</span>(JERRY_INIT_EMPTY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 print 方法到 JavaScript 的全局对象上</span></span><br><span class="line">    <span class="comment">// 在JS 中调用 print 方法时，会调用到 C++ print_handler 方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">jerry_value_t</span> global_object = <span class="built_in">jerry_current_realm</span>();</span><br><span class="line">        <span class="type">jerry_value_t</span> property_name_print = <span class="built_in">jerry_string_sz</span>(<span class="string">&quot;print&quot;</span>);</span><br><span class="line">        <span class="type">jerry_value_t</span> property_value_func = <span class="built_in">jerry_function_external</span>(print_handler);</span><br><span class="line">        <span class="type">jerry_value_t</span> set_result = <span class="built_in">jerry_object_set</span>(global_object, property_name_print, property_value_func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否有错误发生</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">jerry_value_is_exception</span>(set_result)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Failed to add the &#x27;print&#x27; property\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">jerry_value_free</span>(set_result);</span><br><span class="line">        <span class="built_in">jerry_value_free</span>(property_value_func);</span><br><span class="line">        <span class="built_in">jerry_value_free</span>(property_name_print);</span><br><span class="line">        <span class="built_in">jerry_value_free</span>(global_object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">jerry_value_t</span> parsed_code = <span class="built_in">jerry_parse</span>(script, script_size, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">jerry_value_is_exception</span>(parsed_code))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 执行 JS 代码</span></span><br><span class="line">        <span class="type">jerry_value_t</span> ret_value = <span class="built_in">jerry_run</span>(parsed_code);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放返回值</span></span><br><span class="line">        <span class="built_in">jerry_value_free</span>(ret_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">jerry_value_free</span>(parsed_code);</span><br><span class="line">    <span class="built_in">jerry_cleanup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://blog-static.jiangxueqiao.com/blog/img/jerryscript-LOGO.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;以前嵌入脚本首选Lua，但有些年头没有用Lua了，语法也快忘记光了，这些年倒是对 JavaScript 语法愈发熟悉了，于是想看看有没有小巧的 JavaScript 引擎，可以嵌入到 C++程序中使用。嘿，还真有。花时间研究了下 JerryScript 库，也顺手给 JerryScript 提交了几个 PR 被采纳了，有幸成为顶级项目的 Contributor（就是玩儿 ^_^）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-static.jiangxueqiao.com/blog/img/3udYdv0Ten.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jerryscript-project/jerryscript&quot;&gt;JerryScript&lt;/a&gt; 是一个轻量级的 JavaScript 引擎，资源占用极少，它可以运行在资源受限制的设备上，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有几 KB RAM 能运行引擎的设备（&amp;lt;64 KB RAM）&lt;/li&gt;
&lt;li&gt;只能为代码引擎提供有限 ROM 空间的设备（&amp;lt;200 KB ROM）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JerryScript 使用 C 语言开发，跨平台。&lt;/p&gt;</summary>
    
    
    
    <category term="开源库" scheme="https://jiangxueqiao.com/categories/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
    <category term="jeffyscript" scheme="https://jiangxueqiao.com/tags/jeffyscript/"/>
    
    <category term="开源库" scheme="https://jiangxueqiao.com/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>禁用F12作为调试热键</title>
    <link href="https://jiangxueqiao.com/post/4077884774.html"/>
    <id>https://jiangxueqiao.com/post/4077884774.html</id>
    <published>2024-08-26T05:08:03.000Z</published>
    <updated>2024-08-26T05:00:44.953Z</updated>
    
    <content type="html"><![CDATA[<p>在Windows系统中，F12永远为调试器所预留，不能被用来注册为快捷键，如我们通常使用F12打开浏览器的调试工具。即便当前未调试应用程序，如果内核模式调试器或实时调试器有驻留，F12也会被预留。</p><p>详见：<br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms646309.aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms646309.aspx</a></p><p>可以通过修改注册表来指定其他的按键作为调试器预留快捷键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug] UserDebuggerHotKey=dword:00000000</span><br></pre></td></tr></table></figure><p>比如<code>0x13</code> (Pause键)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Windows系统中，F12永远为调试器所预留，不能被用来注册为快捷键，如我们通常使用F12打开浏览器的调试工具。即便当前未调试应用程序，如果内核模式调试器或实时调试器有驻留，F12也会被预留。&lt;/p&gt;
&lt;p&gt;详见：&lt;br&gt;&lt;a href=&quot;https://msdn.mi</summary>
      
    
    
    
    <category term="编程基础" scheme="https://jiangxueqiao.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Visual Studio" scheme="https://jiangxueqiao.com/tags/Visual-Studio/"/>
    
  </entry>
  
  <entry>
    <title>折腾开发环境的一天</title>
    <link href="https://jiangxueqiao.com/post/2133505170.html"/>
    <id>https://jiangxueqiao.com/post/2133505170.html</id>
    <published>2024-08-12T01:52:55.000Z</published>
    <updated>2025-09-18T07:17:50.161Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="无法校验文章哈希">  <script id="hbeData" type="hbeData" data-hmacdigest="2439affaf706f3b9b5d35312f0dbe35bd55eed2a185f844a808dd94c7991d29e">31b52207602f4039033d33a3456606005c3723a80c876cade8b7abcfdb14234c9cc35f12e5fd9389d98f7049c42036eff2331f2debbc7995acabe5df85be6c2017f80ec8c8f6d927d3b2fd636d75d91ce0a49cb43512fcf14fa8bc3117dc6e7e67d035c2c8b3c40e3f475bce904149f3396a904339b497001aa65fe0aeb43fb449dbadb2e69f1a0e671077d84ad25cb322b7a0d6a5699167717819ccaa69124430c3e625948e5fab48907ac2352d16f6e1a77f2d05d0495cfa3c7119ba9a9cc8f13c262c14e48b9989b3a8e7217fc9b3ed004914e3a1526eae17956121321c687dce1ded6b394e968e912a2599267a7f9d1cffee389ef430b6ac36cafaf199ededb179d248f3d67dd3c8cc1e5190bb44a382cc620023df1aed83174a75685ede04aa010dfd4cc0646b62aa760bafcb66747cc1f15c610cf39718a2fc35bb45977c06e78ed999864f13a9a0074b571b780680ffac70eec8e72ac5e0391599bdeb289d5dbdc2e1c8cb750431341e01c133ba246b1fe96c7d3c849f35230a4546dd562ec9955c76fa9d0c985f6972393b5351c92444ae8a32b6f8ae6f4be030002c6805abd6e80147211707311236f5d311a42680433bfd67697756fd01af13bab1ae4d4aaf36ab3dad254c062fd5c484357cfe28b10bc32f593f90f8c59076a7140a02d084b4ce6805d88e21fd02588d455f66fd193ec191b7eaa650c15eafbf105a7a723e450d8ee65482dcf0fac5f134d74d982ed6c696ad3b89c81972bc5eb64fa1a80348ab12f1b13225bd1e6a66dc5ac263ec64c7cf21afdbff7193b5c50061c1d7327611f574fd4d6b8f4af1f532e3b6048d37cc309d331450885499ec89b73ce62822a2b46b6d47bb8b27cb1e6cee5ca6808a565304f9c44a3363a80bcfc2c6159af86bb78668ca2db5365e87a5ed8cf9d8a2fff3952f6ae343a01fe398baae6599f3ac793cfd0f77ce9f75e9a370588ff6c7c66bf158d87f98ff9092c74e77b7a58522818a1b1e9b8f0fba65e4c2708bfdaae60e0fd78c3f27b0f29f6ca9edf3a8d60339ea1fe3d591235f75114db5e98574d88c9a07ff17411d8d7ced89b92cd31b562f1c94a16d2f36b374ad647dd9a9fe2631209519976637fbf6e6c613808f1f1691f9f9bb5fcfaa0f89876c5e214d3704082f6ccea0770975e22c630000a799504eab68c7b94304fd78c747ffe5cd2859ab4db47fb3e8df9300f228f6518ef64eb1a14fa982dadda716b3f571485e68a6f2aee1553030d3445d140261ae74d5ed0ae95a677aa601382d0180e755c047c8abf83009dca1d4a105986453ca341c5368198db812ff8357f1e4284461ce4cd972eece79e04ef159f1aeb77ad2511f84083c79eea12943cea3ad1cd8cd0c8566aac69b360a81a25b69b2c48469026c9b8a351e5ce796040455f78912c6ffbbc4c59514743277c8929fcfc7d65c1df77b0788505bdea9edb5eb05aa214675df9a398eb5bf1a98ebf25569510e4d45a6bfe57a9ba51cad2d8d5d4061c53a0395171d793c9a407d67c568e23a3f3507f34910c04aa25fae184beb148c9f0bf4618648bf4c9383d5197f1f5ac658ab3b558c82ed2bee398547d4b0d86d8dcc6c487d97823fbd1a32928b3a2990d04e0829bb5fcb78f730277612d6b3fa39b90d509c424d720ea140cf2cf658a2e9388725ebf9d53bcffbfa947c46d81f85ca55afc842ee3d5a61070c9b3e2f975af32b5239e79607f40d606efd8d6c9190d6760bbed4eb36afd838c9dbb05d915c6aa2f72081c0b6d0b08d5c0f39d6efe73471fde6cc1e9e7e44908347c924b65b93c3bcaedf637f4e3563b5c39c78d4e921f55ab17a43157156986c1489ff19caf542a03b74a119d8ad01f73112bdb74d1c80885b939bd9ffab4bb262adffd4ca72ce060c70197c06f8ee5f1bb7b2df637936e3dfe35381b6229137979124a319c160395cb14b6187b7a6527ba8fd5b68df24818931f4f791d888b855e862cc171ea45876737d4ef75f47877ac3e9e6772a2a874121f6be4f790505a8fae7d04cfaf4b0a7ffc3b0583579c20c6ab0351ee6a333e52db63afe0bff09cb7150561d5ed8e2476658c1b0896c18bfa4d8b15a90bee7c837cb669129f73402a59ab7f3817eecf998e3d3bc4fab47a3d36f3711e8d638bf33c5972dc0d7ef708b91e6e4b031899800f03d4aa6ea564373578a6dc288c62f31a0de8035323a3d7c430845efd0238c30b34043fa683750af2b2a6ea9de8a78c9ebb4128a4124c256e1e5615e8e08938338a75c208919d1621d81a294b73264b0bb0227261817eae6d7af84f67ed609f21795c8ba6b8223a8b571bcd88ec79730dda6db073f2a78c0291bf10391d94aae982709f56bb819d7e0ae11868302412b20a713cd3510ae706c791d6867e58823fa89140404483649753462574d59f8479cac06b587f4277cce1cb80561f00532209bc2a65d5b0a1633cc3796c07951fd583c568511d320988be53355918c2924cc6fef7bf59aa489a6e3fb39f7ed1a2ff695771f45ed3c57dbee5a258c4572734d940d7ab97f304e0b1bfb8ae0b4273c198aa6c06608ea22b1a7c9dad06b0c782fa8e559aadf07893d98c2923038c59065362db236c03f76c1d98a3b145dcbf455b0e57d1c6b11f684f229b6a88b8c663ba0f895a1364f760d18a7dda89eb02ed178c114279acd1d042d1ec56a783f5fc7a3f5bd943bbb3619175a61934c2056a53581fb16e60e3b009f56d37a6cdbec0214bc7dcecfd55a080d0f35ffc401c7236eea8ceb028c3ad5937a6ab218d28af240ace171db5b31c6ecf8942b71a69697ac08479e938959455f805b03c6aa5e915adb5500d1a3ffb0cbb2a2c94c0bda61fa077d321cf17b7ae78144d232fa4ce046e61fefb521258e4196ef597f4e5259dd2c82d0bf1e1dc54a55638d79137e8b9d27a6ac7766e316ef22fdc54daa10bb270d222be34d30926bb2dc1cef014fe89ec2e171e0204dd7feb7ab276c8d6d58d38bbf7c25e26cc0c2fe8623b5f1a262706941fcabb50fb493c638d2205bcd8accab97d70ecb969b9df5c8576a9d76e2f1f84bad50508f285c8dec7abc81d7afe403f1fe7cebb20200edb108b98d363cb436536bf20a327cb38f47ea55fbc9a6184b35c1edb52e08649bdd3f43eb70187e9076ee03152d658ead80ff7b91886ca4b6cddf902d50c34f7bd78dbb558ea721f395f9cc43f6267be56935386ef31a33d91c0ac2e1e3e395efe5cbfbb0532d36a9358009975d336e8349efef27d5e8fbf9a7a492c7c26f8c15870837b2db7f78b89597622482a75eaba80820af9c4e794e8399fecce0be70baec6efbad74d2a0cbd2cad0fd48753e23d52eda44644d371122812d59ca4284b48dd45bc1503133bc58df2fcd027a6e0261f5e4012afcf4f89b544490c5c1b978dcadb2a6b3d64a90c060f150fdb5a4bc4e9b5ac9e746da8af6973053637bd2dc9d3bbe1a02dbde22701d4de313289bc037965e376bbe0a6c3cf3d6e6e5a20be401dabe5b772336558115c52bb67783b7416929b383f87d742e1e96cfb5f18bf004077f9645662d3af5ce930e46af87c54b3d2490711adb72941a26d0b9407c1e5262a09247a50481ffb5363a0e3c48304454c48c2b51941928aa6092fa2e1ccee8f608aab4d89b4508655ec3f6ec177e794528b388a0a1305956a9ea4815398fb9356c434ca5640c30ab3edc252c07ababad3caa345fed0c31cf66c78b623bc05500d32e51b20344d3b154656141758d0d1254871f24b153e428a160478dbd7879d34d90266f2086661b69f575807f01881db56146e6a6bd2a853e4a972430179cde339c53b7c6caa94a87dfc1a3577a95985574ac63a5a25699a519a821126b33f65c746d8f497253353a3d68240e274e4364401a9d03943d11baa69e1b9a51ed70988bf413a576e64cd0318f4ac5d90008a300501901a78aa14d644ab91df571a318d52267c74859ebbc0cb95351c21b0e15701d70ca09f0769639dd8ee52d216fc547d76be484c0e689b7aac1c9af029c129867cafcce6f7fce4af59ddae98968cf091e666353bc5e8ec0b5411bd5bf0a020fb6e6a2e44becbcc37087315d2725a56e641df39815665ef16e9742735260259d949f4343524975b0d0eea39b6d36492bdb74d733a6ce1913721986a6b6982629944b531c5fb8532eb345ab2332e9fb93dd50f6989a7f7789139cc3ba90a85b1bb829a0995c273c86741e48e8aea026bdafb45d506e021f2d2b8b208c9169d6e5e15d8d6e0580c85e2f062a85518acba0078fc2d9698b3cb113b010af40711839f0255dff3f3a32ec881f5cafda089f4623ae88dbc2a7d876bc551108fc57ef6d16ce90e66c61f5e838f32fe9c5d6d17e57002822c0199276b4d777e10e0f977b3429c16cb744762997b5605ea3fe66312ee8ce652f0a644399940ff5da741e337f6029bc67c9dd2b589fb3a9140c471967ce82b0e8099afed66066f7d77a04b831fb8d16721ef426f180147fef9e03ff85937cb0e96a5c987f783b32eb4878ea3f0500f3a0bb77715b2d38ca2dd7aad48f25f08f13156c19d7bd8fa0ea36201450f9c945dddfc8d9ddd8a25df8c1a91f843f403f975b51e3b29075e12c773b22823b933fe809194d27bf735a659a3f66d11634f8febffebd5e26b00edffe593e2798be63c645ea54f5b5b2f2f38e6ae151fb1569e40a5294aae6ff87ff1b519c9fb22ae5642d35fdca998f3001264524d5af9f14865e397f5afd01d4c1ecca33e4368f00129335ec4730e5eba7b07c46f52805d45d1bfa7810af06619c41a7ed8e43a78770f95f25269e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">文章已被加密，请联系作者获取密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">文章已被加密</summary>
    
    
    
    <category term="编程基础" scheme="https://jiangxueqiao.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Visual Studio" scheme="https://jiangxueqiao.com/tags/Visual-Studio/"/>
    
    <category term="Qt" scheme="https://jiangxueqiao.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>C99柔性数组</title>
    <link href="https://jiangxueqiao.com/post/2984623496.html"/>
    <id>https://jiangxueqiao.com/post/2984623496.html</id>
    <published>2024-07-21T08:00:03.000Z</published>
    <updated>2024-07-26T16:12:53.296Z</updated>
    
    <content type="html"><![CDATA[<p>在讲述柔性数组（Flexible Array）之前，首先要介绍一下不完整类型 (Incomplete Type)。不完全类型是暂时没有完全定义好的类型，缺乏足够的信息（例如长度、类型）去描述一个完整的类型。在C&#x2F;C++中不完全类型有三种不同形式：void、未指定长度的数组以及具有非指定内容的结构和类。</p><span id="more"></span><p>比如通过使用不完整类型可以在头文件中隐藏结构体定义的具体细节，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ring_buffer.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ring_buffer_type</span> <span class="title">ringbuf_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ring_buffer_create</span><span class="params">(<span class="type">ringbuf_t</span> **rcb, <span class="type">size_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ring_buffer_write</span><span class="params">(<span class="type">ringbuf_t</span> * rcb, <span class="type">uint8_t</span> *pdata, <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ring_buffer.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ring_buffer_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span>* data;</span><br><span class="line">    <span class="type">size_t</span>   size;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在C++中经常使用的“向前声明”也是不完整类型的具体应用。</p><p>关于柔性数组所使用的不完整类型则是“未指定长度的数组”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> str[];</span><br></pre></td></tr></table></figure><p>C99 将柔性数组纳入了标准之中，根据 C99 规定，柔性数组需要满足如下条件：</p><ol><li>柔性数组只应用在结构体中。</li><li>结构体中不能只有柔性数组一个成员，而且柔性数组必须是结构体的最后一个成员。</li><li>由于柔性数组没有指定大小，因此不占用存储空间。</li></ol><p>如下面结构体中的 data 数组就是柔性数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Package</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">char</span>* data[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 data 数组的长度为0，因此不占用存储空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(Package) == <span class="keyword">sizeof</span>(<span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>包含柔性数组成员的结构体需要使用 <code>malloc()</code> 函数进行内存的动态分配，并且分配的内存通常大于结构体的大小，多余的空间自动分配给了柔性数组，这样就可以用柔性数组来存储额外的数据了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> data[<span class="number">20</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dataLen = <span class="built_in">strlen</span>(data);</span><br><span class="line"></span><br><span class="line">Package* pck = (Package*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Package) + dataLen);</span><br><span class="line"><span class="keyword">if</span> (pck) &#123;</span><br><span class="line">    pck-&gt;len = dataLen;</span><br><span class="line">    <span class="built_in">memcpy</span>(pck-&gt;data, data, dataLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pck);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在讲述柔性数组（Flexible Array）之前，首先要介绍一下不完整类型 (Incomplete Type)。不完全类型是暂时没有完全定义好的类型，缺乏足够的信息（例如长度、类型）去描述一个完整的类型。在C&amp;#x2F;C++中不完全类型有三种不同形式：void、未指定长度的数组以及具有非指定内容的结构和类。&lt;/p&gt;</summary>
    
    
    
    <category term="C++语言" scheme="https://jiangxueqiao.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C99" scheme="https://jiangxueqiao.com/tags/C99/"/>
    
    <category term="柔性数组" scheme="https://jiangxueqiao.com/tags/%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>了解数字证书</title>
    <link href="https://jiangxueqiao.com/post/3462229631.html"/>
    <id>https://jiangxueqiao.com/post/3462229631.html</id>
    <published>2024-07-17T07:35:10.000Z</published>
    <updated>2025-02-17T09:42:51.677Z</updated>
    
    <content type="html"><![CDATA[<p>打开任何一个数字证书售卖网站都可以看到它们通常将数字证书分为两个大类：SSL证书和数字签名证书。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/Rg3jGGhwtv-TinyTu.png"></p><p>SSL证书的主要作用是对网站进行身份验证和传输数据加密；</p><p>数字签名主要用于验证信息的真实性和完整性，根据使用场景的不同大致分为如下几类：</p><ul><li>对客户端程序（.exe、.dll、.sys等文件）签名的代码签名证书。</li><li>对PDF等文档签名的文档签名证书。</li><li>对电子邮件及其附件签名和加密的邮件安全证书。</li></ul><span id="more"></span><h2 id="颁发机构"><a href="#颁发机构" class="headerlink" title="颁发机构"></a>颁发机构</h2><p>有很多机构都可以颁发数字证书，比如 GlobalSign、DigiCert、Geotrust、Sectigo、WoTrus、Entrust 等，有的机构只能颁发SSL证书，有的机构可以颁发所有类型的证书。</p><p>机构有大小之分，所颁发的证书也有知名度和认可度之分，价格也有高低之分。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/SCDi6zxPU5.png"></p><h2 id="DV、OV、EV的区别"><a href="#DV、OV、EV的区别" class="headerlink" title="DV、OV、EV的区别"></a>DV、OV、EV的区别</h2><p>首先介绍一下它们的全称：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DV = Domain Validation 域名验证</span><br><span class="line"></span><br><span class="line">OV = Organization Validation 机构验证</span><br><span class="line"></span><br><span class="line">EV = Extended Validation 扩展验证</span><br></pre></td></tr></table></figure><p>要了解 DV、OV 和 EV 这三类证书之间的区别，首先要了解 DigiCert 等证书颁发机构（CA）是如何颁发证书的。</p><p>CA 作为受信任的第三方，它通过验证申请者的几个细节来确定是否可以颁发证书。申请三种类型的证书所需要验证的条件从 DV -&gt; OV -&gt; EV 依次增加，这也就导致了三种类型的证书的可信度也是依次增加的。</p><p>在 DV 级别，验证流程相当短，只要求购买者证明其对域名的所有权。验证方式是CA向（WHOIS数据库所列的）域名所有者发送电子邮件。如果您立即需要证书，这算是一种便捷的验证方法，但这种只进行一项检查的验证形式是互联网中最低标准的验证形式，其相应的信任度也应该是最低的。由于 DV 证书只验证域名的所有权，因此 DV 类型的证书只存在于 SSL 证书中。</p><p>OV 和 EV 证书的区别在于获取证书所需要的额外的验证条件和步骤。对于EV和OV证书，CA必须验证域名所有者以及与证书相关联的企业的相关详细信息，包括名称、类型、状态和实际地址。</p><p>而要获得EV，还需要几个额外步骤，包括验证企业的对外电话号码、开展业务的年限、注册号和管辖权，以及域名欺诈检查、联系人黑名单检查并致电以验证申请者的就业情况。</p><blockquote><p>我们购买证书通常是通过CA机构在国内的代理商来申请和购买的，因此具体需要验证哪些材料，可以咨询代理商（如亚洲诚信、锐成信息、数安时代等等，多如牛毛），通常没有那么复杂，都是钱的事情。</p></blockquote><h2 id="SmartScreen"><a href="#SmartScreen" class="headerlink" title="SmartScreen"></a>SmartScreen</h2><p>在介绍 OV 和 EV 类型的代码签名证书的区别之前，我们有必要先了解一下 Windows 上的 SmartScreen 特性。</p><p>SmartScreen 全称 Microsoft Defender SmartScreen，是 Windows、Internet Explorer 和 Microsoft Edge 提供的一个可防止网络钓鱼、恶意软件网站、应用程序以及潜在恶意文件下载的安全功能。</p><p>SmartScreen 通过联机服务检查有关下载的应用程序的数字签名信息，以确定下载程序的信誉。如果此应用程序没有建立信誉，SmartScreen 会认为它是恶意程序的风险较高，就会向用户显示诸如“未知发布者”的警告。</p><p>下面是几种可能出现的 SmartScreen 警告的样式：</p><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/c5d108ee84859c278ff0d6e23dd19bc4.jpeg" width="600px" /></div><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/6f6d4e0ed662228932d96f34036f20b9.jpeg" width="600px" /></div><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/2UyXU94y7h.png" width="500px" /></div><p>对于此类警告，微软的建议是“使用代码签名对程序进行数字签名”，“使用属于 Windows 根证书计划的证书颁发机构(CA)颁发的代码签名证书”，以验证发布者的真实身份，确保应用程序代码的完整性。</p><p>使用 OV 类型证书签名的程序可能不会立即消除 SmartScreen 警告，需要累计一定的下载量后才会消除，微软没有公布具体的消除规则。但由于 EV 类型签名证书的审核规则更加严格，因此使用 EV 类型证书签名的程序可以立即消除该警告。</p><h2 id="代码签名证书OV和EV的区别"><a href="#代码签名证书OV和EV的区别" class="headerlink" title="代码签名证书OV和EV的区别"></a>代码签名证书OV和EV的区别</h2><p>下面列出了OV和EV类型的代码签名证书的不同之处。</p><blockquote><p>OV类型的代码签名证书也称之为普通或标准型代码签名证书。</p></blockquote><table><thead><tr><th>区别</th><th>OV代码签名证书</th><th>EV代码签名证书</th></tr></thead><tbody><tr><td>审核内容</td><td>企业信息</td><td>企业信息及其他的信息。<br/>绝大多数公司都是可以申请的，只是需要签署更多的材料而已</td></tr><tr><td>颁发周期</td><td>时间不固定，1周左右</td><td>时间不固定，1~2周左右</td></tr><tr><td>可签名的软件类型</td><td>只支持签名应用软件，<br/>如.exe、.dll、.cab、.ocx、.msi、.xpi，<br/>不能签名驱动程序</td><td>支持签名应用软件和驱动程序</td></tr><tr><td>Windows硬件认证<br/>（WHQL）<br/>亦称徽标认证</td><td>不支持</td><td>支持</td></tr><tr><td>SmartScreen即时信誉</td><td>通过累计获得信誉，<br/>但微软未公布具体规则</td><td>立即获得</td></tr></tbody></table><h2 id="如何区分OV和EV代码签名"><a href="#如何区分OV和EV代码签名" class="headerlink" title="如何区分OV和EV代码签名"></a>如何区分OV和EV代码签名</h2><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/sSqxH2uXQu-TinyTu.png" width="600px" /></div><p>从上图可以看出，EV证书比OV证书多了很多字段。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;打开任何一个数字证书售卖网站都可以看到它们通常将数字证书分为两个大类：SSL证书和数字签名证书。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-static.jiangxueqiao.com/blog/img/Rg3jGGhwtv-TinyTu.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;SSL证书的主要作用是对网站进行身份验证和传输数据加密；&lt;/p&gt;
&lt;p&gt;数字签名主要用于验证信息的真实性和完整性，根据使用场景的不同大致分为如下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对客户端程序（.exe、.dll、.sys等文件）签名的代码签名证书。&lt;/li&gt;
&lt;li&gt;对PDF等文档签名的文档签名证书。&lt;/li&gt;
&lt;li&gt;对电子邮件及其附件签名和加密的邮件安全证书。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="项目管理" scheme="https://jiangxueqiao.com/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="数字证书" scheme="https://jiangxueqiao.com/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
    
    <category term="代码签名" scheme="https://jiangxueqiao.com/tags/%E4%BB%A3%E7%A0%81%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>玩转Qt 2D绘图之仪表盘实例</title>
    <link href="https://jiangxueqiao.com/post/29874871.html"/>
    <id>https://jiangxueqiao.com/post/29874871.html</id>
    <published>2024-06-26T05:55:02.000Z</published>
    <updated>2024-06-26T04:32:36.466Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的《玩转 Qt 2D 绘图》系列文章中，已经介绍了 2D 绘图中常用的知识，本文主要通过一个汽车仪表盘的实例来综合应用前面所介绍知识点，并且还介绍了一些 Qt 绘图的常用技巧。</p><p>相关文章：</p><ul><li><a href="/post/847642761.html" title="玩转Qt 2D绘图之坐标系">玩转Qt 2D绘图之坐标系</a></li><li><a href="/post/1336811290.html" title="玩转Qt 2D绘图之画家的工具">玩转Qt 2D绘图之画家的工具</a></li><li><a href="/post/1967189103.html" title="玩转Qt 2D绘图之画家">玩转Qt 2D绘图之画家</a></li></ul><span id="more"></span><p>实例效果图如下：</p><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/Sample_E8gfEIPtUV.gif" width="360px"></div><p>本实例主要涉及如下知识点：</p><ul><li>坐标系的缩小、旋转、位移</li><li>绘制线条、圆、饼状图、多边形、文本</li><li>画笔、画刷的应用</li><li>三角函数的应用</li></ul><p>废话不多说，下面开始分布讲解仪表盘的绘制步骤。为了便于后面的描述，我们先将控件上的各个元素进行标注：</p><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/XXcXz2Xl7D-TinyTu.png" width="480px"></div><h2 id="1-坐标系设置"><a href="#1-坐标系设置" class="headerlink" title="1. 坐标系设置"></a>1. 坐标系设置</h2><h3 id="1-1-圆的半径"><a href="#1-1-圆的半径" class="headerlink" title="1.1 圆的半径"></a>1.1 圆的半径</h3><p>仪表盘是一个圆，因此需要先确定圆的中心点和半径，中心点位于 QWidget 的中心，而 QWidget 可能并不是正方形，因此只能以最短边来确定圆的半径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> qreal width = <span class="keyword">this</span>-&gt;<span class="built_in">width</span>();</span><br><span class="line"><span class="type">const</span> qreal height = <span class="keyword">this</span>-&gt;<span class="built_in">height</span>();</span><br><span class="line"><span class="type">const</span> qreal side = <span class="built_in">qMin</span>(width, height); <span class="comment">// 最短边</span></span><br><span class="line"><span class="type">const</span> qreal radius = side / <span class="number">2.0</span>; <span class="comment">// 半径</span></span><br></pre></td></tr></table></figure><h3 id="1-2-坐标系缩放"><a href="#1-2-坐标系缩放" class="headerlink" title="1.2 坐标系缩放"></a>1.2 坐标系缩放</h3><p>假设当外圆的半径为 100 时，我们将内圆的半径设计为 85，中心圆的半径设计为 45，刻度数字字体设计为 10px，等等。 </p><p>由于仪表板控件是一个通用型的控件，因此在实际应用中，其长宽并不固定为100px，其可以为任意值，为了保持美观和协调性，外圆、内圆、中心圆、数字字体等元素的大小都需要根据控件的大小而动态的改变。我们可以通过百分比的方式来设置各个元素的大小，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qreal r1 = side / <span class="number">2.0</span>; <span class="comment">// 外圆半径</span></span><br><span class="line">qreal r2 = r1 * <span class="number">0.85</span>; <span class="comment">// 内圆半径为外圆的85%</span></span><br><span class="line">qreal r3 = r1 * <span class="number">0.45</span>; <span class="comment">// 中心圆的半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字体大小则根据 半径100 -&gt; 10px 这个基础来缩小和放大</span></span><br><span class="line">qreal fz = <span class="number">10</span> * (r1 / <span class="number">100.0</span>);</span><br></pre></td></tr></table></figure><p>看了上面的代码，相信大家已经有了明显的感受：需要手动计算百分比，太繁琐了，而且字体大小的缩放也不够线性。</p><p>的确如此，针对这些问题，我们可以通过下面的方案来解决。</p><p>在实际项目开发中，控件的样式通常不是程序员自己凭空想象的，而是经过设计师或美工设计出来的，设计师通过蓝湖、figma 等工具将效果图交付给开发人员，这些工具都带有尺寸标注功能，开发人员可以方便的获取设计尺寸。我们在开发时可以直接以设计尺寸来进行开发，不再计算百分比，改为动态的对坐标系进行缩放来适应实际尺寸。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> qreal width = <span class="keyword">this</span>-&gt;<span class="built_in">width</span>();</span><br><span class="line"><span class="type">const</span> qreal height = <span class="keyword">this</span>-&gt;<span class="built_in">height</span>();</span><br><span class="line"><span class="type">const</span> qreal side = <span class="built_in">qMin</span>(width, height);</span><br><span class="line">painter.<span class="built_in">scale</span>(side / <span class="number">200.0</span>, side / <span class="number">200.0</span>);  <span class="comment">// 设计师所设计的的长宽为200*200</span></span><br></pre></td></tr></table></figure><h3 id="1-3-坐标系原点"><a href="#1-3-坐标系原点" class="headerlink" title="1.3 坐标系原点"></a>1.3 坐标系原点</h3><p>为了方便绘制，我们通常还将坐标系的原点移动到圆的中心点位置，当然这不是必须的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">translate</span>(width / <span class="number">2</span>, height / <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="2-绘制外圆"><a href="#2-绘制外圆" class="headerlink" title="2. 绘制外圆"></a>2. 绘制外圆</h2><p>控件是包含各种不同的元素，如外圆、内圆、刻度、指针等，一层一层的叠加在 QWidget 上面，从而组成了一个完整的控件。在绘制时，我们通常从最底层元素开始绘制，然后再一层一层地绘制上层元素。</p><p>本实例中，我们先绘制外圆，然后绘制内圆，一层一层的叠加（本文的章节顺序即为元素的绘制顺序）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制外圆</span></span><br><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">80</span>, <span class="number">80</span>, <span class="number">80</span>));</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPointF</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="number">100.0</span>, <span class="number">100.0</span>);</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/BOKo4yqRIC-TinyTu.png" width="300px"></div><h2 id="3-绘制内圆"><a href="#3-绘制内圆" class="headerlink" title="3. 绘制内圆"></a>3. 绘制内圆</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">60</span>, <span class="number">60</span>, <span class="number">60</span>));</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPointF</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="number">85.0</span>, <span class="number">85.0</span>);</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/WOJRb9auYy-TinyTu.png" width="300px"></div><h2 id="4-绘制三色饼状图"><a href="#4-绘制三色饼状图" class="headerlink" title="4. 绘制三色饼状图"></a>4. 绘制三色饼状图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startAngle_ 和 endAngle_ 起始和结束角度</span></span><br><span class="line"><span class="comment">// qreal startAngle_ = -30;</span></span><br><span class="line"><span class="comment">// qreal endAngle_ = 210;</span></span><br><span class="line"></span><br><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    qreal end = endAngle_;</span><br><span class="line">    qreal spanAngles = (endAngle_ - startAngle_) * <span class="number">0.7</span>;  <span class="comment">// 0 ~ 70%</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">24</span>, <span class="number">189</span>, <span class="number">155</span>));</span><br><span class="line">    painter.<span class="built_in">drawPie</span>(<span class="number">-55</span>, <span class="number">-55</span>, <span class="number">110</span>, <span class="number">110</span>, (end - spanAngles) * <span class="number">16</span>, spanAngles * <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    end -= spanAngles;</span><br><span class="line">    spanAngles = (endAngle_ - startAngle_) * <span class="number">0.15</span>;  <span class="comment">// 70% ~ 85%</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">218</span>, <span class="number">218</span>, <span class="number">0</span>));</span><br><span class="line">    painter.<span class="built_in">drawPie</span>(<span class="number">-55</span>, <span class="number">-55</span>, <span class="number">110</span>, <span class="number">110</span>, (end - spanAngles) * <span class="number">16</span>, spanAngles * <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    end -= spanAngles;</span><br><span class="line">    spanAngles = (endAngle_ - startAngle_) * <span class="number">0.15</span>;  <span class="comment">// 85% ~ 100%</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">107</span>, <span class="number">107</span>));</span><br><span class="line">    painter.<span class="built_in">drawPie</span>(<span class="number">-55</span>, <span class="number">-55</span>, <span class="number">110</span>, <span class="number">110</span>, (end - spanAngles) * <span class="number">16</span>, spanAngles * <span class="number">16</span>);</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/fMx4SF5KjH-TinyTu.png" width="300px"></div><h2 id="5-绘制中心圆"><a href="#5-绘制中心圆" class="headerlink" title="5. 绘制中心圆"></a>5. 绘制中心圆</h2><p>绘制中心圆，用于覆盖饼圆的中心。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPointF</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="number">45</span>, <span class="number">45</span>);</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/sl94DkqmCV-TinyTu.png" width="300px"></div><h2 id="6-绘制刻度线"><a href="#6-绘制刻度线" class="headerlink" title="6. 绘制刻度线"></a>6. 绘制刻度线</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// majorScaleNum_ 指定有多少个大刻度线</span></span><br><span class="line"><span class="comment">// scaleNumPerMajor_ 指定每2个大刻度线间隔内有多少个小刻度线</span></span><br><span class="line"><span class="comment">// int majorScaleNum_ = 10;</span></span><br><span class="line"><span class="comment">// int scaleNumPerMajor_ = 10;</span></span><br><span class="line"></span><br><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    QPen pen;</span><br><span class="line">    pen.<span class="built_in">setColor</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">    pen.<span class="built_in">setCapStyle</span>(Qt::RoundCap);</span><br><span class="line">    pen.<span class="built_in">setWidthF</span>(<span class="number">1.0</span>);</span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalScaleNum = majorScaleNum_ * scaleNumPerMajor_;</span><br><span class="line">    qreal angleStep = (endAngle_ - startAngle_) / (qreal)totalScaleNum;</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">rotate</span>(<span class="number">360</span> - endAngle_);  <span class="comment">// rotate 按顺时针方向旋转</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= totalScaleNum; i++) {</span><br><span class="line">        <span class="keyword">if</span> (i % scaleNumPerMajor_ == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 绘制大刻度</span></span><br><span class="line">            painter.<span class="built_in">drawLine</span>(<span class="built_in">QPointF</span>(<span class="number">57.0</span>, <span class="number">0.0</span>), <span class="built_in">QPointF</span>(<span class="number">72.0</span>, <span class="number">0.0</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 绘制小刻度</span></span><br><span class="line">            painter.<span class="built_in">drawLine</span>(<span class="built_in">QPointF</span>(<span class="number">57.0</span>, <span class="number">0.0</span>), <span class="built_in">QPointF</span>(<span class="number">64.0</span>, <span class="number">0.0</span>));</span><br><span class="line">        }</span><br><span class="line">        painter.<span class="built_in">rotate</span>(angleStep);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/gTjzwR61S4-TinyTu.png" width="300px"></div><h2 id="7-绘制刻度数字"><a href="#7-绘制刻度数字" class="headerlink" title="7. 绘制刻度数字"></a>7. 绘制刻度数字</h2><p>因为数字始终是从左到右的方向绘制的，而绘制刻度时会改变坐标轴的方向，因此数字不能与刻度一起绘制。</p><p>使用三角函数计算文字矩形区域下横线中间点位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    QPen pen;</span><br><span class="line">    pen.<span class="built_in">setColor</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line"></span><br><span class="line">    QFont font;</span><br><span class="line">    font.<span class="built_in">setPixelSize</span>(<span class="number">10</span>);</span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line"></span><br><span class="line">    <span class="function">QFontMetrics <span class="title">fm</span><span class="params">(font)</span></span>;</span><br><span class="line">    <span class="type">int</span> txtHeight = fm.<span class="built_in">height</span>();</span><br><span class="line"></span><br><span class="line">    qreal angleStep = (endAngle_ - startAngle_) / majorScaleNum_;</span><br><span class="line">    qreal stepNum = (maxValue_ - minValue_) / majorScaleNum_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= majorScaleNum_; i++) {</span><br><span class="line">        qreal angle = startAngle_ + i * angleStep;</span><br><span class="line">        qreal x = <span class="built_in">qCos</span>(<span class="built_in">qDegreesToRadians</span>(angle)) * <span class="number">74.0</span>;</span><br><span class="line">        qreal y = -<span class="built_in">qSin</span>(<span class="built_in">qDegreesToRadians</span>(angle)) * <span class="number">74.0</span>;  <span class="comment">// 纵坐标与数学坐标系相反</span></span><br><span class="line"></span><br><span class="line">        QString txt = QString::<span class="built_in">number</span>((<span class="type">int</span>)((majorScaleNum_ - i) * stepNum));  <span class="comment">// 大数在右边，小数在左边，先绘制大数</span></span><br><span class="line">        <span class="type">int</span> txtWidth = fm.<span class="built_in">horizontalAdvance</span>(txt);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IS_NEARLY_EQUAL</span>(x, <span class="number">0.0</span>)) {</span><br><span class="line">            painter.<span class="built_in">drawText</span>(<span class="built_in">QRectF</span>(x - txtWidth / <span class="number">2</span>, y - txtHeight, txtWidth, txtHeight), Qt::AlignCenter, txt);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IS_NEARLY_EQUAL</span>(y, <span class="number">0.0</span>)) {</span><br><span class="line">            painter.<span class="built_in">drawText</span>(<span class="built_in">QRectF</span>(x, y - txtHeight / <span class="number">2</span>, txtWidth, txtHeight), Qt::AlignVCenter | Qt::AlignLeft, txt);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">0.0</span>)</span><br><span class="line">                painter.<span class="built_in">drawText</span>(<span class="built_in">QRectF</span>(x, y - txtHeight / <span class="number">2</span>, txtWidth, txtHeight), Qt::AlignVCenter | Qt::AlignLeft, txt);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                painter.<span class="built_in">drawText</span>(<span class="built_in">QRectF</span>(x - txtWidth, y - txtHeight / <span class="number">2</span>, txtWidth, txtHeight), Qt::AlignVCenter | Qt::AlignRight, txt);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/jAexo1JyUu-TinyTu.png" width="300px"></div><h2 id="8-绘制当前指针"><a href="#8-绘制当前指针" class="headerlink" title="8. 绘制当前指针"></a>8. 绘制当前指针</h2><p>指针样式实际为三个点组成的三角形。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maxValue_ 和 minValue_ 为设置的刻度最大值和最小值</span></span><br><span class="line"><span class="comment">// qreal minValue_ = 0.0;</span></span><br><span class="line"><span class="comment">// qreal maxValue_ = 100.0;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> qreal anglePerValue = (endAngle_ - startAngle_) / (maxValue_ - minValue_);</span><br><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">107</span>, <span class="number">107</span>, <span class="number">204</span>));</span><br><span class="line"></span><br><span class="line">    QPolygon pts;</span><br><span class="line">    pts.<span class="built_in">setPoints</span>(<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">-5</span>, <span class="number">64</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    qreal rotateAngle = <span class="number">360.0</span> - endAngle_;</span><br><span class="line">    rotateAngle += anglePerValue * (curValue_ - minValue_);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">rotate</span>(rotateAngle);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">drawPolygon</span>(pts);</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/7ATgnp1HUv-TinyTu.png" width="300px"></div><h2 id="9-绘制中心小圆"><a href="#9-绘制中心小圆" class="headerlink" title="9. 绘制中心小圆"></a>9. 绘制中心小圆</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">    <span class="comment">// 红色圆</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">107</span>, <span class="number">107</span>));</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPointF</span>(<span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">20.0</span>, <span class="number">20.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 白色圆</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPointF</span>(<span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">16.0</span>, <span class="number">16.0</span>);</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/1aLsEMb30H-TinyTu.png" width="300px"></div><h2 id="10-绘制当前值"><a href="#10-绘制当前值" class="headerlink" title="10. 绘制当前值"></a>10. 绘制当前值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line">{</span><br><span class="line">    QFont font = painter.<span class="built_in">font</span>();</span><br><span class="line">    font.<span class="built_in">setPixelSize</span>(<span class="number">14</span>);</span><br><span class="line">    font.<span class="built_in">setBold</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-16</span>, <span class="number">-16</span>, <span class="number">32</span>, <span class="number">32</span>, Qt::AlignCenter, QString::<span class="built_in">number</span>(curValue_));</span><br><span class="line">}</span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br></pre></td></tr></table></figure><div style="text-aligin:center;"><img src="https://blog-static.jiangxueqiao.com/blog/img/c4Hmp4lcrz-TinyTu.png" width="300px"></div><p>至此，大功告成，齐活！</p><hr><p>控件演示程序下载地址：</p><p><a href="https://github.com/winsoft666/qt-custom-2d-controls">https://github.com/winsoft666/qt-custom-2d-controls</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面的《玩转 Qt 2D 绘图》系列文章中，已经介绍了 2D 绘图中常用的知识，本文主要通过一个汽车仪表盘的实例来综合应用前面所介绍知识点，并且还介绍了一些 Qt 绘图的常用技巧。&lt;/p&gt;
&lt;p&gt;相关文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/post/847642761.html&quot; title=&quot;玩转Qt 2D绘图之坐标系&quot;&gt;玩转Qt 2D绘图之坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/1336811290.html&quot; title=&quot;玩转Qt 2D绘图之画家的工具&quot;&gt;玩转Qt 2D绘图之画家的工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/1967189103.html&quot; title=&quot;玩转Qt 2D绘图之画家&quot;&gt;玩转Qt 2D绘图之画家&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Qt" scheme="https://jiangxueqiao.com/categories/Qt/"/>
    
    
    <category term="Qt" scheme="https://jiangxueqiao.com/tags/Qt/"/>
    
  </entry>
  
</feed>
