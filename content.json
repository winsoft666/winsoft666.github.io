{"posts":[{"title":"留言板","text":"来都来了，那就留下点什么吧！","link":"/post/2185937873.html"},{"title":"CMake依赖库查找相关问题","text":"1. 如何查找 Vcpkg 安装的依赖库在 CMake 工具中指定跨平台工具链，如图： 指定 Toolchain 文件D:/sourcecode/vcpkg/scripts/buildsystems/vcpkg.cmake。 2. 如何查找本机安装的 Qt 库设置环境变量CMAKE_PREFIX_PATH，值为 Qt 的安装目录，如C:\\Qt\\5.15.2\\msvc2019，然后启动 CMake 即可。 也可以使用如下批处理来临时设置和启动： 123@echo offset CMAKE_PREFIX_PATH=C:\\Qt\\5.15.2\\msvc2019start \"\" \"C:\\Program Files\\CMake\\bin\\cmake-gui.exe\"","link":"/post/2291877732.html"},{"title":"Vcpkg使用仓库最新代码","text":"在向Vcpkg提交port时，我们会不断地对仓库进行修改和调试。如果采用REF方式指定源码版本，则需要不断地修改REF和SHA512，我们可以采用HEAD_REF的方式来简化调试流程。 在portfile.cmake文件中指定HEAD_REF，如： 123456vcpkg_from_github( OUT_SOURCE_PATH SOURCE_PATH REPO winsoft666/ashe HEAD_REF main AUTHORIZATION_TOKEN $ENV{GITHUB_TOKEN}) 安装时指定--head参数： 1vcpkg install ashe:x64-windows-static --head","link":"/post/2065175920.html"},{"title":"CMake按目录层级进行分组","text":"为了提高项目的可维护性，我们通常会将不同用途的代码文件放到不同的文件夹中，如头文件放到include目录，源文件放到src目录，第三方库放到3rd目录等。 当使用CMake生成Visual Studio工程时，我们亦希望在Visual Studio中能看到这样的文件结构。当然，我们可以使用source_group指令进行添加，但当目录和层级很多时，这样添加起来就显得比较繁琐了，本文介绍一种懒人方法。 函数group_sources用于遍历传入文件并根据文件所在目录添加source_group指令。 1234567891011121314151617function(group_sources) foreach(_source IN ITEMS ${ARGN}) if (IS_ABSOLUTE \"${_source}\") file(RELATIVE_PATH _source_rel \"${CMAKE_CURRENT_SOURCE_DIR}\" \"${_source}\") else() set(_source_rel \"${_source}\") endif() # 获取文件所在目录 get_filename_component(_source_path \"${_source_rel}\" PATH) # 替换为Windows路径样式 string(REPLACE \"/\" \"\\\\\" _source_path_msvc \"${_source_path}\") source_group(\"${_source_path_msvc}\" FILES \"${_source}\") endforeach()endfunction(group_sources) 函数group_sources支持传入多个参数，使用方法如下： 12345file(GLOB_RECURSE HEADER_FILES ./include/*.hpp ./include/*.h)file(GLOB_RECURSE SOURCE_FILES ./src/*.cc ./src/*.cpp)# 安装目录层级对${HEADER_FILES}和${SOURCE_FILES}中的文件进行分组group_sources(${HEADER_FILES} ${SOURCE_FILES})","link":"/post/1531265402.html"},{"title":"Vcpkg安装port历史版本","text":"截至 2023-05-22：vcpkg 仅支持在 manifest 模式下指定 port 的版本，在命令行模式下不支持指定 port 版本。 本文介绍如何在 Vcpkg 命令行模式下安装 port 时如何指定版本。 使用 Git 命令查看当前 Vcpkg 仓库的 baseline： 1git rev-parse HEAD 创建vcpkg_json目录，并在该目录下创建vcpkg.json文件（以 openssl 为例）： 1234567891011{ \"name\": \"cc\", \"version\": \"1.0.1\", \"builtin-baseline\": \"7b30311f0a79d395bf2d933d82fec1853c6a4e77\", \"dependencies\": [ {\"name\": \"openssl\"} ], \"overrides\": [ { \"name\": \"openssl\", \"version-string\": \"1.1.1n#1\" } ]} 使用如下命令安装： 1vcpkg install --triplet \"x64-windows\" \"--x-manifest-root=D:\\vcpkg_json\\\\\" \"--x-install-root=D:CODE\\vcpkg\\installed\\\\\"","link":"/post/1142527271.html"},{"title":"Vcpkg访问Github私有仓库","text":"Vcpkg 默认只支持从公共代码仓库进行下载编译，本文介绍如何使用 Vcpkg 从私有仓库进行源码下载/编译/安装。 1.在 Github 中添加 TOKEN 2. 添加 Windows 环境变量：VCPKG_KEEP_ENV_VARS值为GITHUB_TOKEN GITHUB_TOKEN值为第一步生成的 TOKEN 3.修改 portfile.cmake在vcpkg\\ports目录下，找到对应库的 portfile.cmake 文件，加入AUTHORIZATION_TOKEN参数。 123456vcpkg_from_github( OUT_SOURCE_PATH SOURCE_PATH REPO xxx/xxx HEAD_REF main AUTHORIZATION_TOKEN $ENV{GITHUB_TOKEN})","link":"/post/1904533666.html"},{"title":"C&#x2F;C++不同整数类型的区别","text":"在C/C++中涉及的整数相关的类型大致有如下几种： char、unsigned char short、unsigned short int、unsigned int long、unsigned long long long、unsigned long long int8_t、uint8_t int32_t、uint32_t int64_t、uint64_t DWORD DWORD32、DWORD64 size_t、ssize_t SIZE_T、SSIZE_T 一、原生数据类型以下数据类型C/C++语言中的原生整数类型，其长度取决于所使用的计算机系统和编译器： short、unsigned short int、unsigned int long、unsigned long long long、unsigned long long 如果需要开发跨平台的、具有良好可移植性的程序，请不要使用这些数据类型。通常情况下，这些数据类型所占字节数如下表所示： 数据类型 字节数 范围 char 1 -128 ~ 127 unsigned char 1 0 ~ 255 short 2 -32,768 ~ 32,767 unsigned short 2 0 ~ 65,535 int 4 -2,147,483,648 ~ 2,147,483,647 unsigned int 0 0 ~ 4,294,967,295 long 4 -2,147,483,648 ~ 2,147,483,647 unsigned long 4 0 ~ 4,294,967,295 long long 8 -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 unsigned long long 8 0 ~ 18,446,744,073,709,551,615 二、int*_t数据类型int*_t格式的数据类型是使用typedef重新定义的数据类型。通过在不同的编译环境进行重定义，确保其所占用的字节数始终相同（即数据范围也相同）。 数据类型 字节数 范围 int8_t 1 -128 ~ 127 uint8_t 1 0 ~ 255 int32_t 4 -2,147,483,648 ~ 2,147,483,647 uint32_t 4 0 ~ 4,294,967,295 int64_t 8 -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 uint64_t 8 0 ~ 18,446,744,073,709,551,615 三、size_t和std::size_tsize_t和std::size_t是不同的数据类型，size_t是定义在C语言的头文件，而std::size_t定义在C++标准库的&lt;cstddef&gt;头文件中。 虽然二者是不同的数据类型，但std::size_t在实现上兼容size_t了，二者所占的字节数始终相同。 size_t和std::size_t都是无符号整型，它们在32位编译环境占用4字节，64位编译环境占8字节。 如果需要使用有符号的size_t类型，在Linux上可以使用ssize_t类型，Windows上可以使用SSIZE_T类型。 四、DWORD和DWORD32、DWORD64DWORD是32位无符号整型（范围0 ~ 4,294,967,295） DWORD32是32位无符号整型（范围0 ~ 4,294,967,295）,DWORD64是64位无符号整型（范围0 ~ 18,446,744,073,709,551,615）。 而DWORD也是32位无符号整型（范围0 ~ 4,294,967,295），可能微软在设计之初是打算让DWORD在不同的编译环境具有不同的位数，但从目前情况来看，这种希望已然破灭，DWORD将永远是32位的无符号整型。 五、一点点建议为了保证程序的可移植性，请在开发中只使用固定字节数的数据类型，如int8_t、int32_t、int64_t。","link":"/post/2418701368.html"},{"title":"C++内存池实现","text":"本文从实际需求出发，介绍了内存池的实现原理，并且提供了具体的实现方案。 一、为什么需要使用内存池在 C/C++中我们通常使用malloc,free或new,delete来动态分配内存。一方面，因为这些函数涉及到了系统调用，所以频繁的调用必然会导致程序性能的损耗； 另一方面，频繁的分配和释放小块内存会导致大量的内存碎片的产生，当碎片积累到一定的量之后，将无法分配到连续的内存空间，系统不得不进行碎片整理来满足分配到连续的空间，这样不仅会导致系统性能损耗，而且会导致程序对内存的利用率低下。 当然，如果我们的程序不需要频繁的分配和释放小块内存，那就没有使用内存池的必要，直接使用malloc,free或new,delete函数即可。 二、内存池的实现方案内存池的实现原理大致如下：提前申请一块大内存由内存池自己管理，并分成小片供给程序使用。程序使用完之后将内存归还到内存池中（并没有真正的从系统释放），当程序再次从内存池中请求内存时，内存池将池子中的可用内存片返回给程序使用。 我们在设计内存池的实现方案时，需要考虑到以下问题： 内存池是否可以自动增长？如果内存池的最大空间是固定的（也就是非自动增长），那么当内存池中的内存被请求完之后，程序就无法再次从内存池请求到内存。所以需要根据程序对内存的实际使用情况来确定是否需要自动增长。 内存池的总内存占用是否只增不减？如果内存池是自动增长的，就涉及到了“内存池的总内存占用是否是只增不减”这个问题了。试想，程序从一个自动增长的内存池中请求了 1000 个大小为 100KB 的内存片，并在使用完之后全部归还给了内存池，而且假设程序之后的逻辑最多只需要 10 个 100KB 的内存片，该内存池中的 900 个 100KB 的内存片就一直处于闲置状态，程序内存占用就一直降下来。对内存占用大小有要求的程序需要考虑到这一点。 内存池中内存片的大小是否固定？如果每次从内存池中的请求的内存片的大小如果不固定，那么内存池中的每个可用内存片的大小就不一致，程序再次请求内存片的时候，内存池就需要在“匹配最佳大小的内存片”和“匹配操作时间”上作出衡量。“最佳大小的内存片”虽然可以减少内存的浪费，但可能会导致“匹配时间”变长。 内存池是否是线程安全的？是否允许在多个线程中同时从同一个内存池中请求和归还内存片？这个线程安全可以由内存池来实现，也可以由使用者来保证。 内存片分配出去之前和归还到内存池之后，其中的内容是否需要被清除？程序可能出现将内存片归还给内存池之后，仍然使用内存片的地址指针进行内存读写操作，这样就会导致不可预期的结果。将内容清零只能尽量的（也不一定能）将问题抛出来，但并不能解决任何问题，而且将内容清零会消耗一定的 CPU 时间。所以，最终最好还是需要由内存池的使用者来保证这种安全性。 是否兼容std::allocator？STL 标准库中的大多类都支持用户提供一个自定义的内存分配器，默认使用的是std::allocator，如std::string：typedef basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt; string; 如果我们的内存池兼容 std::allocator，那么我们就可以使用我们自己的内存池来替换默认的 std::allocator 分配器，如：typedef basic_string&lt;char, char_traits&lt;char&gt;, MemoryPoll&lt;char&gt; &gt; mystring; 关于如何兼容std::allocator，可以参考http://www.cplusplus.com/reference/memory/allocator/ 三、内存池的具体实现计划实现一个内存池管理的类MemoryPool，它具有如下特性： 内存池的总大小自动增长。 内存池中内存片的大小固定。 支持线程安全。 在内存片被归还之后，清除其中的内容。 兼容std::allocator。 因为内存池的内存片的大小是固定的，不涉及到需要匹配最合适大小的内存片，由于会频繁的进行插入、移除的操作，但查找比较少，故选用链表数据结构来管理内存池中的内存片。 MemoryPool 中有 2 个链表，它们都是双向链表（设计成双向链表主要是为了在移除指定元素时，能够快速定位该元素的前后元素，从而在该元素被移除后，将其前后元素连接起来，保证链表的完整性）： data_element_ 记录以及分配出去的内存片。 free_element_ 记录未被分配出去的内存片。 3.1 MemoryPool实现代码下面是完整的内存池实现的代码，代码中使用了 std::mutex 等 C++11 才支持的特性，所以需要编译器最低支持 C++11。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302/* MemoryPool.hpp */#ifndef MEMORY_POOL_H_#define MEMORY_POOL_H_#include &lt;climits&gt;#include &lt;cstddef&gt;#include &lt;mutex&gt;template &lt;typename T, size_t BlockSize = 4096, bool ZeroOnDeallocate = true&gt;class MemoryPool {public: /* Member types */ typedef T value_type; typedef T* pointer; typedef T&amp; reference; typedef const T* const_pointer; typedef const T&amp; const_reference; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef std::false_type propagate_on_container_copy_assignment; typedef std::true_type propagate_on_container_move_assignment; typedef std::true_type propagate_on_container_swap; template &lt;typename U&gt; struct rebind { typedef MemoryPool&lt;U&gt; other; }; /* Member functions */ MemoryPool() noexcept; MemoryPool(const MemoryPool&amp; memoryPool) noexcept; MemoryPool(MemoryPool&amp;&amp; memoryPool) noexcept; template &lt;class U&gt; MemoryPool(const MemoryPool&lt;U&gt;&amp; memoryPool) noexcept; ~MemoryPool() noexcept; MemoryPool&amp; operator=(const MemoryPool&amp; memoryPool) = delete; MemoryPool&amp; operator=(MemoryPool&amp;&amp; memoryPool) noexcept; pointer address(reference x) const noexcept; const_pointer address(const_reference x) const noexcept; // Can only allocate one object at a time. n and hint are ignored pointer allocate(size_type n = 1, const_pointer hint = 0); void deallocate(pointer p, size_type n = 1); size_type max_size() const noexcept; template &lt;class U, class... Args&gt; void construct(U* p, Args&amp;&amp;... args); template &lt;class U&gt; void destroy(U* p); template &lt;class... Args&gt; pointer newElement(Args&amp;&amp;... args); void deleteElement(pointer p);private: struct Element_ { Element_* pre; Element_* next; }; typedef char* data_pointer; typedef Element_ element_type; typedef Element_* element_pointer; element_pointer data_element_; element_pointer free_element_; std::recursive_mutex m_; size_type padPointer(data_pointer p, size_type align) const noexcept; void allocateBlock(); static_assert(BlockSize &gt;= 2 * sizeof(element_type), \"BlockSize too small.\");};template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::size_type MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::padPointer(data_pointer p, size_type align) const noexcept { uintptr_t result = reinterpret_cast&lt;uintptr_t&gt;(p); return ((align - result) % align);}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::MemoryPool() noexcept { data_element_ = nullptr; free_element_ = nullptr;}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::MemoryPool(const MemoryPool&amp; memoryPool) noexcept : MemoryPool() {}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::MemoryPool(MemoryPool&amp;&amp; memoryPool) noexcept { std::lock_guard&lt;std::recursive_mutex&gt; lock(m_); data_element_ = memoryPool.data_element_; memoryPool.data_element_ = nullptr; free_element_ = memoryPool.free_element_; memoryPool.free_element_ = nullptr;}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;template&lt;class U&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::MemoryPool(const MemoryPool&lt;U&gt;&amp; memoryPool) noexcept : MemoryPool() {}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;&amp; MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::operator=(MemoryPool&amp;&amp; memoryPool) noexcept { std::lock_guard&lt;std::recursive_mutex&gt; lock(m_); if (this != &amp;memoryPool) { std::swap(data_element_, memoryPool.data_element_); std::swap(free_element_, memoryPool.free_element_); } return *this;}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::~MemoryPool() noexcept { std::lock_guard&lt;std::recursive_mutex&gt; lock(m_); element_pointer curr = data_element_; while (curr != nullptr) { element_pointer prev = curr-&gt;next; operator delete(reinterpret_cast&lt;void*&gt;(curr)); curr = prev; } curr = free_element_; while (curr != nullptr) { element_pointer prev = curr-&gt;next; operator delete(reinterpret_cast&lt;void*&gt;(curr)); curr = prev; }}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::pointer MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::address(reference x) const noexcept { return &amp;x;}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::const_pointer MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::address(const_reference x) const noexcept { return &amp;x;}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;void MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::allocateBlock() { // Allocate space for the new block and store a pointer to the previous one data_pointer new_block = reinterpret_cast&lt;data_pointer&gt; (operator new(BlockSize)); element_pointer new_ele_pointer = reinterpret_cast&lt;element_pointer&gt;(new_block); new_ele_pointer-&gt;pre = nullptr; new_ele_pointer-&gt;next = nullptr; if (data_element_) { data_element_-&gt;pre = new_ele_pointer; } new_ele_pointer-&gt;next = data_element_; data_element_ = new_ele_pointer;}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::pointer MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::allocate(size_type n, const_pointer hint) { std::lock_guard&lt;std::recursive_mutex&gt; lock(m_); if (free_element_ != nullptr) { data_pointer body = reinterpret_cast&lt;data_pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(free_element_) + sizeof(element_type)); size_type bodyPadding = padPointer(body, alignof(element_type)); pointer result = reinterpret_cast&lt;pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(body + bodyPadding)); element_pointer tmp = free_element_; free_element_ = free_element_-&gt;next; if (free_element_) free_element_-&gt;pre = nullptr; tmp-&gt;next = data_element_; if (data_element_) data_element_-&gt;pre = tmp; tmp-&gt;pre = nullptr; data_element_ = tmp; return result; } else { allocateBlock(); data_pointer body = reinterpret_cast&lt;data_pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(data_element_) + sizeof(element_type)); size_type bodyPadding = padPointer(body, alignof(element_type)); pointer result = reinterpret_cast&lt;pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(body + bodyPadding)); return result; }}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline void MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::deallocate(pointer p, size_type n) { std::lock_guard&lt;std::recursive_mutex&gt; lock(m_); if (p != nullptr) { element_pointer ele_p = reinterpret_cast&lt;element_pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(p) - sizeof(element_type)); if (ZeroOnDeallocate) { memset(reinterpret_cast&lt;data_pointer&gt;(p), 0, BlockSize - sizeof(element_type)); } if (ele_p-&gt;pre) { ele_p-&gt;pre-&gt;next = ele_p-&gt;next; } if (ele_p-&gt;next) { ele_p-&gt;next-&gt;pre = ele_p-&gt;pre; } if (ele_p-&gt;pre == nullptr) { data_element_ = ele_p-&gt;next; } ele_p-&gt;pre = nullptr; if (free_element_) { ele_p-&gt;next = free_element_; free_element_-&gt;pre = ele_p; } else { ele_p-&gt;next = nullptr; } free_element_ = ele_p; }}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::size_type MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::max_size() const noexcept { size_type maxBlocks = -1 / BlockSize; return (BlockSize - sizeof(data_pointer)) / sizeof(element_type) * maxBlocks;}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;template &lt;class U, class... Args&gt;inline void MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::construct(U* p, Args&amp;&amp;... args) { new (p) U(std::forward&lt;Args&gt;(args)...);}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;template &lt;class U&gt;inline void MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::destroy(U* p) { p-&gt;~U();}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;template &lt;class... Args&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::pointer MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::newElement(Args&amp;&amp;... args) { std::lock_guard&lt;std::recursive_mutex&gt; lock(m_); pointer result = allocate(); construct&lt;value_type&gt;(result, std::forward&lt;Args&gt;(args)...); return result;}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline void MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::deleteElement(pointer p) { std::lock_guard&lt;std::recursive_mutex&gt; lock(m_); if (p != nullptr) { p-&gt;~value_type(); deallocate(p); }}#endif 3.2 使用示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include \"MemoryPool.hpp\"#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;assert.h&gt;using namespace std;class Apple {public: Apple() { id_ = 0; cout &lt;&lt; \"Apple()\" &lt;&lt; endl; } Apple(int id) { id_ = id; cout &lt;&lt; \"Apple(\" &lt;&lt; id_ &lt;&lt; \")\" &lt;&lt; endl; } ~Apple() { cout &lt;&lt; \"~Apple()\" &lt;&lt; endl; } void SetId(int id) { id_ = id; } int GetId() { return id_; }private: int id_;};void ThreadProc(MemoryPool&lt;char&gt; *mp) { int i = 0; while (i++ &lt; 100000) { char* p0 = (char*)mp-&gt;allocate(); char* p1 = (char*)mp-&gt;allocate(); mp-&gt;deallocate(p0); char* p2 = (char*)mp-&gt;allocate(); mp-&gt;deallocate(p1); mp-&gt;deallocate(p2); }}int main(){ MemoryPool&lt;char&gt; mp; int i = 0; while (i++ &lt; 100000) { char* p0 = (char*)mp.allocate(); char* p1 = (char*)mp.allocate(); mp.deallocate(p0); char* p2 = (char*)mp.allocate(); mp.deallocate(p1); mp.deallocate(p2); } std::thread th0(ThreadProc, &amp;mp); std::thread th1(ThreadProc, &amp;mp); std::thread th2(ThreadProc, &amp;mp); th0.join(); th1.join(); th2.join(); Apple* apple = nullptr; MemoryPool&lt;Apple&gt; mp2; apple = mp2.newElement(10); assert(apple); int a = apple-&gt;GetId(); // 10 assert(a == 10); apple-&gt;SetId(12); mp2.deleteElement(apple); return 0;}","link":"/post/581068365.html"},{"title":"C++实现编译时断言","text":"C++自 C++11 起支持 static_assert 编译时断言，如： 12static_assert ( bool_constexpr , message ) (C++11 起)static_assert ( bool_constexpr ) (C++17 起) 若编译器不支持 C++11（经测试 VS2010 已经支持static_assert），可以使用下面方式来实现编译断言： 1#define COMPILE_ASSERT(expression) switch (0) {case 0: case expression:;} 使用方法： 1COMPILE_ASSERT(1 != 1);","link":"/post/4155207961.html"},{"title":"C++字符串和字符字面量","text":"C++支持各种字符串和字符类型，并提供了表达每种类型字面值的方法。在源代码中，我们使用字符集来表示字符或字符串。同时我们还可以使用通用字符名和转义字符来通过基本的源字符集表示任何字符串。而原始字符串能够避免对转义字符进行转义，并可用于表示所有类型的字符串。 1. 字符和字符串字面量1234567891011121314151617181920int main(){ // Character literals auto c0 = 'A'; // char auto c1 = u8'A'; // char auto c2 = L'A'; // wchar_t auto c3 = u'A'; // char16_t auto c4 = U'A'; // char32_t // Multicharacter literals auto m0 = 'abcd'; // int, value 0x61626364 // String literals auto s0 = \"hello\"; // const char* auto s1 = u8\"hello\"; // const char* before C++20, encoded as UTF-8, // const char8_t* in C++20 auto s2 = L\"hello\"; // const wchar_t* auto s3 = u\"hello\"; // const char16_t*, encoded as UTF-16 auto s4 = U\"hello\"; // const char32_t*, encoded as UTF-32} 2. 原始字符串12345678910int main(){ // Raw string literals containing unescaped \\ and \" auto R0 = R\"(\"Hello \\ world\")\"; // const char* auto R1 = u8R\"(\"Hello \\ world\")\"; // const char* before C++20, encoded as UTF-8, // const char8_t* in C++20 auto R2 = LR\"(\"Hello \\ world\")\"; // const wchar_t* auto R3 = uR\"(\"Hello \\ world\")\"; // const char16_t*, encoded as UTF-16 auto R4 = UR\"(\"Hello \\ world\")\"; // const char32_t*, encoded as UTF-32} 3. 字符串后缀字符串后缀就是在字符串后面加s，如： 1234567891011121314auto S0 = \"hello\"s; // std::stringauto S1 = u8\"hello\"s; // std::string before C++20, std::u8string in C++20auto S2 = L\"hello\"s; // std::wstringauto S3 = u\"hello\"s; // std::u16stringauto S4 = U\"hello\"s; // std::u32stringstd::string_view sv = \"abc\\0\\0def\"sv;// 和原始字符串一起使用auto S5 = R\"(\"Hello \\ world\")\"s; // std::string from a raw const char*auto S6 = u8R\"(\"Hello \\ world\")\"s; // std::string from a raw const char* before C++20, encoded as UTF-8, // std::u8string in C++20auto S7 = LR\"(\"Hello \\ world\")\"s; // std::wstring from a raw const wchar_t*auto S8 = uR\"(\"Hello \\ world\")\"s; // std::u16string from a raw const char16_t*, encoded as UTF-16auto S9 = UR\"(\"Hello \\ world\")\"s; // std::u32string from a raw const char32_t*, encoded as UTF-32 和不加后缀的区别如下： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;void print_with_zeros(auto const note, std::string const&amp; s){ std::cout &lt;&lt; note; for (const char c : s) c ? std::cout &lt;&lt; c : std::cout &lt;&lt; \"₀\"; std::cout &lt;&lt; \" (size = \" &lt;&lt; s.size() &lt;&lt; \")\\n\";}int main(){ using namespace std::string_literals; std::string s1 = \"abc\\0\\0def\"; std::string s2 = \"abc\\0\\0def\"s; print_with_zeros(\"s1: \", s1); print_with_zeros(\"s2: \", s2); std::cout &lt;&lt; \"abcdef\"s.substr(1,4) &lt;&lt; '\\n';} 输出： 123s1: abc (size = 3)s2: abc₀₀def (size = 8)bcde 4. 自定义字符串后缀字符串后缀是通过操作符的重载实现的： 1std::string operator\"\"s( const char *str, std::size_t len ); 我们也可以自定义操作符的重载来实现其他的字符串后缀，自定义的后缀建议以下划线开头，否则会产生编译警告： 1warning C4455: “operator \"\"mm”: 已保留不以下划线开头的文本后缀标识符 下面自定义_mm、_m、_km后缀分别表示毫米、米、千米： 1234567891011121314151617181920long double operator\"\" _mm(long double x) { return x / 1000;}long double operator\"\" _m(long double x) { return x;}long double operator\"\" _km(long double x) { return x * 1000;}int main(){ std::cout &lt;&lt; 1.0_mm &lt;&lt; std::endl; // 0.001 std::cout &lt;&lt; 1.0_m &lt;&lt; std::endl; // 1 std::cout &lt;&lt; 1.0_km &lt;&lt; std::endl; // 1000 return 0;}","link":"/post/487899896.html"},{"title":"C++构造函数排雷","text":"一、默认构造函数1.1 什么是默认构造函数？我们一般会认为默认构造函数就是编译器自动生成的那个构造函数，其实这种理解不全面。准确的说，默认构造函数就是在调用时不需要显示地传入实参的构造函数。根据这个原则，下面 2 种构造函数都是默认构造函数： 1234567class Sample {public: // 默认构造函数。 Sample() { // do something }}; 1234567class Sample {public: // 默认构造函数。虽然有形参，但有默认值，调用的时候可以不显示的传入实参。 Sample(int m = 10) { // do something }}; 1.2 默认构造函数调用时机如果定义一个对象时没有使用初始化式，编译器就会使用默认构造函数。如： 1Sample s; 1.3 编译器何时生成默认构造函数有一句很经典的话可以用来回答这个问题：惟有默认构造函数”被编译器需要“的时候，编译器才会生成默认构造函数。 那我们只需知道什么时候“被编译器需要”，就可以知道什么情况下会生成默认构造函数了。下面几种情况下，编译需要生成默认构造函数： 当该类的类对象数据成员有默认构造函数时。 当该类的基类有默认构造函数时。 当该类的基类为虚基类时。 当该类有虚函数时。 1.4 注意事项1. 避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在 无参数的默认构造函数和带缺省参数的默认构造函数同时存在时，编译器会产生二义性，从而生成编译错误。 12345678910111213141516171819202122class Sample {public: // 默认构造函数 Sample() { // do something printf(\"Sample()\"); } // 默认构造函数 Sample(int m = 10) { // do something printf(\"Sample(int m = 10)\"); }};int main(){ Sample s; // error C2668: “Sample::Sample”: 对重载函数的调用不明确 return 0;} 2. 使用无参构造函数创建对象时，不应在对象名后面加上括号 使用无参构造函数创建对象时，不应在对象名后面加上括号，否则会产生编译警告“warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?)”。因为编译器误认为Sample s();语句时要声明返回值为Sample对象的函数s，而又没找到函数s的定义，所以产生了警告。 12345678910111213141516class Sample {public: // 默认构造函数 Sample() { // do something printf(\"Sample()\"); }};int main(){ Sample s(); // warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?) return 0;} 二、构造函数初始化列表2.1 何为构造函数初始化列表1234567891011121314class Sample {public: // 构造函数内部赋值 Sample(int a) { a_ = a; } // 构造函数初始化列表 Sample(int a) : a_(a) { }private: int a_;}; 上面的代码中，Sample类的 2 个构造函数的功能是一样的，都是初始化成员变量a_，区别在于一个采用的是构造函数内部赋值的方式来初始化的，另一个采用的是构造函数初始化列表初始化列表的方式来初始化的。 2.1 何时必须使用初始化列表如果按照上面所说的，既然 2 种初始化成员变量的方式所起得作用是一样的，那么在哪些情况下必须使用构造函数初始化列表的了？下面 2 种情况的成员变量必须使用构造函数初始化列表的方式来初始化： 成员变量是 const 常量。 成员变量是引用类型。 下面例子演示了成员变量是const常量和引用类型时，如何初始化它们： 123456789class Sample {public: Sample() : kCount(11), name_(std::string(\"jeff\")) { }private: std::string &amp;name_; const int kCount;}; 2.3 初始化列表的顺序问题使用构造函数初始化列表进行成员变量初始化时，要注意成员变量的初始化顺序。举个例子来说明，现有类SeqSample有 3 个成员变量a_, b_, c_，构造函数被设计为将a_, b_, c_都初始化为m，也就是a_ == b_ == c_ == m： 123456789101112131415161718192021class SeqSample {public: SeqSample(int m) : a_(m), b_(a_), c_(b_) { }private: int b_; int a_; int c_;};int main(){ SeqSample ss(1); return 0;} 通过调试器观察到执行构造函数初始化之后，成员变量a_, b_, c_的值分别为： 123b_ = -858993460a_ = 1c_ = -858993460 而不是我们期望的a_ = 1 b_ = 1 c_ = 1。 出现这种问题的原因在于：编译器对构造函数初始化列表中的变量进行初始化的时候，不是按照变量初始化列表中的顺序来进行初始化的，而是按照变量在类中的声明顺序来初始化的。 所以，在初始化列表中的变量有依赖关系时（如上面的b_依赖于a_的初始化结果），要特别注意这种情况。 2.4 初始化列表的另一个好处先模糊的把这个好处说出来，不太明白的，可以看下面的示例：若成员变量是类对象，则使用构造函数的初始化列表可以减少一次默认构造函数的调用。 测试代码如下（声明了一个Apple类，一个Test类，Test 类中有 2 个 Apple 对象apple1_, apple2_，唯一不同的是，apple1_通过初始化列表来初始化，apple2_通过函数体中的赋值语句来初始化）： 12345678910111213141516171819202122232425262728293031323334class Apple {public: Apple() { printf(\"默认构造函数\\n\"); } Apple(const Apple &amp;that) { printf(\"复制构造函数\\n\"); } Apple&amp; operator = (const Apple&amp;that) { printf(\"赋值运算符重载\\n\"); return *this; }};class Test {public: Test(const Apple &amp;apple) : apple1_(apple) { apple2_ = apple; }private: Apple apple1_; Apple apple2_;};int main(){ Apple apple; Test t(apple); return 0;} 运行结果： 1234默认构造函数复制构造函数默认构造函数赋值运算符重载 4 行输出分别由不同的语句产生，如图： apple1_(apple)直接执行的复制构造函数，所以只产生一行输出；而apple2_ = apple;却是先使用默认构造函数构造了一个 apple2对象，然后再通过赋值运算符将 apple 的内容更新到 apple2中，所以产生了 2 行输出。 2.5 构造函数初始化列表的异常捕获构造的函数的初始化列表也可以使用异常捕获，具体使用方式如下： 12345678910111213class Foo {public: Foo::Foo(int n) try :size(n), array(new int[n]) { //... } catch (const std::bad_alloc&amp; e) { printf(\"%s\\n\", e.what()); }private: int size; int *array;};","link":"/post/3768553066.html"},{"title":"C++标准库线程的启动与退出","text":"本文简要介绍C++标准库提供的几种线程操作方法，主要介绍如何判断线程是否已经结束运行。 一、std::threadstd::thread 未提供判断线程是否结束的方法。 如果线程未进行 detach 且此时该线程处理 joinable 状态，析构该线程对象会触发异常。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;thread&gt;std::thread Thread1() { std::thread t = std::thread([]() { std::this_thread::sleep_for(std::chrono::milliseconds(1000)); }); return t;}int main(){ std::thread t1 = Thread1(); t1.join(); //等待线程结束 std::thread t2 = std::thread([]() { std::this_thread::sleep_for(std::chrono::milliseconds(1000)); }); std::cout &lt;&lt; \"thread id:\" &lt;&lt; t2.get_id() &lt;&lt; std::endl; std::cout &lt;&lt; \"joinable:\" &lt;&lt; t2.joinable() &lt;&lt; std::endl; // 1 t2.detach(); std::cout &lt;&lt; \"joinable:\" &lt;&lt; t2.joinable() &lt;&lt; std::endl; // 0 std::this_thread::sleep_for(std::chrono::milliseconds(2000)); return 0;} 二、std::async通过std::async可以判断线程是否结束运行。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;future&gt;int main(){ std::future&lt;void&gt; f = std::async(std::launch::async, []() { std::this_thread::sleep_for(std::chrono::milliseconds(1000)); }); bool isRunning = f.valid() &amp;&amp; f.wait_for(std::chrono::milliseconds(0)) == std::future_status::timeout; std::cout &lt;&lt; isRunning &lt;&lt; std::endl; f.wait(); isRunning = f.valid() &amp;&amp; f.wait_for(std::chrono::milliseconds(0)) == std::future_status::timeout; std::cout &lt;&lt; isRunning &lt;&lt; std::endl; return 0;} 2.1 判断 std::future 是否结束12bool isRunning = f.valid() &amp;&amp; f.wait_for(std::chrono::milliseconds(0)) == std::future_status::timeout; 2.2 std::shared_futurestd::future不支持赋值构造，需要使用std::shared_future。 12345std::shared_future&lt;void&gt; f1 = std::async(std::launch::async, []() { std::this_thread::sleep_for(std::chrono::milliseconds(1000)); });std::shared_future&lt;void&gt; f2 = f1;","link":"/post/2289160283.html"},{"title":"C++默认构造函数","text":"本文围绕 3 个问题来理解 C++的默认构造函数： 什么是默认构造函数？ 默认构造函数什么时候被调用？ 编译器在什么情况下会生成默认构造函数？ 一. 什么是默认构造函数？我们一般会认为默认构造函数就是编译器自动生成的那个构造函数，其实这种理解不全面。准确的说，默认构造函数就是在调用时不需要显示地传入实参的构造函数。 根据这个原则，下面 2 种构造函数都是默认构造函数： 1234567class Sample {public: // 默认构造函数。 Sample() { // do something }}; 1234567class Sample {public: // 默认构造函数。虽然有形参，但有默认值，调用的时候可以不显示的传入实参。 Sample(int m = 10) { // do something }}; 二. 默认构造函数什么时候被调用？如果定义一个对象时没有使用初始化式，编译器就会使用默认构造函数。如： 1Sample s; 三. 编译器在什么情况下会生成默认构造函数？有一句很经典的话可以用来回答这个问题：惟有默认构造函数被编译器需要的时候，编译器才会生成默认构造函数。 那我们只需知道什么时候“被编译器需要”，就可以知道什么情况下会生成默认构造函数了。 下面几种情况下，编译需要生成默认构造函数： 当该类的类对象数据成员有默认构造函数时。 当该类的基类有默认构造函数时。 当该类的基类为虚基类时。 当该类有虚函数时。 四. 注意事项4.1 避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在无参数的默认构造函数和带缺省参数的默认构造函数同时存在时，编译器会产生二义性，从而生成编译错误。 12345678910111213141516171819202122class Sample {public: // 默认构造函数 Sample() { // do something printf(\"Sample()\"); } // 默认构造函数 Sample(int m = 10) { // do something printf(\"Sample(int m = 10)\"); }};int main(){ Sample s; // error C2668: “Sample::Sample”: 对重载函数的调用不明确 return 0;} 4.2 不应在对象名后面加上括号使用无参构造函数创建对象时，不应在对象名后面加上括号，否则会产生编译警告 1warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?) 因为编译器误认为Sample s();语句时要声明返回值为Sample对象的函数s，而又没找到函数s的定义，所以产生了警告。 12345678910111213141516class Sample {public: // 默认构造函数 Sample() { // do something printf(\"Sample()\"); }};int main(){ Sample s(); // warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?) return 0;}","link":"/post/818165951.html"},{"title":"LLVM-Obfuscator代码混淆","text":"LLVM-Obfuscator 可用于混淆程序的代码逻辑，本文介绍如何使用 LLVM-Obfuscator 进行代码逻辑的混淆。 1. 安装 VS Clang 组件 2. 编译 LLVM-Obfuscator使用 heroims 的 Fork 版本：heroims/obfuscator 2.1 Clone 最新 13.x 分支1git clone -b llvm-13.x https://github.com/obfuscator-llvm/obfuscator.git 2.2 安装 mingw从https://github.com/niXman/mingw-builds-binaries/releases 下载 32 位和 64 位 MingW: i686-12.2.0-release-posix-dwarf-msvcrt-rt_v10-rev2.7z x86_64-12.2.0-release-posix-seh-msvcrt-rt_v10-rev2.7z 分别解压到不同的目录。 2.3 编译 64 位 LLVM-Obfuscator打开 CMD，将 64 位 MingW 的 bin 目录添加到 PATH 环境变量： 1SET PATH=%PATH%;C:\\mingw64\\x86_64-12.2.0-release-posix-seh-msvcrt-rt_v10-rev2\\bin 在命令行进入 LLVM-Obfuscator 所在目录，开始编译： 123456mkdir build64cd build64cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=\"clang\" -DLLVM_CREATE_XCODE_TOOLCHAIN=ON -DLLVM_ENABLE_NEW_PASS_MANAGER=OFF -G \"MinGW Makefiles\" ../llvmmingw32-make.exe -j8 2.4 编译 32 位 LLVM-Obfuscator重新打开 CMD，将 32 位 MingW 的 bin 目录添加到 PATH 环境变量： 1SET PATH=%PATH%;C:\\mingw32\\i686-12.2.0-release-posix-dwarf-msvcrt-rt_v10-rev2\\bin 在命令行进入 LLVM-Obfuscator 所在目录，开始编译： 1234mkdir build32cd build32cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=\"clang\" -DLLVM_CREATE_XCODE_TOOLCHAIN=ON -DLLVM_ENABLE_NEW_PASS_MANAGER=OFF -G \"MinGW Makefiles\" ../llvmmingw32-make.exe -j8 3. 用编译输出覆盖到 VS ClangVisual Studio 的 Clang 位于C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\Llvm目录，分别将编译的 32 位和 64 位bin目录中的文件覆盖到 VS Clang 的bin目录中（注意：在覆盖之前，最好先备份）。 4. 设置环境变量在编译完之后，将 32 位和 64 位 MingW 的bin目录路径都添加到 PATH 环境变量中。因为 VS 编译时会启动 clang.exe，而 clang.exe 需要依赖 MingW。 5. VS 工程配置 命令行其他选项如下： 1-D__CUDACC__ -D_ALLOW_COMPILER_AND_STL_VERSION_MISMATCH -mllvm -bcf -mllvm -bcf_prob=73 -mllvm -bcf_loop=1 -mllvm -sub -mllvm -sub_loop=5 -mllvm -fla -mllvm -split_num=5 -mllvm -aesSeed=DEADBEEFDEADCODEDEADBEEFDEADCODE 6. 混淆配置参数开启控制流扁平化-mllvm -fla 开启控制流扁平化 -mllvm -split 激活基本块划分。一起使用时能提高打平能力。 -mllvm -split_num=3 如果激活控制流打平，对每一个基本块应用三次控制流打平。默认使用 1 次。 开启指令替换-mllvm -sub 开启指令替换 -mllvm -sub_loop=3 如果激活了指令替换，使用这个选项在一个函数中应用 3 次指令替换。默认应用 1 次。 开启虚假控制流-mllvm -bcf 开启虚假控制流。 bcf可以配合下面参数使用： -mllvm -bcf_loop=3 设置函数混淆次数为 3 次 不加此选项默认为 1 次。 -mllvm -bcf_prob=40 设置代码块被混淆的概率是 40%，默认 30% 7. CMakeList 中配置混淆参数12345678910111213141516#debug and release all enableSET(CMAKE_CXX_FLAGS \"-mllvm -fla -mllvm -sub -mllvm -sobf \")#so体积优化，（按需开启）#SET(CMAKE_CXX_FLAGS_DEBUG \"$ENV{CXXFLAGS} -O0 -Wall -g2 -ggdb\")#SET(CMAKE_CXX_FLAGS_RELEASE \"$ENV{CXXFLAGS} -Os -Wall -s\")#设置llvm debug模式混淆编译SET(CMAKE_C_FLAGS_DEBUG \"${CMAKE_C_FLAGS_DEBUG} -mllvm -fla\")SET(CMAKE_CXX_FLAGS_DEBUG \"${CMAKE_CXX_FLAGS_DEBUG} -mllvm -fla\")#设置llvm release模式混淆编译SET(CMAKE_C_FLAGS_RELEASE \"${CMAKE_C_FLAGS_RELEASE} -mllvm -fla -mllvm -sub -mllvm -bcf\")SET(CMAKE_CXX_FLAGS_RELEASE \"${CMAKE_CXX_FLAGS_RELEASE} -mllvm -fla -mllvm -sub -mllvm -bcf\")SET(CMAKE_CXX_FLAGS_RELEASE \"${CMAKE_CXX_FLAGS_RELEASE} -s -O3 -Wall -fvisibility=hidden -mllvm -fla\")","link":"/post/2256274631.html"},{"title":"C++生成条形码","text":"条形码(barcode)是将宽度不等的多个黑条和空白，按照一定的编码规则排列，用以表达一组信息的图形标识符。常见的条形码是由反射率相差很大的黑条（简称条）和白条（简称空）排成的平行线图案。 一、条形码介绍条码种类很多，常见的大概有二十多种码制，其中包括：Code39 码（标准 39 码）、Codabar 码（库德巴码）、Code25 码（标准 25 码）、ITF25 码（交叉 25 码）、Matrix25 码（矩阵 25 码）、UPC-A 码、UPC-E 码、EAN-13 码（EAN-13 国际商品条码）、EAN-8 码（EAN-8 国际商品条码）、中国邮政码（矩阵 25 码的一种变体）、Code-B 码、MSI 码、Code11 码、Code93 码、ISBN 码、ISSN 码、Code128 码（Code128 码，包括 EAN128 码）、Code39EMS（EMS 专用的 39 码）等一维条码和 PDF417 等二维条码。 目前，国际广泛使用的条码种类有： EAN 码 —— 国际物品编码协会制定的一种商品用条码，通用于全世界。EAN 码符号有标准版（EAN-13）和缩短版（EAN-8）两种，我国的通用商品条码与其等效，日常购买的商品包装上所印的条码一般就是 EAN 码。 UPC 码 —— UPC 码是美国统一代码委员会制定的一种商品用条码，主要用于美国和加拿大地区，我们在美国进口的商品上可以看到。 Code39 码 —— 因其可采用数字与字母共同组成的方式而在各行业内部管理上被广泛使用。 Code93 码 —— Code 93 码与 39 码具有相同的字符集，但它的密度要比 39 码高，所以在面积不足的情况下，可以用 93 码代替 39 码 Codebar 码 —— 可表示数字 0 - 9，字符$、+、 -、还有只能用作起始/终止符的 a,b,c d 四个字符，可变长度，没有校验位，多用于血库,图书馆和照像馆的业务中。 Code128 码 —— 128 可表示 ASCII 0 到 ASCII 127 共计 128 个 ASCII 字符。 CodeI2of5 码 —— 只能表示数字 0 -9 可变长度，连续性条形码，所有条与空都表示代码，第一个数字由条开始，第二个数字由空组成，空白区比窄条宽 10 倍，应用于商品批发、仓库、机场、生产/包装识别、工业中，条形码的识读率高，可适用于固定扫描器可靠扫描，在所有一维条形码中的密度最高。 二、C++方式实现barcode.h 中实现了 Code39、Code93、Code128、CodeI2of5 等 4 种格式的条形码的生成。具体使用方法：调用对应类的DrawBarcode函数将条形码绘制到 HDC 上，绘制到 HDC 上之后可以保存为图片或者显示到界面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242#ifndef BARCODE_H_#define BARCODE_H_#pragma onceclass Barcode39;class Barcode93;class BarcodeIof5;class Barcode128;static const int ga2_Code128[2][207] ={ { 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, }, { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, },};class BarcodeBase {public: BarcodeBase() { Clear(); i_Ratio = 3; } void operator=(const BarcodeBase&amp;bc) { i_LenBuf = bc.i_LenBuf; i_Ratio = bc.i_Ratio; memcpy(ia_Buf, bc.ia_Buf, sizeof(ia_Buf)); } void Clear() { memset(ia_Buf, 0, sizeof(ia_Buf)); i_LenBuf = 0; } int GetEncodeLength() const { BYTE*pb = (BYTE*)ia_Buf; int i, iLen = 0; for (i = 0; i &lt; i_LenBuf; i++) { //wide is 3 if (*pb &amp; 2) iLen += (i_Ratio - 1); pb++; } return iLen + i_LenBuf; } int GetBufferLength() const { return i_LenBuf; } const BYTE&amp;GetAt(int i) const { return ia_Buf[i]; } int GetRatio() const { return i_Ratio; } int SetRatio(int iRatio) { i_Ratio = iRatio; if (i_Ratio &lt;= 0) i_Ratio = 1; } void DrawBarcode(HDC hDC, int iX, int iY0, int iY10, int iY11, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) { HPEN hPenBar = ::CreatePen(PS_SOLID, iPenW, clrBar); HPEN hPenSpace = ::CreatePen(PS_SOLID, iPenW, clrSpace); HPEN hPenOld = (HPEN)::SelectObject(hDC, hPenBar); BYTE*pb = ia_Buf; int i0, iNum0 = i_LenBuf; BYTE bBar; int i1, iNum1; int iY; for (i0 = 0; i0 &lt; iNum0; i0++) { bBar = *pb &amp; 0x01; iNum1 = (*pb &amp; 0x02) ? i_Ratio : 1; iY = (*pb &amp; 0x04) ? iY11 : iY10; for (i1 = 0; i1 &lt; iNum1; i1++) { if (bBar) ::SelectObject(hDC, hPenBar); else ::SelectObject(hDC, hPenSpace); ::MoveToEx(hDC, iX, iY0, 0); ::LineTo(hDC, iX, iY); iX += iPenW; } pb++; } ::SelectObject(hDC, hPenOld); ::DeleteObject(hPenBar); ::DeleteObject(hPenSpace); }protected: BYTE ia_Buf[4096]; int i_LenBuf; int i_Ratio; struct IntString { int ch; char*psz; };};class Barcode39 : public BarcodeBase { //[n/a][n/a][n/a][n/a][n/a][n/a][w-n][b-s]public: Barcode39() { } ~Barcode39() { } BOOL Encode39(const char*pszCodeIn) { int iLen = strlen(pszCodeIn); char*pszCode = new char[iLen + 3]; sprintf(pszCode, \"*%s*\", pszCodeIn); strupr(pszCode); BYTE*pFst = ia_Buf; BYTE*p0 = pFst, *p1; iLen += 2; int i; for (i = 0; i &lt; iLen; i++) { p1 = P_GetNarrowWideBarSpace39(pszCode[i], p0); if (p1 == 0) return 0; p0 = p1; } i_LenBuf = p1 - pFst; delete[]pszCode; return 1; } void Draw39(HDC hDC, int iX, int iY0, int iY1, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) { DrawBarcode(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW); }private: BYTE*P_GetNarrowWideBarSpace39(char ch, BYTE*pb) { IntString infs[] = { {'1', \"wnnwnnnnwn\"}, {'2', \"nnwwnnnnwn\"}, {'3', \"wnwwnnnnnn\"}, {'4', \"nnnwwnnnwn\"}, {'5', \"wnnwwnnnnn\"}, {'6', \"nnwwwnnnnn\"}, {'7', \"nnnwnnwnwn\"}, {'8', \"wnnwnnwnnn\"}, {'9', \"nnwwnnwnnn\"}, {'0', \"nnnwwnwnnn\"}, {'A', \"wnnnnwnnwn\"}, {'B', \"nnwnnwnnwn\"}, {'C', \"wnwnnwnnnn\"}, {'D', \"nnnnwwnnwn\"}, {'E', \"wnnnwwnnnn\"}, {'F', \"nnwnwwnnnn\"}, {'G', \"nnnnnwwnwn\"}, {'H', \"wnnnnwwnnn\"}, {'I', \"nnwnnwwnnn\"}, {'J', \"nnnnwwwnnn\"}, {'K', \"wnnnnnnwwn\"}, {'L', \"nnwnnnnwwn\"}, {'M', \"wnwnnnnwnn\"}, {'N', \"nnnnwnnwwn\"}, {'O', \"wnnnwnnwnn\"}, {'P', \"nnwnwnnwnn\"}, {'Q', \"nnnnnnwwwn\"}, {'R', \"wnnnnnwwnn\"}, {'S', \"nnwnnnwwnn\"}, {'T', \"nnnnwnwwnn\"}, {'U', \"wwnnnnnnwn\"}, {'V', \"nwwnnnnnwn\"}, {'W', \"wwwnnnnnnn\"}, {'X', \"nwnnwnnnwn\"}, {'Y', \"wwnnwnnnnn\"}, {'Z', \"nwwnwnnnnn\"}, {'-', \"nwnnnnwnwn\"}, {'.', \"wwnnnnwnnn\"}, {' ', \"nwwnnnwnnn\"}, {'*', \"nwnnwnwnnn\"}, {'$', \"nwnwnwnnnn\"}, {'/', \"nwnwnnnwnn\"}, {'+', \"nwnnnwnwnn\"}, {'%', \"nnnwnwnwnn\"}, }; int i0, iNum0 = sizeof(infs) / sizeof(infs[0]); int i1; for (i0 = 0; i0 &lt; iNum0; i0++) { IntString&amp;inf = infs[i0]; if (inf.ch == ch) { for (i1 = 0; i1 &lt; 10; i1++) { if (inf.psz[i1] == 'w') *pb += 2; if (i1 % 2 == 0) *pb += 1; pb++; } return pb; } } return 0; }};class BarcodeI2of5 :public BarcodeBase { //[n/a][n/a][n/a][n/a][n/a][n/a][w-n][b-s]public: BarcodeI2of5() { } ~BarcodeI2of5() { } BOOL EncodeI2of5(const char*pszCode) { Clear(); BYTE*pFst = ia_Buf; BYTE*pb = pFst; const int iNum = strlen(pszCode); int i; //\"nnnn\" for (i = 0; i &lt; 4; i++) { if (i % 2 == 0) *pb += 1; pb++; } int iV; for (i = 0; i &lt; iNum; i += 2) { iV = pszCode[i] - '0'; iV = iV * 10; iV += pszCode[i + 1] - '0'; pb = P_GetNarrorWideBarSpaceI2of5(pb, iV); if (pb == 0) return 0; } //\"wnn\" *pb += 3; pb++; *pb += 0; pb++; *pb += 1; pb++; i_LenBuf = pb - pFst; return 1; } void DrawI2of5(HDC hDC, int iX, int iY0, int iY1, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) { DrawBarcode(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW); }private: BYTE*P_GetNarrorWideBarSpaceI2of5(BYTE*pb, int ch) { if (ch &lt; 0) return 0; if (ch &gt; 99) return 0; IntString infs[] = { {0, \"nnnnwwwwnn\"}, {1, \"nwnnwnwnnw\"}, {2, \"nnnwwnwnnw\"}, {3, \"nwnwwnwnnn\"}, {4, \"nnnnwwwnnw\"}, {5, \"nwnnwwwnnn\"}, {6, \"nnnwwwwnnn\"}, {7, \"nnnnwnwwnw\"}, {8, \"nwnnwnwwnn\"}, {9, \"nnnwwnwwnn\"}, {10, \"wnnnnwnwwn\"}, {11, \"wwnnnnnnww\"}, {12, \"wnnwnnnnww\"}, {13, \"wwnwnnnnwn\"}, {14, \"wnnnnwnnww\"}, {15, \"wwnnnwnnwn\"}, {16, \"wnnwnwnnwn\"}, {17, \"wnnnnnnwww\"}, {18, \"wwnnnnnwwn\"}, {19, \"wnnwnnnwwn\"}, {20, \"nnwnnwnwwn\"}, {21, \"nwwnnnnnww\"}, {22, \"nnwwnnnnww\"}, {23, \"nwwwnnnnwn\"}, {24, \"nnwnnwnnww\"}, {25, \"nwwnnwnnwn\"}, {26, \"nnwwnwnnwn\"}, {27, \"nnwnnnnwww\"}, {28, \"nwwnnnnwwn\"}, {29, \"nnwwnnnwwn\"}, {30, \"wnwnnwnwnn\"}, {31, \"wwwnnnnnnw\"}, {32, \"wnwwnnnnnw\"}, {33, \"wwwwnnnnnn\"}, {34, \"wnwnnwnnnw\"}, {35, \"wwwnnwnnnn\"}, {36, \"wnwwnwnnnn\"}, {37, \"wnwnnnnwnw\"}, {38, \"wwwnnnnwnn\"}, {39, \"wnwwnnnwnn\"}, {40, \"nnnnwwnwwn\"}, {41, \"nwnnwnnnww\"}, {42, \"nnnwwnnnww\"}, {43, \"nwnwwnnnwn\"}, {44, \"nnnnwwnnww\"}, {45, \"nwnnwwnnwn\"}, {46, \"nnnwwwnnwn\"}, {47, \"nnnnwnnwww\"}, {48, \"nwnnwnnwwn\"}, {49, \"nnnwwnnwwn\"}, {50, \"wnnnwwnwnn\"}, {51, \"wwnnwnnnnw\"}, {52, \"wnnwwnnnnw\"}, {53, \"wwnwwnnnnn\"}, {54, \"wnnnwwnnnw\"}, {55, \"wwnnwwnnnn\"}, {56, \"wnnwwwnnnn\"}, {57, \"wnnnwnnwnw\"}, {58, \"wwnnwnnwnn\"}, {59, \"wnnwwnnwnn\"}, {60, \"nnwnwwnwnn\"}, {61, \"nwwnwnnnnw\"}, {62, \"nnwwwnnnnw\"}, {63, \"nwwwwnnnnn\"}, {64, \"nnwnwwnnnw\"}, {65, \"nwwnwwnnnn\"}, {66, \"nnwwwwnnnn\"}, {67, \"nnwnwnnwnw\"}, {68, \"nwwnwnnwnn\"}, {69, \"nnwwwnnwnn\"}, {70, \"nnnnnwwwwn\"}, {71, \"nwnnnnwnww\"}, {72, \"nnnwnnwnww\"}, {73, \"nwnwnnwnwn\"}, {74, \"nnnnnwwnww\"}, {75, \"nwnnnwwnwn\"}, {76, \"nnnwnwwnwn\"}, {77, \"nnnnnnwwww\"}, {78, \"nwnnnnwwwn\"}, {79, \"nnnwnnwwwn\"}, {80, \"wnnnnwwwnn\"}, {81, \"wwnnnnwnnw\"}, {82, \"wnnwnnwnnw\"}, {83, \"wwnwnnwnnn\"}, {84, \"wnnnnwwnnw\"}, {85, \"wwnnnwwnnn\"}, {86, \"wnnwnwwnnn\"}, {87, \"wnnnnnwwnw\"}, {88, \"wwnnnnwwnn\"}, {89, \"wnnwnnwwnn\"}, {90, \"nnwnnwwwnn\"}, {91, \"nwwnnnwnnw\"}, {92, \"nnwwnnwnnw\"}, {93, \"nwwwnnwnnn\"}, {94, \"nnwnnwwnnw\"}, {95, \"nwwnnwwnnn\"}, {96, \"nnwwnwwnnn\"}, {97, \"nnwnnnwwnw\"}, {98, \"nwwnnnwwnn\"}, {99, \"nnwwnnwwnn\"}, }; IntString&amp;inf = infs[ch]; int i; for (i = 0; i &lt; 10; i++) { if (inf.psz[i] == 'w') *pb += 2; if (i % 2 == 0) *pb += 1; pb++; } return pb; }};class Barcode93 :public BarcodeBase { //[n/a][n/a][n/a][n/a][n/a][n/a][n/a][b-s]public: Barcode93() { } ~Barcode93() { } BOOL Encode93(const char* pszCode) { Clear(); const int iNum = strlen(pszCode); BYTE*pFst = ia_Buf; BYTE*pb = pFst; pb = P_GetBarSpace93(pb, 47); if (pb == 0) return 0; BOOL b; int i, iFirst, iSecond; for (i = 0; i &lt; iNum; i++) { b = P_AscIItoCode93Sequence((int)pszCode[i], iFirst, iSecond); if (b == 0) return 0; pb = P_GetBarSpace93(pb, iFirst); if (pb == 0) return 0; if (iSecond != -1) { pb = P_GetBarSpace93(pb, iSecond); if (pb == 0) return 0; } } pb = P_GetCheckDigits(pb, pszCode); if (pb == 0) return 0; pb = P_GetBarSpace93(pb, 48); if (pb == 0) return 0; i_LenBuf = pb - pFst; return 1; } void Draw93(HDC hDC, int iX, int iY0, int iY1, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) { DrawBarcode(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW); }private: BYTE*P_GetBarSpace93(BYTE*pb, int ch) { if (ch &lt; 0) return 0; if (ch &gt; 48) return 0; IntString infs[] = { {0, \"bsssbsbss\"}, {1, \"bsbssbsss\"}, {2, \"bsbsssbss\"}, {3, \"bsbssssbs\"}, {4, \"bssbsbsss\"}, {5, \"bssbssbss\"}, {6, \"bssbsssbs\"}, {7, \"bsbsbssss\"}, {8, \"bsssbssbs\"}, {9, \"bssssbsbs\"}, {10, \"bbsbsbsss\"}, {11, \"bbsbssbss\"}, {12, \"bbsbsssbs\"}, {13, \"bbssbsbss\"}, {14, \"bbssbssbs\"}, {15, \"bbsssbsbs\"}, {16, \"bsbbsbsss\"}, {17, \"bsbbssbss\"}, {18, \"bsbbsssbs\"}, {19, \"bssbbsbss\"}, {20, \"bsssbbsbs\"}, {21, \"bsbsbbsss\"}, {22, \"bsbssbbss\"}, {23, \"bsbsssbbs\"}, {24, \"bssbsbbss\"}, {25, \"bsssbsbbs\"}, {26, \"bbsbbsbss\"}, {27, \"bbsbbssbs\"}, {28, \"bbsbsbbss\"}, {29, \"bbsbssbbs\"}, {30, \"bbssbsbbs\"}, {31, \"bbssbbsbs\"}, {32, \"bsbbsbbss\"}, {33, \"bsbbssbbs\"}, {34, \"bssbbsbbs\"}, {35, \"bssbbbsbs\"}, {36, \"bssbsbbbs\"}, {37, \"bbbsbsbss\"}, {38, \"bbbsbssbs\"}, {39, \"bbbssbsbs\"}, {40, \"bsbbsbbbs\"}, {41, \"bsbbbsbbs\"}, {42, \"bbsbsbbbs\"}, {43, \"bssbssbbs\"}, {44, \"bbbsbbsbs\"}, {45, \"bbbsbsbbs\"}, {46, \"bssbbssbs\"}, {47, \"bsbsbbbbs\"}, {48, \"bsbsbbbbsb\"}, }; IntString&amp;inf = infs[ch]; int i; for (i = 0; i &lt; 9; i++) { if (inf.psz[i] == 'b') *pb += 1; pb++; } if (ch == 48) { *pb += 1; pb++; } return pb; }private: BYTE*P_GetCheckDigits(BYTE*pb, const char*&amp;pszCode) { int i, iSum, iWeight, iFirst, iSecond; // \"C\" check digit character iWeight = 1; iSum = 0; const int iNum = strlen(pszCode); for (i = iNum - 1; i &gt; -1; i--) { P_AscIItoCode93Sequence((int)pszCode[i], iFirst, iSecond); iSum += (iWeight*iFirst); iWeight++; if (iWeight &gt; 20) iWeight = 1; if (iSecond != -1) { iSum += (iWeight*iSecond); iWeight++; if (iWeight &gt; 20) iWeight = 1; } } pb = P_GetBarSpace93(pb, iSum % 47); if (pb == 0) return 0; iWeight = 2; iSum = iSum % 47; for (i = iNum - 1; i &gt; -1; i--) { P_AscIItoCode93Sequence((int)pszCode[i], iFirst, iSecond); iSum += (iWeight * iFirst); iWeight++; if (iWeight &gt; 15) iWeight = 1; if (iSecond != -1) { iSum += (iWeight * iSecond); iWeight++; if (iWeight &gt; 15) iWeight = 1; } } pb = P_GetBarSpace93(pb, iSum % 47); if (pb == 0) return 0; return pb; } BOOL P_AscIItoCode93Sequence(int iValue, int&amp;iFirst, int&amp;iSecond) { if (iValue &lt; 0) return 0; if (iValue &gt; 127) return 0; struct I3 { int iV, iFirst, iSecond; }; I3 i3s[] = { {0, 44, 30}, {1, 43, 10}, {2, 43, 11}, {3, 43, 12}, {4, 43, 13}, {5, 43, 14}, {6, 43, 15}, {7, 43, 16}, {8, 43, 17}, {9, 43, 18}, {10,43, 19}, {11,43, 20}, {12,43, 21}, {13,43, 22}, {14,43, 23}, {15,43, 24}, {16,43, 25}, {17,43, 26}, {18,43, 27}, {19,43, 28}, {20,43, 29}, {21,43, 30}, {22,43, 31}, {23,43, 32}, {24,43, 33}, {25,43, 34}, {26,43, 35}, {27,44, 10}, {28,44, 11}, {29,44, 12}, {30,44, 13}, {31,44, 14}, {32,38, -1}, {33,45, 10}, {34,45, 11}, {35,45, 12}, {36,39, -1}, {37,42, -1}, {38,45, 15}, {39,45, 16}, {40,45, 17}, {41,45, 18}, {42,45, 19}, {43,41, -1}, {44,45, 21}, {45,36, -1}, {46,37, -1}, {47,40, -1}, {48,0, -1}, {49,1, -1}, {50,2, -1}, {51,3, -1}, {52,4, -1}, {53,5, -1}, {54,6, -1}, {55,7, -1}, {56,8, -1}, {57,9, -1}, {58,45, 35}, {59,44, 15}, {60,44, 16}, {61,44, 17}, {62,44, 18}, {63,44, 19}, {64,44, 31}, {65,10, -1}, {66,11, -1}, {67,12, -1}, {68,13, -1}, {69,14, -1}, {70,15, -1}, {71,16, -1}, {72,17, -1}, {73,18, -1}, {74,19, -1}, {75,20, -1}, {76,21, -1}, {77,22, -1}, {78,23, -1}, {79,24, -1}, {80,25, -1}, {81,26, -1}, {82,27, -1}, {83,28, -1}, {84,29, -1}, {85,30, -1}, {86,31, -1}, {87,32, -1}, {88,33, -1}, {89,34, -1}, {90,35, -1}, {91,44, 20}, {92,44, 21}, {93,44, 22}, {94,44, 23}, {95,44, 24}, {96,44, 32}, {97,46, 10}, {98,46, 11}, {99,46, 12}, {100,46,13}, {101,46,14}, {102,46,15}, {103,46,16}, {104,46,17}, {105,46,18}, {106,46,19}, {107,46,20}, {108,46,21}, {109,46,22}, {110,46,23}, {111,46,24}, {112,46,25}, {113,46,26}, {114,46,27}, {115,46,28}, {116,46,29}, {117,46,30}, {118,46,31}, {119,46,32}, {120,46,33}, {121,46,34}, {122,46,35}, {123,44,25}, {124,44,26}, {125,44,27}, {126,44,28}, {127,44,29}, }; I3&amp;i3 = i3s[iValue]; iFirst = i3.iFirst; iSecond = i3.iSecond; return 1; }};class Barcode128 :public BarcodeBase {public: Barcode128() { } ~Barcode128() { } BOOL Encode128A(const char* pszCode) { return P_Encode128((char*)pszCode, SUB::SETA); } BOOL Encode128B(const char* pszCode) { return P_Encode128((char*)pszCode, SUB::SETB); } BOOL Encode128C(const char* pszCode) { return P_Encode128((char*)pszCode, SUB::SETC); } void Draw128(HDC hDC, int iX, int iY0, int iY1, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) { DrawBarcode(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW); }private: struct SUB { enum { SETA = 0, SETB = 1, SETC = 2, }; }; BOOL P_Encode128(char*pszCode, const int iSetIn) { Clear(); BYTE*pFst = ia_Buf; BYTE*pb = pFst; if (iSetIn == SUB::SETA) pb = P_GetBarSpace128(pb, 103); else if (iSetIn == SUB::SETB) pb = P_GetBarSpace128(pb, 104); else pb = P_GetBarSpace128(pb, 105); if (pb == 0) return 0; const int iCheckDigit = GetCheckDigit(iSetIn, pszCode); const int iNum = strlen(pszCode); int iChar, iCharNext; int iPosition = 0; int iSet = iSetIn; while (iPosition &lt; iNum) { if (iSet == SUB::SETC) { if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 101) { pb = P_GetBarSpace128(pb, 101); iPosition++; iSet = SUB::SETA; } else if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 100) { pb = P_GetBarSpace128(pb, 100); iPosition++; iSet = SUB::SETB; } else if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 102) { pb = P_GetBarSpace128(pb, 100); iPosition++; } else { char chT = pszCode[iPosition + 2]; pszCode[iPosition + 2] = 0; iChar = atoi(&amp;pszCode[iPosition]); pszCode[iPosition + 2] = chT; pb = P_GetBarSpace128(pb, iChar); if (pb == 0) return 0; iPosition += 2; } } else { int iTemp2 = pszCode[iPosition]; if (iTemp2 &lt; -1) iTemp2 = iTemp2 &amp; 255; iChar = ga2_Code128[iSet][iTemp2]; pb = P_GetBarSpace128(pb, iChar); if (pb == 0) return 0; iPosition++; if (iSet == SUB::SETA) { if (iChar == 100) iSet = SUB::SETB; else if (iChar == 99) iSet = SUB::SETC; } else if (iSet == SUB::SETB) { if (iChar == 101) iSet = SUB::SETA; else if (iChar == 99) iSet = SUB::SETC; } else if (iChar == 98) { if (iSet == SUB::SETA) iCharNext = ga2_Code128[SUB::SETB][pszCode[iPosition]]; else iCharNext = ga2_Code128[SUB::SETA][pszCode[iPosition]]; pb = P_GetBarSpace128(pb, iChar); if (pb == 0) return 0; iPosition++; } } } pb = P_GetBarSpace128(pb, iCheckDigit); if (pb == 0) return 0; pb = P_GetBarSpace128(pb, 106); i_LenBuf = pb - pFst; return 1; } BYTE*P_GetBarSpace128(BYTE*pb, int iV) { if (iV &lt; 0) return 0; if (iV &gt; 106) return 0; IntString infs[] = { {0, \"bbsbbssbbss\"}, {1, \"bbssbbsbbss\"}, {2, \"bbssbbssbbs\"}, {3, \"bssbssbbsss\"}, {4, \"bssbsssbbss\"}, {5, \"bsssbssbbss\"}, {6, \"bssbbssbsss\"}, {7, \"bssbbsssbss\"}, {8, \"bsssbbssbss\"}, {9, \"bbssbssbsss\"}, {10, \"bbssbsssbss\"}, {11, \"bbsssbssbss\"}, {12, \"bsbbssbbbss\"}, {13, \"bssbbsbbbss\"}, {14, \"bssbbssbbbs\"}, {15, \"bsbbbssbbss\"}, {16, \"bssbbbsbbss\"}, {17, \"bssbbbssbbs\"}, {18, \"bbssbbbssbs\"}, {19, \"bbssbsbbbss\"}, {20, \"bbssbssbbbs\"}, {21, \"bbsbbbssbss\"}, {22, \"bbssbbbsbss\"}, {23, \"bbbsbbsbbbs\"}, {24, \"bbbsbssbbss\"}, {25, \"bbbssbsbbss\"}, {26, \"bbbssbssbbs\"}, {27, \"bbbsbbssbss\"}, {28, \"bbbssbbsbss\"}, {29, \"bbbssbbssbs\"}, {30, \"bbsbbsbbsss\"}, {31, \"bbsbbsssbbs\"}, {32, \"bbsssbbsbbs\"}, {33, \"bsbsssbbsss\"}, {34, \"bsssbsbbsss\"}, {35, \"bsssbsssbbs\"}, {36, \"bsbbsssbsss\"}, {37, \"bsssbbsbsss\"}, {38, \"bsssbbsssbs\"}, {39, \"bbsbsssbsss\"}, {40, \"bbsssbsbsss\"}, {41, \"bbsssbsssbs\"}, {42, \"bsbbsbbbsss\"}, {43, \"bsbbsssbbbs\"}, {44, \"bsssbbsbbbs\"}, {45, \"bsbbbsbbsss\"}, {46, \"bsbbbsssbbs\"}, {47, \"bsssbbbsbbs\"}, {48, \"bbbsbbbsbbs\"}, {49, \"bbsbsssbbbs\"}, {50, \"bbsssbsbbbs\"}, {51, \"bbsbbbsbsss\"}, {52, \"bbsbbbsssbs\"}, {53, \"bbsbbbsbbbs\"}, {54, \"bbbsbsbbsss\"}, {55, \"bbbsbsssbbs\"}, {56, \"bbbsssbsbbs\"}, {57, \"bbbsbbsbsss\"}, {58, \"bbbsbbsssbs\"}, {59, \"bbbsssbbsbs\"}, {60, \"bbbsbbbbsbs\"}, {61, \"bbssbssssbs\"}, {62, \"bbbbsssbsbs\"}, {63, \"bsbssbbssss\"}, {64, \"bsbssssbbss\"}, {65, \"bssbsbbssss\"}, {66, \"bssbssssbbs\"}, {67, \"bssssbsbbss\"}, {68, \"bssssbssbbs\"}, {69, \"bsbbssbssss\"}, {70, \"bsbbssssbss\"}, {71, \"bssbbsbssss\"}, {72, \"bssbbssssbs\"}, {73, \"bssssbbsbss\"}, {74, \"bssssbbssbs\"}, {75, \"bbssssbssbs\"}, {76, \"bbssbsbssss\"}, {77, \"bbbbsbbbsbs\"}, {78, \"bbssssbsbss\"}, {79, \"bsssbbbbsbs\"}, {80, \"bsbssbbbbss\"}, {81, \"bssbsbbbbss\"}, {82, \"bssbssbbbbs\"}, {83, \"bsbbbbssbss\"}, {84, \"bssbbbbsbss\"}, {85, \"bssbbbbssbs\"}, {86, \"bbbbsbssbss\"}, {87, \"bbbbssbsbss\"}, {88, \"bbbbssbssbs\"}, {89, \"bbsbbsbbbbs\"}, {90, \"bbsbbbbsbbs\"}, {91, \"bbbbsbbsbbs\"}, {92, \"bsbsbbbbsss\"}, {93, \"bsbsssbbbbs\"}, {94, \"bsssbsbbbbs\"}, {95, \"bsbbbbsbsss\"}, {96, \"bsbbbbsssbs\"}, {97, \"bbbbsbsbsss\"}, {98, \"bbbbsbsssbs\"}, {99, \"bsbbbsbbbbs\"}, {100, \"bsbbbbsbbbs\"}, {101, \"bbbsbsbbbbs\"}, {102, \"bbbbsbsbbbs\"}, // {103, \"bbsbsbbbbss\"}, {103, \"bbsbssssbss\"}, {104, \"bbsbssbssss\"}, {105, \"bbsbssbbbss\"}, {106, \"bbsssbbbsbsbb\"}, }; int i; IntString&amp;inf = infs[iV]; for (i = 0; i &lt; 11; i++) { if (inf.psz[i] == 'b') *pb += 1; pb++; } if (iV == 106) { *pb += 1; pb++; *pb += 1; pb++; } return pb; }private: int GetCheckDigit(const int iSet, char*pszCode) { int iSum = 0, iCurSet = 0, iChar128, iCharNext, iWeight, iPosition; iCurSet = iSet; if (iSet == SUB::SETA) { iSum = 103; } else if (iSet == SUB::SETB) { iSum = 104; } else if (iSet == SUB::SETC) { iSum = 105; } iPosition = 0; iWeight = 1; const int iNum = strlen(pszCode); while (iPosition &lt; iNum) { if (iCurSet == SUB::SETC) { if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 101) { iChar128 = 101; iSum += (iWeight*iChar128); iPosition++; iWeight++; iCurSet = SUB::SETA; } else if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 100) { iChar128 = 100; iSum += (iWeight*iChar128); iPosition++; iWeight++; iCurSet = SUB::SETB; } else if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 102) { iChar128 = 102; iSum += (iWeight*iChar128); iPosition++; iWeight++; } else { char chT = pszCode[iPosition + 2]; pszCode[iPosition + 2] = 0; iChar128 = atol(&amp;pszCode[iPosition]); pszCode[iPosition + 2] = chT; iSum += (iWeight*iChar128); iPosition += 2; iWeight++; } } else { int iTemp2 = pszCode[iPosition]; if (iTemp2 &lt; -1) iTemp2 = iTemp2 &amp; 255; iChar128 = ga2_Code128[iCurSet][iTemp2]; iSum += (iWeight*iChar128); iPosition++; iWeight++; if (iCurSet == SUB::SETA) { if (iChar128 == 100) iCurSet = SUB::SETB; else if (iChar128 == 99) iCurSet = SUB::SETC; } else if (iCurSet == SUB::SETB) { if (iChar128 == 101) iCurSet = SUB::SETA; else if (iChar128 == 99) iCurSet = SUB::SETC; } else if (iChar128 == 98) { if (iCurSet == SUB::SETA) iCharNext = ga2_Code128[SUB::SETB][pszCode[iPosition]]; else iCharNext = ga2_Code128[SUB::SETA][pszCode[iPosition]]; iSum += (iWeight*iCharNext); iPosition++; iWeight++; } } } return iSum % 103; }};//=============================================class BarcodeEan13 :public BarcodeBase {public: BarcodeEan13() { } ~BarcodeEan13() { } BOOL EncodeEan13(const char*pszCodeIn) { Clear(); //only allow 12 characters as input char szCode[14]; const int iLen = strlen(pszCodeIn); if (iLen &gt; 12) { strncpy(szCode, pszCodeIn, 12); } else { strcpy(szCode, pszCodeIn); while (strlen(szCode) &lt; 12) strcat(szCode, \"0\"); } BYTE*pFst = ia_Buf; BYTE*pb = pFst; //\"bsb\"-long *pb += 5; pb++; *pb += 4; pb++; *pb += 5; pb++; BYTE iaCountryCode[6]; BOOL b = P_GetCountryCode(szCode[0], iaCountryCode); if (b == 0) return 0; pb = P_GetLeftOddParity(pb, szCode[1]); int i; for (i = 2; i &lt; 7; i++) { if (iaCountryCode[i - 2] == 'O') { pb = P_GetLeftOddParity(pb, szCode[i]); } else if (iaCountryCode[i - 2] == 'E') { pb = P_GetLeftEvenParity(pb, szCode[i]); } } //\"sbsbs\"-long *pb += 4; pb++; *pb += 5; pb++; *pb += 4; pb++; *pb += 5; pb++; *pb += 4; pb++; for (i = 7; i &lt; 12; i++) { pb = P_GetRightPattern(pb, szCode[i]); } i = P_GetCheckSumDigit(szCode); pb = P_GetRightPattern(pb, (char)i); //\"bsb\"-long *pb += 5; pb++; *pb += 4; pb++; *pb += 5; pb++; i_LenBuf = pb - pFst; return 1; } void DrawEan13(HDC hDC, int iX, int iY0, int iY10, int iY11, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) { DrawBarcode(hDC, iX, iY0, iY10, iY11, clrBar, clrSpace, iPenW); }private: BOOL P_GetCountryCode(char ch, BYTE*pbCountryCode) { const int iV = ch - '0'; if (iV &lt; 0) return 0; if (iV &gt; 9) return 0; IntString infs[] = { {0, \"OOOOO\"}, {1, \"OEOEE\"}, {2, \"OEEOE\"}, {3, \"OEEEO\"}, {4, \"EOOEE\"}, {5, \"EEOOE\"}, {6, \"EEEOO\"}, {7, \"EOEOE\"}, {8, \"EOEEO\"}, {9, \"EEOEO\"}, }; memcpy(pbCountryCode, infs[iV].psz, 5); return 1; } BYTE*P_GetLeftOddParity(BYTE*pb, char ch) { const int iV = ch - '0'; if (iV &lt; 0) return 0; if (iV &gt; 9) return 0; IntString infs[] = { {0, \"sssbbsb\"}, {1, \"ssbbssb\"}, {2, \"ssbssbb\"}, {3, \"sbbbbsb\"}, {4, \"sbsssbb\"}, {5, \"sbbsssb\"}, {6, \"sbsbbbb\"}, {7, \"sbbbsbb\"}, {8, \"sbbsbbb\"}, {9, \"sssbsbb\"}, }; IntString&amp;inf = infs[iV]; int i; for (i = 0; i &lt; 7; i++) { if (inf.psz[i] == 'b') *pb += 1; pb++; } return pb; } BYTE*P_GetLeftEvenParity(BYTE*pb, char ch) { const int iV = ch - '0'; if (iV &lt; 0) return 0; if (iV &gt; 9) return 0; IntString infs[] = { {0, \"sbssbbb\"}, {1, \"sbbssbb\"}, {2, \"ssbbsbb\"}, {3, \"sbssssb\"}, {4, \"ssbbbsb\"}, {5, \"sbbbssb\"}, {6, \"ssssbsb\"}, {7, \"ssbsssb\"}, {8, \"sssbssb\"}, {9, \"ssbsbbb\"}, }; char*psz = infs[iV].psz; int i; for (i = 0; i &lt; 7; i++) { if (psz[i] == 'b') *pb += 1; pb++; } return pb; } BYTE*P_GetRightPattern(BYTE*pb, char ch) { const int iV = ch - '0'; if (iV &lt; 0) return 0; if (iV &gt; 9) return 0; IntString infs[] = { {0, \"bbbssbs\"}, {1, \"bbssbbs\"}, {2, \"bbsbbss\"}, {3, \"bssssbs\"}, {4, \"bsbbbss\"}, {5, \"bssbbbs\"}, {6, \"bsbssss\"}, {7, \"bsssbss\"}, {8, \"bssbsss\"}, {9, \"bbbsbss\"}, }; char*psz = infs[iV].psz; int i; for (i = 0; i &lt; 7; i++) { if (psz[i] == 'b') *pb += 1; pb++; } return pb; } char P_GetCheckSumDigit(const char*pszCode) { const int iLen = strlen(pszCode); int i, iSum = 0, iItem; for (i = iLen; i &gt;= 1; i--) { iItem = i % 2 ? (pszCode[i - 1] - '0') * 1 : (pszCode[i - 1] - '0') * 3; iSum += iItem; } iSum %= 10; return '0' + (10 - iSum) % 10; }};#endif","link":"/post/3756556672.html"},{"title":"从汇编的角度分析函数调用过程","text":"本文从汇编的视角分析了函数的调用方式，掌握该知识对使用 OllyDbg 等动态调试工具会大有裨益。 一、 函数参数传递形式函数的参数传递有 2 种方式： 堆栈方式 寄存器方式 如果是堆栈方式传递的，就需要定义函数参数在堆栈中的传递顺序，并约定函数被调用之后，由谁来平衡堆栈；如果是寄存器方式传递的，就需要确定参数存放在哪个寄存器中。每一种方式都有其优缺点，而且与使用的编程语言有关系。 我们在开发中经常遇到调用约定类型，如__cdecl、stdcall、PASCAL、fastcall，这些调用约定类型就用来指定函数参数的传递方式的。 上面几种约定类型，除了fastcall是使用寄存器方式传递参数外，其他的都是使用堆栈传递参数的。 Visual Studio 中的 C++工程，可以C++ –&gt; 高级 –&gt; 调用约定中进行调用约定的设置： 二、使用堆栈方式传递函数参数堆栈是一种“后进先出”的数据结构，ESP寄存器始终指向栈顶。栈中数据地址从底部到顶部依次减小，也就是说，栈底对应高地址，栈顶对应低地址。 调用函数时，调用者依次把参数压栈，然后调用函数，函数被调用之后，在堆栈中取得参数数据。函数调用结束以后，堆栈需要恢复到函数调用之前的样子，而到底是由调用者来恢复还是由函数自身来恢复，根据不同的调用约定类型采用不同的方式。 约定类型 __cdecl stdcall PASCAL fastcall 参数传递顺序 从右到左 从右到左 从左到右 使用寄存器 堆栈平衡者 调用者 函数自身 函数自身 函数自身 __cdcel是 C/C++/MFC 程序默认的调用约定。stdcall是绝大多数 Win32 API 函数的约定方式，也有少部分使用__cdcel约定方式（如 wsprintf 等）。在 Windows C/C++开发中常用的就是__cdecl和stdcall这 2 种调用约定。 按照不同的调用约定来调用函数int add(int a, int b)。从调用者的视角来看，其汇编代码分别表示如下： __cdecl 1234push b ;参数按从右到左传递push acall addadd esp, 8 ;调用者在函数外部平衡堆栈 stdcall 123push b ;参数按从右到左传递push acall add ;函数自己内部平衡堆栈，调用者不需要平衡堆栈 在函数调用过程中，参数入栈的过程如图： 上图中，EBP和函数返回地址ret都是 32 位地址。因为函数调用完之后会将EBP恢复为暂存在堆栈中的原EBP值，所以从调用者角度来看，在函数的一次调用过程中EBP是不会变化的。 我们可以在函数中通过新的EBP获取函数各个参数的值： 12参数a = EBP + 0x8参数b = EBP + 0xC 三、调用过程分析123456789101112131415#include &lt;stdio.h&gt;int add(int a, int b) { int c = 0; c = a + b; return c;}int main(){ int r = add(1, 2); return 0;} 我们使用Visual Studio 2017编译上面代码，并在在工程配置中将函数调用约定设置为__cdecl。 在程序调试过程中，可以在Visual Studio的反汇编窗口中看到 C++代码对应的汇编代码，以及寄存器窗口中看到各个寄存器的值。 main函数的反汇编代码如下： 123456789101112131415161718192021int main(){00DD1720 push ebp // 参见add函数中关于这一部分的解析00DD1721 mov ebp,esp00DD1723 sub esp,0CCh00DD1729 push ebx00DD172A push esi00DD172B push edi00DD172C lea edi,[ebp-0CCh]00DD1732 mov ecx,33h00DD1737 mov eax,0CCCCCCCCh00DD173C rep stos dword ptr es:[edi] int r = add(1, 2);00DD173E push 2 // 参数b入栈00DD1740 push 1 // 参数a入栈00DD1742 call add (0DD1276h) // 调用add函数。CALL指令相当于执行一条PUSH指令加一条JMP指令，PUSH指令用于压入该指令的下一条指令地址到栈中，用于执行完子函数之后返回来。JMP指令用于跳转到子函数所在位置开始执行子函数。00DD1747 add esp,8 // 因为是__cdecl，所以由调用者来平衡堆栈.00DD174A mov dword ptr [r],eax return 0;00DD174D xor eax,eax} 执行进入add函数后，add函数内的汇编代码如下： 1234567891011121314151617181920212223242526272829int add(int a, int b) {00DD16D0 push ebp // ebp入栈，相当于暂存ebp的值00DD16D1 mov ebp,esp // 将esp赋值给ebp，在该函数之后的执行过程中不会再改变ebp的值。00DD16D3 sub esp,0CCh // 在栈上分配0xCC大小的局部变量存储区域00DD16D9 push ebx // 暂存ebx00DD16DA push esi // 暂存esi00DD16DB push edi // 暂存edi00DD16DC lea edi,[ebp-0CCh] //下面4行代码（含该条）实现将0xCC大小的局部变量存储区域全部赋值为0xCC00DD16E2 mov ecx,33h // ecx存储循环次数，结合rep指令使用。为什么是0x33次了？因为是按照4个字节赋值的，0x33 * 0x4 = 0xCC00DD16E7 mov eax,0CCCCCCCCh00DD16EC rep stos dword ptr es:[edi] // 循环赋值 int c = 0;00DD16EE mov dword ptr [c],0 // 将局部变量c赋值为0 c = a + b;00DD16F5 mov eax,dword ptr [a]00DD16F8 add eax,dword ptr [b]00DD16FB mov dword ptr [c],eax return c;00DD16FE mov eax,dword ptr [c] // 将结果存储到eax中。在函数调用中返回结果都是存储在eax中的。}01191701 pop edi // 将edi的值还原到函数调用前01191702 pop esi // 将esi的值还原到函数调用前01191703 pop ebx // 将ebx的值还原到函数调用前01191704 mov esp,ebp // 移动栈顶到ebp位置，从而跳过了局部变量存储区域01191706 pop ebp // 将ebp的值还原到函数调用前01191707 ret // ret指令等同于：弹出此时栈顶的值给eip， // 因为此时栈顶存储的刚好是函数返回地址，所以相当于将返回地址赋值给eip，从而实现了返回到函数调用的地方。 在上面代码的注释中已经包含了详细的解释，特别值得注意的几个地方是： rep stos dword ptr es:[edi]结合edi, ecx来初始化局部存储区域。 函数call指令之前的参数压栈顺序。 CALL指令相当于执行一条PUSH指令加一条JMP指令，PUSH指令用于压入该指令的下一条指令地址到栈中，用于执行完子函数之后返回来。JMP指令用于跳转到子函数所在位置开始执行子函数。 因为是__cdecl，函数调用完之后，调用方使用add esp,8来平衡堆栈。 ret指令等同于：弹出此时栈顶的值给 eip，巧妙之处在于此时栈顶存储的刚好是函数返回地址。","link":"/post/4168021185.html"},{"title":"在C++中使用Lamada表达式","text":"Lamada 表达式是 C++11 最重要也是最常用的特性之一。Lamada 来源于函数式编程的概念，也是现代编程语言的一个特点。 一、Lamada 表达式定义下图展示出了 C++ Lamada 表示的组成部分： 其中：① 指明捕获列表。② 指明参数列表。③ mutable可选项。和常规的 mutable 用法类似，即当 lamada 表达式参数是 const 时，使用mutable可以取消这种 const。④ throw可选项。可以使用noexcept指明/约束表达式内不会抛出异常。⑤ 指定返回类型。⑥ Lamada 函数体。 根据上图定义一个完整的 lamada 表达式： 1auto f = [](int a) noexcept -&gt; int { return a + 1; }; 二、返回类型很多时候 lamada 表达式的返回值类型是非常明显的，编译器可以根据return语句自动推导出返回类型，这个时候我们可以省略表达式的返回值定义： 1auto x1 = [](int a) {return a + 1}; // OK: return type is int 但是，初始化列表不能用于返回值的自动推导： 1auto x2 = [](int a) {return {a+1, a+2}; }; // error: 无法推导出返回值类型 三、捕获列表lamada 表达式可以通过捕获列表捕获一定范围内的变量： [] 不捕获任何变量。 [&amp;] 按引用捕获：捕获外部作用域中的所有变量，并作为引用在函数体中使用。 [=] 按值捕获：捕获外部作用域中的所有变量，并作为副本在函数体中使用。 [=, &amp;foo] 按值捕获外部作用域中的所有变量，并按引用捕获 foo 变量。 [bar] 按值捕获 bar 变量，同时不捕获其他变量。 [this] 捕获 lamada 所在的当前类中的this指针，让 lamada 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了&amp;或=，就默认添加此选项。捕获 this 的目的是可以在 lamada 中使用当前类的成员函数和成员变量。 四、异常约束可以使用noexcept来指定和约束 Lamada 表达内不会抛出异常，如果抛出异常，编译器会产生编译警告。 123456// throw_lambda_expression.cpp// compile with: /W4 /EHscint main() // 产生编译警告C4297{ []() noexcept { throw 5; }();} 五、mutable正常情况下，按值捕获的变量，其值在 Lamada 表达式内是不能被修改的（遵循const-by-value），如下面的代码编译会报错： 123456 int n = 1;auto fuc = [n]() { n = 2;};// error C3491: “n”: 无法在非可变 lambda 中修改通过复制捕获 可以使用mutable关键字改变这种行为： 123456int n = 1;auto fuc = [n]() mutable { n = 2;};printf(\"%d\", n); // 1 虽然在 Lamada 表达式内可以修改n的值，但n仍是按值传递，因此外部n的值没有被改变。 参考：https://msdn.microsoft.com/en-us/library/dd293608.aspx","link":"/post/4208014138.html"},{"title":"深入理解C++虚函数","text":"本文主要介绍 C++虚函数的底层实现，虚析构函数的作用，虚函数表的数据结构及存储方式，以及__declspec(novtable)的作用。 一. 虚函数介绍C++中的虚函数主要是用来实现多态（面向对象的三大特性之一）的。下面是一个实现多态的错误例子： 123456789101112131415161718192021222324252627282930313233343536373839404142// 基类//class Base {public: Base() { printf(\"Call Base::Base()\\n\"); } ~Base() { } void Name() { printf(\"Call Base::Name()\\n\"); }};// 派生类//class Derive : public Base {public: Derive() { printf(\"Call Derive::Derive()\\n\"); } ~Derive() { } void Name() { printf(\"Call Derive::Name()\\n\"); }};int main(){ Base* pBase = new Derive(); pBase-&gt;Name(); delete pBase; return 0;} 程序输出： 123Call Base::Base()Call Derive::Derive()Call Base::Name() 输出内容的第 3 行为：Call Base::Name()，并不是期望的Call Derive::Name()。因为void Name()函数不是虚函数，所以pBase-&gt;Name()调用的是基类的 Name()函数，并不是我们所期望的派生类 Derive 的 Name()函数。 如果将基类中void Name()改成虚函数virtual void Name()，程序输出就会和我们期望的一样： 12345678910111213141516// 基类//class Base {public: Base() { printf(\"Call Base::Base()\\n\"); } ~Base() { printf(\"Call Base::~Base()\\n\"); } virtual void Name() { printf(\"Call Base::Name()\\n\"); }}; 二、 虚析构函数virtual不仅可以修饰成员函数，也可以用来修饰析构函数，也就是我们常说的虚析构函数。 下面的例子中的基类的析构函数没有使用 virtual 修饰，我们先执行程序，观察运行结果（类似上面的程序，只是在析构函数中多加入了输出打印语句）。 123456789101112131415161718192021222324252627282930313233343536373839404142// 基类//class Base {public: Base() { printf(\"Call Base::Base()\\n\"); } ~Base() { printf(\"Call Base::~Base()\\n\"); } virtual void Name() { printf(\"Call Base::Name()\\n\"); }};// 派生类//class Derive : public Base {public: Derive() { printf(\"Call Derive::Derive()\\n\"); } ~Derive() { printf(\"Call Derive::~Derive()\\n\"); } void Name() { printf(\"Call Derive::Name()\\n\"); }};int main(){ Base* pBase = new Derive(); pBase-&gt;Name(); delete pBase; return 0;} 程序输出： 1234Call Base::Base()Call Derive::Derive()Call Derive::Name()Call Base::~Base() 从输出内容的第 4 行可以看到，执行delete pBase语句只有基类 Base 类的析构函数被调用了，而派生类 Derive 的析构函数却没有被调用。如果此时派生类 Derive 中有需要在析构函数执行的代码（如内存释放，句柄关闭等），这些代码将不会执行，有可能就会造成内存泄漏、句柄泄漏、逻辑错误等问题。 正确的做法是：使用 virtual 修饰基类的析构函数，即虚析构函数。 12345678910111213141516// 基类//class Base {public: Base() { printf(\"Call Base::Base()\\n\"); } virtual ~Base() { printf(\"Call Base::~Base()\\n\"); } virtual void Name() { printf(\"Call Base::Name()\\n\"); }}; 此时程序输出为： 12345Call Base::Base()Call Derive::Derive()Call Derive::Name()Call Derive::~Derive()Call Base::~Base() 调用delete pBase之后，先执行了派生类 Derive 的析构函数，然后执行基类 Base 的析构函数。 在《C++API 设计》一书中有明确的说到：“如果希望一个类可以被继承，那么就应该将它的析构函数使用 virtual 修饰；反过来可以理解为，如果一个类的析构函数不是虚的，那么这个类是被设计为不可继承的。” 三、虚函数的实现原理3.1 实现原理C++的虚函数是使用虚函数表（即指针数组，也就是指针的指针）来实现的。 只要在类中声明了虚函数，编译器就会在类的对象中自动生成一个虚函数表，但一个对象最多只有一个虚函数表，不管这个类声明了多少个虚函数。虚函数表是针对于类的对象的。 3.2 虚函数表（指针）存储位置不同的编译器将自动生成的虚函数表指针存放的位置不同，有的存放在类对象所占内存的起始位置，有的存放在类对象所占内存的末尾。 可以通过如下代码来判断： 1234567891011121314151617// 返回值： ture - 虚函数指针存放在对象内存起始位置// false - 虚函数指针存放在对象内存末尾位置//bool VirtualTableAtFirst() { class _C { public: char _i; virtual void _f() { } }; _C c; char * p1 = reinterpret_cast&lt;char*&gt;(&amp;c); char * p2 = reinterpret_cast&lt;char*&gt;(&amp;c._i); return p1 != p2;} 通过 MSVC2015 编译运行，返回true, 说明 MSVC 编译器是将虚函数表指针放置在类对象内存的起始位置处。 3.3 虚函数表存储方式既然知道了 C++是使用虚函数表的形式来实现虚函数的，那个虚函数表中的数据是以何种形式来存储的了？ 现在我们根据类的继承方式的不同来分别说明。 3.3.1 单继承无重载类结构如图，Derive 继承于 Base，但 Derive 没有重载 Base 类中的任何函数。 需要说明的是，函数 f(), g(), h(), f1(), g1(), h1() 均为虚函数，这个在图上没有明确的写出来，后面的图也是一样。 这时Base b; 对象 b 的虚函数表为： Derive d; 对象 d 的虚函数表为： 3.3.2 单继承有重载Derive 重载 Base 类中的 f()函数： 这时Base b; 对象 b 的虚函数表不变，无论继承于它派生类如何重载，都不会影响基类的虚函数： Derive d; 对象 d 的虚函数表为： 派生类中重载基类的 f()函数指针替换了原来基类中虚函数 Base::f()的指针； 派生类中其他的虚函数存放在基类虚函数之后。 3.3.3 多继承无重载 此时，Derive d; 对象 d 的虚函数表为： 派生类自己的虚函数存放在第一个基类的虚函数表的最后面。 3.3.4 多继承有重载 此时，Derive d; 对象 d 的虚函数表为： 四、虚函数表的应用我们知道在 C++中要调用类的私有方法，我们可以使用友员（friend）的方式。但其实如果我们知道类的定义，完全可以根据该类对象的内存布局来直接调用它的私有函数。 下面介绍如何使用虚函数表的方式来调用该类的私有虚函数。 现有如下Test类，提供了一个私有虚函数virtual void Func()： 123456789101112131415class Test {public: Test() { } virtual~ Test() { }private: virtual void Func() { printf(\"Private Function\\n\"); }}; 现在我们使用虚函数表来调用Func成员函数： 123456789101112131415typedef void(*PFN_Func)();int main(){ Test t; unsigned long **VirtualTable = (unsigned long **)(&amp;t); unsigned long FuncAddr = VirtualTable[0][1]; PFN_Func pfnFunc = (PFN_Func)FuncAddr; if (pfnFunc) { pfnFunc(); } return 0;} 我们知道虚函数表其实就是一个二维数组。因为示例中的Test类没有继承于其他类，所以第一维只有一个元素；又因Test类有 2 个虚函数，故第二维有 2 个元素，且Func排在第二个，所以用VirtualTable[0][1]来取Func函数地址。 因为该示例运行在 MSVC 编译器环境，所以默认认为虚函数表位于类对象内存布局的起始位置，故直接使用了unsigned long **VirtualTable = (unsigned long **)(&amp;t);。严谨的做法应该是先判断虚函数表是否位于对象的内存布局起始位置。 五、__declspec(novtable)Mircrosoft C++中提供了__declspec(novtable)来修饰类，__declspec(novtable)会阻止编译器为该类生成虚函数表，这样可以减少编译生成代码的大小，同时也约束该类无法被实例化。 1234567891011121314151617181920// novtable.cpp#include &lt;stdio.h&gt;struct __declspec(novtable) X { virtual void mf();};struct Y : public X { void mf() { printf_s(\"In Y\\n\"); }};int main() { // X *pX = new X(); // pX-&gt;mf(); // 导致运行时访问冲突 Y *pY = new Y(); pY-&gt;mf();} 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/3162890435.html"},{"title":"编译器基础概念","text":"一、C++代码编译流程以下面 C++代码为例： 1234567#include &lt;stdio.h&gt;​int main(){ printf(\"Hello World\"); return 0;} 编译成二进制文件需要经过如下 4 个过程： 预编译：将 hello.c 和 stdio.h 预编译为 hello.i 编译：将 hello.i 编译为 hello.s 汇编：将 hello.s 翻译为机器指令 hello.o（.o 目标文件） 链接：链接各种需要的库和其他目标文件（该 hello 程序不需要）得到可执行文件 hello.out（相当于 windows 的.exe）。 二、编译器架构编译器通常分为三个部分： 前端（FrontEnd） 优化器（Optimizer） 后端（BackEnd） 在编译过程中，前端主要负责词法和语法分析，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。 2.1 GCCGCC(GNU Compiler Collection，GNU 编译器集合)是一个完整的编译器，包含 FrontEnd、Optimizer 和 BackEnd。 2.2 LLVM 架构Clang是 LLVM 编译器架构的前端，可以用来编译 C，C++，ObjectiveC 等语言； LLVM是该架构的优化器和后端； 二者统称为 LLVM 架构。 三、编译版本选择3.1 x86、x86-64、AMD64x86 是指 Intel 的开发的一种 32 位指令集，从 386 时代开始，一直沿用至今，所有 Intel 早期的 cpu，以及 amd 早期的 cpu 都支持这种指令集。 AMD 领先 Intel 制造出兼容 x86 的商用 CPU，AMD 称之为 AMD64，且得到用户的认同。 Intel 选择设计了一种不兼容 x86 的全新 64 位指令集，称之为 IA-64。由于是全新设计的 CPU，没有编译器、不支持 Windows，后来不得不在时机落后的情况下也开始支持 AMD64 指令集。因此换了个名字叫 x86_64，表示 x86 指令集的 64 位扩展。 x86_64、x64、AMD64 基本上是一个东西，我们现在用的 intel/amd 的桌面级 CPU 基本上都是 x86_64。 3.2 i386i386 即 Intel 80386。 其实 i386 通常被用来作为对 Intel（英特尔）32 位微处理器的统称。 但是目前更多的时候，我们公认 i386 为 32 位系统，其实就是 x86。 3.3 i686i686 仍然属于 i386 体系，不过相对于 386 CPU 的特性作了指令优化。 3.4 MSVC 编译器版本描述 x86：编译器为 x86 版本，输出文件为 x86。 amd64_x86：编译器为 amd64 版本，输出文件为 x86。 amd64：编译器为 amd64 版本，输出文件为 amd64。 x86_amd64：编译器为 x86 版本，输出文件为 amd64。","link":"/post/3064318708.html"},{"title":"Electron判断程序运行环境","text":"Electron官方未提供判断当前程序运行环境的方法。我认为官方不提供这个方法也是说的过去的，因为Electron扮演的是应用开发框架的角色，而运行环境这些东西本身属于开发者自己的事情，有的开发者喜欢定义“开发、测试、预生产、生成”四个环境，而有的开发者却只定义了一个生产环境，这些都不是框架需要参与的事情。 本文提供了几个定义和判断程序运行环境的方法，开发者可以根据实际情况选取相应的方法。 1. 根据是否打包来判断Electron官方提供了app.isPackaged属性来判断应用是否是经过打包的。 一般开发环境不打包，而非开发环境会打包，我们可以通过这个属性来判断当前运行环境是否是开发环境。 2. 根据可执行文件名判断在开发环境中，我们通常使用如下命令启动程序： 1electron . 此时程序是通过electron.exe（非Windows操作系统上是electron）来启动的，而在打包后的生产环境是通过我们指定的exe启动的，因此我们可以通过判断可执行文件名是否为electron.exe来检查是否为生产环境。 123456789101112131415function isProduction() { if (!process.versions.electron) { // Node.js process return false; } if (process.platform === \"darwin\") { return !/\\/Electron\\.app\\//.test(process.execPath); } if (process.platform === \"win32\") { return !/\\\\electron\\.exe$/.test(process.execPath); } if (process.platform === \"linux\") { return !/\\/electron$/.test(process.execPath); }} 这种方式只能用来检查是否为生产环境，不能定义和判断开发、测试、预生产这些环境。 3. 根据命令行参数判断通过在不同环境中为程序添加不同的启动参数，然后在运行时校验这些命令行参数来判断当前的运行环境。 不同的环境添加启动参数的方式不太一样。由于开发环境不需要打包，因此可以通过下面方式添加： 1electron . --env=development 而非开发环境往往需要打包，因此需要在命令行中手动添加，如： 1Demo.exe --env=test 判断方法如下： 12345678910111213141516function isProduction() { if (!process.versions.electron) { // Node.js process return false; } for (const v of process.argv) { if (v === \"--env=development\" || // 开发环境 v === \"--env=test\" // 测试环境 ) { return false; } } return true;} 4. 通过环境变量判断这个判断方法与方法2类似，不做过多介绍。需要注意的是，Windows和Unix上添加环境变量的方式略有不同。 Windows: 1set APP_ENV=dev &amp;&amp; electron . Unix: 1APP_ENV=dev electron . 在Electron中通过process.env.APP_ENV就就可以获取到APP_ENV环境变量。","link":"/post/612028078.html"},{"title":"Electron启动和禁用调试工具的方法","text":"1. 启用调试工具Electron中打开调试窗口的方法有多种，但前提都需要在创建Browser Window时启用devTools特性，如： 12345678const win = new BrowserWindow({ width: 1080, height: 768, title: \"test window\", webPreferences: { devTools: true }}); 启用devTools特性后，可以通过下面几种方式打开调试窗口： 方式1在代码中使用BrowserWindow.webContents.openDevTools()打开调试窗口。 方式2通过快捷键Ctrl+Shift+I打开调试窗口。 方式3在程序的启动命令行中添加--remote-debugging-port=8888参数，然后使用浏览器打开调试页面http://127.0.0.1:8888即可进行调试。 这种方式默认调试的是渲染进程，如需调试主进程则需要使用--inspect=8888参数。 另外，如果打开调试页面时提示WebSockets request was expected而无法显示调试工具，需要使用访问chrome://inspect/打开inspect页面，配置对应的发现ip和端口，如localhost:8888： 配置完成后，刷新inspect页面后在Remote Target中选择对应的调试目标进行调试。 2. 禁用调试工具在软件上线发布时，我们需要在生产环境完全禁用调试工具，此时只需要将devTools属性设置为false即可，如： 12345678const win = new BrowserWindow({ width: 1080, height: 768, title: \"test window\", webPreferences: { devTools: false }}); 上面的代码虽然可以禁用调试工具，但在开发环境中，我们往往需要打开调试工具，因此在每次“开发-&gt;发布版本”时都需要来回修改devTools，容易出现漏改的情况。 可以使用Electron判断程序运行环境介绍的方法来判断当前是否为生产环境，启用/禁用devTools的代码可以优化为： 12345678const win = new BrowserWindow({ width: 1080, height: 768, title: \"test window\", webPreferences: { devTools: !isProduction() }});","link":"/post/2191045165.html"},{"title":"Janus的编译部署及配置","text":"Janus是一个开源的 WebRTC SFU 服务器，可以作为 WebRTC 的一个端将其收到的数据进行转发，同时提供了一些的控制能力。Janus 是基于插件架构的，其功能都是通过一个个插件来提供，我们可以为 Janus 开发插件，来扩展其功能。 一、编译部署Janus 可以方便的在 Linux 和 MacOS 上面编译部署，暂时不支持 Windows 系统，但可以在 Win10 的Windows Subsystem for Linux上编译部署。 1.1 安装依赖项在编译 Janus 之前，需要安装如下依赖项： Jansson libconfig libnice (at least v0.1.15 suggested, master recommended) OpenSSL (at least v1.0.1e) libsrtp (at least v1.5 suggested) usrsctp (only needed if you are interested in Data Channels) libmicrohttpd (only needed if you are interested in REST support for the Janus API) libwebsockets (only needed if you are interested in WebSockets support for the Janus API) cmake (only needed if you are interested in WebSockets and/or BoringSSL support, as they make use of it) rabbitmq-c (only needed if you are interested in RabbitMQ support for the Janus API or events) paho.mqtt.c (only needed if you are interested in MQTT support for the Janus API or events) nanomsg (only needed if you are interested in Nanomsg support for the Janus API) libcurl (only needed if you are interested in the TURN REST API support) Janus 的某些插件可能还依赖下面的库： Sofia-SIP (only needed for the SIP plugin) libopus (only needed for the bridge plugin) libogg (needed for the voicemail plugin and/or post-processor) libcurl (only needed if you are interested in RTSP support in the Streaming plugin or in the sample Event Handler plugin) Lua (only needed for the Lua plugin) 另外，还需要安装如下工具： GLib pkg-config gengetopt 上面的所有库通常在多数 Linux 发行版中都有提供，可以直接安装。以在Fedora中安装为例： 1234yum install libmicrohttpd-devel jansson-devel \\ openssl-devel libsrtp-devel sofia-sip-devel glib2-devel \\ opus-devel libogg-devel libcurl-devel pkgconfig gengetopt \\ libconfig-devel libtool autoconf automake 需要注意的是，如果你尝试在CentOS上面安装这些依赖项，需要先执行yum install epel-release . 在Ubuntu和Debian系统上，执行如下命令： 1234aptitude install libmicrohttpd-dev libjansson-dev \\ libssl-dev libsrtp-dev libsofia-sip-ua-dev libglib2.0-dev \\ libopus-dev libogg-dev libcurl4-openssl-dev liblua5.3-dev \\ libconfig-dev pkg-config gengetopt libtool automake 在低版本的系统上(如低于Ubuntu 14.04 LTS版本)，可能没有提供的libopus的预编译包，如果遇到这种情况，需要手动编译opus. 1.1.1 libnicelibnice虽然在大多数系统上都提供了预编译包，但可能会导致一些问题，所以建议先卸载老版本，然后下载 libnice 的master的版本，手动编译： 12345git clone https://gitlab.freedesktop.org/libnice/libnicecd libnice./autogen.sh./configure --prefix=/usrmake &amp;&amp; sudo make install 确保已经移除老版本，否则会产生冲突。如果需要保留多个版本的 libnice，可以执行pkg-config --cflags --libs nice确保 Janus 可以找到正确的版本，如果无法找到，可以在编译 Janus 之前设置PKG_CONFIG_PATH环境变量，如export PKG_CONFIG_PATH=/path/to/libnice/lib/pkgconfig 1.1.2 libcurl如果后期需要编译安装 Janus 的Event Handler插件，还需要安装 libcurl 库的开发版本，在 Fedora/CentOS 上通常为libcurl-devel，在 Ubuntu/Debian 上通常为libcurl4-openssl-dev。 1.1.3 libsrtp假如已经安装了libsrtp 1.5 之前的版本，需要先卸载，然后手动安装1.5x 或 1.6x版本。因为 1.4x 版本会导致 WebRTC 出现一些问题。以安装2.2.0版本为例： 12345wget https://github.com/cisco/libsrtp/archive/v2.2.0.tar.gztar xfv v2.2.0.tar.gzcd libsrtp-2.2.0./configure --prefix=/usr --enable-opensslmake shared_library &amp;&amp; sudo make install Janus 的 configure 脚本可以自动检测到使用的 libsrtp 的版本，如果同时安装了 1.5x 和 2.x 版本，会优先使用 2.x 版本，如果想强制使用 1.5 或者 1.6 版本，可以在 configure 命令传入--disable-libsrtp2 参数。 假如安装的是 x86/x64 版本的 libsrtp，需要在 configure 命令传入--libdir=/usr/lib64参数。 1.1.4 BoringSSL如果需要使用BoringSSL代替OpenSSL （因为使用BoringSSL可以使用--enable-dtls-settimeout功能），可以通过如下命令手动安装，并且在 configure 命令传入--enable-boringssl参数： 12345678910111213141516git clone https://boringssl.googlesource.com/boringsslcd boringssl# Don't barf on errorssed -i s/\" -Werror\"//g CMakeLists.txt# Buildmkdir -p buildcd buildcmake -DCMAKE_CXX_FLAGS=\"-lrt\" ..makecd ..# Installsudo mkdir -p /opt/boringsslsudo cp -R include /opt/boringssl/sudo mkdir -p /opt/boringssl/libsudo cp build/ssl/libssl.a /opt/boringssl/lib/sudo cp build/crypto/libcrypto.a /opt/boringssl/lib/ Janus 默认 BoringSSL 安装在/opt/boringssl，如果不是，可以通过--enable-boringssl=/path/to/boringssl指定。 1.1.5 usrcstp1234git clone https://github.com/sctplab/ccd usrsctp./bootstrap./configure --prefix=/usr &amp;&amp; make &amp;&amp; sudo make install Note: 假如安装的是 x8/x64 版本的 usrcstp，需要在 configure 命令传入 --libdir=/usr/lib64 参数。 1.1.6如果需要提供 websockets 信令支持，还需要安装 libwebsockets 库： 123456789git clone https://libwebsockets.org/repo/libwebsocketscd libwebsockets# If you want the stable version of libwebsockets, uncomment the next line# git checkout v2.4-stablemkdir buildcd build# See https://github.com/meetecho/janus-gateway/issues/732 re: LWS_MAX_SMPcmake -DLWS_MAX_SMP=1 -DCMAKE_INSTALL_PREFIX:PATH=/usr -DCMAKE_C_FLAGS=\"-fpic\" ..make &amp;&amp; sudo make install 假如 libwebsockets.org 无法访问, 可以将第一行替换为:git clone https://github.com/warmcat/libwebsockets.git 1.1.7 文档如果需要编译 Janus 文档，需要安装如下工具： Doxygen Graphviz Fedora: 1yum install doxygen graphviz Ubuntu/Debian: 1aptitude install doxygen graphviz 二、编译在安装完依赖项之后，使用下面命令获取 Janus 代码： 1234- [ ] git clone https://github.com/meetecho/janus-gateway.git cd janus-gateway 然后使用sh autogen.sh命令生成 configure 文件。最后，执行 configure 和编译命令开始编译： 123./configure --prefix=/opt/janus --enable-boringsslmakemake install 编译完成之后，使用make configs命令生成默认配置文件，配置文件位于/opt/janus/etc/janus/janus.jcfg。需要注意的是，每次执行make configs命令都会将/opt/janus/etc/janus/janus.jcfg文件还原为默认配置。 三、运行、测试我们可以先不修改任何配置，将 Janus 运行起来，然后使用测试 html，测试一下效果。执行如下命令，运行 Janus： 1/opt/janus/bin/janus Janus 启动完成之后，我们另寻一台客户机，将 Janus 源码下载下来，修改janus-gateway\\html\\echotest.js文件中server变量为：\"ws://47.93.47.150:8188\"，如： 1234567var server = null;if(window.location.protocol === 'http:') server = \"http://\" + window.location.hostname + \":8088/janus\";else server = \"https://\" + window.location.hostname + \":8089/janus\";server = \"ws://47.93.47.150:8188\"; 在浏览器中打开echotest.html，点击“Start”即可看到效果。 如果无法连接成功，可能是因为iceServers默认使用的是 google 的 turn 服务器，国内无法访问导致，可以参考 如何搭建WebRTC的TURN服务器 搭建自己的 TURN 服务器。","link":"/post/3773107387.html"},{"title":"P2P及NAT穿透技术介绍","text":"一、 P2P（peer to peer）P2P 是一个“点对点传输技术”，也就是 2 台计算机之间不需要第三台机器作为服务端就能实现数据的传输。每台计算机即是客户端又是服务端。如果每台计算机都有自己的独立的公网 IP，那么 P2P 技术就比较好实现了，但是现实中由于 NAT 的存在，使得 P2P 技术最大的难点就在于穿越 NAT 的限制，俗称“打洞”。 二、 NAT（Network Address Translation）2.1 NAT 的产生背景IPv4 即网际网协议第 4 版——Internet Protocol Version 4 的缩写。如果我们把 Internet 比作一个邮政系统，那么 IP 地址的作用就等同于包含城市、街区、门牌编号在内的完整地址，可以准确的定位到某一台计算机。IPv4 使用 32bits 整数表达一个地址，地址最大范围就是 232 约为 43 亿。以 IP 创始时期可被联网的设备来看，这样的一个空间已经很大，很难被短时间用完。然而，事实远远超出人们的设想，计算机网络在此后的几十年里迅速壮大，网络终端数量也呈爆炸性增长。 更为糟糕的是，为了路由和管理方便，43 亿的地址空间被按照不同前缀长度划分为 A,B,C,D 类地址网络和保留地址。IANA 向超大型企业/组织分配 A 类网络地址，一次一段。向中型企业或教育机构分配 B 类网络地址，一次一段。这样一种分配策略使得 IP 地址浪费很严重，很多被分配出去的地址没有真实被利用，地址消耗很快。以至于二十世纪 90 年代初，网络专家们意识到，这样大手大脚下去，IPv4 地址很快就要耗光了。于是，人们开始考虑 IPv4 的替代方案，同时采取一系列的措施来减缓 IPv4 地址的消耗。正是在这样一个背景之下，NAT 应运而生。 2.2 NATNAT（Network Address Translation）网络地址转换，就是在内网 IP 和公网 IP 之前相互转换。NAT 通常部署在一个组织的网络出口位置。 2.2.1 什么是内部网络地址（内网 IP）？RFC1918 规定了三个保留地址段落，这三个范围分别处于 A,B,C 类的地址段，不向特定的用户分配，被 IANA 作为私有地址保留。这些地址可以在任何组织或企业内部使用。和其他 IPv4 地址的区别就是，仅能在内部使用，不能作为全球路由地址。这就是说，出了组织的管理范围这些地址就不再有意义，无论是作为源地址，还是目的地址。对于一个封闭的组织，如果其网络不连接到外部 Internet，就可以使用这些地址而不用向 IANA 提出申请，而在内部的路由管理和报文传递方式与其他网络没有差异。 12310.0.0.0-10.255.255.255172.16.0.0-172.31.255.255192.168.0.0-192.168.255.255 对于有 Internet 访问需求而内部又使用私有地址的网络，就要在组织的出口位置部署 NAT 网关，在报文离开私网进入 Internet 时，将源 IP 替换为公网地址，通常是出口设备的接口地址。一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应内容由 Internet 发回到出口网关。出口网关再将目的地址替换为私网的源主机地址，发回内部。这样一次由私网主机向公网服务端的请求和响应就在通信两端均无感知的情况下完成了。依据这种模型，数量庞大的内网主机就不再需要公有 IP 地址了。 2.2.2 NAT 分类 全锥形 NAT（Full Cone NAT）一旦内部主机端口对(iAddr:iPort)被 NAT 网关映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；任何一个外部主机发送到(eAddr:ePort)的报文将会被转换后发到(iAddr:iPort)。 限制锥形 NAT（Restricted Cone NAT）一旦内部主机端口对(iAddr:iPort)被映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；只有 (iAddr:iPort)向特定的外部主机 hAddr 发送过数据，主机 hAddr 从任意端口发送到(eAddr:ePort)的报文将会被转发到(iAddr:iPort)。 端口限制锥形 NAT（Port Restricted Cone NAT）一旦内部主机端口对(iAddr:iPort)被映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；只有(iAddr:iPort)向特定的外部主机端口对(hAddr:hPort)发送过数据，由 (hAddr:hPort)发送到(eAddr:ePort)的报文将会被转发到(iAddr:iPort)。 对称型 NAT（Symmetric NAT）NAT 网关会把内部主机“地址端口对”和外部主机“地址端口对”完全相同的报文看作一个连接，在 NAT 网关上创建一个公网“地址端口对”映射进行转换，只有收到报文的外部主机从对应的端口对发送回应的报文，才能被转换。即使内部主机使用之前用过的地址端口对去连接不同外部主机(或端口)时，NAT 网关也会建立新的映射关系。 三、 NAT 穿越技术常见的 NAT 穿越技术有：STUN、TURN、ICE。 3.1 STUN（Session Traversal Utileties for NAT）在RFC3489和RFC5389中的名称都是 STUN，但其全称是不同的。在 RFC3489 里，STUN 的全称是 Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)， 即穿越 NAT 的简单 UDP 传输，是一个轻量级的协议，允许应用程序发现自己和公网之间的中间件类型，同时也能允许应用程序发现自己被 NAT 分配的公网 IP。这个协议在 2003 年 3 月被提出，目前已经被 STUN/RFC5389 所替代。 但在 RFC5389 中，STUN 的全称变为 Session Traversal Utilities for NAT，即 NAT 环境下的会话传输工具，是一种处理 NAT 传输的协议，但主要作为一个工具来服务于其他协议。和 STUN/RFC3489 类似，可以被终端用来发现其公网 IP 和端口，同时可以检测端点间的连接性，也可以作为一种保活（keep-alive）协议来维持 NAT 的绑定。和 RFC3489 最大的不同点在于，STUN 本身不再是一个 完整的 NAT 传输解决方案，而是在 NAT 传输环境中作为一个辅助的解决方法，同时也增加了 TCP 的支持。RFC5389 废弃了 RFC3489，因此后者通常称为 classic STUN，但依旧是后向兼容的。STUN 是一种 Client/Server 的协议，也是一种 Request/Response 的协议，默认端口号是 3478。 STUN 完整的定义参考：RFC5398 3.2 TURN（Traversal Using Relay NAT）Traversal Using Relay NAT 即使用中继穿透 NAT，STUN 的中继扩展。简单的说，TURN 与 STUN 的共同点都是通过修改应用层中的私网地址达到 NAT 穿透的效果，异同点是 TURN 是通过两方通讯的“中间人”方式实现穿透。 TURN 完整的定义参考：RFC5766 3.3 ICE（Interactive Connectivity Establishment）Interactive Connectivity Establishment 即互动式连接建立，由 IETF 的 MMUSIC 工作组开发出来的，它所提供的是一种框架，使各种 NAT 穿透技术可以实现统一。ICE 跟 STUN 和 TURN 不一样，ICE 不是一种协议，而是一个框架（Framework），它整合了 STUN 和 TURN。 ICE 完整的定义参考：RFC5245 参考：P2P 技术详解(一)：NAT 详解——详细原理、P2P 简介 &gt; P2P 技术详解(二)：P2P 中的 NAT 穿越(打洞)方案详解 &gt; P2P 技术详解(三)：P2P 技术之 STUN、TURN、ICE 详解","link":"/post/2441416675.html"},{"title":"SDP格式解析","text":"会话描述协议（Session Description Protocol 或简写 SDP）描述的是流媒体的初始化参数。此协议由 IETF 发表为 RFC 2327。 SDP 完全是一种会话描述格式，它不属于传输协议。 SDP 用于描述多媒体通信会话，包括会话建立、会话请求和参数协商。SDP 不用于传输媒体数据，只能用于两个通信终端的参数协商，包括媒体类型、格式以及所有其他和会话相关的属性。SDP 以字符串的形式描述上述初始化参数。 一、SDP 组成SDP 是由多行文本组成的一个纯文本协议，如果将SDP从语义上分解成不同组件来描述一个多媒体会话信息，那么SDP由以下部分组成： 会话信息 网络信息 媒体信息 安全信息 服务质量和分组信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 +---------------------+ | v= | +---------------------+ +---------------------+ +---------------------+ ==== | Session Metadata | ===== | o= | | +---------------------+ +---------------------- | +---------------------+ | | t= | | +---------------------+ | | | +---------------------+ | | c= | | +---------------------+ | +---------------------+ ==== | Network Description | ===== | +---------------------+ | +---------------------+ | | a=candidate | | +---------------------+ | | | +---------------------+ | | m= | | +---------------------+ | +---------------------+ +---------------------+ ==== | Stream Description | ===== | a=rtpmap | | +---------------------+ +---------------------- | +---------------------+ | | a=fmtp | | +---------------------+ | +---------------------+ | | a=sendrecv.. | | +---------------------++---------------+| SEMANTIC || COMPONENTS OF || SDP |+---------------+ | +---------------------+ | | a=crypto | | +---------------------+ | +---------------------+ +---------------------+ ==== |Security Descriptions| =====| a=ice-frag | | +---------------------+ +---------------------- | +---------------------+ | | a=ice-pwd | | +---------------------+ | +---------------------+ | | a=fingerprint | | +---------------------+ | | | | +---------------------+ | | a=rtcp-fb | | +---------------------+ | +---------------------+ +---------------------+ ==== | Qos,Grouping | | | | Descriptions | =====| a=group | +---------------------+ +---------------------- +---------------------+ | a=rtcpmux | +---------------------+ 二、SDP 格式SDP 由多行组成，每行的的格式如下： 1&lt;type&gt;=&lt;value&gt; &lt;type&gt;: 区分大小写，代表特定的属性，例如v代表 SDP 版本。 &lt;value&gt;：UTF8 编码的文本，具体格式与类型有关。 =两边不允许存在空格。 =*表示该项是可选的。 下面是 WebRTC（branch_76）的一个真实 SDP 样本: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144// -------------------------------- 【Session Metadata部分】 --------------------------------// sdp版本号v=0// o=&lt;username&gt; &lt;sess-id&gt; &lt;sess-version&gt; &lt;nettype&gt; &lt;addrtype&gt; &lt;unicast-address&gt;// username如何没有使用-代替，3967017503571418851是整个会话的编号，2代表会话版本，如果在会话过程中有改变编码之类的操作，重新生成sdp时,sess-id不变，sess-version加1o=- 3967017503571418851 2 IN IP4 127.0.0.1//会话名s=-// 会话的起始时间和结束时间，0代表没有限制t=0 0// 表示需要共用一个传输通道传输的媒体，通过ssrc进行区分不同的流。如果没有这一行，音视频数据就会分别用单独udp端口来发送.a=group:BUNDLE audio video// WMS是WebRTC Media Stream简称;// 这一行定义了本客户端支持同时传输多个流，一个流可以包括多个track.// 一般定义了这个，后面a=ssrc这一行就会有msid,mslabel等属性.a=msid-semantic: WMS stream_id// -------------------------------- 【Stream Description部分】 --------------------------------// ------------ audio部分 -------------// m意味着它是一个媒体行.// m=audio说明本会话包含音频，9代表音频使用端口9来传输，但是在webrtc中现在一般不使用，如果设置为0，代表不传输音频,// UDP/TLS/RTP/SAVPF是表示用户支持来传输音频的协议，udp,tls,rtp代表使用udp来传输rtp包，并使用tls加密// SAVPF代表使用srtcp的反馈机制来控制通信过程// 后面的111 103 104 9 102 0 8 106 105 13 110 112 113 126表示本会话音频支持的编码，后面几行会有详细补充说明.m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 102 0 8 106 105 13 110 112 113 126// 表示你要用来接收或者发送音频使用的IP地址.// webrtc使用ice传输，不使用这个地址c=IN IP4 0.0.0.0// 用来传输rtcp的地址和端口，webrtc中不使用a=rtcp:9 IN IP4 0.0.0.0// 下面2行是ice协商过程中的安全验证信息a=ice-ufrag:kSq0a=ice-pwd:pWLGrCTwFNq6rm249ZEasHPY// 通知对端支持trickle，即sdp里面描述媒体信息和ice候选项的信息可以分开传输a=ice-options:trickle// dtls协商过程中需要的认证信息a=fingerprint:sha-256 A0:D6:B2:63:1B:69:0E:91:01:C3:88:A9:92:6F:E7:EF:5B:36:52:66:08:DF:94:A0:FE:0C:C9:06:BF:2C:38:A2// 代表本客户端在dtls协商过程中，可以做客户端也可以做服务端, 参考rfc4145 rfc4572a=setup:actpass// 前面BUNDLE行中用到的媒体标识a=mid:audio// 指出要在rtp头部中加入音量信息，参考 rfc6464a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level// 指出是双向通信，另外几种类型是recvonly,sendonly,inactivea=sendrecv// 指出rtp,rtcp包使用同一个端口来传输a=rtcp-mux// 下面十几行都是对m=audio这一行的媒体编码补充说明，指出了编码采用的编号，采样率，声道等a=rtpmap:111 opus/48000/2a=rtcp-fb:111 transport-cc// 下面一行对opus编码可选的补充说明,minptime代表最小打包时长是10ms，useinbandfec=1代表使用opus编码内置fec特性a=fmtp:111 minptime=10;useinbandfec=1a=rtpmap:103 ISAC/16000a=rtpmap:104 ISAC/32000a=rtpmap:9 G722/8000a=rtpmap:102 ILBC/8000a=rtpmap:0 PCMU/8000a=rtpmap:8 PCMA/8000a=rtpmap:106 CN/32000a=rtpmap:105 CN/16000a=rtpmap:13 CN/8000a=rtpmap:110 telephone-event/48000a=rtpmap:112 telephone-event/32000a=rtpmap:113 telephone-event/16000a=rtpmap:126 telephone-event/8000// cname用来标识一个数据源，ssrc当发生冲突时可能会发生变化，但是cname不会发生变化，也会出现在rtcp包中SDEC中，用于音视频同步a=ssrc:2603526440 cname:AyMDWB+q6ApWdpfUa=ssrc:2603526440 msid:stream_id audio_labela=ssrc:2603526440 mslabel:stream_ida=ssrc:2603526440 label:audio_label// ------------ video部分 -------------m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 127c=IN IP4 0.0.0.0a=rtcp:9 IN IP4 0.0.0.0a=ice-ufrag:kSq0a=ice-pwd:pWLGrCTwFNq6rm249ZEasHPYa=ice-options:tricklea=fingerprint:sha-256 A0:D6:B2:63:1B:69:0E:91:01:C3:88:A9:92:6F:E7:EF:5B:36:52:66:08:DF:94:A0:FE:0C:C9:06:BF:2C:38:A2a=setup:actpassa=mid:videoa=extmap:2 urn:ietf:params:rtp-hdrext:toffseta=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-timea=extmap:4 urn:3gpp:video-orientationa=extmap:5 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01a=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/playout-delaya=extmap:7 http://www.webrtc.org/experiments/rtp-hdrext/video-content-typea=extmap:8 http://www.webrtc.org/experiments/rtp-hdrext/video-timinga=sendrecva=rtcp-muxa=rtcp-rsizea=rtpmap:96 VP8/90000a=rtcp-fb:96 goog-remba=rtcp-fb:96 transport-cca=rtcp-fb:96 ccm fira=rtcp-fb:96 nacka=rtcp-fb:96 nack plia=rtpmap:97 rtx/90000a=fmtp:97 apt=96a=rtpmap:98 VP9/90000a=rtcp-fb:98 goog-remba=rtcp-fb:98 transport-cca=rtcp-fb:98 ccm fira=rtcp-fb:98 nacka=rtcp-fb:98 nack plia=rtpmap:99 rtx/90000a=fmtp:99 apt=98a=rtpmap:100 red/90000a=rtpmap:101 rtx/90000a=fmtp:101 apt=100a=rtpmap:127 ulpfec/90000a=ssrc-group:FID 1563406656 4103641903a=ssrc:1563406656 cname:AyMDWB+q6ApWdpfUa=ssrc:1563406656 msid:stream_id video_labela=ssrc:1563406656 mslabel:stream_ida=ssrc:1563406656 label:video_labela=ssrc:4103641903 cname:AyMDWB+q6ApWdpfUa=ssrc:4103641903 msid:stream_id video_labela=ssrc:4103641903 mslabel:stream_ida=ssrc:4103641903 label:video_label 2.1 协议版本第一行v=0定义了 sdp 协议的版本号。 2.2 会话发起者第二行 1o=- 3967017503571418851 2 IN IP4 127.0.0.1 定义了会话发起者的信息，格式如下： 1o=&lt;username&gt; &lt;sess-id&gt; &lt;sess-version&gt; &lt;nettype&gt; &lt;addrtype&gt; &lt;unicast-address&gt; username：发起者的用户名，不允许存在空格，如果应用不支持用户名，则为-。 sess-id：会话 id，由应用自行定义，SDP 规范建议使用 NTP(Network Time Protocol)时间戳。 sess-version：会话版本，用途由应用自行定义，只要会话数据发生变化时（比如编码）sess-version 随着递增即可。SDP 规范建议使用 NTP 时间戳。 nettype：网络类型，比如 IN 表示 Internet。 addrtype：地址类型，比如 IP4、IV6 unicast-address：域名，或者 IP 地址。 2.3 会话名1s=&lt;session name&gt; 必选，有且仅有一个s=字段，且不能为空。可以赋一个空格（即s= ），或者-。 2.4 连接信息1c=&lt;nettype&gt; &lt;addrtype&gt; &lt;connection-address&gt; 每个 SDP 至少需要包含一个会话级别的c=字段，或者在每个媒体描述后面各包含一个c=字段，（媒体描述后的c=会覆盖会话级别的c=）。例如，在上面的示例 SDP 样本中，就不存在会话级别的连接信息。 nettype：网络类型，比如 IN，表示 Internet。 addrtype：地址类型，比如 IP4、IP6。 connection-address：如果是广播，则为广播地址组；如果是单播，则为单播地址； 2.4.1 何为会话级别和媒体级别会话级部分以v =行开始，到第一个媒体级部分结束。每个媒体级部分以m =行开始，持续到下一个媒体级（即下一个m=）。 2.5 媒体描述信息SDP 可以同时包含多个媒体描述信息（如音频、视频等），格式如下： 1m=&lt;media&gt; &lt;port&gt; &lt;proto&gt; &lt;fmt&gt; ... 示例： 12m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 102 0 8 106 105 13 110 112 113 126c=IN IP4 0.0.0.0 media：媒体类型，包括 video、audio、text、application、message 等。 port：传输媒体流使用的端口，具体含义取决于使用的网络类型（在c=中声明）和使用的传输协议(proto)。 proto：传输协议，具体含义取决于c=中定义的地址类型，比如c=IP4，那么这里的传输协议运行在 IP4 之上。 fmt：媒体格式的描述，可能有多个。根据proto的不同，fmt的含义也不同。比如proto为 RTP/SAVP 时，fmt 表示 RTP payload 的类型。如果有多个，表示在这次会话中，多种 payload 类型可能会用到，且第一个为默认的 payload 类型。数字0~95是静态负载类型；96~127是动态负载类型，需要在后面使用附近属性a = rtpmap:指定具体的格式参数。具体的每个数字代表的负载类型和含义可以参考：Real-Time Transport Protocol (RTP) Parameters如上例中的 audio 类型的111表示使用 opus 编码。 2.6 附加属性附加属性用于扩展 SDP，有 2 种作用范围：会话级别、媒体级别： 媒体级别：媒体描述（m=）后面可以跟任意数量的 a= 字段，对媒体描述进行扩展。 会话级别：在第一个媒体字段(media field)前，添加的 a= 字段是会话级别的。 有下面 2 种格式： 12a=&lt;attribute&gt;a=&lt;attribute&gt;:&lt;value&gt; 2.7 时间用于声明会话的开始、结束时间，格式如下： 1t=&lt;start-time&gt; &lt;stop-time&gt; 如果&lt;stop-time&gt;是 0，表示会话没有结束的边界，但是需要在&lt;start-time&gt;之后会话才是活跃(active)的；如果&lt;start-time&gt;是 0，表示会话是永久的。 SDP for the WebRTC &gt; WebRTC：会话描述协议 SDP &gt; WebRTC 中的 SDP 协议","link":"/post/2172509399.html"},{"title":"WebRTC在直播领域应用的可行性分析","text":"一、目前流行的直播技术架构目前主流的直播方案一般采用RTMP架构，首先客户端采集音视频流（如obs studio客户端），然后通过 RTMP 协议将流推到流媒体服务器，最后流媒体服务器将流处理后分发给各个直播客户端。 优点：良好的 CDN 支持，目前主流的 CDN 厂商都有比较成熟的解决方案，另外也有可用的商用 SDK 方便集成，例如声网等，只要集成对应平台的 SDK 即可。由于有 CDN 的支持，相较于端对端的 webrtc 方式，其并发度高，适合多人直播场景。 缺点： 由于 RTMP 协议基于是 TCP 的，相对于基于 UDP 协议的 WebRTC 方式延时较大，所以对于某些低延时场景体验较差，这也是为什么现在直播应用中只能通过弹幕的方式与主播互动，不能实时连麦互动了，因为延迟太大，体验太差。 浏览器没有集成对 RTMP 协议的支持，所以不支持浏览器推流等，需要主播端安装特定的客户端软件。 二、基于端对端的 WebRTC 直播方案严格的讲，基于端对端的 WebRTC 直播方式不属于 WebRTC 常规应用场景，WebRTC 设计之初是用来进行多人实时通信的，所以 WebRTC 代码中集成了很多语音方面的算法，如人声检测等。若将 WebRTC 应用在直播方案中，则主要工作流程如下图所示： 优点： 单纯使用 Javascript 在 Web 端即可实现推流，这对于开发者来说，简化了音视频通信的开发工作，降低了门槛低，不必熟悉流媒体等技术细节；对于主播来说，在浏览器中打开网页即可进行直播，方便快捷。 如果点对点连接成功就可以不通过服务器中转，可以节省服务器带宽费用。 相对于基于 TCP 的 RTMP 推拉流方式，基于 UDP 的 webrtc 方式延时更低。 缺点： PC 端浏览器的性能有局限，如果是 1v1 方式的直播连麦，浏览器尚能支撑；如果同时进行多人直播连麦，则浏览器需要同时给多人推流，这对于浏览器来说恐难支撑。 虽然目前浏览器提供的 WebRTC Javascript API 越来越多，但一旦现有 API 无法满足需求，则单纯的依靠 JavaScript 恐难为力（可以修改 WebRTC C++源码，另外开发浏览器客户端提供 Javascript 接口，但这就失去了主流浏览器支持 WebRTC 的天然优势）。 音视频的传输质量难以保障，尤其在跨地区、跨运营商的情况下，即便可以端对端连接成功，但质量也难保障。 由于端对端连接没有经过服务器，所以无法在服务器端对直播流进行审录制回放等。 三、基于服务器转发的 WebRTC 直播方案基于端对端的 WebRTC 直播方式受限于浏览器性能、连接人数等限制，很难适用于直播场景。为了解决这些问题，从而引入媒体服务器，主播客户端仅传输一路音视频流到媒体服务器，其余客户端通过与媒体服务器建立连接获取音视频流。 目前适用于 WebRTC 的媒体服务器有 SFU 和 MUC 两种类型，两种的差别可以参考： WebRTC的三种架构 虽然两种类型的 WebRTC 服务器架构都有开源的解决方案，也存在一些商用的解决方案，但终究没有基于RTMP+CDN方式的直播方案成熟，这也就意味着一旦采用此方案需要投入更大的研发力度。 基于服务器转发的 WebRTC 直播方案虽然看起来和当前流行的RTMP+CDN方式类似，都经过了服务器的转发，但 WebRTC 基于 UDP 方式延迟可以做到更低，且 WebRTC 内置了很多音视频方面的算法，如 AEC, VAD, VP9 等，并且在网络传输方面做了很多优化工作。","link":"/post/2016855525.html"},{"title":"WebRTC添加选择音频输入输出设备功能","text":"我们先来看看 WebRTC 中提供音频设备输入输出功能的类结构： 从上图中我们看到： AudioDeviceModule接口类是音频设备模型的基类，该接口类及其子类并不提供任何针对音频的实际操作，实际操作都是由AudioDeviceGeneric接口类的子类来提供。 AudioDeviceGeneric接口类是音频设备实际操作（如录音、播放、声音控制等）的基类，然后根据平台不同由不同的类来实现具体操作，如 windows 平台由AudioDeviceWindowsCore来负责实现。 通过代码追踪，我们可以发现 WebRTC 默认使用的是计算机上的系统默认音频输入输出设备，以及默认的视频采集设备，这些我们通过adm_helpers.cc::Init函数来验证（笔者这里使用的是m77分支）： 123456789if (adm-&gt;SetPlayoutDevice(AUDIO_DEVICE_ID) != 0) { RTC_LOG(LS_ERROR) &lt;&lt; \"Unable to set playout device.\"; return;}if (adm-&gt;SetRecordingDevice(AUDIO_DEVICE_ID) != 0) { RTC_LOG(LS_ERROR) &lt;&lt; \"Unable to set recording device.\"; return;} 所以即便我们调用了SetPlayoutDevice和SetRecordingDevice也无济于事，因为在此处仍然会被覆盖为使用默认设备。因此我们只需要针对此处进行修改即可，如： 12345678910111213141516171819202122uint16_t playout_index = 0;// 先获取设备index，如果能够获取到，表示外部已经设备设备index，放弃使用默认设备// AudioDeviceModule没有提供Get接口，需要自己添加//if (adm-&gt;GetPlayoutDevice(&amp;playout_index) == 0) { RTC_LOG(LS_INFO) &lt;&lt; \"Playout device index: \" &lt;&lt; playout_index;} else { if (adm-&gt;SetPlayoutDevice(AUDIO_DEVICE_ID) != 0) { RTC_LOG(LS_ERROR) &lt;&lt; \"Unable to set playout device.\"; return; }}uint16_t recording_index = 0;if (adm-&gt;GetRecordingDevice(&amp;recording_index) == 0) { RTC_LOG(LS_INFO) &lt;&lt; \"Recording device index: \" &lt;&lt; recording_index;} else { if (adm-&gt;SetRecordingDevice(AUDIO_DEVICE_ID) != 0) { RTC_LOG(LS_ERROR) &lt;&lt; \"Unable to set recording device.\"; return; }} 细心的读者可能发现，AudioDeviceModule接口类只定义了 Playout/Recoding 设备的Set接口，但没有提供Get接口，因为 WebRTC 默认使用的是系统设备，所以外界不需要知道具体设备 index，故没有提供（笔者使用的是 webrtc m77分支，也许 webrtc 的后续版本会加入该接口）。我们自己也可以很容易的在 AudioDeviceModule 中加入Get接口。 上面的一切修改完毕之后，我们只需要定义一个 adm，作为参数传入到webrtc::CreatePeerConnectionFactory函数即可： 12345678910111213141516171819m_adm = webrtc::AudioDeviceModule::Create( webrtc::AudioDeviceModule::kPlatformDefaultAudio, webrtc::CreateDefaultTaskQueueFactory().get());int32_t ret = m_adm-&gt;Init();Q_ASSERT(ret == 0);if (m_connParameter.audioInputDeviceIndex == -1) { m_adm-&gt;SetEnableRecording(false);} else { ret = m_adm-&gt;SetRecordingDevice(m_connParameter.audioInputDeviceIndex); Q_ASSERT(ret == 0);}if (m_connParameter.audioOutputDeviceIndex == -1) { m_adm-&gt;SetEnablePlayout(false);} else { ret = m_adm-&gt;SetPlayoutDevice(m_connParameter.audioOutputDeviceIndex); Q_ASSERT(ret == 0);}","link":"/post/2143630083.html"},{"title":"WebRTC的三种架构","text":"WebRTC 是基于 P2P 的实时通信技术，（如果 P2P 打洞失败，则会使用 TURN 服务器进行数据转发），在有 2 台客户端参与的情况下，网络拓扑结构如图： 一、Mesh 架构在只有 2 个客户端参与情况下，我们可以使用上图的这种拓扑结构。但假如同时有 3 个客户端参与（如多人视频会议），如果还是按照上面的方式，拓扑结构就会变成： 从上图中我们可以看到，在 3 人参与的实时通信中，每个客户端要维持 4 个连接（2 个上行，2 个下行）；同理，如果有 N 个客户端参与，每个客户端就要维持N-1上行，N-1个下行，这样会极大的占用客户端的上行带宽和下行带宽； 这种每个端之前完全使用 P2P 方式架构称之为 Mesh 架构。 二、SFU (Selective Forwarding Unit)架构SFU 架构最核心的特点是把自己 “伪装” 成了一个 WebRTC 的客户端，WebRTC 的其他客户端其实并不知道自己通过 P2P 连接过去的是一台真实的客户端还是一台服务器，我们通常把这种连接称之为 P2S，即：Peer to Server。除了 “伪装” 成一个 WebRTC 的客户端外，SFU 服务器还有一个最重要的能力就是具备one-to-many的能力，即可以将一个客户端的数据转发到其他多个客户端。 这种网络拓扑结构中，无论多少人同时进行视频通话，每个 WebRTC 的客户端只需要连接一个 SFU 服务器，上行一路数据即可，可以极大的减少多人视频通话场景下 Mesh 模型给客户端带来的上行带宽压力。 SFU 服务器跟 TURN 服务器最大的不同是，TURN 服务器仅仅是为 WebRTC 客户端提供的一种辅助的数据转发通道，在 P2P 不通的时候进行透明的数据转发。而 SFU 是 “懂业务” 的， 它跟 WebRTC 客户端是平等的关系，甚至 “接管了” WebRTC 客户端的数据转发的申请和控制。 三、MCU (MultiPoint Control Unit)架构从上述 SFU 的定义可以看到，SFU 这种网络拓扑模型，通过由 SFU Server 来实现 one-to-many ，减轻了多人视频通话场景下每个客户端的上行带宽压力，但是下行依然是多路流，随着通话人数的增大，下行带宽的压力依然会成比例的增大，那能否让下行也只剩一路流呢？—— 可以，通过在服务器端合流后再下发即可解决，如下图所示： 目前，随着 5G 技术的推广，可以预见带宽越来越不是问题，所以 SFU 在未来，可能会更有优势。常见的开源 SFU 服务器有：Licode，Janus，Jitsi，mediasoup，Medooze 等等。 文章参考：WebRTC 开发实践：为什么你需要 SFU 服务器 &gt; webrtc 笔记(3): 多人视频通讯常用架构 Mesh/MCU/SFU","link":"/post/2114040426.html"},{"title":"Windows平台编译WebRTC源码","text":"写作本文时使用的 webrtc 版本为：branch heads/67 一、 准备工作1.0 请确保可以访问国外网站1.1 系统语言切换到英文系统 Windows 7/10 都可以，在“控制面板”–&gt;”区域和语言”–&gt;”管理”–&gt;”更改系统区域设置”中切换到“英语（美国）”，然后重启系统。 1.2 卸载部分软件无 1.3 安装 VS2017Visual Studio 2017 现在只提供在线安装包，为了加快在线安装的速度，可以只选择如下几个安装项： Desktop development with C++ MFC and ATL support 1.4 安装 Windows 10 SDK虽然官方指南上面写的是支持 10.0.15063 及以后的版本，但编译选项中默认指定的是 10.0.15063 版本，所以建议安装 10.0.15063 版本。如果要使用其他版本的 SDK，可以在三、 生成vs解决方案 这一步中指定--winsdk=&lt;sdk_version&gt;参数。 10.0.15063 下载地址： 1https://download.microsoft.com/download/0/1/1/01111605-8CDF-4A88-BB06-C20E97E8B3D5/iso_windowssdk/15063.468.170612-1856.rs2_release_svc_sec_WindowsSDK.iso 1.5 安装 DirectX SDk下载地址： 1http://download.microsoft.com/download/A/E/7/AE743F1F-632B-4809-87A9-AA1BB3458E31/DXSDK_Jun10.exe 安装 DirectX SDK June 2010，安装完成后可能会提示“s1023”这样的错误，这是因为与系统已有的 visual c++ redistributable packages 版本冲突，可以忽略不管。 二、 源码获取2.1 配置 depot_toolsdepot_tools 是 webrtc 或 chromium 使用的源码管理工具，从此处下载： 1https://storage.googleapis.com/chrome-infra/depot_tools.zip 解压到 D:\\webrtc\\depot_tools 中，添加该目录到到系统环境变量 PATH。 因为 webrtc 或 chromium 使用的编译系统会自动下载与之匹配的 Python 和 Git，为了防止编译系统错误使用原有的版本，需要将D:\\webrtc\\depot_tools路径放到 PATH 的最前面，至少也要放到 Python 和 Git 的前面。 2.2 环境初始化先设置如下环境变量： 12DEPOT_TOOLS_WIN_TOOLCHAIN = 0GYP_GENERATORS = ninja,msvs-ninja 然后以管理员权限运行系统 cmd 命令行（不要使用其他命令行工具，如 cmder），依次执行下面的命令： 123d:cd D:\\webrtc # 用来进入webrtc目录，目录名不一样，命令也不一样gclient # 需要使用网络代理，耗时较长 2.3 下载源码和依赖项新建 webrtc-checkout 目录，下载源码到该目录，命令如下： 12345mkdir webrtc-checkout # 也可以手动新建cd webrtc-checkoutfetch --nohooks webrtc # 获取源码gclient sync # 更新源码gclient runhooks # 获取DEPS文件中指定的依赖项 三、 生成 vs 解决方案进入 webrtc-checkout\\src 目录（2.3 步骤中下载的源码会自动存储到该目录）,执行： 1gn gen --ide=vs out/Debug 或者加入详细的配置参数： 1gn gen out/x64/Debug --ide=vs --args=\"is_debug=true target_cpu=\\\"x64\\\"\" 执行成功之后，在 out/Debug 目录中会生成 all.sln 解决方案文件。 另外，可以使用gn gen --help查看帮助，节选如下： 12345678910111213141516171819202122232425262728293031323334353637383940IDE options GN optionally generates files for IDE. Possibilities for &lt;ide options&gt; --ide=&lt;ide_name&gt; Generate files for an IDE. Currently supported values: \"eclipse\" - Eclipse CDT settings file. \"vs\" - Visual Studio project/solution files. (default Visual Studio version: 2017) \"vs2013\" - Visual Studio 2013 project/solution files. \"vs2015\" - Visual Studio 2015 project/solution files. \"vs2017\" - Visual Studio 2017 project/solution files. \"xcode\" - Xcode workspace/solution files. \"qtcreator\" - QtCreator project files. \"json\" - JSON file containing target information --filters=&lt;path_prefixes&gt; Semicolon-separated list of label patterns used to limit the set of generated projects (see \"gn help label_pattern\"). Only matching targets and their dependencies will be included in the solution. Only used for Visual Studio, Xcode and JSON.Visual Studio Flags --sln=&lt;file_name&gt; Override default sln file name (\"all\"). Solution file is written to the root build directory. --no-deps Don't include targets dependencies to the solution. Changes the way how --filters option works. Only directly matching targets are included. --winsdk=&lt;sdk_version&gt; Use the specified Windows 10 SDK version to generate project files. As an example, \"10.0.15063.0\" can be specified to use Creators Update SDK instead of the default one. --ninja-extra-args=&lt;string&gt; This string is passed without any quoting to the ninja invocation command-line. Can be used to configure ninja flags, like \"-j\". 在编译解决方案中的某些工程（如freetype_source, harfbuzz_source）时，可能会遇到诸如下面的错误提示： 1error C2220: 警告被视为错误 - 没有生成“object”文件 这时我们需要调低警告等级，编译对应的 ninja 文件，将其中的/WX改成/W3即可。 参考：https://chromium.googlesource.com/chromium/src/+/master/docs/windows_build_instructions.md","link":"/post/2910781705.html"},{"title":"初识WebRTC","text":"WebRTC （Web Real-Time Communications） 是一项实时通讯技术，它允许网络应用或者站点在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。 它并不是单一的协议，包含了媒体、加密、传输层等在内的多个协议标准以及一套基于 JavaScript 的 API。通过简单易用的 JavaScript API ，在不安装任何插件的情况下，让浏览器拥有了 P2P音视频和数据分享的能力。同时WebRTC 并不是一个孤立的协议，它拥有灵活的信令，可以便捷的对接现有的SIP 和电话网络的系统。 不同技术领域的人都可以从WebRTC中获取到需要的东西。 一. 支持的浏览器和平台目前基本上所有的浏览器都已经支持WebRTC 二. WebRTC 内部结构 架构图颜色标识说明： 紫色部分是Web开发者API层 蓝色实线部分是面向浏览器厂商的API层 蓝色虚线部分浏览器厂商可以自定义实现 WebRTC有三个模块： Voice Engine（音频引擎） Voice Engine包含iSAC/iLBC Codec（音频编解码器，前者是针对宽带和超宽带，后者是针对窄带） NetEQ for voice（处理网络抖动和语音包丢失） Echo Canceler（回声消除器）/ Noise Reduction（噪声抑制） Video Engine（视频引擎） VP8 Codec（视频图像编解码器） Video jitter buffer（视频抖动缓冲器，处理视频抖动和视频信息包丢失） Image enhancements（图像质量增强） Transport SRTP（安全的实时传输协议，用以音视频流传输） Multiplexing（多路复用） P2P，STUN+TURN+ICE（用于NAT网络和防火墙穿越的） 除此之外，安全传输可能还会用到DTLS（数据报安全传输），用于加密传输和密钥协商 整个WebRTC通信是基于UDP的 三. WebRTC 的核心组件 音视频引擎：OPUS、VP8 / VP9、H264 传输层协议：底层传输协议为 UDP 媒体协议：SRTP / SRTCP 数据协议：DTLS / SCTP P2P 内网穿透：STUN / TURN / ICE / Trickle ICE 信令与 SDP 协商：HTTP / WebSocket / SIP、 Offer / Answer 模型 四. WebRTC 音频和视频引擎 最底层是硬件设备，上面是音频捕获模块和视频捕获模块 中间部分为音视频引擎。音频引擎负责音频采集和传输，具有降噪、回声消除等功能。视频引擎负责网络抖动优化，互联网传输编解码优化 在音视频引擎之上是 一套 C++ API，在 C++ 的 API 之上是提供给浏览器的Javascript API. 五. WebRTC 协议栈 WebRTC 核心的协议都是在右侧基于 UDP 基础上搭建起来的。 其中，ICE、STUN、TURN 用于内网穿透。 DTLS 用于对传输内容进行加密，可以看做是 UDP 版的 TLS。由于 WebRTC 对安全比较重视，所以这一层是必须的。所有WebRTC组件都必须加密，并且其JavaScript API只能用于安全源（HTTPS或本地主机）。信令机制并不是由WebRTC标准定义的，所以您必须确保使用安全协议。 SRTP 与 SRTCP 是对媒体数据的封装与传输控制协议 SCTP 是流控制传输协议，提供类似 TCP 的特性，SCTP 可以基于 UDP 上构建，在 WebRTC 里是在 DTLS 协议之上。 RTCPeerConnection 用来建立和维护端到端连接，并提供高效的音视频流传输。 RTCDataChannel 用来支持端到端的任意二进制数据传输。 WebRTC 协议栈解释 ICE，STUN，TURN：用于NAT穿透，参考 WebRTC的三种架构 SDP：会话描述协议（RFC 4566） DTLS：数据报传输层安全性（RFC 6347） SCTP：流控制传输协议（RFC 4960） SRTP：安全实时传输协议（RFC 3711）","link":"/post/3298681169.html"},{"title":"如何搭建WebRTC的TURN服务器","text":"本文讲解如何在 Ubuntu 系统上采用coturn搭建 p2p 打洞服务器，coturn 是一个开源的 stun 和 turn 服务器实现。 1. 安装依赖项123sudo apt-get install opensslsudo apt-get install libsslsudo apt-get install libevent-dev 2. 下载 coturn 源码编译安装12git clone https://github.com/coturn/coturn.git./configure &amp;&amp; make &amp;&amp; make install 3. 编辑配置安装完之后，编辑\\usr\\local\\etc\\turnserver.conf配置文件： 12345listening-device=eth0listening-port=3478external-ip=47.93.42.10 #公网IPuser=jeff:123456 #用户名密码realm=rtctest 4. 启动 coturn1turnserver -a -f -v -r rtctest 5. 客户端连接 coturn 服务器webrtc::PeerConnectionFactoryInterface::CreatePeerConnection函数传入的RTCConfiguration 参数如下： 123456789webrtc::PeerConnectionInterface::RTCConfiguration config;config.sdp_semantics = webrtc::SdpSemantics::kUnifiedPlan;config.enable_dtls_srtp = true;webrtc::PeerConnectionInterface::IceServer server;server.urls.push_back(\"stun://47.93.42.10:3478\");server.urls.push_back(\"turn://47.93.42.10:3478\");server.username = \"jeff\";server.password = \"123456\";config.servers.push_back(server);","link":"/post/2256138363.html"},{"title":"🔥Power By Me","text":"本篇汇总了在本站中提及的、由我开发的小工具和开源项目。 工具所有工具从实用性出发，力求每个功能能够简单易用，不单纯地做功能的堆砌者，亦不做广告的传播者。 一键启动神器之1key.run TinyTu-跨平台图片压缩软件 Windows窗口调试利器-WinSpyPlus 开源库 高速文件下载器的实现 基于Qt的无边框窗体实现","link":"/post/3416050985.html"},{"title":"TinyTu-跨平台图片压缩软件","text":"我平时压缩图片通常会使用类似tinify这样的在线图片压缩网站，这些网站有很多，但使用起来总是感觉不太舒爽，似乎差了点什么，仔细想想它们或多或少有这些缺点： 有的网站需要收费或者半收费。 支持图片格式不全，例如有的网站仅PNG格式，而有的网站又不支持jpg、gif等。 通常还会限制上传图片的数量和大小，毕竟上传和下载都会消耗服务器的网络带宽，网站为了节省成本做出此限制。 图片的压缩速度较慢，毕竟压缩速度越快对服务器的硬件要求越高，成本也会越高。 1. TinyTu这些毛病我已经忍了许久，今天我不想再忍了，经过我一顿折腾（不得不说，想做得好用还得费点心思），一款名为TinyTu的图片压缩软件应运而生。因为TinyTu是本地客户端软件，所以不会限制图片的数量、大小，而且还可以使用本机GPU进行硬件加速，提升图片压缩速度。 TinyTu起来非常方便，不需要额外配置，只需要拖入图片，然后点击“立即压缩”即可。 目前支持的图片格式有： PNG JPEG Gif TTF 不断扩展中… 2. 下载 Github（更新及时） https://github.com/winsoft666/TinyTu-Setup/releases 奶牛快传（更新可能延后） https://cowtransfer.com/s/7a17d7cc96e242 3. 压缩模式TinyTu目前支持图像清晰度优先、普通压缩、极限压缩三个挡位的压缩模式。 这样极大简化了用户设置，用户只需选择某个压缩模式，TinyTu会自动在文件大小和图片质量间进行权衡，达到最理想的压缩效果。 默认值为“普通压缩”，该挡位已可以媲美很多在线网站的压缩效果。 3.1 高级选项如果预设的三种压缩模式无法满足您的需求，或者您想自定义压缩参数，可以通过单击文件列表中的“高级选项”按钮打开选项界面进行配置。 该功能需要输入序列号激活后才能使用。 4. 输出策略TinyTu目前支持三种保存压缩后新文件的方式： 直接覆盖源文件。 这种方式会直接使用压缩后的文件覆盖源文件（即压缩前的文件）。 输出到源目录（默认） 该方式会将压缩后的文件输出到和源文件相同的文件夹，但会在新文件名后添加“TinyTu”尾缀，如test.png压缩后的图片为test_TinyTu.png。 输出到其他目录。 我们也可以选择其他的文件夹作为压缩后文件的输出目录。 5. 跳过已完成文件该选项默认开启。 有这样一种应用场景，我们向列表中添加了5个文件并已压缩完成，此时需要再添加新的文件继续压缩，通过设置该选项TinyTu会跳过之前已经完成的文件，而不需要我们每次添加新文件前都要清空列表。 6. 工作线程数量默认4个线程，可以同时压缩4个文件。 7. 购买序列号购买序列号请添加作者微信：18007152215","link":"/post/2053741240.html"},{"title":"Windows窗口调试利器-WinSpyPlus","text":"在Windows平台进行客户端开发时，不可避免的会遇到需要调试窗口的情况，如查看窗口句柄、窗口位置/尺寸、监听窗口消息等。虽然微软随Visual Stuido一同发布了Microsoft Spy++工具，但该工具的功能更新缓慢，这么多年过去了基本没有什么变化，比如： 一直未提供单独的安装包。 强制以管理员权限启动，虽然以管理员权限启动可以避免很多问题（如无法监听管理员权限进程窗口的消息等），但这让用户失去了选择非管理员的权力。 不能通过标题或类名来查找窗口。 查找到的窗口不能自动定位到窗口树中。 不能过滤是否显示隐藏窗口、是否显示无标题窗口。 不能查看Message-Only窗口。 不能定时导出窗口树到文件中，以便做后续的对比分析。 默认启动的时32位进程，无法监听64位进程窗口的消息，监听失败时也未能提示用户。 未提供对窗口的快速操作指令，如显示/隐藏、最大化/最小化/还原、置顶/置底等。 基于Microsoft Spy++的以上缺陷或不足，我开发了一个款为WinSpyPlus的工具，该工具解决了上述所有问题，而且功能特性还在不断扩充中。 下载地址 Github（更新及时）: https://github.com/winsoft666/winspyplus-bin 奶牛快传（更新可能延后）： https://cowtransfer.com/s/aa5ab9c1ef2e46 软件截图","link":"/post/1533480858.html"},{"title":"一键启动神器之1key.run","text":"1key.run既是产品官网域名，亦是产品名称。 顾名思义，主打一键启动，可以一键启动本地应用、网页搜索，并内置了一些实用功能如日历、科学计算、截图等。 一、下载 Github（更新及时） https://github.com/winsoft666/1key.run-Setup/releases 奶牛快传（更新可能延后） https://cowtransfer.com/s/8bc2eca2a04440 二、产品特色产品特色归纳为三个字：轻、快、爽。 2.1 轻“轻”为轻量化。减少系统资源的占用，不采用臃肿的 Electron 或 CEF 等 Web 技术架构，所有功能都采用纯 C++ Native 开发。软件安装包仅有 15MB（事实上还可以更小），运行时仅占用 12MB 内存。 2.2 快“快”为快速运行、快速上手。 1. 输入本地应用的简写（如拼音首字母）可以快速启动该应用。输入szqm: 默认会选中第一项，也可以使用Alt + 数字快捷键快速定位到其他项。 按Enter键运行当前项，还可以在右键菜单中可以选择“以管理员权限运行”。 2. 输入数学表达式，可以快速的计算该表达式的结果。 输入sin(90)+cos(45)+(2+3)*4： 科学计算器为 1key.run 的内置功能，在表达式计算结果项上按Enter键可以进入该功能详情页： 也可以输入kxjsq启动该功能，按Esc键可以退出当前功能。 3. 剪切板检测当 1key.run 被唤起时，会自动检查剪切板中的数据是否可以被 1key.run 的某个功能模块所使用。如复制sin(90)+cos(45)+(2+3)*4到剪切板，使用快捷键Alt+空格唤起 1key.run，会自动显示计算结果。 4. 快速上手想到则输入，所输即所得。不用记忆繁琐的快捷键，只需知道三个快捷键即可上手使用： Alt + 空格唤起 1key.run Enter为执行当前选择项 Esc为退出当前功能 2.3 爽完全免费，卸载无残留。 免费版本和 Pro 版本仅在更新通道上有区别，Pro 版本可以使用稳定的更新通道。在功能方面，免费版本和 Pro 版本没有任何区别。 三、功能介绍1key.run 将功能划分成了不同的功能模块，包含如下功能模块： 快速启动 网页搜索 科学计算器 颜色拾取 日历 截图 JSON 格式化 XML 格式化 可以在 1key.run 主搜索框输入功能模块支持的数据来唤起该功能，如1+2+3为科学计算器支持的数据，{\"a\":1}为 JSON 格式化支持的数据。 也可以直接输入功能模块的触发关键字（可以在“设置”中自定义）来启动该功能，如输入qs触发颜色拾取功能等。 3.1 快速启动快速启动可以用来启动本地应用，支持中文拼音简写、分词，如： 123有道翻译 -&gt; ydfyVisual Studio Code -&gt; vscWinHex -&gt; wh 当搜索结果不足时，会自动添加网页搜索引擎到列表的末尾。 可以在“设置”中自定义需要检索和监控的文件夹，1key.run 会自动检索该文件夹及子文件夹下的可执行项(如.exe、.bat 文件)，并添加到快速启动中。 当文件夹中有文件新增或删除时，1key.run 会自动监控到这些改变，添加到启动项或从中移除。 如果某个目录下文件或子文件夹太多，检索和监控会消耗比较多的系统资源，可以在排除该目录。 最后，我们也可以添加单个启动项。 3.2 网页搜索1key.run 内置了百度、谷歌、必应、百度百科、Microsoft Docs、Github 等主流搜索引擎，输入对的引擎名或简写，可以快速定位到该搜索引擎。 如输入baidu并回车，定位并选择百度搜索引擎： 输入需要搜索的内容，回车即可搜索。 可以在“设置”中管理搜索引擎： 3.3 科学计算器提供传统科学计算器所拥有的全部功能，并且使用起来更加方便。 3.4 颜色拾取实时提取鼠标位置的颜色值，实时显示 RGB 和十六进制颜色值。 与其他取色软件不同的是，1key.run 提供的颜色拾取功能支持通过方向键进行像素级的移动。 3.5 日历传统日历系统通常只显示阴历的“日”，而不显示“月”，有时为了查看当前阴历的月份不得前后翻阅，非常不便。1key.run 提供的轻量级的日历解决了上述问题，使用起来会更加方便，无需联网即可使用。 3.6 截图1key.run 内置的截图功能，支持对窗口、矩形进行截图，实时显示截取区域坐标和尺寸。输入jt可以唤起该功能，也可以在“设置”中自定义全局快捷键。 3.7 JSON 格式化 3.8 XML 格式化 更多更多功能还在开发和完善中，该文档可能更新不及时，已实际应用为准。","link":"/post/776574933.html"},{"title":"高速文件下载器的实现","text":"我们下载文件时通常会使用浏览器或者迅雷这样的下载工具，这些工具大多具有高速下载（下载速度快）、断点续传（可以暂停之后继续下载）等特性。 现在我们自己开发的应用软件中也需要支持这些特性，我们该如何设计和实现了？本文主要围绕这一问题进行论述，并在文章最后分享了作者自己开发的高速文件下载库。 一个完善的文件下载库需要具有如下特性： 多线程分片下载 断点续传 磁盘缓存 最高下载速率限制及实时下载速率反馈（可选） 多协议支持，跨平台（可选） 1. 多线程分片下载Chrome 浏览器和迅雷能实现高速下载的核心就是多线程分片下载（这里忽略迅雷的离线加速等技术），以 HTTP 协议为例，HTTP 协议支持在请求头中指明需要请求数据的起始和结束位置。我们可以开启多个线程同时进行不同的 HTTP 请求，这些请求分别请求同一文件的不同位置，我们将每个 HTTP 请求的内容称为“片”，在文件的所有片下载完成之后，我们再进行片的合并。 libcurl 中可以通过如下方式指定请求文件的某一区域： 1curl_easy_setopt(curl_, CURLOPT_RANGE, \"1024-2048\"); 如何确定分片数量以及每片大小？文件分片有 2 种策略： 分片数量固定除最后一片外，每片的Size = 文件总Size / 分片Num 分片尺寸固定分片Num = 文件总Size / 每片的Size，如果不能整除，还需要新建一个分片，将余数放到该分片中 无论采用哪一种分片策略，在确定分片 Num 和每片 Size 之前，我们都需要先向文件服务器发起一个请求来获取原始文件总 Size。 2. 断点续传试想我们正在下载一个 4G 大小的文件，下载到一半的时候，忽然因为某些原因需要中止下载，等可以再次下载的时候，却不能继续上次的下载进度进行下载，那岂不是让人很抓狂。断点续传功能就是来解决这种问题的，虽然目前市场上的下载器都支持这些功能，但我们需要自己开发下载器的话，还是不得不自己来实现这个功能的。 断点续传原理主要是将已下载的数据信息（偏移、大小等）记录到某个文件中（我们称之为索引文件），下次下载前读取该文件中已下载信息，跳过已下载的内容，直接下载未下载的数据。 断点续传一般都会和多线程分片下载结合使用。 3. 磁盘缓存文件下载中涉及的磁盘缓存都是磁盘的写缓存，主要是为了避免频繁的对磁盘进行写操作，降低磁盘 IO 的效率。 原理：将网络下载数据存入预先分配好的内存缓冲区，待内存缓冲区满之后，再一次性写入磁盘。 关于内存缓冲区，建议采用双缓冲机制，因为磁盘写入操作是一个相对耗时的操作，在将缓冲区写入磁盘时，该缓冲区是禁止写入的，因而此时网络下载的数据写入缓冲区将被阻塞，从而影响下载速率。 4. 限速及实时速率最高下载速率限制有助于减少用户电脑带宽占用，而实时下载速率反馈可以让用户看到实时的下载速度。 因为采用的是多线程下载，假如最高下载速率限制为 N，则每个线程的最大下载速率为: N / 线程Num，但需要注意的是，如果当前活跃的线程数少于初始线程数时（如有的线程已经下载完了），需要重新计算每个线程的最大下载速率，否则总下载速率将会下载，无法达到最高下载速率。 zoe介绍zoe 是我开发的一个文件下载库，支持如上所有特性的开源库，采用 C++开发。该库已经在多个产品中使用，其稳定性得到了验证。 该库原名为teemo，teemo一词来源于英雄联盟游戏中的迅捷斥候，由于该库被灰产非法使用，导致代码被杀毒软件加入特征库，我闭源了原库，在修改代码后重新开源。","link":"/post/3157704992.html"},{"title":"QPixmap使用要点","text":"本文记录在使用 QPixmap 时容易感到困惑和犯错的地方，方便自己查阅，亦希望能成人之美。 1. QPixmap 成员函数使用要点 QPixmap::size()值与程序 devicePixelRatio 无关，输出的是图片原始尺寸。 AspectRatioMode 取值： Qt::IgnoreAspectRatio 忽略图片原长宽比，将图片缩放到指定尺寸 Qt::KeepAspectRatio 在保持图片原长宽比和图片所有元素的情况下，尽量填充满目标矩形。 Qt::KeepAspectRatioByExpanding 在保持长宽比的情况下，拉伸图片保证填充满目标矩形，可能会舍弃部分图片元素。 scaledToWidth、scaledToHeight 函数可以实现在保持原图片长宽比的前提下，将图片缩放到指定的宽或者高。 drawPixmap 函数的参数从左到右依次是：目标区域 -&gt; pix -&gt; 源区域。目标区域会考虑当前 Widget 的 devicePixelRatio，而源区域则与 devicePixelRatio 无关。 2. 开启程序 DPI 缩放12345 QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling); QGuiApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);#if (QT_VERSION &gt;= QT_VERSION_CHECK(5, 14, 0)) QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough);#endif 3. QPixmap::devicePixelRatio首先QPixmap::devicePixelRatio仅适用于开启了 DPI 缩放的程序。 高分辨率版本的图片有大于 1 的设备像素比（即QPixmap::devicePixelRatio），如果该值匹配底层 QPaintDevice 的值，它将直接绘制到设备上，而不应用额外的转换。 该值用于指定当前 QPixmap 图片是基于 1 倍图的几倍缩放图。 需要注意的是，在使用drawPixmap函数时，如果该目标区域参数未指定宽和高，QPixmap::devicePixelRatio才生效。 如下面的drawPixmap原型： 1234567void QPainter::drawPixmap(int x, int y, const QPixmap &amp;pixmap, int sx, int sy, int sw, int sh)void QPainter::drawPixmap(const QPointF &amp;point, const QPixmap &amp;pixmap, const QRectF &amp;source)void QPainter::drawPixmap(const QPoint &amp;point, const QPixmap &amp;pixmap, const QRect &amp;source)void QPainter::drawPixmap(const QPointF &amp;point, const QPixmap &amp;pixmap)void QPainter::drawPixmap(const QPoint &amp;point, const QPixmap &amp;pixmap)void QPainter::drawPixmap(int x, int y, const QPixmap &amp;pixmap) 示例（程序已开启 DPI 缩放）： 123456789void QtWidgetsApplication1::paintEvent(QPaintEvent* e){ qDebug() &lt;&lt; this-&gt;devicePixelRatioF(); // 当前程序的DPI缩放为1.5 QPainter painter(this); QPixmap pix(\"D:\\\\gril.png\"); // gril.png图片实际尺寸为400*400 pix.setDevicePixelRatio(4); // 告知程序该图片是基于1倍图进行4倍放大后的，即1倍图为宽高为400/4 painter.drawPixmap(QPoint(100,100), pix);}","link":"/post/170290456.html"},{"title":"QSS基本使用方法","text":"Qt QSS 选择器和 CSS2、CSS3 的选择器类似，建议先学习或者复习CSS 选择器的语法。QSS 来源与 CSS ，但有也稍许不同，而且支持的语法也没 CSS 那么多。 一、选择器类型1.1 类选择器12345678910111213/*匹配QPushButton的实例及其子类*/QPushButton { color: blue;}/*匹配QPushButton的实例，但不包含子类*/.QPushButton { color: blue;} 1.2 选择器分组123456/*同时匹配QPushButton、QLineEdit的实例*/QPushButton,QLineEdit { color: blue;} 1.3 ID 选择器1234567891011121314151617181920/*匹配所有objectName为btnOK的实例*/*#btnOK { font-weight: bold;}/*和*#btnOK一样，匹配所有objectName为btnOK的实例*/#btnOK { font-weight: bold;}/*匹配所有objectName为btnOK的QPushButton实例*/QPushButton#btnOK { font-weight: bold;} 1.4 属性选择器123456789101112131415161718192021222324252627/*匹配包含flat属性的所有实例*/*[flat] { color: red;}/*匹配包含flat属性的所有QPushButton的实例*/QPushButton[flat] { color: red;}/*匹配flat属性为true的所有QPushButton的实例*/QPushButton[flat=\"true\"] { color: red;}/*匹配falt属性为true且default属性为false的所有QPushButton的实例*/QPushButton[flat=\"true\"][default=\"false\"] { color: red;} 1.5 后代选择器123456/*匹配属于QDialog后代（孩子，孙子等）的QPushButton所有实例*/QDialog QPushButton { color: red;} 1.6 子元素选择器123456/*匹配属于QDialog直接子类的QPushButton所有实例*/QDialog &gt; QPushButton { color: red;} 1.7 伪状态1234567891011121314151617181920/*匹配hover状态的所有QPushButton的实例*/QPushButton:hover { color: white;}/*匹配同时为hover和enabled状态的所有QPushButton的实例*/QPushButton:hover:enabled { color: white;}/*匹配不为hover状态的所有QPushButton的实例*/qradiobutton: !hover { color: red;} 1.8 子控件选择器123QRadioButton::indicator::unchecked:disabled { image: url(:/qss/radiobutton_unchecked_disable.png);} 二、选择器优先级一句话归纳为：优先使用更具体的选择器。 具体实例如下： 123456789/*QPushButton#okButton选择器比QPushButton更具体，所以选择QPushButton#okButton*/QPushButton#okButton { color: gray;}QPushButton { color: red;} 12345678910/*如下2个规则应用于QPushButton实例时：因为QPushButton继承QAbstractButton，所以QPushButton比QAbstractButton更具体，选择QPushButton*/QPushButton { color: red;}QAbstractButton { color: gray;} 123456789/*指定伪状态比不指定伪状态的选择器更具体，所以当鼠标悬停时选择QPushButton:hover，否则选择QPushButton*/QPushButton:hover { color: white;}QPushButton { color: red;} 1234567891011/*如下2个规则应用于处于Enabled状态的QPushButton实例时：鼠标悬停时，QPushButton:hover更能具体描述当前状态，所以选择QPushButton:hover其他时候选择QPushButton:enabled*/QPushButton:enabled { color: red;}QPushButton:hover { color: white;} 1234567891011121314/*如下2个规则应用于处于Enabled状态的QPushButton实例时：鼠标悬停时，QPushButton:enabled:hover更能具体描述当前状态，所以选择QPushButton:enabled:hover其他时候选择QPushButton:enabled*/QPushButton:enabled { color: red;}QPushButton:hover { color: white;}QPushButton:enabled:hover { color: white;} 三、QSS 支持的类型、属性、伪状态、子控件关于 QSS 支持哪些类型、每种类型支持哪些属性、伪状态和子控件，在 Qt 的官方的英文文档中有详细的介绍：《Qt Style Sheets Reference》 也可以在Qt Assistant中搜索”Qt Style Sheets Reference”打开帮助文档。 3.1 伪状态列表为了方便查阅，这里列举出QSS目前支持的所有伪状态。 伪状态都是以一个冒号:开头，如:active。 伪状态 描述 :active 此状态在Widget驻留在活动窗口时设置 :adjoins-item 此状态在QTreeView的::branch与一个item相邻时设置 :alternate 当QAbstractItemView::alternatingRowColors()设置为真时，在绘制QAbstractItemView的行时，为每个交替行设置此状态 :bottom 此item位于底部时设置。例如，QTabBar有位于底部的选项卡 :checked 此item被选中时设置。例如，QAbstractButton的checked状态 :closable 此item可以被关闭时设置。例如，QDockWidget的QDockWidget::DockWidgetClosable特性开启时 :closed 此item处于关闭状态时设置。例如，QTreeView中未展开的item :default 此item的默认状态时设置。例如，一个default的QPushButton或QMenu中的一个默认动作 :disabled 此item被禁用时设置 :editable 如QComboBox是可编辑时设置 :edit-focus 此item具有编辑焦点(参考QStyle::State_HasEditFocus)时设置。此状态仅对Qt扩展应用程序可用 :enabled 此item已启用时设置 :exclusive 此item是属于某个独占组时设置。例如，独占QActionGroup中的菜单项 :first 此item是列表中的第一项时设置。例如，QTabBar中的第一个选项卡 :flat 此item是扁平时设置。例如，一个扁平的QPushButton :floatable 此item可以浮动时设置。例如，QDockWidget的QDockWidget::DockWidgetFloatable的特性开启时 :focus 此item具有输入焦点时设置 :has-children 此item具有子对象时设置。例如，QTreeView中具有子项的项 :has-sibling 此item具有兄弟对象时设置。例如，QTreeView中与之相邻的项 :horizontal 此item处于水平方向时设置 :hover 鼠标悬浮在此item上时设置 :indeterminate 此item处于不确定状态时设置。例如，QCheckBox或QRadioButton被部分选中 :last 此item是列表中的最后一项时设置。例如，QTabBar中的最后一个选项卡 :left 此item位于左侧时设置。例如，QTabBar有位于左侧的选项卡 :maximized 此item处于最大化状态时设置。例如，一个最大化的QMdiSubWindow :middle 此item是列表中的中间一项时设置。例如，一个不在QTabBar中的开头或结尾的选项卡 :minimized 此item处于最小化状态时设置。例如，一个最小化的QMdiSubWindow :movable 此item可以被移动时设置。例如， QDockWidget的QDockWidget::DockWidgetMovable特性开启时 :no-frame 此item没有边框时设置。例如，没有边框的QSpinBox或QLineEdit :non-exclusive 此item是属于非独占组时设置。例如，非独占QActionGroup中的菜单项 :off 对可以切换的items，这适用于处于off状态的item :on 对可以切换的items，这适用于处于on状态的widget :only-one 此item是列表中的唯一项时设置。例如，一个在QTabBar中单独的选项卡 :open 此item处于打开状态时设置。例如，QTreeView中的展开项，或带有菜单的QComboBox或QPushButton :next-selected 此item是列表中的下一个被选中的项时设置。例如，在QTabBar中当前选项卡的下一个要选中的选项卡 :pressed 鼠标正在按压在此item上时设置 :previous-selected 此item是列表中的上一个被选中的项时设置。例如，在QTabBar中当前选项卡的上一个要选中的选项卡 :read-only 此item处于只读或不可编辑状态时设置。例如，一个只读QLineEdit或不可编辑的QComboBox :right 此item位于右侧时设置。例如，QTabBar有位于右侧的选项卡 :selected 此item处于选中状态时设置。例如，一个在QTabBar中被选中的选项卡或一个在菜单中被选中的菜单项 :top 此item位于顶部时设置。例如，QTabBar有位于顶部的选项卡 :unchecked 此item处于未被选中状态时设置 :vertical 此item处于垂直方向时设置 :window Widget是一个窗口(例如，一个顶层Widget)时设置 3.2 子控件列表 伪状态都是以两个冒号::开头，如::item。 子控件 描述 ::add-line 在QScrollBar中跳转下一行的按钮 ::add-page 在QScrollBar中滑动条和add-line之间的区域 ::branch 在QTreeView中的分支指示器 ::chunk 在QProgressBar中的进度块 ::close-button 在QDockWidget或QTabBar选项卡的关闭按钮 ::corner 在QAbstractScrollArea中两个滚动条之间的角落 ::down-arrow 在QComboBox、QHeaderView(排序指示器)、QScrollBar或QSpinBox的向下箭头 ::down-button 在QScrollBar或QSpinBox中的向下按钮 ::drop-down 在QComboBox中的下拉框 ::float-button 在QDockWidget中的浮动按钮 ::groove 在QSlider中的滑动槽 ::indicator 在QAbstractItemVIew、QCheckBox、QRadioButton、可选中的菜单项或可选中的QGroupBox中的指示器 ::handle 在QScrollBar、QSplitter和QSlider中的操作条(滑动条) ::icon 在QAbstractItemVIew或QMenu中的图标 ::item 在QAbstractItemVIew、QMenuBar、QMenu或QStatuBar中的一项 ::left-arrow 在QScrollBar中的向左箭头 ::left-corner 在QTabWidget中的左上角 ::menu-arrow 带有菜单的QToolButton中的箭头 ::menu-button 在QToolButton中的菜单按钮 ::menu-indicator 在QPushButton中的菜单指示器 ::right-arrow 在QMenu或QScrollBar中的向右箭头 ::pane 在QTabWidget中的边或框 ::right-corner 在QTabWidget中的右上角 ::scroller 在QMenu或QTabBar中的滚动条 ::section 在QHeaderView中的区块 ::separator 在QMenu或QMainWIndow中分隔条 ::sub-line 在QScrollBar中跳转上一行的按钮 ::sub-page 在QScrollBar中滑动条和sub-line之间的区域 ::tab 在QTabBar或QToolBox中选项卡 ::tab-bar 在QTabWidget中的选项卡栏 ::tear 在QTabBar中的tear指示器 ::tearoff 在QMenu中的tear-off指示器 ::text 在QAbstractItemView中的文本 ::title 在QGroupBox或QDockWidget中的标题栏 ::up-arrow 在QComboBox、QHeaderView(排序指示器)、QScrollBar或QSpinBox的向上箭头 ::up-button 在QScrollBar或QSpinBox中的向上按钮 使用示例： 123QPushButton#btnTest::menu-indicator { image: url(indicator.png);} 四、盒子模型在使用 QSS 设置样式时，有一个关键的概念需要知晓，那就是“盒子模型”（即Box Model）。 每个 Widget 都被视为具有 4 个同心矩形的框：MARGIN矩形、BORDER矩形、PADDING矩形和CONTENT矩形，上图标注了每个矩形的区域。 默认情况下MARGIN矩形、BORDER矩形、PADDING矩形的宽度都为 0，这样在默认情况下，4 个矩形就重合为 1 个CONTENT矩形了。 同样，默认情况下background-image指定的背景，只在 border 内的区域绘制。但我们要也可以使用background-clip或background-origin属性来更改这种默认行为。 如何实现背景图像随 Widget 大小自动缩放？background-image 指定的背景图像无法随 Widget 大小自动缩放，要提供可以随 Widget 大小缩放的背景图像可以使用border-image和image属性，二者区别如下： border-image 属性指定的图像从 border 及其内的区域开始绘制，会导致 border 属性被覆盖。 image 属性指定的图像从绘制到 content 区域内，image 指定的 url 为 SVG 图像，则支持自动缩放，非 SVG 图像仅支持自动缩小。 五、动态属性通过 setProperty 方法设置 QWidget 对象属性，在 QSS 中可以根据不同的属性值应用不同的样式。 设置 pushButtonMax 按钮的 isMax 属性，表示当前窗口是否最大化： 1pushButtonMax-&gt;setProperty(\"isMax\", this-&gt;isMaximized() ? true : false); 在 QSS 中根据不同的属性值应用不同的样式： 12345678910111213141516171819#pushButtonMax[isMax=\"false\"] { width: 40px; height: 40px; background: gray;}#pushButtonMax[isMax=\"false\"]:hover { background: blue;}#pushButtonMax[isMax=\"true\"] { width: 40px; height: 40px; background: transparent;}#pushButtonMax[isMax=\"true\"]:hover { background: red;} 六、Q_PROPERTY在 Qt 中可以使用Q_PROPERTY宏为 QObject 对象（含子对象）声明属性，任何被Q_PROPERTY声明的属性都能在 QSS 中使用qproperty-&lt;property name&gt;语法进行设置。 以 QToolButton 为例，QToolButton 继承至 QAbstractButton，QAbstractButton 拥有以下被 Q_PROPERTY 声明的属性： 12345678910111213141516171819class Q_WIDGETS_EXPORT QAbstractButton : public QWidget{ Q_OBJECT Q_PROPERTY(QString text READ text WRITE setText) Q_PROPERTY(QIcon icon READ icon WRITE setIcon) Q_PROPERTY(QSize iconSize READ iconSize WRITE setIconSize)#ifndef QT_NO_SHORTCUT Q_PROPERTY(QKeySequence shortcut READ shortcut WRITE setShortcut)#endif Q_PROPERTY(bool checkable READ isCheckable WRITE setCheckable) Q_PROPERTY(bool checked READ isChecked WRITE setChecked DESIGNABLE isCheckable NOTIFY toggled USER true) Q_PROPERTY(bool autoRepeat READ autoRepeat WRITE setAutoRepeat) Q_PROPERTY(bool autoExclusive READ autoExclusive WRITE setAutoExclusive) Q_PROPERTY(int autoRepeatDelay READ autoRepeatDelay WRITE setAutoRepeatDelay) Q_PROPERTY(int autoRepeatInterval READ autoRepeatInterval WRITE setAutoRepeatInterval) Q_PROPERTY(bool down READ isDown WRITE setDown DESIGNABLE false) ....} 在 QSS 中可以直接对属性赋值，如： 12345QToolButton { qproperty-text: \"文本\"; qproperty-icon: url(://img/icon.png); qproperty-iconsize: 100px 100px;} 七、Padding和Margin的使用Margin指控件和其他控件的间距，而Padding指控件内的内容与边框的间距。 二者的语法与CSS中的一样： 12margin: 25px 50px 75px 100px;padding: 25px 50px 75px 100px; 从左到右依次为：上、右、下、左。 支持简写形式： 12margin: 25px 50px;padding: 25px 50px; 表示：上下间距为25px，左右间距为50px。","link":"/post/749849405.html"},{"title":"QSS的几种图片设置方法","text":"大家在使用 QSS 进行图片设置时，也许被image, border-image, background-image这几个属性的差异困扰过。本文就来讲解一下这个几个属性的异同点。 一、background-imagebackground-image按图片实际尺寸显示图片，超过控件显示区域的部分会被裁剪掉。 虽能显示 SVG，但无法对 SVG 进行无损缩放； 关于background-image的几个附属属性的作用，可以一句话概括为：从background-origin区域的background-position位置开始绘制图像，并以background-repeat方式进行重复；最后将图像background-clip区域以外的范围裁剪掉（即不显示）。 二、imageimage会将图片按图片原长宽比进行缩放，并保证填充满控件 content 区域。 image支持 SVG 矢量图显示和无损缩放。 image 可以使用image-position来指定图片开始显示的位置（参考上面background-position）。 三、border-image按控件 border 区域的长宽比来缩放图片，保证填充满控件 border 区域，支持 SVG 矢量图显示和无损缩放; 四、绘制顺序如果在一个控件中同时指定background-image，border-image，image这三个属性，会按照如下的顺序进行绘制： 123先绘制 background-image然后 border-image最后 image 五、示例1234567891011QPushButton#pushButton4 { border: 20px solid rgba(0,0,255,0.5); padding: 20px; margin: 20px; background-image: url(:/QssUsage/Image/头像.png); /*下图中的圆形头像*/ background-origin: margin; background-position:top left; background-repeat:repeat-x; background-clip: margin;}","link":"/post/830332637.html"},{"title":"QSS设置滚动条样式","text":"本文仅简单记录如何使用 QSS 设置滚动条的样式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/*垂直滚动条*/QScrollBar:vertical { background: transparent; /*背景色*/ width: 10px; /*宽度*/ margin: 0px 0px 0px 0px; /**/ padding-top: 12px; /*距离上面12px*/ padding-bottom: 12px; /*距离底部12px*/}/*横向滚动条*/QScrollBar:horizontal { background: transparent; /*背景色*/ height: 10px; /*高度*/ margin: 0px 0px 0px 0px; padding-left: 12px; /*距离左边12px*/ padding-right: 12px; /*距离右边12px*/}/*垂直/横向滚动条Hover效果*/QScrollBar:vertical:hover,QScrollBar:horizontal:hover { background: rgba(0, 0, 0, 30); /*背景色*/ border-radius: 5px; /*圆角*/}/*垂直滚动条 - 滑块*/QScrollBar::handle:vertical { background: rgba(0, 0, 0, 50); width: 10px; border-radius: 5px; border: none;}/*横向滚动条 - 滑块*/QScrollBar::handle:horizontal { background: rgba(0, 0, 0, 50); height: 10px; border-radius: 5px; border: none;}/*垂直/横向滚动条滑块Hover效果*/QScrollBar::handle:vertical:hover,QScrollBar::handle:horizontal:hover { background: rgba(0, 0, 0, 100);}/*垂直滚动条下部分块*/QScrollBar::add-page:vertical { width: 10px; background: transparent;}/*垂直滚动条上面部分块*/QScrollBar::sub-page:vertical { width: 10px; background: transparent;}/*横向滚动条右边部分块*/QScrollBar::add-page:horizontal { height: 10px; background: transparent;}/*横向滚动条左边部分块*/QScrollBar::sub-page:horizontal { height: 10px; background: transparent;}/* ----------- 对于扁平化设计风格，下面的样式可以不用设置 ----------- *//*垂直滚动条顶部三角形位置*/QScrollBar::sub-line:vertical { height: 12px; width: 10px; background: transparent; subcontrol-position: top;}/*垂直滚动条顶部三角形图标*/QScrollBar::up-arrow:vertical { image: url(:/client/images/scrollbar_arrowup_normal.png);}/*垂直滚动条顶部三角形图标 鼠标Hover效果*/QScrollBar::up-arrow:vertical:hover { image: url(:/client/images/scrollbar_arrowup_down.png);}/*垂直滚动条顶部三角形图标 鼠标按下效果*/QScrollBar::up-arrow:vertical:pressed { image: url(:/client/images/scrollbar_arrowup_highlight.png);}/*垂直滚动条底部三角形位置*/QScrollBar::add-line:vertical { height: 12px; width: 10px; background: transparent; subcontrol-position: bottom;}/*垂直滚动条底部三角形图标*/QScrollBar::down-arrow:vertical { image: url(:/client/images/scrollbar_arrowdown_normal.png);}/*垂直滚动条底部三角形图标 鼠标Hover效果*/QScrollBar::down-arrow:vertical:hover { image: url(:/client/images/scrollbar_arrowdown_down.png);}/*垂直滚动条底部三角形图标 鼠标按下效果*/QScrollBar::down-arrow:vertical:pressed { image: url(:/client/images/scrollbar_arrowdown_highlight.png);}/*横向滚动条左侧三角形位置*/QScrollBar::sub-line:horizontal { height: 10px; width: 12px; background: transparent; subcontrol-position: left;}/*横向滚动条左侧三角形图标*/QScrollBar::left-arrow:horizontal { image: url(:/client/images/scrollbar_arrowleft_normal.png);}/*横向滚动条左侧三角形图标 鼠标Hover效果*/QScrollBar::left-arrow:horizontal:hover { image: url(:/client/images/scrollbar_arrowleft_down.png);}/*横向滚动条左侧三角形图标 鼠标按下效果*/QScrollBar::left-arrow:horizontal:pressed { image: url(:/client/images/scrollbar_arrowleft_highlight.png);}/*横向滚动条右侧三角形部分*/QScrollBar::add-line:horizontal { height: 10px; width: 12px; background: transparent; subcontrol-position: right;}/*横向滚动条右侧三角形图标*/QScrollBar::right-arrow:horizontal { image: url(:/client/images/scrollbar_arrowright_normal.png);}/*横向滚动条右侧三角形图标 鼠标Hover效果*/QScrollBar::right-arrow:horizontal:hover { image: url(:/client/images/scrollbar_arrowright_down.png);}/*横向滚动条右侧三角形图标 鼠标按下效果*/QScrollBar::right-arrow:horizontal:pressed { image: url(:/client/images/scrollbar_arrowright_highlight.png);}","link":"/post/140071237.html"},{"title":"QListWidget使用记录","text":"1. 解决无法拖入文件到QListWidget一般而言，QWidget支持拖入文件只需要做如下操作即可： 12345678setDragDropMode(QAbstractItemView::DropOnly); // 仅支持拖入文件// 重写dragEnterEvent，当拖入文件进入时被调用，可以在该函数中取消拖入操作void dragEnterEvent(QDragEnterEvent* e) override;// 重写dropEvent，当拖入文件并释放鼠标时被调用void dropEvent(QDropEvent* e) override; 但执行上述操作后，拖入文件到QListWidget却只能收到dragEnterEvent事件，却无法收到dropEvent事件。 因为还需要重写dragMoveEvent方法，如： 123void dragMoveEvent(QDragMoveEvent* e) { e-&gt;acceptProposedAction();} 2. QListWidgetItem自适应尺寸QListWidget添加item的方法如下： 123456QListWidget* list = new QListWidget();// ...QListWidgetItem* item = new QListWidgetItem();list-&gt;addItem(item); 如需要自定义Item的布局，可以通过自定义Widget，如： 123456789QListWidget* list = new QListWidget();// ...QListWidgetItem* item = new QListWidgetItem();list-&gt;addItem(item);CustomWidget * customWidget = new CustomWidget();list-&gt;setItemWidget(item, customWidget); // 设置Item的自定义Widget 此时还没有为item设置size hint，item会自动根据item的数据（如text）计算size hint。但如果是自定义的Widget，则无法自动计算size hint，需要手动设置size hint，如： 123456int vScrollbarWidth = 0;if (verticalScrollBar()) vScrollbarWidth = verticalScrollBar()-&gt;width();// 减去纵坐标的宽度item-&gt;setSizeHint(QSize(list-&gt;width() - vScrollbarWidth, widget-&gt;height())); QListWidget的滚动条默认显示策略是ScrollBarAsNeeded，当宽度不够显示Item时，滚动条就会显示出来，此时虽然QListWidget宽度改变了，但Item的宽度不会改变，因此Item不会收到ResizeEvent事件。如需Item的宽度跟随QListWidget宽度而改变，需要关闭滚动条显示并在QListWidget的ResizeEvent事件中实时设置每个Item的size hint，代码如下： 1list-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff); 123456789101112131415161718void FileList::resizeEvent(QResizeEvent* e) { int vScrollbarWidth = 0; if (verticalScrollBar()) vScrollbarWidth = verticalScrollBar()-&gt;width(); int w = width(); int cnt = count(); for (int i = 0; i &lt; cnt; i++) { QListWidgetItem* it = item(i); if (it) { CustomWidget* customWidget = dynamic_cast&lt;CustomWidget*&gt;(itemWidget(it)); if (customWidget) { it-&gt;setSizeHint(QSize(w - vScrollbarWidth, customWidget-&gt;height())); } } } QListWidget::resizeEvent(e);}","link":"/post/3168359900.html"},{"title":"Qt中图片按九宫格模式缩放","text":"有时候，我们在缩放图片时没办法保持原图的长宽比，如保持图片高度不变仅拉伸宽度等，此时在不保持长宽比的情况进行图片缩放会导致图片变形。为了解决这种问题，我们可以考虑使用九宫格模式进行图片的缩放。 九宫格模式就是将图片切分为九块，不强制等分，如下图所示，在图片缩放时，我们通常保持1、3、7、9四个顶点位置的图片不变，对2、4、5、6、8五个区域进行缩放。 1. 使用QSS实现在Qt中实现图片按九宫格缩放最简单的方法是使用QSS的border-image属性来实现，通过上下左右四个边框的宽度或高度来设置1、3、7、9四个顶点的大小。 12345border-image: url(:/Sample/image/NinePatchTest.png);border-left: 210px;border-top: 180px;border-right: 300px;border-bottom: 227px; 为了便于测试，我制作了一个九宫格测试图片（整个图片宽高为1280*720）： 通过这种方法实现的九宫格缩放有一个弊端： 该方案会始终保持1、3、7、9四个区域图片的宽高不变，如1号区域是210*180，当我们对图片进行放大时，这个行为是没有问题的，但当我们缩小图片时，缩小后的图片宽高不足以容纳4个顶角图片时，缩小操作就会出现非预期的行为，可能如下图所示： 这种弊端还会体现在支持高DPI缩放的Qt程序中，例如在一个支持DPI缩放的程序中，对一个宽高为640*360的QWidget设置背景图片，我们知道不同的devicePixelRatio会导致实际渲染的图片宽高不同，如devicePixelRatio为1时图片渲染区域为640*360， 而devicePixelRatio为2时渲染区域为1280*720，为了保证程序在不同DPI的环境下都有比较好的界面呈现，我们通常简单得（当然也可以使用SVG或为不同DPI支持不同的图片）指定一个倍图（如2倍图）让程序自动进行图片缩放。而使用border-left等属性指定的宽度是固定的，顶点图片无法参与到自动缩放中来，从而会导致这一DPI适配机制失效。下一节介绍的方法可以解决这一弊端。 2. 使用代码实现九宫格缩放本节介绍使用代码实现图片九宫格模式缩放，实现原理大致是： 提取九个区域的图片，保持1、3、7、9四个图片不变，对2、4、5、6、8五个区域图片进行缩放，分别得到新的图片，最后再将九个区域的图片合并成一张图。 如何解决上述QSS方案的弊端？为了解决上述QSS方案的弊端，我们可以采取先将图片在保持长宽比的情况缩放到相应尺寸： 1QPixmap keepRatioScaledPix = src.scaled(destSize, Qt::KeepAspectRatio, Qt::SmoothTransformation); 由于keepRatioScaledPix实际尺寸肯定与我们想要得到的destSize不匹配，所以我们再把keepRatioScaledPix图片按九宫格模式缩放。 具体实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384QPixmap ScaleByNinePatch(const QPixmap&amp; src, // 原图 QSize destSize, // 目标尺寸 bool keepVertexImageSize, // 是否保持1、3、7、9顶点图片大小不变，设置为true则与QSS方式效果类似（仅类似，因为该函数是直接返回原图） int pos1Width, int pos1Height, int pos3Width, int pos7Height, Qt::TransformationMode mode = Qt::SmoothTransformation) { // 参数校准 pos1Width = qMax(pos1Width, 0); pos1Height = qMax(pos1Height, 0); pos3Width = qMax(pos3Width, 0); pos7Height = qMax(pos7Height, 0); int handlePixW = 0, handlePixH = 0; const QPixmap* handlePix = nullptr; QPixmap keepRatioScaledPix; if (keepVertexImageSize) { // 保持顶点图片大小不变的情况，如果顶点图片宽或高已经大于了目标宽高，则直接返回原图 if (pos1Width + pos3Width &gt; destSize.width() || pos1Height + pos7Height &gt; destSize.height()) return src; handlePixW = src.width(); handlePixH = src.height(); handlePix = &amp;src; } else { const qreal srcW = src.width(); const qreal srcH = src.height(); // 先等比缩放到适合的尺寸 keepRatioScaledPix = src.scaled(destSize, Qt::KeepAspectRatio, mode); handlePixW = keepRatioScaledPix.width(); handlePixH = keepRatioScaledPix.height(); qreal krsPixWidth = handlePixW; qreal krsPixHeight = handlePixH; // 按照之前的比例获取新顶点图片的大小 pos1Width = krsPixWidth * (qreal)pos1Width / srcW; pos1Height = krsPixHeight * (qreal)pos1Height / srcH; pos3Width = krsPixWidth * (qreal)pos3Width / srcW; pos7Height = krsPixHeight * (qreal)pos7Height / srcH; handlePix = &amp;keepRatioScaledPix; } // 提前各个区域图片 QPixmap pix1 = handlePix-&gt;copy(0, 0, pos1Width, pos1Height); QPixmap pix2 = handlePix-&gt;copy(pos1Width, 0, qMax(handlePixW - pos1Width - pos3Width, 0), pos1Height); QPixmap pix3 = handlePix-&gt;copy(qMax(handlePixW - pos3Width, 0), 0, pos3Width, pos1Height); QPixmap pix4 = handlePix-&gt;copy(0, pos1Height, pos1Width, qMax(handlePixH - pos1Height - pos7Height, 0)); QPixmap pix5 = handlePix-&gt;copy(pos1Width, pos1Height, qMax(handlePixW - pos1Width - pos3Width, 0), qMax(handlePixH - pos1Height - pos7Height, 0)); QPixmap pix6 = handlePix-&gt;copy(qMax(handlePixW - pos3Width, 0), pos1Height, pos3Width, qMax(handlePixH - pos1Height - pos7Height, 0)); QPixmap pix7 = handlePix-&gt;copy(0, qMax(handlePixH - pos7Height, 0), pos1Width, pos7Height); QPixmap pix8 = handlePix-&gt;copy(pos1Width, qMax(handlePixH - pos7Height, 0), qMax(handlePixW - pos1Width - pos3Width, 0), pos7Height); QPixmap pix9 = handlePix-&gt;copy(qMax(handlePixW - pos3Width, 0), qMax(handlePixH - pos7Height, 0), pos3Width, pos7Height); // 对2、4、5、6、8区域图片进行缩放 pix2 = pix2.scaled(qMax(destSize.width() - pos1Width - pos3Width, 0), pos1Height, Qt::IgnoreAspectRatio, mode); pix4 = pix4.scaled(pos1Width, qMax(destSize.height() - pos1Height - pos7Height, 0), Qt::IgnoreAspectRatio, mode); pix5 = pix5.scaled(qMax(destSize.width() - pos1Width - pos3Width, 0), qMax(destSize.height() - pos1Height - pos7Height, 0), Qt::IgnoreAspectRatio, mode); pix6 = pix6.scaled(pos3Width, qMax(destSize.height() - pos1Height - pos7Height, 0), Qt::IgnoreAspectRatio, mode); pix8 = pix8.scaled(qMax(destSize.width() - pos1Width - pos3Width, 0), pos7Height, Qt::IgnoreAspectRatio, mode); // 拼接新的图片 QPixmap dest(destSize); dest.fill(Qt::transparent); // 使用透明色填充图片 QPainter painter(&amp;dest); painter.drawPixmap(0, 0, pix1); painter.drawPixmap(pos1Width, 0, pix2); painter.drawPixmap(qMax(destSize.width() - pos3Width, 0), 0, pix3); painter.drawPixmap(0, pos1Height, pix4); painter.drawPixmap(pos1Width, pos1Height, pix5); painter.drawPixmap(qMax(destSize.width() - pos3Width, 0), pos1Height, pix6); painter.drawPixmap(0, qMax(destSize.height() - pos7Height, 0), pix7); painter.drawPixmap(pos1Width, qMax(destSize.height() - pos7Height, 0), pix8); painter.drawPixmap(qMax(destSize.width() - pos3Width, 0), qMax(destSize.height() - pos7Height, 0), pix9); painter.end(); return dest;} 调试小技巧： 可以把每个区域的图片保存到本地，查看图片是否正确，如： 123456789pix1.save(\"D:\\\\1.png\");pix2.save(\"D:\\\\2.png\");pix3.save(\"D:\\\\3.png\");pix4.save(\"D:\\\\4.png\");pix5.save(\"D:\\\\5.png\");pix6.save(\"D:\\\\6.png\");pix7.save(\"D:\\\\7.png\");pix8.save(\"D:\\\\8.png\");pix9.save(\"D:\\\\9.png\");","link":"/post/333631906.html"},{"title":"Qt加载字体文件","text":"本文仅简单记录如何使用 Qt 加载外部字体文件，并遍历字体名称和样式名称。 1234567891011121314151617181920212223242526272829303132333435363738bool LoadFont(const QString&amp; fontPath) { const int fontId = QFontDatabase::addApplicationFont(fontPath); if (fontId == -1) { return false; } // 遍历字体名和样式名#if QT_VERSION &gt;= QT_VERSION_CHECK(6, 0, 0) const QStringList fontFamilyList = fontDb.applicationFontFamilies(fontId); QString fontFamily; foreach (fontFamily, fontFamilyList) { qDebug() &lt;&lt; \"Family:\" &lt;&lt; fontFamily; const QStringList fontStyleList = QFontDatabase::styles(fontFamily); QString fontStyle; foreach (fontStyle, fontStyleList) { qDebug() &lt;&lt; \"\\tStyle:\" &lt;&lt; fontStyle; } }#else QFontDatabase fontDb; const QStringList fontFamilyList = fontDb.applicationFontFamilies(fontId); QString fontFamily; foreach (fontFamily, fontFamilyList) { qDebug() &lt;&lt; \"Family:\" &lt;&lt; fontFamily; const QStringList fontStyleList = fontDb.styles(fontFamily); QString fontStyle; foreach (fontStyle, fontStyleList) { qDebug() &lt;&lt; \"\\tStyle:\" &lt;&lt; fontStyle; } }#endif return true;}","link":"/post/2767065786.html"},{"title":"Qt子线程中更新UI","text":"本文介绍两种在Qt子线程（非UI线程）中更新UI组件的方法。 1. 使用信号槽这是一种非常常规的方式，通过自定义信号、槽，连接该信号和槽，在子线程中发送信号，在槽中更新 UI。 定义信号和槽： 1234signals: void updateUi(int v);private slots: void onUpdateUi(int v); 在子线程中发送信号： 12345678910// 连接信号connect(this, &amp;UpdateUIInSubThread::updateUi, this, &amp;UpdateUIInSubThread::onUpdateUi, Qt::AutoConnection);std::thread t = std::thread([this]() { for (int i = 0; i &lt; 10000; i++) { emit updateUi(i); // 发送信号 std::this_thread::sleep_for(std::chrono::milliseconds(50)); }});t.detach(); 在槽函数中更新 UI： 1234void UpdateUIInSubThread::onUpdateUi(int v){ ui.label-&gt;setText(QString::number(v));} 这种方式需要单独额外定义信号和槽，使用起来比较繁琐。 2. 使用 QMetaObject::invokeMethod使用 QMetaObject::invokeMethod 函数的原型如下： 1template &lt;typename Functor, typename FunctorReturnType&gt; bool QMetaObject::invokeMethod(QObject *context, Functor function, Qt::ConnectionType type = Qt::AutoConnection, FunctorReturnType *ret = nullptr) 该函数可以在context的事件循环中执行function函数。 123456789101112std::thread t = std::thread([this]() { for (int i = 0; i &lt; 10000; i++) { if (QMetaObject::invokeMethod(this, [i, this]() { ui.label-&gt;setText(QString::number(i)); })) { qDebug() &lt;&lt; \"Update UI success\"; } std::this_thread::sleep_for(std::chrono::milliseconds(50)); }});t.detach(); 由于在子线程中更新 UI，因此信号和槽肯定使用的是 QueuedConnection 的连接方式，所以无法将FunctorReturnType返回给调用者，否则会出现如下错误： 1QMetaObject::invokeMethod: Unable to invoke methods with return values in queued connections 当然上述示例中也可以不使用 lambda 表达式，直接调用槽函数： 12345678std::thread t = std::thread([this]() { for (int i = 0; i &lt; 10000; i++) { QMetaObject::invokeMethod(this, \"onUpdateUi\", Qt::AutoConnection, Q_ARG(int, i)); std::this_thread::sleep_for(std::chrono::milliseconds(50)); }});t.detach();","link":"/post/3531733309.html"},{"title":"Qt弹窗外部点击时自动关闭","text":"本文介绍在 Qt 编程中如何实现在鼠标点击弹窗外部区域时，该弹窗可以自动关闭。 1. ActivationChange 事件弹窗通过监听 Activation 改变事件，来判断自身是否还是当前的活动窗口，如果不是则关闭自身。 在 QWidget 里面重写 event，捕获 QEvent::ActivationChange 事件： 123456789bool UserCenterDlg::event(QEvent* e) { if (e-&gt;type() == QEvent::ActivationChange) { QWidget* curActiveWin = QApplication::activeWindow(); if (curActiveWin != this) { this-&gt;close(); } } return QWidget::event(e);} 2. Qt::WA_NoMouseReplay 介绍 摘自 Qt 帮助文档：Qt::WA_NoMouseReplay: Used for pop-up widgets. Indicates that the most recent mouse press event should not be replayed when the pop-up widget closes. The flag is set by the widget’s author and cleared by the Qt kernel every time the widget receives a new mouse event. Qt::WA_NoMouseReplay 属性可以用来避免如下情况的发生：在鼠标点击 Popup Widget 外部区域时，该 Widget 接收到自身的 Activation 状态发生改变，关闭自身，但在该 Widget 在关闭后，Qt 依然会将鼠标点击事件继续向下传递，从而窗口外区域下面的控件也会被点击。 由于 Qt::WA_NoMouseReplay 属性只对具有 Popup 属性的 Widget 起作用，因此只能使用 QWidget，不能使用 QDialog，并设置 Qt::Popup 属性。 1setWindowFlags(windowFlags() | Qt::Popup); 何时设置 Qt::WA_NoMouseReplay 属性了？ 重写 mousePressEvent，在鼠标按下事件发生时，设置 Qt::WA_NoMouseReplay 属性。 1234void UserCenterDlg::mousePressEvent(QMouseEvent* e) { setAttribute(Qt::WA_NoMouseReplay); QWidget::mousePressEvent(e);} 3. 自定义 closed 信号QWidget 没有关闭信号，我们可以自定义关闭信号，该信号在 closeEvent 中触发。 1234void UserCenterDlg::closeEvent(QCloseEvent* e) { emit closed(); QWidget::closeEvent(e);}","link":"/post/3677374843.html"},{"title":"Qt自定义和美化菜单","text":"在Qt中可以通过QSS对菜单进行样式设置，而且对于非标准菜单项我也可以通过自定义Widget的方法来实现，本文讲述在Qt中菜单的这些常用方法。 一、菜单基本使用方法下面示例演示了右键菜单的创建方法，该菜单包含了图标、选中/未选中状态、二级菜单、互斥选择等常用菜单特性，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960QIcon settingIcon(\":/MenuBeauty/setting.png\");// 定义ActionsQAction* action1 = new QAction(\"动作1\");QAction* action2 = new QAction(settingIcon, \"动作2 有图标\");QAction* action3 = new QAction(\"动作3 [未选中]\");action3-&gt;setCheckable(true);action3-&gt;setChecked(false);connect(action3, &amp;QAction::triggered, this, [action3](bool checked) { action3-&gt;setText(checked ? \"动作3 [选中]\" : \"动作3 [未选中]\");});QAction* action4 = new QAction(\"Action4 动作四测试\");QAction* action5 = new QAction(settingIcon, \"动作5 禁用\");action5-&gt;setEnabled(false);QAction* action6 = new QAction(settingIcon, \"动作6 子菜单\");{ // 动作6的子动作 QAction* action6_1 = new QAction(\"动作6.1\"); action6_1-&gt;setCheckable(true); QAction* action6_2 = new QAction(\"动作6.1\"); action6_2-&gt;setCheckable(true); QAction* action6_3 = new QAction(\"动作6.1\"); action6_3-&gt;setCheckable(true); // 动作6的子菜单 QMenu* action6SubMenu = new QMenu(this); action6SubMenu-&gt;addAction(action6_1); action6SubMenu-&gt;addAction(action6_2); action6SubMenu-&gt;addAction(action6_3); // 互斥子菜单项，同时只能选择一个 QActionGroup* action6Group = new QActionGroup(this); action6Group-&gt;setExclusive(true); action6Group-&gt;addAction(action6_1); action6Group-&gt;addAction(action6_2); action6Group-&gt;addAction(action6_3); action6-&gt;setMenu(action6SubMenu);}// 定义菜单QMenu* menu = new QMenu(this);// 添加Actionmenu-&gt;addActions({action1, action2, action3});menu-&gt;addSeparator();menu-&gt;addActions({action4, action5, action6});// 鼠标右键弹出菜单this-&gt;setContextMenuPolicy(Qt::CustomContextMenu);connect(this, &amp;QWidget::customContextMenuRequested, this, [this, menu](const QPoint&amp; pos) { menu-&gt;exec(this-&gt;mapToGlobal(pos));}); 上述菜单未经过任何美化，样式如下图所示： 二、使用QSS美化菜单现在我们使用如下QSS对上面创建的菜单进行美化，可以美化的项包含背景、文本颜色、边距、图标等。 为了使大家不被颜色值所困扰，下面QSS中的颜色统一使用颜色名称表示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* 菜单的属性 */QMenu { border: 1px solod red; /* 圆角生效的前提是菜单窗口背景透明 */ border-radius: 10px; background-color: blue; font-size: 14px; font-family: \"Microsoft YaHei\"; /* 设置菜单项最小宽度，此处有bug：虽可自动增长但实际宽度比所需宽度小 */ min-width: 160px; /* 菜单内容上下边距为10px，预留圆角区域 */ padding: 10px 0px 10px 0px;}/* 菜单项的属性 */QMenu::item { border: none; background-color: transparent; color: white; /* 设置菜单项最小高度，可以让菜单项的高适应内容自动增长 */ min-height: 20px; /* 设置菜单项最小宽度，此处有bug：虽可自动增长但实际宽度比所需宽度小 */ min-width: 160px; /* 使菜单项之间及菜单项和图标之间保持一定间隔，设置上下左右边距为8px，此处不能用margin */ padding: 8px 8px;}/* 菜单项-鼠标移入时的属性 */QMenu::item:selected { background-color: green; color: black;}/* 菜单项-禁用时的属性 */QMenu::item:disabled { background-color: gray; color: white;}/* 分割线的属性 */QMenu::separator { height: 1px; background-color: red; /* 左右边距：6px */ margin: 0x 6px 0px 6px;}/* 图标的属性 */QMenu::icon { width: 12px; height: 12px; /* 左边距：12px */ margin: 0 0 0 12px;}/* 指示器的属性 *//* 这里将互斥和非互斥Action的指示器样式设置为一样的，也可以设置为不一样 */QMenu::indicator:non-exclusive:checked, QMenu::indicator:exclusive:checked { width: 12px; height: 12px; /* 左边距：8px */ margin: 0 0 0 8px; image: url(:/MenuBeauty/check.png);}QMenu::indicator:non-exclusive:unchecked, QMenu::indicator:exclusive:unchecked { width: 12px; height: 12px; /* 左边距：8px */ margin: 0 0 0 8px; image: url(:/MenuBeauty/unchecked.png);} 为了使菜单的圆角生效，我们还需要移除菜单的边框、阴影，并将背景设置为透明，代码如下： 12345menu-&gt;setWindowFlags(action6SubMenu-&gt;windowFlags() | Qt::FramelessWindowHint | // 无边框 Qt::NoDropShadowWindowHint // 移除系统阴影);menu-&gt;setAttribute(Qt::WA_TranslucentBackground); // 背景透明 美化后的菜单如下图所示： QSS可定制的QMenu部分QMenu支持QSS盒子模型，其通用属性如下： 12345678borderborder-radiusmarginpaddingbackgroundcolorfontborder-image QSS还可以对QMenu的子控件进行设置，支持QMenu子控件如下： 1234567itemindicatorseparatorright-arrowleft-arrowscrollertearoff QMenu不支持伪状态，只有其子控件支持伪状态，支持的伪状态如下： 1234defaultselectedexclusivenon-exclusive 具体的子控件和伪状态的含义，可以参考 QSS基本使用方法 文章。 三、自定义菜单项大多数情况，上述常规的菜单项就可以满足要求，但有些情况下，我们的菜单项可能是更加复杂的Widget组合，比如下面播放器的菜单： 我们可以使用QWidgetAction来实现上述菜单效果，QWidgetAction可以将一个QWidget放入菜单项的容器内，从而实现自定义菜单项。 下面代码定义了一个包含3个按钮的菜单项，点击按钮会弹出对话框： 123456789101112131415161718192021QWidgetAction* action7 = new QWidgetAction(this);{ QWidget* widget = new QWidget(); QHBoxLayout* hl = new QHBoxLayout(widget); auto createPushButtonFn = [this](QString title) { QPushButton* btn = new QPushButton(title); connect(btn, &amp;QPushButton::clicked, this, [this]() { QMessageBox::information(this, \"Clicked\", ((QPushButton*)sender())-&gt;text()); }); return btn; }; hl-&gt;addWidget(createPushButtonFn(\"Button1\")); hl-&gt;addWidget(createPushButtonFn(\"Button2\")); hl-&gt;addWidget(createPushButtonFn(\"Button3\")); action7-&gt;setDefaultWidget(widget);}menu-&gt;addAction(action7); 效果如图所示： 我们也可以使用QSS对菜单项内的控件进行样式设置，如： 123456QMenu QPushButton { border: none; border-radius: 10px; background-color: black; color: white;}","link":"/post/711494356.html"},{"title":"Qt静态库编译","text":"需要注意：使用Qt静态库违背了Qt的免费使用协议。 1. 编译编译Qt源码需要提前安装如下工具： nasm perl gperf win_flex_bison llvm python2 openssl 2.1 Windows编译为了方便编译，我已将这些工具和打包脚本提交到了我的开源项目qt-source-compile中。 只需克隆项目到本地，选择对应的批处理文件（如msvc2022-5.15.2-x86-static-mt.bat），然后编辑该文件中的qt_src_folder变量（Qt源码路径）和vcvarsall_path变量（Visual Studio路径），最后运行该批处理即可编译。 2. 疑难问题openssl链接失败错误提示如下： 1ERROR: Feature 'openssl-linked' was enabled, but the pre-condition '!features.securetransport &amp;&amp; !features.schannel &amp;&amp; libs.openssl' failed. 上述错误可能是由于指定openssl的include、lib目录最后包含\\导致。","link":"/post/3406024791.html"},{"title":"在Qt中线条是如何占用空间的","text":"当线条宽度仅有1像素时，我们可能不太关心这1像素占用的是哪里的空间，但当线条宽度很大时，如50像素，此时我们就需要考虑这50像素占用的是哪里的空间了，否则绘制出来的效果和预期的会有很大的差别。 现有如下需求： 在窗口的(200,200)位置绘制长宽均为200px、边框宽度为50px的矩形。 代码如下： 123456789101112131415161718void QtWidgetsApplication::paintEvent(QPaintEvent* e){ QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing); // 窗口填充白色，方便观察 painter.fillRect(rect(), QColor(255, 255, 255)); QPen pen; // 边框颜色为蓝色，宽度为40px pen.setColor(QColor(0, 0, 255)); pen.setWidth(40); painter.setPen(pen); // 在(200,200)处绘制200*200的矩形 painter.drawRect(200, 200, 200, 200);} 实际绘制出来的矩形左上角坐标不是预期的(200, 200)，长宽也不是200px，如下图所示（红色部分是为了便于讲解，后期使用工具添加上去的）： 图中A处的实际坐标为(200, 200)，位于边框的中间位置。 实际绘制矩形位置为： 123QRect(200 - 40 / 2, 200 - 40 / 2, 200 + 40, 200 + 40)=QRect(180, 180, 240, 240) 总结起来就是： 我们在drawRect等函数中指定的左上角坐标实际是左上方两条边框相交的中心点，指定的宽度是左右边框中心点的距离，高度是上下边框中心点的距离。 使用drawLine绘制线条时，与绘制矩形时一样，指定的起点坐标实际是起点处线条中心点位置，指定的终点坐标实际是终点处线条中心点位置。 为什么边框相交处是如下图所示的样式？ 这个是由QPen的相交样式（Qt::PenJoinStyle）控制的，可以通过QPen::setJoinStyle方法修改。","link":"/post/2292901264.html"},{"title":"基于Qt的无边框窗体实现","text":"Qt虽然提供了诸如Qt::FramelessWindowHint之类的属性可以移除窗体的边框，但是移除边框之后，窗体的一些默认行为同时也被移除了，如鼠标拖动改变大小、双击标题栏最大化等，这些行为需要开发者自己来实现。 本文主要介绍实现无边框窗体的几种方案，并在最后分享了作者实现的方案。 笔者认为，一个完美的无边框窗体解决方案需要支持如下功能： 支持通过使用鼠标拖拽来改变窗体位置和大小； 支持双击标题栏最大化窗体和还原窗体； 支持Windows Areo Snap特性； 支持系统阴影； 支持跨不同DPI的屏幕拖拽； 适应分辨率和DPI改变； 在Qt中实现无边框窗体有2种方案： 一、Hook方案通过重载nativeEvent函数拦截Windows消息（如WM_NCHITTEST）来实现，大致步骤如下： 给窗体设置WS_THICKFRAME | WS_CAPTION属性从而还原窗体边框和标题栏，这样窗体就可以接收到WM_NCHITTEST消息。 在WM_NCCALCSIZE消息处理中再移除边框和标题栏。 在WM_NCHITTEST消息处理中通过判断鼠标位置来设置鼠标行为（HTLEFT, HTRIGHT等）。 这种方案的优点是可以支持Windows Areo Snap和系统阴影的特性，但是针对Windows消息处理起来很复杂而且需要兼容Qt的各个版本，目前我还没有找到一个通过这种方案来完美实现无边框的解决方案。 据我所知，有如下的开源项目是通过这种方式来实现的，但都有些许问题，如不支持跨不同DPI屏幕拖拽、不能适应分辨率和DPI改变、WM_NCHITTEST有时无响应等。另外，在设置了背景透明属性之后（如Qt::WA_TranslucentBackground），系统阴影特性也将消失。 qtdevs/FramelessHelper: https://github.com/qtdevs/FramelessHelper wangwenx190/framelesshelper: https://github.com/wangwenx190/framelesshelper 二、纯Qt方案这种方案不Hook windows的 WM_NCHITTEST、WM_NCCALCSIZE消息，也不改变窗体样式，通过纯Qt方式实现。通过对每个Widget设置MouseTracking，来使每个Widget都可以响应鼠标事件（mouseMoveEvent、mousePressEvent、mouseReleaseEvent等），然后这些事件中判断鼠标位置来设置鼠标的形状和行为。 这种方式虽然对鼠标位置的判断逻辑比较繁琐，但兼容性较好，较纯粹，不需要处理Windows的各个消息。 三、Qt-FramelessWindow👉 我根倾向于使用纯Qt方案，简单、稳定、兼容性好，不用关注那些烦人的Windows消息。针对该方案的实现，可以参考笔者的开源项目【Qt-FramelessWindow】，目前可以支持上述除“Windows Areo Snap”和“系统阴影”特性之外的所有无边框窗体的特性，而且仅有一个头文件，使用起来也非常方便。 Qt-FramelessWindow: https://github.com/winsoft666/Qt-FramelessWindow","link":"/post/2402568381.html"},{"title":"移除Qt控件虚线框","text":"方式一：使用 StyleSheet123QWidget:focus { outline: none; /* 去掉得到焦点时的虚线框 */} 方式二：继承 QProxyStyle继承 QProxyStyle，PrimitiveElement 为 QStyle::PE_FrameFocusRect 时不绘制虚线框，然后在 main() 函数里调用 QApplication::setStyle() 使用新的样式。 123456789101112131415161718192021// 文件名: NoFocusRectStyle.h#ifndef NOFOCUSRECTSTYLE_H#define NOFOCUSRECTSTYLE_H#include &lt;QProxyStyle&gt;class NoFocusRectStyle : public QProxyStyle{public: NoFocusRectStyle(QStyle *baseStyle) : QProxyStyle(baseStyle) {} void drawPrimitive(PrimitiveElement element, const QStyleOption *option, QPainter *painter, const QWidget *widget = 0) const{ if (element == QStyle::PE_FrameFocusRect) { return; } QProxyStyle::drawPrimitive(element, option, painter, widget); }};#endif // NOFOCUSRECTSTYLE_H 12345678910111213// 文件名: main.cpp#include \"Widget.h\"#include \"NoFocusRectStyle.h\"#include &lt;QApplication&gt;int main(int argc, char *argv[]){ QApplication app(argc, argv); NoFocusRectStyle *style = new NoFocusRectStyle(app.style()); app.setStyle(style); // Ownership of the style object is transferred to QApplication Widget w; w.show(); return app.exec();}","link":"/post/2202762022.html"},{"title":"继承自QWidget的控件无法应用QSS样式","text":"这是一个老生常谈的问题，在使用Qt进行界面开发时，我们经常会继承自QWidget来实现自定义控件，此时我们发现在该自定义控件上应用QSS样式会无效。 导致这个问题的主要原因是QWidget的paintEvent函数实现为空，未做任何绘制（包含样式表的初始化和绘制），其代码如下： 123void QWidget::paintEvent(QPaintEvent *){} 解决这个问题也比较简单，在QWidget子类的paintEvent函数中初始化并绘制样式表： 123456void CustomWidget::paintEvent(QPaintEvent* e) { QStyleOption opt; opt.init(this); QPainter p(this); style()-&gt;drawPrimitive(QStyle::PE_Widget, &amp;opt, &amp;p, this);} 当然我们也可以采用变通的方法，改为继承自QFrame，因此QFrame默认初始化和绘制了样式表，其代码如下： 1234567891011121314151617void QFrame::paintEvent(QPaintEvent *){ QPainter paint(this); drawFrame(&amp;paint);}/*! \\internal Used by QLabel and QLCDNumber */void QFrame::drawFrame(QPainter *p){ QStyleOptionFrame opt; initStyleOption(&amp;opt); style()-&gt;drawControl(QStyle::CE_ShapedFrame, &amp;opt, p, this);}","link":"/post/10890071.html"},{"title":"ECMAScript6基础语法","text":"ECMAScript 标准的发展经历了一个漫长的过程，从 1997 年发布的ECMAScript 1.0，到 2011 年的ECMAScript 5.1，再到 2015 年的ECMAScript 2015，以及后面每年都会发布的一个新的 ECMAScript 版本，版本众多，而且每个版本都有新特性的加入。 我们通常用ECMAScript 6来统称ECMAScript 2015及其之后的的版本。 但ECMAScript 2015可谓是 ECMAScript 标准的分水岭，其从制定到发布前后经历了 15 年。目前绝大多数浏览器都已支持ECMAScript 2015特性，并部分的支持了后面版本的新特性，所以对于需要快速入门的初学者，只需要直接学习ECMAScript 2015标准即可，编写完全遵守ECMAScript 2015标准的代码不仅更加严谨，而且可以节省不少学习时间。 即便对于那些不支持ECMAScript 6的浏览器（如 IE11），我们也可以使用Babel之类的工具将其转换为ECMAScript 5标准的代码。 查看浏览器对 ES 特性的支持情况，可以访问：https://kangax.github.io/compat-table/es6/ 下文讲述的都是支持 ECMAScript 6 标准的 JavaScript 语法 零 JavaScript 是大小写敏感的 在每行只写一条语句时，结尾可以不加分号;，但建议每条语句都以分号结尾 一、七种基本数据类型基本数据类型有以下 7 种： undefined null Boolean String Number Object Symbol JavaScript 虽然是弱类型的语言，但不代表其没有数据类型，其弱类型指的是在声明变量的时候不需要（也不能）指明变量类型，编译器会根据“值”的类型自动将变量转换成合适的类型。 所以无论是值还是变量终究还是有类型的，对于开发者而言，不需要关注什么类型的值应该赋值给什么类型的变量。 我们可以使用typeof查看每个变量或值的类型： 1234567console.log(typeof 123); // numberconsole.log(typeof \"abc\"); // stringconsole.log(typeof true); // booleanconsole.log(typeof undefined); // undefinedconsole.log(typeof null); // objectconsole.log(typeof [1, 2, 3, 4]); // objectconsole.log(typeof function () {}); // function 值得注意的是undefined的类型是undefined，但null的类型是object，下面的章节会介绍undefined和null的区别。 二、变量声明方式声明变量的方式有 3 种： let 用来声明变量 var 也是用来声明变量的 const 用来声明常量，必须在声明的时候赋初始值，且以后不能再修改 var是ES6之前的，建议不要在代码中使用 var，这样可以避免很多不必要的问题，比如变量提升、暂时性死区等，本文也只讲述let和const，忘记var吧，一起走向新世界。 2.1 变量具有作用域的概念用 let 和 const 声明的变量或常量的作用域可以精确到“块级别” 12345{ let a = 1; console.log(a); // 1}console.log(a); // ReferenceError: a is not defined 1234for (let i = 0; i &lt; 10; i++) { console.log(i); // 依次输出0~9}console.log(i); // ReferenceError: i is not defined 1234567let a = 123;if (true) { let a = 789;}console.log(a); // 123 12345678910// 无论是let还是const都是一样的，在同一个作用域内不能重复声明{ let a = 123; let a = 456; // SyntaxError: Identifier 'a' has already been declared}{ let a = 123; const a = 456; // SyntaxError: Identifier 'a' has already been declared} 2.2 块级作用域内的 let只要“块级作用域内”存在 let 命令，它所声明的变量就“绑定”到这个区域，不再受外部的影响 12345678let a = 123;if (true) { a = 456; // ReferenceError: Cannot access 'a' before initialization let a = 789;}console.log(a); // 123 这个和其他语言不太一样，如果是 C/C++这样的语言是不会报错的，只会在let a = 789;给出“局部变量覆盖了全局变量”的警告。 但在 ES6 中却会报错，我们可以这样理解为“强龙压不过地头蛇”：我用let a = 789;在蓝色区域内声明了变量a，那么在这个蓝色区域的一亩三分地内的都是我说了算，a = 456;敢在我还没声明前都赋值，那我还不给你报个错。 2.3 for 循环的变量作用域for 循环设置循环变量的部分是一个父作用域，而循环体内部是一个单独的子作用域 1234for (let i = 0; i &lt; 10; i++) { let i = \"abc\"; console.log(i); // abc} 虽然编译器没有报错，但尽量不要写这样代码，不利于后期维护。 三、Object 与 ClassObject（对象）是 ES5 就已经有的概念，Class（类）是 ES6 引入的概念。 3.1 关于 JavaScript 中类和对象的叫法学过任何一个面向对象编程语言的同学都知道，对象是类的实例，比如在 Java 中： 1A a = new A(); a为对象，A为类，也就是“对象 a 为类型 A 的实例”。 而大家可能也发现了很多 JavaScript 教程称Object、Number、String为对象，如果根据这个称呼来，下面的代码岂不是“对象 a 为对象 Number 的实例”，很显然在这种叫法很别扭，也不科学： 1let a = new Number(123); 为什么会出现这种蹩脚的叫法了？因为在 ES6 之前，JavaScript 中没有完全引入Class类的概念，其最多只能算是一个伪的面向对象语言，估计也是为了降低学习理解的难度，所以统称为对象吧。 既然在 ES6 中明确引入了 Class 概念，我们在学习的时候就要明确区分“类”和“对象”的概念了。 3.2 万物皆对象在 JavaScript 中万物皆对象。学过其他面向对象编程语言的同学知道，对象是类的实例，每个类都可以有构造函数、析构函数、属性和方法。 在 JavaScript 中，每个对象都有构造函数、属性、方法，但没有析构函数，我们可以通过下面的代码来验证“万物皆对象”： 1234console.log(\"John\".constructor); // [Function: String]console.log((3.14).constructor); // [Function: Number]console.log(false.constructor); // [Function: Boolean]console.log({ name: \"John\", age: 34 }.constructor); // [Function: Object] 3.2.1 隐式声明对象JavaScript 访问属性和方法的方式和其他面向对象语言类似： 1234567891011let msg1 = \"Hello World!\"; // msg1为对象，String类的实例let x = msg1.length; // 访问length属性console.log(x); // 12let msg2 = \"Hello world!\"; // // msg2为对象，String类的实例let y = msg2.toUpperCase(); // 访问toUpperCase方法console.log(y); // HELLO WORLD!let car = { name: \"BMW\", price: 123000 }; // car也为对象，{name: \"BMW\", price: 123000}类的实例console.log(car.name); // BMWconsole.log(car.price); // 123000 大家可以看到上面的代码中都没有使用new来声明对象，但这些对象确确实实存在了，不然我们也无法访问其“属性”和“方法”，我们可以姑且认为这是 JavaScript 的语法糖吧，或者叫“隐式声明对象”吧。 3.2.2 显式声明对象前面介绍的 8 种基本数据类型中除了null和undefined之外，都可以使用 new 来显示的声明对象： 12345678910111213let a1 = new Number(123);console.log(a1); // [Number: 123]console.log(1 + a1); // 124let a2 = new Function();console.log(a2); // [Function: anonymous]let a3 = new String(\"xyz\");console.log(a3); // [String: 'xyz']let a4 = new null(); // TypeError: null is not a constructorlet a5 = new undefined(); // TypeError: null is not a constructor 3.3 使用 Class 定义类在 ES6 中可以使用 Class 关键字定义类，且每个类都有默认的 name 属性。 1234567891011121314151617181920212223242526272829303132333435363738class Rectangle { // 构造函数 // constructor方法名称不能修改 // 通过new命令生成对象实例时，自动调用该方法。 // 一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加 constructor(h, w) { this.height = h; this.width = w; } // Getter get area() { return this.calcArea(); } // Settter set setWidth(w) { this.width = w; } // 方法 calcArea() { return this.height * this.width; } // 静态方法 static printInfo(w, h) { console.log(\"width:\" + w + \", height:\" + h); }}// 注意：这个name属性是通过类本身来访问的，而不是类的实例来访问的，是不是有点乱了。。。console.log(Rectangle.name); // Rectanglelet rect = new Rectangle(5, 6);console.log(rect.area); // 30//rect.printInfo(); // TypeError: rect.printInfo is not a functionRectangle.printInfo(5, 6); // width:5, height:6 Class 的成员都是公共的，外部都可以访问，目前没有从语法层面规定如何定义一个私有的成员 类表达式一个类表达式是定义一个类的另一种方式。类表达式可以是具名的或匿名的。 一个具名类表达式的名称是类内的一个局部属性，它可以通过类的 name 属性来获取。 1234567891011121314151617// 匿名类let Rectangle1 = class { constructor(height, width) { this.height = height; this.width = width; }};console.log(Rectangle1.name); // Rectangle1// 具名类let RectangleX = class Rectangle2 { constructor(height, width) { this.height = height; this.width = width; }};console.log(RectangleX.name); // Rectangle2 四、函数4.1 函数参数是默认声明的变量123function foo1(x) { let x = 0; // SyntaxError: Identifier 'x' has already been declared} 4.2 函数参数可以有默认值1234function foo2(x, y = 1) { console.log(x + y);}foo2(1); // 2 与 C++不同，JavaSript 没有要求拥有默认值的参数必须放在参数列表的尾部，所以可以这样写： 123function foo2(x = 1, y) { console.log(x + y);} 但仔细想一想，这样写并没有什么实际意义。 另外值得注意的是，函数参数的默认值是每次函数调用时都会动态计算的： 123456789let x = 99;function foo(p = x + 1) { console.log(p);}foo(); // 100x = 100;foo(); // 101 4.3 箭头函数123456789function foo(x, y) { return x + y;}// 等同于(x, y) =&gt; { return x + y;}; 如果函数只有一个参数： 123456789101112131415function foo(x) { return x * x;}// 等同于(x) =&gt; { return x * x;};// 括号可以省略，等同于(x) =&gt; { return x * x;}; 如果函数没有返回值大括号可以省略： 1234567function foo() { console.log(\"hi\");}// 大括号可以省略，等同于() =&gt; console.log(\"hi\"); 4.4 函数的 name，length 属性name可以返回函数名；length可以返回没有指定默认值的参数个数； 五、数据结构5.1 Object我们可以向 Object 对象添加任何属性，所以 Object 也是一个容器或集合： 12345678910let obj = new Object(\"hello\");console.log(obj); // [String: 'hello']obj.name = \"jeff\";console.log(obj.name); // jeffobj.print = function () { console.log(\"I'm object\");};obj.print(); // I'm object 5.2 数组JavaScript 中使用 Array 类创建数组对象： 12345678910111213141516171819202122232425// 使用Array类创建数组let cars1 = new Array(\"Saab\", \"Volvo\", \"BMW\");// 使用Array类创建数组let cars2 = new Array();cars2[0] = \"Saab\"; // 支持[]方式访问和赋值，下标从0开始cars2[1] = \"Volvo\";cars2[2] = \"BMW\";// 简写方式let cars3 = [\"Saab\", \"Volvo\", \"BMW\"];console.log(cars3.length); // 3// 数组中的元素可以为不同的类型let a = [1, \"x\", true];console.log(a[1]); // xconsole.log(a[5]); // undefined，访问数组中不存在的元素会返回undefined，不会报错a.testProp = \"xyz\"; // 可以向Array对象添加任意属性console.log(a.testProp); // xyza.print = function () { console.log(\"I'm a\");};a.print(); // I'm a 5.2.1 Array 类完整的属性 属性 描述 length 设置或获取数组元素的个数 prototype 允许你向数组对象添加属性或方法 5.2.2 Array 类完整的方法 方法 描述 concat() 连接两个或更多的数组，并返回结果 copyWithin() 从数组的指定位置拷贝元素到数组的另一个指定位置中 entries() 返回数组的可迭代对象 every() 检测数值元素的每个元素是否都符合条件 fill() 使用一个固定值来填充数组 filter() 检测数值元素，并返回符合条件所有元素的数组 find() 返回符合传入测试（函数）条件的数组元素 findIndex() 返回符合传入测试（函数）条件的数组元素索引 forEach() 数组每个元素都执行一次回调函数 from() 通过给定的对象中创建一个数组 includes() 判断一个数组是否包含一个指定的值 indexOf() 搜索数组中的元素，并返回它所在的位置 isArray() 判断对象是否为数组 join() 把数组的所有元素放入一个字符串 keys() 返回数组的可迭代对象，包含原始数组的键(key) lastIndexOf() 搜索数组中的元素，并返回它最后出现的位置 map() 通过指定函数处理数组的每个元素，并返回处理后的数组 pop() 删除数组的最后一个元素并返回删除的元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度 reduce() 将数组元素计算为一个值（从左到右） reduceRight() 将数组元素计算为一个值（从右到左） reverse() 反转数组的元素顺序 shift() 删除并返回数组的第一个元素 slice() 选取数组的一部分，并返回一个新数组 some() 检测数组元素中是否有元素符合指定条件 sort() 对数组的元素进行排序 splice() 从数组中添加或删除元素 toString() 把数组转换为字符串，并返回结果 unshift() 向数组的开头添加一个或更多元素，并返回新的长度 valueOf() 返回数组对象的原始值 5.2.3 数组的复制123456let a1 = [1, 2, 3];let a2 = a1;a2[1] = 4;console.log(a1[1]); // 4 从上面的例子中，我们发现改变数组a2[1]的值时，数组a1[1]的值也随着改变了，这说明 a1 和 a2 指向的是同一块内存区域，这个在 C/C++中就是指针的概念，let a2 = a1; 做的是浅拷贝操作。 如果需要做深拷贝，也就是将数组 a1 的所有元素克隆一份给 a2，可以通过下面的两种方式： 123456let a1 = [1, 2, 3];let a2 = a1.concat();a2[1] = 4;console.log(a1[1]); // 2 123456let a1 = [1, 2, 3];let a2 = [...a1]; // 也可以写成 let [...a2] = a1;a2[1] = 4;console.log(a1[1]); // 2 5.3 MapMap 对象用来存储键值对(key-value)，并且能够记住键的原始插入顺序。任何对象都可以作为键或值。在 Map 中 Key 是唯一的。 1234567891011121314151617181920212223242526272829303132let myMap = new Map();let keyObj = {};let keyFunc = function () {};let keyString = \"a string\";// 添加键myMap.set(keyString, \"和键'a string'关联的值\");myMap.set(keyObj, \"和键keyObj关联的值\");myMap.set(keyFunc, \"和键keyFunc关联的值\");console.log(myMap.size); // 3// 读取值console.log(myMap.get(keyString)); // 和键'a string'关联的值console.log(myMap.get(\"a string\")); // 和键'a string'关联的值console.log(myMap.get(keyObj)); // 和键keyObj关联的值console.log(myMap.get(keyFunc)); // 和键keyFunc关联的值console.log(myMap.get({})); // undefined, 因为keyObj !== {}console.log(myMap.get(function () {})); // undefined, 因为keyFunc !== function () {}console.log(myMap.size); // 3，返回有多少个键值对// 和Array一样，可以添加任意属性和方法myMap.test = \"a\";console.log(myMap.test);myMap.print = function () { console.log(\"I'm map\");};myMap.print(); // I'm map 5.3.1 Map 与 Array 相互转换Array =&gt; Map 123456let map = new Map([ [1, \"one\"], [2, \"two\"],]);console.log(map); // Map { 1 =&gt; 'one', 2 =&gt; 'two' } Map =&gt; Array 123456let map = new Map();map.set(1, \"one\");map.set(2, \"tow\");let arr2 = Array.from(map);console.log(arr2); // [ [ 1, 'one' ], [ 2, 'two' ] ] 5.3.2 Map 的复制Map 在直接赋值的时候会遇到和 Array 同样的“浅拷贝”的问题，如： 123456789let map1 = new Map();map1.set(1, \"one\");map1.set(2, \"tow\");let map2 = map1;map2.set(1, \"three\");console.log(map1.get(1)); // three，修改map2会导致map1的值也被修改了 可以通过下面的方式完成 Map 的深拷贝： 12345678910let map1 = new Map();map1.set(1, \"one\");map1.set(2, \"tow\");let map2 = new Map(map1);map2.set(1, \"three\");console.log(map1.get(1)); // oneconsole.log(map2.get(1)); // three 5.4 SetMap 是键值对的集合，而 Set 则只是键（key）的集合。 Set 中的每个元素都是唯一的。 任何对象都可以作为 Set 的元素。 1234567891011121314let keys = [1, 1, 2, 3, \"str\"];let s = new Set(keys);// 自动去重了console.log(s); // Set { 1, 2, 3, 'str' }// 新增使用Adds.add(9);s.add(function () {});console.log(s); // Set { 1, 2, 3, 'str', 9, [Function] }// 删除使用deletes.delete(1);console.log(s); // Set { 2, 3, 'str', 9, [Function] } 5.5 迭代器前面介绍 Object、Array、Map、Set 这些容器的时候，都避开了一个话题：遍历。本节主要介绍如何遍历 JavaScript 中的容器或集合。 迭代器（Iterator）就是一个接口，为各种不同的数据结构提供统一的遍历访问机制。任何数据结构只要实现 Iterator 接口，就可以完成遍历操作。 在学习如何自定义迭代器之前，我们先学习一下如何遍历 JavaScript 常用的数据集合： 5.5.1 遍历字符串12345678910111213let str = \"hello\";for (let v of str) { console.log(v);}/*hello*/ 5.5.2 遍历数组123456789let arr = [1, \"str\", 2];for (let v of arr) { console.log(v);}/*1str2*/ 5.5.3 遍历 Map123456789101112131415let map = new Map([ [1, \"one\"], [2, \"two\"], [3, function () {}],]);for (let [k, v] of map) { console.log(k + \":\" + v);}/*1:one2:two3:function () { }*/ 六、解构赋值解构(Destructuring)赋值分为“数组的解构赋值”和“对象的解构赋值”。 6.1 数组的解构赋值123456789101112131415161718192021222324252627282930313233343536373839404142434445let [a, b, c] = [1, 2, 3]; // 根据位置依次取值// a = 1// b = 2// c = 3let [foo, [[bar], baz]] = [1, [[2], 3]];// foo = 1// bar = 2// baz = 3let [ , , third] = [\"foo\", \"bar\", \"baz\"];// third = \"baz\"let [head, ...tail] = [1, 2, 3, 4];// head = 1// tail = [2,3,4]let [x, y, ...z] = [\"a\"];// x = \"a\"// y = undefined// z = []let [foo] = []; // foo = undefinedlet [bar, foo] = [1]; // foo = undefinedlet [bar, foo = true] = [1]; // 可以赋默认值// bar = 1// foo = truelet [x, y] = [1, 2, 3];// x = 1// y = 2let [a, [b], d] = [1, [2, 3], 4];// a = 1// b = 2// d = 4 6.2 对象的解构赋值1234567891011let { foo, bar } = { foo: \"aaa\", bar: \"bbb\" }; // 和顺序没关系，根据属性名来取值// foo = \"aaa\"// bar = \"bbb\"let { foo } = { bar: \"baz\" };// foo = undefined// 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量// 如：console对象有log方法，我们可以这样使用：const { log } = console;log(\"hello\"); // hello 七、promise、async、awaitpromise、async、await 这三个关键字都和异步编程有关。 7.1 PromisePromise 翻译成中文就是“承诺”的意思，声明一个 Promise 就是立下了一个承诺，无论怎么样，都会给被承诺人一个结果，而且这个结果是板上钉钉的，不会再变。 Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。 声明 Promise 对象时需要传入一个函数对象作为参数，这个函数对象的 2 个参数也是函数对象（resolve, reject），resolve和reject不需要开发者定义，Javascript 引擎会自动生成这 2 个函数。 当 Promise 对象生成后会立即变成pending状态，调用resolve函数会将 Promise 对象标记为fulfilled状态，而调用reject函数则会将当前 Promise 对象标记rejected状态。 resolve和rejected函数，我们只能调用它们中的一个，不能即调用resolve又调用rejected。如果我们先调用了resolve，此时 Promise 状态会标记为fulfilled，然后又调用了rejected函数，此时 Promise 状态并不会再改变，仍然使fulfilled状态，因为承诺的结果是板上钉钉的，不会再变。建议将resolve和reject作为最后一行代码调用，简单起见，可以在这 2 个函数前面加上return, 即return resolve();或return reject(); 123456789101112// Promise的参数为一个函数对象，函数有2个参数resolve, rejectlet promise = new Promise((resolve, reject) =&gt; { // 做一些耗时的操作，比如网络请求 // 这里我们使用一个延时器来模拟耗时的网络请求 setTimeout(() =&gt; { // 延时1000ms之后成功 resolve(\"ok\"); }, 1000); // 成功则调用 resolve(); // 失败则调用 reject();}); 那么，我想在这个异步操作完成之后，再根据结果（是成功了，还是失败了）来继续做下一件事情，那我们该怎么做了？Promise 对象提供了then方法，该方法接受 2 个函数对象作为参数：第一个回调函数是 Promise 对象的状态变为resolved时调用;第二个回调函数是 Promise 对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。每个回调函数都可以接受一个参数，这个参数就是上一步调用 resolve 或 reject 时传入的。 12345678910111213// 上面的耗时操作完成之后，我们可能还需要根据结果来继续做一些事情// 此时就可以使用then，then函数有2个参数，分别为2个函数对象。// 上一步操作中，如果调用resolve(data)，则then函数第一个函数对象参数会被调用；// 如果调用reject(data)，则then函数第二个函数对象参数会被调用promise.then( (data) =&gt; { console.log(\"resolve1: \" + data); return \"hello\"; }, (data) =&gt; { console.log(\"reject1: \" + data); }); 在这个例子中，我在第一个参数中直接通过 return 返回了”hello”字符串，那这个返回值的意义在哪里了？还有其他人可以使用到这个返回值吗？是的，还可以继续使用。因为then的返回值是一个 Promise 对象，虽然我只是使用的return \"hello\";，并没有new Promise，但 JavaScript 引擎会自动包装成一个 Promise 对象，等同于： 1234567891011promise.then( (data) =&gt; { console.log(\"resolve1: \" + data); return new Promise((resolve, reject) =&gt; { return resolve(\"hello\"); }); }, (data) =&gt; { console.log(\"reject1: \" + data); }); 到这儿了，我们知道了then的返回的是一个Promise对象。既然then返回的是Promise对象，那么Promise就可以继续then呀，然后一直then下去….这样我们就可以将一系列异步的操作串联起来了： 12345678910111213let p = new Promise((resolve, reject) =&gt; { // ... // resolve(); 或 reject();}) .then(() =&gt; { // ... }) .then(() =&gt; { // ... }) .then(() =&gt; { // ... }); 但多个异步操作串联执行，还有一点需要注意，我们看下面的例子： 1234567891011121314151617let promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { // 延时1000ms resolve(\"ok1\"); }, 1000);}) .then((data) =&gt; { console.log(\"resolve1: \" + data); setTimeout(() =&gt; { // 延时1000ms return \"ok2\"; }, 1000); }) .then((data) =&gt; { console.log(\"resolve2: \" + data); }); 我们期望的输出是： 12resolve1: ok1;resolve2: ok2; 但实际的输出却是： 12resolve1: ok1;resolve2: undefined; 问题出在第二个 setTimeout 模拟的耗时操作，我们以为程序会等第二个 setTimeout 执行完了再执行第二个 then，但事实上 setTimeout 也是一个异步操作，虽然其延时了一秒执行其回调函数，但 setTimeout 这条语句却马上执行完成了，导致第一个 then 没有任何返回，针对这种情况，我们需要将代码改成下面的： 12345678910111213141516171819let promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { // 延时1000ms resolve(\"ok1\"); }, 1000);}) .then((data) =&gt; { console.log(\"resolve1: \" + data); return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { // 延时1000ms resolve(\"ok2\"); }, 1000); }); }) .then((data) =&gt; { console.log(\"resolve2: \" + data); }); 7.2 Promise 异常捕获Promise 对象还提供了catch方法，用来捕获异常。在介绍catch前，我们先看看下面的代码： 1234567891011121314let promise = new Promise((resolve, reject) =&gt; { throw new Error(\"an error\"); resolve(\"ok\");}).then( (data) =&gt; { console.log(\"resolve: \" + data); }, (data) =&gt; { console.log(\"reject: \" + data); });// 输出：// reject: Error: an error 我们在 Promise 中人为抛出了一个异常，但是程序却还是没有中止，而是运行到了 reject 过程中去了。 这是因为 Promise 默认会捕获其操作过程中的异常，如果有异常发生，其状态就会自动变成rejected，还记得前面说过 Promise 状态一旦确定就不会再改变了吧，所以即便后面的resolve(\"ok\");执行了，也不会改变 promise 状态（事实上 throw 语句后的代码并没有机会执行）。 那么，假如我们没有写 reject 回调函数会怎么样了？看看下面的代码： 123456let promise = new Promise((resolve, reject) =&gt; { throw new Error(\"an error\"); resolve(\"ok\");}).then((data) =&gt; { console.log(\"resolve: \" + data);}); 上面的代码中由于没有指定异常处理函数，所以程序抛出了异常信息，中止执行了。 另外，Promise 的异常是会一直向下传递的，直到最后有人处理，如果始终没人处理，程序就会抛出异常信息，然后中止： 123456789101112131415161718let promise = new Promise((resolve, reject) =&gt; { throw new Error(\"an error\"); resolve(\"ok\");}) .then((data) =&gt; { console.log(\"resolve1: \" + data); }) .then( (data) =&gt; { console.log(\"resolve2: \" + data); }, (data) =&gt; { console.log(\"reject2: \" + data); } );// 输出：// reject: Error: an error 上面的代码中，第一个 then 没有处理异常，异常向下传递给第二个 then, 第二个 then 处理了该异常，程序继续运行。 现在理解Promise.catch()方法就容易多了。catch()方法其实就是.then(null, rejectiion)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 我们一般总是建议，Promise 对象后面要跟 catch()方法，这样可以处理 Promise 内部发生的错误。catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then()方法。 7.3 async, awaitasync 是ES7才有的与异步操作有关的关键字，需要和Promise配合使用，async函数返回一个 Promise对象，可以使用then方法添加回调函数： 12345678910111213async function helloAsync() { return \"helloAsync\";}console.log(helloAsync());helloAsync().then((v) =&gt; { console.log(v);});// 输出：// Promise { 'helloAsync' }// helloAsync await关键字只能用在被async标记的函数体内，async函数执行时，如果遇到await就会先暂停执行，等到触发的异步操作完成后，恢复async函数的执行并返回解析值。 123456789101112131415161718function testAwait() { return new Promise((resolve) =&gt; { setTimeout(function () { console.log(\"testAwait\"); resolve(); }, 1000); });}async function helloAsync() { await testAwait(); console.log(\"helloAsync\");}helloAsync();// 输出：// testAwait// helloAsync","link":"/post/51642520.html"},{"title":"NPM和Yarn设置国内源","text":"1. Yarn 设置查看当前使用的镜像源： 1yarn config get registry 全局修改： 12345678yarn config set registry https://registry.npm.taobao.org -gyarn config set disturl https://npm.taobao.org/dist -gyarn config set electron_mirror https://npm.taobao.org/mirrors/electron/ -gyarn config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ -gyarn config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/ -gyarn config set chromedriver_cdnurl https://cdn.npm.taobao.org/dist/chromedriver -gyarn config set operadriver_cdnurl https://cdn.npm.taobao.org/dist/operadriver -gyarn config set fse_binary_host_mirror https://npm.taobao.org/mirrors/fsevents -g 临时修改： 1yarn save 软件名 --registry https://registry.npm.taobao.org/ 2. NPM 设置查看当前使用的镜像源： 1npm get registry 全局设置： 12345npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/distnpm config set electron_mirror https://npm.taobao.org/mirrors/electron/npm config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/npm config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/ npm v9 版本会报错：ELECTRON_MIRROR is not a valid npm option。需要切换为 npm v8 版本：npm install -g npm@^8","link":"/post/908211703.html"},{"title":"Typescript基础语法","text":"如果你还不了解 TypeScript 是什么，或者其与 JavaScript 之前的关系，可以参考：- 前后端常用概念扫盲 TypeScript 是 JavaScript 的一个超集，支持 ES6 的语法规范，并在此基础上进行了增强，二者最大的不同在于：TypeScript 是强类型语言，而 JavaScript 是弱类型的语言。 本文将着重介绍二者的不同之处。 一、变量声明TypeScript 支持使用var、let、const进行变量声明，但建议不要使用var。TypeScript 声明变量时，可以强制指定变量类型或者由编译器自动从“值”推导出变量类型，但无论哪种情况，一旦确定了类型，后面不能再次被赋值为其他类型： 123456789let a = 1;a = 10;a = \"x\"; ❌let b : number = 12;let c : number = \"x\"; ❌let fibonacci: number[] = [1, 1, 2, 3, 5];let fibonacci: number[] = [1, '1', 2, 3, 5];❌ 二、函数参数TypeScript 要求：调用函数时传入的参数必须与函数声明的参数一致（个数及类型），如： 123456function sum(x: number, y: number): number { return x + y;}sum(1, 2, 3); ❌sum(1);❌sum(1, \"x\"); ❌ TypeScript 要求：可选参数必须在参数列表的最后，如： 1234567function buildName(firstName?: string, lastName: string) {❌ if (firstName) { return firstName + ' ' + lastName; } else { return lastName; }} 三、枚举枚举是 TypeScript 特有的：第一个元素没有赋值，则默认为 0，后面的元素的值依此递增： 123456789enum Days { Sun, // 0 Mon, // 1 Tue, // 2 Wed, Thu, Fri, Sat}; 也支持： 123456789enum Days { Sun = 1, // 1 Mon, // 2 Tue, // 3 Wed = 10, // 10 Thu, // 11 Fri, // 12 Sat // 13}; 枚举元素可以是常量值或是可以通过编译期计算得出的值： 123456789enum FileAccess { // 常量值 None, // 0 Read = 1 &lt;&lt; 1, Write = 1 &lt;&lt; 2, ReadWrite = Read | Write, // 计算得出的值 G = \"123\".length} 四、类相比ES6，TypeScript新增了继承、成员访问控制修饰符。越来越有 Java、C++的味道了。 4.1 继承、成员访问控制修饰符TypeScript 继承需要使用extends关键字，只支持单继承，这点不同于 C++。类继承后，子类可以重写父类的方法。 123456789101112131415161718192021222324252627282930313233343536class Person { private id: string; // 私有的，只能被自身访问 protected name: string; // 受保护，可以被其自身以及其子类和父类访问 protected age: number; // 公开的 public getId() : string { return this.id; } public getName() : string { return this.name; } public getAge() : number { return this.age; } public print() : void { console.log(\"name:\" + this.name + \", age:\" + this.age); }}class Student extends Person { private grade : number; public getGrade() : number { return this.grade; } public print() : void { // 重写了父类的方法 super.print(); // 使用super直接调用父类方法 console.log(\"grade:\" + this.grade); }} 4.2 instanceofinstanceof 运算符用于判断对象是否是指定的类型，如果是返回true，否则返回false。 123class Person {}let obj = new Person();let isPerson: boolean = obj instanceof Person; 4.3 interface 接口TypeScript 新增 interface 接口的概念，这个接口的概念和 Java 中的 interface 类似，即：只有定义没有实现。 同时，接口也支持继承。 1234567891011121314interface IPerson { name: string;}interface IStudent extends IPerson { // 接口的继承 grade: number;}class Student implements IStudent { // 实现接口的类 name: string; grade: number;} 五、命名空间TypeScript 中的命名空间的概念和 C++中的命名空间的概念一样，而且关键字也都是namespace。 稍有不同的是，C++不需要将命名空间中的内容暴露出来，C++默认就是全部暴露的，而 TypeScript 需要手动添加 export 关键字将命名空间的中的内容暴露出来： 12345678910namespace XYZ { export let name : string; export class Person { } export interface IPerson { }}XYZ.name = \"jeff\";","link":"/post/2248228478.html"},{"title":"前后端常用概念扫盲","text":"本文主要介绍前后端及客户端开发中遇到的一些常用的技术概念，本文不会涉及太深奥的技术细节。 1. 浏览器内核在 Web 大行其道的时代，网民需要上网浏览网页就需要依赖浏览器这个软件，掌握了浏览器就掌握了流量的入口，于是各大软件公司开始研发自己品牌的浏览器，不同品牌的浏览器其实现原理当然是有区别的，这个实现原理就是浏览器的核心，我们称其浏览器内核。 现在市面上有这么多的浏览器，如 Chrome，QQ 浏览器，搜狗浏览器，这些浏览器厂商是不是都是自己研发浏览器内核了？不是的！ 因为有些公司或者团体将浏览器内核进行了开源，方便其他人基于该内核进行二次开发，常见的开源浏览器内核有 Chromium、WebKit、Gecko。 正因为有了这些开源内核的存在，我们可以不用自己开发内核也可以开发属于自己品牌的浏览器，比如 QQ 浏览器，搜狗浏览器，360 浏览器都是基于 IE 内核和 Chromium 内核二次封装而成，美其名曰双引擎（双内核）。 目前市面上流行的拥有自主内核的浏览器： 浏览器 内核 Chrome Chromium Safari WebKit Firefox Gecko IE IE 内核 2. JavaScript, ECMAScript, ES6, TypeScriptJavaScript是一个编程语言的名称，类似 Java，C++，PHP，是由 Netscape 公司开发的一种解释性编程语言，其运行的宿主环境大多是浏览器，但也可以是其他环境，如 Node。 因为 Netscape 公司希望JavaScript成为一种浏览器脚本语言的标准规范，于是在 1996 年将 JavaScript 提交给标准化组织 ECMA。次年，ECMA 就发布了标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种标准称为 ECMAScript。 所以说，ECMAScript是一个的浏览器脚本语言的标准规范。 不同的浏览器内核及不同的版本对ECMAScript规范的支持情况不同， 截至 2012 年，所有浏览器都完整的支持ECMAScript 5.1； 从ECMAScript 6开始，标准制定者决定不再用诸如”3.1, 5.0”这样的版本号来命名，而是每年 6 月发布一个 ECMAScript 的正式版，并且以当年的年份来命名， 如 2015 年 6 月 17 日 ECMA 国际组织发布了 ECMAScript 的第六版，该版本正式名称为ECMAScript 2015。 ES6只是ECMAScript 6版本的简称，我们一般用ECMAScript 6来统称ECMAScript 2015及其以后的版本。 TypeScript是由微软开发的一种开源的编程语言。它是 JavaScript 的一个严格超集，并添加了静态类型及其他特性。TypeScript目前已经支持ECMAScript 2015。 3. CSS, CSS3CSS即Cascading Style Sheets层叠样式表的简称，在 Web 开发中用来定义元素样式的一种标记型语言。CSS3是 CSS（层叠样式表）的升级版本，2001 年 5 月 23 日 W3C 完成了 CSS3 的工作草案。 4. V8, Node, Node.js, npm, YarnV8，我们通常叫做 V8 引擎，然而其并不是汽车发动机的 V8 引擎，而是由 Google 开发并开源的一个项目，可以解释和执行 JavaScript，因为其性能非常高，目前得到了广泛的应用，如 Node.js 就是基于该引擎而开发。 Node.js 和 Node 是一个东西，Node 是 Node.js 的简称。 npm（node package management）是 Node.js 的一个包管理工具，目前已经内置到了 Node.js 中，不需要再单独安装。 yarn也是一个包管理工具，由 Facebook、Google、Exponent 和 Tilde 联合推出，其目的是为了弥补 npm 的一些缺陷。 5. React, Vue, Angular这 3 个说白了都是 Javascript 库。 我们最初开发 Web 的时候用的是HTML+CSS+JavaScript，后来有人觉得用纯 js 撸太繁琐了，就有了后来的 jQuery 这样的 JavaScript 库，但随着业务的扩增，数据交互越来越复杂，使用 jQuery 也太繁琐了，于时又有了 React, Vue, Angular 这样的库。 总之，前端生态真繁荣。。。。 6. Ant Design, Element UI前面说到了 React, Vue, Angular，虽然又了这些库，数据交互方面变得简单了，但页面效果还是需要 CSS 和 JS 一行行代码来实现的，比如要实现一个下拉列表，动态按钮等。于时现在又出现了一些基于 React, Vue 和 Angular 这些库的 UI 组件库，这些 UI 库将常用的组件封装好了，在开发中直接引入使用，改改属性，设置下参数即可。 7. Scaffold(脚手架)通俗的讲就是将一些重复性的事情整合成一个工具，这个工具就可以叫脚手架。 8. MySQL, Redis, MongoDB, Oracle, PostgreSQL, NoSQL数据库目前分为关系型数据库和非关系型数据（即 NoSQL），不同类型的数据各有其特点。同样，同一类型但不同品牌的数据库也各有其特点和应用领域 。 不能单纯的评判哪种数据库的好坏，一个项目中可能同时用到多个不同种类的数据库。 1、关系数据库MySQL、MariaDB、PostgreSQL、Microsoft Access、Microsoft SQL Server、Oracle、Sybase 等等。 2、非关系型数据库（NoSQL）BigTable（Google）、Cassandra、MongoDB、CouchDB、Redis 等等。 9. Nginx, Apache都是 Web 服务器，不同的团队研发，各有其优缺点。 10. 反向代理反向代理单纯从名字上理解就是正向代理的反方向。 那什么是正向代理？代理内部网络访问外部网络的代理就是正向代理，比如你需要从公司局域网中的电脑 A 经过代理服务器 B 访问网站 C： 1A --&gt; B --&gt; C 如果你认为 A 是内部网络，C 是外部网络，那 B 就是正向代理； 如果你认为 A 是外部网络，C 是内部网络（当然我们一般不这么认为），那么 B 就是反向代理。 11. RESTful一切具有 REST 特性的服务都可以成为 RESTful 服务，那么 REST 特性是什么了？ REST 是Representational state transfer的缩写，维基百科上的解释为： 1Representational State Transfer (REST) is a software architecture style consisting of guidelines and best practices for creating scalable web services. REST is a coordinated set of constraints applied to the design of components in a distributed hypermedia system that can lead to a more performant and maintainable architecture. REST 是一种架构风格, 只有满足这些约束，才能称之为符合 REST 架构风格。REST 的约束大致包括： 客户端-服务器结构 无状态 可缓存 按需代码（可选） 统一接口 持续更新中….","link":"/post/1162897275.html"},{"title":"搭建JavaScript和TypeScript开发调试环境","text":"一、安装Visual Studio CodeVisual Studio Code（简称VSCode）是由微软开发的一个开源的、跨平台的代码编辑器。Visual Studio Code的优势就是有丰富的扩展包，大多数功能都可以通过安装扩展包的方式来实现。 打开Visual Studio Code官网https://code.visualstudio.com/，根据系统选择对应的版本进行安装： 安装选项可以根据个人喜欢来指定，没有强制的要求。但建议勾选如下4项： 二、配置Visual Studio Code2.1 将默认语言设置为中文安装完Visual Studio Code之后，其界面的默认语言是英文，我们只需要安装“简体中文的语言包”就可以将语言修改为中文：点击左侧“扩展”图标，打开扩展工具栏，输入“Chinese”搜索简体中文语言扩展包，安装完重启Visual Studio Code即可。 三、调试环境选择启动Visual Studio Code，按下快捷键F5，可以看到Visual Studio Code已经内置了几种调试环境的配置：但我们需要使用这些配置还需要安装对应的运行时环境如Node.js、Chrome。 Visual Studio Code也可以调试C++，C#，Python，Go，C++等语言，但需要在launch.json中进行适当的配置，后面在讲解使用Node.js调试TypeScript的时候会介绍如何配置launch.json。 因为Node.js可以直接运行Javascript脚本文件，所以这里我们选择使用Node.js来调试JavaScript。 在开始调试前，我们还需要安装Node.js运行时环境，打开Node.js中文官网https://nodejs.org/zh-cn/，选择长期支持版，下载安装即可（安装完成之后可能需要重启Visual Studio Code）： 四、调试JavaScript打开Visual Studio Code，新建一个JavaScript文件，输入任意JavaScript代码并保存，如：点击左侧工具栏的“运行”图标（快捷键Ctrl+Shift+D）并选择“运行和调试”（或者按F5快捷键），在弹出的调试环境下拉框中中选择“Node.js”，此时就会使用Node.js来运行当前脚本。 此时是看不到console.log的输出，因为其输出到了”调试控制台”，我们需要在“查看”菜单中打开“调试控制台”，再次使用上面步骤运行JavaScript文件即可在“调试控制台”看到运行的输出了。 4.1 断点设置/取消断点：用鼠标点击行号左侧区域（即下图画绿框的区域）即可设置断点，再次点击便是取消断点；也可以使用快捷键F9来设置/取消断点.设置断点后，F5开始调试代码，代码运行到断点处便会暂停，此时我们可以在左侧区域查看当前上下文涉及的”局部变量”和”全局变量”、”调用堆栈”、以及”断点列表”。 4.2 调试快捷键 F5 开始调试或在代码暂停后继续执行到下一处断点 F10 单步执行 F11 单步步入，F10遇到函数不会调试进入函数内部，而F11却可以步入到函数内部 Shift+F11 单步跳出 Shift+F5 停止调试 五、调试TypeScriptNode.js是不能直接运行TypeScript脚本的，我们使用Node.js运行TypeScript脚本一般采用如下方法：使用TypeScript官方提供的tcs工具将TypeScript脚本转化为JavaScript，然后再使用Node.js运行js脚本，大致流程如下： 12tcs --outFile index.js index.tsnode index.js 而Node.js的扩展模块ts-node可以简化上述操作（其内部也是使用的tcs和node），将上面二步操作合二为一： 1ts-node index.ts 所以，我们这里采用ts-node模块来作为TypeScript脚本的运行时环境。 由于我们采用了ts-node工具来运行TypeScript脚本，Visual Studio Code没有内置该工具的调试配置，所以我们需要在luanch.json中自定义一个适用于ts-node的调试环境配置。 注意：如果需要自定义配置，那么工程文件必须在一个单独的目录中，并使用Visual Studio Code打开这个目录（对着目录点右键选择使用Visual Studio Code打开即可） 大致步骤如下： 新建项目目录（假设叫TSDemo） 使用Visual Studio Code打开该目录，并在“查看”菜单中选择打开“终端”（之所以在Visual Studio Code中打开终端，纯属是为了方便，因为在Visual Studio Code中打开终端，终端会自动切换到项目当前目录，且不用多个窗口之间切换）。 在终端中依此执行如下命令： 12345678# 生成package.json文件npm init -y# 安装typescriptnpm install typescript -S # 安装ts-node npm install ts-node -S luanch.json的路径为项目目录\\.vscode\\luanch.json，按照下图依此点击左侧工具栏“运行”-&gt;“创建launch.json文件”： 打开自动生成的luanch.json文件，在configurations节添加如下配置： 12345678910111213141516{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Current TS File\", \"type\": \"node\", \"request\": \"launch\", \"program\": \"${workspaceRoot}/node_modules/ts-node/dist/bin.js\", \"args\": [ \"${relativeFile}\" ], \"cwd\": \"${workspaceRoot}\", \"protocol\": \"inspector\" } ]} 打开需要调试的TypeScript文件，快捷键F5开始调试。 因为ts-node既可以执行TypeScript，也可以执行JavaScript，所以这种方式也可以用来调试JavaScript脚本。","link":"/post/997636699.html"},{"title":"Windows注入与拦截(1)--DLL注入基础","text":"一、DLL 注入技术的用途从Windows内存体系(1)--虚拟地址空间文章中我们可以知道，在 Windows 系统中，每个进程都有自己私有的地址空间。当我们用指针来引用内存的时候，指针的值表示的是进程自己的地址空间的一个虚拟的内存地址。进程不能通过指针来引用其他进程地址空间的内存。因此，如果一个进程有缺陷会导致其引用和覆盖随机地址处的内存，那么这个缺陷的影响就会不会扩散到其他的进程。 独立的地址空间有利于系统的稳定性。但很多时候我们还是需要跨越进程的边界来访问另一个进程地址空间，比如： 我们要从另一个进程创建的窗口来派生子类窗口。比如附着在 windows 资源管理器上的一些小插件等。 我们需要假借其他进程之名做某些事情。 我们需要获取其他进程的更多详细信息，如加载了哪些 dll 等。 我们需要对其他进程的某些操作进程拦截。 干一些羞羞的事情… 为了满足上面的这些需求，我们可以使用 DLL 注入的技术，将我们自己开发的 dll 注入到另一个进程的地址空间中，让 dll 中的代码在该进程的地址空间中执行，那么我们就可以在那个中进程为所欲为了。 二、什么样的 DLL 可以被注入？理论上任何 DLL 都可以被注入到其他进程之中，但是大多数情况下，我们注入到其他进程之中是为了实现某些功能、做某些事情的，所以我们需要在我们的 DLL 被注入之后，DLL 中的功能代码能够被调用执行。 我们知道 DLL 被首次载入到进程中时，会收到DLL_PROCESS_ATTACH的通知，即调用DllMain函数，并且参数fdwReason的值被设为DLL_PROCESS_ATTACH。我们可以在收到DLL_PROCESS_ATTACH通知时开始我们的业务逻辑。 下面是一个最简单的 dll 的源码，在被注入成功后（即收到DLL_PROCESS_ATTACH通知时）弹出消息提示框： 12345678910111213141516171819202122BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved ) { switch(fdwReason) { case DLL_PROCESS_ATTACH: { MessageBox(NULL, TEXT(\"我已经被注入啦\"), TEXT(\"信息\"), MB_ICONINFORMATION); break; } case DLL_THREAD_ATTACH: { break; } case DLL_THREAD_DETACH: { break; } case DLL_PROCESS_DETACH: { break; } } return TRUE;} 但是，如果DLL_PROCESS_ATTACH通知处理过程中的操作被挂起（如消息提示框）或者被阻塞（如用户创建了一个消息循环），这样就会导致目标进程中的LoadLibrary(Ex)函数一直无法返回（dll 都是通过LoadLibrary(Ex)函数来加载的），所以我们一般会在DLL_PROCESS_ATTACH通知处理过程中创建一个子线程，将业务逻辑放置到该子线程中执行，代码如下： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;process.h&gt;unsigned int __stdcall PluginProc(LPVOID pArg) { MessageBox(NULL, TEXT(\"我已经被注入啦\"), TEXT(\"信息\"), MB_OK | MB_ICONASTERISK); return 0;}BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved) { HANDLE hThread = NULL; switch(fdwReason) { case DLL_PROCESS_ATTACH: { hThread = (HANDLE)_beginthreadex(NULL, 0, PluginProc, NULL, 0, NULL); if (hThread) { CloseHandle(hThread); // 关闭句柄，防止句柄泄漏 } break; } case DLL_THREAD_ATTACH: { break; } case DLL_THREAD_DETACH: { break; } case DLL_PROCESS_DETACH: { break; } } return TRUE;} 另外，当 DLL 被从目标进程卸载时，DLL 会收到DLL_PROCESS_DETACH通知，我们需要在该通知的处理过程中做好最后的善后工作，防止资源泄漏、程序崩溃等问题出现。","link":"/post/1504192511.html"},{"title":"Windows注入与拦截(2)--DLL注入的方式","text":"一、使用注册表方式注入1.1 注入方法如题，通过注册表的方式来实现 DLL 注入，我们只需要针对特定的注册表项进行修改即可，有一点需要注意的是：如果被注入的进程是 64 位进程，则注入的 DLL 也需要是 64 位的，同理，注入 32 位的进程也需要是 32 位的 DLL。 另外，根据被注入进程的位数（32 或 64）不同，注册表的位置也不同。 1.1.1 注入 64 位系统上的 32 位进程 将被注入的 DLL 名称填入到AppInit_DLLs注册表项： 1HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\AppInit_DLLs AppInit_DLLs中的文件名通过逗号或空格来分割，所以我们在文件名中要避免使用空格。另外AppInit_DLLs中的第一个文件可以包含路径，而后面的文件的路径则将被忽略。出于这个原因，我们最好将 DLL 文件放到 Windows 的系统目录中。 并将LoadAppInit_DLLs注册表项的值修改为1： 1HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\LoadAppInit_DLLs 1.1.2 注入 64 位进程“注入到 64 位进程”和“注入 64 位系统上的 32 位进程”的步骤类似，区别在于： 1). 注册表位置不一样，注入 64 位进程的注册表分别位于： 12HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\AppInit_DLLsHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\LoadAppInit_DLLs 2). 被注入 DLL 需要是 64 位版本。 1.2 为什么可以这么做？当系统的User32.dll被加载到一个新的进程时，会收到DLL_PROCESS_ATTACH通知，User32.dll在该通知处理过程中读取AppInit_DLLs注册表值，并调用LoadLibrary来加载该项中指定的每个 dll。 1.3 这么做有什么弊端？从上面一节我们知道被注入的 DLL 是通过User32.dll加载到目标进程中去的，这也就要求被注入的目标进程必须使用了User32.dll，基于 GUI 的程序都会使用这个 DLL 文件，而命令行程序一般不会加载User32.dll，所以无法通过这种方式被注入。 系统上所有使用了User32.dll的程序都会被注入，很多时候这也并不是我们想要的。 二、使用钩子方式注入2.1 钩子技术介绍Windows 提供了 3 个 API 让我们可以很方便使用钩子技术将 DLL 文件注入到进程之中： 1234567891011121314151617// 安装指定消息类型的钩子到钩子链中HHOOK SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId);// 从钩子链中删除钩子BOOL UnhookWindowsHookEx(HHOOK hhk);// 将消息转发到钩子链上的下一个钩子LRESULT CallNextHookEx(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam); Hook中文名“钩子”，我们可以把它想象成一个“鱼钩”，用来钩住指定类型的消息。“钩子”可以指定需要钩住哪个线程的消息，可以是当前线程，也可以是所有线程。 当“指定线程”的“指定消息”被钩住时，系统就会将我们的 DLL（如果钩子的处理过程位于 DLL 中）加载到该线程所属进程的地址空间中，并且在该地址空间中调用我们的 DLL 中的钩子处理过程函数，从而实现了注入功能。 我们通过SetWindowsHookEx函数来安装一个钩子，操作系统同时也允许开发人员为“同一个线程”的“同一个消息类型”指定多个钩子，这样就形成了一个“钩子链”（Hook Chain）。 2.1.1 SetWindowsHookEx123456HHOOK SetWindowsHookExA( [in] int idHook, [in] HOOKPROC lpfn, [in] HINSTANCE hmod, [in] DWORD dwThreadId); idHook参数：指定我们需要勾住的消息类型；lpfn参数：函数指针。当 idHook 指定的消息触发时，系统将会调用 lpfn 函数指针。hMod参数：lpfn 函数指针所在 DLL 的句柄。有 2 种情况下这个参数需要传 NULL： lpfn 函数的代码位于本进程内时。 只需要勾住本进程的消息时，即 dwThreadId 参数指定的线程位于当前进程。 dwThreadId参数：线程 ID，用于指定勾住哪个线程的消息。如果传 0，则表示勾住所有线程的指定消息。 SetWindowsHookEx 详细的参数解释可以参考 MSDN：https://msdn.microsoft.com/en-us/library/windows/desktop/ms644990(v=vs.85).aspx 2.1.2 CallNextHookEx当我们的钩子处理函数将消息处理完之后，我们可以选择将消息丢弃，不让钩子链上的后面的钩子处理；也可以选择将消息继续传递下去，从而让其他钩子有处理的机会。 如果需要让其他钩子有处理的机会，我们可以在钩子处理函数的最后调用CallNextHookEx函数。 2.1.3 UnhookWindowsHookExUnhookWindowsHookEx函数用于将指定钩子从钩子链中移除。 即使不调用UnhookWindowsHookEx，在调用SetWindowsHookEx的进程退出后，钩子也将被自动移除。 2.2 钩子实例SetWindowsHookEx函数返回一个HHOOK类型的钩子句柄，CallNextHookEx和UnhookWindowsHookEx函数都需要使用这个句柄作为参数。 如果我们将“注入逻辑”放在独立的 exe 中，将“钩子处理过程”放到独立的 dll 中，那么为了在“钩子处理过程”中调用CallNextHookEx时能够拿到钩子的句柄，我们需要通过其他途径将该句柄从 exe 传递到 dll 中。 所以为了避免传递“钩子句柄”的麻烦，我们将“注入逻辑”和“钩子处理过程”都写入到一个 DLL 之中。我们只需要调用这个 DLL 的导出函数就可以将这个 DLL 注入到指定线程所属的进程中。 示例 DLL 名称为InjectDLL，用于勾住指定窗口的WH_GETMESSAGE消息，我们也可以指定其他的消息类型，如键盘消息等。完整的消息类型可以参考 MSDN 上关于SetWindowsHookEx函数的解释。 InjectDLL的完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;tchar.h&gt;HHOOK g_hook = NULL;BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved) { switch(fdwReason) { case DLL_PROCESS_ATTACH: { break; } case DLL_THREAD_ATTACH: { break; } case DLL_THREAD_DETACH: { break; } case DLL_PROCESS_DETACH: { break; } } return TRUE;}// 提权函数// 参考：https://blog.csdn.net/china_jeffery/article/details/79173417//BOOL EnablePrivilege(LPCTSTR szPrivilege, BOOL fEnable) { BOOL fOk = FALSE; HANDLE hToken = NULL; if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) { TOKEN_PRIVILEGES tp; tp.PrivilegeCount = 1; LookupPrivilegeValue(NULL, szPrivilege, &amp;tp.Privileges[0].Luid); tp.Privileges-&gt;Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0; AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL); fOk = (GetLastError() == ERROR_SUCCESS); CloseHandle(hToken); } return fOk;}// 钩子处理过程LRESULT CALLBACK HookProc_GetMsg(int code, WPARAM wParam, LPARAM lParam) { char szMsg[512] = { 0 }; sprintf_s(szMsg, 512, \"code: %d, wParam: %d, lParam: %d\", code, wParam, lParam); OutputDebugStringA(szMsg); return CallNextHookEx(g_hook, code, wParam, lParam);;}// 导出函数，安装钩子HHOOK InjectDllByHook(HWND hwnd) { DWORD dwThreadId = 0; HHOOK hHook = NULL; __try { if (!EnablePrivilege(SE_DEBUG_NAME, TRUE)) { __leave; } // 通过窗口句柄获取到窗口所属线程 dwThreadId = GetWindowThreadProcessId(hwnd, NULL); if (dwThreadId == 0) { __leave; } // 获取DLL自身的句柄 HMODULE hModule = NULL; GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, (LPCWSTR)InjectDllByHook, &amp;hModule); hHook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)HookProc_GetMsg, hModule, dwThreadId); } __finally { } return (hHook);}// 导出函数，卸载钩子BOOL EjectDllByHook(HHOOK hook) { return UnhookWindowsHookEx(hook);} 我们可以直接调用该 DLL 的导出函数InjectDllByHook，实现 Hook 指定窗口（也可以改成线程，因为InjectDllByHook函数内部也是通过窗口查找到对应线程的）的指定消息。当指定的消息类型被勾住时，我们的 DLL 也就被加载到了该窗口所属的进程地址空间了，从而实现了注入。 三、使用远程线程方式注入3.1 远程线程注入原理“注册表注入方式”由于不能精确指定需要注入的进程，而且只能注入到 GUI 程序中，灵活性较差；“钩子注入方式”虽然能够精确指定注入的线程，但只能针对特定类型的消息进行 Hook，从而间接的实现注入，对于类似 windows 服务类的程序就束手无策了。 本节介绍的“远程线程的注入方式”是在实际中使用最为广泛的一种注入方式，它即可以精确指定需要注入的进程，又可以注入到非 GUI 程序中。 远程线程注入方式使用的关键 API 为CreateRemoteThread，原型如下： 123456789HANDLE WINAPI CreateRemoteThread( _In_ HANDLE hProcess, _In_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_ LPDWORD lpThreadId); CreateRemoteThread的参数和我们平时创建本地线程使用的CreateThread的参数类似，新增了hProcess句柄参数用于指定在哪个进程创建远程线程，通过OpenProcess可以获取到进程句柄，但需要注意权限问题。 通过远程线程方式实现 DLL 注入主要是在lpStartAddress和lpParameter这 2 个参数上面做文章。lpStartAddress参数和CreateThread函数的一样，都是线程的处理过程函数，函数原型如下： 1DWORD WINAPI ThreadProc(LPVOID lpParameter); 我们知道加载 DLL 使用的 API 是LoadLibraryA或LoadLibraryW，原型如下： 1HMODULE WINAPI LoadLibrary(LPCTSTR lpFileName); 对比LoadLibrary和线程处理函数(LPTHREAD_START_ROUTINE)的原型，我们发现两者的函数的原型基本相同。虽然不是完全相同，但都是接收一个指针参数，而且都是返回一个值，并且调用约定也都是WINAPI。 我们完全可以利用下它们之间的相似性，把线程处理函数的地址设为LoadLibraryA或LoadLibraryW，类似下面这样： 12345678HANDLE hThread = CreateRemoteThread(hProcessRemote, NULL, 0, LoadLibraryA, \"C:\\\\InjectDll.dll\", 0, NULL); 当CreateRemoteThread创建的新线程在远程进程地址空间中被创建的时候，就会立即调用LoadLibraryA函数，并传入 DLL 路径的地址作为其参数。 3.2 注意事项按照上面的介绍的方法很容易就能实现远程线程注入，实际上也的确是很容易实现，只是还有 3 个地方需要注意：LoadLibrary 函数地址、DLL 路径字符串地址、取消注入。 3.2.1 LoadLibrary 函数地址问题我们不能向上面的代码那样直接把LoadLibraryA或LoadLibraryW作为第 4 个参数传给CreateRemoteThread函数。这其中涉及模块的导入段等问题，如果在调用CreateRemoteThread时直接引用LoadLibraryA，则该引用会被解析为我们被注入 DLL 的导入段中的LoadLibraryA转换函数的地址，如果把这个转换函数的地址作为远程线程的起始地址传入，其结果很可能是访问违规。 为了强制代码略过转换函数并直接调用LoadLibraryA函数，我们必须通过 GetProcAddress 来得到LoadLibraryA的确切地址。如： 12HMODULE hKernel32 = GetModuleHandle(TEXT(\"kernel32.dll\"));LPVOID pLoadLibraryAAddr = (LPVOID)GetProcAddress(hKernel32, \"LoadLibraryA\"); 3.2.2 DLL 路径字符串地址问题DLL 路径字符串\"C:\\\\InjectDll.dll\"的内存地址位于调用进程的地址空间中，并不位于被注入的进程的地址空间中。所以当LoadLibraryA用这个地址去被注入进程的地址空间中访问的时候，DLL 路径的字符串并不在那里，这很有可能导致远程线程访问违规。 如果对进程的地址空间不了解，可以参考：- 《Windows内存体系》系列文章。 为了解决这个问题，我们需要把 DLL 的路径字符串存储到被注入进程的地址空间中。Windows 提供的VirtualAllocEx函数可以实现在其他进程的地址空间中分配内存块。实现过程大致如下： 1234567891011121314hTargeProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID); // dwProcessID为被注入目标进程的进程IDif (!hTargeProcess) { return;}SIZE_T dllPathSize = strlen(pszDllPath); // pszDllPath存储了DLL的路径pVM4DllPath = VirtualAllocEx(hTargeProcess, NULL, dllPathSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);if (!pVM4DllPath) { return;}if (!WriteProcessMemory(hTargeProcess, pVM4DllPath, pszDllPath, dllPathSize, NULL)) { return;} 3.2.3 取消注入问题取消注入就是将 DLL 从目标进程卸载，卸载 DLL 所用的 API 是FreeLibrary，但我们不能直接调用这个函数，因为直接调用的话是在我们的进程中卸载 DLL，而不是目标进程中卸载，很显然这样达不到卸载的目的。我们需要和加载 DLL 时一样，将FreeLibrary的地址作为第 4 个参数传给CreateRemoteThread函数，但同样需要通过GetProcAddress来得到FreeLibrary的确切地址： 1234PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT(\"Kernel32\")), \"FreeLibrary\");if(pfnThreadRtn) { hThread = CreateRemoteThread(hProcess, NULL, 0, pfnThreadRtn, me.modBaseAddr, 0, NULL);} 3.3 实例本实例中的InjectDllByRemoteThread和EjectDllByRemoteThread两个函数使用远程线程的方式分别实现了注入和取消注入的功能。 3.3.1 InjectDllByRemoteThread 函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859BOOL InjectDllByRemoteThread(DWORD dwProcessID, const char* pszDllPath) { BOOL bRet = FALSE; const DWORD dwThreadSize = 50 * 1024; HANDLE hTargeProcess = NULL; HANDLE hRemoteThread = NULL; PVOID pVM4LoadLibrary = NULL; PVOID pVM4DllPath = NULL; __try { if (!EnablePrivilege(SE_DEBUG_NAME, TRUE)) { __leave; } hTargeProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID); if (!hTargeProcess) { __leave; } SIZE_T dllPathSize = strlen(pszDllPath); pVM4DllPath = VirtualAllocEx(hTargeProcess, NULL, dllPathSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (!pVM4DllPath) { __leave; } if (!WriteProcessMemory(hTargeProcess, pVM4DllPath, pszDllPath, dllPathSize, NULL)) { __leave; } HMODULE hKernel32 = GetModuleHandle(TEXT(\"kernel32.dll\")); LPVOID pLoadLibraryAAddr = (LPVOID)GetProcAddress(hKernel32, \"LoadLibraryA\"); hRemoteThread = CreateRemoteThread(hTargeProcess, NULL, 0, (DWORD(WINAPI *)(LPVOID))pLoadLibraryAAddr, pVM4DllPath, 0, NULL); if (!hRemoteThread) { __leave; } WaitForSingleObject(hRemoteThread, INFINITE); DWORD dwExitCode = 0; BOOL B = GetExitCodeThread(hRemoteThread, &amp;dwExitCode); bRet = TRUE; } __finally { if (hTargeProcess &amp;&amp; pVM4DllPath) { VirtualFreeEx(hTargeProcess, pVM4DllPath, dwThreadSize, MEM_RELEASE); } if (hRemoteThread) { CloseHandle(hRemoteThread); } if (hTargeProcess) { CloseHandle(hTargeProcess); } } return bRet;} 3.3.2 EjectDllByRemoteThread 函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162BOOL EjectDllByRemoteThread(DWORD dwProcessID, LPCWSTR pszDllPath) { BOOL bOk = FALSE; HANDLE hTHSnapshot = NULL; HANDLE hProcess = NULL, hThread = NULL; __try { hTHSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwProcessID); if(hTHSnapshot == INVALID_HANDLE_VALUE) { __leave; } MODULEENTRY32W me = {sizeof(me)}; BOOL bFound = FALSE; BOOL bMoreMods = Module32FirstW(hTHSnapshot, &amp;me); for(; bMoreMods; bMoreMods = Module32NextW(hTHSnapshot, &amp;me)) { bFound = (_wcsicmp(me.szModule, pszDllPath) == 0) || (_wcsicmp(me.szExePath, pszDllPath) == 0); if(bFound) break; } if(!bFound) { __leave; } hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION, // For CreateRemoteThread FALSE, dwProcessID); if(hProcess == NULL) { __leave; } PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandle(TEXT(\"Kernel32\")), \"FreeLibrary\"); if(pfnThreadRtn == NULL) { __leave; } hThread = CreateRemoteThread(hProcess, NULL, 0, pfnThreadRtn, me.modBaseAddr, 0, NULL); if(hThread == NULL) { __leave; } WaitForSingleObject(hThread, INFINITE); bOk = TRUE; } __finally { if(hTHSnapshot != NULL) { CloseHandle(hTHSnapshot); } if(hThread != NULL) { CloseHandle(hThread); } if(hProcess != NULL) { CloseHandle(hProcess); } } return(bOk);} 3.3.3 DllMain 函数使用远程线程的方式进行 DLL 注入，我们一般在 DllMain 的DLL_PROCESS_ATTACH条件分支开始业务逻辑（通常会另外创建一个子线程，将业务逻辑放到子线程中处理），DLL_PROCESS_DETACH条件分支出结束业务逻辑。 123456789101112131415161718192021222324252627282930313233BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved) { HANDLE hThread = NULL; switch(fdwReason) { case DLL_PROCESS_ATTACH: { g_hDllModule = hModule; // 使用注册表方式和CreateRemoteThread方式注入时，一般在此处创建线程 // hThread = (HANDLE)_beginthreadex(NULL, 0, PluginProc, NULL, 0, NULL); if (hThread) { CloseHandle(hThread); // 关闭句柄，防止句柄泄漏 } break; } case DLL_THREAD_ATTACH: { break; } case DLL_THREAD_DETACH: { break; } case DLL_PROCESS_DETACH: { // 结束业务逻辑 // ...... break; } } return TRUE;}","link":"/post/721636578.html"},{"title":"Windows注入与拦截(3)--挂载窗口到目标控件","text":"本文主要介绍如何通过 DLL 注入的方式来实现在指定窗口的控件上挂载一个自定义窗口。 何谓挂载？和舰载机挂载导弹类似，将我们自己的窗口挂到原有程序的窗口之上，可以实现对原有窗口功能的覆盖和扩展。 一、挂载的原理挂载的实现过程如下： 通过远程线程的方式（其他方式也可以）将 DLL 注入到指定的进程（当然是被挂载窗口所属的进程）。 在DllMain的DLL_PROCESS_ATTACH条件分支中创建一个新线程 NewThread，后面的处理逻辑将放到 NewThread 中，防止DllMain阻塞。 在 NewThread 线程中查找被挂载的窗口（注意是窗口不是窗口上的控件）的句柄（查找方式：EnumWindows结合FindWindowEx实现，详见FindProcessWindow函数）。 使用SetWindowLong修改窗体的默认的消息处理过程（假设将窗口处理过程修改为我们 DLL 中的WndProc_Trampoline函数），然后向窗体发送一个自定义消息，这时WndProc_Trampoline函数就可以获取到该消息通知，我们在收到该消息通知后就可以开始我们的挂载逻辑了。之所以要通过发送一个自定义消息的方式来做，而不是直接在新线程 NewThread 中开始我们的挂载逻辑，是因为这样做可以保证我们的挂载逻辑（如创建窗口）是在主线程中进行的。 挂载逻辑主要包含：查找需要挂载控件的句柄、创建挂载窗口。创建挂载窗口的时候要设置WS_CHILD子窗口属性，并设置父窗体的WS_CLIPCHILDREN属性来裁剪子窗口，防止我们挂载的子窗口闪烁。 在WndProc_Trampoline函数的最后不要忘记调用之前老的消息处理过程，否则原窗口的消息将无法得到正确的响应。 二、实例代码2.1 DllInjecter 工程DllInjecter.exe实现将 DLL 注入到指定的进程之中，该 exe 是一个通用的 DLL 注入器。包含了对前面文章介绍的“使用远程线程的方式注入”和“使用钩子方式注入”这两种注入方式的实现。 2.2 Test 工程Test.exe是一个模拟的被挂载程序，程序非常简单，只包含一个窗体和大按钮，不包含任何逻辑。本实例主要是将我们的窗口挂载到这个大按钮之上。挂载前如图： 挂载后效果如图： 2.3 Troy 工程Troy.dll就是被注入到Test.exe中的 DLL 文件（名称来源于“特洛伊木马”）。挂载的主要逻辑大都在该工程之中。 在WndProc_Trampoline函数的WUM_CREATE_USER_WINDOW消息处理分支中CreateUserWindowByDuilib函数来创建挂载窗口，CreateUserWindowByDuilib使用duilib界面库来创建挂载窗口。 123456789LRESULT CALLBACK WndProc_Trampoline(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) { switch (message) { case WUM_CREATE_USER_WINDOW: CreateUserWindowByDuilib(); break; } return CallWindowProc(g_oldProc, hwnd, message, wParam, lParam);} 12345678910111213// 线程处理函数unsigned int __stdcall PluginProc(LPVOID pArg) { MessageBox(NULL, TEXT(\"我已经被注入啦\"), TEXT(\"信息\"), MB_OK | MB_ICONASTERISK); HWND hMainWindow = InjectHelper::FindProcessWindow(GetCurrentProcessId(), TEXT(\"#32770\"), TEXT(\"Test\"), TRUE); g_oldProc = (WNDPROC)SetWindowLong(hMainWindow, DWL_DLGPROC, (LONG)WndProc_Trampoline); ::PostMessage(hMainWindow, WUM_CREATE_USER_WINDOW, 0, 0); return 0;} 12345678910111213141516171819202122232425262728293031BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved) { HANDLE hThread = NULL; switch(fdwReason) { case DLL_PROCESS_ATTACH: { g_hDllModule = hModule; // 使用注册表方式和CreateRemoteThread方式注入时，一般在此处创建线程 // hThread = (HANDLE)_beginthreadex(NULL, 0, PluginProc, NULL, 0, NULL); if (hThread) { CloseHandle(hThread); // 关闭句柄，防止句柄泄漏 } break; } case DLL_THREAD_ATTACH: { break; } case DLL_THREAD_DETACH: { break; } case DLL_PROCESS_DETACH: { break; } } return TRUE;} 完整的示例代码见：https://github.com/winsoft666/InjectSample","link":"/post/2804470458.html"},{"title":"C++获取其他Windows进程命令行","text":"本文介绍如何根据进程 ID 获取进程命令行参数，使用 NTDLL 提供的未公开 API 实现。 由于需要使用应用层未公开的 API，这些 API 在 Windows 提供的头文件未提供函数的定义，因此我们需要使用GetProcessAddress动态地从 ntdll.dll 中获取函数地址。 在涉及调用函数比较多时，动态的获取函数地址就会显得比较繁琐，我们可以直接使用下面的库来简化上述操作。https://github.com/winsoft666/ndk 下面介绍如何使用ndk库来根据进程 ID 获取进程命令行参数。 首先需要包含头文件： 1234extern \"C\" {#pragma warning(disable : 4005)#include \"ntndk.h\"} 并引入对应 lib：x86\\ntdll.lib或x64\\ntdll.lib。 拿去用吧具体获取命令行参数的方式已封装到下面GetProcessCommandLine函数，方便读者食用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 返回值为0表示成功DWORD GetProcessCommandLine(unsigned int pid, std::wstring&amp; strResult) { BOOL result = false; SetLastError(0); HANDLE hProcess = NULL; PPEB ppebCopy = NULL; PRTL_USER_PROCESS_PARAMETERS pRtlProcParamCopy = NULL; PWSTR wBufferCopy = NULL; do { hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); if (!hProcess) break; PROCESS_BASIC_INFORMATION basicInfo; ZeroMemory(&amp;basicInfo, sizeof(PROCESS_BASIC_INFORMATION)); NTSTATUS status = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &amp;basicInfo, sizeof(PROCESS_BASIC_INFORMATION), NULL); if (!NT_SUCCESS(status)) break; PPEB ppeb = basicInfo.PebBaseAddress; ppebCopy = (PPEB)malloc(sizeof(PEB)); if (!ppebCopy) break; result = ReadProcessMemory(hProcess, ppeb, ppebCopy, sizeof(PEB), NULL); if (!result) break; PRTL_USER_PROCESS_PARAMETERS pRtlProcParam = ppebCopy-&gt;ProcessParameters; pRtlProcParamCopy = (PRTL_USER_PROCESS_PARAMETERS)malloc(sizeof(RTL_USER_PROCESS_PARAMETERS)); if (!pRtlProcParamCopy) break; result = ReadProcessMemory(hProcess, pRtlProcParam, pRtlProcParamCopy, sizeof(RTL_USER_PROCESS_PARAMETERS), NULL); if (!result) break; PWSTR wBuffer = pRtlProcParamCopy-&gt;CommandLine.Buffer; USHORT len = pRtlProcParamCopy-&gt;CommandLine.Length; wBufferCopy = (PWSTR)malloc(len + 2); if (!wBufferCopy) break; memset(wBufferCopy, 0, len + 2); result = ReadProcessMemory(hProcess, wBuffer, wBufferCopy, // command line goes here len, NULL); if (result) strResult = wBufferCopy; } while (false); DWORD dwGLE = 0; if (!result) { dwGLE = GetLastError(); } if (ppebCopy) free(ppebCopy); if (pRtlProcParamCopy) free(pRtlProcParamCopy); if (wBufferCopy) free(wBufferCopy); if (hProcess) CloseHandle(hProcess); return dwGLE;}","link":"/post/3666245140.html"},{"title":"Windows内核对象","text":"一、什么是内核对象我们在 windows 开发中经常会遇到内核对象，如事件(Event)，管道(Pipe)，互斥量(Mutex)，完成端口(IOCP)，进程(Process)，线程(Thread)等，他们都是内核对象。这些内核对象虽然通过不同的系统 API 来创建，但这些 API 都有一个共同特点，就是都需要传入SECURITY_ATTRIBUTES安全描述符结构体指针，并且返回句柄(HANDLE)。依据这个特点，我们有一个简单方法来判断对象是否是内核对象，就是看创建它的函数是否允许传入SECURITY_ATTRIBUTES安全描述符。 二、内核对象的创建大多数创建内核对象的系统 API 函数，如 CreateEvent, CreateMutex, CreateThread, CreateProcess, CreatePipe, CreateNamedPipe 等都会返回一个 HANDLE（无论是以返回值的形式，还是以指针参数的形式返回），创建内核对象成功时 HANDLE 为非NULL，我们可以通过将 HANDLE 的值与 NULL 进行比较，来判断函数是否执行成功。但是有些函数比较例外，如CreateFile，这些函数执行失败时，返回的HANDLE的值为INVALID_HANDLE_VALUIE。 相关文章：由HANDLE返回值不确定性引发的思考 三、内核对象的访问虽然内核对象属于系统内核，但创建函数返回的HANDLE句柄却只和当前进程有关，离开了当前进程这个句柄也就失去了意义。内核对象属于系统内核级别，为了系统安全性，Windows 不允许我们直接访问内核对象的内存区域，只允许我们通过 Windows 提供的一系列 API 来访问内核对象，如SetEvent, ResetEvent等等，使用这些函数时我们都会用到HANDLE，windows 头文件中HANDLE的定义如下： 1typedef void *HANDLE; 虽然定义为void*类型，但很显然这个HANDLE不是指向内核对象的指针。 如何证明 HANDLE 不是指向内核对象的指针？一方面直接执行内核对象毫无安全性可言；另一方面内核对象保存在内核地址空间（32 位系统是0x80000000 到 0xFFFFFFFF，64 位系统是0x00000040 00000000到0xFFFFFFFF FFFFFFFF），我们可以调用类似CreateEvent的函数创建一个内核对象，观察其返回的 HANDLE，明显不在内核地址空间的范围内，且值一般比较小。 那么这个HANDLE句柄是如何与内核对象关联起来的了？答案是：进程的句柄表。每个进程在初始化的时候，系统都会为它分配一个句柄表(Windows 没有提供官方的文档来介绍句柄表)，参考《Windows 核心编程》得知句柄表的结构，如图： 索引 指向内核对象内存块的指针 访问掩码 标志 1 0x???????? 0x???????? 0x???????? 2 0x???????? 0x???????? 0x???????? … … … … 如我们调用类似CreateEvent的函数返回的句柄HANDLE就是句柄表中的索引。因为是索引，所以它的值一般比较小。我们向 windows API 函数传入这个索引，API 再通过索引找到对应的内核对象指针。 四、内核对象的销毁4.1 引用计数内核对象的所有者是操作系统内核，而不是创建它的进程。 多个进程可以引用（使用）同一个内核对象，操作系统使用了计数器的方式来管理内核对象（这个和 C++中的std::shared_ptr智能指针类似），一个内核对象其实有两个计数器：一个是给用户态(Ring3)用的句柄计数；另一个是指针计数，也叫引用计数，因为核心态程序(Ring0)也经常用到内核对象，为了使用方便，在核心态的代码用指针直接访问对象，所以内核对象的管理器也维护了这个指针引用计数。只有在内核对象的句柄计数和引用计数都为 0 时，该内核对象才被释放。一般而言，指针引用计数值比句柄计数值大。 4.2 正确的销毁方式当程序不再使用内核对象时，需要调用CloseHandle将内核对象的计数减 1，这样系统内核在该对象计数为 0 时（也就是没有被任何东西引用时）将销毁该对象。 并且在调用CloseHandle之后，程序还应该将HANDLE置为NULL。 如果CloseHandle之后不将HANDLE置为NULL，反而再次使用该HANDLE，就会出现 2 种情况： 进程句柄表中该HANDLE所在的索引项的记录已经被清除，且没有别的线程再次在该索引创建记录项，若此时使用这个过期的HANDLE调用 Win32 API 函数，Windows 会返回无效参数错误。这种情况还比较好调试。 进程句柄表中该HANDLE所在的索引项的记录同样也已经被清除，但已经有别的线程（该进程中的其他线程）在该索引位置创建了记录项，若此时使用这个过期的HANDLE调用 Win32 API 函数，该HANDLE就会引用到其他线程新建的那个内核对象，从而出现一些难以预料的错误。这种错误很难调试。 4.3 获取内核对象的引用计数虽然 windows 没有提供 API 让用户在用户态（Ring3）查询一个内核对象的句柄计数和引用计数，但我们可以从Ntdll.dll导出NtQueryObject函数来实现查询内核对象的当前状态(该函数没有被文档化)。 NtQueryObject函数声明如下： 123456789// 返回值：如果成功则返回0//DWORD WINAPI NtQueryObject(HANDLE handle, // 待查询的句柄DWORD nQueryIndex, // 0为查询对象的当前状态，包括句柄计数，引用计数等等。VOID* pOutBuffer, // 存放查询结果DWORD cbInBufferSize, // pOutBuffer的大小，如果nQueryIndex为0，这里为sizeof(SYSTEM_HANDLE_STATE)VOID* cbOutBufferSize // 实际大小); 将NtQueryObject函数调用的细节封装到GetKernelObjectRefCount函数中，方便使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool GetKernelObjectRefCount(HANDLE handle, DWORD &amp;handle_count, DWORD &amp;point_count) { typedef struct _SYSTEM_HANDLE_STATE { DWORD r1; DWORD GrantedAccess; DWORD HandleCount; // 减1为句柄计数 DWORD ReferenceCount; // 减1为指针引用计数 DWORD r5; DWORD r6; DWORD r7; DWORD r8; DWORD r9; DWORD r10; DWORD r11; DWORD r12; DWORD r13; DWORD r14; }SYSTEM_HANDLE_STATE, *PSYSTEM_HANDLE_STATE; typedef DWORD(WINAPI *PFN_NtQueryObject)(HANDLE handle, DWORD nQueryIndex, VOID* pOutBuffer, DWORD cbInBufferSize, VOID* cbOutBufferSize); static PFN_NtQueryObject pfnNtQueryObject = NULL; bool ret = false; do { if (pfnNtQueryObject == NULL) { HMODULE ntdll = GetModuleHandle(TEXT(\"Ntdll.dll\")); if (ntdll == NULL) break; pfnNtQueryObject = (PFN_NtQueryObject)GetProcAddress(ntdll, \"NtQueryObject\"); if (pfnNtQueryObject == NULL) break; } SYSTEM_HANDLE_STATE sys_handle_state; memset(&amp;sys_handle_state, 0, sizeof(SYSTEM_HANDLE_STATE)); DWORD out_buf_size = 0; ret = (pfnNtQueryObject(handle, 0, &amp;sys_handle_state, sizeof(SYSTEM_HANDLE_STATE), &amp;out_buf_size) == 0); if (ret) { handle_count = sys_handle_state.HandleCount - 1; point_count = sys_handle_state.ReferenceCount - 1; } } while (false); return ret;} 五、内核对象跨进程访问虽然内核对象位于独立于进程之外的内核区域，我们在开发中却只能通过调用 Win32 API 传入 HANDLE 参数来操作内核对象（如SetEvent等）。然而HANDLE句柄只对当前进程有效，离开了当前进程该句柄就无效了。所以说，跨进程访问内核对象的关键在于我们怎么跨进程访问句柄HANDLE？ 下面介绍几种方法来实现跨进程共享内核对象。 5.1 使用句柄继承的方式只有进程之间有父子关系时，才可以使用句柄继承的方式。在这种情况下，父进程可以生成一个子进程，并允许子进程访问父进程的内核对象。为了使这种继承生效，父进程必须执行几个步骤：（1）. 父进程在创建一个内核对象时，父进程必须向系统指定它希望这个内核对象的句柄是可以继承的。为了创建一个可继承的内核对象，必须分配并初始化一个SECURITY_ATTRIBUTES结构，如： 123456SECURITY_ATTRIBUTES sa;sa.nLength = sizeof(SECURITY_ATTRIBUTES);sa.bInheritHandle = TRUE; // 可继承的sa.lpSecurityDescriptor = NULL;HANDLE h = CreateEvent(&amp;sa, TRUE, FALSE, NULL); （2）. 父进程通过 CreateProcess 生成子进程，且指定bInheritHandles为 TRUE，从而允许子进程来继承父进程的那些“可继承的句柄”。 1234567891011121314151617181920212223// 启动子进程TestB.exe，将句柄h作为启动参数传给进程TestB//TCHAR cmd_buf[MAX_PATH];StringCchPrintf(cmd_buf, MAX_PATH, TEXT(\"TestB.exe %ld\"), (long)h);STARTUPINFO si = { sizeof(si) };PROCESS_INFORMATION pi;BOOL ret = CreateProcess( NULL, cmd_buf, NULL, NULL, TRUE, // 指定子进程可以继承父进程的“可继承句柄” 0, NULL, NULL, &amp;si, &amp;pi);CloseHandle(pi.hProcess);CloseHandle(pi.hThread); 由于我们传给bInheritHandles参数的值是TRUE，所以系统在创建子进程时会多做一件事情：它会遍历父进程的句柄表，对它的每一项进行检查，凡是包含一个有效的“可继承的句柄”的项，都会将该项完整的复制到子进程的句柄表。在子进程的句柄表中，复制项的位置与它在父进程句柄表中的位置完全一样（包含索引），这个就意味着：在父进程和子进程中，对一个内核对象进行标识的句柄值也是完全一样的。所以我们只需要通过某种方式（如上面示例中的启动参数的方式，或者环境变量的方式等任何进程间通讯的方式）将这个值告诉子进程，子进程就可以将该值转成HANDLE，然后使用这个HANDLE来调用系统 API。 5.2 使用 DuplicateHandle 方式DuplicateHandle 函数可以将指定“源进程的句柄表”中的某一项复制到“目的进程句柄表”中（除了索引），并且返回该项在目的进程句柄表中的索引（即 HADNLE）。可以在任何时候调用 DuplicateHandle 函数，DuplicateHandle 对源句柄是否是可继承的没有要求。 函数声明如下： 123456789BOOL DuplicateHandle( HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions); DuplicateHandle 详细介绍可以参考 MSDN：https://msdn.microsoft.com/en-us/library/windows/desktop/ms724251(v=vs.85).aspx DuplicateHandle 函数不能复制所有类型的句柄，只能复制如下类型的句柄（从 MSDN 复制而来）： Object Description Access token The handle is returned by the CreateRestrictedToken, DuplicateToken, DuplicateTokenEx, OpenProcessToken, or OpenThreadToken function. Change notification The handle is returned by the FindFirstChangeNotification function. Communications device The handle is returned by the CreateFile function. Console input The handle is returned by the CreateFile function when CONIN$ is specified, or by the GetStdHandle function when STD_INPUT_HANDLE is specified. Console handles can be duplicated for use only in the same process. Console screen buffer The handle is returned by the CreateFile function when CONOUT$ is specified, or by the GetStdHandle function when STD_OUTPUT_HANDLE is specified. Console handles can be duplicated for use only in the same process. Desktop The handle is returned by the GetThreadDesktop function. Event The handle is returned by the CreateEvent or OpenEvent function. File The handle is returned by the CreateFile function. File mapping The handle is returned by the CreateFileMapping function. Job The handle is returned by the CreateJobObject function. Mailslot The handle is returned by the CreateMailslot function. Mutex The handle is returned by the CreateMutex or OpenMutex function. Pipe A named pipe handle is returned by the CreateNamedPipe or CreateFile function. An anonymous pipe handle is returned by the CreatePipe function. Process The handle is returned by the CreateProcess, GetCurrentProcess, or OpenProcess function. Registry key The handle is returned by the RegCreateKey, RegCreateKeyEx, RegOpenKey, or RegOpenKeyEx function. Note that registry key handles returned by the RegConnectRegistry function cannot be used in a call to DuplicateHandle. Semaphore The handle is returned by the CreateSemaphore or OpenSemaphore function. Thread The handle is returned by the CreateProcess, CreateThread, CreateRemoteThread, or GetCurrentThread function Timer The handle is returned by the CreateWaitableTimer or OpenWaitableTimer function. Transaction The handle is returned by the CreateTransaction function. Window station The handle is returned by the GetProcessWindowStation function. 不同的事件类型对应的dwDesiredAccess参数不同，具体参考MSDN。 示例进程 TestA 源码 123456789101112131415161718192021222324252627int main(int argc, char** argv) { HANDLE h = CreateEvent(NULL, TRUE, FALSE, NULL); // 启动子进程TestB.exe // TCHAR cmd_buf[MAX_PATH]; StringCchPrintf(cmd_buf, MAX_PATH, TEXT(\"D:\\\\TestB.exe\"), (long)h); STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi; BOOL ret = CreateProcess(NULL, cmd_buf, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;pi); assert(ret); assert(pi.hProcess); HANDLE duplicated_h = NULL; ret = DuplicateHandle(GetCurrentProcess(), h, pi.hProcess, &amp;duplicated_h, 0, FALSE, DUPLICATE_SAME_ACCESS); WaitForSingleObject(pi.hProcess, INFINITE); CloseHandle(pi.hProcess); CloseHandle(pi.hThread); bool has_signal = WaitForSingleObject(h, 0) == WAIT_OBJECT_0; assert(has_signal == true); return 0;} 子进程 TestB 源码 12345678910111213141516int main(int argc, char** argv){ long l = 0; printf(\"Input Handle:\"); scanf(\"%ld\", &amp;l); HANDLE h = (HANDLE)l; bool has_signal = WaitForSingleObject(h, 0) == WAIT_OBJECT_0; assert(has_signal == false); SetEvent(h); return 0;} 在父进程 TestA 中创建一个不可继承的事件 -&gt; 然后启动子进程 TestB -&gt; 调用 DuplicateHandle 复制句柄项到 TestB 进程句柄表 -&gt; 并向 TestB 输入句柄值 -&gt; TestB 访问该事件句柄，将事件置为有信号状态。 5.3 使用命名的内核对象的方式5.3.1 实现原理这种方式严格的说已经不是文章开头说到的跨进程访问句柄了，有点类似跨进程直接访问内核对象了。该方式实现起来比较简单，就是在调用创建内核对象的Create***函数时，通过pszName参数为内核对象取一个名字。如创建事件 Event 的函数CreateEvent： 1234567HANDLE WINAPI CreateEvent( LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCTSTR lpName // 指定名称); 1HANDLE h = CreateEvent(NULL, TRUE, FALSE, TEXT(\"TestA_Obj\")); 若在其他进程中要访问这个内核对象，只需要使用打开函数Open***打开该内核对象，系统就会在进程的句柄表中插入一条记录，并返回这条记录的索引，也就是句柄。需要注意的是，在打开内核对象时需要留意返回值和GetLastError函数的返回值。由于内核对象是有访问权限的，有时候虽然这个名字的内核对象存在，但该进程却不见得有权限可以打开它，这个时候GetLastError函数会返回失败的原因。 以打开事件的函数OpenEvent为例： 123456HANDLE h = OpenEvent(READ_CONTROL, FALSE, TEXT(\"TestA_Obj\"));if (h == NULL) { if (GetLastError() == ERROR_ACCESS_DENIED) { // 没有READ_CONTROL权限 }} 5.3.2 全局命令空间不同的会话（Session）有不同的内核对象命名空间（如 windows 服务程序位于Session 0，而普通的用户进程位于Session 1），要通过名称访问其他会话中的内核对象，需要在名称前面加上Session\\&lt;当前会话ID&gt;。Windows 提供了一个全局的内核对象命名空间，处于任何会话中的进程都可以访问该命名空间，将内核对象放入全局命令空间的方式很简单：只需要在内核对象名称前加入Global\\即可。 如： 1HANDLE h = CreateEvent(NULL, TRUE, FALSE, TEXT(\"Global\\\\TestA_Obj\"));","link":"/post/14744864.html"},{"title":"Windows API的不同返回状态","text":"在Windows编程中，我们经常接触到的Windows API返回值类型有： BOOL HRESULT LSTATUS 1. 错误码BOOL类型通常是0表示失败，非0表示成功，在BOOL类型返回失败时，通常还可以通过GetLastError函数获取错误码。错误码与调用线程相关联，每个线程的错误码是独立的，在调用完Windows API后，如下获取错误码，则需要立即获取，否则可能会被后面调用API所设置的错误码所覆盖。 应用程序也可以通过SetLastError函数来设置错误码。 Windows API通常在没有错误发生时，将错误码设置为0，有错误发生时，视具体错误而设置为其他非0值。 微软官方文档：Debug system error codes 常见的错误码123ERROR_SUCCESS = 0 // 成功ERROR_OUTOFMEMORY // 内存不足... 2. HRESULT2.1 HRESULT结构HRESULT是COM返回的错误码，总共32位，它由三个基本部分组成： 高1位表示成功或失败（0表示成功，1表示失败）。 中间11位编码指示错误来源的设施/设备。 低16位编码错误编号。 0~32位的作用分别如下： 123456789101112131415161718S - 严重度 - 表示成功/失败 0 - 成功 1 - 失败 (COERROR)R - reserved portion of the facility code, corresponds to NT's second severity bit.C - reserved portion of the facility code, corresponds to NT's C field.N - reserved portion of the facility code. Used to indicate a mapped NT status value.r - reserved portion of the facility code. Reserved for internal use. Used to indicate HRESULT values that are not status values, but are instead message ids for display strings.Facility - 设备/设施码Code - 设备/设施的状态码 在实际开发中，通常不需要关心其每一位的具体作用，我们使用更多的是下面的几个宏： 使用SUCCEEDED(hr)宏判断是否成功（即hr&gt;= 0），FAILED(hr)判断是否失败(即hr&lt; 0)。 使用HRESULT_CODE(hr)宏获取错误码。 使用HRESULT_FACILITY(hr)宏获取设备码。 4字节（32位）整数能表示的最大正整数为7FFF FFFFF（最高位为0），当最高位为1时，则为负数。所以HRESULT能通过是否为负数来判断成功与否。 2.2 常见的HRESULT值123S_OK // 成功S_FALSE // 失败E_FAIL // 失败 2.3 API错误码与HRESULT我们可以使用HRESULT_FROM_WIN32宏将上一节介绍的“Windows API的错误码”转成HRESULT。 3. LSTATUS在Windows API中对LSTATUS的定义比较模糊，比如注册表API（如RegCreateEx等）返回的LSTATUS实际就是第一节介绍的Windows错误码。 所以当遇到返回LSTATUS类型的API时，需要参考API的文档说明。","link":"/post/2510508225.html"},{"title":"Windows实现文件强制占用","text":"本文介绍在 Windows 系统上实现使某个文件无法被用户或其他程序删除。 实现的原理大致如下： 通过DuplicateHandle拷贝文件句柄给另外一个进程（一般是系统进程），因为系统进程不会被关闭，所以达到了占用某个文件，不让其他进程删除、读取、写入等。 DuplicateHandle的用法参考：- Windows内核对象 因为需要拷贝文件句柄给系统进程，所以涉及到打开系统进程，可能需要提权操作，一般授权给进程SE_DEBUG_NAME权限即可。 实现一个用于锁住文件的函数LockFile，将文件句柄复制给系统csrss.exe进程，函数实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758bool LockFile(LPCTSTR lpFilePath) { if (lpFilePath == NULL) return false; // 查找进程csrss.exe // DWORD dwCsrssProcessID = 0; PROCESSENTRY32 pe; pe.dwSize = sizeof(PROCESSENTRY32); HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); while (Process32Next(hSnapShot, &amp;pe)) { if (lstrcmpi(pe.szExeFile, TEXT(\"csrss.exe\")) == 0) { dwCsrssProcessID = pe.th32ProcessID; break; } } CloseHandle(hSnapShot); // 未找到 if (dwCsrssProcessID == 0) { return false; } HANDLE hProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwCsrssProcessID); // 打开失败，可能是当前进程未提权导致，需要提前进行提权操作 if (hProcess == NULL) { return false; } HANDLE hFile = CreateFile(lpFilePath, GENERIC_READ | GENERIC_EXECUTE | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { CloseHandle(hProcess); return false; } HANDLE hTargetHandle = INVALID_HANDLE_VALUE; BOOL bRet = DuplicateHandle(GetCurrentProcess(), hFile, hProcess, &amp;hTargetHandle, 0, FALSE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE ); CloseHandle(hProcess); return (bRet == TRUE);}","link":"/post/434128163.html"},{"title":"Windows平台文件自签名","text":"本文使用的工具都是 Windows SDK 自带的，可以采用单独安装 Windows SDK的方式，也可以通过安装 Visual Studio 来附带安装 Windows SDK。 123456# 在弹出界面设置密码123456makecert.exe -sv test.pvk -r -n \"CN=test.com\" test.cercert2spc.exe test.cer test.spcpvk2pfx.exe -pvk test.pvk -pi 123456 -spc test.spc -pfx test.pfx -f 使用 SignTool 工具对 EXE 文件签名： 1signtool.exe sign /f test.pfx /p 123456 Setup.exe","link":"/post/667140500.html"},{"title":"Windows平台生成Dump文件","text":"转储文件也就是我们常说的 dump 文件，可以把转储文件看成软件的某个时刻的一个快照，我们一般在软件出现问题时手动生成或者程序自动生成转储文件。 一、工具篇下面我们介绍几种借助第三方工具生成转储文件的方法。 1.1 任务管理器任务管理器可以说是最易获取的系统工具，同时它具有生成转储文件的功能。但要注意的是在 64 位操作系统上面，默认启动的是 64 位的任务管理器。使用任务管理器生成转储文件需要遵循一个原则：用 32 位任务管理器给 32 位进程（无论该进程是运行在 32 位还是 64 位系统上面）生成转储文件，用 64 位任务管理器给 64 位进程生成转储文件。 在 64 位系统上，32 位的任务管理器位于C:\\Windows\\SysWOW64\\taskmgr.exe。 生成方法：右键进程 –&gt; 创建转储文件–&gt;弹出对话框提示生成成功，以及 dmp 文件位置。 类似的工具还有：Process Explorer，PCHunter 等。 1.2 注册表可以通过在注册表中进行配置，让操作系统在程序崩溃时自动生成 dmp 文件，并放到指定位置。在注册表项 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\\LocalDumps 下面根据进程名（含.exe）新建子项，并配置如下值：名称：DumpCount，类型：REG_DWORD，最大保留 Dump 个数，默认为 10.名称：DumpType，类型：REG_DWORD，Dump 类型(1-Mini dump, 2-Full dump)，默认为 1.名称：DumpFolder，类型：REG_EXPAND_SZ，Dump 文件保存的位置。 1.3 Windbg生成方法：File 菜单–&gt;Attach to Process–&gt;输入命令.dump /ma /u d:\\test.dmp提示成功之后，可以在 D 盘看到生成 dmp 文件到 test_0bf0_2017-08-13_23-46-37-244_11cc.dmp 文件。 0bf0_2017-08-13_23-46-37-244_11cc 是/u 参数附加上去的，意思是 2017 年 08 月 13 日 23 时 46 分 37 秒 244 毫秒，进程 PID 位 11cc。 .dump 命令参数比较多，常用的组合就是/ma，/m 表示生成 minidump，/a 表示 dmp 包含所有信息，/u 参数就是上面说的附加时间和 PID 信息到文件名。 1.4 Windbg -IWindbg -I&nbsp; 可以将 Windbg 设置为及时调试器（开启了 UAC 的系统上面，需要以管理员权限运行），也就是我们常说的 JIT 调试器。设置成功之后，如遇到程序崩溃，Windbg 会自动运行并附加到崩溃进程。 设置成功之后会弹出对话框提示设置成功。如果不想弹出对话框，可以加上 S（slient 首字母）Windbg -IS. 也可以通过修改注册表项 AeDebug 来实现和 windbg -I 同样的功能。根据 windbg 位数（32/64）和系统的位数（32/64）的不同，修改的注册表项的位置也不同： 32 位 windbg–32 位系统：HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug 32 位 windbg–64 位系统：HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug 64 位 windbg–64 位系统：HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug AeDebug 项下面有 2 个值：名称：Auto，类型：REG_SZ，0 表示出现崩溃弹出对话框，让用户选择关闭程序还是调试程序；1 表示自动弹出设置调试器。名称：Debugger，类型：REG_SZ，调试器值。默认为”C:\\WINDOWS\\system32\\vsjitdebugger.exe” -p %ld -e %ld，设置为 windbg 需更改为”C:\\Debuggers\\WinDbg\\x86\\windbg.exe” -p %ld -e %ld -g 看起来挺复杂，其实挺好理解的。 1.5 Adplusadplus 工具位于 windbg 安装目录，最早叫 adplus.vbs，以 VBScript 脚本提供，最新版改成了 adplus.exe。adplus.exe 不仅可以在程序崩溃时手动运行来生成 dmp 文件，也可以在崩溃之前就运行它，当程序崩溃时它会自动生成 dmp 文件；甚至可以在程序没有运行之前就先运行 adplus，当程序崩溃时它会自动生成 dmp 文件。如：adplus -pn powerpnt.exe -pn wincmd32.exe -hang -o c:\\test Adplus 用法： 1234ADPlus &lt;RunMode&gt; -o &lt;OutputDirectory&gt; [Options]RunMode：-hang或-crash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-hang&nbsp;附加到进程，生成dmp，然后解除附加(detach)。多用于程序卡死的情况下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-crash&nbsp;附加到进程，直到程序崩溃或者其他事件发生，生成dmp文件，然后解除附加。 常用参数： -o 目录指定生成文件存储目录。 -p 进程 ID指定进程 ID，可以同时使用多次-p 来指定多个进程。 -pn 进程名指定进程名，支持通配符，也可以同时使用多次-pn 来指定多个进程，但进程名必须存在，不存在则失败。 -po 进程名和-pn 类似，但-po 不要求进程名必须存在。可以在进程启动之前就先启动 Adplus. -pmn 进程名pmn 为 Process Monitor 缩写。顾名思义，可以监视进程列表，一旦指定进程运行，则附加上去。只适用于-crash&nbsp; 模式。 ​# 二、代码篇使用代码生成dump文件的原理大致是： 捕获异常，如SetUnhandledExceptionFilter、__try...__except。 使用MiniDumpWriteDump写入dump到文件。 为了便于使用，我封装了一个捕获异常并写入dump的辅助，具体如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// EasyDump.h#pragma once#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;strsafe.h&gt;namespace cpp4j { typedef struct _EXCEPTION_POINTERS EXCEPTION_POINTERS, *PEXCEPTION_POINTERS; int __cdecl RecordExceptionInfo(PEXCEPTION_POINTERS pExceptPtrs, const TCHAR *szDumpNamePrefix); TCHAR *lstrrchr(LPCTSTR string, int ch); void DumpMiniDump(HANDLE hFile, PEXCEPTION_POINTERS excpInfo);}#define WINMAIN_BEGIN(szDumpNamePrefix) \\ int __96A9695E_RUN_WINMAIN_FUNC(HINSTANCE hInstance, LPTSTR lpCmdLine);\\ LONG WINAPI __96A9695E_UnhandledExceptionHandler( _EXCEPTION_POINTERS *pExceptionInfo ) \\ { \\ OutputDebugString(TEXT(\"Create a dump file sine an exception occurred in sub-thread.\\n\")); \\ int iRet = cpp4j::RecordExceptionInfo(pExceptionInfo, szDumpNamePrefix); \\ return iRet; \\ } \\ int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow) \\ { \\ UNREFERENCED_PARAMETER(hPrevInstance); \\ UNREFERENCED_PARAMETER(nCmdShow); \\ ::SetUnhandledExceptionFilter( __96A9695E_UnhandledExceptionHandler );\\ int ret = 0;\\ __try\\ {\\ ret = __96A9695E_RUN_WINMAIN_FUNC(hInstance, lpCmdLine);\\ }\\ __except(cpp4j::RecordExceptionInfo(GetExceptionInformation(), szDumpNamePrefix))\\ {\\ OutputDebugString(TEXT(\"Create a dump file sine an exception occurred in main-thread.\\n\")); \\ }\\ return ret;\\ }\\ int __96A9695E_RUN_WINMAIN_FUNC(HINSTANCE hInstance, LPTSTR lpCmdLine) \\ {#define WINMAIN_END }#define MAIN_BEGIN(szDumpName) \\ int __96A9695E_RUN_MAIN_FUNC(int argc, _TCHAR* argv[]);\\ LONG WINAPI __96A9695E_UnhandledExceptionHandler( _EXCEPTION_POINTERS *pExceptionInfo ) \\ { \\ OutputDebugString(TEXT(\"Create a dump file since an exception occurred in sub-thread.\\n\")); \\ int iRet = cpp4j::RecordExceptionInfo(pExceptionInfo, szDumpName); \\ return iRet; \\ } \\ int _tmain(int argc, _TCHAR* argv[])\\ { \\ ::SetUnhandledExceptionFilter( __96A9695E_UnhandledExceptionHandler );\\ int ret = 0;\\ __try\\ {\\ ret = __96A9695E_RUN_MAIN_FUNC(argc, argv);\\ }\\ __except(cpp4j::RecordExceptionInfo(GetExceptionInformation(), szDumpName))\\ {\\ OutputDebugString(TEXT(\"Create a dump file since an exception occurred in main-thread.\\n\")); \\ }\\ return ret;\\ }\\ int __96A9695E_RUN_MAIN_FUNC(int argc, _TCHAR* argv[]) \\ {#define MAIN_END } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// EasyDump.cpp#include \"EasyDump.h\"#include &lt;DbgHelp.h&gt;#pragma comment(lib, \"Dbghelp.lib\")namespace cpp4j { TCHAR *lstrrchr(LPCTSTR string, int ch) { TCHAR *start = (TCHAR *)string; while (*string++) ; while (--string != start &amp;&amp; *string != (TCHAR)ch) ; if (*string == (TCHAR)ch) return (TCHAR *)string; return NULL; } inline void DumpMiniDump(HANDLE hFile, PEXCEPTION_POINTERS excpInfo) { if (!excpInfo) { static int iTimes = 0; if (iTimes++ &gt; 1) return; __try { RaiseException(EXCEPTION_BREAKPOINT, 0, 0, NULL); } __except (DumpMiniDump(hFile, GetExceptionInformation()), EXCEPTION_CONTINUE_EXECUTION) { } } else { MINIDUMP_EXCEPTION_INFORMATION eInfo; eInfo.ThreadId = GetCurrentThreadId(); eInfo.ExceptionPointers = excpInfo; eInfo.ClientPointers = FALSE; MiniDumpWriteDump( GetCurrentProcess(), GetCurrentProcessId(), hFile, MiniDumpNormal, excpInfo ? &amp;eInfo : NULL, NULL, NULL); } } int __cdecl RecordExceptionInfo(PEXCEPTION_POINTERS pExceptPtrs, const TCHAR *szDumpNamePrefix) { static bool bFirstTime = true; if (!bFirstTime) return EXCEPTION_CONTINUE_SEARCH; bFirstTime = false; // Dmp文件命名：前缀_年月日.时.分.秒.毫秒.dmp // TCHAR szLocalTime[50] = { 0 }; SYSTEMTIME st; GetLocalTime(&amp;st); StringCchPrintf(szLocalTime, 50, TEXT(\"%04d%02d%02d.%02d.%02d.%02d.%04d\"), st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds); TCHAR szExeDir[MAX_PATH + 1] = { 0 }; GetModuleFileName(NULL, szExeDir, MAX_PATH); if (TCHAR *p = lstrrchr(szExeDir, TEXT('\\\\'))) { *(p + 1) = 0; } TCHAR szDumpFileName[MAX_PATH + 1] = { 0 }; _stprintf_s(szDumpFileName, MAX_PATH, TEXT(\"%s%s_%s.dmp\"), szExeDir, szDumpNamePrefix, szLocalTime); HANDLE hMiniDumpFile = CreateFile( szDumpFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL); if (hMiniDumpFile != INVALID_HANDLE_VALUE) { DumpMiniDump(hMiniDumpFile, pExceptPtrs); CloseHandle(hMiniDumpFile); hMiniDumpFile = NULL; } return EXCEPTION_EXECUTE_HANDLER; }} MAIN_BEGIN和WINMAIN_BEGIN中的参数为生成的 dump 文件的前缀，dump 文件命名方式: 前缀*年月日.时.分.秒.毫秒.dmp。 使用方法也很简单，使用MAIN_BEGIN替换main，WINMAIN_BEGIN替换WinMain即可： 123456789101112#include \"EasyDump.h\"MAIN_BEGIN(TEXT(\"Test\"))int i = 0;int *p = &amp;i;p = NULL;*p = 5;return 0;MAIN_END 上面的代码会在程序的当前目录生成一个名为 Test_20171101.14.49.57.0264.dmp 的 dump 文件。","link":"/post/2648186181.html"},{"title":"Windows注册URL协议","text":"当电脑安装完 Steam 后，我们在浏览器中访问steam://run/123，浏览器会自动提示打开 Steam 程序。类似的功能在迅雷、QQ 等产品上也都有使用，本文讲述如何实现该功能。 实现上述功能只需要在注册表HKEY_CLASSES_ROOT项下添加对应的子项即可，以注册test协议为例： 123456789101112131415indows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\test]@=\"URL:test protocol\"\"URL Protocol\"=\"\"[HKEY_CLASSES_ROOT\\test\\DefaultIcon]@=\"mytest.exe\"[HKEY_CLASSES_ROOT\\test\\Shell][HKEY_CLASSES_ROOT\\test\\Shell\\Open][HKEY_CLASSES_ROOT\\test\\Shell\\Open\\Command]@=\"\\\"D:\\\\sourcecode\\\\mytest.exe\\\" -- \\\"%1\\\"\" 修改完之后，在浏览器中输入test://start/123就会打开D:\\\\sourcecode\\\\mytest.exe，并且传递给mytest.exe的命令行参数为test://start/123。","link":"/post/1343547595.html"},{"title":"Windows用户界面特权隔离(UIPI)","text":"在早期的 Windows 操作系统中，在同一用户下运行的所有进程有着相同的安全等级，拥有相同的权限。此时进程可以自由地发送Windows 消息到其他进程的窗口。 从 Windows Vista 开始，对于某些 Windows 消息，这一方式再也行不通了，进程（或者其他的对象）开始拥有一个新的属性–特权等级(Privilege Level)。此时一个特权等级较低的进程不再可以向特权等级较高的进程发送消息，即便他们在相同的用户权限下运行也不行，这就是所谓的用户界面特权隔离(User Interface Privilege Isolation, 简称 UIPI)。 引入 UIPI 的目的是为了防止恶意程序发送消息给那些拥有较高权限的窗口，从而利用该进程的高权限达到某种目的等等。 一、UIPI 的运行机制在 Windows 7 中，当 UAC(User Account Control)启用的时候，UIPI 的运行可以得到最明显的体现。在 UAC 中，当一个管理员用户登录系统后，操作系统会创建两个令牌对象(Token Object)：一个是管理员令牌，拥有大多数特权(类似于 Windows Vista 之前的 System 中的用户)，而另一个是经过过滤后的简化版本，只拥有普通用户的权限。 默认情况下，以普通用户权限启动的进程拥有普通特权等级【UIPI 的等级划分为低等级(low)，普通(normal)，高等级(high)，系统(system)】。同样的，以管理员权限运行的进程（例如用户右键单击选择“以管理员身份运行”或者是通过添加“runas”参数调用 ShellExecute 运行的进程）拥有高(high)特权等级。 系统中会运行多种不同类型、不同特权等级的进程(当然，从技术上讲这两个进程都是在同一用户下)。我们可以使用Windows Sysinternals工具集中的Process Explorer查看各个进程的特权等级。 所以，当发现进程之间 Windows 消息通信发生问题时，不妨使用Process Explorer查看一下两个进程之间是否有合适的特权等级。 二、UIPI 所带来的限制正如我们前文所说，等级的划分，是为了防止以下犯上。所以，有了用户界面特权隔离，一个运行在较低特权等级的应用程序的行为就受到了诸多限制，它不可以进行如下操作： 验证由较高特权等级进程创建的窗口句柄 通过调用 SendMessage 和 PostMessage 向由较高特权等级进程创建的窗口发送 Windows 消息 使用线程钩子处理较高特权等级进程 使用普通钩子(SetWindowsHookEx)监视较高特权等级进程 向一个较高特权等级进程执行 DLL 注入 但是，一些特殊 Windows 消息是被容许的，因为这些消息对进程的安全性没有太大影响。这些 Windows 消息包括： 123456789101112 0x000 - WM_NULL 0x003 - WM_MOVE 0x005 - WM_SIZE 0x00D - WM_GETTEXT 0x00E - WM_GETTEXTLENGTH 0x033 - WM_GETHOTKEY 0x07F - WM_GETICON 0x305 - WM_RENDERFORMAT 0x308 - WM_DRAWCLIPBOARD 0x30D - WM_CHANGECBCHAIN 0x31A - WM_THEMECHANGED 0x313, 0x31B (WM_???) 三、修复 UIPI 问题基于 Windows Vista 之前的操作系统行为所设计的应用程序，可能希望 Windows 消息能够在进程之间自由的传递以完成一些特殊的工作。当这些应用程序在 Windows 7/10/11 上运行时，因为 UIPI 机制的存在，这种消息传递被阻断了，应用程序就会遇到兼容性问题。 为了解决这个问题，Windows Vista 引入了新的 API 函数ChangeWindowMessageFilter和ChangeWindowMessageFilterEx。在特权等级较高的进程中利用这 2 个函数可以添加或者删除能够通过特权等级隔离的 Windows 消息。这就像拥有较高特权等级的进程设置了一个过滤器，被允许通过的 Windows 消息都将被添加到这个过滤器的白名单，只有在这个白名单上的消息才允许传递进来。 下面对添加/移除白名单功能进行了简单封装（UIPIMsgFilter函数），该函数可以针对特定的窗体添加、移除消息白名单： 123456789101112131415161718192021222324252627282930313233343536373839404142BOOL UIPIMsgFilter(HWND hWnd, UINT uMessageID, BOOL bAllow) { OSVERSIONINFO VersionTmp; VersionTmp.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); GetVersionEx(&amp;VersionTmp); BOOL res = FALSE; if (VersionTmp.dwMajorVersion &gt;= 6) { // vista above. BOOL(WINAPI * pfnChangeMessageFilterEx)(HWND, UINT, DWORD, PCHANGEFILTERSTRUCT); BOOL(WINAPI * pfnChangeMessageFilter)(UINT, DWORD); CHANGEFILTERSTRUCT filterStatus; filterStatus.cbSize = sizeof(CHANGEFILTERSTRUCT); HINSTANCE hlib = LoadLibrary(_T(\"user32.dll\")); if (hlib != NULL) { (FARPROC &amp;)pfnChangeMessageFilterEx = GetProcAddress(hlib, \"ChangeWindowMessageFilterEx\"); if (pfnChangeMessageFilterEx != NULL &amp;&amp; hWnd != NULL) { res = pfnChangeMessageFilterEx(hWnd, uMessageID, (bAllow ? MSGFLT_ADD : MSGFLT_REMOVE), &amp;filterStatus); } // If failed, try again. if (!res) { (FARPROC &amp;)pfnChangeMessageFilter = GetProcAddress(hlib, \"ChangeWindowMessageFilter\"); if (pfnChangeMessageFilter != NULL) { res = pfnChangeMessageFilter(uMessageID, (bAllow ? MSGFLT_ADD : MSGFLT_REMOVE)); } } } if (hlib != NULL) { FreeLibrary(hlib); } } else { res = TRUE; } return res;} 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/2701401097.html"},{"title":"Windows的DLL全局共享变量","text":"同一个DLL文件可以被多个进程加载。当不同的进程将DLL映射到自己的内存空间时，系统会为DLL中的全局和静态变量创建不同的实例，而不会共享同一个变量实例。 那我们如何实现在进程间共享DLL全局变量呢？我们可以在DLL中使用如下语句来创建一个段，用来存放那些需要共享的变量： 1234#pragma data_seg(\"AnyName\") // 开始// 声明变量// ....#pragma data_seg() // 结束 共享的变量需要被初始化，并且还要设置链接器开关，使该段在所有映射DLL的进程中成为共享读写属性： 12// 共享读写#pragma comment(linker,\"/SECTION:AnyName,RWS\") 经过上述操作，共享的变量就可以跨不同进程进行读写操作了。","link":"/post/3002178342.html"},{"title":"Windows程序如何删除自身","text":"本文介绍几种实现在程序退出后，从磁盘删除自身 exe 文件的方式。该技术通常应用于安装包卸载程序中。 一、借用 choice 命令实现Windows 提供了 choice 命令，允许用户从选择列表选择一个项目并返回所选项目的索引。 1234567891011121314151617181920212223242526272829303132C:\\Users\\akx&gt;choice /?CHOICE [/C choices] [/N] [/CS] [/T timeout /D choice] [/M text]描述: 该工具允许用户从选择列表选择一个项目并返回所选项目的索引。参数列表: /C choices 指定要创建的选项列表。默认列表是 \"YN\"。 /N 在提示符中隐藏选项列表。提示前面的消息得到显示， 选项依旧处于启用状态。 /CS 允许选择分大小写的选项。在默认情况下，这个工具 是不分大小写的。 /T timeout 做出默认选择之前，暂停的秒数。可接受的值是从 0 到 9999。如果指定了 0，就不会有暂停，默认选项 会得到选择。 /D choice 在 nnnn 秒之后指定默认选项。字符必须在用 /C 选 项指定的一组选择中; 同时，必须用 /T 指定 nnnn。 /M text 指定提示之前要显示的消息。如果没有指定，工具只 显示提示。示例: CHOICE /? CHOICE /C YNC /M \"确认请按 Y，否请按 N，或者取消请按 C。\" CHOICE /T 10 /C ync /CS /D y CHOICE /C ab /M \"选项 1 请选择 a，选项 2 请选择 b。\" CHOICE /C ab /N /M \"选项 1 请选择 a，选项 2 请选择 b。\" 实现方式如下： 123456789101112131415161718192021222324252627bool DeleteSelf { wchar_t szSystemDir[MAX_PATH] = {0}; if (GetSystemDirectoryW(szSystemDir, MAX_PATH) &gt; 0) { PathAddBackslashW(szSystemDir); } wchar_t szFullCmd[MAX_PATH] = {0}; StringCchPrintfW(szFullCmd, MAX_PATH, L\"%scmd.exe /C choice /C Y /N /D Y /T 4 &amp; rmdir \\\"%s\\\" /Q\", szSystemDir, szPath); STARTUPINFOW si = {sizeof(STARTUPINFOW)}; PROCESS_INFORMATION pi; if (CreateProcessW(NULL, szFullCmd, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, szSystemDir, &amp;si, &amp;pi)) { if (pi.hThread) CloseHandle(pi.hThread); if (pi.hProcess) CloseHandle(pi.hProcess); return true; } return false;}int main() { bool ret = DeleteSelf(); return 0;} 二、使用计划任务实现在程序退出前添加 Windows 计划任务，计划任务在程序退出几秒后执行删除文件的操作。 这种实现方式需要程序具有管理员权限。 此处省略具体的实现方式。","link":"/post/3102005562.html"},{"title":"Windows音频环回录制","text":"所谓音频环回录制就是录制扬声器播放的声音。播放到扬声器的声音已经过混合，Windows 提供了 WASAPI 来获取这种混合的音频信号。 本文将录制到原始音频样本数据写入到文件，可以使用Audacity导入原始数据试听。 在 Audacity 中导入原始数据时需要选择正确的音频参数，否则会导致无法播放。 初始化设备声明相关变量： 12345IMMDeviceEnumerator* pDeviceEnum = NULL;IMMDevice* pDevice = NULL;IAudioClient* pAudioClient = NULL;WAVEFORMATEX* pWaveFormat = NULL;IAudioCaptureClient* pAudioCaptureClient = NULL; 获取默认音频输出设备并初始化环回录制服务： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455HRESULT InitRecord() { HRESULT hr; hr = CoCreateInstance(CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, IID_IMMDeviceEnumerator, (void**)&amp;pDeviceEnum); if (FAILED(hr)) { printf(\"Create device enumerator failed, hr: 0x%x\", hr); return hr; } hr = pDeviceEnum-&gt;GetDefaultAudioEndpoint(eRender, eConsole, &amp;pDevice); if (FAILED(hr)) { printf(\"Get default audio device failed, hr: 0x%x\", hr); return hr; } hr = pDevice-&gt;Activate(IID_IAudioClient, CLSCTX_ALL, NULL, (void**)&amp;pAudioClient); if (FAILED(hr)) { printf(\"Create audio client failed, hr: 0x%x\", hr); return hr; } hr = pAudioClient-&gt;GetMixFormat(&amp;pWaveFormat); if (FAILED(hr)) { printf(\"Get mix format failed, hr: 0x%x\", hr); return hr; } printf(\"Channel: %d, SamplesPerSec: %d, BitsPerSample: %d\\n\", pWaveFormat-&gt;nChannels, pWaveFormat-&gt;nSamplesPerSec, pWaveFormat-&gt;wBitsPerSample); hr = pAudioClient-&gt;Initialize(AUDCLNT_SHAREMODE_SHARED, AUDCLNT_STREAMFLAGS_LOOPBACK, BUFFER_TIME_100NS, 0, pWaveFormat, NULL); if (FAILED(hr)) { // 兼容Nahimic音频驱动 // https://github.com/rainmeter/rainmeter/commit/0a3dfa35357270512ec4a3c722674b67bff541d6 // https://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/bd8cd9f2-974f-4a9f-8e9c-e83001819942/iaudioclient-initialize-failure // 初始化失败，尝试使用立体声格式进行初始化 pWaveFormat-&gt;nChannels = 2; pWaveFormat-&gt;nBlockAlign = (2 * pWaveFormat-&gt;wBitsPerSample) / 8; pWaveFormat-&gt;nAvgBytesPerSec = pWaveFormat-&gt;nSamplesPerSec * pWaveFormat-&gt;nBlockAlign; hr = pAudioClient-&gt;Initialize(AUDCLNT_SHAREMODE_SHARED, AUDCLNT_STREAMFLAGS_LOOPBACK, BUFFER_TIME_100NS, 0, pWaveFormat, NULL); if (FAILED(hr)) { printf(\"Initialize audio client failed, hr: 0x%x\", hr); return hr; } } hr = pAudioClient-&gt;GetService(IID_IAudioCaptureClient, (void**)&amp;pAudioCaptureClient); if (FAILED(hr)) { printf(\"Get audio capture client failed, hr: 0x%x\", hr); return hr; } return S_OK;} 采样在初始化成功后，开启独立线程按固定间隔获取缓冲区中的音频样本。exitFlag用于控制线程是否退出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 线程处理函数void QueryAudioSampleThread() { UINT32 bufferFrameCount = 0; HRESULT hr = pAudioClient-&gt;GetBufferSize(&amp;bufferFrameCount); if (FAILED(hr)) { printf(\"Get buffer frame count failed, hr: 0x%x\", hr); return; } // 根据实际缓冲区中的样本数计算实际填满缓冲区需要的时间 REFERENCE_TIME hnsActualDuration = (double)BUFFER_TIME_100NS * bufferFrameCount / pWaveFormat-&gt;nSamplesPerSec; UINT32 packetLength = 0; BYTE* buffer = NULL; UINT32 numFramesAvailable = 0; DWORD flags = 0; while (!exitFlag.load()) { // 等待半个缓冲周期 Sleep(hnsActualDuration / 10000 / 2); hr = pAudioCaptureClient-&gt;GetNextPacketSize(&amp;packetLength); if (FAILED(hr)) { printf(\"Get next package size failed, hr: 0x%x\", hr); break; } while (packetLength &gt; 0) { hr = pAudioCaptureClient-&gt;GetBuffer(&amp;buffer, &amp;numFramesAvailable, &amp;flags, NULL, NULL); if (FAILED(hr)) { printf(\"Get capture buffer failed, hr: 0x%x\", hr); break; } // 将捕获到的样本写入文件 if (!WriteSample(buffer, numFramesAvailable * pWaveFormat-&gt;nChannels * pWaveFormat-&gt;wBitsPerSample / 8)) { printf(\"Write sample to file failed\"); } hr = pAudioCaptureClient-&gt;ReleaseBuffer(numFramesAvailable); if (FAILED(hr)) { printf(\"Release capture buffer failed, hr: 0x%x\", hr); break; } hr = pAudioCaptureClient-&gt;GetNextPacketSize(&amp;packetLength); if (FAILED(hr)) { printf(\"Get next package size failed, hr: 0x%x\", hr); break; } } }} Sample和Frame的含义pWaveFormat-&gt;nSamplesPerSec表示每秒采样的次数，如48000的采样率就是每秒采48000个Sample，一个Sample 是一个声道的一个采样。 而Frame 则是一个时间点的Sample集合，举例来说，一个线性的PCM 双声道音频文件每个Frame有2个Sample，一个左声道Sample，和一个右声道Sample。 释放设备和内存在录制结束后释放设备和内存： 1234567891011void UnInitRecord() { if (pWaveFormat) { CoTaskMemFree(pWaveFormat); pWaveFormat = NULL; } SAFE_RELEASE(pDeviceEnum); SAFE_RELEASE(pDevice); SAFE_RELEASE(pAudioClient); SAFE_RELEASE(pAudioCaptureClient);} 完整示例代码见：AudioLoopbackRecord.cpp","link":"/post/2236960039.html"},{"title":"《Windows核心编程》","text":"本栏目主要介绍与 Windows 系统编程相关的技术。 文章列表： 了解DPI缩放 理解C/C++运行时库 Windows用户界面特权隔离(UIPI) Windows内核对象 Windows平台生成Dump文件 Windows注册URL协议 Windows程序如何删除自身 C++获取其他Windows进程命令行 Windows实现文件强制占用 Windows音频环回录制 窗口无法接收WM_LBUTTONDBLCLK消息 由HANDLE返回值不确定性引发的思考 为什么SetParent会失败 Windows API的不同返回状态","link":"/post/1395226543.html"},{"title":"为什么SetParent会失败","text":"SetParent是Windows提供的设置窗口父窗体的API，函数原型比较简单： 1234HWND SetParent( [in] HWND hWndChild, [in, optional] HWND hWndNewParent); 我们通常的使用方法是： 123if(!SetParent(hChild, hParent)) { // Failed} 这种使用方法在大多情况下不会失败，但有时却会失败。究其原因，其在微软官方文档中已有说明SetParent Doc。 由于兼容性问题，SetParent函数不会修改hWndChild窗口的WS_CHILD和WS_POPUP样式，因此： 如果hWndNewParent为NULL，你需要在调用SetParent函数后清除WS_CHILD并设置WS_POPUP样式。 如果hWndNewParent不为NULL并且hWndChild之前是桌面的子窗口，你需要在调用SetParent函数前清除WS_POPUP并设置WS_CHILD样式。 总结上述原因，SetParent的正确使用方法如下： 123456789101112131415161718192021222324bool SetWinParent(HWND hChild, HWND hNewParent) { HWND hOldParent = NULL; if (hNewParent) { LONG newStyle = GetWindowLong(hChild, GWL_STYLE); newStyle &amp;= ~WS_POPUP; newStyle |= WS_CHILD; SetWindowLong(hChild, GWL_STYLE, newStyle); hOldParent = ::SetParent(hChild, hNewParent); } else { hOldParent = ::SetParent(hChild, hNewParent); LONG newStyle = GetWindowLong(hChild, GWL_STYLE); newStyle &amp;= ~WS_CHILD; newStyle |= WS_POPUP; SetWindowLong(hChild, GWL_STYLE, newStyle); } return !!hOldParent;}","link":"/post/3832058229.html"},{"title":"了解DPI缩放","text":"dpi 是“Dots Per Inch”的缩写，表示每英寸的像素点个数，也就是像素点的密集度。 dpi不是用来表示屏幕分辨率的，也不是用来表示屏幕物理尺寸的。 dpi = 总像素点 / 物理面积 比如一个 32 寸的显示，但分辨率只有1920*1440，而一个 24 寸的显示器，分辨率却达到3840*2160，很明显后面这个显示器的每英寸的像素点的个数多，显示的画面更加细腻。所以：高分辨率不等于高 dpi。 苹果的视网膜屏幕的核心就是高 dpi：屏幕物理面积小，而分辨率高达 5k，每英寸的像素点（dpi）固然多，画面自然细腻。 软件显示异常为什么高 DPI 显示器会导致某些软件显示异常了？ 随着 2K、4K 显示器的普及，在使用这些高 DPI 显示器时，我们为了使软件界面看起来不至于太小，导致视觉疲劳，一般会在系统中设置缩放比例。 Windows 操作系统对高 dpi 显示器缩放支持最好的是 windows 10+，建议在使用高 DPI 显示器时搭配 Windows 10+操作系统。 假设现有一个软件，其界面宽 950 像素，高 700 像素，该软件在 24 寸、分辨率为1900*1400的显示器上显示正常，但放到高 dpi 显示器（同样是 24 寸，但分辨率为3800*2800）上显示效果会如何？ 从上图可以看到，同样尺寸的软件界面，在高 dpi 显示器上会显得非常小，会对使用者会造成严重的视觉疲劳。 所以我们的软件需要针对高 dpi 进行适配和缩放。 Windows 10+系统的DPI缩放规则Windows 10+操作系统针对 dpi 缩放制定了 3 种规则，每个进程都必须匹配下面的一种规则，默认为PROCESS_DPI_UNAWARE： PROCESS_DPI_UNAWARE在软件启动时， 操作系统会自动将软件进行缩放拉伸；在系统 dpi 缩放改变时，系统也会将软件自动进行缩放拉伸，但软件不会收到 WM_DPICHANGED 消息。 PROCESS_SYSTEM_DPI_AWARE在软件启动时，系统不会将软件进行缩放拉伸；但在系统 dpi 缩放改变时，系统会将软件进行缩放拉伸，但软件仍然不会收到 WM_DPICHANGED 消息。 PROCESS_PER_MONITOR_DPI_AWARE在软件启动时，系统不会将软件进行缩放拉伸；同样，在系统 dpi 缩放改变时，系统也不会将软件进行缩放拉伸，但软件会收到 WM_DPICHANGED 消息。 详见：dpi_awareness","link":"/post/50218900.html"},{"title":"理解C&#x2F;C++运行时库","text":"运行时库（Runtime library）通俗的说就是我们的程序运行的时候所依赖的库文件。在 Windows 平台，这些库由微软提供，并以 2 种形式提供：静态库(lib)、动态库(lib+dll)，每个库还分别提供了 Debug 和 Release 两个版本。 一、什么是运行时库C/C++运行时库从形式上来讲和我们自己开发的静态库、动态库没什么两样，只是它们由微软开发和维护，并提供了一些常用的功能支持（如malloc, free, printf等等），如果我们的程序需要使用这些功能（事实上，只要是 C/C++程序就一定会用到运行时库提供的功能），就要链接 C/C++运行时库。我们可以自主选择是链接“静态库”还是“动态库”，是链接“debug 版本”的还是“release 版本”的。 二、如何链接运行时库大家可能注意到我们在平时开发中从来没有显式的来链接这些库，这是为什么了？因为我们的编译器为我们提供了便利，我们只需要向编译器指定特定的编译选项（如MT、MD、MTd、MDd），编译器就会自动链接对应的库。 同时，编译器会根据MT和MD来定义相应的预处理宏：MT 对应 _MT宏，MD对应_MD宏。 例如，我们通过Visual Studio开发 C/C++程序时，在工程属性中配置“运行库”为MT、MD、MTd、MDd中的一个：就相当于间接的向编译器指定编译选项和定义相应的宏。 三、不同版本和形态的运行时库3.1 运行时库对应的文件下表列出各种编译选项的含义以及对应的库文件： 类型 全称 含义 对应的库文件 备注 ML Single-Threaded Release 版的单线程静态库 libc.lib 从 VS2005 起被废弃 MLd Single-Threaded Debug Debug 版的单线程静态库 libcd.lib 从 VS2005 起被废弃 MT Multi-threaded Release 版的多线程静态库 libcmt.lib MTd Multi-threaded Debug Debug 版的多线程静态库 libcmtd.lib MD Multi-threaded DLL Release 版的多线程动态库 msvcrt.lib + msvcrxxx.dll msvcprt.lib+msvcpxxx.dll MDd Multi-threaded DLL Debug Debug 版的多线程动态库 msvcrtd.lib + msvcrxxxd.dll msvcprtd.lib + msvcpxxxd.dll 如果计算机上安装了多个版本的 VC++运行环境（或者多个版本的 Visual Studio），则相同名称的 lib 或 dll 就会存在多份。如msvcrt.lib文件： 3.2 运行时库文件命名规则msvcr100d.dll为例： 123456ms = Microsoftv = Visualc = C Programr = Run-time100 = Versiond = Debug (不带d即为release版本) msvcp100d.dll为例： 12345ms = Microsoftv = Visualcp = C Plus Plus 即C++100 = Versiond = Debug (不带d即为release版本) 四、运行时库使用注意事项 不要混合使用运行时库的静态库版和动态库版。 不要混合使用运行时库的debug版和release版。 不要混合使用 Visual Studio 2013 及更早版本的运行时库，但在 Visual Studio 2015 及更高版本中提供的运行时库可以保证二进制兼容。 五、Visual Studio 版本之间的 C++ 二进制兼容性（摘自 MSDN） 原文链接：binary-compat-2015-2017 Visual Studio 2013 及更早版本中的 Microsoft C++ (MSVC) 编译器工具集不保证主版本间的二进制兼容性。 无法链接由这些工具集的不同版本生成的对象文件、静态库、动态库和可执行文件。 ABI、对象格式和运行时库不兼容。 我们在 Visual Studio 2015 及更高版本中改变了此行为。 由其中任一版本的编译器编译的运行时库和应用具有二进制兼容性。 这反映在 C++ 工具集主版本号中，对于自 Visual Studio 2015 以来的所有版本，该版本号都以 14 开头。 （对于 Visual Studio 2015、2017、2019 和 2022，工具集版本分别为 v140、v141、v142 和 v143）。** 假设你具有 Visual Studio 2015 生成的第三方库。 你仍可在 Visual Studio 2017、2019 或 2022 生成的应用程序中使用它们。 无需使用匹配工具集重新编译**。 最新版本的 Microsoft Visual C++ 可再发行程序包（可再发行程序包）适用于所有版本。 对二进制兼容性的限制v140、v141、v142 和 v143 工具集与次要版本号更新之间的二进制兼容性方面存在三个重要限制： 你可以混合使用由 v140、v141、v142 和 v143 工具集的不同版本生成的二进制文件。 但是，必须使用至少与应用中最新二进制文件同样新的工具集进行链接。 下面是一个示例：可以将使用任何 2017 工具集（v141，版本 15.0 到 15.9）编译的应用链接到使用 Visual Studio 2019 版本 16.2 (v142) 编译的静态库。 只是必须使用版本 16.2 或更高版本工具集链接它们。 只要使用 16.4 或更高版本工具集，便可以将版本 16.2 库链接到版本 16.4 应用。 应用使用的可再发行程序包具有类似的二进制兼容性限制。 混合使用由工具集的不同受支持版本生成的二进制文件时，可再发行程序包版本必须至少与任何应用组件使用的最新工具集一样新。 使用/GL（全程序优化）编译器开关编译或是使用 /LTCG（链接时间代码生成）链接的静态库或对象文件不在各个版本间二进制兼容（包括次要版本更新）。使用 /GL 和 /LTCG 编译的所有对象文件和库必须将完全相同的工具集用于编译和最终链接。 例如，使用 Visual Studio 2019 版本 16.7 工具集中的 /GL生成的代码无法链接到使用 Visual Studio 2019 版本 16.8 工具集中的 /GL生成的代码。 编译器会发出错误 C1047。 从 Visual Studio 2015 及更高版本升级 Microsoft Visual C++ 可再发行程序包对于 Visual Studio 2015、2017、2019 和 2022，我们使 Microsoft Visual C++ 可再发行程序包主版本号保持相同。 这意味着一次只能安装可再发行程序包的一个实例。 较新版本会覆盖已安装的任何较旧版本。 例如，一个应用可能会从 Visual Studio 2015 安装可再发行程序包。 随后另一个应用从 Visual Studio 2022 安装可再发行程序包。 2022 版本会覆盖较旧版本，但由于它们具有二进制兼容性，早期应用仍可正常工作。 我们确保最新版本的可再发行程序包具有所有最新的功能、安全更新和 bug 修补程序。 这便是为什么我们始终建议升级到最新可用版本。 同样，已安装了较新版本时，无法安装较旧的可再发行程序包。 如果尝试，则安装程序会报告错误。 如果在已具有 2022 版本的计算机上安装 2017 或 2019 可再发行程序，则会看到如下所示的错误： 10x80070666 - Another version of this product is already installed. Installation of this version cannot continue. To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel. 此错误是设计使然。 建议保持安装最新版本。 请确保安装程序可以在无提示的情况下从此错误中恢复。 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/782629701.html"},{"title":"由HANDLE返回值不确定性引发的思考","text":"HANDLE返回值的不确定性指的是Windows API函数的返回值为HANDLE类型时，有两种表示失败的方式： HANDLE == NULL，如CreateEvent等 HANDLE == INVALID_HANDLE_VALUE，如CreateFile等 其中，NULL的值始终为0，而INVALID_HANDLE_VALUE的值为-1，其在32位和64位程序中分别使用0xFFFFFFFF和0xFFFFFFFFFFFFFFFF表示。 具体哪些函数失败时返回NULL，哪些返回INVALID_HANDLE_VALUE了？这个需要查阅MSDN文档来确定。 为什么会出现这两种情况了？ 根据Windows强大的兼容性，我们不能猜测出这么做是为了向前兼容，兼容以前的16位程序。 在16位程序中无效的HANDLE == INVALID_HANDLE_VALUE == 0xFFFF，而到了32位（或64位）时代，则使用0xFFFFFFFF（或0xFFFFFFFFFFFFFFFF）表示。 所以我们在判断HANDLE是否合法时，要特别留意，需要根据API的不同来做不同的判断。 需要注意GetCurrentProcess()用于获取当前进程的伪句柄，当前进程的伪句柄值是-1，恰好与INVALID_HANDLE_VALUE值相等。 因此用WaitForSingleObject等待INVALID_HANDLE_VALUE也就是等同于等待当前进程结束。","link":"/post/3906615635.html"},{"title":"窗口如何逃脱显示桌面指令","text":"在Windows系统中，在按下Win+D快捷键等操作执行“显示桌面”时，会将桌面上的所有窗口都最小化到任务栏，再次按下还原窗口。在显示桌面时，有些窗口仍然保持显示状态，不被最小话，即称之为逃脱显示桌面指令。 实现逃脱显示桌面的方式有三种，每种方式有不同的应用场景。 一、置顶窗口的方式首先创建WS_EX_TOOLWINDOW风格的窗口，WS_EX_TOOLWINDOW风格的窗口不会出现在任务栏，而且按ALT+TAB时也不会显示，然后为该窗口设置WS_EX_TOPMOST样式，使其始终置顶。 可以在创建窗口时通过扩展样式来指定WS_EX_TOOLWINDOW和WS_EX_TOPMOST样式： 12345678910111213HWND hWnd = CreateWindowExW( WS_EX_TOOLWINDOW | WS_EX_TOPMOST, szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); 也可以先创建窗口，然后修改窗口样式： 1234LONG_PTR oldStyle = GetWindowLongPtr(hWnd, GWL_EXSTYLE);oldStyle |= WS_EX_TOOLWINDOW;SetWindowLongPtr(hWnd, GWL_EXSTYLE, oldStyle); 并通过SetWindowPos函数来置顶窗口： 1SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE); 这种方式对系统的兼容性比较好，经测试可以支持Windows XP/7/8/10/11系统。但这种方式会导致窗口一直置顶显示，对于不需要置顶显示的窗口，这种方式就不适用了。 二、改变窗口所有者的方式在执行显示桌面指令时，桌面仍然会显示，因此我们可以将窗口的所有者设置为桌面窗口，来确保窗口不受“显示桌面”指令的影响。 2.1 查找桌面窗口在Win7及之前的系统中，桌面窗口是Program Manager窗口的子窗口，如下图所示： 而在Win8及以后的系统，桌面窗口变成了WorkerW窗口的子窗口，如下图所示： 因此在查找桌面窗口句柄时，需要根据不同的系统环境采用不同的查找方式。 123456789101112131415161718192021HWND FindShellDefViewWnd() { HWND hShellDefView = nullptr; // Try Win7 and later HWND hProgmanWnd = FindWindowW(L\"Progman\", L\"Program Manager\"); if (hProgmanWnd) { hShellDefView = FindWindowExW(hProgmanWnd, NULL, L\"SHELLDLL_DefView\", NULL); } // Try &gt; Win7 if (!hShellDefView) { // When this fails, then look for the WorkerW windows list to get the correct desktop list handle. HWND hDesktop = GetDesktopWindow(); HWND hWorkerW = NULL; do { hWorkerW = FindWindowExW(hDesktop, hWorkerW, L\"WorkerW\", NULL); hShellDefView = FindWindowExW(hWorkerW, NULL, L\"SHELLDLL_DefView\", NULL); } while (hShellDefView == NULL &amp;&amp; hWorkerW != NULL); } return hShellDefView;} 2.2 设置窗口拥有者现在我们将窗口的拥有者设置为SHELLDLL_DefView窗口即可逃脱显示桌面的指令了。 12345678bool EscapeShowDesktop(HWND hWnd) { HWND hShellDefView = FindShellDefViewWnd(); if (hShellDefView) { SetWindowLongPtr(hWnd, GWL_HWNDPARENT, (LONG_PTR)hShellDefView); return true; } return false;} 需要注意： 采用这种方式可能会导致当前的活动桌面发生改变，这个行为会对某些Windows API产生影响，如会导致GetAsyncKeyState失效。 三、使用Appbar机制实现Windows提供了API来使应用程序具有模拟系统任务栏的能力，通常将模拟系统任务栏的程序成为Appbar（application desktop toolbar）。Appbar窗口不受显示桌面指令的控制，但该窗口会和任务栏一样占据一部分桌面可用空间，可以通过API控制占用空间的大小和位置。 关于如何使用Appbar的API，可以参考Windows官方文档:Using Application Desktop Toolbars","link":"/post/2065788833.html"},{"title":"认识Windows顶级(top-level)窗口","text":"在Windows API中经常会出现关于顶级窗口的描述，如EnumWindows： Enumerates all top-level windows on the screen by passing the handle to each window, in turn, to an application-defined callback function. EnumWindows continues until the last top-level window is enumerated or the callback function returns FALSE. 那么什么样的窗口才算得上是顶级窗口了？ 简而言之，没有WM_CHILD属性的窗口都可以称为顶级窗口。","link":"/post/1431775047.html"},{"title":"窗口无法接收WM_LBUTTONDBLCLK消息","text":"在开发中遇到了如下问题： 通过鼠标钩子获取某窗口的消息，发现可以接收到WM_LBUTTONDOWN消息，但始终无法接收到WM_LBUTTONDBLCLK消息。 经过一番排查，发现Windows窗口只有在拥有CS_DBLCLKS类样式时才能接收到鼠标双击事件，即在RegisterClassEx函数的WNDCLASSEX.style参数中指定CS_DBLCLKS样式。 但是窗口不是我们自己创建的，能否通过SetClassLongPtr函数来通过句柄改变窗口类样式，经过多方尝试最终以失败告终（SetClassLongPtr返回值0，GetLastError也为0）。","link":"/post/1955778079.html"},{"title":"Windows套接字I&#x2F;O模型(1)-阻塞模型","text":"套接字I/O的阻塞模型是最常见的网络模型，也是在Socket编程时通常最早接触的一个模型。因为它是阻塞的，所以我们一般都会结合线程一起使用（如将accept，recv等放到单独的线程），防止程序主线程被阻塞。 下面的示例为了演示了阻塞模型使用的基本流程没有请其放到独立的线程中执行。 一、服务端服务端大致流程: 创建Socket Bind端口 开始Listen accept客户端连接（一般在子线程中不间断accept） send数据到客户端（也可以recv） close socket 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;winsock2.h&gt;#include &lt;iostream&gt;#include &lt;assert.h&gt;using namespace std;#pragma comment(lib, \"Ws2_32.lib\")const u_short kPort = 10001;const std::string kHelloServer = \"hello, I'm server.\";int main(){ WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket_ = INVALID_SOCKET; SOCKET s_ = INVALID_SOCKET; do { // (1) socket_ = ::socket(AF_INET, SOCK_STREAM, 0); if (socket_ == INVALID_SOCKET) { std::cout &lt;&lt; \"create socket failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } // (2) struct sockaddr_in addr = { 0 }; addr.sin_family = AF_INET; addr.sin_addr.s_addr = htonl(INADDR_ANY); addr.sin_port = htons(kPort); if (bind(socket_, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) { std::cout &lt;&lt; \"bind failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } // (3) if (listen(socket_, 5) == SOCKET_ERROR) { std::cout &lt;&lt; \"listen failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } std::cout &lt;&lt; \"listen on port: \" &lt;&lt; kPort &lt;&lt; std::endl; // (4) while (true) { struct sockaddr_in addr_c = { 0 }; int addr_len = sizeof(addr_c); SOCKET s = accept(socket_, reinterpret_cast&lt;sockaddr*&gt;(&amp;addr_c), &amp;addr_len); if (s == SOCKET_ERROR) { std::cout &lt;&lt; \"accept failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } std::cout &lt;&lt; \"new connection\" &lt;&lt; endl; // (5) // 此处使用while循环send，详见 三、流协议 int left = kHelloServer.length(); int idx = 0; while (left &gt; 0) { int err = send(s, (const char*)(kHelloServer.c_str() + idx), left, 0); if (err == SOCKET_ERROR) { std::cout &lt;&lt; \"send failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } left -= err; idx += err; std::cout &lt;&lt; \"bytes sent: \" &lt;&lt; err &lt;&lt; std::endl; } } } while (false); // (6) closesocket(socket_); closesocket(s_); WSACleanup(); return 0;} 二、客户端客户端大致流程： 创建Socket connect服务端 recv接收数据从服务端(也可以send) close socket 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;winsock2.h&gt;#include &lt;assert.h&gt;#pragma comment(lib, \"Ws2_32.lib\")const std::string kIP = \"127.0.0.1\";const u_short kPort = 10001;const std::string kHelloClient = \"hello, I'm client.\";int main(){ WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket_ = INVALID_SOCKET; do { // (1) socket_ = ::socket(AF_INET, SOCK_STREAM, 0); if (socket_ == INVALID_SOCKET) { std::cout &lt;&lt; \"create socket failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } // (2) struct sockaddr_in addr = { 0 }; addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(kIP.c_str()); addr.sin_port = htons(kPort); if (connect(socket_, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) { std::cout &lt;&lt; \"connect failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } // (3) char buf[100] = { 0 }; int err = recv(socket_, buf, 100, 0); if (err &gt; 0) { std::cout &lt;&lt; \"recv: \" &lt;&lt; buf &lt;&lt; std::endl; } else if (err == 0) { std::cout &lt;&lt; \"connection closed.\" &lt;&lt; std::endl; break; } else { std::cout &lt;&lt; \"recv failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } } while (false); // (4) closesocket(socket_); WSACleanup(); return 0;} 三、流协议由于大多数面向连接的协议（如TCP）也是流协议。在流协议中，发送者和接收者可以将数据分解成小块数据，或将数据合并成大块数据。对于流套接字上收发数据所有用的函数（如send, recv），需要知道的是：它们不能保证要求进行读取或写入的数据量。比如用send发送一个有1024字节的字符缓冲区时，send函数可能返回的已发出的字节数少于1024。因为对每个收发数据的套接字来说，系统都为它们分配了充足的缓冲区空间，所以send的返回值将被设为已经发送的字节数。 针对这种情况，要保证缓冲区所有数据都被发送出去，可以采用下面的代码： 1234567891011121314int left = kHelloServer.length();int idx = 0;while (left &gt; 0) { int err = send(s, (const char*)(kHelloServer.c_str() + idx), left, 0); if (err == SOCKET_ERROR) { std::cout &lt;&lt; \"send failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } left -= err; idx += err; std::cout &lt;&lt; \"bytes sent: \" &lt;&lt; err &lt;&lt; std::endl;} 对于接收数据来说，也可以采用上面的方式，但意义不大，因为我们一般都是循环的、不间断的接收数据，很少有上面的例子中的，只接收一次的情况。","link":"/post/2937580891.html"},{"title":"Windows套接字I&#x2F;O模型(2)-Select模型","text":"一、Select模型介绍套接字Select模型的中心思想是利用select函数实现对I/O的管理。利用select函数来判断套接字（一个或多个）上是否存在数据，或者能否向套接字写入数据。它也是同步的，也会阻塞。但和阻塞模型不同的是，Select模型可以同时管理多个Socket。 select函数原型： 1234567int select ( int nfds, fd_set FAR * readfds, fd_set FAR * writefds, fd_set FAR * exceptfds, const struct timeval FAR * timeout ); 第一个参数nfds会被忽略。之所以仍然要提供这个参数，只是为了保持与早期的Berkeley套接字应用程序的兼容。 三个fd_set参数：一个用于检查可读性（readfds），一个用于检查可写性（writefds），另一个用于例外数据（ excepfds）。 从根本上说，fdset数据类型代表着一系列特定套接字的集合。其中，readfds集合包括符合下述任何一个条件的套接字： 有数据可以读入。 连接已经关闭、重设或中止。(可以用来判断客户端或服务端程序是否退出了) 假如已调用了listen，而且一个连接正在建立，那么accept函数调用会成功。 writefds集合包括符合下述任何一个条件的套接字： 有数据可以发出。 如果已完成了对一个非锁定连接调用的处理，连接就会成功。 最后，exceptfds集合包括符合下述任何一个条件的套接字： 假如已完成了对一个非锁定连接调用的处理，连接尝试就会失败。 有带外（out-of-band，OOB）数据可供读取。 例如，假定我们想测试一个套接字是否“可读”，必须将自己的套接字增添到readfds集合，再等待select函数完成。select完成之后，必须判断自己的套接字是否仍为readfds集合的一部分。若答案是肯定的，便表明该套接字“可读”，可立即着手从它上面读取数据。在三个参数中（readfds、writedfss和exceptfds），任何两个都可以是空值（NULL）；但是，至少有一个不能为空值！在任何不为空的集合中，必须包含至少一个套接字句柄；否则，select函数便没有任何东西可以等待。 最后一个参数timeout对应的是一个指针，它指向一个timeval结构，用于决定select最多等待I/O操作完成多久的时间。如timeout是一个空指针，那么select调用会无限期地“锁定”或停顿下去，直到至少有一个描述符符合指定的条件后结束。对timeval结构的定义如下： 1234struct timeval { long tv_sec; long tv_usec;} ; 若将超时值设置为(0,0)，表明select会立即返回，允许应用程序对select操作进行“轮询”。出于对性能方面的考虑，应避免这样的设置。select成功完成后，会在fd_set结构中，返回刚好有未完成的I/O操作的所有套接字句柄的总量。若超过timeval设定的时间，便会返回0。不管由于什么原因，假如select调用失败，都会返回SOCKET_ERROR。用select对套接字进行监视之前，在自己的应用程序中，必须将套接字句柄分配给一个集合，设置好一个或全部读、写以及例外fd_set结构。将一个套接字分配给任何一个集合后，再来调用select，便可知道一个套接字上是否正在发生上述的I/O活动。 Winsock提供了下列宏操作，对fd_set进行处理与检查： 1234FD_CLR(s, *set); 从set中删除套接字s。FD_ISSET(s, *set); 检查s是否set集合的一名成员；返回TRUE或FALSE。FD_SET(s, *set); 将套接字s加入集合set。FD_ZERO(*set); 将set初始化成空集合。 二、示例2.1 服务端服务端代码比之前介绍的“套接字I/O 阻塞模型”中的示例稍微复杂一点。可以管理多个客户端的连接，对每个新的客户端发送“Hello，I’m server”问候信息，在客户端程序退出时自动关闭连接等功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;winsock2.h&gt;#include &lt;iostream&gt;#include &lt;assert.h&gt;#include &lt;vector&gt;using namespace std;#pragma comment(lib, \"Ws2_32.lib\")const u_short kPort = 10001;const std::string kHelloServer = \"hello, I'm server.\";int main(){ WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket_ = INVALID_SOCKET; std::vector&lt;SOCKET&gt; clients; do { // (1) socket_ = ::socket(AF_INET, SOCK_STREAM, 0); if (socket_ == INVALID_SOCKET) { std::cout &lt;&lt; \"create socket failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } // (2) struct sockaddr_in addr = { 0 }; addr.sin_family = AF_INET; addr.sin_addr.s_addr = htonl(INADDR_ANY); addr.sin_port = htons(kPort); if (bind(socket_, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) { std::cout &lt;&lt; \"bind failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } // (3) if (listen(socket_, 5) == SOCKET_ERROR) { std::cout &lt;&lt; \"listen failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } std::cout &lt;&lt; \"listen on port: \" &lt;&lt; kPort &lt;&lt; std::endl; fd_set fd_read; while (true) // TODO 未处理何时退出的问题 { // (4) FD_ZERO(&amp;fd_read); FD_SET(socket_, &amp;fd_read); for (std::vector&lt;SOCKET&gt;::iterator it = clients.begin(); it != clients.end(); ++it) FD_SET(*it, &amp;fd_read); // (5) timeval timeout = { 3, 0 }; int ret = select(0, &amp;fd_read, NULL, NULL, &amp;timeout); if (ret == SOCKET_ERROR) { std::cout &lt;&lt; \"select failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } // (6.1) // 检查服务端的监听socket，是否有新的连接被搁置 if (FD_ISSET(socket_, &amp;fd_read)) { // (7.1) struct sockaddr_in addr_c = { 0 }; int addr_len = sizeof(addr_c); SOCKET s = accept(socket_, reinterpret_cast&lt;sockaddr*&gt;(&amp;addr_c), &amp;addr_len); if (s == SOCKET_ERROR) { std::cout &lt;&lt; \"accept failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; } else { clients.push_back(s); std::cout &lt;&lt; \"new connection\" &lt;&lt; std::endl; int left = kHelloServer.length(); int idx = 0; while (left &gt; 0) { int err = send(s, (const char*)(kHelloServer.c_str() + idx), left, 0); if (err == SOCKET_ERROR) { std::cout &lt;&lt; \"send failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } left -= err; idx += err; std::cout &lt;&lt; \"bytes sent: \" &lt;&lt; err &lt;&lt; std::endl; } } } // (6.2) // 检查与客户端连接的socket，是否有数据可以读入 for (std::vector&lt;SOCKET&gt;::iterator it = clients.begin(); it != clients.end(); ) { if (FD_ISSET(*it, &amp;fd_read)) { // (7.2) char buf[100] = { 0 }; int err = recv(*it, buf, 100, 0); if (err &gt; 0) { std::cout &lt;&lt; \"recv: \" &lt;&lt; buf &lt;&lt; std::endl; ++it; } else if (err == 0) { std::cout &lt;&lt; \"connection closed.\" &lt;&lt; std::endl; closesocket(*it); it = clients.erase(it); } else { std::cout &lt;&lt; \"recv failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; closesocket(*it); it = clients.erase(it); } } else { ++it; } } } // while } while (false); // (8) for (std::vector&lt;SOCKET&gt;::iterator it = clients.begin(); it != clients.end(); ++it) { closesocket(*it); } // (9) closesocket(socket_); WSACleanup(); return 0;} 2.2 客户端客户端在连接上服务端之后，便可以不间断的接收服务端的消息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;winsock2.h&gt;#include &lt;iostream&gt;#include &lt;assert.h&gt;#include &lt;vector&gt;using namespace std;#pragma comment(lib, \"Ws2_32.lib\")const std::string kIP = \"127.0.0.1\";const u_short kPort = 10001;const std::string kHelloClient = \"hello, I'm client.\";int main(){ WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket_ = INVALID_SOCKET; do { // (1) socket_ = ::socket(AF_INET, SOCK_STREAM, 0); if (socket_ == INVALID_SOCKET) { std::cout &lt;&lt; \"create socket failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } // (2) struct sockaddr_in addr = { 0 }; addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(kIP.c_str()); addr.sin_port = htons(kPort); if (connect(socket_, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) { std::cout &lt;&lt; \"connect failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } fd_set fd_read; while (true) // TODO 未处理何时退出的问题 { // (3) FD_ZERO(&amp;fd_read); FD_SET(socket_, &amp;fd_read); // (4) timeval timeout = { 3, 0 }; int ret = select(0, &amp;fd_read, NULL, NULL, &amp;timeout); if (ret == SOCKET_ERROR) { std::cout &lt;&lt; \"select failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } // (5) if (FD_ISSET(socket_, &amp;fd_read)) { char buf[100] = { 0 }; int err = recv(socket_, buf, 100, 0); if (err &gt; 0) { std::cout &lt;&lt; \"recv: \" &lt;&lt; buf &lt;&lt; std::endl; } else if (err == 0) { std::cout &lt;&lt; \"connection closed.\" &lt;&lt; std::endl; break; } else { std::cout &lt;&lt; \"recv failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } } } // while } while (false); // (6) closesocket(socket_); WSACleanup(); return 0;}","link":"/post/640627104.html"},{"title":"Windows套接字I&#x2F;O模型(3)-WSAAsyncSelect模型","text":"一、WSAAsyncSelect模型介绍利用WSAAsyncSelect模型结合windows窗口消息循环，应用程序可以在一个套接字上接收以Windows消息为基础的网络事件通知。要想使用WSAAsyncSelect模型，首先必须创建一个Windows窗口，并为该窗口提供一个窗口过程支持函数。 123456int WSAAsyncSelect( _In_ SOCKET s, _In_ HWND hWnd, _In_ unsigned int wMsg, _In_ long lEvent); s 指定我们感兴趣的套接字。hWnd 指定一个窗口句柄，它表示网络事件发生之后，收到消息通知的那个窗口。wMsg 表示在网络事件发生时，窗口收到的消息。lEvent 代表一个掩码，指定应用程序感兴趣的网络事件的组合。事件类型包括：FD_READ，FD_WRITE，FD_CLOSE，FD_CONNECT，FD_ACCEPT。对于FD_CONNECT，FD_ACCEPT，服务端一般使用FD_ACCEPT，客户端一般使用FD_CONNECT。若将lEvent设置为0，则表示停止接收该套接字上的所有网络事件通知。 一旦调用WSAAsyncSelect在套接字上启用了事件通知，除非明确调用closesocket，或者再次调用WSAAsyncSelect重新设置网络事件类型，否则，事件通知总是有效的。 WSAAsyncSelect模型需要结合windows窗口来使用，不适用于没有界面的服务程序。建议使用WSAEventSelect模型来代替。 二、示例因为重点不在界面编程上面，所以示例中使用TraceMsgA打印信息到visual studio的输出窗口或debugview。InitWindow函数用于创建一个简单的、空白的窗口，将句柄存储在全局变量g_hwnd中。WndProc为窗口的处理过程函数。 服务端在有新的客户端连接上时，给客户端发送“hello, I’m server.”消息，在服务端退出时，关闭所有客户端连接。客户端连接上服务端之后，接收服务端的消息。 2.1 服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#include &lt;winsock2.h&gt;#include &lt;vector&gt;#include &lt;strsafe.h&gt;#pragma comment(lib, \"Ws2_32.lib\")const u_short kPort = 10001;const std::string kHelloServer = \"hello, I'm server.\";#define WUM_SOCKET (WM_USER+1)HWND g_hwnd;SOCKET socket_srv = INVALID_SOCKET;std::vector&lt;SOCKET&gt; clients;void TraceMsgA(const char *lpFormat, ...) { if (!lpFormat) return; char *pMsgBuffer = NULL; unsigned int iMsgBufCount = 0; va_list arglist; va_start(arglist, lpFormat); HRESULT hr = STRSAFE_E_INSUFFICIENT_BUFFER; while (hr == STRSAFE_E_INSUFFICIENT_BUFFER) { iMsgBufCount += 1024; if (pMsgBuffer) { free(pMsgBuffer); pMsgBuffer = NULL; } pMsgBuffer = (char*)malloc(iMsgBufCount * sizeof(char)); if (!pMsgBuffer) { break; } hr = StringCchVPrintfA(pMsgBuffer, iMsgBufCount, lpFormat, arglist); } va_end(arglist); if (hr == S_OK) { OutputDebugStringA(pMsgBuffer); } if (pMsgBuffer) { free(pMsgBuffer); pMsgBuffer = NULL; }}LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ int err; SOCKET s; char buf[100] = { 0 }; switch (message) { // (5) case WUM_SOCKET: if (WSAGETSELECTERROR(lParam)) { closesocket((SOCKET)wParam); break; } switch (WSAGETSELECTEVENT(lParam)) { case FD_ACCEPT: s = accept((SOCKET)wParam, NULL, NULL); clients.push_back(s); WSAAsyncSelect(s, g_hwnd, WUM_SOCKET, FD_READ | FD_WRITE | FD_CLOSE); TraceMsgA(\"new connection\\n\"); err = send(s, (const char*)kHelloServer.c_str(), kHelloServer.length(), 0); if (err == SOCKET_ERROR) { TraceMsgA(\"send failed, GLE: %d\\n\", WSAGetLastError()); break; } break; case FD_READ: err = recv((SOCKET)wParam, buf, 100, 0); if (err &gt; 0) { TraceMsgA(\"recv: %s\\n\", buf); } else if (err == 0) { TraceMsgA(\"connection closed\\n\"); closesocket((SOCKET)wParam); } else { TraceMsgA(\"recv failed, GLE: %d\\n\", WSAGetLastError()); closesocket((SOCKET)wParam); } break; case FD_WRITE: break; case FD_CLOSE: closesocket((SOCKET)wParam); for (std::vector&lt;SOCKET&gt;::iterator it = clients.begin(); it != clients.end(); it++) { if (*it == (SOCKET)wParam) { clients.erase(it); break; } } break; } break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); } return 0;}void InitWindow(HINSTANCE hInstance) { WCHAR szWindowClass[100] = L\"Test\"; WNDCLASSEX wcex = { sizeof(WNDCLASSEX) }; wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.lpszClassName = szWindowClass; RegisterClassExW(&amp;wcex); g_hwnd = CreateWindowW(szWindowClass, L\"server\", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (g_hwnd) { ShowWindow(g_hwnd, SW_SHOW); UpdateWindow(g_hwnd); }}int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow){ UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); InitWindow(hInstance); WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); do { // (1) socket_srv = ::socket(AF_INET, SOCK_STREAM, 0); if (socket_srv == INVALID_SOCKET) { TraceMsgA(\"create socket failed, GLE: %d\\n\", WSAGetLastError()); break; } // (2) struct sockaddr_in addr = { 0 }; addr.sin_family = AF_INET; addr.sin_addr.s_addr = htonl(INADDR_ANY); addr.sin_port = htons(kPort); if (bind(socket_srv, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) { TraceMsgA(\"bind failed, GLE: %d\\n\", WSAGetLastError()); break; } // (3) WSAAsyncSelect(socket_srv, g_hwnd, WUM_SOCKET, FD_ACCEPT | FD_READ | FD_WRITE | FD_CLOSE); // (4) if (listen(socket_srv, 5) == SOCKET_ERROR) { TraceMsgA(\"listen failed, GLE: %d\\n\", WSAGetLastError()); break; } TraceMsgA(\"listen on port: %d\\n\", kPort); } while (false); MSG msg; while (GetMessage(&amp;msg, nullptr, 0, 0)) { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } for (std::vector&lt;SOCKET&gt;::iterator it = clients.begin(); it != clients.end(); it++) { closesocket(*it); } // (6) closesocket(socket_srv); WSACleanup(); return 0;} 2.2 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include &lt;winsock2.h&gt;#include &lt;vector&gt;#include &lt;strsafe.h&gt;#pragma comment(lib, \"Ws2_32.lib\")const std::string kIP = \"127.0.0.1\";const u_short kPort = 10001;#define WUM_SOCKET (WM_USER+1)HWND g_hwnd;void TraceMsgA(const char *lpFormat, ...) { if (!lpFormat) return; char *pMsgBuffer = NULL; unsigned int iMsgBufCount = 0; va_list arglist; va_start(arglist, lpFormat); HRESULT hr = STRSAFE_E_INSUFFICIENT_BUFFER; while (hr == STRSAFE_E_INSUFFICIENT_BUFFER) { iMsgBufCount += 1024; if (pMsgBuffer) { free(pMsgBuffer); pMsgBuffer = NULL; } pMsgBuffer = (char*)malloc(iMsgBufCount * sizeof(char)); if (!pMsgBuffer) { break; } hr = StringCchVPrintfA(pMsgBuffer, iMsgBufCount, lpFormat, arglist); } va_end(arglist); if (hr == S_OK) { OutputDebugStringA(pMsgBuffer); } if (pMsgBuffer) { free(pMsgBuffer); pMsgBuffer = NULL; }}LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ int err; SOCKET s; char buf[100] = { 0 }; switch (message) { // (4) case WUM_SOCKET: if (WSAGETSELECTERROR(lParam)) { closesocket((SOCKET)wParam); TraceMsgA(\"connect failed, %d\\n\", WSAGETSELECTERROR(lParam)); break; } switch (WSAGETSELECTEVENT(lParam)) { case FD_CONNECT: TraceMsgA(\"connection to server\\n\"); break; case FD_READ: err = recv((SOCKET)wParam, buf, 100, 0); if (err &gt; 0) { TraceMsgA(\"recv: %s\\n\", buf); } else if (err == 0) { closesocket((SOCKET)wParam); TraceMsgA(\"connection closed\\n\"); } else { closesocket((SOCKET)wParam); TraceMsgA(\"recv failed, GLE: %d\\n\", WSAGetLastError()); } break; case FD_WRITE: break; case FD_CLOSE: closesocket((SOCKET)wParam); TraceMsgA(\"connection closed\\n\"); break; } break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); } return 0;}void InitWindow(HINSTANCE hInstance) { WCHAR szWindowClass[100] = L\"Test\"; WNDCLASSEX wcex = { sizeof(WNDCLASSEX) }; wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.lpszClassName = szWindowClass; RegisterClassExW(&amp;wcex); g_hwnd = CreateWindowW(szWindowClass, L\"client\", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (g_hwnd) { ShowWindow(g_hwnd, SW_SHOW); UpdateWindow(g_hwnd); }}int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow){ UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); InitWindow(hInstance); WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket_ = INVALID_SOCKET; do { // (1) socket_ = ::socket(AF_INET, SOCK_STREAM, 0); if (socket_ == INVALID_SOCKET) { TraceMsgA(\"create socket failed, GLE: %d\\n\", WSAGetLastError()); break; } // (2) WSAAsyncSelect(socket_, g_hwnd, WUM_SOCKET, FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE); // (3) struct sockaddr_in addr = { 0 }; addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(kIP.c_str()); addr.sin_port = htons(kPort); if (connect(socket_, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) { int gle_err = WSAGetLastError(); if (gle_err != WSAEWOULDBLOCK) { TraceMsgA(\"connect failed, GLE: %d\\n\", WSAGetLastError()); break; } } } while (false); MSG msg; while (GetMessage(&amp;msg, nullptr, 0, 0)) { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } // (5) closesocket(socket_); WSACleanup(); return 0;} 代码下载地址: https://github.com/winsoft666/CodeSnippet/tree/main/WSAAsyncSelect-Sample","link":"/post/2544551173.html"},{"title":"Windows套接字I&#x2F;O模型(4)-WSAEventSelect模型","text":"一、WSAEventSelect模型介绍WSAEventSelect模型和WSAAsyncSelect模型类似，但WSAEventSelect模型允许应用程序在一个或多个套接字上面接收以事件为基础的网络事件通知。该模型和WSAAsyncSelect模型的最主要的区别在于网络事件是由事件对象句柄完成的，而不是通过窗口消息完成的。 该模型要求应用程序针对打算使用的每一个套接字都创建一个事件对象。创建方法是就是调用WSACreateEvent函数。 1WSAEVENT WSACreateEvent(void); WSACreateEvent函数返回一个人工控制(manual)、无信号的事件对象句柄。得到事件句柄之后，可以通过调用WSAEventSelect函数，将它和套接字相关联，同时注册感兴趣的网络事件。 12345int WSAEventSelect( _In_ SOCKET s, _In_ WSAEVENT hEventObject, _In_ long lNetworkEvents); 具体的参数解释可以参考MSDN：https://msdn.microsoft.com/en-us/library/windows/desktop/ms741576(v=vs.85).aspx 和CreateEvent创建的事件类型，windows提供了类似的API来重置事件信号、关闭事件等，如WSAResetEvent, WSACloseEvent等。 同样提供了和WaitForMultipleObjects类似的函数WSAWaitForMultipleEvents来等待多个事件信号，其参数也和WaitForMultipleObjects类似。 需要注意的是，WSAWaitForMultipleEvents最多只支持同时等待64个事件，如果需要等待超过64个事件，需要使用多个线程调用多次WSAWaitForMultipleEvents函数来实现，这也是WSAEventSelect模型的一大弊端。 12345int WSAEnumNetworkEvents( _In_ SOCKET s, _In_ WSAEVENT hEventObject, _Out_ LPWSANETWORKEVENTS lpNetworkEvents); WSAEnumNetworkEvents函数用于获取指定SOCKET上发送了哪些事件（是FD_READ，还是FD_WRITE，或者说还是FD_ACCEPT等），hEventObject参数传入事件句柄，函数会自动将事件置为无信号状态，不需要再次调用WSAResetEvent来重置信号。 具体的用法可以参考下面“示例程序”。 二、示例服务端和客户端着重在列出WSAEventSelect模型的基本用法，并未实现复杂的逻辑。服务端在有新的客户端连接上时，给客户端发送“hello, I’m server.”消息，并且在服务端退出时会关闭所有客户端连接。客户端连接上服务端之后，不间断接收服务端的消息。 示例程序只使用了一个线程（主线程）来等待最多64个事件（也就是最多只支持64-1=63个客户端连接），如果需要支持更多的客户端连接，可以开启多个线程来等待。 2.1 服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include &lt;winsock2.h&gt;#include &lt;iostream&gt;#include &lt;assert.h&gt;#include &lt;vector&gt;using namespace std;#pragma comment(lib, \"Ws2_32.lib\")const u_short kPort = 10001;const std::string kHelloServer = \"hello, I'm server.\";HANDLE g_event_array[WSA_MAXIMUM_WAIT_EVENTS];SOCKET g_socket_array[WSA_MAXIMUM_WAIT_EVENTS];int g_index = 0;template&lt;typename T&gt;void RemoveArrayIndex(T arr[], int total, int index) { if (index &gt; total) return; for (int i = index; i &lt; (total - 1); i++) { arr[i] = arr[i + 1]; }}int main(){ WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); do { // (1) g_socket_array[g_index] = ::socket(AF_INET, SOCK_STREAM, 0); if (g_socket_array[0] == INVALID_SOCKET) { std::cout &lt;&lt; \"create socket failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } // (2) struct sockaddr_in addr = { 0 }; addr.sin_family = AF_INET; addr.sin_addr.s_addr = htonl(INADDR_ANY); addr.sin_port = htons(kPort); if (bind(g_socket_array[g_index], reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) { std::cout &lt;&lt; \"bind failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } // (3) g_event_array[g_index] = WSACreateEvent(); WSAEventSelect(g_socket_array[g_index], g_event_array[g_index], FD_ACCEPT | FD_READ | FD_WRITE | FD_CLOSE); // (4) if (listen(g_socket_array[g_index], 5) == SOCKET_ERROR) { std::cout &lt;&lt; \"listen failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } std::cout &lt;&lt; \"listen on port: \" &lt;&lt; kPort &lt;&lt; std::endl; // (5) // 该循环可以放到子线程中 while (true) { DWORD ret = WSAWaitForMultipleEvents(g_index + 1, g_event_array, FALSE, WSA_INFINITE, FALSE); if(ret == WSA_WAIT_FAILED || ret == WSA_WAIT_TIMEOUT) continue; // 忽略上面WSAWaitForMultipleEvents返回值所表示的index。遍历每个socket，查看是否有信号。 for (int i = 0; i &lt;= g_index; i++) { ret = WSAWaitForMultipleEvents(1, &amp;g_event_array[i], FALSE, 0, FALSE); if (ret == WSA_WAIT_FAILED || ret == WSA_WAIT_TIMEOUT) { continue; } WSANETWORKEVENTS network_events; // WSAEnumNetworkEvent函数会将事件重置为无信号状态 WSAEnumNetworkEvents(g_socket_array[i], g_event_array[i], &amp;network_events); if (network_events.lNetworkEvents &amp; FD_ACCEPT) { if (network_events.iErrorCode[FD_ACCEPT_BIT] != 0) { std::cout &lt;&lt; \"FD_ACCEPT failed with code: \" &lt;&lt; network_events.iErrorCode[FD_ACCEPT_BIT] &lt;&lt; \"\\n\"; break; } SOCKET s = accept(g_socket_array[i], NULL, NULL); if (s == SOCKET_ERROR) { std::cout &lt;&lt; \"accept failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } if (g_index &gt;= WSA_MAXIMUM_WAIT_EVENTS - 1) { std::cout &lt;&lt; \"too many connection\\n\"; closesocket(s); break; } g_index++; g_event_array[g_index] = WSACreateEvent(); g_socket_array[g_index] = s; std::cout &lt;&lt; \"new connection\\n\"; int err = send(s, (const char*)kHelloServer.c_str(), kHelloServer.length(), 0); if (err == SOCKET_ERROR) { std::cout &lt;&lt; \"send failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } } if (network_events.lNetworkEvents &amp; FD_READ) { if (network_events.iErrorCode[FD_READ_BIT] != 0) { std::cout &lt;&lt; \"FD_READ failed with code: \" &lt;&lt; network_events.iErrorCode[FD_READ_BIT] &lt;&lt; \"\\n\"; break; } char buf[100] = { 0 }; int err = recv(g_socket_array[i], buf, 100, 0); if (err &gt; 0) { std::cout &lt;&lt; \"recv: \" &lt;&lt; buf &lt;&lt; std::endl; } else if (err == 0) { std::cout &lt;&lt; \"connection closed.\" &lt;&lt; std::endl; closesocket(g_socket_array[i]); WSACloseEvent(g_event_array[i]); RemoveArrayIndex(g_socket_array, g_index, i); RemoveArrayIndex(g_event_array, g_index, i); g_index--; } else { std::cout &lt;&lt; \"recv failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; closesocket(g_socket_array[i]); WSACloseEvent(g_event_array[i]); RemoveArrayIndex(g_socket_array, g_index, i); RemoveArrayIndex(g_event_array, g_index, i); g_index--; } } if (network_events.lNetworkEvents &amp; FD_WRITE) { if (network_events.iErrorCode[FD_WRITE_BIT] != 0) { std::cout &lt;&lt; \"FD_WRITE failed with code: \" &lt;&lt; network_events.iErrorCode[FD_WRITE_BIT] &lt;&lt; \"\\n\"; break; } } if (network_events.lNetworkEvents &amp; FD_CLOSE) { if (network_events.iErrorCode[FD_CLOSE_BIT] != 0) { std::cout &lt;&lt; \"FD_CLOSE failed with code: \" &lt;&lt; network_events.iErrorCode[FD_CLOSE_BIT] &lt;&lt; \"\\n\"; break; } closesocket(g_socket_array[i]); WSACloseEvent(g_event_array[i]); RemoveArrayIndex(g_socket_array, g_index, i); RemoveArrayIndex(g_event_array, g_index, i); g_index--; } } } // while } while (false); // (6) for (int i = 0; i &lt;= g_index; i++) { closesocket(g_socket_array[i]); WSACloseEvent(g_event_array[i]); } WSACleanup(); return 0;} 2.2 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;winsock2.h&gt;#include &lt;iostream&gt;#include &lt;assert.h&gt;#include &lt;vector&gt;using namespace std;#pragma comment(lib, \"Ws2_32.lib\")const std::string kIP = \"127.0.0.1\";const u_short kPort = 10001;HANDLE g_event;SOCKET g_socket;int main(){ WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); do { // (1) g_socket = ::socket(AF_INET, SOCK_STREAM, 0); if (g_socket == INVALID_SOCKET) { std::cout &lt;&lt; \"create socket failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; } // (2) g_event = WSACreateEvent(); WSAEventSelect(g_socket, g_event, FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE); // (3) struct sockaddr_in addr = { 0 }; addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(kIP.c_str()); addr.sin_port = htons(kPort); if (connect(g_socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) { int gle_err = WSAGetLastError(); if (gle_err != WSAEWOULDBLOCK) { std::cout &lt;&lt; \"connect failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; \"\\n\"; break; } } // (4) while (true) { DWORD ret = WSAWaitForMultipleEvents(1, &amp;g_event, FALSE, WSA_INFINITE, FALSE); if (ret == WSA_WAIT_FAILED || ret == WSA_WAIT_TIMEOUT) { continue; } WSANETWORKEVENTS network_events; // WSAEnumNetworkEvent函数会将事件重置为无信号状态 WSAEnumNetworkEvents(g_socket, g_event, &amp;network_events); if (network_events.lNetworkEvents &amp; FD_CONNECT) { if (network_events.iErrorCode[FD_CONNECT_BIT] != 0) { std::cout &lt;&lt; \"FD_CONNECT failed with code: \" &lt;&lt; network_events.iErrorCode[FD_CONNECT_BIT] &lt;&lt; \"\\n\"; break; } std::cout &lt;&lt; \"connect to server\\n\"; } if (network_events.lNetworkEvents &amp; FD_READ) { if (network_events.iErrorCode[FD_READ_BIT] != 0) { std::cout &lt;&lt; \"FD_READ failed with code: \" &lt;&lt; network_events.iErrorCode[FD_READ_BIT] &lt;&lt; \"\\n\"; break; } char buf[100] = { 0 }; int err = recv(g_socket, buf, 100, 0); if (err &gt; 0) { std::cout &lt;&lt; \"recv: \" &lt;&lt; buf &lt;&lt; std::endl; } else if (err == 0) { std::cout &lt;&lt; \"connection closed.\" &lt;&lt; std::endl; closesocket(g_socket); WSACloseEvent(g_event); } else { std::cout &lt;&lt; \"recv failed, GLE: \" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; closesocket(g_socket); WSACloseEvent(g_event); } } if (network_events.lNetworkEvents &amp; FD_WRITE) { if (network_events.iErrorCode[FD_WRITE_BIT] != 0) { std::cout &lt;&lt; \"FD_WRITE failed with code: \" &lt;&lt; network_events.iErrorCode[FD_WRITE_BIT] &lt;&lt; \"\\n\"; break; } } if (network_events.lNetworkEvents &amp; FD_CLOSE) { if (network_events.iErrorCode[FD_CLOSE_BIT] != 0) { std::cout &lt;&lt; \"FD_CLOSE failed with code: \" &lt;&lt; network_events.iErrorCode[FD_CLOSE_BIT] &lt;&lt; \"\\n\"; break; } closesocket(g_socket); WSACloseEvent(g_event); } } // while } while (false); // (5) closesocket(g_socket); WSACloseEvent(g_event); WSACleanup(); return 0;}","link":"/post/547434843.html"},{"title":"《Windows套接字I&#x2F;O模型》","text":"本栏目主要介绍Windows网络编程中涉及的一些网络模型，如WSAEventSelect模型，WSAAsyncSelect模型，完成端口模型等。 文章列表： Windows套接字I/O模型(1)-阻塞模型 Windows套接字I/O模型(2)-Select模型 Windows套接字I/O模型(3)-WSAAsyncSelect模型 Windows套接字I/O模型(4)-WSAEventSelect模型 Windows套接字I/O模型(5)-完成端口模型","link":"/post/3383048230.html"},{"title":"Windows套接字I&#x2F;O模型(5)-完成端口模型","text":"一、写在前面前面的文章已经介绍了套接字I/O的同步模型、WSAAsyncSelect模型、WSAEventSelect模型，到目前为止套接字I/O还剩下2个模型没有介绍：重叠模型，完成端口模型。 如果程序对性能和并发要求不高，可以使用前面介绍的WSAEventSelect模型；如果对性能和并发有要求，可以使用本文介绍的完成端口模型。因为完成端口模型是基于重叠模型的，且在易用性、可伸缩性等方面都高于重叠模型，在一般选择重叠模型的场合，都可以用完成端口模型来替代，强烈建议使用完成端口模型。 完成端口模型是windows系统上面套接字I/O的终极模型，可以用它代替前面的所有模型。如果对完成端口模型有一个好的封装，基本上可以“一招鲜，吃遍天”，免去重复造轮子的麻烦。所以这里对完成端口的模型的介绍和比前面的几篇篇幅更长，示例代码也更加复杂和全面。 Reactor和Proactor在网络编程中，我们常听到的2种I/O多路复用的模式：reactor和proactor。对于这2种模式的区别通俗来说就是： 12Reactor： 能收了你跟我说一声。Proactor: 你帮我最多收十个字节，收好了跟我说一声。 windows提供的完成端口模型就是Proactor模式；而Linux上面由于没有操作系统的支持，只能使用Reactor模式，如epoll等。 二、完成端口模型介绍完成端口模型说白了就是，您要做什么事情（如接收连接AcceptEx、发送数据WSASend、接收数据WSARecv、连接服务端ConnectEx），您告诉我，我做完了通知您。这里的“我”指的是操作系统，“您”指的是应用程序。如应用程序需要接收其他端发来的数据，可以调用WSARecv，并指定接收数据的缓冲区及大小，等其他端发来数据时，操作系统自动将数据放入到应用程序指定的缓冲区中，然后通知应用程序数据来啦。 这个和WSAEventSelect模型最大的不同就是，WSAEventSelect模型只是通知程序数据来了，并没有将数据接收，还需要程序调用recv来接收数据。 2.1 完成端口创建和绑定123456HANDLE WINAPI CreateIoCompletionPort( _In_ HANDLE FileHandle, _In_opt_ HANDLE ExistingCompletionPort, _In_ ULONG_PTR CompletionKey, _In_ DWORD NumberOfConcurrentThreads); CreateIoCompletionPort这个函数比较特殊，根据传入的参数不同，它可以实现2个功能：创建一个完成端口；将完成端口和设备（套接字）相绑定。一般对该函数进行如下封装来实现这2个功能： 12345678HANDLE CreateNewCompletionPort() { return CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);}BOOL AssociateDeviceWithCompletionPort(HANDLE completion_port, HANDLE device, DWORD completion_key) { HANDLE h = CreateIoCompletionPort(device, completion_port, completion_key, 0); return (h == completion_port);} 2.2 线程池前面说到了，完成端口模型就是应用程序等着操作系统把事情做完了通知它。那既然是等，等的操作肯定是阻塞住了的，所以不能在主线程中等，我们需要启动子线程去等。可是启动多个子线程去等了，一个连接一个线程吗？我们知道，线程越多，占用的系统资源也就越多，而且线程的切换也是消耗CPU时间的。所以线程不是越多越好，这里有一个经验法则就是：线程数量 = CPU数量 * 2。 线程数量和CPU数量相同是最理想的环境，这样免去了CPU在各个线程之间切换，但现实情况下，难免某些线程执行某些任务耗时较长，导致CPU将时间片从该线程分拨出去。所以这里用CPU数量乘以2，最大限度的利用CPU资源。这也是完成端口的目标，即最大限度的利用CPU资源。 获取CPU数量的方式： 12345int GetNumberOfProcesser() { SYSTEM_INFO si; GetSystemInfo(&amp;si); return si.dwNumberOfProcessors;} 2.3 AcceptEx等12345678910BOOL AcceptEx( _In_ SOCKET sListenSocket, _In_ SOCKET sAcceptSocket, _In_ PVOID lpOutputBuffer, _In_ DWORD dwReceiveDataLength, _In_ DWORD dwLocalAddressLength, _In_ DWORD dwRemoteAddressLength, _Out_ LPDWORD lpdwBytesReceived, _In_ LPOVERLAPPED lpOverlapped); AcceptEx和WSARecv、WSASend、ConnectEx等函数类似，最后一个参数都是LPOVERLAPPED，需要调用者提供一个重叠结构。但这个AcceptEx、ConnectEx等函数比较特别，他们是微软专门在Windows操作系统里面提供的扩展函数，不是在Winsock2标准里面提供的，是微软为了方便使用重叠I/O机制，额外提供的一些函数。 以AcceptEx为例，微软的实现是通过mswsock.dll中提供的，所以我们可以通过静态链接mswsock.lib来直接调用AcceptEx。但不推荐使用这种方式，因为每次直接调用AcceptEx时，Service Provider都得要通过WSAIoctl()获取一次该函数指针，这样效率比较低。所以我们一般都是在直接代码中先获取到这个函数指针，并保存下来，后面直接使用这个函数指针就好了。 获取AcceptEx等函数的指针的方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162LPFN_ACCEPTEX GetAcceptExFnPointer(SOCKET s){ LPFN_ACCEPTEX fn = NULL; GUID GuidAcceptEx = WSAID_ACCEPTEX; DWORD bytes = 0; if (SOCKET_ERROR == WSAIoctl( s, SIO_GET_EXTENSION_FUNCTION_POINTER, &amp;GuidAcceptEx, sizeof(GuidAcceptEx), &amp;fn, sizeof(fn), &amp;bytes, NULL, NULL)) { return NULL; } return fn;}LPFN_CONNECTEX GetConnectExFnPointer(SOCKET s){ LPFN_CONNECTEX fn = NULL; GUID GuidConnectEx = WSAID_CONNECTEX; DWORD bytes = 0; if (SOCKET_ERROR == WSAIoctl( s, SIO_GET_EXTENSION_FUNCTION_POINTER, &amp;GuidConnectEx, sizeof(GuidConnectEx), &amp;fn, sizeof(fn), &amp;bytes, NULL, NULL)) { return NULL; } return fn;}LPFN_GETACCEPTEXSOCKADDRS GetAcceptExSockAddrsFnPointer(SOCKET s){ LPFN_GETACCEPTEXSOCKADDRS fn = NULL; GUID GuidGetAcceptExSockAddrs = WSAID_GETACCEPTEXSOCKADDRS; DWORD bytes = 0; if (SOCKET_ERROR == WSAIoctl( s, SIO_GET_EXTENSION_FUNCTION_POINTER, &amp;GuidGetAcceptExSockAddrs, sizeof(GuidGetAcceptExSockAddrs), &amp;fn, sizeof(fn), &amp;bytes, NULL, NULL)) { return NULL; } return fn;} 2.4 GetQueuedCompletionStatus函数原型如下： 1234567BOOL WINAPI GetQueuedCompletionStatus( _In_ HANDLE CompletionPort, _Out_ LPDWORD lpNumberOfBytes, _Out_ PULONG_PTR lpCompletionKey, _Out_ LPOVERLAPPED *lpOverlapped, _In_ DWORD dwMilliseconds); 前面说到了，完成端口模型需要在子线程中等待操作系统做完事情之后的通知。而GetQueuedCompletionStatus函数就是用来等待这个通知的。通过该函数可以获取的本次传输的字节数lpNumberOfBytes、一个用户绑定在套接字上的自定义整数lpCompletionKey、用户调用WSASend等函数时指定的OVERLAPPED结构的指针lpOverlapped。 我们比较关注的是lpCompletionKey、lpOverlapped这2个参数：lpCompletionKey是调用CreateIoCompletionPort函数绑定完成端口和套接字时指定的，每个套接字(SOCKET)对应一个lpCompletionKey。lpCompletionKey可以是包括指针在内的任何整数。 lpOverlapped是每次调用WSASend等函数时指定的，每一次操作（也就是每一次调用，如WSASend, WSARecv, AcceptEx, ConnectEx）对应的lpOverlapped都不一样，所以一次操作对应一个lpOverlapped。一个SOCKET可以有多次操作，多以对应多个lpOverlapped。 对应关系如下： 123456789101112131415161718192021+-----------+ +--------------------+| | 1 --&gt; 1 | || SOCKET +-----------&gt; lpCompletionKey || | | |+-----+-----+ +--------------------+ | |1 --&gt; n |+-----v------------------+| || Send,Recv,Accept... || |+-----+------------------+ | |1 --&gt; 1 |+-----v------------------+| || lpOverlapped || |+------------------------+ 注：示例代码中的PER_SOCKET_CONTEXT结构对应图中的SOCKET，PER_IO_CONTEXT结构对应图中的lpOverlapped。知道这个对理解示例代码会有很大的帮助。 Windows还提供了一个辅助宏CONTAINING_RECORD，该宏可以根据结构体中的某成员的地址来推算出该结构体整体的地址。知道了这个功能，我们就可以在lpOverlapped参数上做文章了（扩展），具体见示例。 上面对完成端口模型只做了一个简单的介绍，关于完成端口的详细介绍可以参考《windows核心编程 第5版》 10.3节。 2.5 CONTAINING_RECORD宏的实现原理该宏的作用就是：根据结构体中的某成员的地址来推算出该结构体整体的地址，相当于一个万能公式。 下面代码的注释中，讲解了该宏的实现原理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main(){ struct T { int a; int b; int c; }; //CONTAINING_RECORD宏的作用就是根据结构体中的某成员的地址来推算出该结构体整体的地址。 T t = { 1, 2, 3 }; //假设我们知道T结构体中b的地址和名称，求t的指针 T *pT = CONTAINING_RECORD(&amp;t.b, T, b); printf(\"a:%d b:%d c:%d\\n\", pT-&gt;a, pT-&gt;b, pT-&gt;c); //CONTAINING_RECORD的定义: //((type *)( (PCHAR)(address) - (ULONG_PTR)(&amp;((type *)0)-&gt;field))) //最后一部分(&amp;((type *)0)-&gt;field) 将0(空指针)转成type，再取地址。 //在本例中就是将空指针转成T*, 然后指向b这个变量, 然后再取地址。 //这个操作的作用就是：假设T开始在0x000000内存位置上分配内存，在此基础上求b的内存地址, //这样等同于求得b的内存结构体对齐偏移量, 求得b的地址我们转成ULONG_PTR类型, //然后用实际b的内存地址减去b的结构体偏移量求得结构体首地址。 // //分解开来就是： //这种情况是允许的。 //这个大前提很重要！！！ T *pTemp = (T*)0; //求b的内存地址,在结构体首地址为0的情况下b的内存地址其实就是自身的对齐大小偏移量！！！ //CONTAINING_RECORD宏的核心！！！ int *pB = &amp;pTemp-&gt;b; ULONG_PTR Offset = (ULONG_PTR)pB; //转成数字, 就是b的偏移量。 printf(\"b的偏移量:%d\\n\", Offset); //因为各个成员的地址是递增的，最后用实际b的地址减b的偏移量的到结构体首地址 T *pFinal = (T*)(((char*)&amp;t.b) - Offset); printf(\"T中a:%d b:%d c:%d\\n\", pFinal-&gt;a, pFinal-&gt;b, pFinal-&gt;c); return 0;} 三、示例示例代码实现如下功能： 服务端和客户端都使用完成端口模型来实现。 服务端和客户端之间通过发送消息来模拟TCP的三次握手机制。 3.1 辅助函数iocp.h和iocp.cpp中实现了IOCP相关的结构体定义和一些通用的辅助函数：iocp.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// iocp.h#ifndef IOCP_H_#define IOCP_H_#include &lt;winsock2.h&gt;#include &lt;MSWSock.h&gt;#include &lt;vector&gt;#define MAX_BUFFER_LEN 8192 #define EXIT_CODE 0namespace IOCP { typedef enum _OPERATION_TYPE { ACCEPT_POSTED, CONNECT_POSTED, SEND_POSTED, RECV_POSTED, NULL_POSTED }OPERATION_TYPE; typedef struct _PER_IO_CONTEXT { OVERLAPPED overlapped; SOCKET socket; WSABUF wsa_buffer; char buffer[MAX_BUFFER_LEN]; OPERATION_TYPE operation_type; _PER_IO_CONTEXT() { ZeroMemory(&amp;overlapped, sizeof(overlapped)); ZeroMemory(buffer, MAX_BUFFER_LEN); socket = INVALID_SOCKET; wsa_buffer.buf = buffer; wsa_buffer.len = MAX_BUFFER_LEN; operation_type = NULL_POSTED; } ~_PER_IO_CONTEXT() { if (socket != INVALID_SOCKET) { closesocket(socket); socket = INVALID_SOCKET; } } void ResetBuffer() { ZeroMemory(buffer, MAX_BUFFER_LEN); } } PER_IO_CONTEXT; typedef struct _PER_SOCKET_CONTEXT { SOCKET socket; SOCKADDR_IN client_addr; std::vector&lt;_PER_IO_CONTEXT*&gt; io_ctx_array; _PER_SOCKET_CONTEXT() { socket = INVALID_SOCKET; memset(&amp;client_addr, 0, sizeof(client_addr)); } ~_PER_SOCKET_CONTEXT() { if (socket != INVALID_SOCKET) { closesocket(socket); socket = INVALID_SOCKET; } for (size_t i = 0; i &lt; io_ctx_array.size(); i++) { delete io_ctx_array[i]; } io_ctx_array.clear(); } _PER_IO_CONTEXT* GetNewIoContext() { _PER_IO_CONTEXT* p = new _PER_IO_CONTEXT; io_ctx_array.push_back(p); return p; } void RemoveContext(_PER_IO_CONTEXT* pContext) { for (std::vector&lt;_PER_IO_CONTEXT*&gt;::iterator it = io_ctx_array.begin(); it != io_ctx_array.end(); it++) { if (pContext == *it) { delete pContext; pContext = NULL; io_ctx_array.erase(it); break; } } } } PER_SOCKET_CONTEXT; int GetNumberOfProcesser(); HANDLE CreateNewCompletionPort(); BOOL AssociateDeviceWithCompletionPort(HANDLE completion_port, HANDLE device, DWORD completion_key); LPFN_ACCEPTEX GetAcceptExFnPointer(SOCKET s); LPFN_CONNECTEX GetConnectExFnPointer(SOCKET s); LPFN_GETACCEPTEXSOCKADDRS GetAcceptExSockAddrsFnPointer(SOCKET s);};#endif // IOCP_H_ iocp.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// iocp.cpp#include \"iocp.h\"namespace IOCP { int GetNumberOfProcesser() { SYSTEM_INFO si; GetSystemInfo(&amp;si); return si.dwNumberOfProcessors; } HANDLE CreateNewCompletionPort() { return CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0); } BOOL AssociateDeviceWithCompletionPort(HANDLE completion_port, HANDLE device, DWORD completion_key) { HANDLE h = CreateIoCompletionPort(device, completion_port, completion_key, 0); return (h == completion_port); } LPFN_ACCEPTEX GetAcceptExFnPointer(SOCKET s) { LPFN_ACCEPTEX fn = NULL; GUID GuidAcceptEx = WSAID_ACCEPTEX; DWORD bytes = 0; if (SOCKET_ERROR == WSAIoctl( s, SIO_GET_EXTENSION_FUNCTION_POINTER, &amp;GuidAcceptEx, sizeof(GuidAcceptEx), &amp;fn, sizeof(fn), &amp;bytes, NULL, NULL)) { return NULL; } return fn; } LPFN_CONNECTEX GetConnectExFnPointer(SOCKET s) { LPFN_CONNECTEX fn = NULL; GUID GuidConnectEx = WSAID_CONNECTEX; DWORD bytes = 0; if (SOCKET_ERROR == WSAIoctl( s, SIO_GET_EXTENSION_FUNCTION_POINTER, &amp;GuidConnectEx, sizeof(GuidConnectEx), &amp;fn, sizeof(fn), &amp;bytes, NULL, NULL)) { return NULL; } return fn; } LPFN_GETACCEPTEXSOCKADDRS GetAcceptExSockAddrsFnPointer(SOCKET s) { LPFN_GETACCEPTEXSOCKADDRS fn = NULL; GUID GuidGetAcceptExSockAddrs = WSAID_GETACCEPTEXSOCKADDRS; DWORD bytes = 0; if (SOCKET_ERROR == WSAIoctl( s, SIO_GET_EXTENSION_FUNCTION_POINTER, &amp;GuidGetAcceptExSockAddrs, sizeof(GuidGetAcceptExSockAddrs), &amp;fn, sizeof(fn), &amp;bytes, NULL, NULL)) { return NULL; } return fn; }} 3.1 服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348#include &lt;winsock2.h&gt;#include &lt;iostream&gt;#include &lt;assert.h&gt;#include &lt;vector&gt;#include &lt;process.h&gt;#include \"iocp.h\"using namespace std;const u_short kPort = 10001;const std::string kSYN = \"(SYN) hello server, I'm client. Can you hear me?\";const std::string kSYN_ACK = \"(SYN+ACK) hello client, I'm server. I can hear you, can you hear me?\";const std::string kACK = \"(ACK) hello server, I'm client. I can hear you!\";#pragma comment(lib, \"Ws2_32.lib\")HANDLE g_IOCP = INVALID_HANDLE_VALUE;HANDLE g_exit = NULL;int g_work_thread_num = 0;HANDLE *g_work_threads = NULL;IOCP::PER_SOCKET_CONTEXT *g_listen_ctx = NULL;CRITICAL_SECTION g_cs_socket_ctx_array;std::vector&lt;IOCP::PER_SOCKET_CONTEXT*&gt; g_socket_ctx_array;LPFN_ACCEPTEX g_AcceptExFn = NULL;LPFN_GETACCEPTEXSOCKADDRS g_AcceptExSockAddrsFn = NULL;// 管理g_socket_ctx_array//void AddSocketContext(IOCP::PER_SOCKET_CONTEXT *socket_ctx) { EnterCriticalSection(&amp;g_cs_socket_ctx_array); g_socket_ctx_array.push_back(socket_ctx); LeaveCriticalSection(&amp;g_cs_socket_ctx_array);}void RemoveSocketContext(IOCP::PER_SOCKET_CONTEXT *socket_ctx) { EnterCriticalSection(&amp;g_cs_socket_ctx_array); for (std::vector&lt;IOCP::PER_SOCKET_CONTEXT*&gt;::iterator it = g_socket_ctx_array.begin(); it != g_socket_ctx_array.end(); it++) { if (*it == socket_ctx) { delete *it; g_socket_ctx_array.erase(it); break; } } LeaveCriticalSection(&amp;g_cs_socket_ctx_array);}void ClearSocketContextArray() { EnterCriticalSection(&amp;g_cs_socket_ctx_array); for (std::vector&lt;IOCP::PER_SOCKET_CONTEXT*&gt;::iterator it = g_socket_ctx_array.begin(); it != g_socket_ctx_array.end(); it++) { closesocket((*it)-&gt;socket); delete *it; } g_socket_ctx_array.clear(); LeaveCriticalSection(&amp;g_cs_socket_ctx_array);}// 发送Accept、Recv、Send请求//bool PostAccept(IOCP::PER_IO_CONTEXT* io_ctx) { if (io_ctx == NULL) return false; io_ctx-&gt;operation_type = IOCP::ACCEPT_POSTED; io_ctx-&gt;ResetBuffer(); io_ctx-&gt;socket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED); if (io_ctx-&gt;socket == INVALID_SOCKET) { printf(\"WSASocket failed with code: %d\\n\", WSAGetLastError()); return false; } DWORD bytes = 0; if (g_AcceptExFn(g_listen_ctx-&gt;socket, io_ctx-&gt;socket, io_ctx-&gt;wsa_buffer.buf, 0, sizeof(SOCKADDR_IN) + 16, sizeof(SOCKADDR_IN) + 16, &amp;bytes, &amp;io_ctx-&gt;overlapped) == FALSE) { int gle = WSAGetLastError(); if (gle != WSA_IO_PENDING) { printf(\"AcceptEx failed with code: %d\\n\", gle); return false; } } return true;}bool PostRecv(IOCP::PER_IO_CONTEXT* io_ctx) { if (io_ctx == NULL) return false; io_ctx-&gt;operation_type = IOCP::RECV_POSTED; io_ctx-&gt;ResetBuffer(); DWORD recv_bytes = 0; DWORD flags = 0; int ret = WSARecv(io_ctx-&gt;socket, &amp;io_ctx-&gt;wsa_buffer, 1, &amp;recv_bytes, &amp;flags, &amp;io_ctx-&gt;overlapped, NULL); if (ret == SOCKET_ERROR &amp;&amp; WSAGetLastError() != WSA_IO_PENDING) { return false; } return true;}bool PostSend(IOCP::PER_IO_CONTEXT* io_ctx, const char* msg, int msg_len) { if (io_ctx == NULL) return false; io_ctx-&gt;operation_type = IOCP::SEND_POSTED; memcpy(io_ctx-&gt;wsa_buffer.buf, msg, msg_len); io_ctx-&gt;wsa_buffer.len = msg_len; DWORD sent_bytes = 0; int ret = WSASend(io_ctx-&gt;socket, &amp;io_ctx-&gt;wsa_buffer, 1, &amp;sent_bytes, 0, &amp;io_ctx-&gt;overlapped, NULL); if (ret == SOCKET_ERROR &amp;&amp; WSAGetLastError() != WSA_IO_PENDING) { return false; } return true;}// 处理Accept、Recv、Send完成之后的通知//bool DoAccept(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx) { SOCKADDR_IN* ClientAddr = NULL; SOCKADDR_IN* LocalAddr = NULL; int remoteLen = sizeof(SOCKADDR_IN); int localLen = sizeof(SOCKADDR_IN); g_AcceptExSockAddrsFn(io_ctx-&gt;wsa_buffer.buf, io_ctx-&gt;wsa_buffer.len - ((sizeof(SOCKADDR_IN) + 16) * 2), sizeof(SOCKADDR_IN) + 16, sizeof(SOCKADDR_IN) + 16, (LPSOCKADDR*)&amp;LocalAddr, &amp;localLen, (LPSOCKADDR*)&amp;ClientAddr, &amp;remoteLen); printf(\"* new connection(%s:%d): %s\\n\", inet_ntoa(ClientAddr-&gt;sin_addr), ntohs(ClientAddr-&gt;sin_port), io_ctx-&gt;wsa_buffer.buf); // 此次创建一个新的PER_SOCKET_CONTEXT，之前老的PER_SOCKET_CONTEXT继续用作接收客户端连接 // IOCP::PER_SOCKET_CONTEXT *new_socket_ctx = new IOCP::PER_SOCKET_CONTEXT(); new_socket_ctx-&gt;socket = io_ctx-&gt;socket; if (!IOCP::AssociateDeviceWithCompletionPort(g_IOCP, (HANDLE)new_socket_ctx-&gt;socket, (DWORD)new_socket_ctx)) { printf(\"AssociateDeviceWithCompletionPort failed\\n\"); delete new_socket_ctx; new_socket_ctx = NULL; return false; } AddSocketContext(new_socket_ctx); // post recv IOCP::PER_IO_CONTEXT *new_io_ctx = new_socket_ctx-&gt;GetNewIoContext(); new_io_ctx-&gt;socket = new_socket_ctx-&gt;socket; if (!PostRecv(new_io_ctx)) { printf(\"PostRecv failed\\n\"); return false; } // post new accept if (!PostAccept(io_ctx)) { printf(\"PostAccept failed\\n\"); return false; } return true;}bool DoRecv(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx) { printf(\"recv: %s\\n\", io_ctx-&gt;wsa_buffer.buf); if (strcmp(io_ctx-&gt;wsa_buffer.buf, kSYN.c_str()) == 0) { // SYN+ACK IOCP::PER_IO_CONTEXT * new_io_ctx = socket_ctx-&gt;GetNewIoContext(); new_io_ctx-&gt;socket = socket_ctx-&gt;socket; if (!PostSend(new_io_ctx, kSYN_ACK.c_str(), kSYN_ACK.length())) { printf(\"PostSend failed\\n\"); return false; } } // post new recv if (!PostRecv(io_ctx)) { printf(\"PostRecv failed\\n\"); return false; } return true;}bool DoSend(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx) { printf(\"send: %s\\n\", io_ctx-&gt;wsa_buffer.buf); return true;}// 工作线程unsigned int __stdcall WorkThreadProc(void *arg) { DWORD transferred_bytes = 0; IOCP::PER_SOCKET_CONTEXT *socket_ctx = NULL; OVERLAPPED *overlapped = NULL; DWORD gle; while (WaitForSingleObject(g_exit, 0) != WAIT_OBJECT_0) { BOOL ret = GetQueuedCompletionStatus(g_IOCP, &amp;transferred_bytes, (PULONG_PTR)&amp;socket_ctx, &amp;overlapped, INFINITE); gle = GetLastError(); if (socket_ctx == EXIT_CODE) { break; } if (ret == FALSE) { if (gle == WAIT_TIMEOUT) { continue; } else if (gle == ERROR_NETNAME_DELETED) { printf(\"client exit\\n\"); RemoveSocketContext(socket_ctx); continue; } else { RemoveSocketContext(socket_ctx); break; } } else { // http://blog.csdn.net/china_jeffery/article/details/78801331 IOCP::PER_IO_CONTEXT *io_ctx = CONTAINING_RECORD(overlapped, IOCP::PER_IO_CONTEXT, overlapped); if ((transferred_bytes == 0) &amp;&amp; (io_ctx-&gt;operation_type == IOCP::RECV_POSTED || io_ctx-&gt;operation_type == IOCP::SEND_POSTED)) { printf(\"client disconnect\\n\"); RemoveSocketContext(socket_ctx); continue; } switch (io_ctx-&gt;operation_type) { case IOCP::ACCEPT_POSTED: DoAccept(socket_ctx, io_ctx); break; case IOCP::RECV_POSTED: DoRecv(socket_ctx, io_ctx); break; case IOCP::SEND_POSTED: DoSend(socket_ctx, io_ctx); break; default: assert(false); } } } return 0;}int main(){ WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); do { InitializeCriticalSection(&amp;g_cs_socket_ctx_array); g_IOCP = IOCP::CreateNewCompletionPort(); g_exit = CreateEvent(NULL, FALSE, FALSE, NULL); g_work_thread_num = IOCP::GetNumberOfProcesser() * 2; g_work_threads = new HANDLE[g_work_thread_num]; for (int i = 0; i &lt; g_work_thread_num; i++) { g_work_threads[i] = (HANDLE)_beginthreadex(NULL, 0, WorkThreadProc, NULL, 0, NULL); } g_listen_ctx = new IOCP::PER_SOCKET_CONTEXT; g_listen_ctx-&gt;socket = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED); if (!IOCP::AssociateDeviceWithCompletionPort(g_IOCP, (HANDLE)g_listen_ctx-&gt;socket, (DWORD)g_listen_ctx)) { printf(\"AssociateDeviceWithCompletionPort failed with code: %d\\n\", GetLastError()); break; } struct sockaddr_in addr = { 0 }; addr.sin_family = AF_INET; addr.sin_addr.s_addr = htonl(INADDR_ANY); addr.sin_port = htons(kPort); if (bind(g_listen_ctx-&gt;socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) { printf(\"bind failed with code: %d\\n\", WSAGetLastError()); break; } if (listen(g_listen_ctx-&gt;socket, SOMAXCONN) == SOCKET_ERROR) { printf(\"listen failed with code: %d\\n\", WSAGetLastError()); break; } g_AcceptExFn = IOCP::GetAcceptExFnPointer(g_listen_ctx-&gt;socket); if (g_AcceptExFn == NULL) { printf(\"GetAcceptExFnPointer failed\\n\"); break; } g_AcceptExSockAddrsFn = IOCP::GetAcceptExSockAddrsFnPointer(g_listen_ctx-&gt;socket); if (g_AcceptExSockAddrsFn == NULL) { printf(\"GetAcceptExSockAddrsFnPointer failed\\n\"); break; } int i = 0; for (; i &lt; 10; i++) { IOCP::PER_IO_CONTEXT *io_ctx = g_listen_ctx-&gt;GetNewIoContext(); if (PostAccept(io_ctx) == FALSE) { break; } } if(i != 10) break; } while (FALSE); printf(\"\\npress any ket to stop server...\\n\"); getchar(); SetEvent(g_exit); for (int i = 0; i &lt; g_work_thread_num; i++) { PostQueuedCompletionStatus(g_IOCP, 0, (DWORD)EXIT_CODE, NULL); } WaitForMultipleObjects(g_work_thread_num, g_work_threads, TRUE, INFINITE); ClearSocketContextArray(); printf(\"\\npress any ket to exit...\\n\"); getchar(); DeleteCriticalSection(&amp;g_cs_socket_ctx_array); WSACleanup(); return 0;} 3.2 客户端客户端代码和服务端类似，唯一需要注意的是ConnectEx函数调用之前，需要将SOCKET进行bind操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;winsock2.h&gt;#include &lt;iostream&gt;#include &lt;assert.h&gt;#include &lt;vector&gt;#include &lt;process.h&gt;#include \"iocp.h\"using namespace std;const std::string kIP = \"127.0.0.1\";const u_short kPort = 10001;const std::string kSYN = \"(SYN) hello server, I'm client. Can you hear me?\";const std::string kSYN_ACK = \"(SYN+ACK) hello client, I'm server. I can hear you, can you hear me?\";const std::string kACK = \"(ACK) hello server, I'm client. I can hear you!\";#pragma comment(lib, \"Ws2_32.lib\")HANDLE g_IOCP = INVALID_HANDLE_VALUE;HANDLE g_exit = NULL;int g_work_thread_num = 0;HANDLE *g_work_threads = NULL;IOCP::PER_SOCKET_CONTEXT *g_client_ctx = NULL;LPFN_CONNECTEX g_ConnectExFn = NULL;bool PostConnect(IOCP::PER_IO_CONTEXT* io_ctx, const std::string &amp;ip, int port) { if (io_ctx == NULL) return false; io_ctx-&gt;operation_type = IOCP::CONNECT_POSTED; io_ctx-&gt;ResetBuffer(); // ConnectEx requires the socket to be initially bound. struct sockaddr_in addr0 = { 0 }; addr0.sin_family = AF_INET; addr0.sin_addr.s_addr = INADDR_ANY; addr0.sin_port = 0; int ret = bind(io_ctx-&gt;socket, (SOCKADDR*)&amp;addr0, sizeof(addr0)); if (ret != 0) { printf(\"bind failed: %d\\n\", WSAGetLastError()); return false; } struct sockaddr_in addr1 = { 0 }; addr1.sin_family = AF_INET; addr1.sin_addr.s_addr = inet_addr(ip.c_str()); addr1.sin_port = htons(port); ret = g_ConnectExFn(io_ctx-&gt;socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr1), sizeof(addr1), NULL, 0, NULL, &amp;io_ctx-&gt;overlapped); int gle = WSAGetLastError(); if (ret == SOCKET_ERROR &amp;&amp; gle != WSA_IO_PENDING) { return false; } return true;}bool PostRecv(IOCP::PER_IO_CONTEXT* io_ctx) { if (io_ctx == NULL) return false; io_ctx-&gt;operation_type = IOCP::RECV_POSTED; io_ctx-&gt;ResetBuffer(); DWORD recv_bytes = 0; DWORD flags = 0; int ret = WSARecv(io_ctx-&gt;socket, &amp;io_ctx-&gt;wsa_buffer, 1, &amp;recv_bytes, &amp;flags, &amp;io_ctx-&gt;overlapped, NULL); if (ret == SOCKET_ERROR &amp;&amp; WSAGetLastError() != WSA_IO_PENDING) { return false; } return true;}bool PostSend(IOCP::PER_IO_CONTEXT* io_ctx, const char* msg, int msg_len) { if (io_ctx == NULL) return false; io_ctx-&gt;operation_type = IOCP::SEND_POSTED; memcpy(io_ctx-&gt;wsa_buffer.buf, msg, msg_len); io_ctx-&gt;wsa_buffer.len = msg_len; DWORD sent_bytes = 0; int ret = WSASend(io_ctx-&gt;socket, &amp;io_ctx-&gt;wsa_buffer, 1, &amp;sent_bytes, 0, &amp;io_ctx-&gt;overlapped, NULL); int gle = WSAGetLastError(); if (ret == SOCKET_ERROR &amp;&amp; gle != WSA_IO_PENDING) { printf(\"WSASend failed with code: %d\\n\", gle); return false; } return true;}bool DoConnect(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx) { printf(\"connect to server\\n\"); if (!PostRecv(io_ctx)) { printf(\"PostRecv failed\\n\"); return false; } IOCP::PER_IO_CONTEXT* new_io_ctx = socket_ctx-&gt;GetNewIoContext(); new_io_ctx-&gt;socket = socket_ctx-&gt;socket; if (!PostSend(new_io_ctx, kSYN.c_str(), kSYN.length())) { printf(\"PostSend failed\\n\"); return false; } return true;}bool DoRecv(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx) { printf(\"recv: %s\\n\", io_ctx-&gt;wsa_buffer.buf); if (strcmp(io_ctx-&gt;wsa_buffer.buf, kSYN_ACK.c_str()) == 0) { // ACK IOCP::PER_IO_CONTEXT * new_io_ctx = socket_ctx-&gt;GetNewIoContext(); new_io_ctx-&gt;socket = socket_ctx-&gt;socket; if (!PostSend(new_io_ctx, kACK.c_str(), kACK.length())) { printf(\"PostSend failed\\n\"); return false; } } // post new recv if (!PostRecv(io_ctx)) { printf(\"PostRecv failed\\n\"); return false; } return true;}bool DoSend(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx) { printf(\"send: %s\\n\", io_ctx-&gt;wsa_buffer.buf); return true;}unsigned int __stdcall WorkThreadProc(void *arg) { DWORD transferred_bytes = 0; IOCP::PER_SOCKET_CONTEXT *socket_ctx = NULL; OVERLAPPED *overlapped = NULL; DWORD gle; while (WaitForSingleObject(g_exit, 0) != WAIT_OBJECT_0) { BOOL ret = GetQueuedCompletionStatus(g_IOCP, &amp;transferred_bytes, (PULONG_PTR)&amp;socket_ctx, &amp;overlapped, INFINITE); gle = GetLastError(); if (socket_ctx == EXIT_CODE) { break; } if (ret == FALSE) { if (gle == WAIT_TIMEOUT) { continue; } else if (gle == ERROR_NETNAME_DELETED) { printf(\"server exit\\n\"); closesocket(socket_ctx-&gt;socket); socket_ctx-&gt;socket = INVALID_SOCKET; break; } else { closesocket(socket_ctx-&gt;socket); socket_ctx-&gt;socket = INVALID_SOCKET; break; } } else { IOCP::PER_IO_CONTEXT *io_ctx = CONTAINING_RECORD(overlapped, IOCP::PER_IO_CONTEXT, overlapped); switch (io_ctx-&gt;operation_type) { case IOCP::CONNECT_POSTED: DoConnect(socket_ctx, io_ctx); break; case IOCP::RECV_POSTED: DoRecv(socket_ctx, io_ctx); break; case IOCP::SEND_POSTED: DoSend(socket_ctx, io_ctx); break; default: assert(false); } } } return 0;}int main(){ WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); do { g_IOCP = IOCP::CreateNewCompletionPort(); g_exit = CreateEvent(NULL, FALSE, FALSE, NULL); g_work_thread_num = IOCP::GetNumberOfProcesser() * 2; g_work_threads = new HANDLE[g_work_thread_num]; for (int i = 0; i &lt; g_work_thread_num; i++) { g_work_threads[i] = (HANDLE)_beginthreadex(NULL, 0, WorkThreadProc, NULL, 0, NULL); } g_client_ctx = new IOCP::PER_SOCKET_CONTEXT; g_client_ctx-&gt;socket = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED); if (!IOCP::AssociateDeviceWithCompletionPort(g_IOCP, (HANDLE)g_client_ctx-&gt;socket, (DWORD)g_client_ctx)) { printf(\"AssociateDeviceWithCompletionPort failed with code: %d\\n\", GetLastError()); break; } g_ConnectExFn = IOCP::GetConnectExFnPointer(g_client_ctx-&gt;socket); if (g_ConnectExFn == NULL) { printf(\"GetConnectExFnPointer failed\\n\"); break; } IOCP::PER_IO_CONTEXT* io_ctx = g_client_ctx-&gt;GetNewIoContext(); io_ctx-&gt;socket = g_client_ctx-&gt;socket; if (!PostConnect(io_ctx, kIP, kPort)) { printf(\"PostConnect failed\\n\"); } } while (FALSE); printf(\"press any key to exit client...\\n\"); getchar(); SetEvent(g_exit); closesocket(g_client_ctx-&gt;socket); getchar(); WSACleanup(); return 0;} 完整工程下载地址：https://github.com/winsoft666/CodeSnippet/tree/main/CompletionPort-Sample","link":"/post/326824759.html"},{"title":"开源库nlohmann json使用备忘","text":"nlohmann/json 是一个用于解析 JSON 的开源 C++库，口碑一流，无需额外安装其他第三方库，还支持单个头文件模式，使用起来非常方便直观。 1. 编译从官网https://github.com/nlohmann/json的 Release 页面下载单个json.hpp即可直接使用，无需单独编译。 2. 使用示例下面以示例的方式罗列 nlohmann/json 库的基本使用方法。 2.1 生成 JSON方式 112345678910111213141516171819int main(){ using json = nlohmann::json; json j; j[\"pi\"] = 3.141; j[\"happy\"] = true; j[\"name\"] = \"Niels\"; j[\"nothing\"] = nullptr; j[\"answer\"][\"everything\"] = 42; j[\"list\"] = { 1, 0, 2 }; j[\"object\"] = { {\"currency\", \"USD\"}, {\"value\", 42.99} }; // 转成字符串 std::string strJSON = j.dump(2); // 2个空格的缩进 std::cout &lt;&lt; strJSON; return 0;} 输出如下： 1234567891011121314{ \"answer\": { \"everything\": 42 }, \"happy\": true, \"list\": [1, 0, 2], \"name\": \"Niels\", \"nothing\": null, \"object\": { \"currency\": \"USD\", \"value\": 42.99 }, \"pi\": 3.141} 方式 212345678910111213141516171819int main(){ using json = nlohmann::json; json j = { {\"pi\", 3.141}, {\"happy\", true}, {\"name\", \"Niels\"}, {\"nothing\", nullptr}, {\"answer\", {{\"everything\", 42}}}, {\"list\", {1, 0, 2}}, {\"object\", {{\"currency\", \"USD\"}, {\"value\", 42.99}}} }; // 转成字符串 std::string strJSON = j.dump(2); std::cout &lt;&lt; strJSON; return 0;} 输出内容与方式 1 一样。 方式 312345678910111213141516171819202122232425262728293031323334int main(){ using json = nlohmann::json; json j; j[\"pi\"] = 3.141; j[\"happy\"] = true; j[\"name\"] = \"Niels\"; j[\"nothing\"] = nullptr; json j_answer; j_answer[\"everything\"] = 42; j[\"answer\"] = j_answer; json j_list = json::array(); j_list.push_back(1); j_list.push_back(0); j_list.push_back(2); j[\"list\"] = j_list; json j_object; j_object[\"currency\"] = \"USD\"; j_object[\"value\"] = 42.99; j[\"object\"] = j_object; // 转成字符串 std::string strJSON = j.dump(2); std::cout &lt;&lt; strJSON; return 0;} 输出内容与方式 1 一样。 2.2 解析 JSON12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int main(){ using json = nlohmann::json; std::string strJSON = u8R\"( { \"answer\": { \"everything\": 42 }, \"happy\": true, \"list\": [ 1, 0, 2 ], \"name\": \"Niels\", \"nothing\": null, \"object\": { \"currency\": \"USD\", \"value\": 42.99 }, \"pi\": 3.141 } )\"; auto jsonObj = json::parse(strJSON); std::cout &lt;&lt; jsonObj[\"pi\"].get&lt;float&gt;() &lt;&lt; std::endl; // 3.141 std::cout &lt;&lt; jsonObj[\"pi\"].get&lt;double&gt;() &lt;&lt; std::endl; // 3.141 std::cout &lt;&lt; std::boolalpha &lt;&lt; jsonObj[\"happy\"].get&lt;bool&gt;() &lt;&lt; std::endl; // true std::cout &lt;&lt; jsonObj[\"name\"].get&lt;std::string&gt;() &lt;&lt; std::endl; // Niels assert(jsonObj[\"nothing\"] == nullptr); std::cout &lt;&lt; jsonObj[\"answer\"][\"everything\"].get&lt;int&gt;() &lt;&lt; std::endl; // 42 std::cout &lt;&lt; jsonObj[\"list\"].size() &lt;&lt; std::endl; // 3 std::cout &lt;&lt; jsonObj[\"list\"][0].get&lt;int&gt;() &lt;&lt; std::endl; // 1 std::cout &lt;&lt; jsonObj[\"list\"][1].get&lt;int&gt;() &lt;&lt; std::endl; // 0 std::cout &lt;&lt; jsonObj[\"list\"][2].get&lt;int&gt;() &lt;&lt; std::endl; // 2 std::cout &lt;&lt; jsonObj[\"object\"][\"currency\"].get&lt;std::string&gt;() &lt;&lt; std::endl; // USD std::cout &lt;&lt; jsonObj[\"object\"][\"value\"].get&lt;float&gt;() &lt;&lt; std::endl; // 42.99 // 依次输出: // 1 // 0 // 2 for (json::iterator it = jsonObj[\"list\"].begin(); it != jsonObj[\"list\"].end(); ++it) { std::cout &lt;&lt; *it &lt;&lt; std::endl; } return 0;} 3. 异常处理当解析和生成 JSON 出错时，nlohmann/json 会抛出异常，因此在解析和生成 JSON 时，需要进行异常捕获。 1234567891011121314151617181920int main(){ using json = nlohmann::json; std::string strJSON = u8R\"( { \"pi\": 3.141 } )\"; try { auto jsonObj = json::parse(strJSON); std::cout &lt;&lt; jsonObj[\"ppp\"].get&lt;float&gt;() &lt;&lt; std::endl; } catch (std::exception&amp; e) { std::cout &lt;&lt; e.what() &lt;&lt; std::endl; } return 0;} 4. 判断成员是否存在12345678910111213141516int main(){ using json = nlohmann::json; std::string strJSON = u8R\"( { \"pi\": 3.141 } )\"; auto jsonObj = json::parse(strJSON); std::cout &lt;&lt; std::boolalpha &lt;&lt; jsonObj.contains(\"pi\") &lt;&lt; std::endl; // true std::cout &lt;&lt; std::boolalpha &lt;&lt; jsonObj.contains(\"ppp\") &lt;&lt; std::endl; // false return 0;}","link":"/post/1128187204.html"},{"title":"开源库rpclib使用备忘","text":"rpclib是一个 C++的 RPC 库，基于 MessagePack 进行二进制序列化和反序列化，底层使用 TCP 进行进程间通信。其功能与 Facebook 的 Thrift、Google 的 Protocol Buffers 相似，但 rpclib 更加轻量级，不需要依赖 Boost，而且不用声明接口描述文件。 rpclib 官网：https://github.com/rpclib/rpclib 1. 编译使用 CMake 生成对应编译系统的项目文件，编译即可，也可以使用 vcpkg 进行安装，如： 1vcpkg install rpclib:x86-windows-static 2. 简单应用rpclib 有服务端和客户端概念，只能由客户端调用服务端，接受服务端的返回值，服务端不能主动调用客户端函数。如需实现两端双向调用，则需要在两端分别启动一个服务端和客户端，并彼此相连。 rpclib 库的错误是通过 C++异常抛出的，因此在使用该库时需要使用 try...catch 进行异常捕获。 2.1 服务端在服务端完成端口监听，及函数的绑定操作。 12345678910111213141516#include \"rpc/server.h\"try { std::shared_ptr&lt;rpc::server&gt; rpcServer = std::make_shared&lt;rpc::server&gt;(\"0.0.0.0\", 8001); // 8001为监听端口 // 绑定Add函数，供客户端调用 rpcServer-&gt;bind(\"Add\", [](int x, int y) -&gt; int { return x + y; }); rpcServer-&gt;async_run(); // 异步启动Server循环，也可以使用run()同步启动}catch(std::exception&amp; e) { // ...} 2.2 客户端客户端通过 IP 和端口连接服务端，并调用服务端的函数。 1234567891011121314#include \"rpc/client.h\"try { std::shared_ptr&lt;rpc::client&gt; rpcClient = std::make_shared&lt;rpc::client&gt;(\"127.0.0.1\", 8001); // 服务端监听端口 rpcClient-&gt;set_timeout(200); // 设置同步调用的超时时间 int result = rpcClient-&gt;call(\"Add\", 100, 200).as&lt;int&gt;(); // 调用Add函数，参数为100,200 // result为Add函数的返回值}catch(std::exception&amp; e) { // ...} 2.3 支持的参数和返回值类型rpclib 使用 MessagePack 进行序列化，支持的数据类型与 MessagePack 相同。支持如下 C++类型： bool char* double float char，不支持 wchar_t short int long long long std::string，不支持 std::wstring std::vector std::array std::map std::shared_ptr std::unique_ptr 3. 广告在这里推荐我的veigar框架，一个基于共享内存的rpc框架，与rpclib相比有如下的优势： 没有服务端和客户端的概念，每个Veigar实例间都可以相互调用。 没有网络问题，如端口占用、半关闭状态等。 没有诡异的端口假可用性问题（特别是在Windows系统上）。","link":"/post/1963116418.html"},{"title":"以管理员权限运行批处理脚本","text":"基本原理： 根据 系统自带的cacls.exe 是否能够访问”%SystemDrive%\\System Volume Information”文件，来判断当前批处理进程是否具有管理员权限。 创建 vbs 脚本到临时目录，然后使用该脚本提权执行当前 bat 文件。 下面是批处理模板，在最后追加需要执行的脚本即可。 123456789101112131415@echo offcd /d \"%~dp0\"cacls.exe \"%SystemDrive%\\System Volume Information\" &gt;nul 2&gt;nulif %errorlevel%==0 goto Adminif exist \"%temp%\\getadmin.vbs\" del /f /q \"%temp%\\getadmin.vbs\"echo Set RequestUAC = CreateObject^(\"Shell.Application\"^)&gt;\"%temp%\\getadmin.vbs\"echo RequestUAC.ShellExecute \"%~s0\",\"\",\"\",\"runas\",1 &gt;&gt;\"%temp%\\getadmin.vbs\"echo WScript.Quit &gt;&gt;\"%temp%\\getadmin.vbs\"\"%temp%\\getadmin.vbs\" /fif exist \"%temp%\\getadmin.vbs\" del /f /q \"%temp%\\getadmin.vbs\"exit:Adminrem ---------- Here is the script to be run ------------","link":"/post/3405299964.html"},{"title":"如何在批处理中执行SQL","text":"示例如下： 123\"%~dp0\\mysql-5.6.19-win32\\bin\\mysql.exe\" ^ -h127.0.0.1 -P31060 -uroot ^ --execute=\"update mysql.user SET password=PASSWORD('123456') WHERE user='root';\";","link":"/post/4169328538.html"},{"title":"批处理运行外部程序","text":"本文介绍了批处理中启动外部程序和批处理的几种不同方法，以及如何获取命令返回值，最后还介绍了批处理中命令顺序执行的几种方法的区别。 1. start、call 和直接运行1.1 start使用 start 命令时，当前批处理不会等待外部程序运行结束，而是继续向下执行。 使用 start 命令运行其他批处理和 windows 命令行程序时，还会创建一个新的命令行窗口，并将在新的窗口中运行新的程序，如： 123456789@echo offecho 1start ping baidu.comecho 2start notepad.exeecho 3start other.batecho 4pause 1.2 call使用 call 命令时，当前批处理会等待外部程序或批处理运行结束，然后才继续向下执行。并且始终在当前命令行窗口中运行其他批处理和命令行程序。 1.3 直接运行直接运行与使用 call 命令一样。但直接运行外部批处理时会破坏当前批处理的运行流程，会导致执行流程无法返回到当前批处理继续执行。 123456789@echo offecho 1ping baidu.comecho 2notepad.exeecho 3other.batecho 4pause 上述示例，执行other.bat后，无法返回到当前批处理，从而无法执行echo 4及后面语句。 2. 获取命令的返回值在 Windows 批处理中，%errorlevel%变量保存着上一个命令的执行结果（即main函数的返回值）。一般来说，0 表示执行成功，非 0 则表示执行失败，具体的非 0 值的含义则取决于具体的命令。 在批处理脚本中，可以根据%errorlevel%的值来进行后续的处理逻辑，例如： 1234567891011@echo offREM 执行一个命令start un-exist.exeREM 判断命令执行结果if %errorlevel% equ 0 ( echo success) else ( echo failed with: %errorlevel%)pause 运行结果如下： 123系统找不到文件 un-exist.exe。failed with: 9059请按任意键继续. . . %errorlevel%是上一个命令的执行结果，因此上面例子中的 9059 是 start 命令的结果，而不是 un-exist.exe 返回的结果。 3. 顺序执行Windows 批处理提供了&amp;、&amp;&amp;、||、|、&gt;、&gt;&gt;等顺序执行方式，它们区别如下（下面说的执行成功指的是命令返回值为 0）： &amp; 顺序执行多条命令，而不管前面命令是否执行成功。 &amp;&amp; 顺序执行多条命令，当前面命令执行出错，后面的命令将不会执行。 || 顺序执行多条命令，直到遇到执行成功的命令。 | 管道命令，将前一个命令的执行结果输出到后一个命令 如：help|more。 &gt; 文件写入命令，清除原文件中的内容后再写入。 &gt;&gt; 文件追加写入命令","link":"/post/2372684836.html"},{"title":"批处理杂记","text":"1. exitexit命令用于退出当前的批处理脚本，并返回一个退出代码ExitCode（即返回值）。退出代码通常是一个整数，用于指示脚本执行的状态，例如成功（0）或失败（非零值）。 exit命令的语法为： 1exit [/b] [exitCode] 其中 /b 选项表示仅退出当前批处理脚本的执行，而不会影响调用脚本的父进程。如果不使用 /b 选项，则 exit 命令会终止当前整个的命令处理器进程（CMD.EXE），并返回退出代码给调用者。 exitCode 是一个可选参数，用于指定退出代码。如果未指定退出代码，则默认返回上一个命令的退出代码。 2. 变量延迟扩展SETLOCAL ENABLEDELAYEDEXPANSION的作用是设置本地变量延迟扩展。 CMD在执行命令前会对脚本进行预处理，在这个过程中，如果有类似%value%这样的变量就会对其进行识别，并且查找这个变量对应的值，从而用该值替换掉变量，这个替换值的过程，就叫变量扩展，这个类似于C/C++中的宏。 请看下面示例： 123@echo offset a=4set a=5 &amp; echo %a% 结果：4 为什么输出是4而不是5呢？ 原因是批处理是按行读取命令的（另外例如for命令等，其后用一对圆括号闭合的所有语句也当作一行），在执行之前要完成必要的预处理工作，这其中就包括对该行命令中的变量赋值。上例中，批处理在运行到set a=5 &amp; echo %a%之前，先把这一整句读取并做了预处理（对变量a赋了值），此时%a%当然就是4。 明白这个道理之后，我们将上例修改为如下方式，就可以输出结果5。 1234@echo offset a=4set a=5echo %a% 为了能够让批处理感知变量的动态变化，批处理设计了变量延迟，即在读取了一条完整的语句之后，不立即对该行的变量赋值，而会在单条语句执行之前再进行赋值，也就是说“延迟”了对变量的赋值。 1234@echo offSETLOCAL ENABLEDELAYEDEXPANSIONset a=4set a=5 &amp; echo !a! 结果：5 由于启动了变量延迟，得到了输出结果5。 变量延迟的启动语句是SETLOCAL ENABLEDELAYEDEXPANSION，并且变量要用一对叹号括起来，否则就没有变量延迟的效果。 3. 调用npm命令无法返回原批处理需要使用call命令，如： 1call npm install 具体原因参考：批处理运行外部程序 可以使用%errorlevel%获取命令的执行结果（通常0表示成功），如： 123456call npm run build-releaseif %errorlevel% NEQ 0 goto ERROR:ERRORecho Compile Failed 4. 切换脚本的当前目录有些命令依赖批处理程序的当前目录，如npm、yarn这样的命令。假如项目位于D:\\A\\B路径，使用批处理（文件位于D:\\build.bat）进行自动构建： 123@echo offcd D:\\A\\Bcall npm run build 运行上面批处理，构建会失败，通常会提示诸如“D:\\package.json不存在”的错误，原因是npm命令是批处理程序的当前目录查找package.json文件的，批处理程序的当前目录默认为批处理文件所在的目录，即D:\\，D:\\package.json不存在，因此构建失败。 可以使用为cd命令指定/d参数来切换批处理程序的当前目录，上面示例可以修改为： 123@echo offcd /d D:\\A\\Bcall npm run build 5. 批处理命令换行当批处理命令过长，如果都写在一行不便于阅读，可以使用^符号进行分割。 123456call \"%qt_src_folder%\\configure.bat\" -silent -debug-and-release -force-debug-info -strip ^ -platform win32-msvc -static -static-runtime -no-opengl -no-dbus -no-icu ^ -nomake examples -nomake tests -skip qtwebengine -skip qtlocation ^ -qt-harfbuzz -qt-freetype -qt-zlib -qt-doubleconversion ^ -mp -optimize-size -ltcg -no-pch ^ OPENSSL_LIBS=\"-lUser32 -lAdvapi32 -lGdi32 -lWS2_32 -lCRYPT32 -llibcrypto32 -llibssl32\" 6. ECHO 处于关闭状态遇到“ECHO 处于关闭状态”提示，通常是因为输出变量为空导致。 此时需要注意如下情况： 批处理变量左右不能有空格。如果有空格，空格会被当成变量名，如set a =1，变量名实际为a 。 开启变量延迟扩展后，引用变量需要使用两个!的方式，如!str_a!。 7. 显示选择项提示用户选择使用CHOICE命令可以提供用户在指定的选项中选择一项，并使用%ERRORLEVEL%获取选择的值。 CHOICE命令语法如下： 12345678910111213141516171819202122232425262728293031CHOICE [/C choices] [/N] [/CS] [/T timeout /D choice] [/M text]描述: 该工具允许用户从选择列表选择一个项目并返回所选项目的索引。参数列表: /C choices 指定要创建的选项列表。默认列表是 \"YN\"。 /N 在提示符中隐藏选项列表。提示前面的消息得到显示， 选项依旧处于启用状态。 /CS 允许选择分大小写的选项。在默认情况下，这个工具 是不分大小写的。 /T timeout 做出默认选择之前，暂停的秒数。可接受的值是从 0 到 9999。如果指定了 0，就不会有暂停，默认选项 会得到选择。 /D choice 在 nnnn 秒之后指定默认选项。字符必须在用 /C 选 项指定的一组选择中; 同时，必须用 /T 指定 nnnn。 /M text 指定提示之前要显示的消息。如果没有指定，工具只 显示提示。 /? 显示此帮助消息。 注意: ERRORLEVEL 环境变量被设置为从选择集选择的键索引。列出的第一个选择返回 1，第二个选择返回 2，等等。 如果用户按的键不是有效的选择，该工具会发出警告响声。如果该工具检测到错误状态，它会返回 255 的ERRORLEVEL 值。 如果用户按 Ctrl+Break 或 Ctrl+C 键，该工具会返回 0的 ERRORLEVEL 值。 在一个批程序中使用 ERRORLEVEL 参数时，将参数降序排列。 如： 1CHOICE /C YNC /M \"确认请按 Y，否请按 N，或者取消请按 C。\"","link":"/post/3801212176.html"},{"title":"NSIS教程(1)-基础语法","text":"NSIS（Nullsoft Scriptable Install System）是一个开源的 Windows 系统下安装包制作程序。NSIS 通过它定义的脚本语言来描述安装包的行为和逻辑的。 一. 环境搭建从http://nsis.sourceforge.net/Download下载 NSIS 安装进行安装。 使用 NSIS 生成安装包的大致流程如下： 使用任意文本编辑器（如 notepad++、Visual Studio Code）开发 NSIS 脚本 使用安装目录内的makensisw.exe编译 NSIS 脚本生成安装包。 makensisw.exe 只提供编译脚本的功能，不能对脚本进行调试。 二. NSIS 脚本结构一个 NSIS 脚本可以包括安装程序属性、页面、区段等。对于一个最简单的 NSIS 脚本，只有OutFile属性和一个区段是必须的，OutFile属性指定 NSIS 编译生成安装包的路径）。 1234OutFile \"Simple.exe\"Section \"Installer Section\"SectionEnd 保存上面脚本到*.nsi 文件，并使用makensisw.exe打开编译，如下图表示编译成功，成功之后会在脚本当前目录看到输出的Simple.exe； 如果编译失败，makensisw.exe会在输出窗口提示失败原因。 需要注意：如果 NSIS 脚本内包含中文等分 ASCII 字符，需要将脚本保存为 ANSI 编码格式，而不能保存为 UTF8 格式。 2.1 安装程序属性安装程序的属性用于控制安装程序的外观，包括哪个页面出现在安装程序里，在每个页面的每个部分显示什么文本，安装程序的名称（如上面脚本中的OutFile），使用什么样的图标，默认安装目录等等。 安装程序属性可以在除了区段和函数以外的任何地方设置。 可以理解为安装程序属性是设置给 NSIS 编译器看的，这些属性值在编译时都已经确定了，所以除了 InstallDir 以外，其他安装程序属性都不允许使用变量（除了$\\r和$\\n）。 2.2 完整的安装程序属性见 NSIS教程(2)-完整属性 2.2 页面页面分为NSIS内置的向导页面和用户自定义页面。 一个非静默安装程序需要页面来指导用户运行安装程序，可以通过Page命令或PageEx（PageEx 提供了更多高级的设置）命令来设定哪个页面显示。 页面实际的显示顺序和它在 NSIS 脚本中定义的顺序是一致的。 2.2.1 内置向导页面：NSIS 内置的向导页面有： license：许可证页面。 components： 组件选择页面，每个可见的区段都可以作为一个组件给用户选择是否安装。你可以只使用一个区段来构建安装包，但是如果你想要使用组件页来让用户选择可选的组件，那你就需要使用多个区段。 directory： 安装目录选择页面。 instfiles： 安装过程页面。 uninstConfirm： 卸载确认页面。 不同的页面，有不同的属性。 内置页面语法如下： 1Page (license|components|directory|instfiles|uninstConfirm) [预置函数] [显示函数] [离开函数] 每个内建的页面都有三个回调函数（预置函数、显示创建函数和离开函数），预置函数在页面被创建之前被直接的调用，显示函数在页面被创建后且在显示之前被直接调用，离开函数在用户按下下一页按钮之后并且在页面离开之前被直接调用。 如： 123PageEx license LicenseData \"license.rtf\" #可以是txt或rtf文件格式PageExEnd 2.2.2 自定义页面创建自定义页面语法： 1page custom [创建函数] [离开函数] [标题] 自定义页面只有两个回调函数（创建函数和离开函数），创建函数在需要创建页面时被调用，离开函数在用户按下”下一页”按钮之后并且在页面离开之前被直接调用。 2.2.3 页面回调函数每个内建的页面都有三个回调函数：一个预置函数、一个显示创建函数和一个离开函数。 预置函数在页面被创建之前被直接的调用，显示函数在页面被创建后且在显示之前被直接调用，离开函数在用户按下下一页按钮之后并且在页面离开之前被直接调用。 预置函数允许使用 Abort 来略过该页面。 显示函数允许使用 CreateFont、SetCtlColors、SendMessage 和其他来调整页面的用户界面。 离开函数允许使用 Abort 来强制用户停留在当前页面。 一个自定义的页面仅有两个回调函数，一个是必须的创建页面，另一个离开函数的作用就和内建页面的离开函数一样。 例如： 123456789101112131415161718192021222324252627Page license skipLicense \"\" stayInLicensePage custom customPage \"\" \": 自定义页面\"Page instfilesFunction skipLicense MessageBox MB_YESNO \"你想略过许可页面吗？\" IDNO no Abort no:FunctionEndFunction stayInLicense MessageBox MB_YESNO \"你想停留在许可页面吗？\" IDNO no Abort no:FunctionEndFunction customPage GetTempFileName $R0 File /oname=$R0 customPage.ini InstallOptions::dialog $R0 Pop $R1 StrCmp $R1 \"cancel\" done StrCmp $R1 \"back\" done StrCmp $R1 \"success\" done error: MessageBox MB_OK|MB_ICONSTOP \"InstallOptions error:$\\r$\\n$R1\" done:FunctionEnd 2.3 区段（Section）在安装程序中用户需要安装许多东西，如安装源码、附加插件、脚本样例或其他。里面的每个安装组件都有它自己的代码块，当用户选择了安装该组件，那么安装程序就会执行对应的代码。 在 NSIS 脚本里，这些代码称为区段。每个可见的区段都可以作为一个组件给用户选择是否安装（区段也可以设置属性对用户隐藏，默认安装，让用户无法选择是否安装）。 NSIS 脚本对区段的数量没有限制，你可以只使用一个区段来构建安装包，但是如果你想要使用组件页来让用户选择可选的组件，那你就需要使用多个区段了。 卸载程序也可以有多个区段，但卸载程序区段名前要加上前缀un.，因为卸载程序是要被编译成是一个单独的 exe 的，所以要对编译器指明哪些内容（如区段）需要被编译进卸载程序，因此需要特殊前缀。 区段名为空、遗漏或者以一个 “-“ 开头，那么它将是一个隐藏的区段，用户也不能在组件选择页面选择是否禁止。 三. NSIS 语法3.1 语法概述 单行注释用井号#或分号;，跨行注释用可以用 C/C++中注释语法； 数字常量可以用十进制、十六进制(0x 为前缀)、八进制(0 为前缀)表示，颜色用类似 html 的中 RGB 表示法，但去井号”#”。 字符串常量可以用引号引用，特殊的字符可以使用美元符号”$”作前缀来转义。美元符号、换行、回车、制表符都是特殊字符，需要转义，他们在NSIS中可以写成： $$, $\\n, $r, $\\t NSIS 脚本用行尾的反斜杠”\"表示下一行和当前行逻辑上是同一行。 3.2 常量和变量NSIS 的变量和常量都是全局的，且大小写敏感的，NSIS 中变量和常量都是弱类型的。 常用和变量的引用方式都是${VAR_NAME}或$VAR_NAME。 使用!define方式定义常量，如：!define PRODUCT_NAME \"网易云音乐\" 使用Var方式定义变量，如：Var a NSIS 内置了 20 个已注册的变量：$0 ~ $9 和 $R0 ~ $R9，这些变量不需要声明就可以使用，一般用于参数传递等。 另外，NSIS 内置一个堆栈，使用push和pop命令来入栈和出栈，可以使用堆栈来暂存数据。 关于变量的赋值，NSIS 中不能直接使用=来赋值，需要借助StrCpy来实现，如： 12StrCpy $0 \"hello\"StrCpy $0 123 3.3 函数3.3.1 函数定义123Function 函数名FunctionEnd 函数名以“.”开头的(例如 “.Whatever”)一般作为回调函数保留。函数名以“un.”开头的函数将会被创建在卸载程序里。因此，普通安装区段和函数不能调用卸载函数，而卸载区段和卸载函数也不能调用普通函数。NSIS 函数声明中不支持参数定义，如果需要传递参数，可以使用内置的 20 个变量或者堆栈的方式。 3.3.2 函数调用1Call 函数名 3.4 宏除了函数之外，NSIS 还支持定义宏，NSIS 中的宏支持定义参数。 3.4.1 宏定义123!macro 宏名 [参数1] [参数n]!macroend 3.4.2 宏调用1!insertmacro 宏名 [参数1] [参数n] 3.5 指令NSIS 内置了很多指令，这些指令提供了安装包常用了功能，如果这些指令无法满足需求，用户也可以自己开发插件。 NSIS 支持的指令列表见：NSIS教程(3)-完整指令 NSIS 指令使用中比较特别的在于跳转，比如执行失败跳转到哪里，成功跳转到哪里。以MessageBox指令为例（[]为可选项）： 1MessageBox 消息框选项列表 消息框文本 [/SD 返回] [检测返回值 跳转到] [检测返回值2 跳转到2] 下面的用法表示如果 MessageBox 返回 IDYES，则+2，即跳转到该指令的下 2 条执行（+1 该指令的下 1 条，+2 就为该指令的下 2 条），/SD IDYES表示安装包采用静默安装方式时默认用户选择了IDYES: 1MessageBox MB_ICONQUESTION|MB_YESNO \"你确实要完全删除网易云音乐，及其所有组件吗?\" /SD IDYES IDYES +2 IDNO +1 四. NSIS 界面NSIS 提供的界面分为传统界面（Classic UI）、现代界面（Modern UI）。 4.1 传统界面 4.2 现代界面 4.3 自定义界面我们可以使用第三方界面库（如 duilib, Qt）自己绘制安装包的界面，这样灵活度更大，可以开发出类似 QQ 那样的安装界面。在此之前需要掌握 NSIS 的插件开发技巧。","link":"/post/409779091.html"},{"title":"NSIS教程(10)-MUI跳过指定安装步骤","text":"在正常情况下安装包会有“欢迎界面”、“安装目录选择界面”等等，有时我们需要安装包自动跳过这 2 个界面，如安装包通过命令行参数传入“安装目录”（如setup.exe /installdir F:\\test），本文讲述如何使安装包跳过指定的界面。 HOW TO DO?在页面插入宏之前通过MUI_PAGE_CUSTOMFUNCTION_PRE来指定 pre 处理函数，在该函数中来判断是否需要跳过： 12345678# 安装程序欢迎页面!define MUI_PAGE_CUSTOMFUNCTION_PRE SkipPage!insertmacro MUI_PAGE_WELCOME# 安装程序显示安装目录选择页面!define MUI_PAGE_CUSTOMFUNCTION_PRE SkipPage!insertmacro MUI_PAGE_DIRECTORY SkipPage函数定义如下： 123456Function SkipPage StrLen $R1 $paramInstllDir ${If} $R1 &gt; 0 Abort ${EndIf}FunctionEnd 获取命令行参数存入$paramInstllDir变量，并解析命令行参数： 12345678910!macro ParseParameters ${GetParameters} $R0 ${GetOptions} $R0 '/installdir' $R1 StrCpy $paramInstllDir $R1 StrLen $R1 $paramInstllDir ${If} $R1 &gt; 0 StrCpy $INSTDIR $paramInstllDir ${EndIf}!macroend","link":"/post/1597634702.html"},{"title":"开源库spdlog使用备忘","text":"spdlog是一个高性能C++日志库，支持仅头文件（header-only）模式使用。 官网地址： https://github.com/gabime/spdlog spdlog是线程安全的，但不是进程安全的，可以多个线程同时使用一个spdlog对象输出日志，但不能多个进程同时往一个文件写入日志。 在spdlog内部使用fmt进行字符串的格式化，因此spdlog字符串格式的方式与fmt库相同，如： 1spdlog::critical(\"Support for int: {0:d}; hex: {0:x}; oct: {0:o}; bin: {0:b}\", 42); 一、日志级别大多数日志库都有日志级别的概念，通过设定日志级别可以动态控制我们需要打印输出的日志，spdlog支持如下日志级别： 123456trace = SPDLOG_LEVEL_TRACE // 最低级debug = SPDLOG_LEVEL_DEBUGinfo = SPDLOG_LEVEL_INFOwarn = SPDLOG_LEVEL_WARNerr = SPDLOG_LEVEL_ERRORcritical = SPDLOG_LEVEL_CRITICAL // 最高级 如下代码设置日志级别为info，此时只会打印输出info及比info级别高的日志： 1spdlog::set_level(spdlog::level::info); 二、Logger和Sinkspdlog主要由Logger(记录器)和Sink(输出位置)两部分组成，spdlog的高可拓展性体现在Logger和Sink的可以由用户自定义方面。 每个程序可以创建多个Logger对象，而每个Logger对象又可以包含多个Sink（也就是可以同时输出到多个位置）。 2.1 创建Sink在介绍Logger的创建方法前，我们先看看如何创建Sink对象。 每个Sink都是一个std::shared_ptr&lt;spdlog::sink&gt;对象，创建Sink方法如下： 1auto sink = std::make_shared&lt;spdlog::sinks::stdout_sink_mt&gt;(); spdlog有_mt（multi threaded）和_st（single threaded）两类后缀的sink对象，用于区分是否线程安全。单线程(_st后缀)的sink是非线程安全的，不能被多个线程使用。 spdlog内置了多种不同的sink类型，如可以输出到文件、控制台、tcp/udp端口、Windows事件日志、mongo数据库等。完整的sink可以查看源代码的sinks目录，通常一个文件对应一个sink。 虽然内置的Sink可以满足我们的大多数需求，但spdlog依然支持自定义Sink，具体方法参考官方文档：implementing-your-own-sink 下面介绍几种常用内置sink的创建方法。 simple_file_sink一个简单的文件接收器，将日志写入到给定的日志文件，没有任何的限制。 123#include \"spdlog/sinks/basic_file_sink.h\"// ...auto logger = spdlog::basic_logger_mt(\"mylogger\", \"log.txt\"); 关于日志的输出目录，如上面的data/logs目录，从splog 1.5.0版本开始，spdlog将自动创建包含日志文件的目录。但在此之前，必须手动创建目录。 rotating_file_sink当达到最大文件大小时，关闭文件，并重命名，然后创建一个新的文件。最大文件大小和最大文件数都可以在构造函数中配置。 1234#include \"spdlog/sinks/rotating_file_sink.h\"// ...auto file_logger = spdlog::rotating_logger_mt(\"file_logger\", \"data/logs/mylogfile.log\", 1048576 * 5, 3); daily_file_sink每天在指定的时间创建一个新的日志文件，并在文件名后附加一个时间戳。 123#include \"spdlog/sinks/daily_file_sink.h\"// ...auto daily_logger = spdlog::daily_logger_mt(\"daily_logger\", \"logs/daily\", 14, 55); 上面代码将创建一个线程安全的sink，该sink将在每天14:55创建一个新的日志文件。 stdout_sink输出到控制台。 12#include \"spdlog/sinks/stdout_sinks.h\"auto sink = std::make_shared&lt;spdlog::sinks::stdout_sink_mt&gt;(); stdout_sink with colors输出到控制台，并带颜色标记。 12#include \"spdlog/sinks/stdout_sinks.h\"auto sink = std::make_shared&lt;spdlog::sinks::stdout_color_sink_mt&gt;(); msvc_sink输出到Windows调试接收器（如DbgView）,在spdlog内部实际使用OutputDebugStringA进行日志输出。 123#include \"spdlog/sinks/msvc_sink.h\"// ...auto sink = std::make_shared&lt;spdlog::sinks::msvc_sink_mt&gt;(false); msvc_sink的构造函数支持check_debugger_present参数，如果该参数为true，则仅在调试环境输出日志到Windows调试接收器。 dup_filter_sink在日志输出时移除重复的日志。如果日志与前一条日志相同，并且间隔时间小于max_skip_duration，则跳过输出该日志。 123456789#include \"spdlog/sinks/dup_filter_sink.h\"auto dup_filter = std::make_shared&lt;dup_filter_sink_mt&gt;(std::chrono::seconds(5));spdlog::logger l(\"logger\", dup_filter);l.info(\"Hello\");l.info(\"Hello\");l.info(\"Hello\");l.info(\"Different Hello\"); 上面示例输出的日志如下： 123[2019-06-25 17:50:56.511] [logger] [info] Hello[2019-06-25 17:50:56.512] [logger] [info] Skipped 3 duplicate messages..[2019-06-25 17:50:56.512] [logger] [info] Different Hello 2.2 创建Logger在创建完Sink对象后，就可以使用这些Sink来创建Logger对象。 下面示例创建了名为mylogger的同步Logger对象，为该对象配置了2个sink。 123456789auto file_sink = std::make_shared&lt;spdlog::sinks::rotating_file_sink_mt&gt;(\"logs/app.log\", 1048576, 7);auto msvc_sink = std::make_shared&lt;spdlog::sinks::msvc_sink_mt&gt;(false);std::vector&lt;spdlog::sink_ptr&gt; sinks = {file_sink, msvc_sink};auto logger = std::make_shared&lt;spdlog::logger&gt;(\"mylogger\", sinks.begin(), sinks.end()); spdlog内部为每个进程都维护一张全局的Logger记录表，记载了每个进程中通过工厂方法创建的Logger实例(某些情况需要用户手动注册)。因而，在使用时只需要知道创建时指定的名称即可获取Logger对象： 123auto logger = spdlog::get(\"mylogger\");logger-&gt;info(\"some things want to say.\"); 三、自定义日志格式日志格式作用在Sink对象上，每个Sink都有一个格式化程序，spdlog的默认日志记录格式为： 1[2014-10-31 23:46:59.678] [my_loggername] [info] Some message 我们可以通过下面方式为当前进程的所有Logger对象的所有Sink都统一设置日志格式： 1spdlog::set_pattern(\"*** [%H:%M:%S %z] [thread %t] %v ***\"); 也可以通过下面方式为指定的Logger对象的所有Sink设置日志格式： 1some_logger-&gt;set_pattern(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\"); 当然可以针对具体的Sink来设置日志格式： 12345some_logger-&gt;sinks()[0]-&gt;set_pattern(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\");some_logger-&gt;sinks()[1]-&gt;set_pattern(\"..\");// 或some_sink-&gt;set_pattern(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\"); 在设置日志格式时，spdlog都会对格式进程预编译，避免每次输出日志都进程格式解析，提升日志性能。 3.1 格式标记下面列出了spdlog的pattern字符串支持的格式标记（类似%flag）。 标记 含义 示例 %v 实际的日志文本 some user text %t 线程ID 1232 %P 进程ID 3456 %n 日志名称 some logger name %l 日志等级全称 debug、info等 %L 日志等级简写 D、I等 %a 简写星期名称 Thu %A 星期名称全程 Thursday %b 简写月份名称 Aug %B 月份名称全程 August %c 日期和时间 Thu Aug 23 15:35:46 2014 %C 两位数表示年份 2014输出14 %Y 四位数表示年份 2014 %D MM/DD/YY格式的日期 08/23/14 %m 月份（01-12） 11 %d 天（01-31） 29 %H 24小时制的小时(00-23) 23 %I 12小时制的小时(01-12) 11 %M 分钟（00-59） 59 %S 秒（00-59） 58 %e 毫秒 678 %f 微妙 056789 %F 纳秒 256789123 %p AM/PM AM %r 12小时制时间 02:55:02 PM %R 24小时制时间，等同于 %H:%M 23:55 %T或%X ISO 8601时间格式，等同于%H:%M:%S 23:55:59 %z ISO 8601时间格式，时区偏移 ([+/-]HH:MM) 如中国是东8区，+08:00 %E 时间戳 1528834770 %% 输出% % %+ spdlog默认格式 [2014-10-31 23:46:59.678] [mylogger] [info] Some message %^ 开始颜色标记（只能使用一次） [mylogger] [info(green)] Some message %$ 结束颜色标记(如%^[+++]%$ %v) (只能使用一次) [+++] Some message %@ 源文件路径和所在行数，等同于%g:%# /some/dir/my_file.cpp:123 %s 源文件名 my_file.cpp %g 源文件的完整路径或相对路径，等同于__FILE__宏 /some/dir/my_file.cpp %# 源码所在行数 123 %! 源码所在函数名 my_func %o 与上条日志的间隔时间（毫秒） 456 %i 与上条日志的间隔时间（微秒） 456 %u 与上条日志的间隔时间（纳秒） 11456 %O 与上条日志的间隔时间（秒） 4 使用示例： 12auto file_sink = std::make_shared&lt;spdlog::sinks::rotating_file_sink_mt&gt;(\"logs/app.log\", 1048576, 7);file_sink-&gt;set_pattern(\"%Y-%m-%d %H:%M:%S.%e %z %-10n %-8l [%P %t] %v\"); 输出日志格式如下： 12023-12-21 09:34:45.691 +08:00 Dock1703122417075610 info [15460 6948] this is log text 源码位置标记如果需要使用源码位置标记，如%s, %g, %#, %!，需要在包含spdlog头文件之前，定义如下宏： 1#define SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_TRACE 3.2 对齐每个格式标记可以通过预先添加宽度标记来实现对齐。 使用-（左对齐）或=（中间对齐）控制对齐方向： 对齐 含义 示例 结果 % 右对齐 %8l “ info” %- 左对齐 %-8l “info “ %= 中间对齐 %=8l “ info “ 3.3 截断还可以通过添加!标记来进行数据截断，如果宽度超过指定的宽度，则截断结果： 对齐 含义 示例 结果 %! 右对齐并长度超过3个后截断 %3!l “inf” %-! 左对齐并长度超过2个后截断 %-2!l “in” %=! 中间对齐并长度超过1个后截断 %=1!l “i” 四、输出策略(Flush policy)基于性能考虑，spdlog不会立即输出日志，而是在内部通过日志队列的方式缓存日志，在合适的时候进行批量输出。 如果需要让spdlog立即输出队列中的日志，可以通过下面的几种方式实现。 4.1 手动操作我们可以单独调用Sink的flush函数立即输出队列中的日志，也可以调用Logger对象的flush函数让该对象下的所有sink立即输出。 如果是异步日志，调用flush函数只会给日志队列发送一个flush消息，不会立即刷新。 在程序退出前，spdlog会确保队列中的所有日志都输出完成。如果想手动确保所有日志输出完成后退出程序，可以调用spdlog::shutdown()函数。 4.2 基于日志等级的输出您可以设置将触发自动输出的最低日志级别。例如，每当记录错误或更严重的消息时，这将触发立即输出： 1my_logger-&gt;flush_on(spdlog::level::err); 4.3 定时输出所有已注册的Logger每5秒的定期输出： 1spdlog::flush_every(std::chrono::seconds(5)); 这种方式只能使用在线程安全的sink上（即_mt后缀），因为定时输出任务执行在不同的线程上。 五、异常spdlog在其文档中关于异常的说明，spdlog只会在构造Logger和Sink错误时主动抛出异常，因为spdlog认为这个错误是致命的，但这个并不可信，最多只能认为spdlog在其他情况下不会主动抛出异常，但不能保证其依赖的库（如fmt）不会抛出异常。 而且如果多个进程向同一个文件写入日志，当文件达到最大大小时，spdlog会自动重命名当前文件，并新建一个新的日志文件。如果多个进程向同一个文件写入日志，会导致重命名日志文件失败，splog会将该失败认为是致命错误，并抛出异常。 如果在打印日志时出现了spdlog能够预料的错误（非预料的及三方库抛出的异常仍然会传递到外部），spdlog默认将向stderr打印错误消息，为了避免错误消息充斥屏幕，每个Logger的错误消息输出速率限制为1条消息/分钟。 spdlog提供了错误处理方法，来让用户自定义如何处理错误信息，我们可以通过set_error_handler函数来自定义错误处理方法： 123456789// 全局为每个Logger注册错误处理方法spdlog::set_error_handler([](const std::string&amp; msg) { std::cerr &lt;&lt; \"my err handler: \" &lt;&lt; msg &lt;&lt; std::endl;});// 分别为特定的Logger注册错误处理方法critical_logger-&gt;set_error_handler([](const std::string&amp; msg) { throw std::runtime_error(msg);}); spdlog不是异常安全的，在使用spdlog时一定要注意异常捕获，否则可能因为一个格式化标记写错导致程序崩溃，本来是想通过日志来排除问题的，结果却因为日志导致程序崩溃，如： 12// 导致程序崩溃logger-&gt;error(\"create device enumerator failed, hr: {#x}\", hr); 六、宽窄字符spdlog内部将字符作为char类型处理，如果需要输出wchar_t类型的字符串，需要将其转换为char类型，spdlog仅将char类型字符串原样输出，不做字符编码判断和处理，需要调用者来觉得字符串的编码，建议统一日志字符串的编码格式为UTF-8或ANSI。 七、日志格式spdlog日志字符串的格式化处理使用的是开源fmt库，其详细语法见：Format String Syntax。 下面列举了常用的日志格式化方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869logger-&gt;info(\"输出char字符串:{}\", \"hello\");// 输出char字符串:hellologger-&gt;info(\"输出std::string:{}\", std::string(\"hello\"));// 输出std::string:hello/** 输出最小长度的字符串，如果长度不足则用固定字符填充，但超出不会截断字符串*/logger-&gt;info(\"输出左对齐字符串(最小长度10，空格填充):{:&lt;10}\", \"hello\");// 输出左对齐字符串(最小长度10，空格填充):hello logger-&gt;info(\"输出左对齐字符串(最小长度10):{:&lt;10}\", \"hello my world\");// 输出左对齐字符串(最小长度10):hello my worldlogger-&gt;info(\"输出右对齐字符串(最小长度10，空格填充):{:&gt;10}\", \"hello\");// 输出右对齐字符串(最小长度10，空格填充): hellologger-&gt;info(\"输出居中对齐字符串(最小长度10，空格填充):{:^10}\", \"hello\");// 输出居中对齐字符串(最小长度10，空格填充): hello logger-&gt;info(\"输出居中对齐字符串(最小长度10，*填充):{:*^10}\", \"hello\");// 输出居中对齐字符串(最小长度10，*填充):**hello***logger-&gt;info(\"输出整型:{}\", 1234);// 输出整型:1234logger-&gt;info(\"输出布尔类型:{}\", true);// 输出布尔类型:truelogger-&gt;info(\"输出float:{}\", 3.1415936f);// 输出float:3.1415937logger-&gt;info(\"输出double:{}\", 3.1415936);// 输出double:3.1415936/** 输出最小位数（含小数点）的浮点型* 小数点前部的最小位数=总位数-后部固定位数-1，位数不足默认填充空格，超过不截断；* 小数点后部的位数始终固定，位数不足则在尾部添加0，超出则四舍五入后截断；*/logger-&gt;info(\"输出浮点型(含小数点最小位数6位（左边填充空格），小数点后始终3位):{:6.3f}\", 3.1415936);// 输出浮点型(含小数点最小位数6位（左边填充空格），小数点后始终3位): 3.142logger-&gt;info(\"输出浮点型(含小数点最小位数6位（左边填充空格），小数点后始终3位):{:6.2f}\", 31415926.1);// 输出浮点型(含小数点最小位数6位（左边填充空格），小数点后始终3位):31415926.10logger-&gt;info(\"输出小写十六进制:{:x}\", 123);// 输出小写十六进制:7blogger-&gt;info(\"输出大写十六进制:{:X}\", 123);// 输出大写十六进制:7Blogger-&gt;info(\"输出小写十六进制(带0x前缀):{:#x}\", 123);// 输出小写十六进制(带0x前缀):0x7blogger-&gt;info(\"输出大写十六进制(带0x前缀):{:#X}\", 123);// 输出大写十六进制(带0x前缀):0X7Blogger-&gt;info(\"输出小写十六进制(固定8位，不足补0):{:08x}\", 123);// 输出小写十六进制(固定8位，不足补0):0000007blogger-&gt;info(\"输出小写十六进制(带0x前缀，固定8位，不足补0):{:#010x}\", 123);// 输出小写十六进制(带0x前缀，固定8位，不足补0):0x0000007bHRESULT hr = E_FAIL;logger-&gt;info(\"输出HRESULT:{:#010x}\", (unsigned long)hr);// 输出HRESULT:0x80004005","link":"/post/2185523635.html"},{"title":"NSIS教程(11)-中文手册","text":"这这里分享几个我一直使用的NSIS中文手册： 《NSIS用户手册 中文版》 NSIS官方英文的手册上的机器翻译版本，有些地方翻译可能不太纯正。 《NSIS图文教程集锦 - 轻狂志》 里面有很多基于NSIS的安装包示例，大多数与NSIS有关的功能，都可以在这个文档找到线索。 上述文档下载地址：https://github.com/winsoft666/NSIS-Chinese-Doc","link":"/post/2948643539.html"},{"title":"NSIS教程(12)-开源UI插件","text":"一、项目介绍介绍一个我开发的开源NSIS UI插件NSIS-UI-Plugin，基于NSIS-UI-Plugin插件我们可以快速的制作出NSIS安装包。 该插件默认使用Qt作为界面库（不需要编译Qt静态库，可以使用Qt动态库），但也可以很方便的切换使用其他界面库，如DuiLib等。 项目地址：https://github.com/winsoft666/NSIS-UI-Plugin 二、依赖项使用NSIS-UI-Plugin插件需要提前安装如下工具。 2.1 NSIS从https://nsis.sourceforge.io/Download 下载NSIS并安装，新增系统环境变量NSIS_DIR为NSIS安装目录。 2.2 Python之所以需要安装Python，主要是为了执行NsisScriptGenerate.py脚本。 将Python.exe所在目录添加到Path环境变量。 2.3 Qt因为插件默认使用Qt作为界面库，所以需要安装Qt。 Qt安装包会默认将安装目录添加QTDIR环境变量，如果没有自动添加，则需要手动添加。 三、开始使用3.1 编译NSIS-UI-Plugin安装完上面依赖项之后，编译NSIS-UI-Plugin\\NSIS-UI-Plugin.vcxproj工程，Visual Studio的生成后事件会自动将目标文件（Debug版：nsQtPluginD.dll， Release版：nsPlugin.dll）拷贝到NSIS插件目录（NSIS_DIR\\Plugins\\x86-unicode）。 3.2 生成安装包VimeoSetup是一个关于如何在NSIS中使用该插件的示例工程： 12345App -- 放置需要打包到安装包中的文件VCRuntimeDLL -- 放置VC++运行时库文件（Debug版和Release版），Qt界面库默认采用MD模式编译，运行时需要依赖VC++运行时库vimeo-template.nsi -- NSIS模板文件，文件名的`-template`后缀固定的，NsisScriptGenerate.py会根据该模板生成vimeo.nsibuild-setup [debug].bat -- 生成Debug版的安装包，即使用Debug版的Qt和NSIS-UI-Pluginbuild-setup [debug].bat -- 生成Release版的安装包 将需要打包的文件放置到App目录，然后运行build-setup.bat生成安装包。 NsisScriptGenerate.py脚本功能：因为NSIS没有提供获取文件释放进度的功能，所以NsisScriptGenerate.py遍历App目录，采用File命令挨个添加文件，并调用插件接口SetInstallStepDescription通知安装详情。 四、截图仅用作示例，你可以使用任意界面库来创建任意的安装/卸载界面。","link":"/post/2584392152.html"},{"title":"NSIS教程(2)-完整属性","text":"本文列举了 NSIS 支持的所有属性，以供查阅。 描黑加粗部分的为默认值。 一、常规属性AddBrandingImage1(left|right|top|bottom) (width|height) [填充] 在安装程序顶部、底部、左边、右边添加一个标志图像。它的大小将由指定的宽/高、安装程序的宽/高和安装程序字体确定。最终的大小不一定就是你需要的，请看输出命令来得到实际大小。因为这取决于安装程序字体，所以你应该在 AddBrandingImage 前使用 SetFont。默认的填充值为 2。 AllowRootDirInstalltrue|false控制是否允许安装在驱动器根目录，或者共享网络。把它设为“true”可以改变这个安全行为，此安全行为可以防止用户选择 C:\\ 或 \\\\Server\\Share 来作为安装(或卸载)目录。对于另外的可定制的目录选择页面。 AutoCloseWindowtrue|false设置当安装完成的时候窗口是否自动关闭。该属性可以不理会一个使用了 SetAutoClose 的区段。 BGGradient[off|(顶部颜色 底部颜色 [文本颜色|notext])] 指定是否使用一个渐变的背景窗口。如果为“off”，安装程序将不显示背景窗口，如果无指定参数，则使用默认的黑蓝渐变，或者指定顶部颜色或底部颜色来得到一个渐变的背景。顶部颜色和底部颜色使用 RRGGBB 格式(十六进制，就像 HTML 那样，但略去了 #，因为 # 用于注释)。你也可以指定“文本颜色”，该颜色会显示“Name”指定的名称在左上角，或者你不需要文本时使用“notext”来关闭文本显示。 BrandingText/TRIM(LEFT|RIGHT|CENTER) 文本设置显示在安装窗口底部的文本(默认为“Nullsoft Install System vX.XX”)。如果设为空字串(“”)则使用默认值；设为” “(一个空格)则显示空白。如果你不知道哪个适合你，那就保留默认值吧，这样可以使每个人知道你使用的 NSIS 版本。使用 /TRIMLEFT、/TRIMRIGHT 或 /TRIMCENTER 来裁剪控制大小到字串大小。 Caption标题当使用一个外部的 PageEx 区块:设置安装程序标题条文本。默认为“Name 安装”，当使用了 Name 指令指定了名称时。你可以把它替换为“我的安装程序”或其他。如果你指定为空字串(“”)，则使用默认值(你也可以指定为” “来使用一个空白字串)。 当使用一个内部的 PageEx 区块:设置当前页面的子标题。 ChangeUI1对话框 ui_file.exe 使用 ui_file.exe 里相同资源 ID 的一个对话框替换对话框(IDD_LICENSE、IDD_DIR、IDD_SELCOM、IDD_INST、IDD_INSTFILES、IDD_UNINST 或 IDD_VERIFY)。你也可以指定“all”作为一个对话框，当你想从同一个 UI 文件里一次载入替换全部 7 个对话框时。一些 UI 的例子请看位于 NSIS 目录下的 Contrib\\UIs。 IDD_LICENSE 必须包含 IDC_EDIT1 (RICHEDIT 控件)。 IDD_DIR 必须包含 IDC_DIR (编辑框)，IDC_BROWSE (按钮) 和 IDC_CHECK1 (选择框)。 IDD_SELCOM 必须包含 IDC_TREE1 (SysTreeView32 control)，和 IDC_COMBO1 (组合框)。 IDD_INST 必须包含 IDC_BACK (按钮)，IDC_CHILDRECT (静态控制其他所有对话大小)，IDC_VERSTR (静态文本框)，IDOK (按钮)，和 IDCANCEL (按钮)。如果该对话框有一个图象控件(静态 SS_BITMAP 样式)，那么它将被用于 SetBrandingImage 作为默认值。 IDD_INSTFILES 必须包含 IDC_LIST1 (SysListView32 控件), IDC_PROGRESS (msctls_progress32 控件)，和 IDC_SHOWDETAILS (按钮)。 IDD_UNINST 必须包含 IDC_EDIT1 (编辑框)。 IDD_VERIFY 必须包含 IDC_STR (静态文本框)。 CheckBitmap1bitmap.bmp 指定一个位图为用于组件选择页面树形列表选择框的图像。 该位图应该为 96x16 像素大小，不能多于 8 位位深(256 色)且包括六个用于不同状态(次序为: 鼠标点击反白边缘、未选时、已选时、子区段未选时、未选且只读、已选且只读)的 16x16 图像。使用粉红色为覆盖颜色(该区域实际时为透明)。 CompletedText文本当指定了参数时替换在安装结束时的默认文本(“完成”)。否则，使用默认值。 ComponentText1[文本 [子文本] [子文本 2]] 用来更改组件选择页面的默认文本。 文本: 控件上的文本，到安装图标的右边。 子文本: 安装类型选择控件的文本。 子文本 2: 安装类型选择控件下面、组件列表左边的文本。 如果字串为空(“”)则使用默认文本。 CRCCheckon|off|force指定安装前安装程序是否对自身执行一个 CRC。注意，如果用户使用了 /NCRC 命令行参数，且你没有指定“force”参数时，不会执行 CRC，这样有可能导致用户安装一个损坏的安装程序。 DetailsButtonText1show details text 指定参数时替换默认详细信息按钮文本“显示细节”，未指定参数时使用默认值。 DirText1[文本] [子文本] [浏览按钮文本] [浏览对话框文本] 用来更改目录选择页面的默认文本。 文本: 控件上面的文本，右延至安装图标。 子文本: 在目录选择框架上的文本。 浏览按钮文本: 浏览按钮上的文本。 浏览对话框文本: 在点击“浏览”按钮后“浏览目录”对话框上的文本。 如果字串为空(“”)则使用默认文本。 DirVar1用户变量(目录输入输出) 指定用哪个变量来保存所选的目录。该变量也会保存默认值。这样可以很方便的建立两个不同的目录选择页面而不需要频繁的读取、写入 $INSTDIR。默认的变量为 $INSTDIR。它只能用于 PageEx 来确定目录变量和 uninstConfirm 页面。 DirVerifyauto|leave如果使用了“DirVerify leave”，则当安装目录无效或磁盘空间不够用时下一步按钮将会被禁止并且你可以在离开函数里使用 GetInstDirError 来读取被设置的位标计。 FileErrorText文件错误文本替换当文件不能写入时显示的默认文本。该文本可以包含一个代表文件名的 $0($0 会被临时更改为该值)。例如: “文件 $0$\\r$\\n不能写入$\\r$\\n 祝你下次好运。”。 Icon1[路径\\]图标文件.ico 设置安装程序的图标。在图标文件里的每一个图标将会被包含在图标文件里。注意如果你在安装程序和卸载程序里使用了不同的图标，那么它们的文件大小和结构必须匹配否则安装程序的构建将会失败。 InstallButtonText安装按钮文本如果指定了参数，则会把默认的“安装”按钮文本替换为你指定的文本。 InstallColors1/windows | (前景色 背景色) 设置安装信息屏幕颜色(默认为 00FF00 000000)。使用 RRGGBB 格式(十六进制，就像 HTML 那样，但略去了 #，因为 # 用于注释)。注意指定了 “/windows” 作为唯一的参数，将使用默认的 Windows 颜色。 InstallDir默认安装目录设定默认的安装目录。查看变量一段得到可用于该字串的变量(尤其是 $PROGRAMFILES)。注意该字串中最后一个 \\ 后面的部分会被保留，当用户在安装时选择“浏览”并取得新的目录字串时，该部分会自动附加在后面(要禁止该行为你需要在目录字串后面添加一个额外的 \\ ，但是你要使用引号把目录字串括起来以避免被认为是断行处理)。如果没有起作用的话，还是使用浏览按钮吧。 InstallDirRegKey根键 子键 键名该属性让安装程序去检测一注册表里的一个字串，如果该字串可用那么把它用来作为安装目录。如果预置了该属性，当指定的注册表键可用时它会越过 InstallDir 指定的字串，否则使用默认的 InstallDir 指定值。查询注册表时，该命令将自动截去引号(如“”C:\\program files\\poop” “%1””，可得“C:\\program files\\poop”)。如果该字串以“.exe”结尾，它还会自动移去字串里的文件名部分(如“C:\\program files\\poop\\poop.exe”，将得到“C:\\program files\\poop”)。对于更多高级的安装目录配置，可在 .onInit 函数里设定 $INSTDIR。[译者注: 事实上它还可以自动截取如“”C:\\program files\\poop\\poop.exe” “%1””而得到“C:\\program files\\poop”，这样你只要知道了某个程序关联的文件类型，就可以直接用它获得该程序的安装目录。比如 InstallDirRegKey HKCR “FlashGet.Document\\shell\\open\\command” “” 即可获得网际快车的安装目录] InstProgressFlags1[位标计 [...]] 有效的位标计值为“smooth”(平滑进度条)或“colored”(把进度条着色为 InstallColors 设定的颜色)。例如: “InstProgressFlags” (默认老式 Windows 外观)，”InstProgressFlags smooth” (新式平滑外观)，”InstProgressFlags smooth colored” (新式平滑外观并着色)。注意: 当安装程序运行在 Windows XP 且使用了新式主题时“smooth”或“colored”都不能与 XPStyle on 共用。 InstType1安装类型名称 | /NOCUSTOM | /CUSTOMSTRING=字串 | /COMPONENTSONLYONCUSTOM 把一个安装类型添加到安装类型列表里，或禁止自定义安装类型。最多可以增加到 32 类，每一个类型都需要指定安装类型名称。如果以“un.”作前缀那么它就是一个卸载程序安装类型。你可以使用在运行时可以处理的用户变量而不是难以改变的代码来作为安装类型名称，这样你可以动态的改变安装类型的名称。另一个在运行时更改 InstType 名称的方法是 InstTypeSetText 命令。所不同的是使用 InstTypeSetText 你可以保留你自己宝贵的用户变量。第一个类型为默认类型(通常为“常规”)。每一个类型都是以编号的，从 1 开始。查看 SectionIn 可以知道这些编号怎么使用。如果指定了 /NOCUSTOM 开关，那么“自定义”类型就会被禁止，那么用户就必须选择一个已经定义的安装类型。作为选择，如果指定了 /CUSTOMSTRING 开关，那么该开关的参数将会替代“自定义”安装类型文本。作为选择，如果指定了 /COMPONENTSONLYONCUSTOM 位标计，那么组件列表仅在选择了“自定义”安装类型的时候才显示。 LicenseBkColor颜色 | /gray | /windows设置许可协议数据的背景颜色。颜色使用 RRGGBB 格式(十六进制，就像 HTML 那样，但略去了 #，因为 # 用于注释)。默认为“/gray”。你也可以使用“/windows”来使用 Windows 操作系统定义的颜色。 LicenseData1许可文件.(txt|rtf) 指定一个用户读取许可协议的文本文件或 RTF 文件。如果没有许可协议需要显示那么可以忽略它。注意该文件必须是 DOS 文本格式(\\r\\n)。要定义多语言许可协议请使用 LicenseLangString。 如果你使用 RTF 文件来显示许可协议推荐使用写字板来编辑 RTF 文件而不是使用微软的 Word。使用写字板可以得到更小的文件。 LicenseForceSelection(checkbox [接受文本] | radiobuttons [接受文本] [拒绝文本] | off) 指定显示的许可协议是否必须被接受。可以使用单选框或互斥按钮的形式。默认情况下“下一步”按钮是禁止的并且只能在钩选了单选框选择了正确的互斥按钮后才可以进入下一步。如果指定了 off 则默认情况下“下一步：按钮是可用的。 LicenseText1[文本 [按钮文本]] 用来更改许可协议页面的默认文本。 文本: 控件上方的文本，右延至安装图标。 按钮文本: “我同意”按钮上的文本。 如果字串为空(“”)则使用默认文本。 MiscButtonText1[上一步文本 [下一步文本] [退出按钮文本] [关闭按钮文本]] 替换这四个(上一步、下一步、退出、关闭)按钮的默认文本。如果留空参数，将使用默认值代替。 Name1名称 [双与名称] 设置安装程序的名称。名称通常用来显示产品的名称比如“我的程序”或“蓝色网际的程序”。如果在名称里有一个或多个与符号(&amp;)，把第二个参数设为与第一个相同，有 &amp; 的地方使用两个 &amp; 来表示。例如你的产品名称为“foo &amp; bar2000”，那么使用: Name “foo &amp; bar2000” “foo &amp;&amp; bar2000”如果你的安装程序名称里有 &amp; 符号并且对名称使用了一个 LangString，那么你还需要创建另一个含有双 &amp; 字符的名称作为第二个参数。 OutFile1[路径\\]安装程序.exe 指定 MakeNSIS 要写入安装程序的输出文件。仅仅是 MakeNSIS 要写入的文件，它不会对安装程序的内容有任何影响。 SetFont字体名 字体大小设置安装程序字体大小。请记住你选择的字体在用户的机器上也要有，不要使用只有你自己有的字体。 ShowInstDetailshide|show|nevershow 设置是否显示安装详细信息。你可以设为“hide”来默认隐藏详细信息但用户可以查看，或“show”来默认显示详细信息，或“nevershow”来阻止用户查看任何信息。注意区段里可以使用 SetDetailsView 来越过它的设置。 ShowUninstDetailshide|show|nevershow设置是否显示卸载详细信息。你可以设为“hide”来默认隐藏详细信息但用户可以查看，或“show”来默认显示详细信息，或“nevershow”来阻止用户查看任何信息。注意区段里可以使用 SetDetailsView 来越过它的设置。 SilentInstallnormal|silent|silentlog 指定安装程序是否静默安装。如果它为“silent”或“silentlog”，所有位标计为 SF_SELECTED 的区段都会被安装而不做提示(你可以使用 SectionSetFlags 来设定区段的位标计)，安装程序本身没有任何屏幕输出(而脚本仍可以显示某些特定的输出，使用 MessageBox 的 /SD 参数来指定静默安装时默认的返回值)。注意如果设置为“normal”且用户运行时使用了 /S (区分大小写)命令行参数时就相当于 SilentInstall 设置为“silent”一样。注意: 也可以看 LogSet。 SilentUnInstallnormal|silent指定卸载程序是否静默安装。如果它为“silent”，卸载区段会被运行而不做提示，卸载程序本身没有任何屏幕输出(而脚本仍可以显示某些特定的输出，使用 MessageBox 的 /SD 参数来指定静默安装时默认的返回值)。注意如果设置为“normal”且用户运行时使用了 /S (区分大小写)命令行参数时就相当于 SilentUnInstall 设置为“silent”一样。注意: 也可以看 LogSet。 SpaceTexts1[需要空间文本 [可用空间文本]] 如果指定了参数，将会取代所需空间和可用空间文本(默认为“所需空间: ”和“可用空间: ”)。如果指定了“none”则不会显示空间提示文本。 SubCaption1[页面代号 子标题] 取代每一个安装程序页面(0=”: 许可协议”,1=”: 安装选项”,2=”: 安装目录”, 3=”: 正在安装”, 4=”: 安装完成”)的子标题。如果指定了空字串(“”)，将使用默认值(你也可以指定 “ “ 来使用一个空白字串)。 你也可以在一个 PageEx 区块内部使用 Caption 来设置一个子标题(或取代默认值)。 UninstallButtonText文本替换卸载程序上默认为“卸载”的按钮文本。如果无指定参数，将使用默认的文本。也可以看 WriteUninstaller (替换 UninstallEXEName)。 UninstallCaption标题设置卸载程序标题条上显示的文本。默认情况下，它为由 Name 命令指定的“卸载名称”。你可以取代它为“我的应用程序卸载”或其他。如果指定了空字串(“”)，将使用默认值(你也可以指定 “ “ 来使用一个空白字串)。 UninstallIcon1[路径\\]图标.ico 设置卸载程序的图标。这个图标文件必须和安装程序的图标结构一致。 UninstallSubCaption页面代号 子标题取代每一个卸载程序页面(0=”: 卸载确认”,1=”: 正在卸载”,2=”: 卸载完成”)的子标题。如果指定了空字串(“”)，将使用默认值(你也可以指定 “ “ 来使用一个空白字串)。 你也可以在一个 PageEx 区块内部使用 Caption 来设置一个子标题(或取代默认值)。 UninstallText1文本 [子文本] 指定卸载程序确认页面上的文本。 文本: 控件上方的文本 子文本: 下面卸载定位的文本 WindowIconon|off设置是否显示安装程序的图标。 XPStyleon|off设置是否把 XP 外观添加到安装程序里。当运行在 Windows XP 时一个 XP 外观使得安装程序控件使用新的 XP 样式。这个设定也会影响卸载程序。 二、编译器位标计下面的命令可以改变编译器如何去创建代码和压缩数据。这些命令在脚本的任何地方都有效，并且影响着该命令下的每一行(直道被另一个命令取代)。 AllowSkipFileson|off该命令指定用户是否可以略过文件。如果 SetOverwrite 设为 on(默认)且当安装程序打开一个文件往里边写入东西失败时一个用户可以选择略过文件。如果使用了 off 则不会显示允许用户略过文件的忽略按钮，这样用户只能选择退出安装程序(退出按钮)或重试打开该文件写入(重试按钮)。如果使用了 on 则用户可以选择跳过文件(同时置一个错误位标计 - 看 SetOverwrite)。 FileBufSize缓冲大小以 MB 为单位该命令设置编译器内部文件缓冲大小。该命令允许你通过限制一个所给的文件一次性读入内存的多少来控制编译器的内存的使用。因为编译器需要输入和输出，所以文件缓冲时需要使用两倍指定的内存大小。该命令不会限制需要另一组内存大小的压缩器缓冲，也不会限制编译器另外的内部缓冲，因为这两个缓冲正常情况下无论如何也不能达到 1MB。指定一个很小的数字可能会降低执行效率。指定过大的数字可能会耗尽系统的资源并迫使编译器退出编译处理。该默认值为 32MB。 SetCompressauto|force|off 该命令设置由安装程序使用来决定数据是否应该被压缩的压缩位标计。典型的 SetCompress 位标计将影响它后面的命令，并且脚本文件中的最后一个 SetCompress 命令也决定了是否压缩安装信息区段和卸载数据。如果压缩位标计为“auto”，那么仅当压缩后大小小于未压缩时文件才会被压缩。如果压缩位标计为“force”，则始终使用压缩。如果压缩位标计为“off”，则不使用压缩(这样可以加快编译速度)。 注意该选项当使用了固实压缩方式后无效，固实压缩方式在使用 BZIP2 和 LZMA 时默认启用。 SetCompressorzlib|bzip2|lzma该命令设置了安装程序压缩文件、数据使用的压缩算法。 支持三种压缩方式: ZLIB，BZIP2 和 LZMA。 ZLIB (默认值) 使用收缩算法，是一个快速简单的方法。默认的压缩级别它消耗大约 300 KB 内存。 BZIP2 通常比 ZLIB 的压缩率好，但是稍微慢了一点并且内存的使用也多一点。默认的压缩级别它消耗大约 4 MB 内存。 LZMA 是一个压缩率比较理想的新式压缩方式。它的解压速度非常快(在 2 GHz 的 CPU 上能达到 10-20 MB/s 的速度)，但是压缩速度很慢。解压时内存的使用量是字典的大小加上一些 KB，默认值为 8 MB。 SetCompressorDictSize字典大小以 MB 为单位设置使用 LZMA 压缩器时的字典大小(默认为 8 MB)。 SetDatablockOptimizeon|off该命令决定编译器是否优化数据区块。数据区块的优化首先由编译器检查要添加到数据区块的数据是否已经存在了，如果已存在，只需要简单的作为引用来添加(会保留一小部分大小)。非常强烈的推荐保留该选项为 on。 SetDateSaveon|off该命令设置了由 File 命令使用的保存文件日期、时间位标计来决定是否保留最后上次写入文件的日期和时间，它可以在安装时储存下来。有效的位标计为“on”和“off”。“on”为默认。 SetOverwriteon|off|try|ifnewer|ifdiff|lastused 该命令设置了由 File 命令使用的覆盖位标计来决定目标文件已存在时是否覆盖。如果覆盖位标计为“on”，则目标文件被覆盖(这个是默认值)。如果覆盖位标计为“off”,则已存在的文件不会被覆盖。如果覆盖位标计为“try”，文件仅当可以被覆盖时(就是说假如文件不能写入，它会自动略过而不需要用户决定)才会覆盖目标文件。如果覆盖位标计为“ifnewer”，则仅当已存在的文件比新文件旧时才会覆盖目标文件。如果覆盖位标计为“ifdiff”，则仅当已存在的文件比新文件旧或新时才会覆盖目标文件。注意在“ifnewer”或“ifdiff”模式下，目标文件的日期都会被设为新文件的日期，而不管 SetDateSave 是怎么设置的。 SetPluginUnloadmanual|alwaysoff 该命令设置了 CallInstDLL 和插件调用(插件名::函数)的不卸载插件位标计。 该命令设为“alwaysoff”相当于每个 CallInstDLL 和插件调用都使用了 /NOUNLOAD 参数。该命令设为“manual”则仅当你指定了 /NOUNLOAD 参数时才不卸载。 版本信息VIAddVersionKey1[/LANG=语言 ID] 键名 值 在文件属性的版本表格里添加一个字段。既可以是由系统提供的的一个字段也可以是一个用户定义的字段。随后的这些字段由系统提供: ProductName Comments CompanyName LegalCopyright FileDescription FileVersion ProductVersion InternalName LegalTrademarks OriginalFilename PrivateBuild SpecialBuild 这些字段名称由目标系统翻译，而用户自定义的字段则无翻译。 VIProductVersion1[版本字串_X.X.X.X] 在文件属性版本表格的顶部添加产品版本号。","link":"/post/1923360270.html"},{"title":"NSIS教程(3)-完整指令","text":"本文列出了 NSIS 支持的完整指令，以供查阅。 基本指令NSIS 用于脚本的这些指令稍微的近似于 PHP 和汇编。他们没有真正的高级语言结构，但是他们的指令(对于绝大部分)却是高级的，并且你可以很容易的掌握(比如你不用担心字串的连接等等)。NSIS 为你提供了 25 个寄存器(20 个常规用途，5 个特殊用途)，和一个堆栈。 Delete1[/REBOOTOK] 文件 从目标系统删除文件(可以是文件或通配符，但必须指定一个完整的路径)。如果指定了“/REBOOTOK”并且该文件当前不可删除，则会在系统重启时删除该文件 – 如果该文件要在系统重启时删除，你还要设置一个重启的位标计。如果找到的文件不能被删除则会置一个错误位标计。但该错误位标计不是从尝试删除一个不存在的文件设置的。 Exec命令执行一个指定的程序并且立即继续安装。注意指定的文件必须存在于目标系统而不是编译的系统。$OUTDIR 用于指定工作路径。如果该命令不能被运行则会置一个错误位标计。注意，如果该命令包含有空格，你要用引号来把他们包括起来。例如：Exec ‘“$INSTDIR\\command.exe” 参数’。如果你不用引号括起来则在 Windwos 9X 下不正常或丢失参数。 ExecShell1动作 命令 [参数] [SW_SHOWNORMAL | SW_SHOWMAXIMIZED | SW_SHOWMINIMIZED] 使用 Windows 的外壳关联来执行一个指定的程序。注意“动作”通常为“open”、“print”等等，也可以是一个空字串来使用默认动作。参数和显示类型是可选项。$OUTDIR 用于指定工作路径。如果该处理不能被运行则会置一个错误位标计。 ExecWait1命令 [用户变量(退出代码)] 执行一个指定的程序并且等待运行处理结束。更多信息请查看 Exec。如果没有用户输出变量 ExecWait 会置一个错误位标计当程序执行返回一个非零错误代码，或者当产生错误时。如果指定了输出变量，ExecWait 会把变量置为退出代码(并且仅当产生一个错误时置一个错误位标计；如果产生一个错误则该用户变量的内容为未指定)。注意，如果该命令包含有空格，你要用引号来把他们包括起来。例如：Exec ‘“$INSTDIR\\command.exe” 参数’。如果你不用引号括起来则在 Windwos 9X 下不正常或丢失参数。 File1[/nonfatal] [/a] ([/r] (文件|通配符) [...] | /oname=输出路径\\文件名 输入路径\\文件名) 释放文件到当前输出路径($OUTDIR). 注意输出文件名是 $OUTDIR\\文件名。 如果使用了 /oname=X 开关，则输出名变为 $OUTDIR\\X。当使用了 /oname= 开关时只能指定一个文件，且文件名可以使用变量(或完整路径如 $SYSDIR\\whatever.dll)。支持通配符。 如果使用了 /r 开关，文件和目录将会被递归添加。如果没有尾随通配符(如 File /r C:\\whatever\\mydir)，则整个 mydir 目录树将会被添加到 $OUTDIR。如果要使它放到 $OUTDIR 请使用 File /r C:\\whatever\\mydir*.*。 如果使用了 /a 开关，被添加的文件的属性将会被保护。 如果覆盖模式被设定为 “try” 并且文件未被覆盖，那么 File 命令将会置一个错误位标计，或者如果覆盖模式被设定为 “on” 并且文件未被覆盖并且用户选择了忽略，那么也会被置一个错误位标计。 如果使用了 /nonfatal 开关，当文件未找到时使用警告来代替错误。 Rename1[/REBOOTOK] 源文件 目标文件 把源文件重命名为目标文件。你可以用它来把用户系统里的任何地方的一个文件移动到用户系统里的任何地方，你也可以在一些驱动器上把一个目录移动到某些地方。目标文件必须为不存在否则移动失败(除非你使用了 /REBOOTOK)。如果指定了 /REBOOTOK，并且文件当时不能移动(比如，目标文件已存在)，则该文件在系统重启后才被移动到目标。如果文件在重启后才被移动，会置一个重启的位标计。当文件不能被重命名时(并且没有使用 /REBOOTOK)或者原文件不存在时，会置一个错误位标计。 如果没有指定绝对路径则使用当前路径代替。当前路径可以使用 SetOutPath 指令来设置。如果你没有使用 SetOutPath 那么当前路径为 $EXEDIR。 ReserveFile1[/nonfatal] [/r] 文件 [文件...] 保存一个文件在最后使用的数据区块。之所以要把在脚本中使用到的文件，这样添加是因为要在 .onInit 函数里使用，例如使得安装程序载入变慢。这时候这个命令就非常有用了，它可以把文件包含在数据区块的顶端而不是让 NSIS 从已压缩的数据区块从头搜到脚来找这个文件，这样可以加快安装程序载入速度。 相关参数说明请查看 File。 RMDir1[/r|/REBOOTOK] 目录名 删除指定的目录(完整的路径)。没有 /r 参数时只有在目录为空时才会被删除。如果指定了 /r，则目录会被递归删除，所以在指定目录下的所有文件和目录均被删除。如果指定了 /REBOOTOK，并且目录不能被覆盖，则当系统重启的时候会被删除 —— 如果目录需要在重启时被删除，会设一个重启的位标计。当目录不能被删除时会置一个错误的位标计。 SetOutPath输出路径设置输出路径($OUTDIR)且当路径不存在时创建(需要时递归)。必须为全路径名，通常使用 $INSTDIR。 注册表、INI 文件指令在下面所有的注册表指令里使用一个空字串(“”)来作为某个子健默认项，该默认项在注册表编辑器里显示为“(默认)”。 DeleteINISec1INI_文件名 区段名 从“INI_文件名”里删除整个区段 [区段名]。如果该区段不能被删除，会置一个错误的位标计。但是如果该区段找不到时则不会置错误位标计。 DeleteINIStr1INI_文件名 区段名 字串名 从“INI_文件名”里的 [区段名] 区段删除“字串名”字串。如果该字串不能被删除，会置一个错误的位标计。但是如果该字串找不到时则不会置错误位标计。 DeleteRegKey1[/ifempty] 根键 子键 删除一个注册表键。如果指定了 /ifempty，则该注册表键仅当它无子键时才会被删除(否则，整个注册表键将被删除)。有效的根键值在后面的 WriteRegStr 列出。如果该键不能被删除(或如果它不存在)则会置一个错误的位标计。 DeleteRegValue1根键 子键 键名 删除一个注册表键值。有效的根键值在后面的 WriteRegStr 列出。如果该键值不能被删除(或如果它不存在)则会置一个错误的位标计。 EnumRegKey1用户变量(输出) 根键 子键 索引 把用户变量 $x 设为“根键\\子键”第“索引”号注册表键名。有效的根键值在后面的 WriteRegStr 列出。当指定的“根键\\子键”没有任何键时会返回一个空字串，当产生一个错误时会返回空字串并置一个错误位标计。 EnumRegValue1用户变量(输出) 根键 子键 索引 把用户变量 $x 设为“根键\\子键”第“索引”号注册表键值。有效的根键值在后面的 WriteRegStr 列出。当指定的“根键\\子键”没有任何键值时会返回一个空字串，当产生一个错误时会返回空字串并置一个错误位标计。 ExpandEnvStrings1用户变量(输出) 字串 把“字串”里的环境变量扩展到用户变量 $x。如果错误，该变量会被设为空值并置一个错误位标计。 FlushINI1INI_文件名 刷新 INI 文件缓冲。Windows 9x 会保持 INI 文件在内存里。该命令强制更改立即写入磁盘。当你自己编辑一个 INI 文件的时候可以使用它，删除、移动、复制，直到你使用 WriteINIStr、DeleteINISec 或 DeleteINStr 来更改它。 ReadEnvStr1用户变量(输出) 名称 从环境字串“名称”读取值并把值赋给用户变量 $x。如果读取字串时有错误发生，该用户变量被设为空，并置一个错误位标计。 ReadINIStr1用户变量(输出) INI_文件名 区段名 项名 从“INI_文件名”的 [区段名] 区段读取“项名”的值并把该值赋给用户变量 $x。如果该项未找到时会置一个错误位标计且该用户变量被赋为空值。 ReadRegDWORD1用户变量(输出) 根键 子键 项 从注册表读取一个 32 位 DWORD 到用户变量 $x。有效的根键值在后面的 WriteRegStr 列出。如果 DWORD 不存在时会置一个错误位标计并把 $x 设为空字串。如果该值存在但不是 DWORD，则会作为字串类型读取并置一个错误位标计。 ReadRegStr1用户变量(输出) 根键 子键 项 从注册表读取一个字串值到用户变量 $x。有效的根键值在后面的 WriteRegStr 列出。如果字串不存在时会置一个错误位标计并把 $x 设为空字串。如果该值存在但是 DWORD，则会转换为字串类型并置一个错误位标计。 WriteINIStr1INI_文件名 区段名 项名 值 把“项名”=“值”写入“INI_文件名”的 [区段名] 区段。如果 INI 文件不能写入则置一个错误的位标计。 WriteRegBin1根键 子键 项 值数据 该命令将会写一个区块的二进制数据到注册表。有效的根键值在后面的 WriteRegStr 列出。值数据为十六进制格式(如 DEADBEEF01223211151)。如果该二进制数据不能写入注册表则置一个错误的位标计。如果注册表键不存在则会自动创建。“值数据”不能使用变量。 WriteRegDWORD1根键 子键 项 值 该命令写一个 DWORD(32 位整数)到注册表(可以使用变量)。有效的根键值在后面的 WriteRegStr 列出。如果该 DWORD 不能写入注册表则置一个错误的位标计。如果注册表键不存在则会自动创建。 4.9.2.16 WriteRegStr 1根键 子键 项 值 把字串写入注册表。详细信息请查看 WriteRegExpandStr。 4.9.2.17 WriteRegExpandStr 1根键 子键 项 值 把字串写入注册表。根键必须为下面列表之一: HKCR 或 HKEY_CLASSES_ROOT HKLM 或 HKEY_LOCAL_MACHINE HKCU 或 HKEY_CURRENT_USER HKU 或 HKEY_USERS HKCC 或 HKEY_CURRENT_CONFIG HKDD 或 HKEY_DYN_DATA HKPD 或 HKEY_PERFORMANCE_DATA 如果字串不能写入注册表则置一个错误的位标计。字串的类型为 REG_SZ 对应 WriteRegStr，或 REG_EXPAND_STR 对应 WriteRegExpandStr。如果注册表键不存在则会自动创建。 常规用途指令CallInstDLL1DLL_文件 [/NOUNLOAD] 函数名 从一个 NSIS 扩展动态链接库里调用一个函数名。看 Contrib\\ExDLL 的样本可以知道如何来创建。扩展动态链接库可以访问堆栈和变量。使用 /NOUNLOAD 来强制安装程序保持动态链接库载入。注意: 要自动释放并调用 DLL 插件请使用插件命令来替换 CallInstDLL。 CopyFiles1[/SILENT] [/FILESONLY] 目标系统文件规范 目标路径 [文件大小_单位为_kb] 在正在安装的系统中把“目标系统文件规范”复制到“目标路径”。 如果你想从安装媒体里复制，或从系统的一个地方复制到另一个地方，你可以使用 $EXEDIR 变量来代替安装程序目录。如果复制操作需要很长时间的话你可以看到 Windows 的复制文件窗口(要禁止出现复制文件窗口使用/SILENT)。最后的参数用来指定要复制的文件的大小(单位为 kb)，使安装程序可以估计所需磁盘空间。在出错，或用户退出(仅当忽略了 /SILENT 时)时，会置一个错误位标计。如果指定了 /FILESONLY 则仅复制文件。 如果没有指定绝对路径则使用当前路径代替。当前路径为最后一个 SetOutPath 指定的路径。如果没有使用任何 SetOutPath 指令则当前路径为 $EXEDIR。 CreateDirectory要创建的路径创建(必要时递归)指定的目录。当目录不能创建时是一个错误位标计。 你也可以指定一个绝对路径。 CreateShortCut1快捷文件.lnk 目标文件 [参数 [图标文件 [图标索引号 [启动选项 [键盘快捷键 [描述]]]]]] 创建一个指向“目标文件”的快捷方式“快捷文件.lnk”，可以带“参数”参数。 用于快捷方式的图标为“图标文件,图标索引号”；要使用默认图标的话把“图标文件”和“图标索引号”设为空字串。 “启动选项”可以是它们之一: SW_SHOWNORMAL, SW_SHOWMAXIMIZED, SW_SHOWMINIMIZED, 或一个空字串。 “键盘快捷键”应该为“flag|c”格式且 flag 可以联合使用(使用 |): ALT, CONTROL, EXT, 或 SHIFT。c 为要使用的字符(a-z, A-Z, 0-9, F1-F24 等等)。注意在这些字串里不能含有空格。一个典型的例子为 “ALT|CONTROL|F8”。$OUTDIR 被用来作为工作目录。你可以在创建快捷方式之前使用 SetOutPath 来指定或更改。“描述”为快捷方式的描述，或在 XP 下作为注释调用。 当快捷方式不能创建的时候会置一个错误位标计(例如路径不存在或一些其它错误)。 GetDLLVersion1文件名 用户变量(高位_DWORD_输出) 用户变量(低位_DWORD_输出) 从“文件名” DLL(或其他包含版本信息的可执行文件)取得版本信息。成功时把版本信息高位 DWORD 和低位 DWORD 设为用户输出变量；失败时输出为空且置错误位标计。下面的例子演示了读取一个 DLL 版本并可读的版本到 $0: 123456GetDllVersion \"$INSTDIR\\MyDLL.dll\" $R0 $R1IntOp $R2 $R0 / 0x00010000IntOp $R3 $R0 &amp; 0x0000FFFFIntOp $R4 $R1 / 0x00010000IntOp $R5 $R1 &amp; 0x0000FFFFStrCpy $0 \"$R2.$R3.$R4.$R5\" GetDLLVersionLocal1内部文件 用户变量(高位_DWORD_输出) 用户变量(低位_DWORD_输出) 类似于 GetDLLVersion，但它仅用于获取安装程序内部文件的信息(它实际上编译为两个 StrCpy 命令)。成功时把内部文件的版本信息高位 DWORD 和低位 DWORD 设为用户输出变量。 GetFileTime1文件名 用户变量(高位_DWORD_输出) 用户变量(低位_DWORD_输出) 获取“文件名”的最后写入时间。成功时把时间戳信息高位 DWORD 和低位 DWORD 输出到用户输出变量;失败时输出为空且置一个错误位标计。 GetFileTimeLocal1内部文件 用户变量(高位_DWORD_输出) 用户变量(低位_DWORD_输出) 类似于 GetFileTime，但它仅用于获取安装程序内部文件的信息(它实际上编译为两个 StrCpy 命令)。 GetFullPathName1[/SHORT] 用户变量(输出) 路经或文件 把指定的文件完整路径信息输出到用户变量 $x。如果参数的部分路径未找到，则置一个错误位标记并清空 $x。如果指定了 /SHORT，路经将会被转换为短文件名格式。 GetTempFileName1用户变量(输出) [基本路径] 把一个临时文件的名称输出到用户变量 $x。该文件会自动创建，所以你可以随时的覆盖它。该临时文件的名称唯一。如果你希望这个临时文件创建在另一个目录而不是 Windows 临时目录的话指定一个“基本路径”给它。你需要在完成之后手动删除它。 SearchPath1用户变量(输出) 文件名 由第二个参数指定的文件名的全路径输出到用户变量 $x。如果该文件不存在则会置一个错误位标记并清空 $x。使用 SearchPath() 来在系统目录里搜索文件。 SetFileAttributes1文件名 属性 1|属性 2|... 设置“文件名”的属性。多从属性可用 | 隔开，有效的属性为: NORMAL 或 FILE_ATTRIBUTE_NORMAL (你可以把该项缩写为 0) ARCHIVE 或 FILE_ATTRIBUTE_ARCHIVE HIDDEN 或 FILE_ATTRIBUTE_HIDDEN OFFLINE 或 FILE_ATTRIBUTE_OFFLINE READONLY 或 FILE_ATTRIBUTE_READONLY SYSTEM 或 FILE_ATTRIBUTE_SYSTEM TEMPORARY 或 FILE_ATTRIBUTE_TEMPORARY 如果文件的属性不能被设置则置一个错误的位标计(例如文件不存在，或者你没有足够的权限)。你只能进行属性设置，而不能移除属性，如果你想移除的话请使用 NORMAL。这样所有的属性都会被擦除，该命令不支持通配符。 RegDLL1DLL_文件 [入口点名称] 载入指定的 DLL 并且调用 DllRegisterServer (或入口点名称，当指定之后)。当产生一个错误的时候会置一个错误位标计(例如不能载入 DLL，不能初始化 OLE，不能找到入口点，或者函数返回任何其它错误 ERROR_SUCCESS (=0))。 当某些要注册的 DLL 要依靠其它的位于同目录或 Windows 目录下的 DLL 时请用 SetOutPath 来设定当前目录。例如，如果 foo.dll 依靠位于 $INSTDIR 的 bar.dll 时: 12SetOutPath $INSTDIRRegDLL $INSTDIR\\foo.dll UnRegDLL1DLL_文件 载入指定的 DLL 并且调用 DllUnregisterServer。当产生一个错误的时候会置一个错误位标计(例如不能载入 DLL，不能初始化 OLE，不能找到入口点，或者函数返回任何其它错误 ERROR_SUCCESS (=0))。 流程控制指令Abort1[用户信息] 取消安装，停止执行脚本，并且在状态显示里显示用户信息。注意: 你可以用于回调函数来实现一些特殊功能。页面回调也可以用 Abort 来实现特殊目的。 Call1函数名 | :标记名 调用“函数名”函数。如果在 Uninstall 区段，Call 仅能调用以“un.”开头的函数名。如果参数以一个“:”开始则它竟会被认为是一个标记(所以你可以在你的函数里调用一个标记 - 这样大概不会使用太多的时间)。 ClearErrors清除错误位标记。 GetCurrentAddress1用户变量(输出) 获取当前指令的地址(GetCurrentAddress)并且把它保存到用户输出变量。该用户变量可以传递到 Call 或 Goto。 GetFunctionAddress1用户变量(输出) 函数名 获取函数地址并且把它保存到用户输出变量。该用户变量可以传递到 Call 或 Goto。注意如果你 Goto 一个由 GetFunctionAddress 输出的地址，你的函数将不能返回(当你 Goto 的函数要返回时，你应该立即返回)。 GetLabelAddress1用户变量(输出) 标记 获取标记地址并且把它保存到用户输出变量。该用户变量可以传递到 Call 或 Goto。需要注意的是你可能仅能从你的函数里随标记调用该指令，但是你可以从任何地方调用它(可能存在不稳定因素)。需要注意的是如果你调用(Call)了 GetLabelAddress 的输出，那么直到它返回时才会被执行(明确或隐含在一个函数的结尾)，然后你将回到 Call 指令的状态。. Goto1要跳转的标记 | +偏移| -偏移| 用户变量(目标) 如果指定了标记，则跳转到“要跳转的标记:”。 如果指定了 +偏移 或 -偏移 ，跳转会根据偏移指令相对的跳转。Goto +1 跳转到下一条指令，Goto -1 跳转到上一条指令，等等。 如果指定了用户变量，则跳转到绝对地址(通常你可以从一个函数比如 GetLabelAddress 来取得该值)。编译器位标计命令和 SectionIn 不是指令所以跳转对它们无效。 IfAbort1退出时要跳转的标记 [不是退出时要跳转的标记] 如果调用退出时它将“返回” true。这种情况可能发生在当一个文件不能创建(或覆盖)失败而用户选择退出时或者当用户手动退出时。该函数仅能在 instfiles 页面的离开函数里调用。 IfErrors1错误时跳转 [没有错误时跳转] 检测并清除错误位标计，如果设了错误位标计，则跳转到“错误时跳转”，否则跳转到“没有错误时跳转”。错误位标计由其它指令在产生一个错误是设置的(比如试图去删除一个正在使用的文件)。 IfFileExists1要检测的文件 文件存在时跳转 [文件不存在时跳转] 检测“要检测的文件”是否存在(可以用通配符，或目录)，并当文件存在时跳转到“文件存在时跳转”，否则跳转到“文件不存在时跳转”。如果你要检测目标是文件还是目录请使用 IfFileExists 目录*.* IfRebootFlag1[已设时跳转] [未设时跳转] 至少需要一个参数。检测重启位标计，如果设置了重启位标计则跳转到“已设时跳转”，否则跳转到“未设时跳转”。重启位标计可以在 Delete 河 Rename，或手动设定的 SetRebootFlag 指令里设置。 IfSilent1[静默安装时跳转] [非静默安装时跳转] 至少需要一个参数。检测静默安装位标计，如果安装程序是静默安装时跳转到“静默安装时跳转”，否则跳转到“非静默安装时跳转”。静默安装位标计可以由 SilentInstall、SilentUninstall、SetSilent 和用户使用 /S 命令行启动来设置。 IntCmp值 1 值 2 相等时跳转 [值 1 小时跳转] [值 1 大时跳转]比较两个整数 值 1 和 值 2。如果 值 1 和 值 2 相等，则跳转到“相等时跳转”，否则如果 值 1 &lt; 值 2，跳转到“值 1 小时跳转”，否则如果 值 1 &gt; 值 2 ，跳转到“值 1 大时跳转”。 IntCmpU1值1 值2 相等时跳转 [值1小时跳转] [值1大时跳转] 比较两个无符号整数 值 1 和 值 2。如果 值 1 和 值 2 相等，则跳转到“相等时跳转”，否则如果 值 1 &lt; 值 2，跳转到“值 1 小时跳转”，否则如果 值 1 &gt; 值 2 ，跳转到“值 1 大时跳转”。比较时作为无符号整数来比较。 MessageBox1消息框选项列表 消息框文本 [/SD 返回] [检测返回值 跳转到] [检测返回值 2 跳转到 2] 显示一个包含“消息框文本”的消息框。“消息框选项列表”必须为下面的一个或多个，多个使用 | 来隔开(例如 MB_YESNO|MB_ICONSTOP)。 MB_OK - 显示 OK 按钮 MB_OKCANCEL - 显示 OK 和取消按钮 MB_ABORTRETRYIGNORE - 显示退出、重试、忽略按钮 MB_RETRYCANCEL - 显示重试和取消按钮 MB_YESNO - 显示是和否按钮 MB_YESNOCANCEL - 显示是、否、取消按钮 MB_ICONEXCLAMATION - 显示惊叹号图标 MB_ICONINFORMATION - 显示信息图标 MB_ICONQUESTION - 显示问号图标 MB_ICONSTOP - 显示终止图标 MB_TOPMOST - 使消息框在最前端显示 MB_SETFOREGROUND - 设置前景 MB_RIGHT - 右对齐文本 MB_DEFBUTTON1 - 默认为按钮 1 MB_DEFBUTTON2 - 默认为按钮 2 MB_DEFBUTTON3 - 默认为按钮 3 MB_DEFBUTTON4 - 默认为按钮 4 “检测返回值”可以为 0(或空，或保留关闭)，或下列之一: IDABORT - 退出按钮 IDCANCEL - 取消按钮 IDIGNORE - 忽略按钮 IDNO - 否按钮 IDOK - OK 按钮 IDRETRY - 重试按钮 IDYES - 是按钮 如果消息框的返回值为“检测返回值”，则安装程序执行跳转。 用 /SD 来指定一个上面列出的返回值当在安装程序静默安装时作为返回值。 Return从一个函数或区段返回。 Quit使得安装程序立即退出。在调用 Quit 后，安装程序将退出(将没有回调函数可以运行)。 SetErrors设置错误位标计。 StrCmp1字串1 字串2相同时跳转 [不相同时跳转] 比较(不区分大小写)“字串 1”和“字串 2”。如果两者相等，跳转到“相同时跳转”，否则跳转到“不相同时跳转”。 文件指令FileClose句柄关闭一个由 FileOpen 打开的文件句柄。 FileOpen1用户变量(句柄输出) 文件名 打开模式 打开一个“文件名”的文件，并且把句柄设置为句柄输出变量。“打开模式”为“r”(只读)“w”(写入，文件的所有内容将被清空)或“a”(附加，保持文件内容并写入)其中之一。在所有的打开模式里，文件指针都置于文件起始位置。如果文件不能被打开，则句柄输出变量为空，并置一个错误位标计。 如果没有指定绝对路径则使用当前路径。当前路径由 SetOutPath 设置。如果之前没有使用 SetOutPath 则当前路径为 $EXEDIR。 FileRead1句柄 用户变量(输出) [最大长度] 读取一个由 FileOpen 打开的文件的字串。该字串一直读取到新的一行为止(或回车新行)。或直到读取到空的字节为止，或者直到读取的字串满足了“最大长度”(如果指定了的话)。字串的最大长度被限定在 1024 字节之内。如果读取到了文件的结尾却没有有效的数据则输出字串被清空，并置一个错误位标计。 FileReadByte1句柄 用户变量(输出) 读取一个由 FileOpen 打开的文件的字节。读取的字节作为一个整数(0-255)保存在输出变量里。如果读取到了文件的结尾却没有有效的数据则输出字串被清空，并置一个错误位标计。 FileSeek1句柄 偏移 [模式] [用户变量(新位置)] 定位一个由 FileOpen 打开的文件。 如果“模式”忽略或指定为“SET”，则文件指针定位到“偏移”。 如果“模式”指定为“CUR”，则文件指针向后移动“偏移”。 如果文件指定为“END”，则指针定位到相对于文件结尾 EOF(End of file)处。 如果指定了最后一个参数“用户变量(新位置)”，则新文件位置将保存在该变量中。 FileWrite1句柄 字串 写入一个字串到 FileOpen 打开的文件。如果写入时产生了错误，则置一个错误位标计。 FileWriteByte1句柄 字串 写入“字串”解释为整数的值到 FileOpen 打开的文件。当然你也可以直接输入整数值。下面的代码写入一个“回车/换行” - 输入到文件。 12FileWriteByte 文件句柄 \"13\"FileWriteByte 文件句柄 \"10\" 如果写入时产生了错误，则置一个错误位标计。需要注意的是整数仅低字节被使用，例如: 写入 256 和写入 0 一样，等等。 FindClose1句柄 关闭一个由 FindFirst 打开的搜索。 FindFirst1用户变量(句柄输出) 用户变量(文件输出) 文件匹配格式 按“文件匹配格式”执行一个搜索，把第一个查找到的文件放置到“用户变量(文件输出)”。也可以把搜索的句柄放到“用户变量(句柄输出)”。如果未找到任何文件，则输出都被设为空，并且置一个错误位标计。比较好的用法是使用 FindNext 和 FindClose。需要注意的是“用户变量(文件输出)”不带有路径。 FindNext1句柄 用户变量(文件输出) 继续一个由 FindFirst 开始的搜索。句柄应该为 FindFirst 返回的值。如果搜索已完成(没有更多文件)，“用户变量(文件输出)”将被设为空，并且置一个错误位标计。需要注意的是“用户变量(文件输出)”不带有路径。 卸载程序指令WriteUninstaller1[路径\\]可执行文件名.exe 由指定的文件名(路径为可选项)写入卸载程序。仅在一个安装区段或函数里有效，并且你的脚本里必须有一个卸载区段。也可以参考卸载配置。你可以调用一次或多次来写入一个或多个卸载程序(副本)。 混合指令GetInstDirError1用户变量(错误输出) 用于目录选择页面的离开函数。读取位标计设置看“DirVerify leave”是否已使用。可能的值: 0: 无错误 1: 无效的安装目录 2: 目标驱动器没有足够的空间 InitPluginsDir初始化插件目录($PLUGINSDIR)，当之前没有初始化时。 SetShellVarContextcurrent|all 设置 $SMPROGRAMS 的内容或其他命令解释程序目录。如果设为“current”(默认值)，则使用当前用户的命令解释程序目录。如果设为“all”，则使用所有用户的命令解释程序目录。所有用户目录可能不能被所有的操作系统支持。如果所有用户的目录找不到则使用当前用户代替。请考虑一个普通用户或游客是否有正确的权限在所有用户目录里操作。仅仅管理员才有完全的权限访问所有用户目录。你可以用 UserInfo 来查看用户身份。详细信息请查看 Contrib\\UserInfo\\UserInfo.nsi 样例。 Sleep休眠时间单位为毫秒在安装程序里暂停执行“休眠时间单位为毫秒”时间。“休眠时间单位为毫秒”可以是一个变量，例如 “$0”或一个数字，比如 “666”。 字串操作指令StrCpy1用户变量(目标) 字串 [最大长度] [起始偏移] 把用户变量 $x 设为“字串”。注意“字串”可以包含另一个变量，或该用户变量会被设置(可以用来连接字串等等)。如果指定了“最大长度”则目标字串的长度为“最大长度”(如果“最大长度”是负数，则会从字串尾部截去“最大长度”的绝对值个字符)。如果指定了起始偏移，则字串偏移到该处作为起始(如果“起始偏移”是负数，则会从尾部开始偏移)。 StrLen1用户变量(长度输出) 字串 把用户变量 $x 设为“字串”的长度值。 堆栈支持Exch1[用户变量 | 堆栈索引] 当不指定参数时，交换堆栈顶部的两个单元。当指定了一个参数并且是一个用户变量时，交换堆栈顶部的单元和该参数。当指定了一个参数并且是正整数时，Exch 将会交换堆栈顶部那项和根据参数从堆栈顶部偏移到指定的那项。如果堆栈里没有足够的项来完成交换时，会产生一个致命的错误(来帮助你调试你的代码)。 Pop1用户变量(输出) 从堆栈里弹出一个字串到用户变量 $x。如果堆栈是空的，则会置一个错误位标计。 Push1字串 把一个字串压入堆栈。该字串可随后从堆栈里弹出。 整数支持IntFmt1用户变量(输出) 格式 数字字串 用“格式”格式格式化“数字字串”中的数字，并把输出设为用户变量 $x。例如格式化字串包含 “%08X” “%u” IntOp1用户变量(输出) 值1 操作 [值2] 联合值 1 和(取决于操作)值 2 到用户变量 $x。操作定义为下列之一: + 值 1 加 值 2 - 值 1 减 值 2 *值 1 乘 值 2 / 值 1 除 值 2 % 由 值 2 取 值 1 的模 | 值 1 和 值 2 二进制“或” &amp; 值 1 和 值 2 二进制“与” ^ 值 1 和 值 2 二进制“异或” ~ 按位取反 值 1(例如 7 变为 4294917288) ! 逻辑取反 值 1(例如 7 变为 0) || 值 1 和 值 2 逻辑“或” &amp;&amp; 值 1 和 值 2 逻辑“与” 重启指令Reboot重启电脑。请小心使用该指令。如果重启时产生了错误，该函数会置一个错误位标计并继续。如果重启成功，该指令不返回任何值。 SetRebootFlagtrue|false设置重启位标计为“true”或“false”。 安装记录指令LogSeton|off设置安装记录到 $INSTDIR\\install.log 将会发生。 在你调用该函数之前， $INSTDIR 必须有一个值，否则该指令将无效。需要注意的是在编译的时候编译配置文件(config.h)必须设置 NSIS_CONFIG_LOG (默认未设置)来支持该指令。关于重新编译 NSIS 的详细信息请查看 编译 NSIS 源代码。 LogText文本如果启用了安装程序记录，插入“文本”文本到记录文件。 区段管理SectionSetFlags1区段索引 区段位标计 设置区段位标计。位标计为 32 位整数。第一位(低位)代表该区段当前是否选中，第二位代表该区段是否是一个子区段(请不要修改这里除非你真的很了解)，第三位代表该区段是否是一个子区段的结尾(同样，请不要修改)，第四位代表该区段文字是否描黑显示，第五位代表该区段是否是只读，第六位代表子区段是否自动展开。如果指定了超出范围的区段则会置一个错误的位标计。 SectionGetFlags1区段索引 用户变量(输出) 找回该区段的位标计。位标计的描述请看上面。如果指定了超出范围的区段则会置一个错误的位标计。 SectionSetText1区段索引 区段文本 设置“区段索引”区段的描述。要设置一个子区段的文本，你必须在文本前加 -。如果文本设为 “”则该区段将会隐藏。如果指定了超出范围的区段则会置一个错误的位标计。 SectionGetText1区段索引 区段文本 把“区段索引”区段的描述保存在输出变量。如果区段为隐藏，则保存的变量为空。如果指定了超出范围的区段则会置一个错误的位标计。 SectionSetInstTypes1区段索引 安装类型 设置“区段索引”区段在安装类型中的默认启用状态。需要注意的是区段索引从零开始。“安装类型”的每一位都是一个告诉该区段是否属于这个安装类型的位标计。例如，如果你有 3 个安装类型并且你希望第一个区段包含在类型 1 和 3，则命令如下: 1SectionSetInstTypes 0 5 因为 5 的二进制值为 “00000101”。 如果指定了超出范围的区段则会置一个错误的位标计。 SectionGetInstTypes1区段索引 用户变量(输出) 找回一个区段的安装类型位标计。如果处理输出的描述请看上面的关于 SectionSetInstTypes 的解释。如果指定了超出范围的区段则会置一个错误的位标计。 SectionSetSize区段索引 新容量设置“区段索引”区段的容量。需要注意的是索引从零开始。容量的单位为 KB 且仅支持整数。 SectionGetSize区段索引 用户变量获得“区段索引”区段的容量并把值保存在指定的用户变量里。需要注意的是索引从零开始。 SetCurInstType安装类型索引设置当前安装类型。如果使用了一个超出范围的安装类型则不会置一个错误位标计。 SetCurInstType 仅在当前存在组件选择页面时才有效。 GetCurInstType用户变量获取当前的安装类型并保存在指定的用户变量里。${NSIS_MAX_INST_TYPES} (默认为 32)的值意味着选择了自定义安装类型。 InstTypeSetText1安装类型索引 文本 设置指定的安装类型的文本。如果设置的文本为空则移除该安装类型。通过使用一个以前未使用的“安装类型索引”序号你可以创建一个新的安装类型。要在新的安装类型里添加、删除区段请看 SectionSetInstTypes。与 SectionIn 不同的是该索引从零开始，这意味着第一个安装类型索引为 0。 InstTypeGetText1安装类型索引 用户变量 获取指定的安装类型的文本。 用户界面指令BringToFront使安装程序窗口可见并把它带到其他窗口的最前端。如果一个应用程序已经执行且显示在安装程序的前面，BringToFront 将把安装程序带回到焦点。 CreateFont1用户变量(句柄输出) 字体名 [高] [宽] [/ITALIC] [/UNDERLINE] [/STRIKE] 创建一个字体并把句柄保存在用户变量里。关于不同参数的更多信息请看 MSDN 页面关于 Win32 API 函数 CreateFont()。 DetailPrint用户信息添加“用户信息”字串到安装程序的安装信息查看窗口。 EnableWindow1窗口句柄(HWND) (1|0) 对指定的窗口或控件允许或禁止鼠标和键盘输入。可用的状态为 0(禁止) 或 1(允许)。 FindWindow1用户变量(窗口句柄输出) 窗口类 [窗口标题] [windowparent] [childafter] 查找一个窗口。类似于 Win32 FindWindowEx()。由窗口类来查找(和/或窗口标题，如果指定的话)。如果指定了 windowparent 或 childafter，则查找会受到限制。如果窗口类或窗口标题指定为 “”，则它们将不能用于查找。如果窗口未找到，用户变量将返回 0 值。要实现旧式 FindWindow 行为，请和 SendMessage 一起使用。 GetDlgItem1用户变量(输出) 窗口句柄 控件ID 在指定的对话框上根据控件 ID 获得控件句柄。如果你想获得安装程序内部的控件句柄，请先使用 FindWindow 用户变量(窗口句柄输出) \"#32770\" \"\" $HWNDPARENT 来获取窗口句柄。 HideWindow隐藏安装程序。 IsWindow1窗口句柄 是窗口时跳转 [不是窗口时跳转] 如果“窗口句柄”是一个窗口，则跳转到“是窗口时跳转”，否则跳转到“不是窗口时跳转”(如果指定了的话)。 SendMessage1窗口句柄 消息 第一个消息参数 第二个消息参数 [用户变量(返回值)] [/TIMEOUT=毫秒] 发送消息到“窗口句柄”。如果指定了一个用户变量 $x 作为最后一个参数(或在 /TIMEOUT 之前的最后一个参数)，SendMessage 的返回值将保存在该变量里。需要注意的是当指定“消息”时你只能用消息的整数值。如果你需要发送字串请使用“STR:字串”作为“第一个消息参数”或“第二个消息参数”。 WM_CLOSE 16 WM_COMMAND 273 WM_USER 1024 Include WinMessages.nsh 来获得所有 Windows 消息定义。 要发送一个字串参数的话，在参数前面加入 STR: ，例如: “STR:一些字串” 。 使用 /TIMEOUT=毫秒 来指定持续时间，单位为毫秒。 SetAutoClose1true|false 取代默认的窗口自动关闭位标计(由 AutoCloseWindow 指定，且对于写在程序为 false)。指定“true”将使得安装程序在安装完成时立即关闭窗口，或者“false”来使它需要手动关闭。 SetBrandingImage1[/IMGID=对话里的 ID 项] [/RESIZETOFIT] 位图.bmp 把当前位图作为标志图像显示。如果没有指定 IMGID 则使用第一个找到的图像控件，或由 AddBrandingImage 建立的图像控件。需要注意的是位图必须预先存在于当前用户的机器上。可以先使用 File 指令把它释放。如果指定了 /RESIZETOFIT 则图像会自动改变尺寸到图像控件的大小。如果你使用了 AddBrandingImage 你可以得到它的大小，通过编译你的脚本并察看 AddBrandingImage 的输出，它会告诉你控件的大小。SetBrandingImage 在 .onInit 或 .onInit 调用的函数里无效。 SetDetailsView1show|hide 显示或隐藏详细信息，取决于你使用什么样的参数。它可以覆盖默认的由 ShowInstDetails 设定的详细信息察看属性。 SetDetailsPrint1none|listonly|textonly|both|lastused 为命令输出的状态信息设置一个显示模式。None 为不输出，listonly 仅在列表框显示，textonly 仅在状态条显示，both 则两者都显示(默认)。对于释放很多小的文件，推荐使用 textonly(特别在 Win9X 下启用了平滑卷动)。 SetCtlColors1句柄 [/BRANDING] [文本颜色] [transparent|背景颜色] 对一个静态控件、编辑控件、按钮或一个对话框设置一个背景颜色和文本颜色。使用 GetDlgItem 来获取控件的句柄。如果要使得控件透明你可以指定“transparent”作为背景颜色值。你也可以指定 /BRANDING 并带或不带文本颜色和背景颜色来使得控件完全灰白(或其他你选择的颜色)。在 MUI 里用来显示标志牌。 SetSilent1silent | normal 设置安装程序为静默模式或普通模式。关于静默安装的详细信息请看 SilentInstall。仅能在 .onInit 里使用。 ShowWindow1窗口句柄 显示状态 设置一个窗口的显示程度。可能的“显示状态”和 Windows ShowWindow 函数相同。SW_* 常量定义于 Include\\WinMessages.nsh。 多语言指令LoadLanguageFile1语言文件.nlf 给一个语言表的结构载入一个语言文件。所有的语言文件在 Contrib\\Language Files 在你插入一个语言文件后 ${LANG_langfile} 将会被定义为语言 ID(例如: ${LANG_ENGLISH} 将会被定义为 1033)。你可以把它用于 LangString、LicenseLangString、LangDLL 和 VIAddVersionKey。 LangString1名称 语言ID 字串 定义一个使用多种语言的字串。这意味着它的值将对于每个语言都不同。这允许你方便的使安装程序多语言化，不需要再脚本里使用大量的开关语句。 每一个语言字串都有一个特定的名字和一个用于安装程序的分配给每一个语言的值。他们可以在脚本里用于任何运行时字串。要使用一个语言字串你所需要做的就是把 $(LangString_名称) 插入到你想插入字串的地方。 注意: 不像定义使用花括号 - {} 一样，语言字串使用圆括号 - ()。 如果你想在 .onInit 函数里更改语言，需要注意的是在 .onInit 里的语言字串将仍旧使用基于用户的默认 Windows 语言检测到的语言，因为语言的初始化在 .onInit 之后。 总是在你的脚本里为所有语言设置语言字串。 如果你把语言 ID 设为 0，则使用 LangString 或 LoadLanguageFile 最后使用的语言。 使用例子: 12345LangString message ${LANG_ENGLISH} \"英语信息\"LangString message ${LANG_FRENCH} \"法语信息\"LangString message ${LANG_KOREAN} \"韩文信息\"MessageBox MB_OK \"A translated message: $(message)\" LicenseLangString1名称 语言ID 许可文件路径 用法和 LangString 一样，但它仅从一个文本、RTF 文件载入字串并且定义一个特别的仅能用于 LicenseData 的 LangString。","link":"/post/2673115526.html"},{"title":"NSIS教程(4)-传统界面示例","text":"本文以一个完整的、传统界面的网易云音乐安装包的脚本为示例，来介绍 NSIS 传统用户界面的开发流程。 网易云音乐安装脚本完整的示例脚本如下，脚本中包含了详细的注释加以解释说明。请将下面脚本保存为.nsi 文件（需使用 ANSI 编码保存），编译即可生成安装包。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199# 单行注释用井号\"#\"或分号\";\"，跨行注释用可以用C/C++中注释语法。# 使用!define定义一些常量（如安装包的版本号等）# 对常量或变量的引用可以使用如${PRODUCT_NAME}格式，也可以使用如$PRODUCT_NAME格式!define PRODUCT_NAME \"网易云音乐\"!define EXE_NAME \"cloudmusic.exe\"!define PRODUCT_VERSION \"1.0.0.1\"!define PRODUCT_PUBLISHER \"NetEase\"!define PRODUCT_LEGAL \"NetEase 1999-2014\"!define TEMP_DIR \"\"/*NSIS内置了一些常用的变量，如$INSTDIR 表示用户定义的解压路径；$DESKTOP 表示Windows桌面目录；等等。也可以用 Var 命令来声明自己的变量($VARNAME)。 NSIS的变量都是全局的并且可以在任何区段或函数中使用。另外堆栈可以用来作为临时存储。 使用 Push 和 Pop 命令来访问堆栈。Push把一个值添加到堆栈，Pop移除一个值并且设置该变量。且NSIS内置了20个已注册的变量 (如 $0~$9 和 $R0~$R9)。 这些变量不需要声明就可以使用。*/# 定义安装包可执行文件的版本信息VIProductVersion \"${PRODUCT_VERSION}\"VIAddVersionKey \"ProductVersion\" \"${PRODUCT_VERSION}\"VIAddVersionKey \"ProductName\" \"${PRODUCT_NAME}\"VIAddVersionKey \"CompanyName\" \"${PRODUCT_PUBLISHER}\"VIAddVersionKey \"FileVersion\" \"${PRODUCT_VERSION}\"VIAddVersionKey \"InternalName\" \"${EXE_NAME}\"VIAddVersionKey \"FileDescription\" \"${PRODUCT_NAME}\"VIAddVersionKey \"LegalCopyright\" \"${PRODUCT_LEGAL}\"# ==================== NSIS属性 ================================# 设置安装包的压缩方案，有ZLIB（默认）、BZIP2、LZMASetCompressor lzma; 设置安装包名字，显示在安装包标题栏等位置Name \"$PRODUCT_NAME\"# 安装包可执行程序文件名OutFile \"网易云音乐安装-Basic UI.exe\"# 安装包默认安装位置，也就是安装路径的默认值InstallDir \"$PROGRAMFILES\\Netease\\CloudMusic\"# 设置是否显示安装详细信息ShowInstDetails hide# 设置是否显示卸载详细信息ShowUnInstDetails hide# 针对Vista和win7+ 的UAC进行权限请求.# RequestExecutionLevel none|user|highest|adminRequestExecutionLevel admin# 安装和卸载程序的图标Icon \"image\\logo.ico\"UninstallIcon \"image\\un_logo.ico\"/*向导页面是NSIS安装程序中最重要的界面元素，在nsis脚本中可以使用NSIS内置页面或者定制界面，通过脚本可以指定页面的顺序、显示样子和行为。 PageEx指令用来定义安装程序中的页面，也可以使用Page指令，但PageEx提供更多选项；UninstPage用来定义卸载页面。页面显示的顺序和它在nsis脚本中定义的次序一致。安装页面有：license|components|directory|instfiles|卸载页面有：uninstConfirm每个页面有不同元素和属性。也可以使用Page custom来自定义页面，这个后面的文章有讲到。*/PageEx license LicenseData \"license.rtf\" #可以是txt或rtf文件格式PageExEnd/*在一个普通的安装包里用户需要安装许多东西。例如在NSIS安装包里你可以选择安装源码、附加插件、脚本样例或其他。里面的每个组件都有它自己的代码块，当用户选择了安装该组件，那么安装程序就会执行对应的代码。在脚本里，这些代码称为区段，见下面的Section。每个可见的区段都可以作为一个组件给用户选择是否安装。你可以只使用一个区段来构建安装包，但是如果你想要使用组件页来让用户选择可选的组件，那你就需要使用多个区段。*/PageEx components Caption \"组件选择\" ComponentText \"选择安装组件：\" \"主程序\" \"快捷方式\"PageExEndPageEx directory Caption \"安装目录\" DirText \"请选择安装目录：\"PageExEndPageEx instfilesPageExEnd# 区段1# 区段名以一个!开头，那么该区段的显示名称将以粗体字显示.Section \"!Files\" \"des_files\" ; 设置下面指定的文件在安装时默认的解压路径 SetOutPath $INSTDIR ; 指明哪些文件需要被压缩进入安装包，\"app\\*.*\"是相对于nsis脚本文件的相对路径 File /r \"app\\*.*\"SectionEnd# 区段2# 该区段专门用来创建一些快捷方式#Section \"Shortcut\" \"des_shortcut\" SetShellVarContext all CreateDirectory \"$SMPROGRAMS\\${PRODUCT_NAME}\" CreateShortCut \"$SMPROGRAMS\\${PRODUCT_NAME}\\${PRODUCT_NAME}.lnk\" \"$INSTDIR\\${EXE_NAME}\" CreateShortCut \"$SMPROGRAMS\\${PRODUCT_NAME}\\卸载${PRODUCT_NAME}.lnk\" \"$INSTDIR\\uninst.exe\" SetShellVarContext currentSectionEnd# 区段3# 区段名为空、遗漏或者以一个 \"-\" 开头，那么它将是一个隐藏的区段，用户也不能选择禁止它.#Section \"-Necessary\" # 生成卸载程序 WriteUninstaller \"$INSTDIR\\uninst.exe\" # 添加卸载信息到控制面板 WriteRegStr HKLM \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${PRODUCT_NAME}\" \"DisplayName\" \"${PRODUCT_NAME}\" WriteRegStr HKLM \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${PRODUCT_NAME}\" \"UninstallString\" \"$INSTDIR\\uninst.exe\" /* 在NSIS脚本里每一行都作为一个命令处理，如果这一行太长的话你可以使用“\\”来分隔，编译器会自动地把下一行接到上一行来作为完整的一行，而不是看作新的行。 */ WriteRegStr HKLM \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${PRODUCT_NAME}\" \"DisplayIcon\" \"$INSTDIR\\${EXE_NAME}\" WriteRegStr HKLM \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${PRODUCT_NAME}\" \"Publisher\" \"$INSTDIR\\${PRODUCT_PUBLISHER}\"SectionEnd# 卸载区段，如果一个区段名为“Uninstall”或以“un.”为前缀，那么它就是一个卸载程序区段。#Section \"Uninstall\" ; 删除快捷方式，SetShellVarContext 设置操作是针对当前用户还是所有用户 SetShellVarContext all Delete \"$SMPROGRAMS\\${PRODUCT_NAME}\\${PRODUCT_NAME}.lnk\" Delete \"$SMPROGRAMS\\${PRODUCT_NAME}\\卸载${PRODUCT_NAME}.lnk\" RMDir \"$SMPROGRAMS\\${PRODUCT_NAME}\\\" Delete \"$DESKTOP\\${PRODUCT_NAME}.lnk\" SetShellVarContext current SetOutPath \"$INSTDIR\" ; 删除安装的文件 Delete \"$INSTDIR\\*.*\" SetOutPath \"$DESKTOP\" RMDir /r \"$INSTDIR\" RMDir \"$INSTDIR\" SetAutoClose trueSectionEnd# ============================== 回调函数 ====================================# 函数名以“.”开头的一般作为回调函数保留.# 函数名以“un.”开头的函数将会被创建在卸载程序里，因此，普通安装区段和函数不能调用卸载函数，而卸载区段和卸载函数也不能调用普通函数。Function .onInitFunctionEndFunction .onGUIInitFunctionEnd# 安装成功以后.Function .onInstSuccessFunctionEnd# 卸载操作开始前.Function un.onInit MessageBox MB_ICONQUESTION|MB_YESNO \"你确实要完全删除网易云音乐，及其所有组件吗?\" /SD IDYES IDYES +2 IDNO +1 AbortFunctionEnd# 卸载成功以后.Function un.onUninstSuccess MessageBox MB_ICONINFORMATION|MB_OK \"${PRODUCT_NAME} 已成功地从你的计算机移除\" /SD IDOKFunctionEnd 上述脚本会将与脚本相同级别的 app 目录下的全部文件（含子目录）打包进安装包。image\\logo.ico和image\\un_logo.ico分别是安装包和卸载程序的图标。 运行截图","link":"/post/275632694.html"},{"title":"NSIS教程(5)-现代界面示例","text":"NSIS 的现代用户界面(Modern UI)只是相对于传统（丑陋）的界面而言的“现代”而已。它定义在MUI2.nsh中，nsh 文件类似 C++中的头文件，可以被其他模块包含引用。 📌 推荐：NSIS-UI-Plugin 开源 NSIS UI 插件框架，支持任意第三方界面库。默认使用 Qt 作为界面库的安装包示例。 使用 MUI2 界面需要包含MUI2.nsh： 1!include \"MUI2.nsh\" MUI2 界面和传统界面不同之处在于，传统界面使用的Page(或PageEx)语法来标识显示哪些页面，如： 123PageEx license LicenseData \"license.rtf\" #可以是txt或rtf文件格式PageExEnd 而 MUI2 使用的是MUI2.nsh中定义的一系列宏来标识显示哪些页面，如： 1!insertmacro MUI_PAGE_LICENSE \"license.rtf\" 和NSIS教程(4)-传统界面示例类似，这里提供制作网易云音乐的现代用户界面的安装包示例，脚本代码中包含了详细的注释。 高仿网易云音乐安装脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188# ====================== 自定义宏 ==============================!define PRODUCT_NAME \"网易云音乐\"!define EXE_NAME \"cloudmusic.exe\"!define PRODUCT_VERSION \"1.0.0.1\"!define PRODUCT_PUBLISHER \"NetEase\"!define PRODUCT_LEGAL \"NetEase 1999-2014\"!define TEMP_DIR \"\"# ===================== 外部插件以及宏 =============================!include \"MUI2.nsh\"# ===================== 安装包版本 =============================VIProductVersion \"${PRODUCT_VERSION}\"VIAddVersionKey \"ProductVersion\" \"${PRODUCT_VERSION}\"VIAddVersionKey \"ProductName\" \"${PRODUCT_NAME}\"VIAddVersionKey \"CompanyName\" \"${PRODUCT_PUBLISHER}\"VIAddVersionKey \"FileVersion\" \"${PRODUCT_VERSION}\"VIAddVersionKey \"InternalName\" \"${EXE_NAME}\"VIAddVersionKey \"FileDescription\" \"${PRODUCT_NAME}\"VIAddVersionKey \"LegalCopyright\" \"${PRODUCT_LEGAL}\"# ==================== NSIS属性 ================================# ZLIB(默认) BZIP2 LZMASetCompressor lzma; 安装包名字.Name \"${PRODUCT_NAME}\"# 安装程序文件名.OutFile \"网易云音乐安装0.exe\"# 默认安装位置.InstallDir \"$PROGRAMFILES\\Netease\\CloudMusic\"# 设置是否显示安装详细信息。ShowInstDetails hide# 设置是否显示卸载详细信息ShowUnInstDetails hide# 针对Vista和win7 的UAC进行权限请求.# RequestExecutionLevel none|user|highest|adminRequestExecutionLevel admin# ==================== MUI属性 ==================================# 安装和卸载程序图标!define MUI_ICON \"image\\logo.ico\"!define MUI_UNICON \"image\\un_logo.ico\"# 如果未使用MUI，则可直接使用.onGUIInit!define MUI_CUSTOMFUNCTION_GUIINIT onGUIInit# 安装程序欢迎页面!insertmacro MUI_PAGE_WELCOME# 安装程序软件授权申明页面!insertmacro MUI_PAGE_LICENSE \"license.rtf\"# 安装程序显示安装目录选择页面!insertmacro MUI_PAGE_DIRECTORY# 安装程序显示安装组件选择页面!insertmacro MUI_PAGE_COMPONENTS# 安装程序显示进度页面!insertmacro MUI_PAGE_INSTFILES# 安装程序显示安装结束页面!insertmacro MUI_PAGE_FINISH# 卸载程序显示进度!insertmacro MUI_UNPAGE_INSTFILES# 卸载程序显示安装结束!insertmacro MUI_UNPAGE_FINISH# 指定语言，必须在最后指定!insertmacro MUI_LANGUAGE \"SimpChinese\"# ========================= 安装步骤 ===============================# 区段1# 区段名以一个 ! 开头，那么该区段的显示名称将以粗体字显示.Section \"!Files\" \"des_files\" ; 设置文件的输出路径 SetOutPath $INSTDIR ; 放置文件 File /r \"app\\*.*\"SectionEnd# 区段2Section \"Shortcut\" \"des_shortcut\" SetShellVarContext all CreateDirectory \"$SMPROGRAMS\\${PRODUCT_NAME}\" CreateShortCut \"$SMPROGRAMS\\${PRODUCT_NAME}\\${PRODUCT_NAME}.lnk\" \"$INSTDIR\\${EXE_NAME}\" CreateShortCut \"$SMPROGRAMS\\${PRODUCT_NAME}\\卸载${PRODUCT_NAME}.lnk\" \"$INSTDIR\\uninst.exe\" SetShellVarContext currentSectionEnd# 区段3# 区段名为空、遗漏或者以一个 \"-\" 开头，那么它将是一个隐藏的区段，用户也不能选择禁止它.Section \"-Necessary\" # 生成卸载程序 WriteUninstaller \"$INSTDIR\\uninst.exe\" # 添加卸载信息到控制面板 WriteRegStr HKLM \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${PRODUCT_NAME}\" \"DisplayName\" \"${PRODUCT_NAME}\" WriteRegStr HKLM \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${PRODUCT_NAME}\" \"UninstallString\" \"$INSTDIR\\uninst.exe\" WriteRegStr HKLM \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${PRODUCT_NAME}\" \"DisplayIcon\" \"$INSTDIR\\${EXE_NAME}\" WriteRegStr HKLM \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${PRODUCT_NAME}\" \"Publisher\" \"$INSTDIR\\${PRODUCT_PUBLISHER}\"SectionEnd# 卸载区段Section \"Uninstall\" ; 删除快捷方式 SetShellVarContext all Delete \"$SMPROGRAMS\\${PRODUCT_NAME}\\${PRODUCT_NAME}.lnk\" Delete \"$SMPROGRAMS\\${PRODUCT_NAME}\\卸载${PRODUCT_NAME}.lnk\" RMDir \"$SMPROGRAMS\\${PRODUCT_NAME}\\\" Delete \"$DESKTOP\\${PRODUCT_NAME}.lnk\" SetShellVarContext current SetOutPath \"$INSTDIR\" ; 删除安装的文件 Delete \"$INSTDIR\\*.*\" SetOutPath \"$DESKTOP\" RMDir /r \"$INSTDIR\" RMDir \"$INSTDIR\" SetAutoClose trueSectionEnd# 区段描述!insertmacro MUI_FUNCTION_DESCRIPTION_BEGIN !insertmacro MUI_DESCRIPTION_TEXT ${des_files} \"主程序文件\" !insertmacro MUI_DESCRIPTION_TEXT ${des_shortcut} \"创建开始菜单和桌面快捷方式\"!insertmacro MUI_FUNCTION_DESCRIPTION_END# ============================== 回调函数 ====================================# 函数名以“.”开头的一般作为回调函数保留.# 函数名以“un.”开头的函数将会被创建在卸载程序里，因此，普通安装区段和函数不能调用卸载函数，而卸载区段和卸载函数也不能调用普通函数。Function .onInitFunctionEndFunction onGUIInitFunctionEnd# 安装成功以后.Function .onInstSuccessFunctionEnd# 卸载操作开始前.Function un.onInit MessageBox MB_ICONQUESTION|MB_YESNO \"你确实要完全删除网易云音乐，及其所有组件吗?\" /SD IDYES IDYES +2 IDNO +1 AbortFunctionEnd# 卸载成功以后.Function un.onUninstSuccess MessageBox MB_ICONINFORMATION|MB_OK \"${PRODUCT_NAME} 已成功地从你的计算机移除\" /SD IDOKFunctionEnd 运行效果","link":"/post/3798382521.html"},{"title":"NSIS教程(6)-静默安装","text":"静默安装/卸载是一种安装/卸载形式，用户打开安装包后不显示任何安装界面，直接开始安装，支持使用命令行参数指定安装路径等。 1. 静默方式常用的静默安装有 2 种： 在脚本中加入 SilentInstall 和 SilentUninstall 命令 在程序启动参数里加 /S 参数(区分大小写) 2. 当前是否静默运行在脚本中判断安装、卸载程序是否为静默运行，可以使用 IfSilent： 12345# 安装操作开始前.Function .onInit IfSilent +2 +1 MessageBox MB_ICONQUESTION|MB_OK \"欢迎使用\"FunctionEnd 3. 默认应答对于有些命令需要为静默安装指定默认的回答，如MessageBox需要加入/SD 开关来指定默认回答。 12345# 卸载操作开始前.Function un.onInit MessageBox MB_ICONQUESTION|MB_YESNO \"确定要卸载吗?\" /SD IDYES IDYES +2 IDNO +1 AbortFunctionEnd 4. 启动参数解析如果需要为静默安装指定其他的参数，如用户名等，可以使用程序启动参数指定，并在.onInit 函数里进行解析： 1234#使用插件FileFunc中的2个宏!include \"FileFunc.nsh\"!insertmacro GetParameters!insertmacro GetOptions 12# 定义全局变量Var paramInstllDir # 启动参数-安装目录 12345678# 自定义宏ParseParameters，在.onInit函数中调用即可!macro ParseParameters ${GetParameters} $R0 ${GetOptions} $R0 '/installdir' $R1 StrCpy $paramInstllDir $R1 IfSilent +1 +2 StrCpy $INSTDIR $paramInstllDir!macroend","link":"/post/4172083706.html"},{"title":"NSIS教程(7)-插件使用","text":"NSIS 内置了很多指令，这些指令可以满足我们基本需求，但难免会遇到 NSIS 没有内置的功能，如进程操作，后台运行（即多线程），7z 压缩等等，这个时候我们就需要借助第三方插件来满足我们所需要的功能了。 一、插件获取NSIS 官方收录插件的网址是： http://nsis.sourceforge.net/Category:Plugins 我们可以在这个网站上查找和下载我们需要的插件，该网站上针对每个插件都提供了比较完善的示例。 二、插件使用NSIS 插件以 dll 的形式存在，我们以KillProc插件为例（从名字上可以看出该插件提供杀进程的功能），我们下载下来的一般是压缩包，解压之后找到对应插件 dll 文件，如KillProc.dll文件。 使用步骤如下： 将 dll 文件拷贝到 NSIS 安装目录下的Plugins\\x86-ansi目录（Unicode 插件需要拷贝到Plugins\\x86-unicode目录）。 在官方文档上找到该插件所提供的函数，以及函数的参数传递形式、返回值形式。NSIS 中插件函数的参数传递形式有 2 种形式： 使用$0 ~ $9，$R0 ~ $R9来传递。 使用堆栈来传递。 在 NSIS 脚本中按照函数声明的形式来调用，需要在函数名前加上 dll 名称（不需要.dll 后缀），如KillProc::KillProcesses。 1234567891011Section StrCpy $0 \"foo.exe\" # 变量赋值 KillProc::KillProcesses StrCmp $1 \"-1\" wooops wooops: Abort completed:SectionEnd","link":"/post/3031217406.html"},{"title":"NSIS教程(8)-插件开发","text":"虽然 NSIS 官方提供了很多插件，也有一些第三方的插件可以下载使用，但在实际开发中难免会遇到已有插件没有提供的功能或者插件不好用的情况，这时我们可以选择自己开发 NSIS 插件。 一、插件开发规范NSIS 插件对开发语言没有限制（本文介绍基于 C++开发），只要按照 NSIS 标准所要求的生成一个 dll 文件，该 dll 文件提供纯C规范的、固定格式的导出函数即可。 总结起来，开发 NSIS 插件的步骤为： 使用 Visual Studio 新建 dll 工程（运行库选择MT或MTD），建议使用的 MT 运行库，不需要额外携带运行时文件。 定义插件功能函数，假设函数名为 add，则函数声明格式如下： 123456extern \"C\" __declspec(dllexport) void __cdecl add ( HWND hwndParent, int string_size, char *variables, stack_t **stacktop, extra_parameters *extra); 编译生成 dll 文件。 二、参数和返回值开发 NSIS 插件的难点在于：获取调用者传入的参数，以及将执行结果返回给调用者。前面的 NSIS教程(7)-插件使用 说到了，插件函数的调用者传递参数方式有 2 种： 一种是通过$0~$9 $R0~$R9的形式，这种形式的参数通过char *variables参数来获取。 一种是通过堆栈的形式，这种形式的参数通过stack_t **stacktop参数来获取。 三、PluginCommon为了方便插件开发中获取用户传入参数、以及执行结果的返回，我对插件开发的常用操作进行了封装。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147// PluginCommon.h#ifndef _PLUGIN_COMMON_H_#define _PLUGIN_COMMON_H_#include &lt;stdio.h&gt;#define PLUGIN_BUF_LEN 1024#define NSISAPI extern \"C\" __declspec(dllexport) void __cdecl#define EXDLL_INIT() { \\ g_stringsize=string_size; \\ g_stacktop=stacktop; \\ g_variables=variables; }typedef struct _stack_t { struct _stack_t *next; char text[1];} stack_t;static unsigned int g_stringsize;static stack_t **g_stacktop;static char *g_variables;enum{ INST_0, // $0 INST_1, // $1 INST_2, // $2 INST_3, // $3 INST_4, // $4 INST_5, // $5 INST_6, // $6 INST_7, // $7 INST_8, // $8 INST_9, // $9 INST_R0, // $R0 INST_R1, // $R1 INST_R2, // $R2 INST_R3, // $R3 INST_R4, // $R4 INST_R5, // $R5 INST_R6, // $R6 INST_R7, // $R7 INST_R8, // $R8 INST_R9, // $R9 INST_CMDLINE, // $CMDLINE INST_INSTDIR, // $INSTDIR INST_OUTDIR, // $OUTDIR INST_EXEDIR, // $EXEDIR INST_LANG, // $LANGUAGE __INST_LAST};static int __stdcall popstring(char *str){ stack_t *th; if (!g_stacktop || !*g_stacktop) return 1; th=(*g_stacktop); lstrcpyA(str,th-&gt;text); *g_stacktop = th-&gt;next; GlobalFree((HGLOBAL)th); return 0;}static void __stdcall pushstring(char *str){ stack_t *th; if (!g_stacktop) return; th=(stack_t*)GlobalAlloc(GPTR,sizeof(stack_t)+g_stringsize); lstrcpynA(th-&gt;text,str,g_stringsize); th-&gt;next=*g_stacktop; *g_stacktop=th;}static int __stdcall popint(){ char buf[512] = {0}; popstring(buf); return atoi(buf);}static void __stdcall pushint(long value){ char buf[512] = {0}; sprintf_s(buf, \"%ld\", value); pushstring(buf);}static char * __stdcall getuservariable(int varnum){ if (varnum &lt; 0 || varnum &gt;= __INST_LAST) return NULL; return g_variables+varnum*g_stringsize;}static void __stdcall setuservariable(int varnum, char *var){ if (var != NULL &amp;&amp; varnum &gt;= 0 &amp;&amp; varnum &lt; __INST_LAST) lstrcpyA(g_variables + varnum*g_stringsize, var);}enum NSPIM{ NSPIM_UNLOAD, // This is the last message a plugin gets, do final cleanup NSPIM_GUIUNLOAD, // Called after .onGUIEnd};typedef UINT_PTR (*NSISPLUGINCALLBACK)(enum NSPIM);// extra_parameters data structures containing other interesting stuff// but the stack, variables and HWND passed on to plug-ins.typedef struct{ int autoclose; int all_user_var; int exec_error; int abort; int exec_reboot; // NSIS_SUPPORT_REBOOT int reboot_called; // NSIS_SUPPORT_REBOOT int XXX_cur_insttype; // depreacted int plugin_api_version; // see NSISPIAPIVER_CURR // used to be XXX_insttype_changed int silent; // NSIS_CONFIG_SILENT_SUPPORT int instdir_error; int rtl; int errlvl; int alter_reg_view; int status_update;} exec_flags_t;#ifndef NSISCALL#define NSISCALL __stdcall#endiftypedef struct { exec_flags_t *exec_flags; int (NSISCALL *ExecuteCodeSegment)(int, HWND); void (NSISCALL *validate_filename)(char *); // returns 0 on success, 1 if already registered and &lt; 0 on errors int (NSISCALL *RegisterPluginCallback)(HMODULE, NSISPLUGINCALLBACK);} extra_parameters;#endif //_PLUGIN_COMMON_H_ 在开发插件中经常用到的有：4 个堆栈操作函数：pushint,pushstring,popint,popstring。2 个寄存器变量($R0~$R9,$0~$9)操作函数：getuservariable，setuservariable。 四、示例基于上面的 PluginCommon.h，我们可以将开发插件的步骤流程大大简化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;windows.h&gt;#include &lt;commctrl.h&gt;#include &lt;stdarg.h&gt;#include &lt;tchar.h&gt;#include \"PluginCommon.h\"HINSTANCE g_hInstance;HWND g_hwndParent;extra_parameters *g_pluginParms = NULL;#define NSMETHOD_INIT(parent) {\\ g_pluginParms = extra; \\ g_hwndParent = parent; \\ EXDLL_INIT(); }BOOL WINAPI DllMain(HANDLE hInst, ULONG ul_reason_for_call, LPVOID lpReserved){ g_hInstance = (HINSTANCE)hInst; if (ul_reason_for_call == DLL_PROCESS_ATTACH) { //do what you want at init time. } if (ul_reason_for_call == DLL_THREAD_DETACH || ul_reason_for_call == DLL_PROCESS_DETACH) { //clean up code. } return TRUE;}//// 以上内容通用，每个插件都可以将上面的内容直接复制过去。//// NSIS插件导出函数,以add函数为例，若要添加其他函数，则只是函数名需要修改，函数逻辑写在NSMETHOD_INIT(hwndParent);之后的花括号内。//extern \"C\" __declspec(dllexport) void __cdecladd ( HWND hwndParent, int string_size, char *variables, stack_t **stacktop, extra_parameters *extra){ NSMETHOD_INIT(hwndParent); { // == 添加自己代码 // 假设调用者通过堆栈的形式传递的参数 int i = popint(); // 注意：栈是先进后出 int j = popint(); int k = i + j; pushint(k); // 通过plugin-common.h中提供的pushint返回整数，也可以使用pushstring返回字符串 // == }} 五、Unicode 支持大家可能注意到了上面的示例和PluginCommon.h中使用的都是char，而不是wchar_t。那如果要改成wchar_t需要哪些工作了？ 将插件代码中的char改成wchar_t。 在 nsi 脚本中加入Unicode True。 需要将生成的插件 dll 放到 nsis 目录下的Plugins\\x86-unicode子目录中。","link":"/post/1273492093.html"},{"title":"NSIS教程(9)-使用界面库制作安装界面","text":"前面的几篇文章介绍了 NSIS 的传统界面的安装包和现代界面的安装包的制作方法，也提到了 NSIS 支持自定义页面（即使用page custom）的特性，自定义页面需要用户自己创建对话框、控件、添加控件响应等等，虽然 NSIS 提供了nsDialogs.nsh来支持这些功能，但使用起来还是不太方便（需要专门了解这个插件诸多用法），而且不够灵活，所以本文介绍一种终极的自定义界面的安装包解决方案，即完全使用第三方界面库来绘制安装包界面。 该方案是对界面库没有限制的，可以使用其他任何界面库，如 MFC, Qt，WTL 等。通过这种方案可以很轻松的实现类似金山毒霸、QQ、360 安全卫士等软件的安装包界面。 一、原理NSIS 自定义页面的语法： 1page custom [创建函数] [离开函数] [标题] 使用第三方界面库完全定制安装包界面的基本原理就是：新建一个 dll 插件，在page custom的[创建函数]中调用该插件中的函数来显示界面，这时界面上的按钮的响应就不再由 NSIS 控制了，完全由我们的代码控制。 二、难点问题使用我们的插件 dll 完全替代 NSIS 界面之后，有几个问题需要解决： 如何获取安装和卸载的进度 如何从 C++回调 NSIS 函数 2.1 安装和卸载进度NSIS 中的安装和卸载进度由!insertmacro MUI_PAGE_INSTFILES或Page instfiles提供。 在完全使用自己的界面之后，这 2 个 NSIS 界面都不能使用了，这时我们需要自己获取安装（释放）和卸载（删除）的进度。 以安装进度为例，NSIS 中文件的安装时文件释放功能都是由File命令提供，但该命令没有提供释放进度，所以我们无法获取到实时的释放进度。在这里我们可以使用一个曲折的方法，我们将一个 7z 压缩包放入安装包中： 12SetOutPath $INSTDIRFile \"app\\app.7z\" 等安装包释放完这个压缩包之后（这段时间的进度无法显示），再使用 NSIS 官方提供的nsis7z插件来解压缩这个 7z 压缩包，由于 nsis7z 插件可以提供解压缩进度，所以我们可以将这个进度显示在安装进度页面上，解压完之后再删除 7z 压缩包。这个方案的一个弊端就是，7z 压缩包从安装包中释放到本地磁盘的过程需要时间，且这个时间无法准确的显示在进度页面。 1234567Function ExtractFunc SetOutPath $INSTDIR File \"app\\app.7z\" GetFunctionAddress $R9 ExtractCallback Nsis7z::ExtractWithCallback \"$INSTDIR\\app.7z\" $R9 Delete \"$INSTDIR\\app.7z\"FunctionEnd 123456789101112131415Function ExtractCallback Pop $1 Pop $2 System::Int64Op $1 * 100 Pop $3 System::Int64Op $3 / $2 Pop $0 nsDui::SetSliderValue \"slrProgress\" $0 ${If} $1 == $2 nsDui::SetSliderValue \"slrProgress\" 100 nsDui::NextPage \"wizardTab\" ${EndIf}FunctionEnd 写这篇文字的时候，发现现在的nsis7z已经太老了，新版的压缩软件生成的 7z 压缩包，该插件已经无法解压。可以使用 7za.exe 命令行工具来生成 7z 压缩文件，7za.exe 从此处下载：http://download.csdn.net/download/china_jeffery/10214464。7za 生成 7z 压缩包语法为：7za.exe a app.7z app\\* 2.2 从 C++回调 NSIS 函数比如用户点击了我们自定义界面上的“取消”按钮，这时我们需要调用 NSIS 的Abort函数来取消安装。此时就需要解决如何从 C++环境回调到 NSIS 环境。 我们可以使用NSIS教程(8)-插件开发中介绍的PluginCommon.h来实现该功能。 大致原理是，在 NSIS 脚本中初始化自定义界面的控件与 NSIS 函数指针（整型）的绑定关系（如控件名–函数名），当用户点击控件之后，查找到该控件绑定的 NSIS 函数，然后调用extra_parameters::ExecuteCodeSegment函数（函数第一个参数就是 NSIS 函数指针）。 以 duilib 界面库为例，对 NSIS 暴露 OnControlBindNSISScript 接口，提供绑定控件与 NSIS 函数指针（整型）的功能： 123456789NSISAPI OnControlBindNSISScript(HWND hwndParent, int string_size, char *variables, stack_t **stacktop, extra_parameters *extra){ char controlName[MAX_PATH]; ZeroMemory(controlName, MAX_PATH); popstring(controlName); int callbackID = popint(); g_pMainDlg-&gt;SaveToControlCallbackMap( controlName, callbackID );} 在 NSIS 中调用OnControlBindNSISScript绑定控件与 NSIS 函数： 12GetFunctionAddress $0 OnExitDUISetupnsDui::OnControlBindNSISScript \"btnFinishedClose\" $0 在 duilib 的Notify按钮事件响应函数中调用ExecuteCodeSegment执行 NSIS 函数： 1234567891011121314void CDlgMain::Notify( TNotifyUI&amp; msg ){ std::map&lt;CDuiString, int &gt;::iterator iter = m_controlCallbackMap.find( msg.pSender-&gt;GetName() ); if( _tcsicmp( msg.sType, _T(\"click\") ) == 0 ){ if( iter != m_controlCallbackMap.end() ) g_pluginParms-&gt;ExecuteCodeSegment( iter-&gt;second - 1, 0 ); } else if( _tcsicmp( msg.sType, _T(\"textchanged\") ) == 0 ){ if( iter != m_controlCallbackMap.end() ) g_pluginParms-&gt;ExecuteCodeSegment( iter-&gt;second - 1, 0 ); } else { WindowImplBase::Notify(msg); }} 可以参考我的NSIS-UI-Plugin 项目，基于该项目可以使用任意第三方界面库来定制安装界面。","link":"/post/100006247.html"},{"title":"《打包狂魔之NSIS教程》","text":"NSIS 是 Windows 平台的安装包制作脚本，越来越多的互联网公司选择使用它来制作安装包，它开源免费且功能强大。该教程提供 NSIS 安装包制作的一站式解决方案。 专栏文章列表： NSIS教程(1)-基础语法 NSIS教程(2)-完整属性 NSIS教程(3)-完整指令 NSIS教程(4)-传统界面示例 NSIS教程(5)-现代界面示例 NSIS教程(6)-静默安装 NSIS教程(7)-插件使用 NSIS教程(8)-插件开发 NSIS教程(9)-使用界面库制作安装界面 NSIS教程(10)-MUI跳过指定安装步骤 NSIS教程(11)-中文手册 NSIS教程(12)-开源UI插件","link":"/post/4015642655.html"},{"title":"《拨开字符编码的迷雾》","text":"本专栏从字符编码的基础概念开始，力求帮助读者一步一步地理清在开发过程中遇到的各种字符编码问题，助您告别字符编码和乱码的烦恼。 文章列表： 拨开字符编码的迷雾(1)--字符编码概述 拨开字符编码的迷雾(2)--编译器处理文件编码 拨开字符编码的迷雾(3)--字符编码转换 拨开字符编码的迷雾(4)--MySQL字符编码 拨开字符编码的迷雾(5)--Qt字符编码","link":"/post/1376508302.html"},{"title":"拨开字符编码的迷雾(1)--字符编码概述","text":"为什么这样的字符串{\"data\":\"颸颸\"}，JSON 库（如jsoncpp）会解析失败？ 为什么软件界面上的韩文会显示乱码？ ASCII 和 ANSI 有什么区别？ 相信不少人在字符编码上面摔过跟头，这篇文章针对开发中需要了解的字符编码知识进行了简要的讲解，希望能够对大家有所帮助。 1. ASCII 及其扩展1.1 什么是 ASCII 字符集字符集就是一系列用于显示的字符的集合。 ASCII 字符集由美国国家标准协会（American National Standard Institute)于 1968 年制定一个字符映射集合。 ASCII 使用 7 位二进制位来表示一个字符，总共可以表示 128 个字符（即2^7，二进制000 0000 ～ 111 1111，十进制0～127）。 ASCII 字符集中每个数字对应一个唯一的字符，如下表： 因为其对应关系非常简单，不需要特殊的编码规则，所以严格来讲 ASCII 不能算字符编码，因为它没有规定编码规则。我们只是习惯性的将 ASCII 字符集称之为 ASCII 码、ASCII 编码。 1.2 ASCII 的扩展1.2.1 最高位扩展 - ISO/IEC 8859ASCII 字符集是美国人发明的，其中的字符完全是为其自己量身定制的。随着计算机技术普及到欧洲（如法国、德国）各国，欧洲很多国家使用的字符除了 ASCII 表中的 128 个字符之外，还有一些各国特有的字符，此时欧洲人民发现 ASCII 字符集不能完全表达他们所要表达的内容。怎么办了？他们发现 ASCII 只使用了一个字节（8 位）之中的低 7 位，于是欧洲各国开始各显神通，打起了那 1 个最高位（第 0 位）的主意，将最高位利用了起来，这样又多了 128 个字符，从而满足了欧洲人民的需要。 但因为每个国家的需求不一样，各国都设计了不同的方案。为了结束这种混乱的局面，国际标准化组织(ISO)及国际电工委员会(IEC)联合制定了一系列 8 位字符集的标准，统称为 ISO 8859（全称 ISO/IEC 8859）。注意，这是一系列字符集的统称，如 ISO/IEC 8859-1（也就是常听到的 Latin-1）支持西欧语言，ISO/IEC 8859-4（Latin-4）支持北欧语言等。 完整列表如下（摘自百度百科）：ISO/IEC 8859-1 (Latin-1) - 西欧语言ISO/IEC 8859-2 (Latin-2) - 中欧语言ISO/IEC 8859-3 (Latin-3) - 南欧语言，世界语也可用此字符集显示。ISO/IEC 8859-4 (Latin-4) - 北欧语言ISO/IEC 8859-5 (Cyrillic) - 斯拉夫语言ISO/IEC 8859-6 (Arabic) - 阿拉伯语ISO/IEC 8859-7 (Greek) - 希腊语ISO/IEC 8859-8 (Hebrew) - 希伯来语(视觉顺序)ISO 8859-8-I - 希伯来语(逻辑顺序)ISO/IEC 8859-9 (Latin-5 或 Turkish) - 它把 Latin-1 的冰岛语字母换走，加入土耳其语字母。ISO/IEC 8859-10 (Latin-6 或 Nordic) - 北日耳曼语支，用来代替 Latin-4。ISO/IEC 8859-11 (Thai) - 泰语，从泰国的 TIS620 标准字集演化而来。ISO/IEC 8859-13 (Latin-7 或 Baltic Rim) - 波罗的语族ISO/IEC 8859-14 (Latin-8 或 Celtic) - 凯尔特语族ISO/IEC 8859-15 (Latin-9) - 西欧语言，加入 Latin-1 欠缺的芬兰语字母和大写法语重音字母，以及欧元符号。ISO/IEC 8859-16 (Latin-10) - 东南欧语言。主要供罗马尼亚语使用，并加入欧元符号。 我们在数据库中常见到的 Latin-1、2、5、7 其实就是上面提到的针对特定语言的 ASCII 扩展字符集。 1.2.2 多字节扩展 - GB 系列前面讲到了，欧洲各国有效利用闲置的最高位对 ASCII 字符集进行了扩展。可是欧洲人民没有想到在大洋彼岸有着一个拥有五千年历史的伟大民族，她拥有着成千上万的汉字，1 个字节显然不够表达如此深厚的文化底蕴。 于是当计算机引入到中国之初，国家技术监督局就设计了 GB 系列编码方案（GB 为 guo biao 的简称)。GB 编码方案使用 2 个字节来表达一个汉字。同时为了兼容 ASCII 编码，规定各个字节的最高位（首位）必须为 1，从而避免了和最高位为 0 的 ASCII 字符集的冲突。 GB 系列字符集经历下面的几个发展过程： 编码名称 发布时间 字节数 汉字范围 GB2312 1980 年 变字节（ASCII 1 字节，汉字 2 个字节） 6763 个汉字 GB13000 1993 年第一版 变字节（ASCII 1 字节，汉字 2 个字节） 20902 个汉字 GBK Windows95 中 2 个字节 21886 个汉字和图形符号（含 GB2312，BIG5 中所有字符） GB18030 2000 年第一版 变字节（ASCII 1 字节，汉字 2 个或 4 个字节） 27484 个汉字 每一次迭代，支持的字符数量都会增加，而且每一次迭代都会保留之前版本支持的编码，所以做到了向上兼容。 1.2.3 全角与半角因为汉字在显示器上的显示宽度要比英文字符的宽度要宽一倍，在一起排版显示时不太美观。所以 GB 编码不仅仅加入了汉字字符，而且包括了 ASCII 字符集中本来就有的数字、标点符号、字母等字符。这些被编入 GB 编码的数字、标点、字母在显示器上的显示宽度比 ASCII 字符集中的宽度宽一倍，所以前者称为全角字符，后者称为半角字符。 2. ANSI2.1 ANSI 与代码页前面说到了世界各国针对 ASCII 的扩展方案（如欧洲的 ISO/IEC 8859，中国的 GB 系列等），这些 ASCII 扩展编码方案的特点是：他们都兼容 ASCII 编码，但他们彼此之间是不兼容的。微软将这些编码方案统称为 ANSI 编码。故 ANSI 并不是特指某一种编码方案，只有知道了在哪个国家，哪个语言环境下，才知道它具体表示哪个编码方案。 在 Windows 操作系统上，默认使用 ANSI 来保存文件（从Windows 10开始默认使用UTF8编码）。操作系统是如何知道 ANSI 到底应该表示哪种编码了，是 GBK还是 ASCII，或者还是 EUC-KR 了？ Windows 通过一个叫”Code Page”（翻译为中文叫代码页）的东西来判断系统的默认编码。 简体中文操作系统默认的代码页是 936，它表示 ANSI 使用的是 GBK 编码。GB18030 编码对应的 windows 代码页为 CP54936。 可以使用命令chcp来查看系统默认的代码页. 汉字“𤭢”（念 suì）只包含在 GB18030 中，GB2312、GB13000、GBK 中均不包含。默认情况下，在 Visual Studio 中输入该汉字，visual studio 会使用 CP936（即 GBK）来保存代码文件，但如果在代码文件中输入该汉字，visual studio 弹出如下提示要求用户选择代码页： 2.2 更改默认代码页2.2.1 chcp 命令可以使用chcp命令来更改默认代码页，如chcp 437将默认代码页更改为 437（美国）。 2.2.2 控制面板在“控制面板”–&gt;“区域和语言”–&gt; “更改系统区域设置”中更改系统默认的代码页为“中文（简体，中国）”。 2.2.3 代码修改也可以通过代码更改默认的代码页： 1234char *setlocale( int category, const char *locale); 3. Unicode3.1 Unicode 产生背景各个国家使用不同的编码规则，虽然他们都是兼容 ASCII 的，但它们相互却是不兼容的。 试想法国人 Jack 写了一封名为”love_you.txt”的信，传给了他的德国朋友 Rose，Rose 想要在 windows 系统上打开这个文件，她需要知道德国使用的字符编码是 Latin-1，然后还要确保她的计算机上安装了该编码，才能顺利的打开这个文件。如果上面这些还能忍受，那么随着网络的发展，你从互联网上获取的文件，你很有可能不知道它来自哪个国家，使用的哪种编码。这也就是 Email 刚诞生时常常出现乱码的原因，发信人和收信人使用的编码可能是不一样的。 于是The Unicode Standard（统一码标准）横空出世，它由 The Unicode Consortium 于 1991 年发布，我们习惯称它为 Unicode 字符集。 Unicode 字符集和 ASCII 字符集一样，也只是一个字符集合，标记着字符和数字之间的映射关系，它不包含任何编码规则和方案。和 ASCII 不一样的是，Unicode 字符集支持的字符数量是没有限制的（具体可以参考 Unicode 规范）。 我们通常认为的 Unicode 字符固定占用 2 个字节的观点是错误的。如“𤭢”（念 suì）Unicode 码为D852 DF62。 那么 Unicode 字符是怎样被编码成内存中的字节的了？它是通过 UTF(Unicode Transformation Formats)实现的，比较常见得有 UTF-8，UTF-16。 在 windows 系统上汉字默认使用 CP936（即 GBK 编码），占 2 个字节。而大多数 Unicode 字符的 Unicode 码值也占 2 个字节，所以大多数人误以为汉字字符串在内存中的值就是 Unicode 值，这是错误的。可以从 站长工具-Unicode 查询汉字的 Unicode 码值。 3.3 字符集与字符编码的区别从 ASCII、GB2312、GBK、GB18030、Big5（繁体中文）、Latin-1 等采用的方案来看，它们都只是定义了单个字符与二进制数据的映射关系，一个字符在一个方案中只会存在一种表示方式，所以我们说 GB2312 是字符集还是字符编码方式都无所谓了。但是 Unicode 不一样，Unicode 作为一个字符集可以采用多种编码方式，如 UTF-8, UTF-16, UTF-32 等。所以自 Unicode 出现之后，字符集与字符编码需要明确区分开来。 3.4 UTF-16 编码的缺点UTF-16 编码方式规定用两个或四个字节来表示所有的字符。对于 ASCII 字符保持不变，只是将原来的 7 位扩展到了 16 位，其高 9 位永远是 0。如字符’A’： 12ASCII: 100 0001UTF-16: 0000 0000 0100 0001 可以看到对于 ASCII 字符，UTF-16 的存储空间扩大了一倍，UTF-16 并不是完全兼容 ASCII 字符集。这对于那些 ASCII 字符集已经满足需求的西方国家来说完全是没必要的，而且 ASCII 字符经过 UTF-16 编码之后高字节始终是 0，导致很多 C 语言函数（如strcpy,strlen)会将此字节视为字符串的结束符'\\0'，从而出现错误的计算结果。而且，UTF-16 还存在大小端的问题，“𤭢”（念 suì）Unicode 码在大端系统上为D852 DF62，小端系统上为52D8 62DF。因此，UTF-16 一开始推出的时候就遭到很多西方国家的抵制，影响了 Unicode 的推行。于是后来又设计了 UTF-8 编码方式，才解决了这些问题。 3.5. Unicode 字符集常用编码方式：UTF-83.5.1 UTF-8 概述UTF-8 是互联网上使用最广泛的 Unicode 字符集编码方式。UTF-8 编码的最小单位由 8 位（1 个字节）组成，UTF-8 使用一个至四个字节来表示 Unicode 字符。另外，UTF-8 是完美兼容 ASCII 字符集的，这一点可以通过下面的 UTF-8 的编码规则得到证明。 3.5.2 UTF-8 编码规则UTF-8 编码规则很简单：（1）对于 ASCII（单字节字符）字符，采用和 ASCII 相同的编码方式，即只使用一个字节表示，且该字节第一位为 0.（2）对于多字节（2~4 字节）字符，假设字节数为 n（1 &lt; n &lt;= 4），第一个字节：前 n 位都设为 1，第 n+1 位设为 0；后面的 n-1 个字节的前两位一律设为 10。所有字节中的没有提及的其他二进制位，全部为这个符号的 unicode 码。 Unicode 符号范围(十六进制) UTF-8 编码方式(二进制) 单字节:00000000-0000 007F 0xxxxxxx 双字节:00000080-0000 07FF 110xxxxx 10xxxxxx 三字节:00000800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 四字节:0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 3.5.2 UTF-8 BOMBOM（byte order mark）从字面意义来看是标记字节顺序的。最早出现的原因是因为 UTF-16 和 UTF-32 编码采用 2 个或 4 个字节表示一个字符，面临大小端的问题。为了区分是使用的大端(Big Endian，简称 BE)还是小端(Little Endian，简称 LE)，采用了在串的前面加入指定的字节加以区分，UTF-16 大端加入FE FF，小端加入FF FE. 比如， 字符串“ABC”的 UTF-16 编码为 00 41 00 42 00 43，对应的各种的字节序列如下： 序列 数据 UTF-16BE(withoutBOM) 00 41 00 42 00 43 UTF-16LE(withoutBOM) 41 00 42 00 43 00 UTF-16BE(with BOM) FE FF 00 41 00 42 00 43 UTF-16LE(with BOM) FF FE 41 00 42 00 43 00 因为 UTF-8 和 ASCII 都是单字节序列，二者不好区分，微软采用在 UTF-8 编码的字符串前也加入 BOM（3 个字节EF BB BF）来标记 UTF-8 编码的串。UTF-8 BOM 这一规范大多在 windows 下被使用，在其他平台下用的很少使用，如：Linux 全部采用 UTF-8 编码，不存在要区分的情况；HTTP 协议中可以包含Content-Type:text/html; charset=utf-8这样的说明，也不需要区分。 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/2720283852.html"},{"title":"拨开字符编码的迷雾(3)--字符编码转换","text":"本文主要介绍如何使用系统 API 进行字符编码的转换。 1. Windows API 介绍本文介绍使用 Windows API 进行字符编码的转换，涉及WideCharToMultiByte和MultiByteToWideChar2 个 API，API 接口名中的MultiByte对应着多字节编码，如 ASCII、UTF-8 等都是多字节编码，而WideChar字面意思是宽字符，在 windows 内部宽字符特指 UTF-16 编码。 原型如下： 1234567891011int WideCharToMultiByte( UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar); 123456789int MultiByteToWideChar( UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar); 2. API 封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118std::string UnicodeToANSI(const std::wstring &amp;str, UINT iCodePage = CP_ACP) { std::string strRes; int iSize = ::WideCharToMultiByte(iCodePage, 0, str.c_str(), -1, NULL, 0, NULL, NULL); if (iSize == 0) return strRes; char *szBuf = new (std::nothrow) char[iSize]; if (!szBuf) return strRes; memset(szBuf, 0, iSize); ::WideCharToMultiByte(iCodePage, 0, str.c_str(), -1, szBuf, iSize, NULL, NULL); strRes = szBuf; delete[] szBuf; return strRes;}std::wstring ANSIToUnicode(const std::string &amp;str, UINT iCodePage = CP_ACP) { std::wstring strRes; int iSize = ::MultiByteToWideChar(iCodePage, 0, str.c_str(), -1, NULL, 0); if (iSize == 0) return strRes; wchar_t *szBuf = new (std::nothrow) wchar_t[iSize]; if (!szBuf) return strRes; memset(szBuf, 0, iSize * sizeof(wchar_t)); ::MultiByteToWideChar(iCodePage, 0, str.c_str(), -1, szBuf, iSize); strRes = szBuf; delete[] szBuf; return strRes;}std::string UnicodeToUTF8(const std::wstring &amp;str) { std::string strRes; int iSize = ::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, NULL, 0, NULL, NULL); if (iSize == 0) return strRes; char *szBuf = new (std::nothrow) char[iSize]; if (!szBuf) return strRes; memset(szBuf, 0, iSize); ::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, szBuf, iSize, NULL, NULL); strRes = szBuf; delete[] szBuf; return strRes;}std::string UnicodeToUTF8BOM(const std::wstring &amp;str) { std::string strRes; int iSize = ::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, NULL, 0, NULL, NULL); if (iSize == 0) return strRes; unsigned char *szBuf = new (std::nothrow) unsigned char[iSize + 3]; if (!szBuf) return strRes; memset(szBuf, 0, iSize + 3); if (::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, (LPSTR)(szBuf + 3), iSize, NULL, NULL) &gt; 0) { szBuf[0] = 0xEF; szBuf[1] = 0xBB; szBuf[2] = 0xBF; } strRes = (char*)szBuf; delete[] szBuf; return strRes;}std::wstring UTF8ToUnicode(const std::string &amp;str) { std::wstring strRes; int iSize = ::MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0); if (iSize == 0) return strRes; wchar_t *szBuf = new (std::nothrow) wchar_t[iSize]; if (!szBuf) return strRes; memset(szBuf, 0, iSize * sizeof(wchar_t)); ::MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, szBuf, iSize); strRes = szBuf; delete[] szBuf; return strRes;}std::string ANSIToUTF8(const std::string &amp;str, UINT iCodePage = CP_ACP) { return UnicodeToUTF8(ANSIToUnicode(str, iCodePage));}std::string ANSIToUTF8BOM(const std::string &amp;str, UINT iCodePage = CP_ACP) { return UnicodeToUTF8BOM(ANSIToUnicode(str, iCodePage));}std::string UTF8ToANSI(const std::string &amp;str, UINT iCodePage = CP_ACP) { return UnicodeToANSI(UTF8ToUnicode(str), iCodePage);} 对于只支持简体中文（部分韩文、日文）的系统，iCodePage可以使用 CP_ACP，这时 API 会使用系统当前的代码页（简体中文系统为 CP936，即 GBK 字符集）来进行编码转换。 但遇到如下情况就需要手动指定代码页： 需要转换的字符串中的文字是系统当前代码页不支持的。如字符串中含有中文，而当前系统代码页确是英文的； GBK 字符集中只包含了一部分韩文和日文，部分韩文和日文的转换可以正常转换，若遇到不能转换的情况也需要将指定 iCodePage 为特定的支持韩文或日文的代码页了，特别是中文和韩文、日文等混合的情况下。如韩文“탉”不包含在 GBK 中，若这时仍然使用 CP_ACP 就会得到错误的转换结果?，十六进制3F。但 GB18030（代码页为 54936）支持“탉”，可以手动指定 iCodePage 为 54936。 如果代码中含有 GBK 不支持的字符，如“탉”、“𤭢”（念 suì）等，Visual Studio 会弹出如下提示：选择“以其他编码保存”，选择“Unicode（UTF-8 带签名）- 代码页 65001”保存。虽然“简体中文（GB18030) - 代码页 54936”也支持这些字符，但不能选择该选项进行保存，具体原因在拨开字符编码的迷雾(2)--编译器处理文件编码中有详细的介绍。 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/4126466705.html"},{"title":"拨开字符编码的迷雾(2)--编译器处理文件编码","text":"本文主要介绍微软 MSVC 编译器如何加载和处理 C++代码文件。 一. Visual Studio 字符集使用 Visual Studio 创建的 C++工程可以在工程属性配置属性--&gt;常规中配置字符集：使用Unicode字符集（默认）、使用多字节字符集。如图： 但这个设置项不会对编译器处理字符编码产生直接的影响（注意这里的“直接”二字，第 3 节会说到），只会在工程属性配置属性--&gt;C/C++--&gt;预处理器加入相应的宏： 12使用Unicode字符集 --&gt; _UNICODE和UNICODE宏使用多字节字符集 --&gt; _MBCS宏 这几个宏一般用来判断是使用 char 还是 wchar_t，在系统 API 中使用比较多，如 MessegeBox 通过是否定义了 UNICODE 宏来决定是使用 LPCSTR 还是 LPCWSTR（LPCSTR 即 const char*, LPCWSTR 即 const wchar_t*）： 12345#ifdef UNICODE#define MessageBox MessageBoxW#else#define MessageBox MessageBoxA#endif // !UNICODE 二. char 和 wchar_t上面提到了，定义 API 时通过UNICODE 宏来决定是使用 char 还是 wchar_t类型，那么 char 和 wchar_t 有什么不同了？ char 和 wchar_t 是标准 C/C++字符类型，并不是 Windows 特有的。 char 固定占 1 个字节，wchar_t 固定占 2 个字节，从内存的角度来看，char、wchar_t 和其他数据类型一样，只是代表一段内存块，用来存储固定长度的二进制 0 或 1。 在编程时，我们一般习惯于将字符串储到 char 或 wchar_t 定义的内存空间中，将整形存储在 int 定义的内存空间中。 所以，用 char 还是 wchar_t 来存储字符，只是内存分配和数据存储上面的事情，它们本身也是与字符编码无直接关系的（ 同样注意这里的“直接”二字，第 3 节会说到）。 三. 编译器如何处理硬编码字符VC++编译器编译源代码的步骤中，涉及编码处理的步骤主要有 2 个：第 1 步：预处理 1.1) 读取源文件，判断源文件采用的字符编码类型。(这一步不会改变文件内容) 1234编译器判断源文件编码类型的步骤为：1. 若文件开始处有BOM(EF BB BF)，则判定为UTF-8编码；2. 若没有BOM，则试图从文件的前8个字节来判断文件是否像UTF-16编码，如果像，则就判断为UTF-16编码。3. 如果既没BOM，也不是UTF-16编码，则使用系统当前的代码页（简体中文操作系统为CP936）。 1.2) 将源文件内容转成源字符集(Source Character Set)，默认为 UTF-8 编码。 第 2 步：链接 2.1) 将 1.2 中得到的 UTF-8 转为执行字符集(Execution Character Set)： 对于宽字符串（即 C/C++中以L标记的串，如L\"abc\", L'中'），执行字符集为 UTF-16 编码。 对于窄字符串（和宽字符串对应，即不以L标记的串），执行字符集为系统当前的代码页。 现在我们就可以说清楚 Visual Studio 字符集设置、char、wchar*t 是如何***间接_**影响到编译器对字符编码的处理了： 1234567Visual Studio字符集设置 |决定声明哪一个宏（UNICODE还是_MBCS宏） |宏又决定了API参数使用char还是wchar_t |编译器在进行【执行字符集】编码时对char和wchar_采用不同的处理方式，从而对字符编码产生了影响。 在 Visual Studio 2010（含）之后，支持使用#pragma execution_character_set来设置执行字符集。 四. 实例分析 已知汉字“中”的各种编码如下： 123GBK D6 D0Unicode 2D 4EUTF-8 E4 B8 AD 函数DumpCharacterCode用于按字节打印内存中的数据： 1234567void DumpCharacterCode(const char* pChar, int iSize) { for(int i = 0; i &lt; iSize; i++) { char a = *pChar++; printf(\"%02X \", a &amp; 0xff); } printf(\"\\n\");} 设置系统代码页的方法：“控制面板” –&gt; “区域和语言” –&gt; “管理” –&gt; “非 Unicode 程序的语言” –&gt; “更改系统区域设置” Visual Studio 保存文件到指定编码方法：“文件” –&gt; “高级保存选项” 4.1 测试编译器处理窄字符编码测试代码如下： 12345678int _tmain(int argc, _TCHAR* argv[]){ char buf[100] = {\"中\"}; // char DumpCharacterCode(buf, 2); // 也可以打印4个字节 return 0;} 针对不同的系统代码页和源文件编码，打印出的汉字“中”的编码分别为： 测试用例 系统代码页 保存源文件编码 编译器判断文件采用的编码 源字符集(Source Character Set) 执行字符集(Execution Character Set) 打印输出 用例 1 简体中文 CP936 简体中文 CP936 简体中文 CP936 UTF-8 简体中文 CP936 D6 D0 用例 2 简体中文 CP936 UTF-8 BOM UTF-8 BOM UTF-8 简体中文 CP936 D6 D0 用例 3 简体中文 CP936 UTF-8 简体中文 CP936 UTF-8 简体中文 CP936 编译错误(C2146) 用例 4 西欧 CP1252 简体中文 CP936 西欧 CP1252 UTF-8 西欧 CP1252 D6 D0 用例 5 西欧 CP1252 UTF-8 BOM UTF-8 BOM UTF-8 西欧 CP1252 3F 00 表格中列 4~6 依次对应编译处理源文件的几个步骤。3F对应的 ASCII 字符为?，编译器遇到不能识别的字符时，就会用?来替代。 出现?的情况会伴随着编译警告C4566。上面出现了 1 次3F（用例 5），导致乱码的原因是UTF-8 --&gt; 西欧 CP1252. 西欧 CP1252也就是 ASCII 的扩展，不支持汉字，所以用3F替代。 用例 3 为什么会编译错误？微软的编译器只能识别带 BOM 的 UTF-8，用例 3 的 UTF-8 没带 BOM，编译器会判定源文件编码为系统当前代码页 CP936。“中”的 UTF-8 编码为E4 B8 AD，列 5 执行从 CP936 到 UTF-8 转换之后变成了E6 B6 93 3F，列 6 再要将E6 B6 93 3F转换为 CP936 肯定是转换不回去的，相当于 UTF-8（1） –&gt; UTF-8 （2），再将 UTF-8（2）转换回 CP936，这时肯定得到的字符不是原来的字符了。 用例 4 为什么输出的D6 D0，而不是3F？对着用例 4 的各个顺序来看，源文件通过 CP936 保存着，但编译器通过 CP1252 来读取的，CP1252 就是 ASCII 扩展，单字节的，虽然此时显示为乱码，但各字节仍然是 D6 D0；然后将读取到的文件内容从 CP1252 转成 UTF-8 编码，转码后为 C3 96 C3 90；然后再将 UTF-8 编码转回为 CP1251，转码就又变成了 D6 D0。 但这个D6 D0在 CP1252 中是无法显示的，如果我们在用例 4 加入MessageBoxA(NULL, \"中\", \"test\", MB_OK); 会发现弹出的对话框中显示仍然是乱码。可以使用下面的代码进行测试： 1234567891011121314int _tmain(int argc, _TCHAR* argv[]){ char buf[3] = { 0 }; // 模拟CP936编码的“中” buf[0] = 0xD6; buf[1] = 0xD0; std::string strUTF8 = ANSIToUTF8(buf, 1252); char *p = (char*)strUTF8.c_str(); // 通过visual studio查看指针p处内存为： C3 96 C3 90 std::string str = UTF8ToANSI(strUTF8, 1252); p = (char*)str.c_str(); // 通过visual studio查看指针p处内存为： D6 D0 return 0;} 4.2 测试编译器处理宽字符编码测试代码如下： 12345678int _tmain(int argc, _TCHAR* argv[]){ wchar_t buf[100] = {L\"中\"}; // wchar_t DumpCharacterCode((char*)buf, 4); // 打印4个字节 return 0;} 同样，针对不同的系统代码页和源文件编码，打印出的汉字“中”的编码分别为： 测试用例 系统代码页 保存源文件编码 编译器判断文件采用的编码 源字符集(Source Character Set) 执行字符集(Execution Character Set) 打印输出 用例 1 简体中文 CP936 简体中文 CP936 简体中文 CP936 UTF-8 UTF-16 2D 4E 00 00 用例 2 简体中文 CP936 UTF-8 BOM UTF-8 BOM UTF-8 UTF-16 2D 4E 00 00 用例 3 简体中文 CP936 UTF-8 简体中文 CP936 UTF-8 UTF-16 编译错误(C2146) 用例 4 西欧 CP1252 简体中文 CP936 西欧 CP1252 UTF-8 UTF-16 D6 00 D0 00 大小端 用例 5 西欧 CP1252 UTF-8 BOM UTF-8 BOM UTF-8 UTF-16 2D 4E 00 00 五. 彻底避免硬编码字符乱码通过第 3 节的说明，很容易知道，要开发支持多语言，在任意语言（系统代码页）的 windows 环境下都正常编译，且运行起来没有乱码的程序，需要遵循如下原则： 代码文件采用 UTF-8 with BOM 编码。 Visual Studio 字符集设置为 Unicode 字符集。 使用 wchar_t。 做到上面 3 步，你的代码被别人从 github 上 clone 下来编译，不会因为你代码中含有中文等字符，产生类似error C2015这样的编译错误，更不会产生乱码。 本文介绍的方法只用来解决硬编码字符乱码的问题，至于数据传输中的乱码，需要统一字符编码来解决。 参考: https://blogs.msdn.microsoft.com/vcblog/2016/02/22/new-options-for-managing-character-sets-in-the-microsoft-cc-compiler 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/1337290471.html"},{"title":"拨开字符编码的迷雾(4)--MySQL字符编码","text":"一. MySQL 字符集和校对规则MySQL 的字符集是用来定义 MySQL 存储字符串的方式，校对规则（有的软件叫排序规则）则是用来定义了比较字符串的方式。字符集和校对规则是一对多的关系。每种字符集都有一个默认校对规则。 查看数据库支持的字符集: 123456# 方法1：SHOW CHARACTER SET;# 方法2：USE information_schema;SELECT * FROM CHARACTER_SETS; 查看数据库支持的校对规则： 123456# 方法1：SHOW COLLATION;# 方法2：USE information_schema;SELECT * FROM collations; 二. MySQL 各个级别字符集MySQL 可以对如下字符集进行设置： 服务器级字符集（CHARACTER_SET_SERVER） 数据库级字符集（CHARACTER_SET_DATABASE） 表级字符集 字段级字符集 连接字符集（CHARACTER_SET_CONNECTION），客户端连接数据库所用的字符集。 结果字符集（CHARACTER_SET_RESULTS），存储查询结果（含错误信息）所用的字符集。 客户端字符集（CHARACTER_SET_CLIENT），客户端发送给 MySQL 服务器的查询语句字符集。 系统字符集（CHARACTER_SET_SYSTEM），用于存储我们新建的或自带的数据库的表、列的名称，默认是 UTF-8 服务器级、数据库级、表级、字段级 这 4 个字符集设置影响到数据库中存储数据的编码。 这 4 个级别的字符集继承关系为：服务器级 --&gt; 数据库级 --&gt; 表级 --&gt; 字段级, 从左到右，一级继承一级，和 C++、Java 中的类的继承类似，如果某一级未显式的指定字符集，那么将继承上一级的字符集设置。 2.1 服务器级别字符集设置服务器级别的字符集可以从下面几个地方指定，从上到下优先级依次增加： 编译 MySQL 时指定的字符集 my.cnf 配置文件设置 character-set-server mysqld 服务启动命令行中指定字符集 影响数据存储的字符集之间的关系： 查看当前数据库的字符集设置： 123456# 方法1：SHOW VARIABLES LIKE '%character%';# 方法2：USE information_schema;SELECT * FROM GLOBAL_VARIABLES WHERE VARIABLE_NAME LIKE '%character%'; 3. utf8 与 utf8mb4 区别UTF-8 是多字节编码方案，采用 1~4 个字节来存储一个字符，但在 MySQL 设计之初，一个字符最多采用 3 个字节的就可以存储，所以 Mysql 的设计者将 MySQL 中的 UTF-8 字符集（UTF-8 其实不是字符集，是字符编码方案，但在 MySQL 中一直这么叫）设计成了最大长度只能为 3. 如图： 但随着 Unicode 字符集的扩张，出现了需要 4 个字节才能存储的字符，如果这时仍然使用 utf-8（指 mysql 中的 3 字节 utf-8）来存储这些字符就会出现错误，如执行INSERT INTO member(memberName)VALUES('𤭢')报错如下： 12Warning Code : 1366Incorrect string value: '\\xF0\\xA4\\xAD\\xA2' for column 'memberName' at row 1 于是 MySQL 后来新增了 utf8mb4 字符集，最大长度为 4，兼容之前的 utf8，但为了之前的数据库不报错，仍然保留了之前的 utf8 字符集。 所以 MySQL 中的 UTF-8 字符集是伪 UTF-8，现在需要使用 utf8mb4。 4. 完全避免字符乱码要完全避免字符乱码，最简单也是最好的方法就是将各个字符集保持一致，可以都设置为 utf8mb4。Mysql 数据存储涉及到的 4 个字符集的设置可以使用第 2 节的方法进行设置，客户端字符集、连接字符集，结果字符集关系到数据显示的正确性，可以使用如下语句统一设置为 utf8mb4，但这个设置只针对当前连接有效： 1set names utf8mb4; 编程开发中，一般使用 MySQL API 进行数据连接、查询等操作，可以使用mysql_set_character_set对每个连接进行设置，这个 API 会将客户端字符集、连接字符集，结果字符集都设置为指定字符集，代码大致如下： 123MYSQL* pMysql = NULL;mysql_real_connect(pMysql, szHost, szUser, szPwd, szDatabase, iPort, NULL, CLIENT_MULTI_STATEMENTS);mysql_set_character_set(pMysql, \"utf8mb4\"); 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/1559270845.html"},{"title":"Windows内存体系(1)--虚拟地址空间","text":"一、实模式下内存分配机制在 8086 或者 80186 以前，程序运行时，操作系统会把程序全都装入内存，程序都是直接运行在物理内存上的。也就是说程序中访问的内存地址都是实际的物理内存地址。当计算机同时运行多个程序时，必须保证这些程序用到的内存总量要小于计算机实际物理内存的大小。 例如某台计算机总的内存大小是128M ，现在同时运行两个程序 A 和 B ，A 需占用内存10M ， B 需占用内存110M 。计算机在给程序分配内存时会采取这样的方法：先将内存中的前10M分配给程序 A ，接着再从内存中剩余的118M中划分出 110M分配给程序 B 。这种分配方法虽然可以保证程序 A 和程序 B 都能运行，但是这种简单的内存分配策略会导致很多问题： 问题 1 ：进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意但有 bug 的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。这种情况对用户来说是无法容忍的，因为用户希望使用计算机的时候，其中一个任务失败了，不能影响其它的任务。 问题 2 ：内存使用效率低。在 A 和 B 都运行的情况下，如果用户又运行了程序 C ，而程序 C 需要 20M 大小的内存才能运行，而此时系统只剩下 8M 的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序 C 使用，然后再将程序 C 的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。 问题 3 ：程序运行的地址不确定。当内存中的剩余空间可以满足程序 C 的要求后，操作系统会在剩余空间中随机分配一段连续的 20M 大小的空间给程序 C 使用，因为是随机分配的，所以程序运行的地址是不确定的。 二、虚拟地址空间介绍操作系统让每个进程都有自己的虚拟地址空间（Virtual Address Space，简称VAS）。以 32 位进程为例，每个进程都有0x00000000 ~ 0xFFFFFFFF(4GB)的虚拟地址空间，所以每个进程都可能分配到0x123456地址的内存，但这个地址不能在进程间相互访问。 因为这些都是“虚拟”的地址空间，这些“地址”都不能直接使用，CPU 在寻址的时候虽然是按照虚拟地址来寻址的，但是还要通过MMU(内存管理单元)来将虚拟地址转换为物理存储器（如内存等）上的物理地址： 从图上可以看出，进程 A 和 B 虽然都有地址0x123456，但它们分别对应的物理地址不一样。 ##三、虚拟地址空间分区进程的虚拟地址空间虽然很大，但是它被划分成了很多分区，供 Ring3 层应用程序使用的用户模式分区并不大（一半不到），如图： 3.1 空指针赋值分区这一分区的进程地址空间的范围为：[0x00000000, 0x0000FFFF]，总大小为64K，保留该分区的目的是为了帮助应用程序员捕获对空指针的赋值。如malloc分配内存失败，就会返回NULL。 如果进程中的线程试图访问该分区内的内存地址，就会引发访问违规。 3.2 用户模式分区在 Windows 中，所有的 exe 和动态链接库都载入到这一区域。系统同时会把该进程可以访问的所有内存映射文件（后面会介绍）映射到这一分区。 进程无法通过指针来读取、写入、访问其他进程的这一分区，因此一个应用程序破坏另一个应用程序的可能性就非常小了，从而使整个系统更加坚固。 3.3 内核模式分区内核模式分区是操作系统代码的驻地。与线程调度、内存管理、文件系统支持、网络支持以及设备驱动程序相关的代码都会载入到这一分区。该分区内的代码和数据被完全的保护起来了，如果一个应用程序试图读取或写入位于这一分区的内存地址，会引发访问违规。 驻留在这一分区内的代码为所有进程共有。 四、虚拟地址空间的使用虚拟地址空间的使用涉及到 3 个概念：页面大小、分配粒度、预定和调拨。 4.1 页面大小虚拟地址空间被分成以“页面”为单位，因为硬件内存管理单元是以页面为粒度将虚拟地址转译成物理地址的。页面的大小根据不同的 CPU 不而有所不同。x86 和 x64 系统使用的页面大小都是4KB，而 IA-64 系统使用的页面大小是8KB。 IA-64 操作系统只能在 INTEL 安腾系列处理器及 AMD 部分服务器处理器运行，所以主流市场并不常见 当应用程序在虚拟地址空间分配空间时，系统需要确保分配区域的大小正好是系统页面大小的整数倍。 4.2 分配粒度当应用程序在从虚拟地址空间分配空间时，系统会确保所有分配区域的起始地址都是分配粒度的整数倍。分配粒度的会根据不同的 CPU 平台而有所不同，但目前所有的 CPU 平台的分配粒度都是使用64KB。也就是说，分配的起始地址 = 64 * N。 通过 Windows 的GetSystemInfo函数也可以获得此分配粒度值。 上面所说的分配粒度和页面大小的限制，只是针对于“应用程序”，系统内核自己不存在这样的限制。 4.3 预定和调拨虚拟地址空间的使用分为 2 个步骤： 预定（reserve）：告诉系统我们要从虚拟地址空间预定哪一块区域，系统为我们保留这一块区域。预定的局域的起始地址和大小遵循上面介绍的分配粒度和页面大小的要求。因为预定的只是虚拟地址空间，不占用任何其他物理存储器，所以没有形成实质的开销。 调拨（commit）：预定的区域还不能使用，我们还需要为预定的区域从页交换文件中调拨存储器，调拨之后我们才能使用该区域。至于为什么要从页交换文件中调拨存储器？ 页交换文件如何与物理内存之间交互？在下一篇文章Windows内存体系(2)--虚拟内存中会详细介绍。 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/2494475058.html"},{"title":"拨开字符编码的迷雾(5)--Qt字符编码","text":"我们以“测试字符串-보고싶다-Test String.”这个字符串来进行讲解，它包含了英文、中文和韩文。因为我使用 Qt 的方式是Visual Studio + Qt库的形式，所以本文以Visual Studio的MSVC编译器为例来进行讲解，但这种方式的原理也适用于其他编译器。 QString 中使用 QChar 来存储每一个字符，QChar 是 short 类型，占 2 个字节，默认按 Unicode 编码存储。 首先，为了保证写到代码文件中的测试字符串能被 MSVC 编译器理解，我们需要将源文件保存为Utf8-带签名的格式。具体参考：拨开字符编码的迷雾(2)--编译器处理文件编码 解决Qt程序乱码问题的关键在于理解QString中存储字符的编码格式。 QString 中存储的字符串的编码格式就是“编译器执行字符集编码格式”。 这一句话很关键。 在 MSVC 中我们可以使用#pragma execution_character_set(\"utf-8\")来指定该源文件的执行字符集编码格式为 UTF8 格式，这样 QString 中存储的字符串格式就是 utf8 编码了。 下面是完整的测试用例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void Demo01::qStringUseCase() { /* 该源文件使用Utf8-BOM格式保存. 源字符集为UTF8-BOM. 可执行字符集为UTF8：#pragma execution_character_set(\"utf-8\") 定义在stdafx.h. */#define TEST_STR_A \"测试字符串-보고싶다-Test String.\"#define TEST_STR_W L\"测试字符串-보고싶다-Test String.\" { // 因为可执行字符集是utf8，所以使用OutputDebugStringA需要转换成ANSI OutputDebugStringA(Utf8ToAnsi(TEST_STR_A).c_str()); } { ui.lblLanguage-&gt;setText(TEST_STR_A); } // char* --&gt; QString { QString qstr = TEST_STR_A; qInfo() &lt;&lt; qstr; } // QString --&gt; char*或std::string { QString qstr = TEST_STR_A; std::string str = qstr.toStdString(); // 不能直接使用qstr.toStdString().c_str()来获取，必须先将qstr.toStdString()存入std::string中 const char* pStr = str.c_str(); QString qstr2 = QString::fromUtf8(pStr); Q_ASSERT(qstr == qstr2); } // QString --&gt; wchar_t*或std::wstring { QString qstr = TEST_STR_A; std::wstring str = qstr.toStdWString(); const wchar_t * pStr = str.c_str(); QString qstr2 = QString::fromWCharArray(pStr); Q_ASSERT(qstr == qstr2); } // std::string --&gt; QString { std::string str = TEST_STR_A; // std::string中存储的是UTF-8编码的字符串，因为可执行字符集为UTF8 QString qstr = QString::fromStdString(str); } // std::wstring --&gt; QString { std::wstring str = TEST_STR_W; // std::wstring中存储的是UTF-8编码的字符串，因为可执行字符集为UTF8 QString qstr = QString::fromStdWString(str); }} QString::toLocal8BitQString 有一个名为toLocal8Bit的方法，网上很多介绍如何解决乱码的文章都会提到这个函数。关于这个函数官方的介绍如下： 12345Returns the local 8-bit representation of the string as a QByteArray. The returned byte array is undefined if the string contains characters not supported by the local 8-bit encoding.QTextCodec::codecForLocale() is used to perform the conversion from Unicode. If the locale encoding could not be determined, this function does the same as toLatin1().If this string contains any characters that cannot be encoded in the locale, the returned byte array is undefined. Those characters may be suppressed or replaced by another. 简单来说，我们可以理解为这个函数将字符串转换为的 ANSI 编码，通过拨开字符编码的迷雾(1)--字符编码概述介绍，我们应该知道ANSI是和具体的代码页相关联的（在 Windows 中文环境下默认代码页为 936）。Qt 不是根据系统代码页来做判断的，而是通过QTextCodec来做判断的，所以文档中会提到这个函数需要结合QTextCodec::codecForLocale()来使用，toLocal8Bit根据对应的QTextCodec来做相应的转换。 总结所以要想在使用 Qt 时，避免遇到中文乱码问题，只需要在预编译头文件中加入（对于不使用预编译头的项目可以在.cpp文件中添加）： 1#pragma execution_character_set(\"utf-8\") 同时由于部分韩文、日文等字符不在 Visual Studio 默认的中文 GB2312 编码中，所以如果遇到 Visual Studio 提示“此文件的某些 Unicode 字符未能保存到当前代码页中”时，这时应该选择”Utf8-带签名“格式来保存。 综上所述，源文件保存为Utf8-带签名，且设置#pragma execution_character_set(\"utf-8\") 就可以解决所有乱码问题。 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/1204594779.html"},{"title":"Windows内存体系(2)--虚拟内存","text":"一、页交换文件虚拟地址空间只是操作系统为进程“虚拟”出来的一块地址区域，并不代表任何实际的空间。而“页交换文件”却对应了实际的空间，这个空间一般是磁盘上名为“pagefile.sys”的文件。 “页交换文件”的大小和位置可以在系统设置（系统属性 -&gt; 高级 -&gt; 性能 -&gt; 设置 -&gt; 高级 ）中进行设置： 从微软的官方文档来看，“虚拟内存”等于“物理内存”+“分页文件”总和。可以把“虚拟内存”理解为 Windows 的一种内存管理机制。 二、虚拟地址空间、页交换文件、物理内存虚拟地址空间、页交换文件、物理内存三者的关系如下图： 《Windows 核心编程》第 13 章关于“物理存储器和页交换文件”章节中讲到了“页交换文件、物理存储器之间的数据交换过程”，流程如下： 应用程序从进程的虚拟地址空间预定并调拨了一块地址区域时，起初这块区域只是从“页交换文件”中调拨的，这样作有个好处就是：因为还不确定何时才会使用这块区域，如果立即从物理内存调拨，会将占用很多的物理内存。当程序读写该地址区域时，此时就会出现上面图上的页交换文件和物理内存之间的数据交换过程。 三、将页面锁定在物理内存从上面的几节我们知道，当物理内存中没有闲置页面时，系统会将内存中的某些页面的数据写入到交换文件中，从而将该物理内存区域释放出来供后面的程序使用。 我们可以通过调用VirtualLock方法，将页面锁定在物理内存中，从而防止虚拟内存管理机制将页面交换至页面文件，而引起不必要的硬盘和物理内存之间的低效页面交换。 也可以通过调用VirtualUnlock方法解锁页面，允许系统对页面进行交换操作。 需要注意的是，锁定页面时系统会根据当前可用实际物理内存情况，以及进程工作集配额判定当前最大可锁定的页面的实际数量，超过此数量会引起一个错误。我们可以调用SetProcessWorkingSetSize可以改变一个进程工作集大小的配额，从而可以锁定更多的物理页面。 四、虚拟内存使用实例虚拟内存方面的 API 属于页面粒度 API，通过这些 API 分配的内存的最小粒度是64KB。这些 API 分配（调拨）的内存区域最初都是位于“页交换文件”上面，当程序对该区域的某些“页面”（对虚拟内存的管理以页面为单位进行的）进行读写时，才会将这些页面交换到物理内存上面。 从Windows内存体系(1)--虚拟地址空间中我们知道虚拟地址空间要经过预定和调拨2 个步骤之后才能使用，这 2 个步骤都可以通过VirtualAlloc函数实现： 123456LPVOID VirtualAlloc( LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect); 当预定或者调拨的空间我们不在需要时，我们需要调用VirtualFree来释放该地址空间： 12345BOOL VirtualFree( LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType); 下面是的示例演示了在预定、调拨、使用等操作前后，进程的各项内存的占用情况： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;windows.h&gt;int main(){ SIZE_T size = 1 &lt;&lt; 30; // 1GB // 预定1GB的空间 char *pVirtualAddress = (char *)VirtualAlloc(NULL, size, MEM_RESERVE, PAGE_READWRITE); if (pVirtualAddress == NULL) { printf(\"Reserve 1GB failed.\\n\"); return 1; } // 验证分配粒度是不是64KB int n = (long)pVirtualAddress % (64*1024); if (n == 0) { printf(\"分配粒度为64K\\n\"); } printf(\"已经预定1GB\\n\"); getchar(); // 暂停 if (VirtualAlloc(pVirtualAddress, size, MEM_COMMIT, PAGE_READWRITE) == NULL) { printf(\"Commit 1GB failed.\\n\"); return 1; } printf(\"已经调拨1GB\\n\"); getchar(); // 暂停 // 页面大小为4K，访问2560个页面，即2560*4K = 10MB // for (int i = 0; i &lt; 2560; i++) { char * p = pVirtualAddress + i * (4 * 1024); *p = 'A'; // 只访问每个页面的第一个字节 } printf(\"已经使用前10MB\\n\"); getchar(); // 暂停 return 0;} 在程序运行各个阶段进程的内存情况如下图：（“内存专用工作集”表示占用的物理内存的大小，“提交大小”表示调拨的页交换文件的大小） 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/595856315.html"},{"title":"Windows内存体系(3)--内存映射文件","text":"一、为什么需要内存映射“内存映射文件”可以将硬盘上的文件映射到虚拟地址空间，这样就不需要将所有东西都放入到页交换文件中，比如系统有许多程序同时运行时，如果将这些程序文件都加载到页交换文件中，页交换文件将会变得非常大。事实上，Windows 也并没有将硬盘上的程序文件复制到页交换文件中，因为这样不仅会让页交换文件将会变得非常大，也会浪费很多时间，特别是可执行程序非常大的时候。 当用户要求执行一个应用程序时，系统会打开该应用程序的.exe文件，并计算出应用程序的代码和数据的大小，然后系统会在进程的虚拟地址空间预定一块地址空间，并注明与该区域相关联的物理存储器就是.exe文件本身。 当把一个位于硬盘上的文件（可以是.exe，.dll也可以是普通文件）映像用作地址空间区域对应的物理存储器时，我们称这个文件映像为“内存映射文件”。 现在我们可以对Windows内存体系(2)--虚拟内存第 2 节的图进行完善了，加入“内存映射文件”部分： 二、内存映射文件技术介绍常用的有 Win32 API 的CreateFile()、WriteFile()、ReadFile()和 MFC 提供的CFile类都可以实现文件的读写操作。一般来说，以上这些函数可以满足大多数场合的要求，但是对于某些特殊应用领域所需要的动辄几十 GB、几百 GB、乃至几 TB 的海量存储，此时在以平常的文件处理方法进行处理显然是行不通的（效率低下，而且内存没那么大）。目前，对于这种大文件的操作一般是以内存映射文件的方式来加以处理的。 内存映射文件也是 Windows 的一种内存管理方法，提供了一个统一的内存管理特征，使应用程序可以通过内存指针对磁盘上的文件进行访问。通过文件映射将磁盘文件内容（全部或者部分）与进程虚拟地址空间的某个区域建立映射关联，可以直接对被映射的文件进行访问，而不必执行文件 I/O 操作也无需对文件内容进行缓冲处理。内存文件映射的这种特性是非常适合于用来管理大尺寸文件的。 三、大文件读写实例通过 C++调用系统 API 实现文件映射的步骤大致如下： 本示例首先在D:\\生成一个大小为 1GB 的BigFile.data文件，然后使用内存映射技术将该文件内全部填充字符 A，随后读取其中的第20000~20100字节，并将这些字节修改为字符 B，然后再次读取已验证是否修改成功。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;windows.h&gt;void Test() { HANDLE file_ = CreateFile(TEXT(\"D:\\\\BigFile.data\"), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (file_ == INVALID_HANDLE_VALUE) { printf(\"CreateFile failed, GLE:%d\\n\", GetLastError()); return; } LARGE_INTEGER filesize; filesize.QuadPart = 1024 * 1024 * 1024; // 1GB HANDLE mapping_ = CreateFileMapping(file_, NULL, PAGE_READWRITE, filesize.HighPart, filesize.LowPart, NULL); if (mapping_ == NULL) { printf(\"CreateFileMapping failed, GLE:%d\\n\", GetLastError()); return; } LARGE_INTEGER offset; offset.QuadPart = 0; LPVOID mapping_addr = MapViewOfFile(mapping_, FILE_MAP_WRITE | FILE_MAP_READ, offset.HighPart, offset.LowPart, 0); if (mapping_addr == NULL) { printf(\"MapViewOfFile failed, GLE:%d\\n\", GetLastError()); return; } // 向文件中填充1GB的字符'A' // char buf[1024]; for (int i = 0; i &lt; 1024; i++) { buf[i] = 'A'; } // 每次填充1024字节，填充1024*1024次 for (long l = 0; l &lt; 1024 * 1024; l++) { memcpy((LPVOID)((long)mapping_addr + l * 1024), buf, 1024); } // 填充完毕 // 读取第20000~20100字节，共100字节 // char read_content[101] = { 0 }; memcpy(read_content, (LPVOID)((long)mapping_addr + 20000), 100); printf(\"%s\\n\", read_content); // 将第20000~20100字节，共100字节全部修改为字符'B' // char write_content[100]; for (int i = 0; i &lt; 100; i++) { write_content[i] = 'B'; } memcpy((LPVOID)((long)mapping_addr + 20000), write_content, 100); // 再次读取第20000~20100字节，共100字节，验证修改是成功 // memcpy(read_content, (LPVOID)((long)mapping_addr + 20000), 100); printf(\"%s\\n\", read_content); UnmapViewOfFile(mapping_addr); CloseHandle(mapping_); CloseHandle(file_); return;}int main(){ Test(); return 0;} 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/3938269003.html"},{"title":"Windows内存体系(4)--内存对齐","text":"一、内存为什么要对齐虽然所有的变量都是保存在特定地址的内存中，但最好还是按照内存对齐的要求来存储。这主要出于两个方面的原因考虑： 平台原因：不是所有的硬件平台(特别是嵌入式系统中使用的低端处理器)都能访问任意地址上的任意数据，某些硬件平台只能访问对齐的地址，否则会出现硬件异常。 性能原因：如果数据存放在未对齐的内存空间中，则处理器访问变量时需要进行两次内存访问才能完整读取该变量的值，而对齐的内存访问仅需一次访问。 二、内存对齐的规则 对于结构（或联合）的各个成员，第一个成员位于偏移为 0，以后每个数据成员的偏移量必须是#pragma pack指定的数值和结构体(或联合)中最大数据成员长度 这2个数值中较小的一个的倍数。使用伪代码表示： min(#pragma pack, 结构最大数据成员长度) * N 在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐也按照#pragma pack指定的数值和结构(或联合)最大数据成员长度这2个数值中较小的一个进行。 如果没有使用#pragma pack指令来显式的指定内存对齐的字节数，则按照默认字节数来对齐，各个平台的默认对齐规则如下：32位CPU默认按照4字节对齐；64位CPU默认按照8字节对齐。 三、#pragma pack 命令123#pragma pack(n) // 使用自定义n字节对齐 n可以为1，2，4，8，16#pragma pack() // 使用缺省字节对齐#pragma pack(show) // 在编译输出窗口以警告的形式显示出当前的内存以几个字节对齐 四、结构体内存对齐示例在 64 位系统上编译下面的测试程序，已知在 64 位系统上各类型占用字节数如下： 123456char 1字节short 2字节int 4字节long 4字节double 8字节long long 8字节 示例代码如下： 123456789101112131415#pragma pack(8)struct A { char s[5]; short c; int a;};int main(){ int i = sizeof(A); printf(\"%d\", i); return 0;} 按照第二节所讲的内存对齐规则，分析如下：因为结构体中最大的数据成员长度为 int（即 4 字节），而且#pragma pack(8)指令指定按照 8 字节对齐，所以min(4,8) = 4，故我们可以知道结构体 A 按照 4 字节对齐。 下图是结构体 A 按照 4 字节对齐的内存布局（需要注意的是“内存不是填充在 s5 后面，而是填充在 c 后面”）： 从图我们很容易知道sizeof(A) = 12. 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/4245522728.html"},{"title":"Windows内存体系(6)--跨模块内存分配释放","text":"在《Windows核心编程 第五版》第19章 DLL基础（511页）中给出了一个建议： “当一个 MT 版本的模块如果提供一个内存分配函数的时候，它必须同时提供另一个用来释放内存的函数。”。 说得更加直白一点就是，“对于 MT 的模块，不要跨模块进行内存释放。”。但是核心编程这本书上面没有具体分析原因，本文就来分析具体的原因。 一、不同堆分配的内存块不能相互释放Windows 的堆管理器对每个进程都维护了多个“堆”，我们从每个“堆”中分配处理的内存块的地址都不一样。所以我们不能将从“堆 A”中分配出来的内存块拿到“堆 B”中，让“堆 B”来释放，这样就会导致程序异常。 如上图，通过malloc函数从“堆 A”中分配 100 字节内存块，内存块地址为0x123456；从“堆 B”中分配 100 字节内存块，内存块地址为0x345678.如果将0x123456这个地址拿到“堆 B”中去释放，势必会导致异常，因为“堆 B”中没有这地址。 那么我们是不是可以使用HeapFree函数来释放hHeap参数指定的“堆”中的任何内存块了。答案是：不能。回忆前面介绍的HeapFree函数， 12345BOOL HeapFree( HANDLE hHeap, DWORD dwFlags, LPVOID lpMem); 这个函数只要求传入了内存块的起始地址指针，但没有要求传入需要释放的内存块的大小，那么该函数是如何知道起始地址指针指向的内存块的大小了？ 我们可以简单的理解为，HeapAlloc函数每次分配内存块的时候都会额外分配一点空间用于存储一个结构体，该结构体中存储了本次分配的内存块的大小等信息。大致如下图： 所以，HeapFree函数首先会通过lpMem指针计算出“结构体”的地址，然后从结构体中获取到分配的内存块的具体大小，最后执行释放操作。 基于上面的原因，我们不能在HeapFree函数的lpMem参数中传入随意的地址，因为该地址处可能没有存储用于存放内存块信息的结构体，所以释放操作就会失败。free函数也一样，因为free函数内部也是调用的HeapFree函数。 二、MD 模块内存可以相互释放为什么 MD模块内存可以相互释放，而MT模块的却不可以了？ 2.1 MT 模块内存相互释放会崩溃我们先分析为什么 MT 模块的内存间相互释放会崩溃？ 现在有 2 个模块（A.dll和B.dll）都是使用MT运行时库，即加载的静态库libcmt.lib（可以参考理解C/C++运行时库），在A.dll中使用malloc分配 100 字节的内存，malloc返回的内存地址为0x123456。然后将该地址传给B.dll，在B.dll中调用free函数来释放这个内存。如图： 从Windows内存体系(5)--堆我们知道，DLL 在启动代码_DllMainCRTStartup中会建立一个“堆”（堆句柄存放在_crtheap 变量中），所以 A.dll 和 B.dll 中都会有一个 crt 堆。 为了区分，我们将A.dll中的crt堆称作_crtheap_A，B.dll中的crt堆称作_crtheap_B。 从上面图可以看到，A.dll中malloc的内存拿到B.dll去中去free，就相当于从堆_crtheap_A中分配的内存拿到另一个堆_crtheap_B中的释放。第一节已经解释了为什么不能这样做了。 2.2 MD 模块内存相互释放不会崩溃现在我们分析为什么 MD 模块的内存间相互释放不会崩溃。 还是 2 个模块（A.dll和B.dll），但是现在他们都是使用MD运行时库，即加载的动态库msvcr100.dll，程序的代码的过程和上面一样，还是在A.dll中使用malloc分配 100 字节的内存，malloc返回的内存地址为0x123456。然后将该地址传给B.dll，在B.dll中调用free函数来释放这个内存。但是这个时候程序却不会崩溃，通过下面的图我们基本可以明白原因了，如图： 因为 A、B 两个 dll 都是链接的·msvcr100.dll·，同一个 dll 在一个进程只会被加载一次，所以进程中只会有一个 crt 堆（_crtheap），malloc和free都是运行时库提供的函数，所以都会调到运行时库里面去，然后从运行时库里面的_crtheap分配和释放内存块。因为分配和释放都是在同一个堆上，所以不会崩溃。 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/213040252.html"},{"title":"Windows内存体系(5)--堆","text":"一、为什么要使用堆 (Heap)？应用程序虽然可以使用页面粒度的函数（如VirualAlloc）来分配一个最小为4KB或8K的内存块，但是很多时候我们并不需要分配这么大的内存块，我们可能只想分配 1K，2K 的内存块，那么这个时候无论从内存的使用率，还是从性能的角度来看，再分配这么大的一个内存区域显然不是最优的了。 为了满足这种需求，Windows 提供了一个被称为“堆管理器”的组件，它负责管理大内存区域中的内存分配，这些大内存区域就是通过一些页面粒度的内存分配函数（如VirualAlloc）来预定（reserve）的。 堆管理器中的分配粒度相对比较小：在32位系统上是8字节，在64位系统上是16字节。 堆管理器已经被 Windows 系统精心设计，在这些小内存分配的情况下会进行内存使用率和性能两个方面的优化。 二、进程的默认堆每个进程至少有一个堆，那就是进程的默认堆。进程的默认堆是在进程启动的时候创建的，而且在进程的生命周期中永远不会被删除。 “默认堆”的默认大小为1MB，但是可以通过/HEAP链接器编译器选项来指定一个更大的起始大小。这个大小值只是初始的保留内存大小，后期根据需要它可以自动扩充。 应用程序可以调用GetProcessHeap来获取进程的默认堆，也可以通过调用HeapCreate函数来创建额外的私有堆，当一个进程不在需要一个私有堆的时候，它可以调用HeapDestory来释放虚拟地址空间。 三、crt 堆C 语言的malloc,free函数以及 C++的new,delete都是从堆上分配和释放内存的。但是他们所使用的堆不是进程的默认堆，他们使用的是私有堆。可是我们在使用malloc函数之前并有进行任何私有堆的创建操作呀？ 因为malloc函数使用的这个私有堆不需要程序员来创建，而是在 C 或 C++运行时库 DLL 的启动代码_DllMainCRTStartup中自动创建的。下面通过解析malloc函数的调用过程来说明这一点。 malloc函数的定义在malloc.c文件中，调用流程如下：（以Microsoft Visual Studio 10.0为例，malloc.c文件路径为C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\crt\\src） 123(1). void* __cdecl malloc(size_t const size)(2). void * __cdecl _malloc_base (size_t size)(3). void * __cdecl _heap_alloc (size_t size) _heap_alloc 的定义如下： 12345678910__forceinline void * __cdecl _heap_alloc (size_t size){ if (_crtheap == 0) { _FF_MSGBANNER(); /* write run-time error banner */ _NMSG_WRITE(_RT_CRT_NOTINIT); /* write message */ __crtExitProcess(255); /* normally _exit(255) */ } return HeapAlloc(_crtheap, 0, size ? size : 1);} 从上面的代码中，我们可以看到分配内存块的时候使用的是_crtheap句柄标记的堆。那么_crtheap堆是何时创建的了？ 我们从heapinit.c文件中的_heap_init函数可以看到_crtheap堆的创建过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445HANDLE _crtheap=NULL;/****_heap_init() - Initialize the heap**Purpose:* Setup the initial C library heap.** NOTES:* (1) This routine should only be called once!* (2) This routine must be called before any other heap requests.**Entry:* &lt;void&gt;*Exit:* Returns 1 if successful, 0 otherwise.**Exceptions:* If heap cannot be initialized, the program will be terminated* with a fatal runtime error.********************************************************************************/int __cdecl _heap_init (void){ ULONG HeapType = 2; // Initialize the \"big-block\" heap first. if ( (_crtheap = HeapCreate(0, BYTES_PER_PAGE, 0)) == NULL ) return 0;#ifdef _WIN64 // Enable the Low Fragmentation Heap by default on Windows XP and // Windows Server 2003. It's the 8 byte overhead heap, and has // generally better performance charateristics than standard heap, // particularly for apps that perform lots of small allocations. if (LOBYTE(GetVersion()) &lt; 6) { HeapSetInformation(_crtheap, HeapCompatibilityInformation, &amp;HeapType, sizeof(HeapType)); }#endif /* _WIN64 */ return 1;} 从上面的代码，我们可以看到，创建的私有堆句柄存放在一个全局的_crtheap变量中，后面每次调用malloc函数都是从该堆分配内存块。 四、Win32 堆函数我们最常用的 Windows 堆函数如下： HeapCreate或HeapDestory — 创建或删除一个私有堆 HeapAlloc — 分配一个堆内存块 HeapFree — 释放一个原先由HeapAlloc分配的内存块 HeapReAlloc — 增长或缩减一个已分配的内存块的大小 HeapLock或HeapUnLock — 控制堆操作的内存访问 HeapWalk — 列举一个堆内部的内存项和区域。 五、Windows 内存管理 API 分层结构 从上图可以看到，虚拟内存机制（Virtual Memory）是 windows 内存体系的基础，无论你是使用堆，还是使用内存映射文件，它们的底层都是基于虚拟内存来实现的。 从上往下，每一层的 API 在内部会依次调用下一层的 API。下图中列举了每层 API 中经常使用的函数： CRT Memory Functions：malloc, free, new, delete Local, Global Memory API: ** LocalAlloc, GlobalAlloc （这 2 个函数现在不建议使用，注意是为了兼容以前的老代码才保留下来的**） Heap Memory API：HeapCreate, HeapAlloc, HeapDestory Virtual Memory API：VirtualAlloc, VirtualFree Memory Mapped File API：CreateFileMapping, MapViewOfFile, MapViewOfFileEx, UnMapViewOfFile 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/3599385732.html"},{"title":"Windows内存体系(7)--使用std::string跨MT模块传参","text":"前面的Windows内存体系(6)--跨模块内存分配释放文章解释了跨 MT 模块分配的内存相互释放为什么会崩溃的问题，本文介绍如何解决该问题。 一、问题描述这篇文章主要介绍我们在实际开发中经常遇到的一个问题：针对 MT 模块定义接口函数时，接口参数使用std::string类型，在程序运行时遇到\"Debug Assertioni Failed\"错误的问题。 上面的错误提示是debug_heap.cpp文件中的一个调试断言（release模式下调用的是heap.cpp中的分配函数），用于判断指针是否指向堆分配的内存块的第一块。在 release 模式下不会弹出这样的断言错误，程序可能会直接崩溃（崩溃相对来说还比较好排查），或者出现其他不可预料的、难以排查的错误。 二、实例现有DLLUser.exe调用DLL.dll中的TestFun函数，代码量非常小： DLL.dll中TestFun函数定义：1234DLL_API void TestFun( std::string str){ return;} DLLUser.exe中调用TestFun函数：123456789int _tmain(int argc, _TCHAR* argv[]){ std::string str = \"test\"; TestFun(str); return 0;} 上面的代码运行之后程序就会弹出错误断言。原因是std::string在进行值传参的过程中会执行一次深拷贝，即：在堆上分配内存块，拷贝“test”到内存块中，然后将临时形参std::string对象传递到 dll 中，dll 中的TestFun函数在作用域结束后对临时形参进行释放时就出现了错误，因为尝试在dll的crt堆中释放由在exe的crt堆中分配的内存块。 三、自定义std::allocator通过上面问题的分析，加上前面几篇文章对 Windows 内存体系的介绍，我们不难想出解决方案，其中一种方案就是：让std::string统一在进程的默认堆上分配内存块，而不是在各个模块的crt堆上分配。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;windows.h&gt;#include &lt;string&gt;#include &lt;vector&gt;template &lt;typename T&gt;class vm_allocator : public std::allocator&lt;T&gt; {public: typedef size_t size_type; typedef T* pointer; typedef const T* const_pointer; template&lt;typename _Tp1&gt; struct rebind { typedef vm_allocator&lt;_Tp1&gt; other; }; pointer allocate(size_type n, const void *hint = 0) { UNREFERENCED_PARAMETER(hint); void* pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, n * sizeof(T)); return (pointer)pBuffer; } void deallocate(pointer p, size_type n) { UNREFERENCED_PARAMETER(n); if (p) { HeapFree(GetProcessHeap(), 0, p); } } vm_allocator() throw() : std::allocator&lt;T&gt;() { } vm_allocator(const vm_allocator &amp;a) throw() : std::allocator&lt;T&gt;(a) { } template &lt;class U&gt; vm_allocator(const vm_allocator&lt;U&gt; &amp;a) throw() : std::allocator&lt;T&gt;(a) { } ~vm_allocator() throw() { }};typedef std::basic_string&lt;char, std::char_traits&lt;char&gt;, vm_allocator&lt;char&gt; &gt; mystring; 上面的代码使用自定义的内存分配器vm_allocator&lt;char&gt;定义了mystring类，我们只需要将TestFun函数接口中的std::string修改为mystring即可解决崩溃问题。 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/3937624737.html"},{"title":"《Windows内存体系》","text":"力求全面的介绍在 Ring3 层开发过程中需要了解的 Windows 内存体系方面的知识。 文章列表： Windows内存体系(1)--虚拟地址空间 Windows内存体系(2)--虚拟内存 Windows内存体系(3)--内存映射文件 Windows内存体系(4)--内存对齐 Windows内存体系(5)--堆 Windows内存体系(6)--跨模块内存分配释放 Windows内存体系(7)--使用std::string跨MT模块传参","link":"/post/3219980417.html"},{"title":"MySQL的DECLARE...HANDLER使用","text":"一、 功能DECLARE...HANDLER语法如下： 123DECLARE handler_action HANDLER FOR condition_value [, condition_value] ... statement 功能概括起来就是：在一个或者多个condition_value条件满足时，先执行statement语句，然后执行handler_action动作。 二、 参数解释2.1 statementstatement语句可以是一行简单的SQL语句，如SET var_name = value，也可以是多行复杂的的SQL语句，但多行SQL语句需要使用BEGIN和END包围。 简单statement： 1DECLARE CONTINUE HANDLER FOR 1051 SET result = 0; 复杂的statement： 1234DECLARE CONTINUE HANDLER FOR 1051BEGIN -- body of handlerEND; 2.2 handler_actionhandler_action的取值如下： CONTINUE：表示继续执行当前SQL脚本。 EXIT：表示终止执行当前SQL脚本。即使condition_value（见2.3）由statement语句的BEGIN...AND语句块引发，也是一样会终止执行。 2.3 condition_valuecondition_value的取值可以为如下几种： ● mysql_error_code：MySQL的错误码，整数类型。 1234DECLARE CONTINUE HANDLER FOR 1051BEGIN -- body of handlerEND; MySQL错误码取值见:https://dev.mysql.com/doc/refman/5.7/en/error-messages-server.html ● SQLSTATE ：用5个字符表示的SQLSTATE值。 1234DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'BEGIN -- body of handlerEND; 以'00'开始的值表示成功。SQLSTATE的完整取值列表见:https://dev.mysql.com/doc/refman/5.7/en/error-messages-server.html ● condition_name：使用DECLARE ... CONDITION定义的条件的名称。 如何使用DECLARE ... CONDITION定义条件，见：https://dev.mysql.com/doc/refman/5.7/en/declare-condition.html ● SQLWARNING：相当于值从'01'开始的SQLSTATE 。● NOT FOUND：相当于值从'02'开始的SQLSTATE 。● SQLEXCEPTION：相当于值不为'00','01','02'的所有 SQLSTATE。 参考文档: https://dev.mysql.com/doc/refman/5.7/en/declare-handler.html","link":"/post/3457369310.html"},{"title":"MySQL获取字符串长度的几种方式","text":"常用函数有char_length、length、bit_length，它们针对不同的字符编码处理方式不一样。总的来说：char_length字符显示的个数；length 字符在当前编码下存储，所占的字节数。bit_length 字符在当前编码下存储，所占的bit，也就是length*8 GBK 编码1234567select char_length('中国'); -- 2select length('中国'); -- 4select length('china'); -- 5select bit_length('中国'); --32 UTF-8 编码1234567select char_length('中国'); -- 2select length('中国'); -- 6select length('china'); -- 5select bit_length('中国'); -- 48","link":"/post/1446858454.html"},{"title":"MySQL获取时间和日期","text":"一、 时间、日期获取1.1 获取当前本地的日期和时间123456SELECT NOW(), CURRENT_TIMESTAMP(), LOCALTIME(), LOCALTIMESTAMP(), SYSDATE(); 上面5个函数都可以获取当前本地时间，但SYSDATE有所不同。 1SELECT NOW(), SLEEP(3), NOW(); 执行结果： 12NOW() sleep(3) NOW()2017-11-09 17:21:09 0 2017-11-09 17:21:09 虽然sleep了3秒，但NOW()前后2次获取到时间是一样的，也就是说NOW()函数获取的时间是在整个SQL语句开始执行时的时间，无论SQL语句中有多少个NOW()函数，获取到的时间都是一样的。CURRENT_TIMESTAMP(), LOCALTIME(), LOCALTIMESTAMP()和NOW()函数一样。 但SYSDATE不同，它获取到的是SYSDATE()函数执行时的实时时间： 1SELECT SYSDATE(), SLEEP(3), SYSDATE(); 执行结果： 12SYSDATE() sleep(3) SYSDATE()2017-11-09 17:25:05 0 2017-11-09 17:25:08 1.2 获取当前本地的日期123SELECT CURDATE(), CURRENT_DATE(); 1.3 获取当前本地的时间123SELECT CURTIME(), CURRENT_TIME(); 1.4 获取当前UTC日期和时间12SELECT UTC_TIMESTAMP(); 1.5 获取当前UTC日期12SELECT UTC_DATE(); 1.6 获取当前UTC时间12SELECT UTC_TIME(); 1.7 获取时间戳（自1970年经过的秒）12SELECT UNIX_TIMESTAMP(); -- 当前时间时间戳SELECT UNIX_TIMESTAMP('2017-11-09 12:30:00'); -- 自1970年到2017-11-09 12:30:00经过的秒数 二、 时间操作2.1 从字符串提取时间和日期12345678910111213SET @dt = '2008-09-10 07:15:30.123456';SELECT DATE(@dt); -- 2008-09-10SELECT TIME(@dt); -- 07:15:30.123456SELECT YEAR(@dt); -- 2008SELECT QUARTER(@dt); -- 3SELECT MONTH(@dt); -- 9SELECT WEEK(@dt); -- 36SELECT DAY(@dt); -- 10SELECT HOUR(@dt); -- 7SELECT MINUTE(@dt); -- 15SELECT SECOND(@dt); -- 30SELECT MICROSECOND(@dt); -- 123456 2.2 获取某天在周、月、年中所处位置12345SET @dt = '2017-11-09';SELECT DAYOFWEEK(@dt); -- 5 星期日为0，5代表星期四SELECT DAYOFMONTH(@dt); -- 9 一个月的第9天SELECT DAYOFYEAR(@dt); -- 313 2017年的第313天 2.3 获取指定日期的最后一天1SELECT LAST_DAY('2017-02-05'); -- 2017-02-28 2.4 时间加减123456789101112SET @dt = \"2017-11-09 17:10:20.0000001\";SELECT DATE_ADD(@dt, INTERVAL 1 DAY); -- 加1天SELECT DATE_ADD(@dt, INTERVAL 2 HOUR); -- 加2小时SELECT DATE_ADD(@dt, INTERVAL 1 MINUTE); -- 加1分钟SELECT DATE_ADD(@dt, INTERVAL 1 SECOND);SELECT DATE_ADD(@dt, INTERVAL 1 MICROSECOND); -- 加1微妙SELECT DATE_ADD(@dt, INTERVAL 1 WEEK); -- 加1周SELECT DATE_ADD(@dt, INTERVAL 1 MONTH);SELECT DATE_ADD(@dt, INTERVAL 1 QUARTER); -- 加1个季度SELECT DATE_ADD(@dt, INTERVAL 1 YEAR);SELECT DATE_ADD(@dt, INTERVAL -1 DAY); -- 减1天 2.5 两个日期、时间加减12SELECT DATEDIFF('2008-08-08', '2008-08-01'); -- 7SELECT DATEDIFF('2008-08-01', '2008-08-08'); -- -7 第一个参数减去第二个参数 12SELECT TIMEDIFF('2008-08-08 08:08:08', '2008-08-08 00:00:00'); -- 08:08:08SELECT TIMEDIFF('00:00:00', '08:08:08'); -- -08:08:08 2.6 时间格式化123SELECT DATE_FORMAT('2008-08-08 22:23:00', '%W %M %Y'); -- Friday August 2008SELECT DATE_FORMAT('2008-08-08 22:23:01', '%Y%m%d%H%i%s'); -- 20080808222301SELECT TIME_FORMAT('22:23:01', '%H.%i.%s'); -- 22.23.01 2.7 秒计算计算指定时间折合多少秒，如00:01:00表示1分钟，等于60秒。 12SELECT TIME_TO_SEC('01:00:05'); -- 3605SELECT SEC_TO_TIME(3605); -- '01:00:05'","link":"/post/3556253141.html"},{"title":"SQL批量添加更新和删除","text":"批量插入1INSERT INTO users(name, age) VALUES('姚明', 25), ('比尔.盖茨', 50), ('火星人', 600); 批量更新1UPDATE member SET descipt = \"默认\" WHERE usertypeid IN (1,2,3,4); 1234567UPDATE member SET descipt = CASE id WHEN 1 THEN '默认' WHEN 2 THEN '黄铜' WHEN 3 THEN '黄金' END WHERE id IN (1,2,3); 批量删除1DELETE FROM users WHERE id IN (1,2,3,4);","link":"/post/2842059394.html"},{"title":"🐉2024龙行龘龘","text":"写下这一行预示着2024年的工作开始了，加油！ 物来顺应，未来不迎。 当时不杂，既过不恋。","link":"/post/1391804423.html"},{"title":"白酒入门","text":"正值 9 月 9 全球酒水节，各大电商都在做活动，趁机网购了一批酒水。在享受这大自然馈赠的礼物的同时，也说一说自己对白酒的理解。希望在了解了白酒的这些知识后能明明白白喝酒。 1. 白酒酿造工艺1.1 粮食酒与勾兑酒首先，所有的白酒都是粮食经过发酵、蒸馏而成的，也就是我们常说的粮食酒，这也印证了人们常说的“酒是粮食精，越喝越年轻”这句话。 因为白酒都要经过蒸馏这个步骤，所以我们也称白酒为“蒸馏酒”。 但我们常提到的“非粮食酒”指的是用食用酒精（有的甚至用的工业酒精）勾兑而成的酒，我认为这种酒严格意义上可以称为“假酒”(虽然使用食用酒精勾兑在法律上是被允许的，也就是后面提到的液态发酵酒。法律禁止使用工业酒精勾兑酒)，喝了之后对人体没有任何好处，最多只能麻痹神经（工业酒精勾兑的酒是绝对不能喝的，工业酒精成份是甲醇，少量就会使人失明或者致命）。 很多人对“勾兑”二字很敏感，认为凡是勾兑的酒都不是好酒，这个观点是错误的。 下面介绍白酒的酿造工艺时会说到，粮食等最初经过发酵、蒸馏形成的酒叫“原浆”，原浆的酒精度数一般在 70 度左右，是无法直接饮用的，需要降低其度数才能饮用。 如果在市面上看到如“茅台镇粮食原浆酒”等这样的“原浆酒”，但度数低于 70 度(左右)的，都不是真正的原浆酒。这样的商家要么是不诚信，要么就是不专业。 降低度数不是直接往酒里面掺水，这样口感会非常差，而且会使酒体变浑浊。 需要专门的白酒勾兑工艺，白酒勾兑一门很复杂的学科，勾兑主要是将不同的原料、不同窖池、不同环节、不同年份的酒进行调配，从而产生具有不同口味、香型的白酒。 标准的白酒勾兑工艺中是不允许添加化学添加剂的，白酒的口味、香型都是自然形成的。 我们可以认为市面上所有的酒都是“勾兑酒”，只是每种酒勾兑所用的原料、工艺不相同，茅台、五粮液、汾酒等无一例外也是勾兑而成的。好酒采用“酒勾兑酒”的方式，差酒采用“酒精勾兑水”或者“酒精+香精+添加剂勾兑水”的方式。 1.2 酿造工艺1.2.1 纯粮固态发酵、液态发酵白酒在酿造工艺上分为纯粮固态发酵和液态发酵 2 种。 纯粮固态发酵酒是通过粮食+曲+发酵+陈酿+勾兑等几个环节制成的。 液态发酵酒是用甘蔗和甜菜渣、薯干、玉米等（这几种植物发酵周期短、出酒率高、酒质差）制造出来的食用酒精为基础酒，加入增香调味物质模拟传统粮食白酒的口感，经调配而成的液态白酒，行话叫“三精一水”，即食用酒精、香精、糖精、水。 由于纯粮固态发酵工艺所遵循的都是自然的酿造规律，加之曲、老窖中微生物的作用，酒体中除了乙醇外，还蕴含了丰富的己酸、乙酯等营养成分。酸是白酒中的重要呈味物质，它与其他香味物质共同构成白酒所特有的芳香。优质纯粮固态发酵的白酒的酸超过普通液态白酒的两倍。酯也是固态发酵白酒的香味物质，优质白酒的酯类含量比液态白酒高出一倍以上，所以优质白酒香味浓郁，而液态发酵白酒的香味只能靠添加人工合成的香味物质来解决。 1.2.2 酿造流程这里只介绍白酒纯粮固态酿造的几大主要的流程，每个酒厂生产酒的特点不一样，具体细节也会有很大差异，但都离不开这几大流程。 1. 选料原料主要是粮食和水。粮食以高粱、玉米、小麦、大米、糯米等中的一种或多种为主，每种粮食酿出的酒的口味都不一样，有行业术语叫“高粱香、玉米甜、大米净、小麦糙、糯米绵”。 水，酿酒对水的要求很高，常言道“水为酒之血，名酒必有佳泉”，这也是为什么只有赤水河的水才能酿出茅台的原因。 2. 制曲如果说粮食是酒的根本，那么“曲就是酒的骨髓”。曲类似于做馒头的酵母。曲主要有 3 种： 大曲：由麦子高温制成，发酵周期长、微生物含量丰富，多用于高端白酒。 小曲：由米制成，发酵周期短、微生物含量低。 麸曲：由麸皮（小麦的壳，打碎之后叫糠，农村常用于喂猪）制成，发酵周期短，出酒率高，但酒质较差。多用于低端酒，如二锅头等。 3. 发酵将粮食和曲放入窖池中发酵，利用曲和窖池中的微生物将粮食糖化、发酵成酒精。 “千年老窖”中含有的微生物丰富，发酵出来的酒口感和味道也不一样。 4. 蒸馏靠发酵形成的酒的酒精度数很低，需要进行提纯。利用酒精和水的沸点不一样，采用蒸馏法进行提纯。 蒸馏的过程分为头、中、尾 3 部分，产生的酒称为酒头、中馏酒、酒尾，每种酒在酒厂中都有不同的用处。 5. 陈酿经过蒸馏产生的高度源酒还只能算半成品，喝起来辛辣，不醇和。需要经过合理的贮存、陈酿，一方面自然的排除杂味，另一方面让酒分子（即乙醇分子）和水分子充分结合，使酒的口感更加醇厚。这一步陈酿的越久，口味就越好，成本就越高，价格也就越贵。 6. 勾兑经过上面几个步骤产生的酒就可以称为“原浆”了，度数较高、口味单一、香味不纯在。为了统一口味，协调香味、降低度数，需要专门的调酒师对原浆酒进行勾兑。 现在白酒市场越来越来乱，各种混、配，如固态发酵白酒+食用酒精+食用香精+其他添加物等等，认准好酒除了相信一分钱一分货之外，还有**好酒在酿造工艺上需具备这 3 个关键词 纯粮、纯固态、大曲**。瓶身都有配料表，出现“食用酒精”的不要购买。 1.3 年份酒我们在市面上经常遇到类似“白云边 12 年”，“白云边 15 年”，“白云边 20 年”这样的年份酒，很多人认为这个“12 年”、“15 年”、“20 年”指的这瓶酒存储的年份。 如果你是这么认为的，那只能说你“太年轻，太简单”了。 拿“白云边 20 年”为例，它指的是在白酒勾兑过程中掺入了少许 20 年年份的酒，具体的这个“少许”指的是多少就不清楚了，可能是一缸酒:一杯 20 年酒，也可能更少或更多。 现实中由于酒的年份不同，价格差距也巨大，所以调酒时所用的基酒的品质等也会有差别，毕竟白云边 20 年和 15 年喝起来差别还是很大的。 1.4 白酒收藏一般收藏酒的年份指的是这整瓶酒存放的年份。 这个价值不是年份酒所能比拟的。我们经常听说“酒是陈的香”，但白酒是不是存放的越久就一定越好喝了？ 不一定，这个和酒的质量、存放的环境、密封程度等有很大关系。一般存放 3~5 年喝为宜，很多几十年的陈酒已经不适合直接喝了，可以用来作为基酒进行勾调。 有几种酒不适合陈： 含添加剂的酒。现在市面上很多低端酒都加入了香精，如果存放时间长了，香精挥发了，口感也会不一样。 低度酒（43 度以下的酒就算低度酒了）。世界上没有绝对密封的环境（我们可能认为玻璃瓶、陶瓷瓶的瓶壁是绝对封闭的，但从分子的角度来看，仍然会有酒分子的渗漏挥发，更何况还有瓶口的密封等问题），酒或多或少都会有挥发，低度酒度数本来就不高，挥发之后酒的度数就会更低；另外，低度酒杀菌能力较弱，存储不当会导致微生物易在酒体中繁殖。 2. 白酒香型分类新中国成立之后，为了加强白酒市场的管理，提高白酒质量，通过对白酒香味成分的分析（当然到现在也没弄清楚酱香型白酒的香味成分），提出了按香型对白酒分类的方案。截止到现在，白酒的香型有十几种之多，但酱香型、浓香型、清香型这 3 种香型差不多占据了白酒市场 90%的份额。 香型 代表酒 酱香型 茅台、郎酒 浓香型 五粮液、泸州老窖、剑南春 清香型 汾酒、二锅头 董香型 董酒 凤香型 西凤酒 兼香型 白云边 馥郁香型 酒鬼酒 米香型 三花酒 3. 酱香型白酒3.1 酱香白酒的优点为什么将酱香型白酒单独拿出来说了？一个是因为我自己爱喝，另外一个原因是喝酱香型白酒的确有诸多好处。酱香型白酒主要有以下特点： 正规酱香型白酒出厂前要经过三年以上的贮存，酒体中的易挥发物质少，对身体的刺激少。茅台酒空杯留香也和这有一定的关系。 因为易挥发物质少，酱香型的酒更适合存放，越陈越香。 酱香型白酒的酸度高、含 SOD 等物质，对软化血管，抗氧化等方面有一定的帮助。 目前还没找到可以产生酱香味的主要香味物质，所以很难通过香精、添加剂造假。 国家已经出台酱香型白酒国家标准，明确规定酱香型白酒不允许使用食用酒精及非白酒发酵生产的呈香、呈味、呈色物质，必须是使用纯粮食、固态法发酵而成。（但低端酱香酒因为成本等原有很难达使用大曲发酵）。 上面列出的酱香型酒的诸多好处都是基于适量饮酒的前提。 3.2 坤沙、碎沙、翻沙、串沙坤沙、碎沙、翻沙、串沙这些名词是专门用于酱香型白酒的工艺。“沙”指的是高粱，不是沙子。 坤沙酒“坤”是音译过来的，也叫做“捆”，表示用完整的高粱来酿酒。坤沙酒也叫捆沙酒、坤籽酒，也就是常说的正宗的酱香型白酒。严格按照传统的贵州茅台镇工艺进行生产，采用当地产的糯高粱、小麦，生产周期长达一年，出酒率低，但酒质好。需要经过很重要的“回沙“工艺，即 1 年生产、2 次投料、9 次蒸馏、8 次发酵、7 次取酒，也就是常说的 12987 生产工艺，然后还要经过三年以上的陈酿才能够出厂。在生产过程中高粱不能够粉碎，高粱的粉碎率需控制在 20%以内。 坤沙酒生产流程非常复杂，周期长，且出酒率低，这也是茅台飞天等高端酱香型酒价格居高不下的一个原因吧。 碎沙酒碎沙工艺就是指用被完完全全粉碎的高粱来酿酒。碎沙工艺生产周期较短，出酒率高，不要经过像坤沙那么严格的”回沙“工艺，所出酒的酱香味单薄，不如坤沙那样酱香味浓郁。但较好入口，也赢得了一部分人的喜爱。市面上的中低端酱香白酒大多采用此种工艺。 翻沙酒翻沙就是利用坤沙工艺中最后一次（第 9 次）蒸馏之后废弃的酒糟，再次加入高粱和曲，重新发酵酿出来的酒。翻沙酒生产周期短，出酒率高，但品质差。这样做只是利用酒糟让酒多了一点酱香味。因为生产成本低廉，市场上很多低端酱香型酒多是用的这种方法。 串沙酒窜沙酒，也叫串香酒，也是利用坤沙工艺中最后一次（第 9 次）蒸馏之后废弃的酒糟，但是它是直接加入食用酒精蒸馏。酒质很差，成本非常低廉。这种酒不符合酱香型的国家标准，不能算酱香型白酒了。 3.3 茅台及子品牌说到酱香就不能不提茅台了，酱香型酒曾经一度也叫“茅香型酒”。“今茅已非彼茅”，茅台今天已经是一个上市公司，大集团，旗下有很多子公司，每个子公司都有自己的品牌。常见的有飞天茅台、五星茅台、茅台王子酒、茅台迎宾酒、汉酱等等，它们有贵的，也有便宜的，这也是茅台集团多品牌战略的核心，以适应各种消费层次的需求。 下图是茅台集团及其子公司的白酒类品牌： 我们常说的高端茅台指的贵州茅台酒股份有限公司生产的飞天茅台、五星茅台、茅台纪念酒、茅台生肖酒、茅台陈年酒，这些高端茅台酒大多有 43 度和 53 度 2 种度数。度数不同，价格差距很大，以飞天茅台市场价为例，43 度的差不多 900 元，53 度的将近 2400 元。 4. 如何喝酒喝酒当然是用嘴喝，这里说的喝酒一定程度上指的是品酒，但品酒是一个很专业的事情，不是一两句话可以说的清的，需要专业的知识和经验的累积，故这里使用“如何品酒”这个标题。酒是小口小口的品的，绝不是“我干了，你随意”式的喝法。下面列出我的一点喝酒的方法： 4.1 望倒入杯中看是否有酒花，是否挂杯。观察酒的颜色，如酱香型的酒会微微偏黄。 4.2 闻端起酒杯闻酒香，不同的酒有不同的香味，有时候通过香味是否纯在就可以判断一个酒的好坏。喝完之后，可以闻闻是否空杯留香等等。 4.3 咂含在口中，慢慢感受酒的气味，是柔和还是刺激；从舌尖滑到舌根，最后到喉咙；回味是否甘甜。","link":"/post/1855436935.html"},{"title":"基于Hexo搭建静态博客","text":"Hexo是一个快速、简洁且高效的博客框架，使用Hexo可以快速地生成静态博客框架。在框架生成完成后，可以使用任意文本编辑器语法书写博客。我们可以使用Markdown语法书写博客，Hexo在生成博客时会自动将Markdown解析成Html静态页面。 Hexo官网：https://hexo.io/zh-cn/Hexo中文文档：https://hexo.io/zh-cn/docs/ 一、玩法说明使用Hexo写博客的大致流程如下： 生成博客框架 配置博客 选择自己喜欢的主题 配置博客和主题 写文章 生成博客 发布博客到服务器 其中，第1~4步为前置操作，只需要执行一次。 Hexo只负责生成静态的HTML文件，不提供服务器。如需对外发布博客，我们还需将HTML文件部署到服务器上，可以选择如下的方式： Github Pages、GitLab Pages，免费，访问速度较慢。 Gitee Pages，收费。 对象存储服务，如阿里云OSS、腾讯云COS、七牛云OSS等。当访问量大时，需搭配CDN使用，避免因数据回源产生巨额流量费用。 自己购买服务器使用Nginx搭建Web服务器。当访问量大时，服务器出口带宽要求较高，此时仍然需要搭配对象存储服务和CDN使用。 二、生成博客框架2.1 环境准备在搭建博客框架之前，确保电脑上已经安装如下软件（建议安装最新版本的Node.js，这样可以确保兼容最新版本的Hexo）： Node.js Git 2.2 安装Hexo在所有必备的应用程序安装完成后，即可使用 npm 全局安装 Hexo工具： 1npm install -g hexo-cli 2.3 生成博客框架安装 Hexo 完成后，在指定文件夹下执行如下命令，Hexo 将会在目录下新建博客所需的文件： 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 如果遇到网络错误等问题，请排除是否因为访问国外域名失败导致，可以尝试将npm源切换到国内，参考： NPM和Yarn设置国内源 新建完成后，指定文件夹的目录大致如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml 网站的配置文件，可以在此配置大部分的参数，需要区别于主题的_config.yml配置文件。 package.json 应用程序的信息。 scaffolds 模版文件夹。当新建文章时，Hexo会根据scaffold来创建文件。Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果修改 scaffold/post.md 中的 Front-matter （即两个---中间的内容）内容，那么每次新建一篇文章时都会包含这个修改。 source 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件/文件夹和隐藏的文件将会被忽略。在生成博客时，Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被直接拷贝过去。 themes 主题文件夹。将下载的主题文件放置到该目录，Hexo 会根据主题来生成静态页面。 三、配置博客Hexo的配置分别站点配置和主题配置，站点配置文件为博客根目录下的_config.yml文件，主题配置文件为位于themes\\&lt;主题目录&gt;中的_config.yml文件。 3.1 站点配置本节介绍博客的站点配置，部分配置的含义如下： title 网站标题 subtitle 网站副标题 description 网站描述，主要用于SEO keywords 网站的关键词。支持多个关键词。 author 作者名字 language 网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。 timezone 网站时区。对于中国大陆地区可以使用 Asia/Shanghai。 theme 当前主题名称，名称为themes目录中的子目录名称。值为false时禁用主题。 per_page 每页显示的文章量 (0 = 关闭分页功能)。 pagination_dir 指定博客生成后，每页的index.html文件存放目录。 3.2 利用Hexo-abbrlink插件生成唯一文章链接Hexo在生成博客文章链接时，默认是按照年/月/日/标题格式来生成的，可以在站点配置文件中指定new_post_name的值，默认是:year/:month/:day/:title这样的格式。如果你的标题是中文的话，你的URL链接还会包含中文。而且当我们修改原文章的日期或标题后，之前生成的链接将会失效。 为了给每一篇文章指定一个唯一的不含中文的链接，可以利用hexo-abbrlink插件，来解决这个问题。 先安装下hexo-abbrlink： 1npm install hexo-abbrlink --save 修改站点配置文件(_config.yml)： 1234permalink: post/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 生成完后原文章.md文件的Front-matter 内会增加abbrlink字段，值为生成的ID。这个字段确保了在我们修改了Front-matter内的title或date字段之后链接地址不会改变。换句话说，就是本篇文章有了自己的专属链接。 当然，也可以选择不同的算法和进制： crc16 &amp; hex https://post.zz173.com/posts/66c8.html crc16 &amp; dec https://post.zz173.com/posts/65535.html crc32 &amp; hex https://post.zz173.com/posts/8ddf18fb.html crc32 &amp; dec https://post.zz173.com/posts/1690090958.html 注意，配置完成之后，之前的文章的链接有可能会变成了undefined，需要执行hexo clean并重新生成部署。 四、配置主题每个主题的配置内容都不一样，具体参考使用主题的帮助文档。我使用的是hexo-theme-matery主题。 4.1 推荐主题 hexo-theme-aircloud hexo-theme-new-yilia hexo-theme-vexo hexo-theme-next hexo-theme-butterfly hexo-theme-volantis hexo-theme-icarus 可以在Github中搜索Hexo Theme发现更多主题。 五、写文章5.1 生成文章使用如下命令生成新的文章: 1hexo new &lt;文章标题&gt; 执行上述命令后，会在source_posts目录下生成对应的.md文件，文件内容如下： 5.2 Front-matterFront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量。Hexo预定义了一些变量，同时每个主题也会定义一些变量。 5.2.1 Hexo预定义变量 title 标题，默认为文章的文件名 date 建立日期，默认为文件建立日期 updated 更新日期，默认文件更新日期 comments 是否开启文章的评论功能，true/false. tags 标签（不适用于分页），支持多个。 categories 分类（不适用于分页），支持多个。 permalink 覆盖文章的永久链接，永久链接应该以/或.html结尾。 keywords: 文章关键字，用于SEO。 如： 12345678910111213141516---title: 从汇编的角度分析函数调用过程categories: - C++ - 汇编abbrlink: 4168021185date: 2022-01-21 15:53:01updated: 2023-01-21 15:53:01keywords: - 函数 - C++ - 汇编tags: - C++ - 传参形式--- 5.2.2 hexo-theme-matery主题定义变量 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 hide false 隐藏文章，如果hide值为true，则文章不会在首页显示 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图各有特色。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。 最简示例1234---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00--- 最全示例123456789101112131415161718---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truehide: falsecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags: - Typora - Markdown--- 5.3 引用站内文章语法如下： 1{% post_link slug [title] %} 其中，slug 表示 _post 目录下的 Markdown 文件名。可以通过 title 指定链接标题。 5.4 按钮语法如下： 1{% button /path/to/url/, text, icon [class], [alt] %} 如： 1{% button https://jiangxueqiao.com, 江雪桥的博客, home fa-fw fa-lg, 江雪桥 %} 5.5 插入图片Markdown 并不会保存插入的图片资源本身，只是记录了获取资源的链接。因此我们需要选择一款合适的图床来支持博客写作，目前各大云服务商都提供了对象存储服务，如七牛云 KODO、又拍云 USS、腾讯云 COS、阿里云 OSS 等。 可以使用PicGo工具上传图片到图床上。 5.6 支持emoji表情Hexo默认的 Markdown 渲染器是 hexo-renderer-marked，这个渲染器不支持 emoji 表情。可以利用 hexo-filter-github-emojis插件实现支持 emoji 表情。 安装插件： 1npm install hexo-filter-github-emojis --save 修改站点配置文件（_config.yml）添加如下配置： 123456githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 在emoji-cheat-sheet中找到想要的表情，粘贴到文章中即可。 五、发布使用如下命令生成静态HTML文件： 1hexo g 生成的HTML文件位于博客根目录的public中，将该目录部署中的所有文件部署到服务器即可。","link":"/post/2737986840.html"},{"title":"基于Joplin和WebDAV搭建私有云笔记","text":"一、私有Docker搭建WebDAV服务从我的Github上下载WebDAV的Docker配置文件： 1git clone https://github.com/winsoft666/docker-webdev 根据docker-compose.yml.sample文件来新建docker-compose.yml文件： 1cp docker-compose.yml.sample docker-compose.yml 修改docker-compose.yml文件中的相应字段： 123456789101112131415version: '3'services: webdav: build: . restart: always ports: - \"9443:443\" - \"9080:80\" environment: SERVER_NAME: www.xxx.com,xxx.com AUTH_TYPE: Basic SSL_CERT: selfsigned volumes: - /webdav-server:/var/lib/dav - /root/webdav/user.passwd:/user.passwd 字段含义如下： ports为容器和宿主机器的端口映射，冒号前面的端口可以自定义； SERVER_NAME为服务器绑定的域名，如果没有绑定域名，可以直接写服务器的外网IP。 Joplin只支持Basic验证模式； /root/webdav/user.passwd为WebDAV的用户名和密码存储文件，存在在宿主机器上，通过映射的方式映射到容器中，生成步骤如下： 123456# 在CentOS7系统上安装httpdyum -y install httpdcd /root/webdav/touch user.passwdhtpasswd -B user.passwd zhanghua 在docker-compose.yml文件所在目录，执行： 1docker-compose up -d 上面命令会部署并启动WebDAV服务。 二、测试WebDAV服务在浏览器中打开http://xxx.com:9080，会弹出用户名和密码输入框，输入使用htpasswd 命令创建的用户和密码，点击登录，如果可以登录进去，说明服务搭建成功。 三、新建Joplin数据目录在宿主机器的/webdav-server/data目录下，新建子目录joplin。因为/webdav-server/目录已经映射到容器中，所以容器可以直接访问。 重启Docker： 123docker ps -a # 查看容器IDdocker stop XXXdocker start XXX 从Joplin官网（https://joplinapp.org/）下载Joplin客户端，在“同步”选项中设置WebDAV，如图所示： 设置完成之后，点击“检查同步配置”，提示“成功”则说明配置正确。","link":"/post/2173106656.html"},{"title":"Git杂记","text":"本文记录 Git 使用中的一些零碎知识，方便自己查阅，亦希望成人之美。 一、gitignore 文件规则 所有空行或#开头的行都会被忽略； 文件或目录前加 /表示仓库根目录； 匹配模式最后跟反斜杠 / 指明是目录而非文件，忽略该目录下的所有文件，但不忽略该目录； 在模式前加!，指明不忽略某个文件或目录； 支持标准的 glob 模式匹配 * 匹配零个或多个任意字符； ? 只匹配一个任意字符； [abc]匹配任何一个列在方括号中的字符； [0-9] 表示匹配所有 0 到 9 的数字，同理有[a-z]等； 二、清空仓库历史提交1234567891011121314151617# 1. 创建新分支，如名称latest_branchgit checkout --orphan latest_branch# 2. 添加所有文件git add .# 3. 提交git commit -m \"自定义提交说明\"# 4. 删除原来的主分支（master）git branch -D master# 5. 将当前分支重命名为mastergit branch -m master# 6. 强制推送到远端git push -f origin master 有些仓库有 master 分支保护，不允许强制 push，需要在远程仓库项目把分支保护关掉才能推送。 推送前需要使用git remote -v 查看关联的远程仓库的信息（主要是远程库的别名）。虽然远程库的别名默认是 origin ,但可能设置过其他的别名（而非 origin）。","link":"/post/2042033077.html"},{"title":"MSVC版本的二进制兼容性","text":"Visual Studio 2013 及更早版本中的 Microsoft C++ (MSVC) 编译器工具集不保证主版本间的二进制兼容性，无法链接由不同版本工具集生成的对象文件、静态库、动态库和可执行文件。 ABI、对象格式和运行时库不兼容。 微软在 Visual Studio 2015 及更高版本中改变了这个行为。对于自 Visual Studio 2015 以来的所有版本（该版本号都以 14 开头，如Visual Studio 2015、2017、2019 和 2022工具集的版本分别为 v140、v141、v142 和 v143）由其中任一版本编译器编译的运行时库和应用具有二进制兼容性。假设你使用 Visual Studio 2015 生成第三方库，你仍可在 Visual Studio 2017、2019 或 2022 生成的应用程序中使用它们，无需使用匹配工具集重新编译。 同时最新版本的 Microsoft Visual C++ 可再发行程序包（可再发行程序包）也适用于所有版本，无需为不同版本安装不同的运行时库，统一安装最新的即可。 对二进制兼容性的限制v140、v141、v142 和 v143 工具集与次要版本号更新之间的二进制兼容性方面存在三个重要限制： 你可以混合使用由 v140、v141、v142 和 v143 工具集的不同版本生成的二进制文件。 但是，必须使用至少与应用中最新二进制文件同样新的工具集进行链接。 下面是一个示例：可以将使用任何版本的v141工具集（版本 15.0 到 15.9）编译的应用链接到使用 Visual Studio 2019 版本 16.2 (v142) 编译的静态库。 只是必须使用版本 16.2 或更高版本工具集链接它们。只要使用 16.4 或更高版本工具集，便可以将版本 16.2 库链接到版本 16.4 应用。 应用使用的可再发行程序包具有类似的二进制兼容性限制。 混合使用由工具集的不同受支持版本生成的二进制文件时，可再发行程序包版本必须至少与任何应用组件使用的最新工具集一样新。 使用 /GL（全程序优化）编译器开关编译或是使用 /LTCG（链接时间代码生成）链接的静态库或对象文件不在各个版本间二进制兼容（包括次要版本更新）。 使用 /GL 和 /LTCG 编译的所有对象文件和库必须将完全相同的工具集用于编译和最终链接。 例如，使用 Visual Studio 2019 版本 16.7 工具集中的 /GL 生成的代码无法链接到使用 Visual Studio 2019 版本 16.8 工具集中的 /GL生成的代码。 编译器会发出错误 C1047。 从 Visual Studio 2015 及更高版本升级 Microsoft Visual C++ 可再发行程序包对于 Visual Studio 2015、2017、2019 和 2022，微软将 Microsoft Visual C++ 可再发行程序包的主版本号保持一致。 这意味着我们一次只能安装可再发行程序包的一个实例。 较新版本会覆盖已安装的任何较旧版本。 例如，一个应用可能会从 Visual Studio 2015 安装可再发行程序包。 随后另一个应用从 Visual Studio 2022 安装可再发行程序包。 2022 版本会覆盖较旧版本，但由于它们具有二进制兼容性，早期应用仍可正常工作。 微软确保最新版本的可再发行程序包具有所有最新的功能、安全更新和 bug 修补程序。 这便是为什么微软始终建议升级到最新可用版本。 同样，已安装了较新版本时，无法安装较旧的可再发行程序包。 如果尝试，则安装程序会报告错误。 如果在已具有 2022 版本的计算机上安装 2017 或 2019 可再发行程序，则会看到如下所示的错误： 10x80070666 - Another version of this product is already installed. Installation of this version cannot continue. To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel. 此错误是微软故意这样设计的，以确保Microsoft Visual C++ 可再发行程序包为最新版本。 本文参考：Visual Studio 版本之间的 C++ 二进制兼容性","link":"/post/3437796039.html"},{"title":"一个MySQL存储过程模板","text":"在进行数据库开发时，我们可能需要写很多存储过程，本文提供一个存储过程的模板，通过该模板可以简化存储过程的开发。 MySQL存储过程的范例模板，带返回值和异常处理的功能。 12345678910111213141516171819202122DROP PROCEDURE IF EXISTS sp_sample;CREATE PROCEDURE sp_sample(OUT errno INT)root:BEGIN /* 功能： IN参数： OUT参数： errno 存储过程异常标志(0-成功, 1-异常) */ DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN ROLLBACK; SET errno = 1; END; SET errno = 0; START TRANSACTION; -- do what you want to do. -- ... COMMIT;END; 其中，存储过程的异常捕获和回滚使用DECLARE...HANDLER实现： 12345DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN ROLLBACK; SET errno = 1; END; 关于DECLARE...HANDLER的用法见： MySQL的DECLARE...HANDLER使用","link":"/post/254517042.html"},{"title":"图形编程扫盲","text":"一、常见图形编程接口我们常见的图形编程接口主要分为如下派系： OpenGL DirectX Vulkan Metal 下图展示了各个派系的分支及特点： 二、ANGLEANGLE （全称 Almost Native Graphics Layer Engine）是Google发起的开源项目，主要用在 Chromium 项目里面，Google创建这个项目是为了让WebGL能够间接调用硬件平台支持的图形API，如Windows平台上调用DirectX图形接口。 目前ANGLE支持Windows, Mac, Linux, iOS和Android平台。 WebGL基于OpenGL ES开发，而在Windows系统上默认只安装了OpenGL 1.1驱动程序，如果用户没有升级更新的OpenGL驱动，则网页中的WebGL将只能使用软件渲染（即CPU绘制图形），显然这种方式无法利用显卡GPU的优势，图形渲染性能和效果都不好。为了改版这个现状，Google公司开发了ANGLE项目。 例如在Windows平台，ANGLE项目通过将DirectX接口进行二次封装，封装后的接口与OpenGL ES接口非常类似，这样当程序代码调用ANGLE提供的类OpenGL ES接口时，ANGLE就可以在内部判断是调用OpenGL接口还是调用DirectX接口，从而实现了当用户系统上没用安装OpenGL驱动时，自动使用合适的DirectX绘制接口。 项目地址：https://github.com/google/angle 三、EGLEGL 是 OpenGL ES 和本地窗口系统（Native Window System）之间的通信接口，OpenGL ES 的平台无关性正是借助 EGL 实现的，EGL 屏蔽了不同平台的差异（Apple 提供了自己的 EGL API 的 iOS 实现，自称 EAGL）。 我们通常在安装目录看到的libEGL.dll和libGLESv2.dll文件就是EGL在Windows平台的实现。WebGL基于OpenGL ES实现，所以使用了WebGL和OpenGL ES的程序都会带上这2个文件。","link":"/post/1919525700.html"},{"title":"正则规则速查","text":"本文不是一个完整的正则表达式的教程，仅适用于已掌握正则表达式语法，需要进行规则速查的开发人员。 一、元字符 字符 说明 ^ 一行开始 $ 一行结束 \\b 单词的开始或结束 . 除换行符外的任意字符 \\w 单词字符（包括字母、数字、下划线和汉字） \\W 任意的非单词字符（包括字母、数字、下划线和汉字） \\s 任意的空白字符，如空格、制表符、换行符、中文全角空格等 \\S 任意的非空白字符 \\d 任意的数字 \\D 任意的非数字字符 二、字符集合 字符集合 说明 [aeiou] aeiou 字符集中的任何字符 [^aeiou] 除 aeiou 字符集之外的字符 [0-9a-z] 字符集合 0 到 9，a 到 z 中的任何字符 [^0-9a-z] 除字符集合 0 到 9， a 到 z 中的任何字符 三、限定符 字符 说明 {n} 重复次数=n 次 {n,} 重复次数&gt;=n 次 {n,m} n&lt;=重复次数&lt;=m * 重复次数&gt;=0 + 重复次数&gt;=1 ? 0&lt;=重复次数&lt;=1 *? 尽可能少地使用重复的第一个匹配 +? 尽可能少地使用重复但至少使用一次 ?? 使用零次重复（如有可能）或一次重复 四、分组分组又称为子表达式，即把一个正则表达式的全部或部分分成一个或多个组。其中，分组使用的字符为(和)，即左圆括号和右圆括号。分组之后，可以将字符为(和)之中的表达式看成一个整体来处理。 以下正则表达式可以匹配重复出现字符串“abc”一次或两次的字符串。此时，表达式将“abc”看成一个整体来进行重复匹配。 1(abc){1,2} 当一个正则表达式被分组之后，每一个组将自动被赋予一个组号，该组号可以代表该组的表达式。其中，组号的编制规则为：从左到右、以分组的左括号(为标志，第一个分组的组号为 1，第二个分组的组号为 2，以此类推。可以使用 \\数字 的方式来引用分组。如\\1，\\2。 五、贪婪与非贪婪比如说匹配输入串 A:&nbsp;101000000000100 使用1.*1将会匹配到 1010000000001, 匹配方法: 先匹配至输入串 A 的最后, 然后向前匹配, 直到可以匹配到 1, 称之为贪婪匹配。 使用1.*?1将会匹配到 101, 匹配方法: *匹配下一个 1 之前的所有字符, 称之为非贪婪匹配。 所有带有量词的都是非贪婪匹配:&nbsp;.*?,&nbsp;.+?,&nbsp;.{2,6}?, .??。 六、在线正则验证工具 https://c.runoob.com/front-end/854/ http://www.yunjson.com/reg/ https://tool.oschina.net/regex/","link":"/post/3005885000.html"},{"title":"《网络协议》","text":"本栏目系统性的介绍了常用的网络协议（如 ARP, IP, TCP, UDP, HTTP 等），并深入剖析协议的原理。让读者不仅可以知其然，而且可以知其所以然。在这其中也覆盖面试中的一些常见问题。 文章列表： 网络协议(1)--基础概念 网络协议(2)--ARP和RARP协议 网络协议(3)--IP协议 网络协议(4)--ICMP协议 网络协议(5)--UDP协议 网络协议(6)--TCP协议 网络协议(7)--HTTP与HTTPS协议","link":"/post/253039952.html"},{"title":"网络协议(1)--基础概念","text":"一、TCP/IP 协议栈 二、IP 地址、子网掩码、网关2.1 IP 地址及分类IP 地址相当于互联网上的门牌号，计算机在启动的时候可以从磁盘（无盘系统例外）上读取该主机的 IP 配置。 IP 地址由 4 个字节（也就是 32 位）的二进制码组成，包含了网络号( net-id )和主机号( host-id )。但现实中，我们经常还需要再继续划分“子网”，这时就需要借用主机号的一部分充任子网号，这样 IP 地址也就可以看成由标准网络号、子网号、主机号3 部分组成的，即IP地址=标准网络号+子网号+主机号。 网络号、子网号、主机号三者间的关系，形象的描述如下：假设你的住址 IP 是武汉市文治街16号，那么，IP 地址 = 武汉市文治街 16 号网络号 = 武汉市子网号 = 文治街主机号 = 16 号 IP 地址种类 二进制组成(前缀位+网络位+主机位) IP 范围 网络数 主机数/网络 A 类地址 0+7 位网络号+24 位主机号 1.0.0.0 - 127.255.255.255 $2^7-2$ $2^{24}-2$ B 类地址 10+14 位网络号+16 位主机号 128.0.0.0 - 191.255.255.255 $2^{14}-1$ $2^{16}-2$ C 类地址 110+21 位网络号+8 位主机号 192.0.0.0 - 223.255.255.255 $2^{21}-1$ $2^8-2$ D 类地址 1110+多播地址(用于多播) 224.0.0.0 - 239.255.255.255 - - E 类地址 1111+保留位(不开放, 保留使用) 240.0.0.0-249.255.255.255 - - 从表中可以看出，A 类 IP 的第 1 位（二进制位）必须是 0，所以 A 类 IP 的第一个整数的范围是0000 0000 ~ 01111 11111，转换为十进制就是0 ~ 127，以此类推。 关于网络数的解释网络数就是一种网络的子网数, 比如 A 类地址, 可以分为多少个子网。看表格可以推出网络数的计算公式为: $2^{网络号位数}$。规定网络地址全为0的 IP 地址是保留地址，意思是“本网络”。 在 A 类地址中，实际上 0.0.0.0 是不指派的，而可以指派的最小网络是 1.0.0.0；网络地址为 127 的 A 类 IP 地址保留作为本地软件环回测试本主机的进程之间的通信(比如常用的 127.0.0.1，但实际上网络地址为127的都可以用作本地环回地址)。所以 A 类地址网络数为 $2^7-2$。 在 B 类地址中，实际上 128.0.0.0 是不指派的，而可以指派的最小网络是 `128.1.0.0，所以 B 类地址网络数是 $2^{14} - 1$。 在 C 类地址中，实际上 192.0.0.0 是不指派的，而可以指派的最小网络是 192.0.1.0，所以 C 类地址网络数是 $2^{21}-1$。 关于主机数的解释主机数就是一个子网里面可以容纳多少台主机。看表格可以推出主机数的计算公式为: 2^主机号位数-2。主机号全为 0 表示该网络，而主机号全为 1 表示广播地址，所以要排除掉这两个。比如 A 类地址 1.0.0.0 表示主机所在的网段的网络地址, 1.255.255.255 为该网段的广播地址。 2.2 私有 IP 地址经常可以看到192.168.1.101这类的 IP 地址, 这些是私有 IP 地址, 专用地址, 也就是局域网内使用的的 IP 地址。公网 IP 地址是需要向有关部门申请备案的，私有 IP 地址不用申请, 但是仅限内网使用, 也节约公网 IP。 IP 地址种类 私有 IP 范围 A 类地址 10.0.0.0 - 10.255.255.255 B 类地址 172.16.0.0 - 172.31.255.255 C 类地址 192.168.0.0 - 192.168.255.255 路由器看到专用地址就不转发，所以说专用地址作为目的地址是不可能在因特网上传送的。专用 IP 地址也可叫做可重用地址。那好，问题来了，如果配置了这些专用地址的主机想和因特网上的主机通信，怎么办呢？NAT(network address translation: 网络地址转换)在这种情况下就应运而生了。NAT 就是将这种地址转换成有效的外部全球 IP 地址，使得整个专用网只需要一个全球 IP 地址就可以与因特网联通。 2.3 子网掩码IP地址=标准网络号+子网号+主机号。从 IP 分类可以很容易确定“标准网络号”，32bit的 IP 地址除去前面的“标准网络号”之后，剩下的就是“子网号”和“主机号”，那么怎么确定“子网号”和“主机号”了？ 这就需要借助“子网掩码”了。子网掩码也是一个 32bit(xxx.xxx.xxx.xxx)的值，其中值为 1 的 bit 留给“标准网络号”和“子网号”，为 0 的 bit 留给“主机号”。我们可以将子网掩码和 IP 地址进行二进制“与运算”，通过得到的结果来确定“子网号”。 以 C 类 IP 地址为例，对于规范的 C 类 IP 地址来说，规范子网掩码为255.255.255.0，即用 32 比特 IP 地址的前 24 比特标识网络号，后 8 比特标识主机号。因而，每个 C 类网络下共可容纳 254 台主机($2^8-2$)。 如今，我们先思索借用 2 比特的主机号来充任子网络号的情形。 C 类网络地址210.31.233.0，我们借用 2bit 的主机号来充当子网号，子网的数目为$2^2-2$(子网号无法全为 0 或 1，所以减 2). 为了借用原来 8 位主机号中的前 2 位充任子网络号，采用了新的非规范子网掩 255.255.255.192。采用了新的子网掩码后，借用的 2 位子网号可以用来标识两个子网：01 子网和 10 子网(子网号无法全为 0 或 1，因而 00、11 子网无法用)。 对于上图的 01 子网来说，其网络号的点分十进制的方式为：210.31.233.64，该子网的最小 IP 地址为：210.31.233.65，最大 IP 地址为：210.31.233.126（主机号全为 1 位广播地址），共可容纳 62 台主机。对该子网的直接广播地址为：210.31.233.127（主机号全为 1）。 经常见到像192.168.1.0/24这样的写法，它的意思是网络号为192.168.1.0；子网掩码为 24 位，即111111111 111111111 111111111 00000000，转为点分十进制就为255.255.255.0，没有借用主机号来充当子网号，可以拥有的主机数为$2^8$-2. 2.3 网关的作用你的住址 IP 是武汉市洪山区文治街16号，你的父母只允许你和文治街的小朋友（同一个子网）一起玩耍，如果你想要去和别的街道（别的子网）的小朋友玩耍，你就需要经过你的父母的同意，由你的父母带你过去，这时候你的父母就充当了网关的角色，没有你的父母，你就不能和其他街道（其他子网）的小朋友玩耍。 三、包的封装与解封装 封装英文：Encapsulation解封装英文：Demultiplexing 当应用程序使用网络传送数据时，数据按照协议栈从上到下的顺序，逐次通过每一层。其中每一层对收到的数据都要增加一些首部信息（有时还增加尾部信息）。最终生成一串比特流通过以太网来传输，我们称这串比特流叫帧。如图： 当数据报到达链路层时，链路层也要对 IP 数据包封装进行包装。链路层也要对 IP 数据包封装的方式主要有以太网IP数据包封装（RFC894）、IEEE 802 IP数据报封装（RFC1042）两种，最常使用的封装格式是以太网 IP 数据包封装（RFC894）。下图显示了这两种不同形式的封装格式：从图中可以看到以太网封装限制了数据帧的最大长度为 1500 字节，这个限制叫做 MTU，最大传输单元（详见第四节）。 接收端收到帧之后，按照和上面相反的顺序（协议栈从下到上）来解包，依次解析每一层加入的头部（或尾部），最终将原始数据传给最上层应用程序。如图： 因为传输层的 TCP、UDP、ICMP 等都有可能向网络层 IP 协议传送数据，这样在 IP 协议层解包的时候，需要知道这个包对应的上层协议是哪一个，因此 IP 协议必须在生成的 IP 首部加入某种标识，以表明数据的上一层的具体协议。为此，IP 在首部中存入了一个长度为 8bit 的数值，称作协议域。常见的 IP 协议号有：1 表示 ICMP 协议，2 表示 IGMP 协议，6 表示 TCP 协议，17 表示 UDP 协议。 完整的 IP 协议号见：IP 协议号列表 四、MTU前面第三节提到了以太网封装限制了数据帧的长度为 1500 字节，这个限制是在链路层封装 IP 数据报时作的。如果 IP 层的数据报比链路层的这个 MTU 值大，那么 IP 层就需要分片（英文：fragmentation），把数据报分成若干片，保证每一片的大小都小于 MTU 值。 windows 系统修改 MTU 值 查询当前 MTU 值 1netsh interface ipv4 show subinterfaces 修改 MTU 值 1netsh interface ipv4 set subinterface \"本地连接\" mtu=1480 store=persistent 文章参考：https://m.vipcn.com/a/360973/ &gt; https://ahaochan.github.io/posts/IP_address,_subnet_mask,_gateway_Introduction.html &gt; https://www.zhihu.com/question/20717354 《TCP/IP 详解 卷 1：协议》在线阅读地址：http://www.52im.net/topic-tcpipvol1.html 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/3886809266.html"},{"title":"网络协议(3)--IP协议","text":"IP 协议是 TCP/IP 协议族中最核心的协议。所有的 TCP、UDP、ICMP、IGMP 数据都以 IP 数据报的格式传输。 IP 协议是不可靠、无连接的： 不可靠表示 IP 协议不能保证 IP 数据报能成功的到达目的地。IP 仅提供传输服务，任何可靠性的要求都必须由上层来提供（如 TCP）。如果传输过程发生错误，IP 协议简单的丢弃该数据报，然后发送 ICMP 消息给发送端。 无连接表示 IP 协议不维护任何关于后续数据报的状态信息，每个数据报都是相互独立的。这也说明，IP 数据报可能不是按照发送顺序被接收到的，很有可能后发送的数据被先收到。 一、IP 首部IP 数据报的格式如图： 4 位版本：标识目前采用的 IP 协议的版本号。IPv4 为 0100, IPv6 为 0110 4 位首部长度：用于标识首部的长度，单位为4 字节，所以首部的最大长度为15*4字节=60字节。 8 位服务类型：包括 3bit 的优先权字段（已被忽略），4bit 的 TOS 字段，1bit 的始终为 0 的未使用位。 16 位总长度(字节数)：整个 IP 数据报的长度。数据报中数据内容的长度=总长度 - 首部长度 16 位标识：唯一地标识主机发送的每一份数据报。IP 数据报的最大长度可达 65535 字节，但大多数链路层都会对它进行分片。由于 TCP 本身会把用户数据分成若干片，因此这个字段一般来说不会影响到 TCP。 3 位标志：用于 IP 数据报分片。该字段第 1bit 不使用，第 2bit 是 DF(Don't Fragment)位，DF 位设为 1 时表明 IP 不对该数据包分片。第 3bit 是 MF(More Fragments)位，当对数据包分片时，除了最后一片外，其他每个组成数据报的片都要把此位设为 1。 13 位偏移：用于 IP 数据报分片。单位为 8 字节。表示该片相对于原始数据报开始处的位置，能表示的最大偏移为$2^{13}$*8=65536 字节。 另外，数据报被分片之后，每个片的总长度要更改为该片的长度值。IP 层分片是透明的，但是即使只丢失一片数据也要重传整个数据报，因为 IP 层本身没有超时重传的机制。 8 位生存时间(TTL)：设置数据报可以经过的最多路由器数量，每经过一个路由器，该值就减去 1。当该值为 0 时，数据报就被丢弃。通常初始值为 32 或 64. 8 位协议：表示上层传输层所用的协议类型。1 表示 ICMP 协议，2 表示 IGMP 协议，6 表示 TCP 协议，17 表示 UDP 协议。 16 位首部校验和：用于对 IP 首部的正确性进行校验，但不包括数据部分，这点不同于 TCP 和 UDP 的首部校验和。 32 位源 IP 地址：发送端的 32bit 的 IP 地址。 32 位目的 IP 地址：接收端的 32bit 的 IP 地址。 选项：可变长度的可选信息。如果首部不含“选项字段”，则 IP 首部长度为 20 字节。 二、IP 首部校验和 发送端对 IP 数据报的校验和的计算步骤： 把 IP 数据报的校验和字段置为 0； 把首部看成以 16 位为单位的数字组成，依次进行二进制反码求和； 把求和得到的结果取反。 将第 2、3 步得到的 2 个字节数据存入首部校验和。 接收端对 IP 数据报的校验和的校验步骤： 把首部看成以 16 位为单位的数字组成，依次进行二进制反码求和； 把求和得到的结果取反码。 如果结果为 0，则表示检验和校验通过，IP 报文没有被修改过。 三、使用代码计算校验和通过 wireshark 抓取一帧数据报，如图： 以该数据报的 IP 首部为基础，使用 C++代码来验证 IP 首部校验和的计算步骤和校验步骤： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;assert.h&gt;// GetChecksum函数用于实现上面所说的计算步骤中的第2步、第3步：// 把首部看成以16位（2字节）为单位的数字组成，依次进行二进制反码求和，// 但实际的算法实现上需要考虑取和溢出时的改进计算方法（见函数内部注释）//unsigned short GetChecksum(unsigned short* ip_header, int size) { assert(sizeof(unsigned short) == 2); // 为什么使用unsigned long（4字节）？ // 因为虽然首部校验和只占16位（2个字节），但执行“以16位（2字节）为单位的二进制反码数据”求和操作得到的checksum可能会超过16位（2字节）， // 所以这里用4个字节的unsigned long来接收相加得到的结果，后面再进行处理。 // unsigned long checksum = 0; while (size &gt; 1) { checksum += *ip_header; // 因为都是正数，所以反码与原码相同；故直接相加求和 ip_header++; // ip_header为unsigned short类型的指针每次按2个字节相加 size -= 2; } // 执行到这：checksum = 0x2850c // IP首部如果不包含“选项”字段，则为20字节，偶数；如果包含了“选项”，则字节数就可能为奇数了， // 这里针对字节数为奇数的情况进行处理。 // 注：示例main函数中构造的ip_header不含有“选项” // if (size == 1) { checksum += *(unsigned char*)ip_header; } // 因为上面相加之后的结果大于2个字节，所以执行额外的处理步骤： // checksum &gt;&gt; 16 右移16位 // 即除以2的16次方（0xffff），就是去除右边的2个字节，如：0x2850c &gt;&gt; 16 = 0x2 // // checksum &amp; 0xffff 位运算，得到后2个字节 // 如：0x2850c &amp; 0xffff = 0x850c // // checksum = 0x2 + 0x850c = 0x850e // checksum = (checksum &gt;&gt; 16) + (checksum &amp; 0xffff); // 假如还大于2个字节，再次将多余的字节和checksum相加。 checksum += (checksum &gt;&gt; 16); // 求和得到的结果的取反 return (unsigned short)(~checksum);}int main(){ // 将上面wirkshark抓的数据包的IP头部，使用char数组，按字节构造出来 // unsigned char ip_header[20] = { 0x45, // 4位版本+4位首部长度 0x00, // 8位服务类型（TOS） 0x00, 0x1c, // 16位总长度（字节数） 0x50, 0xaa, // 16位标识 0x00, 0x00, // 3位标志+13位片偏移 0xff, // 8位生存时间（TTL） 0x01, // 8位协议 0xf1, 0x7a, // 16位首部校验和 0xc0, 0xa8, 0x2e, 0x55, // 32位源IP地址 0xee, 0x73, 0x9c, 0x4a // 32位目的IP地址 }; // 第1步：把IP数据包的校验和字段置为0； // ip_header[10] = 0x00; ip_header[11] = 0x00; // 第2、3步计算校验和 // unsigned short checksum = GetChecksum((unsigned short*)ip_header, sizeof(ip_header)); printf(\"%02hhx %02hhx\\n\", *(char*)(&amp;checksum), *((char*)(&amp;checksum) + 1)); // 第4步：将第2、3步得到的2个字节数据存入首部校验和 // ip_header[10] = *(char*)(&amp;checksum); ip_header[11] = *((char*)(&amp;checksum) + 1); // 模拟接收到IP包之后，对IP首部的校验和进行校验 // unsigned short checksum_check = GetChecksum((unsigned short*)ip_header, sizeof(ip_header)); if (checksum_check == 0) { printf(\"checksum check successful!\\n\"); } else { printf(\"checksum check failed!\\n\"); } return 0;} 四、IP 校验和的设计原理我们将 IP 首部进行简化来讲解 IP 校验和的设计原理，假设 IP 首部只有 6 个字节，第 5,6 字节存放校验和： 计算校验和时第 5,6 字节置为 0，校验和等于：A+B+0，然后取反，即： 接收端收到之后校验步骤为：求校验和（不同的是：校验和位不置 0），若此时求得校验和为 0，则校验通过。即： 五、IP 地址相关操作本节介绍在网络编程中涉及到的与 IP 地址相关的操作 struct in_addr1234567891011121314151617// sizeof(in_addr) == sizeof(ULONG) == 4//typedef struct in_addr { union { struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b; struct { USHORT s_w1,s_w2; } S_un_w; ULONG S_addr; // 4个字节，按网络字节序列存储 // 可以使用inet_addr函数将IP格式字符串转为网络字节序列的整数。 } S_un;// 定义的一些宏，方便访问结构体成员#define s_addr S_un.S_addr /* can be used for most tcp &amp; ip code */#define s_host S_un.S_un_b.s_b2 // host on imp#define s_net S_un.S_un_b.s_b1 // network#define s_imp S_un.S_un_w.s_w2 // imp#define s_impno S_un.S_un_b.s_b4 // imp ##define s_lh S_un.S_un_b.s_b3 // logical host} IN_ADDR, *PIN_ADDR, FAR *LPIN_ADDR; struct sockaddr_in1234567// sizeof(sockaddr_in) == 16struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8];}; struct sockaddr123456// sizeof(sockaddr) == 16//struct sockaddr { u_short sa_family; /* address family */ char sa_data[14]; /* up to 14 bytes of direct address */}; 5.1 转换函数 webrtc 中的IPAddress类和SocketAddress类，对网络地址的操作进行了很好的封装，值得参考。 5.1.1 IP 字符串 -&gt; 整数123unsigned long inet_addr( _In_ const char *cp); 将类似127.0.0.1这样的 IP 字符串转换为网络字节序列的整数 5.1.2 整数 -&gt; IP 字符串123char* FAR inet_ntoa( _In_ struct in_addr in); 将 in_addr（也可以理解为网络字节序列整数）转换为 IP 字符串。 5.2 字节序列转换123456htonshtonlntohsntohlhtonllntohll 对整数（short、long、longlong）进行网络字节序列和主机字节序列间的转换操作。以 htons 为例：h是 host 的首字母，表示主机字节序列；n是 network 的首字母，表示网络字节序列；s代表 short；所以 htons 的功能是，将 short 从主机字节序列转为网络字节序列。 字节序列可以参考：http://blog.csdn.net/china_jeffery/article/details/78401731 5.3 获取本机 IP 地址5.3.1 使用 gethostbyname这种方式有一个弊端：只能获取一个网卡的 IP 地址。 123456789101112131415unsigned long GetLocalIPv4Address() { char hostname[MAX_PATH] = { 0 }; gethostname(hostname, MAX_PATH); struct hostent FAR* lpHostEnt = gethostbyname(hostname); if (lpHostEnt == NULL) { return htonl(0x7f000001); //127.0.0.1 } LPSTR lpAddr = lpHostEnt-&gt;h_addr_list[0]; struct in_addr addr; memcpy(&amp;addr, lpAddr, 4); return addr.s_addr;} 5.3.2 使用 GetAdaptersInfo该方式可以获取本机多块网卡的信息（不限于 IP 地址）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;windows.h&gt;#include &lt;Iphlpapi.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#pragma comment(lib,\"Iphlpapi.lib\")bool GetLocalAddress(std::vector&lt;std::string&gt; &amp;ip_list) { PIP_ADAPTER_INFO pIpAdapterInfo = new IP_ADAPTER_INFO(); unsigned long stSize = sizeof(IP_ADAPTER_INFO); int nRet = GetAdaptersInfo(pIpAdapterInfo, &amp;stSize); if (ERROR_BUFFER_OVERFLOW == nRet) { delete pIpAdapterInfo; pIpAdapterInfo = (PIP_ADAPTER_INFO)new BYTE[stSize]; nRet = GetAdaptersInfo(pIpAdapterInfo, &amp;stSize); } if (ERROR_SUCCESS != nRet) { if (pIpAdapterInfo) { delete pIpAdapterInfo; } return false; } while (pIpAdapterInfo) { IP_ADDR_STRING *pIpAddrString = &amp;(pIpAdapterInfo-&gt;IpAddressList); switch (pIpAdapterInfo-&gt;Type) { case MIB_IF_TYPE_OTHER: case MIB_IF_TYPE_ETHERNET: case MIB_IF_TYPE_TOKENRING: case MIB_IF_TYPE_FDDI: case MIB_IF_TYPE_PPP: case MIB_IF_TYPE_LOOPBACK: case MIB_IF_TYPE_SLIP: { std::string address = pIpAddrString-&gt;IpAddress.String; if (\"0.0.0.0\" == address) break; ip_list.push_back(address); break; } default: break; } pIpAdapterInfo = pIpAdapterInfo-&gt;Next; } if (pIpAdapterInfo) { delete pIpAdapterInfo; } return true;} 《TCP/IP 详解 卷 1：协议》在线阅读地址：http://www.52im.net/topic-tcpipvol1.html 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/2274025898.html"},{"title":"网络协议(4)--ICMP协议","text":"互联网控制消息协议（英文：Internet Control Message Protocol，ICMP）是互联网协议族的核心协议之一。定义在 RFC 792 文档中。ICMP 的消息大致可以分为两类：一类是差错报文，即通知出错原因的错误消息（如traceroute），另一类是查询报文，即用于诊断的查询消息（如ping）。使用 ICMP 协议的典型应用有ping和traceroute（windows 上叫tracert）。 ICMP 是在 IP 数据报的内部被传输的，紧跟着 IP 报文的首部（如果 IP 首部有可选部分，则紧跟着可选部分）：图上的 IP 首部 20 字节是在 IP 报文首部不含可选部分的情况下，若 IP 首部含可选部分，则大于 20 字节。 一、 ICMP 报文格式所有 ICMP 报文的前 4 个字节都是一样的，但剩下的其他字节则根据报文类型的不同而不同。 8位类型字段和8位代码字段共同决定一种 ICMP 报文的类型。 校验和的计算方法和 IP 首部校验和的计算方式相同，但 ICMP 校验和覆盖整个 ICMP 报文。 IP 首部校验和的计算方式和原理参考：网络协议(3)--IP协议UDP 和 TCP 的校验和同样也都覆盖到了他们的首部和数据。 《TCP/IP 详解 卷 1：协议》在线阅读地址：http://www.52im.net/topic-tcpipvol1.html 二、实际应用2.1 Ping2.1.1 Ping 程序原理大多数系统都已经在内核中内置了 ping 服务器的功能，所以不需要单独的其他进程来接收主机的 ping 请求。 windows 系统下，输入ping /?命令查看 ping 的用法如下： 123456789101112131415161718192021222324用法: ping [-t] [-a] [-n count] [-l size] [-f] [-i TTL] [-v TOS] [-r count] [-s count] [[-j host-list] | [-k host-list]] [-w timeout] [-R] [-S srcaddr] [-4] [-6] target_name选项: -t Ping 指定的主机，直到停止。 若要查看统计信息并继续操作 - 请键入 Control-Break； 若要停止 - 请键入 Control-C。 -a 将地址解析成主机名。 -n count 要发送的回显请求数。 -l size 发送缓冲区大小。 -f 在数据包中设置“不分段”标志(仅适用于 IPv4)。 -i TTL 生存时间。 -v TOS 服务类型(仅适用于 IPv4。该设置已不赞成使用，且 对 IP 标头中的服务字段类型没有任何影响)。 -r count 记录计数跃点的路由(仅适用于 IPv4)。 -s count 计数跃点的时间戳(仅适用于 IPv4)。 -j host-list 与主机列表一起的松散源路由(仅适用于 IPv4)。 -k host-list 与主机列表一起的严格源路由(仅适用于 IPv4)。 -w timeout 等待每次回复的超时时间(毫秒)。 -R 同样使用路由标头测试反向路由(仅适用于 IPv6)。 -S srcaddr 要使用的源地址。 -4 强制使用 IPv4。 -6 强制使用 IPv6。 其中-r参数用于记录跃点路由，类似 tracert 的功能，但他们的实现方式不一样，ping 是通过在 IP 头部“选项”字段记录经过的每个路由的 IP 来实现记录路由功能的，这种实现有个限制，就是 IP 首部“选项”字段的最大字节数为 40 字节，所以最多只能记录 10 个 IP。 ping 功能通过 ICMP 的回显请求和回显应答来实现，也就是说 ping 是基于 ICMP 协议实现的。 ICMP 回显请求和回显应答的报文格式如下： 标识符：在实现中，一般将该字段设置为当前进程 ID。这样即使在同一台主机上同时运行了多个 ping 程序实例， ping 程序也可以识别出返回的信息属于哪个进程。 序号：序号一般从 0 开始（没有强制性，从任何数字开始都可以），每发送一次新的回显请求就加 1。因为 ICMP 是在 IP 数据报内部被传输的，而 IP 协议又是不可靠、无连接的，所以 ping 程序打印出返回的每个分组的序列号，方便我们查看是否有分组丢失、失序或重复。 选项：在“选项”字段中，我们一般放入发送时间戳，这样在收到回应的时候可以用来计算本次 ping 的耗时。我们经常会指定 ping 包的大小，所以也会在“选项”字段中填充一些废数据来让包达到一定大小，在下面的FillPingPacket函数就有这样的实现。 2.1.2 C++代码实现定义 ICMP、ping 首部networkprotocolheader.h头文件中定义了 IP 协议、ICMP 协议等协议的首部结构体。 12345678910111213141516171819#pragma pack(1)#define __u8 unsigned char#define __u16 unsigned short#define __u32 unsigned longstruct icmp_common_hdr { __u8 type; __u8 code; __u16 check; /*Other content start here. */};struct ping_header { icmp_common_hdr common_hdr; __u16 id; __u16 seq; __u32 timestamp;};#pragma pack() 程序执行参数12345678910111213DECLARE_bool(h); // 帮助DECLARE_bool(t); // ping指定的主机直到停止DECLARE_int(w); // 等待每次回复的超时时间(毫秒)DECLARE_int(s); // 发送ping包超时时间(毫秒)DECLARE_int(l); // 发送缓冲区大小DECLARE_int(i); // TTLDEFINE_bool(h, false, \"帮助\");DEFINE_bool(t, false, \"ping指定的主机直到停止\");DEFINE_int(w, 3000, \"等待每次回复的超时时间(毫秒)\");DEFINE_int(s, 3000, \"发送ping包超时时间(毫秒)\");DEFINE_int(l, 32, \"发送缓冲区大小\");DEFINE_int(i, 128, \"TTL\"); ping 程序的执行参数的定义和解析由 webrtc 的\"rtc_base/flags.h\"支持。 完整代码代码中的某些功能，如参数解析、断言、时间戳等基于 webrtc 的rtc_base实现，这些功能也可以很方便的自己实现。 另外，使用原始套接字需要管理员权限，如果需要绕开管理员权限，可以使用 windows 提供的IcmpSendEcho系列函数。 在发送 ping 请求的时候，我们只封装了一个 ICMP 报文，并没有自己手动添加 IP 头，封装 IP 报文。因为内核会自动添加 IP 头，如果想自己添加 IP 头，可以调用setsockopt设置IP_HDRINCL选项，告诉内核由我们自己来封装 IP 头。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271#include &lt;WinSock2.h&gt;#include &lt;ws2spi.h&gt;#include &lt;ws2tcpip.h&gt;#include \"rtc_base/networkprotocolheader.h\"#include \"rtc_base/checks.h\"#include \"rtc_base/flags.h\"#include \"rtc_base/timeutils.h\"DECLARE_bool(h); // 帮助DECLARE_bool(t); // ping指定的主机直到停止DECLARE_int(w); // 等待每次回复的超时时间(毫秒)DECLARE_int(s); // 发送ping包超时时间(毫秒)DECLARE_int(l); // 发送缓冲区大小DECLARE_int(i); // TTLDEFINE_bool(h, false, \"帮助\");DEFINE_bool(t, false, \"ping指定的主机直到停止\");DEFINE_int(w, 3000, \"等待每次回复的超时时间(毫秒)\");DEFINE_int(s, 3000, \"发送ping包超时时间(毫秒)\");DEFINE_int(l, 32, \"发送数据大小\");DEFINE_int(i, 128, \"TTL\");void FillPingPacket(__u8* icmp_packet, __u16 seq, __u16 icmp_packet_size) { RTC_DCHECK(icmp_packet); ping_hdr* pping_hdr = reinterpret_cast&lt;ping_hdr*&gt;(icmp_packet); pping_hdr-&gt;common_hdr.type = 8; pping_hdr-&gt;common_hdr.code = 0; pping_hdr-&gt;id = (__u16)GetCurrentProcessId(); pping_hdr-&gt;seq = seq; __u32 now = rtc::Time32(); memcpy((icmp_packet + sizeof(ping_hdr)), &amp;now, sizeof(__u32)); // fill some junk in the buffer. int junk_data_size = FLAG_l - sizeof(__u32); // timestamp int junk_offset = icmp_packet_size - junk_data_size; if(junk_data_size &gt; 0) memset((icmp_packet + junk_offset), 'E', junk_data_size); pping_hdr-&gt;common_hdr.check = 0; pping_hdr-&gt;common_hdr.check = rtc::GetCheckSum(reinterpret_cast&lt;__u16*&gt;(icmp_packet), icmp_packet_size);}void DecodeIPPacket(__u8* ip_packet, __u16 packet_size) { iphdr* ip_hdr = reinterpret_cast&lt;iphdr*&gt;(ip_packet); __u32 now = rtc::Time32(); __u16 ip_hdr_len = ip_hdr-&gt;ihl * 4; // bytes ping_hdr *pping_hdr = reinterpret_cast&lt;ping_hdr*&gt;(ip_packet + ip_hdr_len); if (pping_hdr-&gt;common_hdr.type != 0 || pping_hdr-&gt;common_hdr.code != 0) { printf(\"non-echo response, type=%d, code=%d\\n\", pping_hdr-&gt;common_hdr.type, pping_hdr-&gt;common_hdr.code); return; } if (pping_hdr-&gt;id != (__u16)GetCurrentProcessId()) { printf(\"other process ping response packet, pid=%d\\n\", GetCurrentProcessId()); return; } __u32 timestamp = 0; memcpy(&amp;timestamp, reinterpret_cast&lt;__u32*&gt;((__u8*)pping_hdr + sizeof(ping_hdr)), sizeof(__u32)); in_addr from; from.s_addr = ip_hdr-&gt;saddr; printf(\"%d bytes from %s, time &lt; %d ms, icmp_seq = %d, TTL = %d \\n\", packet_size - ip_hdr_len - sizeof(ping_hdr), inet_ntoa(from), now - timestamp, pping_hdr-&gt;seq, ip_hdr-&gt;ttl );}int main(int argc, char**argv){ rtc::FlagList::SetFlagsFromCommandLine(&amp;argc, argv, true); if (FLAG_h) { rtc::FlagList::Print(NULL, false); return 1; } char *hostname = argv[argc - 1]; if (!hostname || strlen(hostname) == 0) { printf(\"Invalid host name\\n\"); return 1; } if (FLAG_l &lt;= 4) { return 1; } WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); sockaddr_in from; int from_len = sizeof(sockaddr_in); sockaddr_in dest; memset(&amp;dest, 0, sizeof(sockaddr_in)); dest.sin_family = AF_INET; dest.sin_addr.s_addr = inet_addr(hostname); // resolve host name if (dest.sin_addr.s_addr == INADDR_NONE) { unsigned long begin_time = rtc::Time32(); struct addrinfo* result = nullptr; struct addrinfo hints = { 0 }; hints.ai_family = AF_UNSPEC; hints.ai_flags = AI_ADDRCONFIG; int ret = getaddrinfo(hostname, nullptr, &amp;hints, &amp;result); if (ret != 0) { printf(\"Resolve host name failed, error code = %d\\n\", ret); return 1; } unsigned long end_time = rtc::Time32(); struct addrinfo* cursor = result; printf(\"------------------------------\\n\"); printf(\"Resolve [time &lt; %d ms]: \\n\", end_time - begin_time); bool flag = false; for (; cursor; cursor = cursor-&gt;ai_next) { sockaddr_in *paddr_in = reinterpret_cast&lt;sockaddr_in *&gt;(cursor-&gt;ai_addr); printf(\"%s\\n\", inet_ntoa(paddr_in-&gt;sin_addr)); if (!flag) { dest.sin_addr = paddr_in-&gt;sin_addr; flag = true; } } freeaddrinfo(result); printf(\"-------------------------------\\n\"); } printf(\"Ping %s [TTL %d]: \\n\", inet_ntoa(dest.sin_addr), FLAG_i); // socket函数需要管理员权限 // 需要绕开管理员权限，可以使用IcmpSendEcho系列函数 // SOCKET s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP); if (s == INVALID_SOCKET) { printf(\"create socket failed, error code = %d\\n\", WSAGetLastError()); WSACleanup(); return 1; } int err = setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_s), sizeof(FLAG_s)); RTC_DCHECK(err != SOCKET_ERROR); if (err == SOCKET_ERROR) { printf(\"setsockopt for SO_SNDTIMEO failed, error code = %d\\n\", WSAGetLastError()); closesocket(s); WSACleanup(); return 1; } err = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_w), sizeof(FLAG_w)); RTC_DCHECK(err != SOCKET_ERROR); if (err == SOCKET_ERROR) { printf(\"setsockopt for SO_RCVTIMEO failed, error code = %d\\n\", WSAGetLastError()); closesocket(s); WSACleanup(); return 1; } err = setsockopt(s, IPPROTO_IP, IP_TTL, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_i), sizeof(FLAG_i)); RTC_DCHECK(err != SOCKET_ERROR); if (err == SOCKET_ERROR) { printf(\"setsockopt for IP_TTL failed, error code = %d\\n\", WSAGetLastError()); closesocket(s); WSACleanup(); return 1; } // ping request int icmp_packet_size = sizeof(ping_hdr) + FLAG_l; // data __u8 *icmp_packet = new __u8[icmp_packet_size]; RTC_DCHECK(icmp_packet); // ping response __u16 ip_packet_size = icmp_packet_size + 20; // 20 bytes ip header, no option. __u8 *ip_packet = new __u8[ip_packet_size]; RTC_DCHECK(ip_packet); if (!icmp_packet || !ip_packet) { closesocket(s); WSACleanup(); return 1; } __u16 i = 0; while (true) { if (i == 0xFFFF) i = 0; i++; if (!FLAG_t) { if(i &gt; 4) break; } FillPingPacket(icmp_packet, i, icmp_packet_size); int sent = sendto(s, reinterpret_cast&lt;const char*&gt;(icmp_packet), icmp_packet_size, 0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;dest), sizeof(sockaddr)); if (sent == SOCKET_ERROR) { int gle = WSAGetLastError(); if (gle == WSAETIMEDOUT) { printf(\"request timeout\\n\"); continue; } else { printf(\"ping %s failed, error code = %d\\n\", inet_ntoa(dest.sin_addr), gle); break; } } if (sent &lt; FLAG_l) { printf(\"warning, sent %d bytes\\n\", sent); } int bread = recvfrom(s, reinterpret_cast&lt;char*&gt;(ip_packet), ip_packet_size, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;from), &amp;from_len); if (bread == SOCKET_ERROR) { int gle = WSAGetLastError(); if (gle == WSAETIMEDOUT) { printf(\"receive timeout\\n\"); continue; } else { printf(\"ping %s failed, error code = %d\\n\", inet_ntoa(dest.sin_addr), gle); break; } } if (bread &lt; ip_packet_size) { printf(\"too few bytes from %s\\n\", inet_ntoa(from.sin_addr)); continue; } DecodeIPPacket(reinterpret_cast&lt;__u8*&gt;(ip_packet), ip_packet_size); Sleep(1000); } delete [] icmp_packet; delete [] ip_packet; if (s != INVALID_SOCKET) { closesocket(s); } WSACleanup(); return 0;} 运行效果 2.2 TracertTracert 是 windows 系统提供的一个工具，使用该程序可以让我们看到 IP 数据报从一台主机到另一台主机所经过的路由器。Linux 系统也提供了类似的工具，叫 traceroute，功能和 Tracert 一样。 2.2.1 Tracert 原理在介绍 Tracert 的原理之前，需要先弄清楚 IP 首部 TTL 字段的含义，IP 报文每经过一个路由器，路由器都会将该 IP 报文首部的 TTL 字段减 1，当路由器收到一份 IP 数据报的 TTL 是 0 或 1 时，路由器此时不会转发该数据报，而会丢弃该数据报，并且给 IP 数据报首部中的源地址发送一份 ICMP 超时报文。 IP 首部的定义见：网络协议(3)--IP协议 Tracert 利用了路由器会丢弃 TTL 为 1 或 0 的数据报且返回 ICMP 超时报文的特性，来实现侦测路由的功能。Tracert 程序先发送 TTL 值为 1 的 IP 数据报，处理这份数据报的第一个路由器将 TTL 减 1，丢弃该数据报并返回 ICMP 超时报文，这样程序就得到了第一个路由器的地址，以此方式，递增 IP 数据报 TTL 的值，直到数据报最终到达目标主机。 那么怎么判断数据报到达了最终的目标主机呢？我们不能单纯的通过未收到路由器返回的 ICMP 差错报文的方式来判断数据报到达目的地了，因为有可能我们由于接收 ICMP 差错报文超时等原因导致我们收不到 ICMP 差错报文（这也是为什么我们后面会介绍每一个 TTL 跃点会发送 3 次或多次请求的原因）。windows 平台的 tracert 与 linux 平台的 traceroute 的实现原理稍有不同，判断数据报到达目标主机的方式也有不同。tracert 是通过发送 ping 包，因为 windows 系统内核都实现了 ping 功能，所以如果目的主机收到了 ping 请求就会回复相应的 ping 包，tracert 就是通过这种方式来判断数据报是否到达了目标主机。而 traceroute 是通过发送 UDP 包（UDP 端口选择一个不可能使用的 UDP 端口，比如大于 30000 的端口），因为目的主机没有监听该端口，所以不会响应接收到的该 UDP 请求，因此当 UDP 包到达时，目标主机会返回“端口不可达”的错误，traceroute 就是通过该错误来判断 UDP 包到达了目的主机。 从实现方式来看，traceroute 通过 UDP 的方式来实现更加稳定可靠，因为大多数主机的防火墙会组织 ICMP 报文，而不会阻止 UDP 报文。 下图使用 wireshark 抓取的tracert 192.168.3.76命令的数据包，从图中可以看到 tracert 是通过发送 ping 包来实现的，以及每个 ping 包的 TTL 递增过程： 2.2.2 ICMP 差错报文格式路由器在丢弃 TTL 为 0 或 1 的数据报时，会发送一个一份 ICMP 差错报文，该 ICMP 的差错报文的 type 为 11, code 为 0. type 为 11 的报文格式如下（code 有 0 和 1 两种，格式一样）： 2.2.3 实现该示例和之前的 Ping 程序的示例有所不同，该示例设置了IP_HDRINCL选项来自己构造 IP 头部。 程序的启动参数使用 webrtc 的\"rtc_base/flags.h\"实现。 代码中的其他某些功能，如断言、时间戳等基于 webrtc 的rtc_base实现，这些功能也可以很方便的自己实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348#include &lt;WinSock2.h&gt;#include &lt;ws2spi.h&gt;#include &lt;ws2tcpip.h&gt;#include &lt;strsafe.h&gt;#include &lt;algorithm&gt;#include \"rtc_base/networkprotocolheader.h\"#include \"rtc_base/checks.h\"#include \"rtc_base/flags.h\"#include \"rtc_base/timeutils.h\"DECLARE_bool(h); // 帮助DECLARE_int(m); // 最大跃点数DECLARE_int(w); // 等待每次回复的超时时间(毫秒)DECLARE_int(s); // 发送ICMP包超时时间(毫秒)DECLARE_int(n); // 每个跃点发送的请求数DEFINE_bool(h, false, \"帮助\");DEFINE_int(m, 30, \"最大跃点数\");DEFINE_int(w, 3000, \"等待每次回复的超时时间(毫秒)\");DEFINE_int(s, 3000, \"发送ICMP包超时时间(毫秒)\");DEFINE_int(n, 3, \"每个跃点发送的请求数\");const int kPingDataSize = 36;__u32 kLocalIP = 0;__u32 GetLocalIPv4Address() { return inet_addr(\"192.168.42.26\"); char hostname[MAX_PATH] = { 0 }; gethostname(hostname, MAX_PATH); struct hostent FAR* lpHostEnt = gethostbyname(hostname); if (lpHostEnt == NULL) { return htonl(0x7f000001); //127.0.0.1 } LPSTR lpAddr = lpHostEnt-&gt;h_addr_list[0]; struct in_addr addr; memcpy(&amp;addr, lpAddr, 4); return addr.s_addr;}std::string IPv4ToString(__u32 ip) { in_addr addr; addr.s_addr = ip; char *p= inet_ntoa(addr); if (p) return p; return \"\";}std::string GetPrintString(const char* fmt, ...) { char buf[100]; va_list arglist; va_start(arglist, fmt); StringCchVPrintfA(buf, 100, fmt, arglist); va_end(arglist); return buf;}bool print_ip(__u32* ips, int count, __u32 dest_ip) { bool has_ip = false; bool trace_end = false; for (int i = 0; i &lt; count; i++) { if (ips[i] != 0) { printf(\" %s\", IPv4ToString(ips[i]).c_str()); has_ip = true; trace_end = (ips[i] == dest_ip); } } if (!has_ip) printf(\" timeout\"); printf(\"\\n\"); if (trace_end) printf(\"Trace Complete\\n\"); return trace_end;}void FillRequestIPPacket(__u8* ip_packet, __u16 ip_packet_size, __u16 seq, __u8 ttl, __u32 dest_addr) { RTC_DCHECK(ip_packet); iphdr* p_iphdr = reinterpret_cast&lt;iphdr*&gt;(ip_packet); memset(p_iphdr, 0, sizeof(iphdr)); p_iphdr-&gt;version = 4; p_iphdr-&gt;ihl = sizeof(iphdr)/4; // no option p_iphdr-&gt;tos = 0; p_iphdr-&gt;frag_off = 0; p_iphdr-&gt;id = (__u16)rtc::Time32(); p_iphdr-&gt;ttl = ttl; p_iphdr-&gt;protocol = IPPROTO_ICMP; p_iphdr-&gt;tot_len = ip_packet_size; p_iphdr-&gt;daddr = dest_addr; p_iphdr-&gt;saddr = kLocalIP; p_iphdr-&gt;check = rtc::GetCheckSum(reinterpret_cast&lt;__u16*&gt;(p_iphdr), p_iphdr-&gt;ihl*4); ping_hdr* p_ping_hdr = reinterpret_cast&lt;ping_hdr*&gt;(ip_packet + p_iphdr-&gt;ihl*4); p_ping_hdr-&gt;common_hdr.type = 8; p_ping_hdr-&gt;common_hdr.code = 0; p_ping_hdr-&gt;id = (__u16)GetCurrentProcessId(); p_ping_hdr-&gt;seq = seq; // fill some junk in the buffer. if (kPingDataSize &gt; 0) memset((void*)((__u8*)p_ping_hdr+sizeof(ping_hdr)), 'E', kPingDataSize); p_ping_hdr-&gt;common_hdr.check = 0; p_ping_hdr-&gt;common_hdr.check = rtc::GetCheckSum(reinterpret_cast&lt;__u16*&gt;(p_ping_hdr), ip_packet_size - p_iphdr-&gt;ihl*4);}// return source ip addressbool DecodeIPPacket(const __u8* ip_packet, __u16 ip_packet_size, __u32 send_time, __u32* src_addr) { const iphdr* ip_hdr = reinterpret_cast&lt;const iphdr*&gt;(ip_packet); __u32 use_time = rtc::Time32() - send_time; __u16 ip_hdr_len = ip_hdr-&gt;ihl * 4; // bytes const icmp_common_hdr *icmp_hdr = reinterpret_cast&lt;const icmp_common_hdr*&gt;(ip_packet + ip_hdr_len); if (icmp_hdr-&gt;type == 0 &amp;&amp; icmp_hdr-&gt;code == 0) { // 回显应答 const ping_hdr *p_ping_hdr = reinterpret_cast&lt;const ping_hdr*&gt;(icmp_hdr); if (p_ping_hdr-&gt;id != (__u16)GetCurrentProcessId()) { printf(\"other process ping response packet, pid=%d\\n\", GetCurrentProcessId()); return false; } printf(\"%-10s\", GetPrintString(\"&lt;%d ms\", use_time == 0 ? 1 : use_time).c_str()); *src_addr = ip_hdr-&gt;saddr; return true; } else if (icmp_hdr-&gt;type == 11 &amp;&amp; icmp_hdr-&gt;code == 0) { // cause by ttl == 0 printf(\"%-10s\", GetPrintString(\"&lt;%d ms\", use_time == 0 ? 1 : use_time).c_str()); *src_addr = ip_hdr-&gt;saddr; return true; } else { printf(\"unexpected response, type=%d, code=%d\\n\", icmp_hdr-&gt;type, icmp_hdr-&gt;code); return false; }}#define SAFE_RELEASE \\if (req_ip_packet) { \\delete[] req_ip_packet; \\ req_ip_packet = NULL;\\}\\if (rsp_ip_packet) { \\delete[] rsp_ip_packet; \\ rsp_ip_packet = NULL;\\}\\if (s != INVALID_SOCKET) {\\ closesocket(s);\\ s = INVALID_SOCKET;\\}\\WSACleanup();int main(int argc, char**argv) { rtc::FlagList::SetFlagsFromCommandLine(&amp;argc, argv, true); if (FLAG_h) { rtc::FlagList::Print(NULL, false); return 1; } char *hostname = argv[argc - 1]; if (!hostname || strlen(hostname) == 0) { printf(\"Invalid host name\\n\"); return 1; } printf(\"Trace %s\\n\", hostname); WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); sockaddr_in from; int from_len = sizeof(sockaddr_in); kLocalIP = GetLocalIPv4Address(); sockaddr_in dest; memset(&amp;dest, 0, sizeof(sockaddr_in)); dest.sin_family = AF_INET; dest.sin_addr.s_addr = inet_addr(hostname); // resolve host name if (dest.sin_addr.s_addr == INADDR_NONE) { unsigned long begin_time = rtc::Time32(); struct addrinfo* result = nullptr; struct addrinfo hints = { 0 }; hints.ai_family = AF_UNSPEC; hints.ai_flags = AI_ADDRCONFIG; int ret = getaddrinfo(hostname, nullptr, &amp;hints, &amp;result); if (ret != 0) { printf(\"Resolve host name failed, error code = %d\\n\", ret); return 1; } unsigned long end_time = rtc::Time32(); struct addrinfo* cursor = result; printf(\"------------------------------\\n\"); printf(\"Resolve [time &lt; %d ms]: \\n\", end_time - begin_time); bool flag = false; for (; cursor; cursor = cursor-&gt;ai_next) { sockaddr_in *paddr_in = reinterpret_cast&lt;sockaddr_in *&gt;(cursor-&gt;ai_addr); printf(\"%s\\n\", inet_ntoa(paddr_in-&gt;sin_addr)); if (!flag) { dest.sin_addr = paddr_in-&gt;sin_addr; flag = true; } } freeaddrinfo(result); printf(\"-------------------------------\\n\"); } printf(\"Tracing %s [%d max hops]: \\n\", inet_ntoa(dest.sin_addr), FLAG_m); SOCKET s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP); if (s == INVALID_SOCKET) { printf(\"create socket failed, error code = %d\\n\", WSAGetLastError()); WSACleanup(); return 1; } int err = setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_s), sizeof(FLAG_s)); RTC_DCHECK(err != SOCKET_ERROR); if (err == SOCKET_ERROR) { printf(\"setsockopt for SO_SNDTIMEO failed, error code = %d\\n\", WSAGetLastError()); closesocket(s); WSACleanup(); return 1; } err = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_w), sizeof(FLAG_w)); RTC_DCHECK(err != SOCKET_ERROR); if (err == SOCKET_ERROR) { printf(\"setsockopt for SO_RCVTIMEO failed, error code = %d\\n\", WSAGetLastError()); closesocket(s); WSACleanup(); return 1; } int opt = 1; err = setsockopt(s, IPPROTO_IP, IP_HDRINCL, reinterpret_cast&lt;const char*&gt;(&amp;opt), sizeof(opt)); RTC_DCHECK(err != SOCKET_ERROR); if (err == SOCKET_ERROR) { printf(\"setsockopt for IP_HDRINCL failed, error code = %d\\n\", WSAGetLastError()); closesocket(s); WSACleanup(); return 1; } // ip packet for ping request. __u16 req_ip_packet_size = sizeof(iphdr) + sizeof(ping_hdr) + kPingDataSize; __u8 *req_ip_packet = new __u8[req_ip_packet_size]; memset(req_ip_packet, 0, req_ip_packet_size); // ip packet for icmp response or ping echo. __u16 rsp_ip_packet_size = // ICMP差错报文的大小 sizeof(iphdr) + sizeof(icmp_common_hdr) // ICMP(type=11,code=0或1)差错报文 + 4 // unused + sizeof(iphdr) + 8; //取ping包大小和ICMP差错报文大小的最大值，保证无论返回哪种报文缓冲区都够用， //也可以直接分配一个足够大的缓冲区，如1024 // rsp_ip_packet_size = std::max(rsp_ip_packet_size, req_ip_packet_size); __u8 *rsp_ip_packet = new __u8[rsp_ip_packet_size]; memset(rsp_ip_packet, 0, rsp_ip_packet_size); RTC_DCHECK(rsp_ip_packet); int ttl = 1; int seq = 0; __u32 *ips = new __u32[FLAG_n]; for(int hop = 1; hop &lt;= FLAG_m; hop++) { printf(\" %-4d\", hop); for (int i = 0; i &lt; FLAG_n; i++) { ips[i] = 0; seq++; FillRequestIPPacket(req_ip_packet, req_ip_packet_size, seq, ttl, dest.sin_addr.s_addr); __u32 send_time = rtc::Time32(); int sent = sendto(s, reinterpret_cast&lt;const char*&gt;(req_ip_packet), req_ip_packet_size, 0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;dest), sizeof(sockaddr)); if (sent == SOCKET_ERROR) { printf(\"%-10s\", \"*\"); if (i == FLAG_n - 1) if (print_ip(ips, FLAG_n, dest.sin_addr.s_addr)) { SAFE_RELEASE; return 0; } continue; } int bread = recvfrom(s, reinterpret_cast&lt;char*&gt;(rsp_ip_packet), rsp_ip_packet_size, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;from), &amp;from_len); if (bread == SOCKET_ERROR) { int gle = WSAGetLastError(); printf(\"%-10s\", \"*\"); if (i == FLAG_n - 1) if (print_ip(ips, FLAG_n, dest.sin_addr.s_addr)) { SAFE_RELEASE; return 0; } continue; } __u32 dest_ip = 0; DecodeIPPacket(reinterpret_cast&lt;const __u8*&gt;(rsp_ip_packet), rsp_ip_packet_size, send_time, &amp;dest_ip); ips[i] = dest_ip; if (i == FLAG_n - 1) if (print_ip(ips, FLAG_n, dest.sin_addr.s_addr)) { SAFE_RELEASE; return 0; } } ttl++; } SAFE_RELEASE; return 0;} 2.2.4 运行效果： 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/349088656.html"},{"title":"网络协议(5)--UDP协议","text":"一、什么是 UDP 协议？UDP 是 User Datagram Protocol 的简称，中文名是用户数据报协议，是 OSI 参考模型中的传输层协议，它是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。 UDP 的正式规范是IETF RFC768。UDP 在 IP 报文的协议号是 17。 ISO 七层模型： 二、UDP 报头UDP 报头的结构如图： UDP 报头由 4 个部分组成，其中两个是可选的（粉红背景标出部分）： 各 16bit 的来源端口和目的端口用来标记发送和接受的应用进程。因为 UDP 不需要应答，所以来源端口是可选的，如果来源端口不用，那么置为零。 在目的端口后面是长度固定的以字节为单位的报文长度域，用来指定 UDP 数据报包括数据部分的长度，长度最小值为 8byte。 首部剩下地 16bit 是用来对首部和数据部分一起做校验和（Checksum）的，这部分是可选的，但在实际应用中一般都使用这一功能。 UDP 和 TCP 的校验和都覆盖到了他们的首部和数据，而之前介绍的 IP 首部的校验和只覆盖了 IP 首部。 三、TCP 和 UDP 区别 特征点 TCP UDP 是否连接 面向连接 面向非连接 传输可靠性 可靠 会丢包，不可靠 应用场景 传输数据量大 传输量小 速度 慢 快 TCP(传输控制协议)提供的是面向连接、可靠的字节流服务。当客户端和服务器彼此交换数据前，必须先在双方之间建立一个 TCP 连接，之后才能传输数据。TCP 提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。UDP(用户数据报协议)是一个简单的面向数据报的运输层协议。UDP 不提供可靠性，它只是把应用程序传给 IP 层的数据报发送出去，但是并不能保证它们能到达目的地。由于 UDP 在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。 由于 UDP 缺乏拥塞控制（congestion control），需要基于网络的机制来减少因失控和高速 UDP 流量负荷而导致的拥塞崩溃效应。换句话说，因为 UDP 发送者不能够检测拥塞，所以像使用包队列和丢弃技术的路由器这样的网络基本设备往往就成为降低 UDP 过大通信量的有效工具。数据报拥塞控制协议（DCCP）设计成通过在诸如流媒体类型的高速率 UDP 流中，增加主机拥塞控制，来减小这个潜在的问题。 四、应用场景由于缺乏可靠性且属于非连接导向协议，UDP 的应用一般必须允许一定量的丢包、出错和复制粘贴。但有些应用，比如 TFTP，需要可靠性保证，则必须在应用层增加根本的可靠机制。但是绝大多数 UDP 应用都不需要可靠机制，甚至可能因为引入可靠机制而降低性能。流媒体、即时多媒体游戏和 IP 电话（VoIP）就是典型的 UDP 应用。如果某个应用需要很高的可靠性，那么可以用传输控制协议（即 TCP 协议）来代替 UDP。 使用 UDP 协议的应用有：域名系统（DNS）、简单网络管理协议（SNMP）、动态主机配置协议（DHCP）、路由信息协议（RIP）等等。 因为 UDP 不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用 UDP 较多，因为它们即使偶尔丢失几个数据包，也不会对接收结果产生太大影响。 五、单播、多播、广播、组播假设 A(all 简写)代表所有的机器，M(multiple 简写)代表 A 中的多个机器，G(group 简写)代表一组机器，1 代表一台机器，那么： 12345671 -&gt; 1 就是单播；1 -&gt; M 就是多播；1 -&gt; A 就是广播；1 -&gt; G 就是组播；当M=A时，多播就是广播；当M=G时，多播就是组播； 多播包括组播和广播，组播、广播都是多播的一种表现形式。 5.1 单播单播是主机之间“一对一”的通讯模式。发送方需要指定一个接收方的 IP 和端口，只有这个接收方会收到数据报。不会对子网内的其他机器产生影响。在单播模式下，服务器针对每个客户机都要发送数据流，服务器流量=客户机数量×客户机流量，在客户机数量大、每个客户机流量大的应用（如流媒体）中，服务器将不堪重负。 5.1.1 单播发送端因为 UDP 不是面向连接的，且不可靠的，所以发送端在调用sendto之后，就算sendto返回成功，也不代表接收端一定收到了数据，可能接收端压根都没启动，也是有可能的。不能根据sendto的返回值来确保接收端一定收到了数据。如果需要数据传输的可靠性得到保证，可以使用 TCP 或者通过业务逻辑来保证。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;WinSock2.h&gt;#pragma comment(lib, \"Ws2_32.lib\")void SendLogic() { WSADATA wsaData; WORD wVersionRequested = MAKEWORD(1, 0); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0); if (socket == INVALID_SOCKET) { printf(\"WSASocket failed, error=%d\\n\", WSAGetLastError()); return; } sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(6000); // 接收端端口 addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); // 接收端IP char buf[100] = { \"hello\" }; int err = sendto(socket, buf, strlen(buf), 0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)); if (err == SOCKET_ERROR) { printf(\"sendto failed, error=%d\\n\", WSAGetLastError()); return; } printf(\"[SEND] %s OK\\n\", buf); WSACleanup();}int main(){ SendLogic(); getchar(); return 0;} 5.1.2 单播接收端因为 UDP 不是面向连接的，所以接收端不用 listen，也不用 accept，只需要绑定到指定的端口和地址即可。recvfrom是同步的，会阻塞住等待数据的到来。如果要使用异步方式，可以使用WSARecvFrom结合 ICOP 的方式来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;WinSock2.h&gt;#pragma comment(lib, \"Ws2_32.lib\")void RecvLogic() { WSADATA wsaData; WORD wVersionRequested = MAKEWORD(1, 0); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0); if (socket == INVALID_SOCKET) { printf(\"WSASocket failed, error=%d\\n\", WSAGetLastError()); return; } sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(6000); // 端口 addr.sin_addr.s_addr = INADDR_ANY; // 任意IP地址 int err = bind(socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)); if (err == SOCKET_ERROR) { printf(\"bind failed, error=%d\\n\", WSAGetLastError()); return; } while (true) { // TODO：未考虑退出的情况 char buf[100] = { 0 }; int fromlen = sizeof(addr); err = recvfrom(socket, buf, 100, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;addr), &amp;fromlen); if (err == SOCKET_ERROR) { printf(\"recvfrom failed, error=%d\\n\", WSAGetLastError()); return; } printf(\"[RECV] %s\\n\", buf); } WSACleanup();}int main(){ RecvLogic(); getchar(); return 0;} 5.2 广播广播是主机之间“一对所有”的通讯模式。子网的一台主机作为发送发广播一条信息，该子网中的所有主机都可以接收到该信息（不管你是否需要该信息）。在广播模式下，由于服务器不用向每个客户机单独发送数据，所以服务器流量负载极低。无法在广域网上进行广播，而且广播消息不会被路由转发，所以只能在一个子网中进行广播。因为如果路由器转发了广播信息，那么势必会引起网络瘫痪。这也是为什么 IP 协议的设计者故意没有定义互联网范围的广播机制。 主机发送广播消息时，需要指定目的 IP 地址为255.255.255.255和接受者的端口号。 UDP 的广播和单播的不同在于发送端（接收端的实现和单播方式没有区别）的实现上： 发送端将套接字配置为发送广播消息，使用setsockopt函数。 发送地址更改为受限的广播地址255.255.255.255。 需要说明的是广播地址不仅仅只有255.255.255.255一个。广播地址分为受限的广播、指向网络的广播、指向子网的广播、指向所有子网的网广播。255.255.255.255只是受限的广播地址。 5.2.1 广播发送端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;WinSock2.h&gt;#pragma comment(lib, \"Ws2_32.lib\")void SendLogic() { WSADATA wsaData; WORD wVersionRequested = MAKEWORD(1, 0); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0); if (socket == INVALID_SOCKET) { printf(\"WSASocket failed, error=%d\\n\", WSAGetLastError()); return; } // 将套接字配置为发送广播消息 int broadcast = 1; int err = setsockopt(socket, SOL_SOCKET, SO_BROADCAST, reinterpret_cast&lt;const char*&gt;(&amp;broadcast), sizeof(int)); if (err == SOCKET_ERROR) { printf(\"setsockopt failed, error=%d\\n\", WSAGetLastError()); return; } sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(6000); addr.sin_addr.s_addr = INADDR_BROADCAST; // 也可以换成inet_addr(\"255.255.255.255\") char buf[100] = { \"hello\" }; err = sendto(socket, buf, strlen(buf), 0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)); if (err == SOCKET_ERROR) { printf(\"sendto failed, error=%d\\n\", WSAGetLastError()); return; } printf(\"[BROADCAST] %s OK\\n\", buf); WSACleanup();}int main(){ SendLogic(); getchar(); return 0;} 5.2.2 广播接收端(和单播一样)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;WinSock2.h&gt;#pragma comment(lib, \"Ws2_32.lib\")void RecvLogic() { WSADATA wsaData; WORD wVersionRequested = MAKEWORD(1, 0); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0); if (socket == INVALID_SOCKET) { printf(\"WSASocket failed, error=%d\\n\", WSAGetLastError()); return; } sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(6000); addr.sin_addr.s_addr = INADDR_ANY; int err = bind(socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)); if (err == SOCKET_ERROR) { printf(\"bind failed, error=%d\\n\", WSAGetLastError()); return; } while (true) { char buf[100] = { 0 }; int fromlen = sizeof(addr); err = recvfrom(socket, buf, 100, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;addr), &amp;fromlen); if (err == SOCKET_ERROR) { printf(\"recvfrom failed, error=%d\\n\", WSAGetLastError()); return; } printf(\"[RECV] %s\\n\", buf); } WSACleanup();}int main(){ RecvLogic(); getchar(); return 0;} 5.3 组播组播是主机之间“一对多”的通讯模式。一台主机加入一个组播 IP 后，之后向该组播 IP 发送的数据报都会发送到该主机。专门为组播划出了一个地址范围，在 IPv4 中为 D 类地址，范围是224.0.0.0 ~ 239.255.255.255，并将 D 类地址划分为局部链接组播地址、预留组播地址、管理权限组播地址如下：局部链接地址：224.0.0.0～224.0.0.255，用于局域网，路由器不转发属于此范围的 IP 包。 预留组播地址：224.0.1.0～238.255.255.255，用于全球范围或网络协议。 管理权限地址：239.0.0.0～239.255.255.255，组织内部使用，用于限制组播范围。 组播就是将数据发送到一组主机。接收端如果要接收消息，则需要加入到该分组，分组是用 IP 来标识的。从网络协议(3)--IP协议可以知道，适用于分组的 IP 有224.0.0.0 ~ 239.255.255.255。同样，发送端就需要将数据发送到该分组 IP。 5.3.1 组播发送端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;WinSock2.h&gt;#pragma comment(lib, \"Ws2_32.lib\")void SendLogic() { WSADATA wsaData; WORD wVersionRequested = MAKEWORD(1, 0); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0); if (socket == INVALID_SOCKET) { printf(\"WSASocket failed, error=%d\\n\", WSAGetLastError()); return; } // 将套接字配置为发送广播消息 int broadcast = 1; int err = setsockopt(socket, SOL_SOCKET, SO_BROADCAST, reinterpret_cast&lt;const char*&gt;(&amp;broadcast), sizeof(int)); if (err == SOCKET_ERROR) { printf(\"setsockopt failed, error=%d\\n\", WSAGetLastError()); return; } sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(6000); addr.sin_addr.s_addr = inet_addr(\"225.0.0.37\"); // 向指定广播组发送消息 char buf[100] = { \"hello\" }; err = sendto(socket, buf, strlen(buf), 0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)); if (err == SOCKET_ERROR) { printf(\"sendto failed, error=%d\\n\", WSAGetLastError()); return; } printf(\"[BROADCAST] %s OK\\n\", buf); WSACleanup();}int main(){ SendLogic(); getchar(); return 0;} 5.3.2 组播接收端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;WinSock2.h&gt;#include &lt;Ws2ipdef.h&gt;#pragma comment(lib, \"Ws2_32.lib\")void RecvLogic() { WSADATA wsaData; WORD wVersionRequested = MAKEWORD(1, 0); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0); if (socket == INVALID_SOCKET) { printf(\"WSASocket failed, error=%d\\n\", WSAGetLastError()); return; } sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(6000); addr.sin_addr.s_addr = htonl(INADDR_ANY); int err = bind(socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)); if (err == SOCKET_ERROR) { printf(\"bind failed, error=%d\\n\", WSAGetLastError()); return; } // 将SOCKET加入广播组 // struct ip_mreq mreq; // 引入头文件&lt;Ws2ipdef.h&gt; mreq.imr_multiaddr.s_addr = inet_addr(\"225.0.0.37\"); // 广播组地址 mreq.imr_interface.s_addr = htonl(INADDR_ANY); // 注：使用IP_DROP_MEMBERSHIP可以离开广播组 err = setsockopt(socket, IPPROTO_IP, IP_ADD_MEMBERSHIP, reinterpret_cast&lt;const char*&gt;(&amp;mreq), sizeof(ip_mreq)); if (err == SOCKET_ERROR) { printf(\"setsockopt failed, error=%d\\n\", WSAGetLastError()); return; } while (true) { char buf[100] = { 0 }; int fromlen = sizeof(addr); err = recvfrom(socket, buf, 100, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;addr), &amp;fromlen); if (err == SOCKET_ERROR) { printf(\"recvfrom failed, error=%d\\n\", WSAGetLastError()); return; } printf(\"[RECV] %s\\n\", buf); } WSACleanup();}int main(){ RecvLogic(); getchar(); return 0;} 《TCP/IP 详解 卷 1：协议》在线阅读地址：http://www.52im.net/topic-tcpipvol1.html 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/4190400644.html"},{"title":"网络协议(6)--TCP协议","text":"一、TCP 特性尽管 TCP 和 UDP 都是用 IP 协议作为网络层，但 TCP 却提供和 UDP 完全不同的网络服务。TCP 是面向连接的、稳定可靠的字节流服务。TCP 首部的很多字段都是为了实现这 2 大特性而设计的。 在一个 TCP 连接中，仅有两方能进行彼此通信。所以说广播和多播不适用于 TCP 协议。 为了通过 IP 数据报实现可靠性传输，需要考虑很多事情，如数据的破坏、丢包、重复以及分片顺序混乱等问题。TCP 通过检验和、序列号、确认序列号、重发控制、连接管理以及窗口控制等机制来实现可靠性传输。 二、TCP 协议首部摘自《TCP/IP 详解卷 1》中的关于 TCP 首部定义的图： TCP 协议的实现较 UDP 协议复杂太多，它的首部的各个字段的用法也比 UDP 首部字段复杂多，这里先对 TCP 首部字段的功能做个大概的介绍。 16 位源端口号：表示发送端端口号。传输层使用端口号来标识发送端和接收端的应用程序，而网络层是通过 IP 地址来标识主机，这样使用“IP 地址+端口”就可以精确定位到某一台主机上的某一应用程序。 16 位目的端口号：表示接收端端口号。 32 位序列号：序列号用来标识从 TCP 发送端已经发送的字节数。达到最大值$2^{32}-1$之后，再从 0 开始。 32 位确认序列号：确认序列号用来标识 TCP 接收端期望接收的下一个序列号（反过来想也就是，TCP 接收端已经接受到的字节数为确认序列号减去1）。只有ACK标志位为 1 时，该字段才有效。只要 TCP 连接建立，这个字段会一直起作用，也就是说只要 TCP 连接建立，ACK标志位会一直为 1。 4 位首部长度：和 IP 首部一样，是以4个字节(32 bit)为单位的，所以 TCP 首部最大长度也是15*4=60字节。若没有“选项”字段，长度固定为 20 字节。 6 位标志位：他们中的多个可以同时被设置为 1。 123456URG 标记后面的\"16位紧急指针\"是否有效。ACK 标记前面的\"32位确认序号\"是否有效。PSH 接收方应该尽快的将这个报文交给上层的网络层。RST 重建连接。SYN 标记这个TCP段是用来同步初始序号（ISN）的。FIN 标记发送端已经完成了发送任务。 16 位窗口大小：窗口大小为字节数，用于 TCP 的流量控制，这个值是接收端期望接受的字节数。 16 位校验和：和 UDP 类似，校验和覆盖首部和数据部分。 16 位紧急指针：只有前面提到的URG标记位为 1 时，这个字段才有效。 选项：添加一些附加数据。和 UDP 不同，TCP 的“选项”字段使用的比较多。 三、三次握手与四次挥手3.1 完整的 TCP 会话流程图本文通过真实的网络示例来讲解 TCP 的三次握手和四次挥手。读者可以先下载作者写本文时使用的网络包示例，然后使用 wireshark 打开（当然也可以使用 wireshark 随便抓取一个网络包），选中编号为No.9的包，右键选择“追踪流” –&gt; “TCP 流”： 上图是使用 wireshark 抓取的一个 Http 接口请求的过程（不含 DNS 解析等步骤），包含了 TCP 连接建立、Http 请求、Http 响应、TCP 连接断开。现在以这个示例为基础，来画出该 Http 接口请求中涉及的整个 TCP 会话的流程（也是本文最重要的图）： 箭头上方标出了该 TCP 包SYN、ACK、FIN、PSH等标志位的设置情况（大家可能注意到，除了第一个箭头上没有ACK之外，其他的箭头上都有ACK，这是因为ACK标记位只是用于标记 TCP 首部的32位确认序列号是否有效。在此之后的32位确认序列号一直有效，所以也就一直有ACK标记位。）；箭头下发标出了该 TCP 包的序号和确认序号。 seq_num：表示 32 位的序号，紧跟其后括号[]中的是相对序号。 ack_num：表示 32 位的确认序号，紧跟其后括号[]中的是相对确认序号。 payload_len：表示本次 TCP 携带的数据大小（字节）。 在三次握手和四次挥手的部分，旁边的红色粗体字表示当前端的 TCP 状态。在这个示例中是服务端执行主动关闭。 3.2 Wireshark 的相对序号相对序号是 Wireshark 引出的概念，TCP 协议中没有这个概念。Wireshark 使用相对数值来显示序号和确认序号，这个相对值是相对于初始序号（ISN）而言的。因为人类更加习惯跟踪更小数值，所以 Wireshark 默认用相对数值来展示。如果需要查看真实的序号，可以在 wireshark 中选中该网络包，在最下方的数据窗口查看，如： 3.3 Wireshark 的 TCP 流量图我们也可以使用 Wireshark 自带的统计功能来查看整个 TCP 会话的过程。通过菜单“统计” –&gt; “流量图”打开流量图窗口，在“显示”选项选择“显示的分组”，“流类型”选项选择“TCP 流”，如图： 四、TIME_WAIT 及 MSL4.1 TIME_WAIT 状态为何存在？这里我们不使用“客户端”、“服务端”来表示 TCP 连接的 2 端，转而使用“主动断开连接端”、“被动断开连接端”来表示 TCP 通讯的 2 端。因为执行主动断开连接的端可能是服务端也可能是客户端（虽然我们大多数情况下遇到的是客户端执行主动断开）。 在“主动断开连接端”收到了“被动断开连接端”发来的LAST_ACK之后，会给“被动断开连接端”回复一个ACK确认消息。但这个时候为了确保“被动断开连接端”有足够的时间能够收到该消息，“主动断开连接端”不能马上关闭 socket，需要等待一定的时间来确保“被动断开连接端”可以收到ACK确认消息。“主动断开连接端”在等待的这个时间段内的状态我们称之为TIME_WAIT状态。 归纳为一句话就是：TIME_WAIT 状态就是“主动断开的一方”在发送完最后一次 ACK 后进入的等待状态。 4.2 等待时间那么TIME_WAIT状态需要持续多久了，也就是“主动断开连接端”在发送完最后一个 ACK 之后需要等待多久了？《TCP/IP 详解 卷 1：协议》中提到：默认 TIME_WAIT 的超时时间是 2 倍的 MSL。MSL 是Maximum Segment Lifetime的缩写，表示报文的最大生存时间，这个时间和系统的 TCP 实现有关，每个系统是不一样的。 4.2.1 windows 系统 MSL注册表HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters下的TcpTimedWaitDelay键（如果没有可以新建一个）就对应了2*MSL（2 倍的 MSL）的值。 4.2.2 Linux 系统 MSL以 CentOS 为例（摘自网络，仅供参考）： 查看默认的 MSL 值（60s）： 1cat /proc/sys/net/ipv4/tcp_fin_timeout 修改默认为 120： 1echo 120 &gt; /proc/sys/net/ipv4/tcp_fin_timeout 修改完成后，重新加载配置文件： 1sysctl -p /etc/sysctl.conf 查看是否已经生效： 1sysctl -a | grep fin 4.3 SO_REUSEADDR 如果进程中的某个 TCP 连接处于TIME_WAIT等待状态，因为这个等待时间比较长，在这期间该连接使用的端口将一直被占用。 如果一个服务端进程（绑定了某个端口）退出（正常退出或异常退出）后，立即启动一个新的该进程，可能由于 Windows 系统对端口的释放不及时，导致这个端口还没有被释放，不能被再次绑定，从而导致新进程绑定端口失败。 那么遇到上面的问题如何解决了？我们在网络编程中经常设置的SO_REUSEADDR选项就可以解决这个问题， 12int flag = 1;setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast&lt;const char*&gt;(&amp;flag), sizeof(flag)); SO_REUSEADDR提供如下四个功能： SO_REUSEADDR 允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在。这通常是重启监听服务器时出现，若不设置此选项，则bind时将出错。 SO_REUSEADDR 允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地 IP 地址即可。由于设置该Socket选项不需要任何特殊权限，恶意程序可以轻易使用SO_REUSEADDR强制绑定已用于标准网络协议服务的套接字，从而使这些服务拒绝访问。不用担心，我们可以使用SO_EXCLUSIVEADDRUSE选项解决这个问题。 SO_REUSEADDR 允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地 IP 地址即可。这一般不用于 TCP 服务器。 SO_REUSEADDR 允许完全重复的捆绑：当一个 IP 地址和端口绑定到某个套接口上时，还允许此 IP 地址和端口捆绑到另一个套接口上。一般来说，这个特性仅在支持多播的系统上才有，而且只对 UDP 套接口而言（TCP 不支持多播）。 其中第一个功能就可以用来解决该问题。 关于SO_REUSEADDR更详细的介绍可以访问微软的官方文档：using-so-reuseaddr-and-so-exclusiveaddruse 五、为什么要进行 3 次握手？前面的文章介绍了 TCP 的三次握手，那么 TCP 的握手为什么是 3 次了？ 本文从 3 个角度来解释为什么要进行 3 次握手？ 1TCP 的握手的目的是让通信双方都确定双方能够正常发送和接收信息。 第一步，服务端收到客户端发送的 SYN，服务端能够确定如下信息：“客户端的发送功能正常，服务端自己的接受功能正常”。但客户端还什么都不能确定。第二步，客户端收到服务端回复的 SYN+ACK，截至目前，客户端能够确定如下信息：“客户端自己的发送/接收功能都正常，服务端的接收和发送功能都正常”；服务端还是只能确定自己的接受功能正常，还不知道自己的发送功能是否正常，客户端的接受功能是否正常。 大家可以看到，到第二步完成，客户端和服务端能够确认的信息分别如下： 1234567891011客户端能够确定： 客户端-发送 正常 客户端-接收 正常 服务端-发送 正常 服务端-接收 正常服务端能够确定： 客户端-发送 正常 客户端-接收 ？ 服务端-发送 ？ 服务端-接收 正常 从上面表可以看到，第二步完成之后，服务端还能不能确定“服务端的发送功能”和“客户端的接收功能”是否正常。所以需要第三步。 第三步，服务端收到客户端回复的 ACK，服务端能够确定如下信息：客户端的发送功能正常，服务端的接收功能正常。 2我们可以假设“客户端”和“服务端”是 2 个人，模拟这 2 个人打招呼的形式来理解为什么需要 3 次握手。 123客户端：hi，服务端，你能听到我说话吗？服务端：hi，客户端，我能听到你说的话，你能听到我说的话吗？客户端：嗯，服务端，我也能听到你说的话。 3对照文章开始处 TCP 握手图的前 2 步，现在我们假设 TCP 只有 2 次握手： 服务端在收到客户端的SYN并且回复SYN+AKC之后，就认为连接已经建立完成了，并为之分配相应的资源。但客户机却因为网络延迟等问题一直没收到服务端回复的SYN+ACK，这样客户端就认为连接没有建立成功，糟糕的是，客户端会因为连接没有成功而不停的重试，这样每次服务端都会认为连接建立成功并分配资源。 如果按照上面描述的那样，客户端一直没有收到服务端回复的SYN+ACK，且一直这样尝试建立连接，就会造成服务端资源极大的浪费，加重服务端的负担。 六、为什么要进行 4 次挥手？ 对比上面的图，我们不难发现：4 次挥手相比 3 次握手多了一次，主要是因为握手的ACK和SYN是合并在一条发送的，而挥手的ACK和FIN是分开发送的，所以挥手比握手多了一次。 现在我们分析为什么 TCP 挥手的ACK和FIN（分别对应图中的第 2,3 条线）要分开发送？ “被动断开方”之所以叫称之为“被动”是因为 TCP 连接的断开并不是它想的，也不是它主动触发的，是对面的“主动断开方”想要断开的，也许这个时候“被动断开方”还正想发送点数据给“主动断开方”了。 为了让“被动断开方”有机会将想要发送的数据发送完，主动断开方在发送完FIN并收到了ACK确认信息进入FIN_WAIT_2状态后，只关闭了发送功能了，但仍然保留接收功能。这样“被动断开方”就有机会将没有发送完的数据发送完成，发送完成之后，“被动断开方”也发送一个FIN，相当于告诉“主动断开方”：“我的数据已经发完了呀，以后不会再发数据了，你可以安心的把接收功能关闭了，另外我自己也要关闭了呀”。 《TCP/IP 详解 卷 1：协议》在线阅读地址：http://www.52im.net/topic-tcpipvol1.html 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/1504706832.html"},{"title":"网络协议(7)--HTTP与HTTPS协议","text":"HTTP 是Hyper Text Transfer Protocol（超文本传输协议）的缩写。HTTP 协议位于 TCP/IP 协议栈的应用层。 一、HTTP 协议介绍1.1 什么是 HTTPHTTP 是一个客户端和服务器端请求和应答的标准，主要用于从万维网（即WWW，全称 World Wide Web）服务器传输超文本到本地浏览器之间的请求数据和响应数据的协议。客户端通过使用网页浏览器或者其它的工具发起一个 HTTP 请求到服务器上指定端口（默认端口为80），服务器在收到请求之后，返回响应内容（文本、图片等）。 HTTP 协议是基于 TCP 协议来进行数据传输的。 1.2 HTTP 的版本HTTP 协议已经演化出了很多版本，它们中的大部分都是向下兼容的。客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。现在大多使用的都是1.1版本。 1.0 版本： HTTP 协议非常老的标准，为了提高系统的效率，HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。正式因为这种特性造成了一些性能上的缺陷。 1.1 版本： 克服了 HTTP 1.0 的缺陷，HTTP 1.1 支持持久连接（HTTP/1.1 的默认模式使用带流水线的持久连接），在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。同时还增加更多的请求头和响应头来改进和扩充 HTTP 1.0 的功能（如 POST 请求头字段等）。 2.0 版本： 2015 年 5 月作为互联网标准正式发布。主要新增如下特性：多路复用，二进制分帧，首部压缩，服务端推送。 二、HTTP 消息请求2.1 URI、URL、URN通过 HTTP 或者 HTTPS 协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。我们常用的是 URL，那么 URI, URL, URN 之前有什么区别和联系了？ 123URI = Uniform Resource Identifier 统一资源标识符URL = Uniform Resource Locator 统一资源定位符URN = Universal Resource Name 统一资源名称 三者关系如下图： URI用来唯一标识符来标识一个资源，是一个通用的概念，URI由URL和URN两个子集组成。 URL通过描述资源的位置来标识资源。 URN通过资源的名字来标识资源，与其所处的位置无关，这样即使资源的位置发生变动，其URN也不会变化。 HTTP 规范将更通用的概念 URI 作为其资源标识符，但是实际上，HTTP 应用程序处理的只是 URI 的 URL 子集. 2.2 消息请求格式 2.3 HTTP 常见的请求方法HTTP 消息请求的第一个字段就是“请求方法”，HTTP 1.1 中定义的几种常见的请求方法如下（只列出了常用的）： GET向服务器获取数据。使用 GET 请求方法时，消息 Body 中没有“请求数据”（见上面消息格式的图）部分，所以将需要提交到服务器的数据放在 URL 中，因此能够提交到服务器的数据会受到 URL 长度的限制。 12345678910 各个浏览器对URL长度的限制如下（这些限制值可能随着浏览器的版本的更新而发生改变，仅供参考）：1. IE浏览器（Microsoft Internet Explorer） 对URL长度限制是2083（2K+53），超过这个限制，则自动截断（若是form提交则提交按钮不起作用）。2. FirefoxFirefox（火狐浏览器）对URL长度限制是65536字符，但实际上有效的URL最大长度不少于100,000个字符。3. Chromechrome对URL长度限制是8182个字符。4. SafariSafari对URL长度限制是80000字符。5. OperaOpera浏览器对URL长度限制是190000 字符。 POST向服务器提交数据（例如提交表单或者上传文件）。提交的数据包含在 Body 中。 三、HTTP 消息响应3.1 消息响应格式 3.2 HTTP 状态码状态代码由三位数字组成，第一个数字定义了响应的类别，共分五种类别: 123451xx消息—— 请求已被服务器接收，继续处理2xx成功 —— 请求已成功被服务器接收、理解、并接受3xx重定向 —— 需要后续操作才能完成这一请求4xx请求错误 —— 请求含有词法错误或者无法被执行5xx服务器错误 —— 服务器在处理某个正确请求时发生错误 常见的状态码有： 1234567200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，比如：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //由于超载或系统维护，服务器暂时的无法处理客户端的请求 关于 HTTP 状态码的完整定义见：https://tools.ietf.org/html/rfc2616#page-39 四、HTTPS 之密码学基础4.1 对称加密算法对称加密算法（英文：Symmetric-key algorithm）是指密码学中的一类加密算法，又称为：私钥加密、共享密钥加密。这类算法在加密和解密时使用相同的密钥（或者这 2 个密钥可以通过简单的规则相互推算）。“对称加密算法”比“非对称加密算法”速度更快，但对称加密算法的主要缺点在于要求加密和解密的双方获取相同的密钥，这样只要密钥被泄漏，则密文将不再安全。 常见的对称加密算法有： DES: Data Encryption Standard, 数据加密标准，速度较快，适用于加密大量数据的场合。 3DES: Triple DES, 是基于 DES，对一块数据用三个不同的密钥进行三次加密，强度更高。 AES: Advanced Encryption Standard, 高级加密标准，是下一代的加密算法标准，速度快，安全级别高。 Blowfish: 一个 64 位分组及可变密钥长度的对称密钥分组密码算法，可用来加密 64 比特长度的字符串。 IDEA: 在 DES 算法的基础上发展出来的，密钥为 128 位。 RC5 RC6 4.2 非对称加密算法“非对称加密算法”又称为“公开密钥加密”（英语：public-key cryptography）。也一种密码学算法类型，在这类加密算法中，需要一个“密钥对”，即“私钥”和“公钥”。这两个密钥是数学相关，用某个密钥对的“私钥”加密的信息，只能用该密钥对的“公钥”才能解密。同样，用“公钥”加密的信息，也只能用该密钥对的“私钥”才能解密。 “私钥”一般都是自己保留，不透露给他人；而“公钥”可以公开给他人。 “非对称加密算法”比“对称加密算法”安全性更高，不用担心加密密钥的泄漏，因为“公钥”是公开的，不存在泄漏。但“私钥”还是要保存妥当，不能泄露给他人，因为我们不需要在网络上传输“私钥”，所以“私钥”泄露的可能性会小很多。 但是“非对称加密算法”比“对称加密算法”的运算速度慢很多，一般在数据量比较少的时候采用“非对称加密算法”。 如上图，因为李四的“公钥”是公开的，所以张三要给李四发送信息，可以使用李四的“公钥”来加密信息。李四收到密文信息之后就可以使用自己的“私钥”来解密信息。因为其他人没有李四的“私钥”，所以就算密文信息被他人截获也无法解密。 常见的非对称加密算法有： RSA: 由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的。 DSA: Digital Signature Algorithm, 数字签名算法，是一种标准的 DSS（数字签名标准）。 ECC: Elliptic Curves Cryptography, 椭圆曲线密码编码学。 非对称算法虽然安全，但运算速度很慢，而对称算法的速度虽快，但在管理和传输密钥方面会存在安全隐患。在实际的操作过程中，我们通常采用的方式是：采用“非对称加密算法”管理“对称加密算法”的密钥，然后用“对称加密算法”加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。 使用 OpenSSL 生成 RSA 公私钥对 12345// 生成1024位的私钥openssl genrsa -out d:\\rsa_private.pem 1024// 生成私钥对应的公钥openssl rsa -in d:\\rsa_private.pem -pubout -out d:\\ca_public.pem git 客户端安装文件中的提供的ssh-keygen.exe工具也可以用来生产非对称加密的公私钥对。 4.3 散列函数散列函数（英文：Hash Function）是将任意长度的的输入转化为定长输出的算法。编程中对散列函数使用非常普遍，如MD5,但并不是所有的散列函数都适用于密码学。密码学的散列函数必须同时具有如下几个额外的特性： 单向性：给定一个散列值，无法反向找到或者构造出生成它的消息。 抗碰撞性：给定一个消息和它的散列值，无法找到具有相同散列值的不同的消息。 散列函数最常用的场合是以紧凑的方式来唯一表示大量数据，如“数字签名”中用到散列函数生成摘要信息等。 常见的散列函数： MD5：1991 年对 MD4 的改进版本，该算法不可逆。2004 年王小云等人证明了完全碰撞，在理论上说明 MD5 可以被完全攻破，2005 年，Lenstra 等人证明了现实中的碰撞，展示了两张完全不同的证书却拥有同样的 MD5 散列值。所以，目前MD5已经不安全了。 SHA-1：SHA-1 在许多安全协议中广为使用，包括 TLS 和 SSL、PGP、SSH、S/MIME 和 IPsec，曾被视为是 MD5 的后继者，但因为在理论在已经证明 SHA1 可以被破解，但限制于计算机的计算能力所以 SHA-1 被破解还是很困难，所以 SHA-1 的安全性如今被密码学家严重质疑。 SHA-256：SHA-224、SHA-256、SHA-384、SHA-512 一起并称为 SHA-2，至今尚找出对 SHA-2 有效的破解方法。 五、数字签名与数字证书5.1 数字签名数字签名（英文：Digital Signature）类似于我们写在纸上的手写签名，它的诞生主要是为了解决如下问题： 证明该文件（或信息）是由你发送的。 证明该文件（或信息）没有被他人篡改过。 其实，我们生活中手写签名的纸质合同也是通过各种形式达到上面 2 个效果（如：合同一式多份，每份合同都有双方签名等）。 数字签名利用了“非对称加密算法”，签名和验证签名的过程如下图（图中的“认证”部分不是数字签名必须的，在“数字证书”部分会介绍）： 假设“李四”要发送一份数据给“张三”：发送者“李四”对数据生成摘要信息（摘要明文A），然后使用“李四”的“私钥”加密摘要信息；接收者“张三”收到加密的摘要信息之后： 使用“李四”的“公钥”对加密的摘要信息进行解密。若能解密则证明签名是由“李四”所签，这是因为只有“李四”的“私钥”加密的数据才能由“李四”的“公钥”解密，而又只有“李四”才有“李四”的“私钥”。 并将数据使用相同的摘要算法自己也生成一份摘要信息（摘要明文B），然后比较 A 和 B。若两者相等，则证明了该数据内容没有被他人篡改过。 通过上面的过程我们可以知道： 数字签名具有合法性的前提条件是用于加密散列值的“私钥”没有被泄露。 数字签名不负责数据的加密，若要防止数据被他人窥视，则还要结合其他手段，如使用接收者的“公钥”对数据进行加密等。 如何获取签名者的公钥？如何保证获得的公钥就是签名者的，而不是他人的？基于这些问题，数字签名需要结合后面介绍的数字证书来使用（也就是上图中的“认证”文件）。 5.2 数字证书有了上面的公开密钥算法（也就是“非对称加密算法”）之后，我们就可以通过他人的公开密钥（公钥）与其安全通信了，但是还有一些悬而未决的问题： 如何获取那些从未谋面的人的公钥？ 如何存储和吊销这些公钥？ 如何确保获取的公钥就是那个人的？ 公钥基础设施（public key infrastructure, 简称KPI）就是为了解决这个问题而建立的。PKI的目标就是为了实现不同成员在不见面的情况下进行安全通信的，我们当前采用的 PKI 模型是基于可信的第三方机构，也就是“证书颁发机构”（certification authority，简称CA）签发的证书。证书中存储了使用“证书颁发机构”的私钥加密之后的申请者的公钥信息。 5.2.1 数字证书的申请数字证书需要向“证书颁发机构”提交申请，并通过审核之后才能颁发。因为数字证书中存储的是申请者的公钥，所以如果申请者的私钥丢失或泄漏，就需要向“证书颁发机构”申请注销该证书。 Web服务器向CA申请证书的流程大致如图： “证书”中主要包含了经过“证书颁发机构”的私钥加密过后的申请者的“公钥”、“证书有效期”、“申请者信息（如域名等）”。更详细的信息，可以参考《HTTPS 权威指南》第 3.3.1 章节。 5.2.2 数字证书的验证以“Chrome 浏览器”为例：浏览器会内置各大著名的“证书颁发机构”的“公钥”，当收到 Web 服务器返回的“服务器证书”后，Chrome 会尝试使用内置的该“证书颁发机构”的“公钥”来解密该证书，如果能解密则说明该证书是“证书颁发机构”颁发的，且没有被篡改过的。然后通过解密所得的“域名”、“证书有效期”来校验该证书是否为该网站所有，是否过期等。 本文介绍的只是“数字证书”申请和验证的基本的流程，实际流程比这个复杂很多，关于“数字证书”的信息介绍可以参考《HTTPS 权威指南》 六、HTTPS在 HTTP 请求过程中，客户端与服务端之前没有进行身份确认，而且传输的数据都没有加密处理，所以很容易被劫持和篡改。 基于 HTTP 协议的这些弊端，后面就出现了HTTPS（严格的说，HTTPS 并不是一个协议，所以前面文章都没有使用“HTTPS 协议”），HTTPS 是基于SSL/TSL协议的，说白了就是HTTP+SSL/TSL，可以把 HTTPS 大致理解为“HTTP Over SSL”或者“HTTP Over TSL”。 HTTP, SSL/TSL, HTTPS 的关系如下图： 6.1 SSL/TSL 协议6.1.1 SSLSSL（英文：Secure Sockets Layer的缩写）中文叫“安全套接层”。最开始由 NetScape 公司研发，用以保障互联网上数据传输的安全，利用数据加密技术确保数据在网络上之传输过程中不会被截取及窃听。SSL 协议在 TCP/IP 协议栈中位于传输层和应用层之间。以HTTPS为例，SSL 协议就位于 TCP 和 HTTP 之间： 6.1.2 TLSTLS（英文：Transport Layer Security的缩写）中文叫“传输层安全协议”，TLS 1.0是 IETF（Internet Engineering Task Force，Internet 工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为 SSL 3.1，它定义在RFC5246中。 因为 TLS 是基于 SSL 3.0 的，所以也可以认为 TLS 是 SSL 的加强版。 我们一般将二者并称为SSL/TSL协议，因为这二者可以视为同一个产品的不同阶段。 6.2 SSL/TSL 协议的握手过程 在了解 SSL/TSL 协议的握手过程之前，需要先阅读关于 HTTPS 的前几篇文章，对相关预备知识有所了解。 参考上面的流程图，握手过程可以分为 4 个步骤： 1). 客户端发送 Client Hello 请求到服务端，包含如下内容： SSL 或 TSL 协议的版本 客户端生成的随机串Client random； 客户端支持的加密算法列表，用于客户端和服务端加密算法的协商； 客户端支持的 HASH 算法； 2). 服务端发送 Sever Hello 响应到客户端，包含如下内容： 服务端生成的随机串Server random（第 3 步会用到）； 由“CA 证书机构”颁发的证书的Public key部分（Public key和Private Key为一对，用于非对称加密和解密）； 会话 ID 协商的加密算法（对称加密和非对称加密）和 HASH 算法。 3). 客户端发送 Client Key 到服务端，包含如下内容或步骤： 检查服务端返回的“证书”的有效性，如果无效则在浏览器上显示警告。 客户端使用前 2 步生成的Client random和Server random作为随机因子，生成另外一个随机串Premaster。 使用Public key（第 2 步服务端返回）非对称加密的随机串Premaster。 4). 服务端通知客户端握手结束，包含如下内容： 通过解密出来的Premaster生成的本次会话的Session key。 前面所有握手内容的 HASH 值，供客户端校验。 参考：http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html &gt; http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/3654006375.html"},{"title":"网络协议(2)--ARP和RARP协议","text":"ARP(Address Resolution Protocol)地址解析协议，位于 TCP/IP 协议栈中的链路层。当局域网内主机间（或者是主机与网关间）需要通信时，通过使用ARP协议获取目标IP地址对应的硬件MAC地址，然后主机间通过该硬件MAC地址完成数据包发送和接收。 一、ARP 协议1.1 ARP 协议介绍通过使用ARP协议获取目标IP地址对应硬件MAC地址的具体过程如下： 本地主机在局域网中广播ARP 请求，ARP 请求数据帧中包含目的主机的 IP 地址。意思是“如果你是这个 IP 地址的拥有者，请回答你的硬件 MAC 地址”。 目的主机的 ARP 层解析这份广播报文，识别出是询问其硬件地址。于是发送（单播）ARP 应答包，里面包含 IP 地址及其对应的硬件地址。 本地主机收到 ARP 应答后，知道了目的地址的硬件地址，之后的数据报就可以传送了。 1.2 ARP 缓存如果像上面说的那样，每次发包之前都要发送 ARP 请求硬件地址会不会太慢，但是实际上 ARP 的运行是非常高效的。那是因为每一个主机上都有一个 ARP 高速缓存，我们可以通过命令arp -a获取本机 ARP 高速缓存的所有内容： 12345678910111213141516λ arp -a接口: 192.168.42.26 --- 0xb Internet 地址 物理地址 类型 192.168.1.1 00-00-00-00-00-ff 静态 192.168.40.1 f8-75-88-c2-df-c1 动态 192.168.40.74 c8-5b-76-86-c6-06 动态 192.168.40.245 38-d5-47-e1-8a-2f 动态 192.168.42.131 60-a4-4c-65-9f-68 动态 224.14.51.28 01-00-5e-0e-33-1c 静态 224.19.133.150 01-00-5e-13-85-96 静态 224.49.6.212 01-00-5e-31-06-d4 静态 224.50.134.225 01-00-5e-32-86-e1 静态 224.68.111.100 01-00-5e-44-6f-64 静态 224.80.154.130 01-00-5e-50-9a-82 静态 224.88.174.75 01-00-5e-58-ae-4b 静态 通过命令arp -d清除 arp 缓存内容。 1.3 ARP 缓存生存周期在默认情况下，Windows Server 2003 家族和 Windows XP 中，ARP 缓存中的表项仅存储 2 分钟。如果一个 ARP 缓存表项在 2 分钟内被用到，则其期限再延长 2 分钟，直到最大生命期限 10 分钟为止。超过 10 分钟的最大期限后，ARP 缓存表项将被移出，并且通过另外一个 ARP 请求来获得新的对应关系。 ARP 缓存表项的存放时间可以通过改变ArpCacheLife和ArpCacheMinReferencedLife的注册表值来重新设置。 1234567891011HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Tcpip/Parameters键值：ArpCacheLife，设置未被使用的ARP缓存表项可以被保持的时间，类型为Dword，单位为秒，默认值为120。ArpCacheMinReferencedLife，设置被重复使用的表项可以在ARP缓存中存放的时间，类型为Dword，单位为秒，默认值为600。ArpCacheMinReferencedLife和ArpCacheLife的值的使用方法如下：如果ArpCacheLife &gt;= ArpCacheMinReferencedLife，则被使用和未被使用的ARP缓存表项可存储的时间都是ArpCacheLife。如果ArpCacheLife &lt; ArpCacheMinReferencedLife，则未被使用的ARP缓存表项在ArpCacheLife秒的时间后就过期了，被使用的表项的生存期为ArpCacheMinReferencedLife秒。注意：这些键值默认是不存在的，如果你想修改，必须自行创建；修改后重启计算机后生效 1.3 ARP 帧格式 123456789101112131415以太网目的地址：目的主机的硬件地址。目的地址全为1的特殊地址是广播地址。以太网源地址：源主机的硬件地址。帧类型：对于ARP协议，该字段为0x0806。对于RARP协议，该字段为0x8035。硬件类型：表示硬件地址的类型。值为1时表示以太网地址。ARP协议不仅仅应用于以太网协议，还可以支持别的链路层协议。协议类型：表示要映射的协议地址类型。值为0x0800时表示IP协议。硬件地址长度：与硬件类型对应的硬件地址的长度，以字节为单位。如果是以太网，则是6字节（MAC长度）。协议地址长度：与协议类型对应的协议地址长度，以字节为单位。如果是IP协议，则是4字节（IP地址长度）。操作类型（op）：四种操作类型。ARP请求（1），ARP应答（2），RARP请求（3），RARP应答（4）。发送端硬件地址：如果是以太网，则是源主机以太网地址，此处和以太网头中的源地址对应。发送端协议地址：如果是IP协议，则表示源主机的IP地址。目的端硬件地址：如果是以太网，则是目的以太网地址，和以太网头中的目的地址对应。目的端协议地址：如果是IP协议，则表示源主机要请求硬件地址的IP地址。对应ARP请求包来说，目的端的硬件地址字段无须填充，其他字段都需要填充。对于ARP回复包来说，所有字段都需要填充。 1.4 ARP 欺骗ARP 欺骗一般目的是通过某种方式把自己伪装成网关，从而欺骗目标机器，使本应发送到真实网关的数据包发送到欺骗者的机器。 现有如下网络： 1.4.1 如何伪装成网关？我们以主机 A 请求www.csdn.net网站为例，涉及到 ARP 的主要流程如下： 主机 A 通过浏览器打开www.csdn.net（假设通过 DNS 得到的 IP 是47.95.163.175），然后组装需要发送 http 请求包。 主机 A 准备根据默认路由（网关）将数据包发送给192.168.0.1, 但是最开始的时候主机 A 不知道 192.168.0.1 的 MAC 地址, 所以主机 A 广播一条 ARP 请求, 询问 192.168.0.1 的 MAC 地址。 路由器（网关）收到该 ARP 请求, 发现自己是 192.168.0.1 于是向主机 A 回复一条 ARP 应答包, 告诉主机 A 192.168.0.1 的 MAC 地址是 xxxGW. 主机 A 收到该 ARP 响应包, 并向该响应包中的 MAC 地址发送一个 Http 请求包。 路由器（网关）收到该 Http 请求包, 发现目标 IP 是公网 IP, 便将该包放送到公网, 公网返回 Http 应答包给路由器（网关）。 路由器（网关）准备将 Http 响应包发送给192.168.0.100, 但是同第 2 步, 路由器最开始的时候也不知道 192.168.0.100 的 MAC 地址是多少, 所以路由器会广播一条 ARP 请求, 询问 192.168.0.100 的 MAC 地址是多少。 主机 A 收到 ARP 请求, 发现自己是192.168.0.100, 于是向路由器回复一个 ARP 应答包, 告诉路由器192.168.0.100 的 MAC 地址是 xxxA. 路由器（网关）收到 ARP 应答包, 并使用该 APR 应答包中的 MAC 地址将第 5 步收到 Http 响应包发送出去。 试想，如果现在主机 B 做了如下 2 件事情会有什么后果： 主机 B 不停的向主机 A 发送 ARP 应答包, 告诉路由器（网关）192.168.0.1 的 MAC 地址是 xxxB, 会发生什么? 主机 B 不停的向路由器（网关）发送 ARP 应答包, 告诉主机 A 192.168.0.100 的 MAC 是 xxxB, 会发生什么? 如果主机 B 做了上面说的两件事的, 那么主机 A 访问网络的所有数据都会先经过主机 B, 并且从网关发送到主机 A 的数据也都会经过 B, 至此, 整个 ARP 欺骗完成。 但是，如果欺骗者机器不对这些数据包作处理，当被欺骗数据包到达后就会被本机丢弃（因为自己到底不是网关，还不知道如何处理这类数据包），这当然是不允许的。这时开启 IP 转发功能可以解决该问题，IP 转发负责把该类数据包再转发给真正的网关处理，开启 IP 转发的方法： 1sysctl net.ipv4.ip_forward=1 1.4.2 arpspoof 使用在 Ubuntu 或 Kali 等系统上有arpspoof工具可以轻松实现 ARP 欺骗的整个流程。 123456789101112arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host参数：-i 指定用攻击机的哪个网络接口，可以使用ifconfig命令查看攻击机接口列表。-c own|host|both-t 指定arp攻击的目标。如果不指定，则目标为该局域网内的所有机器。可以指定多个目标，如：arpspoof -i etho -t 192.168.32.100 -t 192.168.32.101-r host希望拦截攻击机和哪个host之间的通信，一般都是网关。 二、RARP 协议RARP 协议（Reverse Address Resolution Protocol），反向地址转换协议，也叫逆地址解析协议，主要被那些没有磁盘驱动器的系统使用，如无盘工作站等。 具有本地磁盘的系统引导时，一般是从磁盘中的配置文件读取 IP 地址。但是无盘机，如无盘工作站，则需要采用其他方法获取 ip 地址。网络上的每个系统都具有唯一的硬件地址，它是由网络接口生产厂家配置的。无盘系统的 RARP 实现过程是从网卡上读取唯一的硬件地址，然后发送 RARP 请求到 RARP 服务器，请求该主机在无盘系统的 IP 地址。 文章参考：https://segmentfault.com/a/1190000009562333 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/3034381124.html"},{"title":"小懒","text":"人生于世，一味勤，不见得是好事。 与人处，得小懒。管头管脚，大到原则问题，小至鸡毛蒜皮，样样都想插一手。这样的相处模式，除了惹人厌，再难有其他结果。容他人藏点隐私，给彼此留点空间，这样的小懒，比起所谓的无微不至更令人欣赏。 与人言，也得小懒。话不能说得太满，意犹未尽之处，于人于已都是余地。留有这样的余地，日后才好转圜。同样的意思，横冲直撞与婉转留余，可能带来不同的结果。留一线，好相见，这样的留，自然是小懒。 言语中的小懒，还在于倾听。话不说满，这满是话意，也是话频。一味照着自己的频率说，不顾对方的感受，也不理会对方的想法。这种单方面的所谓沟通，比起无言的槛尬，更令人心生庆烦。话不能说得太满，也不能说得太勤，时时带着点小懒，关注对方的心思，给对方表达的机会，这才是两相宜的沟通方式。 独处，也得带点小懒。忙忙碌碌，俗务缠身，这是很多人的常态。但再忙，总得有那么一些时光，一个人，一本书，一盏茶，静享闲暇之乐。紧绷与小懒，劳与逸，两相结合，人生的路才能走得更远。 养儿育女，其实也需要小懒。能干的父母，容易养出懒情的儿女。事无巨细，大包大揽，自然会让儿女养成依赖的习惯。久而久之，习惯就成了本性。到那时，再怎么怨叹，也无济于事。 人生的小懒，不同于彻底躺平的大懒，也不是任由本性的放纵。一路奔跑之余，总得留有那么一点儿时光，来放任自己的小懒。这样的小懒，如春日的阳光，又似秋日的微风，不多不少，却刚刚好。 作者：郭华悦","link":"/post/2501563677.html"},{"title":"史铁生：职业事业（节选）","text":"选择一项事业（或者找一条能够载渡精神的船）的时候，应该想起兵书上的一句话：知己知彼，百战不殆。没有谁是为了失败而工作的，因为注定的失败不能引导出一个如醉如痴的过程。 所谓知己，就是要知道自己的兴趣何在？自己的禀赋何在？如果你喜欢文学，可你偏偏不肯舍弃一个学化学的机会，且不说没有兴趣你的化学很难学好，即便你小有成就那也是你的悲剧。如果你是一个数学天才，比如说是一个潜在的陈景润，可你对此昏然不知偏要去当一个写小说的，结果多半不妙。 所谓知彼，就是得知道客观条件允许你干什么。如果你热爱起足球的时候已经 40 多岁，你最好安心作一个球迷，千万别学马拉多纳了。如果你羡慕三毛，你也有文学才能，但是你的双腿一动都不能动，你就不要向往撒哈拉，你不如写一写自己心中的沙漠。 我一贯相信，每个人都有自己的所长，倘能扬长避短谁都能有所作为；相反如果弃长取短，天才也能成为蠢才，不信让陈景润与托尔斯泰调换一下工作试试看。对事业的选择，要根据“知己知彼”的原则，可别为“热门”或时髦所左右。 然后还得需要点勇气，需要冒一点风险，没有什么办法能保证你肯定有一条金光大道。我开始想写作的时候，人们提醒我说，你哪儿都去不了不能深入生活，你凭什么能干这一行呢？我自己心里也打鼓。可是我忍不住地想写。我有纸也有笔，还有好多想法，别人一天有 24 小时的生活，我一天也有 24 小时的生活，所有的生活一样都有品味不尽的深意，我就偷偷地写了一点，自己觉得还有希望，于是豁出去了，写！如果你看不出你的选择有什么不对头，你得豁得出去，你得敢于试试，一条道走到黑或者不撞南墙不回头。当然那时我已经在街道生活组挣着自己的饭钱了，我想我最不济是个 0，不会是个负数了。","link":"/post/1173742882.html"},{"title":"C++的API设计规范","text":"《C++ API 设计》是一本非常不错的书，该书内容远远超过了它标题所指的 C++ API 设计，它不仅仅讲述了与编程语言无关的 API 设计需要遵循的一些规范，同时也介绍了很多 C++开发中需要遵守一些准则，如果在开发中能遵循这些准则，将有利于我们写出高质量的代码。 读罢该书，受益匪浅，本文将该书中我认为比较受用的部分摘录下来。 只有两种编程语言：一种是天天挨骂的，另一种是没人用的。 良好的 API 设计的首要目标是：在为客户提供所需功能的前提下，使用新发布的 API 对客户的代码造成的影响应该最小，理想的情况下应该是零影响。 C++ 没有包私有的概念，而是使用更加宽泛的友元的概念，以允许指定的类和方法访问某个类的受保护的和私有的成员。虽然友元可以用来加强封装，但是如果使用不当，它会向用户暴露过多的内部细节。 类的数据成员应该始终声明为私有的，而不是公有的或受保护的。 类只应该定义做什么，而不是怎么做。不要将某一个功能的具体实现步骤暴露出来，即便定义为私有的，也尽量不要这样做。可以使用Pimpl技巧来将所有的私有数据成员和函数隔离到一个.cpp 文件中独立实现的类或结构体内。 不要过度承诺。当不确定是否需要某个接口时，就不要提供此接口。谨记奥卡姆（Occam）剃刀原理：若无必要，勿增实体。 谨慎添加虚函数，使用虚函数要意识到其潜在的隐患： 对基类看似无害的修改可能会给客户带来不利的影响。 客户可能会以你根本无法预料的方式来使用 API。 客户可能采用不正确的或易于出错的方式来扩展 API。 重写虚函数可能破坏类的内部原有逻辑的完整性。 使用虚函数要注意的方面： 虚函数的调用必须在运行时查虚函数表才能决定，无法在编译时决定。 使用虚函数需要维护虚函数表指针，进而增加对象的大小。 添加、重排或者移除虚函数会破坏二进制兼容性。因为虚函数调用通常用类的虚函数表的整型偏移量来表示，所以改变虚函数的顺序，或者执行可能会引起其他虚函数的顺序发送变化的操作，都需要重新编译现有代码。 如果类包含了任一虚函数，那么必须将析构函数声明为虚函数。这样子类就可以释放其可能申请的额外资源。 绝不在构造函数或析构函数中调用虚函数，这些调用不会指向之类。 Sutter 建议接口应该是非虚的，同时在适当的情况下使用模板方法设计模式。 给出清晰的、描述性强的且恰当的名字是 API 设计中最困难的任务之一。 避免编写拥有多个相同类型参数的函数。 使用一致的（统一规范）函数命令和参数顺序。 API 接口应该是平台独立的。不要将平台相关的#if或#ifdef语句放在公共的 API 中，因为这些语句暴露了实现的细节，并使 API 因平台而异。 优秀的 API 表现为松耦合和高内聚。 除非确实需要#include类的完整定义，否则应该为类使用前置声明。 通常，优秀的软件工程实践的目标是去除冗余，即确保每个重要的知识点或行为有且仅有一次实现。而代码复用意味着耦合，因此略微的增加重复以断绝过分的耦合关系有时是值得的。 《C++ API 设计》[美] Martin Reddy 著；刘晓娜，臧秀涛，林健 译","link":"/post/128186902.html"},{"title":"戴建业：阅读习惯与人生未来","text":"人有丑俊，书有浅深。就像人有种种色色一样，书也分不同的性质和层次。 东汉思想家王充将当时的书分为三种：作、述、论。他的名著《论衡》刚杀青时，有人恭维他“可谓作者”，也就是说他的著作算得上是“作”。王充谦逊地说自己的书“非作也，亦非述也，论也”。他把自己的代表作取名为《论衡》。原创性著作可称为“作”，它们横空出世而自铸伟词，属于前无古人且后启来者的经典。或阐述他人之思，或综贯百家之绪，或引申前人之学，虽然没有原创性，但能自成一家言，这一类书籍称为“述”；或记录“思想火花”，或更正当时邪说，或分析一时变故，按王充的说法，属于“杂说”一类的东西统称之为“论”。 今天书籍的种类更为繁多，有经典著作与流行书籍之别，有专业著作与大众读物之殊，有文字读物与视频读物之异……网络上的绝大多数读物没有“书”的形态，但它们赢得了绝大多数读者。这些东西多数不会成书，它们的作者也不想著书。 可喜的是，随着互联网的发达和手机的普及，人类有可能真正实现“知识的普惠”，任何层次任何形式的书籍都能轻易得到，前人蔑视的“引车卖浆之流”都能阅读。地铁里，公交上，休息时，随时随地都能看到“低头一族”。 “引车卖浆之流”意思是拉大车的，做小买卖的。指平民百姓。 不过，这种情况让人“亦喜亦忧”——随着知识的日益普及化，知识也日益浅表化和碎片化。 知识的浅表化不仅在社会大众中存在，在研究生和学者中也很普遍，区别只在五十步与百步之间。譬如要写一篇李白诗中“月亮”意象的论文，前人就得通读李白全集，今人只需要在电脑中敲上“月亮”二字，李白诗歌中所有与“月亮”有关的诗句都蹦了出来。你根本用不着读李白集，甚至用不着去完整地读一首李白诗，一篇上万字的论文就糊弄出来了。前人说李白诗“豪放飘逸”，李诗何以“豪放”，又如何“飘逸”，写文章的作者可能两眼茫然，对前人的评论缺乏深刻的理解，对李白诗歌也缺乏深度的体验。钱锺书谈到李白诗中的月亮，今天学者也谈到李白诗中的月亮，表面上看“月亮还是那个月亮”，但此“月亮”非彼“月亮”。 知识碎片化的情况更为严重。过去获取知识大多来于书本，书本上的知识具有一定的系统性，而且还需要一定的逻辑证明或事实依据，这种知识往往系统完整，而且还具有逻辑上的连贯性。今天，无论是日常生活，还是学术研究，我们都不必积累大量的知识，更不必建立自己的知识结构，什么知识都可以“谷歌”“百度”，什么材料都可以去文献检索。无须穷经皓首，无须博闻强记，无须学识渊博，在生活与研究中照样畅通无阻，在任何一个领域都潇洒无忧。只要你会“谷歌”，会“百度”，会搜索，无知可以显得有知，不学也可以显得博学。 长此以往，我们既难以认知哲人理论体系的深刻严谨，也难以体验诗人情感的博大崇高，甚至无法感受艺术作品的细腻美妙，因而认识会越来越浮浅，心灵会越来越荒芜，审美会越来越庸俗。从来不去碰一碰原创性的经典，我们自己怎么可能会有原创性？ 阅读大体上可以分为三大类：消遣性阅读、鉴赏性阅读与挑战性阅读。 消遣性阅读纯粹是为了消磨时光，比如在手机上刷刷天南地北的奇闻，看看男女明星的恩怨，上购物网上看看今年穿什么裙子，上旅游网上看看去哪些地方自驾游……这种阅读表面上是在“看”，其实是一无所“看”，因为他本来就没有打算去“看”什么，所以他才会什么都“看”。他阅读只是为了排遣无聊，希望这百无聊赖的日子赶快溜走，盼只盼“马儿呀快快地走”，这就是所谓“不做无聊之事，何以遣有涯之生”。 鉴赏性阅读包括听轻盈优美的音乐，看赏心悦目的画册，读文字优美的游记，读情节曲折的小说等等。这类阅读轻松愉快，紧张思考之余，下班归来之后，听听音乐，翻翻画册，品品字帖，读读小品，既能使自己身心放松，又能提高自己的审美能力，还可以使自己情感丰富细腻，这种阅读有“一石三鸟”的多重好处。 最后一种阅读就是挑战性阅读。人类流传下来的伟大经典，还有专业公认的名著，这一类经典著作都是挑战性阅读的读物。要想挑战自己的智力极限，要想攀登灵魂的珠穆朗玛峰，最佳选择就是挑战性阅读，去阅读那些伟大的经典，去结交那些非凡的智者或崇高的伟人。 一位西方作家曾不无调侃地说，所谓“经典著作”就是人人说好，但人人不读的那些书籍。的确，经典大多数是在人们书架上被“供奉”，并不是在人们案头上被阅读。为什么会出现这种情况呢？或深度超出了自己的智力范围，初读往往不知所云，如罗素的《数学原理》、弗雷格的《算术基础》；或行文过于晦涩艰深，超出了一般读者忍受的极限，如康德的《纯粹理性批判》、海德格尔的《存在与时间》；或自己缺乏必要的知识准备，或时代相隔十分遥远，今人无法领略书中的美感，如屈原的骚赋、杜甫的诗歌、但丁的《神曲》。这些经典是人类的精神宝库，但大多数人不得其门而入，它只向那些勤奋坚毅者敞开大门。 经典绝不能“随便翻翻”，再三思考琢磨才能探骊得珠，反复咀嚼才能品咂出它的味道。经典不是心灵的“可口可乐”，我们可以咕噜咕噜地一饮而尽，它需要我们不断钻研才能常读常新，如先秦的《庄子》、司马迁的《史记》、马克思的《资本论》、黑格尔的《精神现象学》，你越读越觉得奇妙无比。倘若真正读懂了这些经典，你会有一种“一览众山小”的开豁；倘若终身浸润于伟大的经典之中，你将“身心获益靡涯，文笔增华有望”。 “探骊得珠”的原意是骊珠，相传为藏在骊龙颔下的宝珠，骊龙栖息深渊中，欲取得骊珠，必须潜入深渊，待骊龙入睡后，再俟机窃取；指获得极为珍贵的宝物；后引申为写作文章能抓住重点，深得题旨的精髓。 可惜，有“会当凌绝顶”雄心的人很多，但最后实现“凌绝顶”志向的人极少。古人常常感叹，“学者如牛毛，成者如麟角”，学无所成的原因是没有定力。人与人拉开差距的关键，大多不是智力的高下，而是毅力与恒心的大小。包括我在内的许多朋友，“会当凌绝顶”的雄心不过一时心血来潮，还没有爬到半山腰就见难而返。 弃难图易是人的天性，“东海西海，心同理同”，套用王尔德的话说，所有人都有惰性，连我也有惰性：只要能读消遣读物我就不读经典，只要能读中文我就不想读英文，只要能读现代文学我就不想读古代文学，只要能看电视我就不想读书，只要能玩手机我就不会看电视…… 当然，今天人们无法拒绝手机阅读和网络阅读。问题是，能否让网络空间也飘溢书香？是否也能在手机上咀嚼经典？看来人们已经发现了问题的严重性，就像大家拒绝快餐食品一样，人们会逐渐改变消遣式浏览，在网络空间中培养挑战性阅读的习惯，同时在纸质书本与网络空间培植深度阅读的土壤。 稍稍留意一下就不难发现，不同的阅读和思考习惯，短时间内看不出有什么差别，时间一长就出现天差地别：有的才华出众，有的“泯然众人”。你自己选择了什么样的阅读习惯，你就为自己选择了什么样的人生。","link":"/post/1878076142.html"},{"title":"客户端软件日志输出规范","text":"众所周知，软件日志对问题的排查可以起到至关重要的作用，但在多人协同开发的情况下，可能会导致不同的人使用不同的日志打印风格，导致日志可阅读性不高。纵观各大知名软件的输出日志，无不有着规范的格式，非常利于阅读。 本日志输出规范仅适用于客户端软件，不适用于服务器端软件。 日志中使用英文。 日志文件采用UTF-8编码。 每条日志的第一个单词的首字母大写，而且每条日志以回车换行符(\\r\\n)结束，不需要写句号.，如： 12// RTC_LOG会自动在日志结尾添加\\r\\nRTC_LOG(LS_INFO) &lt;&lt; \"Forced software decoder fallback enabled\"; 不同语义间使用逗号,分隔，key-value间使用冒号:分隔，如： 123RTC_LOG(LS_INFO) &lt;&lt; \"DataChannel received DATA message, sid: \" &lt;&lt; sid;RTC_LOG(LS_INFO) &lt;&lt; \"Session: \" &lt;&lt; session_id() &lt;&lt; \" is destroyed\";RTC_LOG(LS_ERROR) &lt;&lt; \"Invalid configuration: \" &lt;&lt; config_error.message(); 每条日志需要包含日志打印的时间（日期+时间+时区，精确到毫秒）、日志级别。","link":"/post/449620601.html"},{"title":"聊聊桌面客户端开发的技术选型","text":"桌面客户端（也叫 PC 客户端，支持 Windows、MacOS、Ubuntu 等系统）开发有多种技术选型的方式，每种方式各有优劣。采用不同的方式会导致在开发周期、技术人员构成、软件性能、安装包体积等方面有比较大的差别。本文结合作者多年客户端开发经验，聊聊在客户端开发方面的各种技术选型。 1. WinFormsWinForms（Windows Forms）是微软推出的 UI 框架，可以使用 C#和 Visual Basic 语言开发。WinForms 框架适合开发传统 UI 元素和界面的应用程序，比如工业、医疗领域的管理、控制软件。 WinForms 也能开发出绚丽、非标准化的界面效果，但需要花费较多的时间，对开发人员的技术要求也更高。 基于 WinForms 开发的应用程序需要依赖.Net Framework 运行时，如果用户电脑上未安装，则需要自动为用户安装，否则程序无法运行。 使用 WinForms 开发的应用程序体积本身很小，但为了适应不同的用户电脑环境，安装包需要检测用户电脑上的.Net Framework 运行时版本是否与软件所需版本匹配，如不匹配则需要自动安装相应的.Net Framework 运行时。 .Net Framework 很难做成便携版，通常需要使用微软提供的安装包进行安装，安装.Net Framework 运行时分为在线和离线安装两种方式： 离线安装方式。将微软提供的.Net Framework 离线安装包（不同版本体积不同，如 4.8 版本的离线安装包约 115M 左右）打包进程序安装包，安装时进行释放和安装。这种方式会增加程序安装包的体积。 在线安装方式。将微软提供的.Net Framework 在线安装工具（体积很小，约 1.5M 左右）打包进程序安装包，安装时进行释放和在线安装，这种方式虽然可以减少安装包体积，但在线安装需要实时从微软服务器下载资源，受限于用户网络环境，可能导致安装失败。 1.1 .Net Framework 版本兼容性在.Net Framework 4.5 版本之前，其各个版本之间不相互兼容（无论是向前还是向后都无法兼容），但从 4.5 及以后的版本就可以保证向后兼容了。 举例说明： 如果程序使用.Net Framework 3.5 版本开发，则只能基于该版本的运行时运行。 如果程序使用.Net Framework 4.6 版本开发，则用户电脑上只需要安装&gt;=4.6 版本的运行时即可运行。 1.2 系统自带.Net Framework 版本从 Windows Vista 开始，Windows 系统会自带.Net Framework 运行时，但各个系统自带的运行时版本不同。 下表列出了不同系统自带的.Net Framework 运行时的最低版本： 为什么是最低版本了？因为用户可能通过系统升级的方式更新了.Net Framework 运行时的版本。 操作系统 .Net Framework 运行时版本 Windows XP 1.0 Windows Vista 2.0 Windows 7 3.5 Windows 8 4.5 Windows 10 4.6 ~ 4.7 Windows 11 4.8+ 不同系统所支持的.Net Framework 最高版本也有所不同： Windows XP 最高支持.NET Framework 4.0 Windows 7 最高支持.NET Framework 4.6.2 Windows 8.1 最高支持.NET Framework 4.6.2 Windows 10 和 Windows 11 可以支持任意版本的.NET Framework 1.3 .Net Core .Net Core 官网：https://dotnet.microsoft.com/en-us/ .Net Core 是微软开发的一个开源的、跨平台的（支持 Windows、MacOS、Linux 等系统）通用软件开发框架。在.Net Core 出现之前，开发人员只能基于.Net Framwork 开发 WinForms 应用程序，.Net Core 出现之后，开发人员多了一种选择。 .Net Core 与.Net Framework 最大的不同在于.Net Core 是开源和跨平台的，基于.Net Core 开发的应用程序可以运行在不同的操作系统上，如 Windows、Linux、MacOS。 .Net Core 还处于快速的更新迭代中，之前的老版本对 WinForms 及 WPF 的支持不太好（甚至不支持），建议采用最新版本的.Net Core 进行开发。 使用.Net Core 开发的应用的体积本身非常小，但在打包分发时也需要携带.Net Core 运行时。不同于.Net Framework，.Net Core 运行时既支持安装包的方式，也支持便携版的方式。以.Net Core 6.0 版本为例，微软官方提供的 WindowsDesktop 的运行时大小为 50M，我们可以根据程序实际依赖情况，安装包只包含程序依赖的文件，从而缩减安装包体积（缩减后约 20M 左右）。 2. WPFWPF（Windows Presentation Foundation）也是微软推出的 UI 框架。与 WinForms 一样，可以使用 C#和 Visual Basic 进行开发，也都支持.Net Framework 和.Net Core 两种开发平台。 使用 WPF 框架开发的应用程序界面更加炫酷，界面组件可随意定制化，适合用于对界面要求较高的应用。 WPF 程序的性能稍逊与 WinForms 应用，不过这种性能差别在计算机硬件配置快速提升的今天已在逐渐的被淡化，因此在进行技术选型时 WPF 的性能问题基本可以忽略。 需要注意的是，WPF 应用在启动时通常较慢，比如用户打开应用后需要花费大概 1 秒左右的时间才能看见主界面。 3. MFCMFC（Microsoft Foundation Classes）是微软提供的一个基础类库，对 Windows 系统 API 进行了封装，包含一些基础控件，从而减少应用开发人员的工作量。MFC 应用程序的开发语言为 C++，MFC 提供的控件都是常规的 Windows 风格，和 WinForms 一样，如果需要开发炫丽、交互复杂的界面，需要开发人员花费精力自己绘制，会降低不少开发效率。 MFC 比较适合应用在对软件性能要求较高、调用系统 API 较多、界面交互较简单的软件上。 4. DirectUIDirectUI 是一类技术的统称，即 Paint on parent dc directly，直接在父窗体上进行绘制。是对 MFC 的一种改进，整个窗口只有一个句柄，而不是像 MFC 一样，每个控件都有一个句柄。 目前流行的 DirectUI 界面库大多由个人开发并开源，由于没有专门的团队进行维护，因此使用该类界面库的公司通常需要自己维护一个分支进行 Bug 修复和添加新功能。 常用的 DirectUI 界面库有： duilib 作者已基本不维护。 DuiLib_Ultimate 其他人维护的一个 duilib 版本。 GacUI …… 建议选择技术人员熟练的库，最好熟悉源码可以进行 Bug 修复和功能定制开发。 DirectUI 界面库通常都是轻量级的，因此其开发的应用程序体积都会比较小。 5. QtQt 是一个跨平台的 C++图像界面开发框架，不仅支持 Windows、MacOS、Linux 等 PC 操作系统，还支持嵌入式 QNX、VxWorks 及 Android、iOS 等操作系统。 Qt 的应用非常广泛，是目前使用最广的 C++ 图像界面框架。Qt 应用程序的开发语言为 C++，Qt 比 MFC 上手更快，而且在控件定制、 UI 绘制上也比 MFC 方便。 以 Qt 5.15.2 版本为例，Qt 应用程序打包后的体积最小到 6MB 左右，如果使用更老版本的 Qt，体积可以更小。 5.1 Qt 版权问题Qt 分为开源版本和商业版本，开源版本可以免费使用，商业版本需要付费才能使用。开源版本也可以用于商业用途，但需要遵守相应的规则。 Qt中的大多数模块采用LGPL开源协议，少部分模块采用的是GPL协议，在开发商业软件是我们应选择LGPL协议的模块，并采用Qt动态链接库的方式（而不是静态库的方式）。 对应有些必须静态链接的模块，如QtMain，Qt采用BSD协议，允许在商业软件中使用。 慎用采用GPL协议的模块，该协议具有传染性，它要求所有使用这些模块的软件要开源，因此要慎用GPL协议的模块。 可以在https://www.qt.io/product/features网站查询Qt模块对应的开源协议。 另外如果有对 Qt 源码进行修改，需要公布修改部分的源码。 6. CEF CEF 官网：https://bitbucket.org/chromiumembedded/cef/wiki/Home。 CEF（Chromium Embedded Framework ）是 Google 公司开发的一个跨平台的浏览器内核框架（与 Chrome 浏览器为同一内核），以开源库的方式提供，可以内嵌到第三方程序中用于显示网页以及与网页进行交互。 CEF 自身主要使用 C++进行开发，目前也有 CEF 的其他语言的绑定，比如 CefSharp 就是 C#的绑定。因此基于 CEF 技术方案，可以使用 C++、C#或其他语言作为开发语言，但据我了解大多使用的还是 C++。 在开发中，我们通常不会直接使用 CEF，而是进行二次封装，将其封装成组件，该组件用于打开 Web 页面，由 Web 页面进行界面交互，Javascript 和 C++或 C#进行交互。 为了节省开发时间，可以使用我封装的QCefWidget组件。 CEF 经历了 CEF1 和 CEF3 两个大版本，CEF1 现已基本被淘汰，目前主流的是 CEF3（CEF 2623 版本是最后一个支持 Windows XP 的版本）。 由于版权问题，CEF 默认不支持 MP4 解码，如需支持，需要自行下载源码进行编译（这个过程可能会耗时 1 天左右）。 采用 CEF 内嵌 Web 页面的方式，可以借助 Web 开发的优势，极大提升软件开发效率，Web 页面更新起来也比客户端的升级更加方便。但由于本质还是客户端内嵌浏览器，因此软件内存占用会比较高，通常一个简单的程序可能会占用 100MB 左右。在性能方面，也远远不及上面介绍的其他原生开发方式。 CEF 不同版本的体积差距较大，2623 版本压缩后大约 25MB，而 89.0.18 版本压缩后大约 60MB。不同版本对 Web 新特效的支持程度不同，在不在乎安装包体积的情况下可以选择最新版本，如果需要考虑安装包体积，则需要做出权衡。 采用该技术方案需要由 Web 开发者开发客户端内嵌页面，并 C++开发者开发客户端主体框架，由于 Web 页面无法直接访问系统资源，因此还需 Web 与 C++进行交互，由 C++完成系统功能的开发。 7. Electron前面提到使用 CEF 时需要二次封装，而 CEF 的接口又不是那么易于使用，所以封装一个功能完整、稳定运行的 CEF 组件需要花费不少时间。而 Electron 则是基于 CEF 进行了深层次的封装，Electron 相比自己封装 CEF 会更加稳定，而且可以节省开发和后期维护的时间。 Electron 和 CEF 最大的不同之处是 Electron 可以直接调用 Node.js 的模块，如文件、系统、网络等模块，基于这些模块，理论上可以使用 JavaScript 完成客户端应用的开发，但这也仅限于理论上，实际上由于大多数的 Web 开发者缺少客户端软件开发经验，甚至缺少系统方面的理论基础，因此很难完全依靠 Web 开发者开发出功能完备的客户端软件。 基于 Electron 开发客户端应用时，大多数时候都需要有 C++开发者开发 Node 模块来供 JavaScript 调用。 8. 其他图像界面库除了上面介绍的方案，还要很多其他的优秀界面库，这些库各有特色，目前它们的使用者还没有上面的多。 下面列举了一些我所知道的优秀界面库，欢迎补充： RmlUi yue elements imgui","link":"/post/3110746169.html"},{"title":"Linux GDB调试命令","text":"一、启动GDBgdb -tui：分屏显示源代码gdb -q：不显示开始的提示信息 可以在.bashrc中加入别名： 1alias gdb=\"gdb -q -tui\" 二、开始调试执行run（需要提前设置断点），也可以在调试过程中重新运行调试的程序，run后可以跟随发给该程序的任何参数。 三、常用命令 命令 功能 list（简写l） 显示当前行前面和后面的10行代码 list n1 n2 显示n1到行和n2行之间的代码 list main 显示main函数代码 info functions regex 列出符合正则表达式的函数名称 info breakpoints（简写info b） 查看当前所有的断点信息（断点号，断点类型，断点位置） break func 在当前文件的func函数处设置断点 break fileName:N 在某文件的第N行处设置断点，当前文件第N行设置断点可以忽略fileName break func(或fileName:N) if exp 条件断点，exp成立则断点 delete N 删除第N号断点 delete 删除所有断点 clear N 清除第N行上的断点 watch exp exp成立程序停住 next（简写n） 单步执行，遇到函数会跳过 next N 执行N次单步执行 step（简写s) 单步执行，遇到函数会进入 finish 执行完当前函数，返回到调用它的位置 continue 运行到下一个断点处 until（简写u） 鼠标放到代码行，运行到该代码行停止 jump N 跳转到第N行开始执行，不会主动在N行停住 run 重新运行调试的程序，可以带参数 [Enter] 直接回车执行上次执行的命令 print var（简写p） 查看变量var的值 print /x var 按16进制格式显示变量值 ptype var 查看变量var的结构或类型 backtrach 查看调用堆栈 四、多进程调试在调试多进程程序时GDB默认只会调试主进程，但是GDB（&gt;V7.0）支持对多进程分别或同时调试。换句话说，GDB可以同时调试多个程序。只需要设置follow-fork-mode(默认值：parent)和detach-on-fork（默认值：on）即可。 follow-fork-mode detach-on-fork 说明 parent on 只调试主进程（GDB默认） child on 只调试子进程 parent off 同时调试两个进程，gdb跟主进程，子进程block在fork位置 child off 同时调试两个进程，gdb跟子进程，主进程block在fork位置 设置方法：set follow-fork-mode [parent|child] set detach-on-fork [on|off] 查询正在调试的进程：info inferiors 切换调试的进程： inferior 添加新的调试进程： add-inferior [-copies n] [-exec executable] ,可以用file executable来分配给inferior可执行文件。 其他：remove-inferiors infno， detach inferior","link":"/post/2824175441.html"},{"title":"Windbg基本使用方法","text":"Windbg 是 Microsoft 公司推出的免费的、带 GUI 的调试器，支持 Source 和 Assembly 两种模式的调试。 Windbg 不仅可以调试应用程序，还可以进行系统内核调试，Windbg 支持的平台包括 X86、IA64、AMD64。 一、安装从下面的链接或其他链接下载安装：Download Debugging tools for Windows 二、配置常用的配置包含符号文件搜索路径、可执行文件搜索路径、源码文件搜索路径配置。 2.1 符号文件搜索路径配置在菜单项File -&gt; Symbol File Path中设置，如： 1D:\\symbol_path;SRV*D:\\symbolslocal*http://msdl.microsoft.com/download/symbols 意思是先从D:\\symbol_path中找符号文件；如果没找到，就去服务器中下载并保存到D:\\symbolslocal目录中。 可以使用.sympath+ 命令来添加其他目录到搜索路径中，如.sympath+ D:\\other_symbol_dir。 然后使用.reload来根据新的路径重新搜索并加载符号文件。 2.2 可执行文件路径在菜单项File -&gt; Image File Path中设置，此项是在加载 dump 时，设置可执行文件 exe、dll 的路径的。 2.3 源代码目录配置在菜单项File -&gt; Source File Path中设置源代码目录。如果当前指令指针在源代码范围内，就会自动跳出源文件窗口。源文件窗口中的操作和 vs 类似。如果没有跳出，可以单机菜单项 Open Source File 手动选择源文件 2.4 设置启动产生可以通过对 windbg 加入启动参数的方式来指定符号文件路径和源码路径等等。 1start \"\" \"%~dp0/Debuggers_x86/windbg.exe\" -Q -y \"D:\\symbolslocal*http://msdl.microsoft.com/download/symbols\" -srcpath \"srv*C:\\CodeCache\" 三、开始调试可以通过菜单项File -&gt; Open Executable来加载本地的一个 exe 来进行调试，也可以通过菜单项File -&gt; Attache to a Process来加载一个已经运行的 exe 来进行调试。 具体调试指令可以参考：Help -&gt; Contents -&gt; Debugging Tools for Windows -&gt; Debuggers -&gt; Debugger Reference 四、工作空间Windbg 会保存每个你调试的工程的信息，这些信息包括调试项目的属性、参数、会话状态、调试器设置、及图形界面信息，类似于 ide 的项目文件。 每个调试的工作空间信息默认保存在HKEY_CURRENT_USER\\Software\\Microsoft\\Windbg\\Workspaces中，在这个键下一般有 4 个子键 User、Kernel、Dump、Explicit, 他们分别保存用户态调试，内核态调试、转储文件调试、以及手动保存（Save Workspace As）的工作空间信息。 五、窗口界面介绍 名称 热键 用途 Command Atl+1 输入命令、显示命令结果和调试信息输出 Watch Atl+2 观察指令全局变量、局部变量和寄存器的信息 Locals Atl+3 自动显示当前函数的所有局部变量 Registers Atl+4 观察和修改寄存器的值 Memory Atl+5 观察和修改内存数据 Call Stack Atl+6 栈中记录的函数调用序列 Disassembly Atl+7 反汇编 Scratch Pad Atl+8 白板，可以用来做调试笔记等 Processes and Threads Atl+9 显示所有调试目标的列表，包括进程和线程等 Command Browser Ctrl+N 执行和浏览命令 六、常用命令windbg 命令分为标准命令，元命令和扩展命令。以.开头的元命令提供标准命令没有提供的功能，也内建在调试引擎中。以!开头的扩展命令用于扩展某一方面的调试功能，实现在动态加载的扩展模块中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657tab键 自动完成命令.hh 查看指定命令的帮助手册.reload 重新加载符号文件.restart 重新启动调试目标bp $exentry 在程序入口点设置断点，$exentry是一个伪寄存器bp 0x00401030 在地址0x00401030处设置断点bp MyTestModule!MyTestFunc 在MyTestModule模块中的MyTestFunc函数处设置断点，前提是该模块符号已经加载bp MyTestModule!MyTestClass::SetValue 在模块MyTestModule的MyTestClass类成员函数SetValue处设置断点bp @@C++(MyTestModule!MyTestClass::SetValue) 与上面一样，语法不同，C++语法，上面的为MASM语法bl 查看设置的断点be 激活断点bd 禁用断点bc 删除某个断点ba 设置访问断点ba r 1 0044108c 在内存0044108c的位置开始的下一个字节的读断点ba w4@@C++(&amp;i) 给变量i地址下4个字节的写断点g 运行程序，相当于F5gu 返回函数调用处，相当于shift+F11u 查看当前正要执行的代码k 查看当前调用堆栈~*kb 显示所有进程调用堆栈~ 查看调试进程中的线程信息!teb 线程环境块~. 当前线程信息~# 导致当前异常或调试事件的线程信息~[Number]s 线程切换a 修改当前指令，输入修改的指令按Enter结束s –a 00400000 L53000 “Wrong” 以ASCII码的形式从00400000处开始往后53000个字节搜索字符串“Wrong”db 400000 以二进制的方式显示内存地位为400000开始的内容dd 400000 以DWORD类型查看d 按上一次的d命令的方式来显示，如果不带参数，则从上一次显示结束的地方继续显示?i 查看局部变量i的值，会以10进制和16进制同时显示eb 0012ff78 'a' 'b' 从内存地址0012ff78开始依次写入后面的值r 用于查看或者修改寄存器或伪寄存器r $peb $peb是一个伪寄存器，调试器将它定义为当前进程的进程环境块地址dt 用于查看结构体内容!address 400000 查看指定内存地址的信息dv 查看当前作用域下局部变量的类型和值.ecxr 当前异常的上下文信息!analyze -v 详细显示当前异常信息，常用于分析dmp文件| 所有进程列表|. 当前进程信息|# 导致当前异常或调试事件的进程信息|[Number]s 进程切换!peb 进程环境块!locks 查看进程中有些锁处于锁定状态!cs -l 查看处于锁定状态的关键区!handle 000000c0 f 查看句柄000000c0的信息 七、常用调试方法7.1、附加进程调试使用 File 菜单中的 Attach to a Process 选项来选择要附加调试的进程. 7.2、启动新进程并调试 使用菜单File-&gt; Open Executable选项来选择要启动调试的进程。 启动 windbg 时将待调试的程序的文件路径作为参数传递给 windbg。 新建注册表项。在“HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options”下新建一个以程序名命名的子项，然后在这个子项中新建一个名为Debugger的REG_SZ类型的值，将值设置为 windbg 的全路径，比如：C:\\Program Files (x86)\\Windows Kits\\8.1\\Debuggers\\x86\\windbg.exe。 这样，再运行待调试的程序时，操作系统就会先启动 windbg，并把要调试程序的路径传递给他。 7.3、调试转储文件使用 File 菜单中的 Open Crash Dump 选项来加载 dump 文件。 7.4、远程调试服务器（被调试程序的机器）和客户端（发出远程请求的机器）都应该安装版本相同的 windbg，应该有网络连接或者串行口连接。 以 tcp 端口方式：以命令行的方式启动服务器中的 windbg，如：windbg.exe -server tcp:port=5005以命令行的方式启动客户端中的 windbg，如：windbg.exe -remote tcp:port=5005,server=192.168.1.180 以管道方式：以命令行的方式启动服务器中的 windbg，如：windbg -server npipe:pipe=advdbg （adbdbg 为命名管道名称）。在客户端中以命令行的方式启动 windbg，如：windbg -remote npipe:server=REMOTEHOSTNAME,pipe=advdbg （REMOTEHOSTNAME 为远程主机名，dbvdbg 为远程主机创建的命名管道名，也可以选择 File 菜单中的 Connect to Remote Session,在弹出来的编辑框中输入远程参数 npipe:server=REMOTEHOSTNAME,pipe=advdbg） 成功连接后，命令行信息区会显示类似如下信息： 1...(npipe advdbg) connected at Thu Jul 11 14:22:02 2017 之后可以在客户端或者服务器的 windbg 中执行各种调试命令，执行结果会同时显示在两个调试器中。 其它的远程调试方案，可以参考:https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/remode-debugging-using-windbg","link":"/post/2711697202.html"},{"title":"做人做事做管理","text":"大道至简，越是根源和基本的问题，道理实际上越简单。关于如何做人、做事、做管理的书很多，我看得不多，但是我觉得这些书更多是侧重技术和实现细节上的，而很少从人的思想和观念去讲。从实际根本上去说，如何做人做事是世界观的问题，也是一个哲学话题。很多人和我一样，已经到了30的年纪，是需要去思考一下应该如何做人如何做事的，也需要一套简单、有效、完整的体系来指导自己，而这套体系将是让自己安身立命于这个世界的基石。 职场上如何做人关于在职场上如何做人，我只谨记两个字－－服务。 你要把自己当成一个品牌去爱惜，当成一家公司去经营，你要牢牢记住你之所以能在一家公司立足，是因为公司需要你的服务。 我们经常会抱怨某某银行的工作人员服务态度不好、某某商品的售后服务不好，但从来不去思考自己对公司的服务好不好？公司的任务有没有如期完成，有没有哪个任务是提前完成的，是否所有任务都拖到“最后期限”？工作完成的够不够彻底，是不是答复已经完成了，结果后面又出状况？完成后有没有向上级反馈，是不是等到上级问你完成了没有，你才去报告进度？拖延的任务有没有持续跟进，是不是上级不追了这个任务最后就不了了之了？上面这些问题我都是反复遇见，其实根本原因就是没有意识到你其实在做一项服务，你在公司的发展前景，全都取决你对公司的服务够不够好。设想一下，如果交给你的每件事情都可以迎刃而解、化险为夷，让人感觉稳妥、放心、踏实，你自然会收到更多更重要的“订单”。当你的单多到你忙不过来的时候怎么办？招下属啊，呵呵，恭喜你，你已经是领导了（当然我们也要排除极少数的任人唯亲的公司，大局面是积极向上的）。反之，如果给你一件事情你要拖延，给你一件事情你办不好，给你一件事情就没了下文了，让人不放心，久而久之你就“无单可做”了，那么公司重新请一个人就可以了，干嘛非要用你呢？ 服务不光是对于自己供职的公司，对于公司的客户也是一样的。每一次去客户那里出差前，我总是再三叮嘱自己，我此次之行是为客户做服务的，是去为客户解决问题的。这个心态非常重要，我们做软件系统的，去见客户除了做演示、做培训，很多时候就是处理现场问题，难免遇到客户对系统的投诉，比如系统速度慢、bug多等问题。当你有了这样的心态，你就会谦虚地接受客户的批评，细致地记录客户提出的问题，然后一项项地去思考如何解决，并且应该给客户一份详尽的解决方案。有了这样的心态，你会不自觉地、自然而然地与客户站在一边，让他感到你是在为他着想，帮助他去解决问题的。在你面对客户时，应该有这样一个虔诚的信念：我是去为客户服务的，为他解决他所解决不了的问题的。如果你没有这样的心态，面对投诉很可能就会产生厌烦，而且容易为自己的问题进行辩解。这种做法给客户的感觉就是你竭力在证明你是对的他是错的，这样你就站在客户的对面了。 在客户面前的表现对你的职场发展也是非常有好处的，尤其是接触到一些跨国企业时，你优良的职业素养会为你赢来客户的认同与尊敬。这样当你哪天希望寻找更高的平台，只要放个口风出去，立即就会有Offer了。所以认真服务好客户只赚不赔。 职场上如何做事关于如何做事，也有很多的理论，比如要事第一，把事情分为紧急、重要等等，这些我都不讨论了，我只就我自己的经验来谈一谈。 对于如何做事，我也恪守一个信条：不焦不燥，把心沉下去，将注意力集中于要解决的问题上。 我看过这样一个故事，是说从前有一户人家，家里的菜园中有一块大石头，经常会有人不小心撞到；儿子就问：为什么不把他挖走呢？他的爸爸说：这个石头爷爷的时代就有了，就是因为它那么大，不好挖才一直在那里；又过了一代人，家里的一个媳妇实在受不了，就扛着锄头去挖了，她已经做好了心理准备要挖几天的时间，结果一天就挖完了… …原来那个石头的中间是空的。 我们遇到的很多事情也是一样的，看似棘手、难以解决，实际上只要你认真地去分析、去思考，然后放手去做，往往并没有想象中的那么困难。你需要克服心中的顽石。我发现一些人遇到问题后，很轻易地就会说：这个我做不了，这个实现不了，这个我也没办法。其实就好像看到这块大石头一样，被它的“外表”吓住了，而放弃了应有的行动。 而且我发现了一个有趣的现象，不管多么困难的问题，只要你沉下心去思考如何解决，就好像在冥冥之中上苍在看着你一样，当你拼到最后就要打算认输的时候，往往会出现新的契机和方法。 另外，我发现有些人遇到问题的时候，他想的是这件事如何困难如何难以完成，这样的思维方式是有问题的，是一种保守且退缩的思维；遇到问题的时候，想的应该是如何才能够完成。我一般采取这样几个步骤：1、列出所有的可能性；2、分析各种可能性；3、选择一种实现起来最简单、快速的可能性；4、去实现。 除此以外，我发现一些人在做事的时候，会以“这样做很麻烦”来作为不采纳方案的理由，而不是“这样是否必要”或者“这样是否更好”来作为标准，实际上“麻烦”应该是排在“是否必要”、“是否更好”后面进行考虑的。如果一种实现方式，虽然麻烦，但是很有必要，且对客户来说更好，那么就算麻烦也要去做。但是程序员往往关心的是会不会很麻烦，是不是要修改很多地方，是不是给自己带来很多工作量… …告诉你，你关心的这些不是最重要的。 职场上如何做管理和上面一样，做管理也有很多的细节，我也都不谈了，因为这些都是一本书一本书的讲，而我觉得要简单、有效、好操作，所以我也只说三点。 我觉得做好一个技术经理，只要下面的三点就好了： 1、德行德行其实就是品德，简单地讲就是要善良、诚恳。最重要的，你做事的出发点要是好的，对别人是没有坏心的。 为什么说出发点一定要是好的呢？我们还是以服务客户的例子来说，在为客户解决问题的时候，如果我们的出发点是好的，是站在客户一边尽心尽力去为客户解决问题的，那么即便由于方法、能力、条件等各方面的原因，事情搞砸了或者没有做好，也很容易获得客户的理解和原谅。很可能的情形是，你就算做失败了也一样赢得客户；相反，如果你的出发点是“省麻烦”，“赶紧交差了事”，“完成任务”，如果事情做成了也就算了，一旦失败了，你看看客户会怎么样？告诉你，好的客户会批评你、投诉你，因为他对你还有期望；更多的客户是什么话也不说，直接换个供应商就是了，才懒得理你。 记住永远不要把客户当成傻瓜，你是如何做事情的，客户是很容易感受得到的。所以，面对和服务客户没有那么多的技巧，你不需要有多好的口才和魅力，也用不着忽悠和夸大其词(我发现很多销售人员都是这样，你可以骗客户一次，但就没有第二次了)，你只需要放下身段，兢兢业业地为客户着想，设身处地地解决他的问题就可以。对待下属也是一样的，你对他的奖励也好，惩罚也好，出发点一定要是好的。我对待下属遵循的原则就是：我是在帮助你，帮你把工作做的更好，帮你获得更大的提高，而不是说找你茬儿，跟你过意不去，或者是挤兑你压迫你。德行是基本的，有一个好的德行，至少可以保证你的下属不会讨厌你。 这一点放在做产品上仍然有效，做一个好的产品同样不需要那么多的技巧和花样，从用户实际需求出发，想用户所想，做用户想要的，用户自然买单，盈利也是水到渠成的事情。 2、敬业如果有人问我，下属和经理的区别是什么。我会告诉他：下属等着别人交代事情做，经理想着还有哪些事情可以做。 这其实是一个积极心态的问题，作为一个中层干部，你需要将公司的事情当成自己家的事情来处理，当你有这样的心态，你就是再怎么加班都不会有怨言的，即便分文不取… （有谁见过给自己家装修叫苦不迭的？）如果你可以长期保持这样的状态，你的这种献身精神和敬业精神，会很轻易地感染你的下属和你的同事，你会感觉到在公司左右逢源，而且你也会更有话语权，大家会更重视你的意见，同事和下属也会对你报以更多的信任。当这种情况出现时，管理起下属还会困难吗？但需要注意的是，你的敬业精神不是说体现在无休止的加班上，工作异常繁忙、经常性加班其实是工作没有做好的表现之一，加班只应该出现在紧急情况发生的时候，而不应该是一种常态。 3、技术如果有人问我，技术人员和其他人员最大的区别是什么。我会告诉他：技术人员个个自以为是，认为别人的技术都不如自己。 可能大家不爱听，但我观察到的现象就是这样的，而且往往那些自认为懂得很多的人，实际是还没敲开知识的大门。 很少有人愿意去读别人的代码，彼此都觉得写得好烂。所以，如果想赢得技术人员的钦佩，你需要有压倒性的技术能力。这个压倒性的优势，不是下属70分，你80分，而是下属70分，你要做到100分；下属100分，你要做到150分。所以，缺乏技术能力的人去管理技术人员往往是吃力不讨好的，可能下属表面上服从你，心里根本不当你一回事儿，这样管理起来就存在障碍了。当然，如果你的德行非常好，也非常敬业，技术就显得不那么重要了；而如果你已经满足了前面两条，同时技术也很精湛，那自然是锦上添花了。 上面就是一点点心得，欢迎交流。","link":"/post/1719474789.html"},{"title":"使用WinDbg查看调用堆栈","text":"一. 显示堆栈信息k*命令 1234[~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] [FrameCount][~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] = BasePtr [FrameCount][~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] = BasePtr StackPtr InstructionPtr[~Thread] kd [WordCount] 参数：Thread： &nbsp;指定显示哪个线程的调用堆栈。如果省略该参数，则显示当前线程的调用堆栈。显示所有线程的调用堆栈。b： &nbsp;显示每个函数的前3个参数。p： &nbsp;显示每个函数的所有参数。参数列表包括每个参数的类型、名称、值。P： &nbsp;类似于p*。不同之处在于，每个参数显示在单独的行上面。n： &nbsp;显示调用堆栈中每帧的序号（一般称栈帧，如栈帧3）。FrameCount： &nbsp;指定显示调用堆栈的帧数，即调用堆栈的深度。默认为16进制格式。默认帧数为0x14=20 二. 切换到指定帧信息调用堆栈显示出来之后，如果想知道调用某帧时的相关信息，可以使用.frame来切换到指定的帧，然后就可以使用如dv命令显示局部变量等。 1.frame [/c] [/r] [FrameNumber] /r： &nbsp;显示执行该帧时寄存器的值。 FrameNumber： &nbsp;指定要切换到的帧号。","link":"/post/2414867920.html"},{"title":"由字符串格式化函数引起的崩溃","text":"本文记录一个由错误使用StringCchVPrintf等格式化函数所导致的崩溃问题。 一. 问题描述我们常用的格式化字符串函数有： 123456HRESULT StringCchVPrintf( _Out_ LPTSTR pszDest, _In_ size_t cchDest, _In_ LPCTSTR pszFormat, _In_ va_list argList); 1int printf ( const char * format, ... ); 对于如下的调用： 12char buf[100] = {0};StringCchVPrintf(buf, 100, \"select * from member where name like '%sjj%';\"); 此时buf中存储的并不是期望的select * from member where name like '%sjj%';字符串。不出意外，%sjj%处的%s会变成乱码。 因为函数将%sjj%中的%s当做了字符串格式化串了，而我们又没有给最后一个参数（即可变参数）传值，根据可变参数的原理，默认会根据format参数的地址来取一个地址让%s进行输出。 具体计算方式参考va_start宏定义: 12#define va_start _crt_va_start#define _crt_va_start(ap,v) ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) ) 这个地址的内容是未知的，所以就可能出现乱码或崩溃。 二. 解决方案要解决这个问题，我们只需要做到一点，在调用StringCchVPrintf、vsprintf、vswprintf、_vstprintf、printf等函数时，一定不要将固定字符串传入到pszFormat参数，如： 1StringCchVPrintf(szBuf, 512, \"我想输出单纯的%s，我是错误的格式示范\"); // 错误的 这个时候，单纯的%s中的%s已经不在单纯。 正确的做法是： 1StringCchVPrintf(szBuf, 512, \"%s\", \"我想输出单纯的%s，我是正确的格式示范\"); 同理，下面的调用方式也是错误的、危险的： 12std::string strInfo = GetInfo();printf(strInfo.c_str()); 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/432875265.html"},{"title":"使用WinDbg调试互斥体死锁","text":"本文通过一个实例来讲解如何使用WinDbg来调试Windows Mutex死锁的问题。 一. 演示用例下面是一个会导致Mutex死锁的程序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;process.h&gt;HANDLE hMutexA = NULL;HANDLE hMutexB = NULL;unsigned __stdcall ThreadProc1(void * pArg) { WaitForSingleObject(hMutexA, INFINITE); Sleep(500); WaitForSingleObject(hMutexB, INFINITE); printf(\"+++\\n\"); ReleaseMutex(hMutexB); ReleaseMutex(hMutexA); return 0;}unsigned __stdcall ThreadProc2(void * pArg) { WaitForSingleObject(hMutexB, INFINITE); Sleep(500); WaitForSingleObject(hMutexA, INFINITE); printf(\"...\\n\"); ReleaseMutex(hMutexA); ReleaseMutex(hMutexB); return 0;}int main(){ hMutexA = CreateMutex(NULL, FALSE, TEXT(\"MutexA\")); hMutexB = CreateMutex(NULL, FALSE, TEXT(\"MutexB\")); // 启动线程 HANDLE hThread1 = (HANDLE)_beginthreadex(NULL, 0, ThreadProc1, NULL, 0, NULL); HANDLE hThread2 = (HANDLE)_beginthreadex(NULL, 0, ThreadProc2, NULL, 0, NULL); getchar(); // 等待线程退出并关闭句柄 if (hThread1) { WaitForSingleObject(hThread1, INFINITE); CloseHandle(hThread1); } if (hThread2) { WaitForSingleObject(hThread2, INFINITE); CloseHandle(hThread2); } // 关闭句柄 if(hMutexA) CloseHandle(hMutexA); if(hMutexB) CloseHandle(hMutexB); return 0;} 二. 死锁原因程序生成了2个线程（线程1、线程2）和2个互斥体MutexA和MutexB。观察线程执行代码可知，这是一个典型的死锁用例，2个线程相互等待。 线程1： 拥有MutexA –&gt; 过一段时间(sleep) —&gt; 想拥有MutexB 线程2： 拥有MutexB –&gt; 过一段时间(sleep) —&gt; 想拥有MutexA 线程1想拥有属于线程2的MutexB，而线程2却想拥有属于线程1的MutexA，互不松手，就只能都等着了。 三. Windbg调试~*kvn查看所有线程调用堆栈： 从线程#1栈帧03可以看到其正在等待句柄00000038。从线程#2栈帧03可以看到其正在等待句柄00000034。即：线程#1（ID：22f4）—&gt;等待句柄38线程#2（ID：33bc）—&gt; 等待句柄34 使用!handle命令查看句柄00000034和00000038是什么类型： 从图中可以看到：句柄00000034为名为MutexA的互斥体，被线程ID：2264 拥有。句柄00000038为名为MutexB的互斥体，被线程ID：33bc 拥有。 即：线程#1（ID：22f4）等待00000038（互斥体MutexA ），拥有00000034（互斥体MutexB)线程#2（ID：33bc）等待句柄00000034（互斥体MutexB ），拥有00000038（互斥体MutexA) 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/1092140776.html"},{"title":"使用WinDbg调试关键区死锁","text":"本文通过一个实例来讲解如何使用WinDbg来调试Windows CriticalSection死锁的问题。 一. 演示示例这里有一个关键区锁死问题的程序，运行之后依次点击“CS锁死”按钮、右上角退出按钮，程序就会卡死。 对于眼下的这个问题，界面完全失去响应，这说明负责消息处理的UI线程阻塞了。 对于几乎所有的windows GUI程序，编号为0的初始线程就是UI线程，windows发现该界面一段时间没有消息响应之后就会在标题后面加上“（未响应）”。 二. WinDbg调试启动Windbg，附加到执行进程（F6）。 ~*knv3查看各个线程的调用堆栈，数字3表示显示的堆栈深度，省略即显示完整堆栈。 #0号线的栈帧0表示线程程阻塞在NtWaitForSingleObject函数，MSDN得知该函数原型为： 12345NTSTATUS WINAPI NtWaitForSingleObject( _In_ HANDLE Handle, _In_ BOOLEAN Alertable, _In_ PLARGE_INTEGER Timeout); 第一个参数Handle为其等待的句柄，第三个参数TimeOut为超时时间。同样从栈帧0得知NtWaitForSingleObject正在等待句柄000000c4，超时时间为0（即没信号就一直等待）。 !handle 000000c4 f 命令查看000000c4句柄的信息： 现在我们知道c4句柄就是线程ID:20d0的句柄，主线程在退出的时候等待该线程退出，而该线程一直没有退出，所以主线程卡死了。 根据图3得知20d0线程就是#1线程，~1kvn查看该线程完整堆栈： 栈帧00 NtWaitForSingleObject表示线程在等待000000c0句柄。 !handle!handle 000000c0 f查看句柄信息，得知c0句柄为事件句柄： 123456789101112130:002&gt; !handle c0 fHandle c0 Type Event Attributes 0 GrantedAccess 0x100003: Synch QueryState,ModifyState HandleCount 2 PointerCount 4 Name &lt;none&gt; Object Specific Information Event Type Auto Reset Event is Waiting !locks!locks查看进程中哪些锁处于锁定状态： 从第一行结果可以得知是gcsName临界区（需要有pdb才会显示具体变量名）处于锁定状态。 其实，我们从栈帧02 RtlEnterCriticalSection也可以很快的知道该线程一直在等待进入关键区。 经过分析，知道程序无法退出的原因了：线程#1中的关键区gcsName处于锁定状态（也就是一直等待进入关键区），导致线程#1阻塞无法执行。又因主线程在退出的时候执行了WaitForSingleObject等待#1线程，从而导致主线程卡死。 RTL_CRITICAL_SECTION结构关键区机制主要是通过下面这样的RTL_CRITICAL_SECTION结构来实现的，可以通过dt命令查看该结构定义： 123456780:002&gt; dt RTL_CRITICAL_SECTIONTest1!RTL_CRITICAL_SECTION +0x000 DebugInfo : Ptr32 _RTL_CRITICAL_SECTION_DEBUG +0x004 LockCount : Int4B +0x008 RecursionCount : Int4B +0x00c OwningThread : Ptr32 Void +0x010 LockSemaphore : Ptr32 Void +0x014 SpinCount : Uint4B 其中，LockCount字段用来标识关键区的锁状态，RecursionCount字段用来记录递归次数，用来支持同一个线程多次进入关键区，OwningThread字段用来记录进入（拥有）关键区的线程ID，LockSemaphore用来记录这个关键区对应的事件对象，当有线程需要等待这个关键区时，便是通过等待这个事件来做到的，这个事件对象是按需创建的，如果LockSemaphore为NULL表示这个关键区从来没有线程在此等待过。 通过图6中的OwningThread=738得知，关键区被线程ID为738的线程所拥有，即Enter之后一直没有Leave。 知道了是哪个线程获取了关键区但没有释放，就可以很容易的在代码中定位问题了。 !cs -l!locks没有显示LockSemaphore字段，我们可以通过!cs -l命令获取更为全面的关键区信息： 从上图可以看到LockSemaphore=0xC0，正好是#1线程NtWaitForSingleObject的事件对象。 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","link":"/post/3177767322.html"},{"title":"Wav音频编码","text":"一. WAVE 简介WAV格式是微软公司（Microsoft)开发的一种声音文件格式，它符合 RIFF(Resource Interchange File Format)文件规范，用于保存 Windows 平台的音频信息资源，被 Windows 平台及其应用程序所广泛支持。 WAVE 是录音时用的标准的 WINDOWS 文件格式，文件的扩展名为“WAV”，数据本身的格式为 PCM 或其他压缩数据，属于无损音乐格式的一种。 所有的 WAV 都有一个文件头，这个文件头记录了音频流的编码参数。WAV文件 = WAV头 + PCM数据。 二. 音频编码参数在介绍 WAVE 文件头之前，需要了解下音频编码的各个参数的含义： 声道数量(NumChannels)声道数是指支持能不同发声的音响的个数，它是衡量音响设备的重要指标之一。我们戴的耳机因为只有左右 2 个喇叭，所以最多只能支持 2 个声道数量。单声道（mono）的声道数为 1；立体声道（stereo）的声道数默认为 2，即左右声道；四声道即前左、前右，后左、后右供 4 个发音点；目前还有 5.1 声道、7.1 声道。 对于我们音频编码存储来说，每多一个声道，就要多存储一份数据。 采样率(SampleRate)表示每秒采样的次数，常见的有 8000, 16000, 32000, 44100, 48000。 采样精度(BitPerSample)表示每次从每个声道采样的数据的大小，以比特位单位。一般为 16,32。16 即 16 比特，也就是 2 个字节。 比特率(ByteRate)表示每秒的音频数据大小，以字节为单位，可以根据上面几个参数求得。ByteRate = SampleRate * NumChannels * BitPerSample / 8 三. WAVE 文件头 偏移 字段字节数 字段名 解释 0 4 ChunkID “RIFF”串 十进制大端表示为 0x52494646 4 4 ChunkSize 整个文件的大小减去 8 字节(ChunkID+ChunkSize)。36 + SubChunk2Size或者 4 + (8 + SubChunk1Size) + (8 + SubChunk2Size) 8 4 Format “WAVE”串，十六进制大端表示为 0x57415645 12 4 Subchunk1ID “fmt “串，十六进制大端表示为 0x666d7420 16 4 Subchunk1Size 整个 Subchunk1 的大小减去该字段本身所占的 4 字节，对于 PCM 来说固定为 16 20 2 AudioFormat PCM 格式为 1，大于 1 表示其他压缩格式 22 2 NumChannels 声道数量，如 Mono = 1, Stereo = 2 24 4 SampleRate 采样率，如 8000, 44100 等 28 4 ByteRate 比特率， 等于SampleRate * NumChannels * BitsPerSample/8 32 2 BlockAlign 每个 Sample 的大小，等于NumChannels * BitsPerSample/8 34 2 BitsPerSample 采样精度，如 8,16,32 36 4 Subchunk2ID “data”串，十六进制大端表示为 0x64617461 40 4 Subchunk2Size 实际音频数据的大小，不包含 Subchunk2ID 和 Subchunk2Size 这 2 个字段的大小 44 * Data 实际的音频数据 下图是以十六进制显示的一个 WAV 文件的前 72 字节： 四. 从其他编码转 WAVE我们可以使用 ffmpeg.exe 将音频从其他编码转为 wave 编码，命令如下: 1ffmpeg.exe -i input.mp3 output.wav 我们还可以指定输出文件的编码格式，如采用率，采样精度，声道数，如： 1ffmpeg.exe -f u16le -ar 44100 -ac 1 -i input.mp3 output.wav ffmpeg 参数解释见：http://trac.ffmpeg.org/wiki/audio%20types ffmpeg 生成的 wav 文件的文件头可能和我们上面介绍的不太一样，它可能会包含LIST和INFO数据块，这个时候我就需要通过 2 个步骤来生成不包含LIST和INFO数据块的 WAV 文件了：首先通过 ffmpeg.exe 将音频文件转成 pcm 裸数据文件，然后使用其他工具（如audacity）为该 pcm 裸数据加上 wav 头。 ffmpeg 将音频转成 pcm 裸数据命令如下： 1ffmpeg.exe -f s16le -c:a pcm_u16le -i input.mp3 output.raw 五、WebRTC 对 Wav 格式支持WebRTC 源码src\\common_audio目录中的wav_header.h和wav_file.h提供了对 wav 的读写功能。","link":"/post/3666885372.html"},{"title":"流媒体基础概念","text":"一、流媒体协议1.1 RTP (Real-time Transport Protocol)1.1.1 RTP 特征实时传输协议（Real-time Transport Protocol）是一个网络传输层协议，它是由 IETF 的多媒体传输工作小组 1996 年在 RFC 1889 中公布的，它作为因特网标准在 RFC 3550（该文档的旧版本是 RFC 1889）有详细说明，RTP 标准定义了两个子协议：RTP 和 RTCP。 RTP 协议是建立在 UDP 协议上的。 RTP 协议详细说明了在互联网上传递音频和视频的标准数据包格式。RTP 协议常用于流媒体系统（配合 RTCP 协议）、视频会议和视频电话系统（配合 H.263 或 SIP）。 RTP 标准由两个紧密链接部分组成： RTP —- 传送具有实时属性的数据； RTP 控制协议（RTCP）—-监控服务质量并传送正在进行的会话参与者的相关信息。 RTP 本身并没有提供按时发送机制或其他服务质量（QoS）保证，它依赖于底层服务去实现这一过程。RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。RTP 实行有序传送，RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。 1.1.2 RTP 报头RTP 报头格式如下： V：RTP 协议的版本号，占 2 位，当前协议版本号为 2。 P：填充标志，占 1 位，如果 P=1，则在该报文的尾部填充一个或多个额外的八位组，它们不是有效载荷的一部分。 X：扩展标志，占 1 位，如果 X=1，则在 RTP 报头后跟有一个扩展报头。 CC：CSRC 计数器，占 4 位，指示 CSRC 标识符的个数。 M: 标记，占 1 位，不同的有效载荷有不同的含义，对于视频，标记一帧的结束；对于音频，标记会话的开始。 PT: 有效载荷类型，占 7 位，用于说明 RTP 报文中有效载荷的类型，如 GSM 音频、JPEM 图像等。 序列号：占 16 位，用于标识发送者所发送的 RTP 报文的序列号，每发送一个报文，序列号增 1。接收者通过序列号来检测报文丢失情况，重新排序报文，恢复数据。 时戳(Timestamp)：占 32 位，时戳反映了该 RTP 报文的第一个八位组的采样时刻。接收者使用时戳来计算延迟和延迟抖动，并进行同步控制。 同步信源(SSRC)标识符：占 32 位，用于标识同步信源。该标识符是随机选择的，参加同一视频会议的两个同步信源不能有相同的 SSRC。 特约信源(CSRC)标识符：每个 CSRC 标识符占 32 位，可以有 0 ～ 15 个。每个 CSRC 标识了包含在该 RTP 报文有效载荷中的所有特约信源。 这里的同步信源是指产生媒体流的信源，它通过 RTP 报头中的一个 32 位数字 SSRC 标识符来标识，而不依赖于网络地址，接收者将根据 SSRC 标识符来区分不同的信源，进行 RTP 报文的分组。特约信源是指当混合器接收到一个或多个同步信源的 RTP 报文后，经过混合处理产生一个新的组合 RTP 报文，并把混合器作为组合 RTP 报文的 SSRC，而将原来所有的 SSRC 都作为 CSRC 传送给接收者，使接收者知道组成组合报文的各个 SSRC。 1.2 RTCP (Real-time Transport Control Protocol)实时传输控制协议（Real-time Transport Control Protocol,RTCP）是实时传输协议（RTP）的一个姐妹协议。 RTCP 为 RTP 媒体流提供信道外控制。RTCP 定期在多媒体流会话参加者之间传输控制数据。RTCP 的主要功能是为 RTP 所提供的服务质量提供反馈。 RTCP 收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，时延抖动，单向和双向网络延迟等等。网络应用程序可以利用 RTCP 所提供的信息试图提高服务质量，比如限制信息流量或改用压缩比较小的编解码器。RTCP 本身不提供数据加密或身份认证，其伴生协议SRTCP（安全实时传输控制协议）则可用于此类用途。 WebRTC 内部采用的是 RTC+RTCP 1.3 SRTP &amp; SRTCPSRTP = Secure Real-time Transport ProtocolSRTCP = Secure Real-time Transport Control ProtocolSRTP 是在实时传输协议 RTP 基础上所定义的一个协议，旨在为单播和多播应用程序中的实时传输协议的数据提供加密、消息认证、完整性保证和重放保护。它是由 David Oran（思科）和 Rolf Blom（爱立信）开发的，并最早由 IETF 于 2004 年 3 月作为 RFC 3711 发布。 1.4 RTSP (Real-time Transport Streaming Protocol)RTSP（Real Time Streaming Protocol），RFC2326，实时流传输协议。RTSP 在体系结构上位于 RTP 和 RTCP 之上，它使用 TCP 或 UDP 完成数据传输。 RTSP 是一种基于文本的应用层协议，在语法及一些消息参数等方面与 HTTP 协议类似。 RTSP 被用于建立的控制媒体流的传输，它为多媒体服务扮演“网络远程控制”的角色。尽管有时可以把 RTSP 控制信息和媒体数据流交织在一起传送，但一般情况 RTSP 本身并不用于传送媒体流数据，媒体数据的传送可通过 RTP/RTCP 等协议来完成。 1.5 SDP (Session Description Protocol)会话描述协议（Session Description Protocol 或简写 SDP）描述的是流媒体的初始化参数。此协议由 IETF 发表为 RFC 2327。 SDP 完全是一种会话描述格式，它不属于传输协议。 SDP 用于描述多媒体通信会话，包括会话建立、会话请求和参数协商。SDP 不用于传输媒体数据，只能用于两个通信终端的参数协商，包括媒体类型、格式以及所有其他和会话相关的属性。SDP 以字符串的形式描述上述初始化参数。 可以参考 SDP格式解析 1.6 SIP (Session Initiation Protocol)SIP(Session Initiation Protocol)是一个应用层的信令控制协议。 SIP 用于初始化一个 Session，并负责传输 SDP 包；而 SDP 包中描述了一个 Session 中包含哪些媒体数据，邀请的人等等；当需要被邀请的人都通过各自的终端设备被通知到后，就可以使用 RTSP 来控制特定 Media 的通信，比如 RTSP 控制信息要求开始 Video 的播放，那么就开始使用 RTP（或者 TCP）实时传输数据，在传输过程中，RTCP 要负责 QoS 等。 1.7 RTMP (Real Time Messaging Protocol)RTMP(Real-Time Messaging Protocol 实时消息传送协议)的缩写，它是 Adobe Systems 公司为 Flash 播放器和服务器之间音频、视频和数据传输开发的一个基于TCP的应用层传输协议。这是一个标准的、未加密的实时消息传递协议，默认端口是 1935。 RTMP 是一种有状态协议。 RTMP 协议有效的保证了媒体传输质量，使用户可以观看到高质量的多媒体。RTMP 采用 TCP 协议作为其在传输层的协议，避免了多媒体数据在广域网传输过程中的丢包对质量造成的损失。此外 RTMP 协议传输的 FLV 封装格式支持的 H．264 视频编码方式可以在很低的码率下显示质量还不错的画面，非常适合网络带宽不足的情况下收看流媒体。 当然 RTMP 协议也有一些局限，RTMP 基于 TCP 协议，而 TCP 协议实时性不如 UDP，也非常占用带宽。目前基于 UDP 的 RTMFP 协议能很好的解决这些问题。 RTMPT 封装在 HTTP 请求之中，可穿越防火墙;RTMPS 类似 RTMPT，但使用的是 HTTPS 连接; 1.8 RTMFP (Real Time Media Flow Protocol)RTMFP 是 Adobe 公司开发的一套新的通信协议。 RTMFP 是基于 UDP 的，RTMP 是基于 TCP 的。UDP 在传送直播数据方面比 TCP 还是有较多优势的，比如减少延时，对丢包的容忍，虽然在可靠性上有所损失。与 RTMP 不同, RTMFP 支持 Flash Player 直接发送数据给另一个，而不经过 Server。 1.9 RSVP (Resource ReSerVation Protocol)使用 RSVP 预留一部分网络资源（即带宽），能在一定程度上为流媒体的传输提供 QoS。通常 RSVP 请求将会引起每个节点数据路径上的资源预留。 RSVP 只在单方向上进行资源请求，因此，尽管相同的应用程序，同时可能既担当发送者也担当接受者，但 RSVP 对发送者与接受者在逻辑上是有区别的。 RSVP 属于网络层协议。 RSVP 不传输应用数据，但支持因特网控制协议，如 ICMP、IGMP 或者路由选择协议。 1.10 MMS (Microsoft Media Server Protocol)MMS(Microsoft Media Server Protocol)，微软媒体服务器协议，用来访问接收 Windows Media 服务器中 .asf 文件的一种协议。MMS 协议用于访问 Windows Media 发布点上的单播内容。 MMS 的默认端口是 1755. 1.11 HLS (HTTP Live Streaming)HTTP Live Streaming（缩写是 HLS）是一个由苹果公司提出的基于HTTP的流媒体网络传输协议。它的工作原理是把整个流分成一个个小的基于 HTTP 的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的 extended M3U (m3u8)playlist 文件，用于寻找可用的媒体流。 HLS 只请求基本的 HTTP 报文，与实时传输协议（RTP)不同，HLS 可以穿过任何允许 HTTP 数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。 HLS 协议规定： 视频的封装格式是 TS。 视频的编码格式为 H264,音频编码格式为 MP3、AAC 或者 AC-3。 除了 TS 视频文件本身，还定义了用来控制播放的 m3u8 文件（文本文件）。 二、封装格式 名称 推出机构 流媒体支持 支持的视频编码 支持的音频编码 AVI Microsoft Inc. 否 几乎所有格式 几乎所有格式 MP4 MPEG 是 MPEG-2, MPEG-4, H.264, H.263 等 AAC, MPEG-1 Layers I, II, III, AC-3 等 TS MPEG 是 MPEG-1, MPEG-2, MPEG-4, H.264 MPEG-1 Layers I, II, III, AAC FLV Adobe Inc. 是 Sorenson, VP6, H.264 MP3, ADPCM, Linear PCM, AAC 等 MKV CoreCodec Inc. 是 几乎所有格式 几乎所有格式 RMVB Real Network Inc. 是 RealVideo 8, 9, 10 AAC, Cook Codec, RealAudio Lossless 三、视频编码格式 名称 推出机构 推出时间 HEVC(h.265) MPEG/ITU-T 2013 H.264 MPEG/ITU-T 2003 MPEG4 MPEG 2001 MPEG2 MPEG 1994 VP9 Google 2013 VP8 Google 2008 VC-1 Microsoft Inc. 2006 四、音频编码格式 名称 推出机构 推出时间 AAC MPEG 1997 AC-3 Dolby Inc. 1992 MP3 MPEG 1993 WMA Microsoft Inc. 1999 目前，直播服务普通采用RTMP作为流媒体协议，FLV作为封装格式，H.264作为视频编码格式，AAC作为音频编码格式化。点播服务普通采用HTTP作为流媒体协议，H.264作为视频编码格式，AAC作为音频编码格式，而封装格式有多种，如MP4，FLV，F4V等。","link":"/post/737279469.html"},{"title":"CentOS7更新国内阿里源","text":"依次执行如下命令： 1yum install -y wget 12345# 备份并下载阿里云的base和epel源mv -f /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backupwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repomv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backupwget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 123yum clean allyum makecacheyum -y update","link":"/post/1822204079.html"},{"title":"Redis常见异常及处理方案","text":"1. 缓存雪崩在短时间内本应交由 Redis 处理的大量请求，都发送到了数据库进行处理，从而导致对数据库的压力迅速增大，严重时数据库可能崩溃，从而导致整个系统崩溃，就像雪崩一样，引发连锁效应，所以叫缓存雪崩。 出现上述情况的常见原因主要有以下两点： 大量缓存数据同时过期，导致本应请求到缓存的需重新从数据库中获取数据。 redis 本身出现故障，无法处理请求，那自然会再请求到数据库那里。 针对大量缓存数据同时过期的情况： 实际设置过期时间时，应当尽量避免大量 key 同时过期的场景，如果真的有，那就通过随机、微调、均匀设置等方式设置过期时间，从而避免同一时间过期。 添加互斥锁，使得构建缓存的操作不会在同一时间进行。 双 key 策略，主 key 是原始缓存，备 key 为拷贝缓存，主 key 失效时，可以访问备 key，主 key 缓存失效时间设置为短期，备 key 设置为长期。 后台更新缓存策略，采用定时任务或者消息队列的方式进行 redis 缓存更新或移除等。 针对 Redis 本身出现故障的情况： 在预防层面，可以通过主从节点的方式构建高可用的集群，也就是实现主 Redis 实例挂掉后，能有其他从库快速切换为主库，继续提供服务。 如果事情已经发生了，那就要为了防止数据库被大量的请求搞崩溃，可以采用服务熔断或者请求限流的方法。当然服务熔断相对粗暴一些，停止服务直到 redis 服务恢复，请求限流相对温和一些，保证一些请求可以处理，不是一刀切，不过还是看具体业务情况选择合适的处理方案。 2. 缓存击穿缓存击穿一般出现在高并发系统中，是大量用户同时并发请求缓存中没有但数据库中有的数据，也就是同时读 Redis 缓存，但缓存中没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大。 和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。 出现这种情况一般因为某个热点数据缓存过期，由于是热点数据，请求并发量大，所以过期的时候还是会有大量请求同时过来，来不及更新缓存就全部打到数据库了。 针对这种情况有两种常见的处理方案： 简单粗暴的对热点数据不设置过期时间，这样不会过期，自然也就不会出现上述情况了，如果后续想清理，可以通过后台进行清理。 添加互斥锁，即当过期之后，除了请求过来的第一个查询的请求可以获取到锁请求到数据库，并再次更新到缓存中，其他的会被阻塞住，直到锁被释放，同时新的缓存也被更新上去了，后续请求又会请求到缓存上，这样就不会出现缓存击穿了。 3. 缓存穿透缓存穿透是指数据既不在 Redis 中，也不在数据库中，这样就导致每次请求过来的时候，在缓存中找不到对应 key 之后，每次都还要去数据库再查询一遍，发现数据库也没有，相当于进行了两次无用的查询。 这样请求就可以绕过缓存直接查数据库，如果这个时候有人想恶意攻击系统，就可以故意使用空值或者其他不存在的值进行频繁请求，那么就会对数据库造成比较大的压力。 针对缓存穿透，一般有以下三种处理方案： 非法请求的限制，主要是指参数校验、鉴权校验等，从而一开始就把大量的非法请求拦截在外，这在实际业务开发中是必要的手段。 缓存空值或者默认值，如果从缓存取不到的数据，在数据库中也没有取到，那我们仍然把这个空结果进行缓存，同时设置一个较短的过期时间。通过这个设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库，可以防止有大量恶意请求是反复用同一个 key 进行攻击。 使用布隆过滤器快速判断数据是否存在。 那什么是布隆过滤器呢，简单来说，就是可以引入了多个相互独立的哈希函数，保证在给定的空间和误判率下，完成元素判重。因为我们知道，存在 hash 碰撞这样一种情况，那如果只使用一个 hash 函数，则碰撞冲突的概率明显会变大，那为了减少这种冲突，我们可以多引入几个 hash 函数，而布隆过滤器算法的核心思想就是利用多个不同的 hash 函数来解决这样一种冲突。它的优点是空间效率高，查询时间短，远超其他算法，而它的缺点就是会存在一定的误识别率，它不能完全保证请求过来的 key 通过布隆过滤器的校验就一定有这个数据，毕竟理论上还是会存在冲突情况，无论概率多小。但是，只要没有通过布隆过滤器的校验，那么这个 key 就一定不存在，只要利用这一点其实就已经可以过滤掉大部分不存在的 key 的请求了，在正常场景下已然足够了。 4. 缓存预热缓存预热就是系统上线前后，将相关的缓存数据直接加载到缓存系统中去，而不依赖用户触发请求时才加入。这样就可以避免在用户请求的时候，先查询数据库再将数据缓存的问题。用户直接查询事先被预热的缓存数据，这样可以避免那么系统上线初期，对于高并发的流量，都会访问到数据库中，对数据库造成流量的压力。 根据数据不同量级，可以有以下几种做法： 数据量不大：项目启动的时候自动进行加载。 数据量较大：后台定时刷新缓存。 数据量极大：只针对热点数据进行预加载缓存操作。 5. 缓存降级当缓存失效或缓存服务出现故障时，我们为了防止数据库发生雪崩而不去访问数据库，但此时仍然想要保证服务的主体功能是基本可用的。因此对于不重要的缓存数据，我们可以采取服务降级策略。 一般做法有以下两种： 直接访问内存部分的数据缓存。 直接返回系统设置的默认值。","link":"/post/44844734.html"},{"title":"Redis慢日志与BigKey","text":"1. 慢日志设置1234# 当命令耗时超过5毫秒时，记录慢日志CONFIG SET slowlog-log-slower-than 5000# 只保留最近500条慢日志CONFIG SET slowlog-max-len 500 2. 查看慢日志123456789101112131415127.0.0.1:6379&gt; SLOWLOG get 51) 1) (integer) 32693 # 慢日志ID 2) (integer) 1593763337 # 执行时间戳 3) (integer) 5299 # 执行耗时(微秒) 4) 1) \"LRANGE\" # 具体执行的命令和参数 2) \"user_list:2000\" 3) \"0\" 4) \"-1\"2) 1) (integer) 32692 2) (integer) 1593763337 3) (integer) 5044 4) 1) \"GET\" 2) \"user_info:1000\"... 3. BigKey如果查询慢日志发现，并不是复杂度过高的命令导致的，而都是 SET / DEL 这种简单命令出现在慢日志中，此时需要考虑实例否写入了 BigKey。 BigKey 俗称“大 key”，Redis 是 key-value 的存储方式，当一个 Key 所对应的存储数值过长时，就会出现大 key 的情况。 Redis 在写入数据时，需要为新的数据分配内存，相对应的当从 Redis 中删除数据时，也会释放对应的内存空间。BigKey 会导致分配和释放内存的耗时都比较长。 可以使用下面命令扫描 Redis 中的 BigKey： 1234567891011121314151617181920$ redis-cli -h 127.0.0.1 -p 6379 --bigkeys -i 0.01...-------- summary -------Sampled 829675 keys in the keyspace!Total key length in bytes is 10059825 (avg len 12.13)Biggest string found 'key:291880' has 10 bytesBiggest list found 'mylist:004' has 40 itemsBiggest set found 'myset:2386' has 38 membersBiggest hash found 'myhash:3574' has 37 fieldsBiggest zset found 'myzset:2704' has 42 members36313 strings with 363130 bytes (04.38% of keys, avg size 10.00)787393 lists with 896540 items (94.90% of keys, avg size 1.14)1994 sets with 40052 members (00.24% of keys, avg size 20.09)1990 hashs with 39632 fields (00.24% of keys, avg size 19.92)1985 zsets with 39750 members (00.24% of keys, avg size 20.03) 对线上实例进行 bigkey 扫描时，Redis 的 OPS 会突增，为了降低扫描过程中对 Redis 的影响，需要控制扫描的频率，指定 -i 参数即可，它表示扫描过程中每次扫描后休息的时间间隔，单位是秒。","link":"/post/851648499.html"},{"title":"CentOS7申请免费LetsEncrypt证书并续期","text":"本文介绍在 CentOS7 环境下，使用 Certbot 申请免费的 Lets Encrypt SSL 证书，并自动续期。 1. 环境准备安装 Python3： 1yum install python3 安装 Certbot 和 Python 虚拟环境： 123456789# 假设certbot安装到/root/certbotmkdir -p /root/certbotcd /root/certbotpython3 -m venv venvsource venv/bin/activate# 升级pippip install --upgrade pip 阿里云注册并解析的域名，执行如下命令： 12# 安装certbotpip install certbot certbot-nginx certbot-dns-aliyun -i https://pypi.tuna.tsinghua.edu.cn/simple 2. 阿里云子账号创建阿里云子账号（https://ram.console.aliyun.com），并分配 AliyunDNSFullAccess 权限。 为子账号生成 access_key 和 access_secret。 创建/root/certbot/aliyun.ini文件，内容如下： 12dns_aliyun_access_key = XXXXXdns_aliyun_access_key_secret = XXXXX 使用如下命令修改该文件权限： 1chmod 600 /root/certbot/aliyun.ini 3. 申请证书以申请 mytools123.com 证书为例： 12345/root/certbot/venv/bin/certbot certonly \\-a dns-aliyun \\--dns-aliyun-credentials /root/certbot/aliyun.ini \\-d mytools123.com \\-d \"*.mytools123.com\" 执行成功后，生成的证书位于/etc/letsencrypt/live/mytools123.com目录 4. 手动续期Lets Encrypt 的证书有效期只有 3 个月，到期后需要手动续期。 12345# --dry-run 的是模拟更新证书/root/certbot/venv/bin/certbot renew -a dns-aliyun --dns-aliyun-credentials /root/certbot/aliyun.ini --dry-run# 正式更新证书/root/certbot/venv/bin/certbot renew -a dns-aliyun --dns-aliyun-credentials /root/certbot/aliyun.ini 5. 自动续期可以创建定时续期脚本，来实现自动续期。 创建脚本文件/root/renew_cert.sh，内容如下： 12# 更新证书/root/certbot/venv/bin/certbot renew -a dns-aliyun --dns-aliyun-credentials /root/certbot/aliyun.ini 为 sh 添加可执行权限： 1chmod +x /root/renew_cert.sh 新建定时任务： 1crontab -e 新增如下内容： 10 0,12 * * * python -c 'import random; import time; time.sleep(random.random() * 3600)' &amp;&amp; /root/renew_cert.sh","link":"/post/2025031576.html"},{"title":"一个Dockerfile同时运行多个进程","text":"Docker 容器的哲学是一个 Docker 容器只运行一个进程。 但如果需要在一个容器内运行多个进程或服务，可以采取将入口文件设置为 Bash Shell 脚本，在脚本内运行多个程序的方式。 1234567891011#!/bin/bash# start 1start1 &gt; /var/log/start1.log 2&gt;&amp;1 &amp;# start 2start2 &gt; /var/log/start2.log 2&gt;&amp;1 &amp;# just keep this script runningwhile [[ true ]]; do sleep 1done 在 Dockerfile 的入口中运行 run.sh： 1234FROM ubuntu:latest...COPY ./run.sh /ENTRYPOINT [\"run.sh\"]","link":"/post/2409581593.html"},{"title":"使用Watchtower自动更新Docker","text":"Watch­tower 官网: https://github.com/containrrr/watchtower Watch­tower 可以用于自动更新 Docker 镜像与容器。Watch­tower 会监视正在运行的容器以及相关的镜像，当检测到 Reg­istry 中的镜像与本地的镜像有差异时，会拉取最新镜像并使用最初部署时相同的参数重新启动相应的容器。 1. 安装运行Watch­tower 本身被打包为 Docker 镜像，因此可以像运行其他容器一样运行它： 1234567docker run -d \\ --name watchtower \\ --restart unless-stopped \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower \\ --cleanup \\ --interval 60 运行 Watch­tower 后，所有容器都会自动更新，也包括 Watch­tower 本身。 默认情况下 Watch­tower 每 5 分钟会轮询一次，可以使用--interval参数指定（单位秒）。 查看帮助文档： 1docker run --rm containrrr/watchtower -h 2. 手动更新前面的使用方式是让 Watch­tower 以 detached（后台）模式在运行并自动更新容器，而 Watch­tower 也支持以 foreground（前台）模式来使用，即运行一次退出并删掉容器，来实现手动更新容器。这对于偶尔更新一次那些不在自动更新列表中的容器非常有用。 对于 foreground 模式，需要加上 --run-once （--run-once 可以简写为 -R）这个专用的选项。下面的例子 Docker 会运行一次 Watch­tower 并检查 aria2-pro 容器的基础镜像更新，最后删掉本次运行创建的 Watch­tower 容器。 12345docker run --rm \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower --cleanup \\ --run-once \\ aria2-pro 3. 更新私有镜像如果是从私有 Docker 仓库获取镜像，则需提供身份验证凭据和环境变量 REPO_USER 和 REPO_PASS，或者通过将宿主机的 docker 配置文件挂载到容器的根目录下。 通过添加环境变量的方式： 123456docker run -d \\ --name watchtower \\ -e REPO_USER=username \\ -e REPO_PASS=password \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower container_to_watch --debug 通过挂载宿主机 docker 配置文件的方式： 12345docker run -d \\ --name watchtower \\ -v /home/&lt;user&gt;/.docker/config.json:/config.json \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower container_to_watch --debug","link":"/post/1404510687.html"}],"tags":[{"name":"Vcpkg","slug":"Vcpkg","link":"/tags/Vcpkg/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Thread","slug":"Thread","link":"/tags/Thread/"},{"name":"Lamada","slug":"Lamada","link":"/tags/Lamada/"},{"name":"QSS","slug":"QSS","link":"/tags/QSS/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"静默安装","slug":"静默安装","link":"/tags/%E9%9D%99%E9%BB%98%E5%AE%89%E8%A3%85/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"白酒","slug":"白酒","link":"/tags/%E7%99%BD%E9%85%92/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Joplin","slug":"Joplin","link":"/tags/Joplin/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"},{"name":"Ping","slug":"Ping","link":"/tags/Ping/"},{"name":"UDP","slug":"UDP","link":"/tags/UDP/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"史铁生","slug":"史铁生","link":"/tags/%E5%8F%B2%E9%93%81%E7%94%9F/"},{"name":"戴建业","slug":"戴建业","link":"/tags/%E6%88%B4%E5%BB%BA%E4%B8%9A/"},{"name":"GDB","slug":"GDB","link":"/tags/GDB/"},{"name":"Windbg","slug":"Windbg","link":"/tags/Windbg/"},{"name":"Crash","slug":"Crash","link":"/tags/Crash/"},{"name":"Deadlock","slug":"Deadlock","link":"/tags/Deadlock/"},{"name":"Wav","slug":"Wav","link":"/tags/Wav/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"LetsEncrypt","slug":"LetsEncrypt","link":"/tags/LetsEncrypt/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Watch­tower","slug":"Watch­tower","link":"/tags/Watch%C2%ADtower/"}],"categories":[{"name":"⑩ 编程基础","slug":"⑩-编程基础","link":"/categories/%E2%91%A9-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"CMake","slug":"⑩-编程基础/CMake","link":"/categories/%E2%91%A9-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/CMake/"},{"name":"② C++","slug":"②-C","link":"/categories/%E2%91%A1-C/"},{"name":"④ Electron","slug":"④-Electron","link":"/categories/%E2%91%A3-Electron/"},{"name":"⑤ 音视频编程","slug":"⑤-音视频编程","link":"/categories/%E2%91%A4-%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B/"},{"name":"③ Power By Me","slug":"③-Power-By-Me","link":"/categories/%E2%91%A2-Power-By-Me/"},{"name":"Qt","slug":"②-C/Qt","link":"/categories/%E2%91%A1-C/Qt/"},{"name":"WebRTC","slug":"⑤-音视频编程/WebRTC","link":"/categories/%E2%91%A4-%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B/WebRTC/"},{"name":"⑫ Web开发","slug":"⑫-Web开发","link":"/categories/%E2%91%AB-Web%E5%BC%80%E5%8F%91/"},{"name":"① 专栏集锦","slug":"①-专栏集锦","link":"/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/"},{"name":"⑪ 开源库","slug":"⑪-开源库","link":"/categories/%E2%91%AA-%E5%BC%80%E6%BA%90%E5%BA%93/"},{"name":"批处理","slug":"⑩-编程基础/批处理","link":"/categories/%E2%91%A9-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%89%B9%E5%A4%84%E7%90%86/"},{"name":"⑨ 数据库","slug":"⑨-数据库","link":"/categories/%E2%91%A8-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"⑭ 杂念","slug":"⑭-杂念","link":"/categories/%E2%91%AD-%E6%9D%82%E5%BF%B5/"},{"name":"⑮ 爱折腾","slug":"⑮-爱折腾","link":"/categories/%E2%91%AE-%E7%88%B1%E6%8A%98%E8%85%BE/"},{"name":"Windows注入与拦截","slug":"①-专栏集锦/Windows注入与拦截","link":"/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8B%A6%E6%88%AA/"},{"name":"网络协议","slug":"①-专栏集锦/网络协议","link":"/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"Windows核心编程","slug":"①-专栏集锦/Windows核心编程","link":"/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"},{"name":"⑬ 美文赏析","slug":"⑬-美文赏析","link":"/categories/%E2%91%AC-%E7%BE%8E%E6%96%87%E8%B5%8F%E6%9E%90/"},{"name":"⑧ 软件架构","slug":"⑧-软件架构","link":"/categories/%E2%91%A7-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"},{"name":"⑦ 软件调试","slug":"⑦-软件调试","link":"/categories/%E2%91%A6-%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95/"},{"name":"⑥ 服务器开发","slug":"⑥-服务器开发","link":"/categories/%E2%91%A5-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"name":"Windows套接字I&#x2F;O模型","slug":"①-专栏集锦/Windows套接字I-O模型","link":"/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E5%A5%97%E6%8E%A5%E5%AD%97I-O%E6%A8%A1%E5%9E%8B/"},{"name":"打包狂魔之NSIS教程","slug":"①-专栏集锦/打包狂魔之NSIS教程","link":"/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/%E6%89%93%E5%8C%85%E7%8B%82%E9%AD%94%E4%B9%8BNSIS%E6%95%99%E7%A8%8B/"},{"name":"拨开字符编码的迷雾","slug":"①-专栏集锦/拨开字符编码的迷雾","link":"/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/%E6%8B%A8%E5%BC%80%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%9A%84%E8%BF%B7%E9%9B%BE/"},{"name":"Windows内存体系","slug":"①-专栏集锦/Windows内存体系","link":"/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E5%86%85%E5%AD%98%E4%BD%93%E7%B3%BB/"}],"pages":[{"title":"","text":"","link":"/404.html"},{"title":"关于","text":"没有什么比时间更具有说服力了，因为时间无需通知我们就可以改变一切。从一开始的不甘平凡，到逐渐接受自己的平庸，我不得不承认自己不是一个聪明的人，只能努力做一个勤奋的人。 曾经我也以为老去是很遥远的事，突然发现年轻却是很久以前的事了，时光真的是好不经用呀，抬眼已在这行摸爬滚打十几载。软件行业的水深且广，自己不会的实在太多，要学的也太多，然而学的越多，却发现自己会的越少，终究还得沉下心来慢慢学习，以某一点为圆心逐步扩散，一步一步地对知识体系进行完善。 随着年龄的增长，属于自己的空闲时间是越来越少，时长问自己为什么要写这些了，写的大多也不是什么热门技术，基本没什么人看，这样有意义吗？ 首先，我不认为自己写的这些东西算得上文章，最多算个随笔和总结吧（虽然很多地方用了“本文”二字，但这只能算一种行文习惯）。 自己记忆力很差劲，比如通常记不住上周三中午吃的什么菜，希望通过这种形式来弥补自己记忆的缺失。 如果有一天我不再从事软件这一行，我想这一天总会来的，技术会逐渐生疏，知识也会慢慢被遗忘，打开这个网站，看着曾经记录的点滴，回忆着一个个知识，也是对自己青春的一种追思吧。 其次，记录这些的同时也可以促使自己进行思考和总结，以反向输出的形式逼自己对知识体系进行完善，把知识从点变成线，再由线变成面。 最后，我的所学大多来自于书本和网络，受馈于他人的分享，我也想发挥一丝分享的精神，若记录的这些东西能对他人产生帮助，对我而言也是一件开心的事情。","link":"/about/index.html"},{"title":"friends","text":"","link":"/friends/index.html"},{"title":"contact","text":"","link":"/contact/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"分类","text":"","link":"/categories/index.html"}]}