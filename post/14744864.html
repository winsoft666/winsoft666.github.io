<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Windows,Linux,C/C++,Golang,Qt,Node.js,Electron,Vue,WebRTC">
    <meta name="description" content="除注明转载以外，所有文章均为原创">
    <meta name="author" content="江雪桥">
    
    <title>
        
            Windows内核对象 |
        
        代码派
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/favicon.png">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"jiangxueqiao.com","root":"/","language":"zh-CN","path":"search.xml"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"代码派","author":"江雪桥","avatar":"/images/avatar.png","logo":"/images/logo.png","favicon":"/images/favicon.png"},"menu":{"Archives":"/archives","Categories":"/categories","About":"/about","Github":"https://github.com/winsoft666"},"first_screen":{"enable":false,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Keep writing and Keep loving.","hitokoto":false},"social_contact":{"enable":true,"links":{"github":"https://github.com/winsoft666","weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":true,"hide_header":true},"home":{"category":false,"tag":true,"announcement":null},"post":{"author_badge":{"enable":false,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":false,"min2read":false},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":false,"share":true,"reward":{"enable":false,"img_link":null,"text":null}},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":false,"site_uv":false,"site_pv":false,"page_pv":false}},"local_search":{"enable":true,"preload":false},"comment":{"enable":true,"use":"twikoo","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":"https://twikoo.jiangxueqiao.com","region":"zh-CN","version":"1.6.21"},"waline":{"server_url":null,"reaction":false,"version":2},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":true},"lazyload":{"enable":true},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":false},"footer":{"since":2017,"word_count":false,"icp":{"enable":true,"record_code":"鄂ICP备2020015399号-6","url":"https://beian.miit.gov.cn"},"site_deploy":{"enable":false,"provider":"github","url":null},"shields_style":{"enable":false,"custom":[{"link_url":null,"img_url":null}]}},"inject":{"enable":false,"css":[null,"/css/custom.css"],"js":[null]},"root":"","version":"4.0.7"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="CodeSilo" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container border-box">

    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.png">
                </a>
            
            <a class="site-name border-box" href="/">
               代码派
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    <li class="menu-item">
                        <a class=""
                           href="/"
                        >首页</a>
                    </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >归档</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >分类</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >关于</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               target="_blank" rel="noopener" href="https://github.com/winsoft666"
                            >GITHUB</a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            <li class="drawer-menu-item flex-center">
                <a class=""
                   href="/"
                >首页</a>
            </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives"
                    >归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories"
                    >分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about"
                    >关于</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       target="_blank" rel="noopener" href="https://github.com/winsoft666"
                    >GITHUB</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        Windows内核对象
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/avatar.png">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">江雪桥</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2021-07-03 20:00:35</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Wed Sep 27 2023 12:26:03 GMT+0800">2023-09-27 12:26:03</span>
            </span>
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/">① 专栏集锦</a></li>
                        
                    
                            <li class="category-item">&nbsp;<i class="icon fas fa-angle-right"></i>&nbsp;<a href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/">Windows核心编程</a></li>
                        
                    
                </ul>
            </span>
        

        

        
        
        
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body">
                    

                    <h2 id="一、什么是内核对象"><a href="#一、什么是内核对象" class="headerlink" title="一、什么是内核对象"></a>一、什么是内核对象</h2><p>我们在 windows 开发中经常会遇到内核对象，如事件(Event)，管道(Pipe)，互斥量(Mutex)，完成端口(IOCP)，进程(Process)，线程(Thread)等，他们都是内核对象。这些内核对象虽然通过不同的系统 API 来创建，但这些 API 都有一个共同特点，就是都需要传入<code>SECURITY_ATTRIBUTES</code>安全描述符结构体指针，并且返回句柄(HANDLE)。依据这个特点，我们有一个简单方法来判断对象是否是内核对象，就是看创建它的函数是否允许传入<code>SECURITY_ATTRIBUTES</code>安全描述符。</p>
<span id="more"></span>

<h2 id="二、内核对象的创建"><a href="#二、内核对象的创建" class="headerlink" title="二、内核对象的创建"></a>二、内核对象的创建</h2><p>大多数创建内核对象的系统 API 函数，如 CreateEvent, CreateMutex, CreateThread, CreateProcess, CreatePipe, CreateNamedPipe 等都会返回一个 HANDLE（无论是以返回值的形式，还是以指针参数的形式返回），创建内核对象成功时 HANDLE 为<code>非NULL</code>，我们可以通过将 HANDLE 的值与 NULL 进行比较，来判断函数是否执行成功。但是有些函数比较例外，如<code>CreateFile</code>，这些函数执行失败时，返回的<code>HANDLE</code>的值为<code>INVALID_HANDLE_VALUIE</code>。</p>
<p>相关文章：<a href="/post/3906615635.html" title="由HANDLE返回值不确定性引发的思考">由HANDLE返回值不确定性引发的思考</a></p>
<h2 id="三、内核对象的访问"><a href="#三、内核对象的访问" class="headerlink" title="三、内核对象的访问"></a>三、内核对象的访问</h2><p><strong>虽然内核对象属于系统内核，但创建函数返回的<code>HANDLE</code>句柄却只和当前进程有关，离开了当前进程这个句柄也就失去了意义。</strong><br>内核对象属于系统内核级别，为了系统安全性，Windows 不允许我们直接访问内核对象的内存区域，只允许我们通过 Windows 提供的一系列 API 来访问内核对象，如<code>SetEvent</code>, <code>ResetEvent</code>等等，使用这些函数时我们都会用到<code>HANDLE</code>，windows 头文件中<code>HANDLE</code>的定义如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *HANDLE;</span><br></pre></td></tr></tbody></table></figure>

<p>虽然定义为<code>void*</code>类型，但很显然这个<code>HANDLE</code>不是指向内核对象的指针。</p>
<blockquote>
<p>如何证明 HANDLE 不是指向内核对象的指针？<br>一方面直接执行内核对象毫无安全性可言；<br>另一方面内核对象保存在内核地址空间（32 位系统是<code>0x80000000 到 0xFFFFFFFF</code>，64 位系统是<code>0x00000040 00000000到0xFFFFFFFF FFFFFFFF</code>），我们可以调用类似<code>CreateEvent</code>的函数创建一个内核对象，观察其返回的 HANDLE，明显不在内核地址空间的范围内，且值一般比较小。</p>
</blockquote>
<p>那么这个<code>HANDLE句柄</code>是如何与内核对象关联起来的了？答案是：<strong>进程的句柄表。</strong><br>每个进程在初始化的时候，系统都会为它分配一个句柄表(Windows 没有提供官方的文档来介绍句柄表)，参考《Windows 核心编程》得知句柄表的结构，如图：</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>指向内核对象内存块的指针</th>
<th>访问掩码</th>
<th>标志</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0x????????</td>
<td>0x????????</td>
<td>0x????????</td>
</tr>
<tr>
<td>2</td>
<td>0x????????</td>
<td>0x????????</td>
<td>0x????????</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>如我们调用类似<code>CreateEvent</code>的函数返回的句柄<code>HANDLE</code>就是句柄表中的<code>索引</code>。因为是<code>索引</code>，所以它的值一般比较小。我们向 windows API 函数传入这个<code>索引</code>，API 再通过<code>索引</code>找到对应的<code>内核对象指针</code>。</p>
<h2 id="四、内核对象的销毁"><a href="#四、内核对象的销毁" class="headerlink" title="四、内核对象的销毁"></a>四、内核对象的销毁</h2><h3 id="4-1-引用计数"><a href="#4-1-引用计数" class="headerlink" title="4.1 引用计数"></a>4.1 引用计数</h3><p><strong>内核对象的所有者是操作系统内核，而不是创建它的进程。</strong></p>
<p>多个进程可以引用（使用）同一个内核对象，操作系统使用了计数器的方式来管理内核对象（这个和 C++中的<code>std::shared_ptr</code>智能指针类似），一个内核对象其实有两个计数器：一个是给用户态(Ring3)用的句柄计数；另一个是指针计数，也叫引用计数，因为核心态程序(Ring0)也经常用到内核对象，为了使用方便，在核心态的代码用指针直接访问对象，所以内核对象的管理器也维护了这个指针引用计数。只有在内核对象的<code>句柄计数</code>和<code>引用计数</code>都为 0 时，该内核对象才被释放。一般而言，指针引用计数值比句柄计数值大。</p>
<h3 id="4-2-正确的销毁方式"><a href="#4-2-正确的销毁方式" class="headerlink" title="4.2 正确的销毁方式"></a>4.2 正确的销毁方式</h3><p>当程序不再使用内核对象时，需要调用<code>CloseHandle</code>将内核对象的计数减 1，这样系统内核在该对象计数为 0 时（也就是没有被任何东西引用时）将销毁该对象。 <strong>并且在调用<code>CloseHandle</code>之后，程序还应该将<code>HANDLE</code>置为<code>NULL</code>。</strong></p>
<p>如果<code>CloseHandle</code>之后不将<code>HANDLE</code>置为<code>NULL</code>，反而再次使用该<code>HANDLE</code>，就会出现 2 种情况：</p>
<ol>
<li><p>进程句柄表中该<code>HANDLE</code>所在的索引项的记录已经被清除，且没有别的线程再次在该索引创建记录项，若此时使用这个过期的<code>HANDLE</code>调用 Win32 API 函数，Windows 会返回无效参数错误。这种情况还比较好调试。</p>
</li>
<li><p>进程句柄表中该<code>HANDLE</code>所在的索引项的记录同样也已经被清除，但已经有别的线程（该进程中的其他线程）在该<code>索引</code>位置创建了记录项，若此时使用这个过期的<code>HANDLE</code>调用 Win32 API 函数，该<code>HANDLE</code>就会引用到其他线程新建的那个内核对象，从而出现一些难以预料的错误。这种错误很难调试。</p>
</li>
</ol>
<h3 id="4-3-获取内核对象的引用计数"><a href="#4-3-获取内核对象的引用计数" class="headerlink" title="4.3 获取内核对象的引用计数"></a>4.3 获取内核对象的引用计数</h3><p>虽然 windows 没有提供 API 让用户在用户态（Ring3）查询一个内核对象的句柄计数和引用计数，但我们可以从<code>Ntdll.dll</code>导出<code>NtQueryObject</code>函数来实现查询内核对象的当前状态(该函数没有被文档化)。</p>
<p><code>NtQueryObject</code>函数声明如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值：如果成功则返回0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">NtQueryObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE   handle,       <span class="comment">// 待查询的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">DWORD   nQueryIndex,   <span class="comment">// 0为查询对象的当前状态，包括句柄计数，引用计数等等。</span></span></span></span><br><span class="line"><span class="params"><span class="function">VOID*   pOutBuffer,    <span class="comment">// 存放查询结果</span></span></span></span><br><span class="line"><span class="params"><span class="function">DWORD   cbInBufferSize,   <span class="comment">// pOutBuffer的大小，如果nQueryIndex为0，这里为sizeof(SYSTEM_HANDLE_STATE)</span></span></span></span><br><span class="line"><span class="params"><span class="function">VOID*   cbOutBufferSize   <span class="comment">// 实际大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>将<code>NtQueryObject</code>函数调用的细节封装到<code>GetKernelObjectRefCount</code>函数中，方便使用：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetKernelObjectRefCount</span><span class="params">(HANDLE handle, DWORD &amp;handle_count, DWORD &amp;point_count)</span> </span>{</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_HANDLE_STATE</span> {</span><br><span class="line">    DWORD   r1;</span><br><span class="line">    DWORD   GrantedAccess;</span><br><span class="line">    DWORD   HandleCount;      <span class="comment">// 减1为句柄计数</span></span><br><span class="line">    DWORD   ReferenceCount;   <span class="comment">// 减1为指针引用计数</span></span><br><span class="line">    DWORD   r5;</span><br><span class="line">    DWORD   r6;</span><br><span class="line">    DWORD   r7;</span><br><span class="line">    DWORD   r8;</span><br><span class="line">    DWORD   r9;</span><br><span class="line">    DWORD   r10;</span><br><span class="line">    DWORD   r11;</span><br><span class="line">    DWORD   r12;</span><br><span class="line">    DWORD   r13;</span><br><span class="line">    DWORD   r14;</span><br><span class="line">  }SYSTEM_HANDLE_STATE, *PSYSTEM_HANDLE_STATE;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI *PFN_NtQueryObject)</span><span class="params">(HANDLE handle,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD nQueryIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">    VOID* pOutBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD cbInBufferSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    VOID* cbOutBufferSize)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> PFN_NtQueryObject pfnNtQueryObject = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> {</span><br><span class="line">    <span class="keyword">if</span> (pfnNtQueryObject == <span class="literal">NULL</span>) {</span><br><span class="line">      HMODULE ntdll = <span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">"Ntdll.dll"</span>));</span><br><span class="line">      <span class="keyword">if</span> (ntdll == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      pfnNtQueryObject = (PFN_NtQueryObject)<span class="built_in">GetProcAddress</span>(ntdll, <span class="string">"NtQueryObject"</span>);</span><br><span class="line">      <span class="keyword">if</span> (pfnNtQueryObject == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    SYSTEM_HANDLE_STATE sys_handle_state;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sys_handle_state, <span class="number">0</span>, <span class="built_in">sizeof</span>(SYSTEM_HANDLE_STATE));</span><br><span class="line"></span><br><span class="line">    DWORD out_buf_size = <span class="number">0</span>;</span><br><span class="line">    ret = (<span class="built_in">pfnNtQueryObject</span>(handle, <span class="number">0</span>, &amp;sys_handle_state, <span class="built_in">sizeof</span>(SYSTEM_HANDLE_STATE), &amp;out_buf_size) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) {</span><br><span class="line">      handle_count = sys_handle_state.HandleCount - <span class="number">1</span>;</span><br><span class="line">      point_count = sys_handle_state.ReferenceCount - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="五、内核对象跨进程访问"><a href="#五、内核对象跨进程访问" class="headerlink" title="五、内核对象跨进程访问"></a>五、内核对象跨进程访问</h2><p>虽然内核对象位于独立于进程之外的内核区域，我们在开发中却只能通过调用 Win32 API 传入 HANDLE 参数来操作内核对象（如<code>SetEvent</code>等）。然而<code>HANDLE句柄</code>只对当前进程有效，离开了当前进程该句柄就无效了。所以说，跨进程访问内核对象的关键在于我们怎么跨进程访问<code>句柄HANDLE</code>？</p>
<p>下面介绍几种方法来实现跨进程共享内核对象。</p>
<h3 id="5-1-使用句柄继承的方式"><a href="#5-1-使用句柄继承的方式" class="headerlink" title="5.1 使用句柄继承的方式"></a>5.1 使用句柄继承的方式</h3><p>只有进程之间有父子关系时，才可以使用句柄继承的方式。在这种情况下，父进程可以生成一个子进程，并允许子进程访问父进程的内核对象。为了使这种继承生效，父进程必须执行几个步骤：<br>（1）. 父进程在创建一个内核对象时，父进程必须向系统指定它希望这个内核对象的句柄是可以继承的。为了创建一个可继承的内核对象，必须分配并初始化一个<code>SECURITY_ATTRIBUTES</code>结构，如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SECURITY_ATTRIBUTES sa;</span><br><span class="line">sa.nLength = <span class="built_in">sizeof</span>(SECURITY_ATTRIBUTES);</span><br><span class="line">sa.bInheritHandle = TRUE;  <span class="comment">// 可继承的</span></span><br><span class="line">sa.lpSecurityDescriptor = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">HANDLE h = <span class="built_in">CreateEvent</span>(&amp;sa, TRUE, FALSE, <span class="literal">NULL</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>（2）. 父进程通过 CreateProcess 生成子进程，且指定<code>bInheritHandles</code>为 TRUE，从而允许子进程来继承父进程的那些“可继承的句柄”。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动子进程TestB.exe，将句柄h作为启动参数传给进程TestB</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">TCHAR cmd_buf[MAX_PATH];</span><br><span class="line"><span class="built_in">StringCchPrintf</span>(cmd_buf, MAX_PATH, <span class="built_in">TEXT</span>(<span class="string">"TestB.exe %ld"</span>), (<span class="type">long</span>)h);</span><br><span class="line"></span><br><span class="line">STARTUPINFO si = { <span class="built_in">sizeof</span>(si) };</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line">BOOL ret = <span class="built_in">CreateProcess</span>(</span><br><span class="line">  <span class="literal">NULL</span>,</span><br><span class="line">  cmd_buf,</span><br><span class="line">  <span class="literal">NULL</span>,</span><br><span class="line">  <span class="literal">NULL</span>,</span><br><span class="line">  TRUE,  <span class="comment">// 指定子进程可以继承父进程的“可继承句柄”</span></span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="literal">NULL</span>,</span><br><span class="line">  <span class="literal">NULL</span>,</span><br><span class="line">  &amp;si,</span><br><span class="line">  &amp;pi</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line"><span class="built_in">CloseHandle</span>(pi.hThread);</span><br></pre></td></tr></tbody></table></figure>

<p>由于我们传给<code>bInheritHandles</code>参数的值是<code>TRUE</code>，所以系统在创建子进程时会多做一件事情：它会遍历父进程的句柄表，对它的每一项进行检查，凡是包含一个有效的“可继承的句柄”的项，都会将该项完整的复制到子进程的句柄表。在子进程的句柄表中，复制项的位置与它在父进程句柄表中的位置完全一样（包含索引），这个就意味着：在父进程和子进程中，对一个内核对象进行标识的句柄值也是完全一样的。所以我们只需要通过某种方式（如上面示例中的启动参数的方式，或者环境变量的方式等任何进程间通讯的方式）将这个值告诉子进程，子进程就可以将该值转成<code>HANDLE</code>，然后使用这个<code>HANDLE</code>来调用系统 API。</p>
<h3 id="5-2-使用-DuplicateHandle-方式"><a href="#5-2-使用-DuplicateHandle-方式" class="headerlink" title="5.2 使用 DuplicateHandle 方式"></a>5.2 使用 DuplicateHandle 方式</h3><p>DuplicateHandle 函数可以将指定“源进程的句柄表”中的某一项<strong>复制</strong>到“目的进程句柄表”中（除了索引），并且返回该项在目的进程句柄表中的索引（即 HADNLE）。<br>可以在任何时候调用 DuplicateHandle 函数，DuplicateHandle 对源句柄是否是可继承的没有要求。</p>
<p>函数声明如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DuplicateHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hSourceProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hSourceHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hTargetProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPHANDLE lpTargetHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bInheritHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwOptions</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>DuplicateHandle 详细介绍可以参考 MSDN：<a class="link" target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724251(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms724251(v=vs.85).aspx<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>DuplicateHandle 函数不能复制所有类型的句柄，只能复制如下类型的句柄（从 MSDN 复制而来）：</p>
<table>
<thead>
<tr>
<th>Object</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Access token</td>
<td>The handle is returned by the CreateRestrictedToken, DuplicateToken, DuplicateTokenEx, OpenProcessToken, or OpenThreadToken function.</td>
</tr>
<tr>
<td>Change notification</td>
<td>The handle is returned by the FindFirstChangeNotification function.</td>
</tr>
<tr>
<td>Communications device</td>
<td>The handle is returned by the CreateFile function.</td>
</tr>
<tr>
<td>Console input</td>
<td>The handle is returned by the CreateFile function when CONIN$ is specified, or by the GetStdHandle function when STD_INPUT_HANDLE is specified. Console handles can be duplicated for use only in the same process.</td>
</tr>
<tr>
<td>Console screen buffer</td>
<td>The handle is returned by the CreateFile function when CONOUT$ is specified, or by the GetStdHandle function when STD_OUTPUT_HANDLE is specified. Console handles can be duplicated for use only in the same process.</td>
</tr>
<tr>
<td>Desktop</td>
<td>The handle is returned by the GetThreadDesktop function.</td>
</tr>
<tr>
<td>Event</td>
<td>The handle is returned by the CreateEvent or OpenEvent function.</td>
</tr>
<tr>
<td>File</td>
<td>The handle is returned by the CreateFile function.</td>
</tr>
<tr>
<td>File mapping</td>
<td>The handle is returned by the CreateFileMapping function.</td>
</tr>
<tr>
<td>Job</td>
<td>The handle is returned by the CreateJobObject function.</td>
</tr>
<tr>
<td>Mailslot</td>
<td>The handle is returned by the CreateMailslot function.</td>
</tr>
<tr>
<td>Mutex</td>
<td>The handle is returned by the CreateMutex or OpenMutex function.</td>
</tr>
<tr>
<td>Pipe</td>
<td>A named pipe handle is returned by the CreateNamedPipe or CreateFile function. An anonymous pipe handle is returned by the CreatePipe function.</td>
</tr>
<tr>
<td>Process</td>
<td>The handle is returned by the CreateProcess, GetCurrentProcess, or OpenProcess function.</td>
</tr>
<tr>
<td>Registry key</td>
<td>The handle is returned by the RegCreateKey, RegCreateKeyEx, RegOpenKey, or RegOpenKeyEx function. Note that registry key handles returned by the RegConnectRegistry function cannot be used in a call to DuplicateHandle.</td>
</tr>
<tr>
<td>Semaphore</td>
<td>The handle is returned by the CreateSemaphore or OpenSemaphore function.</td>
</tr>
<tr>
<td>Thread</td>
<td>The handle is returned by the CreateProcess, CreateThread, CreateRemoteThread, or GetCurrentThread function</td>
</tr>
<tr>
<td>Timer</td>
<td>The handle is returned by the CreateWaitableTimer or OpenWaitableTimer function.</td>
</tr>
<tr>
<td>Transaction</td>
<td>The handle is returned by the CreateTransaction function.</td>
</tr>
<tr>
<td>Window station</td>
<td>The handle is returned by the GetProcessWindowStation function.</td>
</tr>
</tbody></table>
<p>不同的事件类型对应的<code>dwDesiredAccess</code>参数不同，具体参考<a class="link" target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724251(v=vs.85).aspx">MSDN<i class="fas fa-external-link-alt"></i></a>。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>进程 TestA 源码</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>{</span><br><span class="line">  HANDLE h = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, TRUE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动子进程TestB.exe</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  TCHAR cmd_buf[MAX_PATH];</span><br><span class="line">  <span class="built_in">StringCchPrintf</span>(cmd_buf, MAX_PATH, <span class="built_in">TEXT</span>(<span class="string">"D:\\TestB.exe"</span>), (<span class="type">long</span>)h);</span><br><span class="line"></span><br><span class="line">  STARTUPINFO si = { <span class="built_in">sizeof</span>(si) };</span><br><span class="line">  PROCESS_INFORMATION pi;</span><br><span class="line">  BOOL ret = <span class="built_in">CreateProcess</span>(<span class="literal">NULL</span>, cmd_buf, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line">  <span class="built_in">assert</span>(ret);</span><br><span class="line">  <span class="built_in">assert</span>(pi.hProcess);</span><br><span class="line"></span><br><span class="line">  HANDLE duplicated_h = <span class="literal">NULL</span>;</span><br><span class="line">  ret = <span class="built_in">DuplicateHandle</span>(<span class="built_in">GetCurrentProcess</span>(), h, pi.hProcess, &amp;duplicated_h, <span class="number">0</span>, FALSE, DUPLICATE_SAME_ACCESS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">WaitForSingleObject</span>(pi.hProcess, INFINITE);</span><br><span class="line">  <span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">  <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> has_signal = <span class="built_in">WaitForSingleObject</span>(h, <span class="number">0</span>) == WAIT_OBJECT_0;</span><br><span class="line">  <span class="built_in">assert</span>(has_signal == <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>子进程 TestB 源码</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">long</span> l = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Input Handle:"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;l);</span><br><span class="line"></span><br><span class="line">  HANDLE h = (HANDLE)l;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> has_signal = <span class="built_in">WaitForSingleObject</span>(h, <span class="number">0</span>) == WAIT_OBJECT_0;</span><br><span class="line">  <span class="built_in">assert</span>(has_signal == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SetEvent</span>(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在父进程 TestA 中创建一个不可继承的事件 -&gt; 然后启动子进程 TestB -&gt; 调用 DuplicateHandle 复制句柄项到 TestB 进程句柄表 -&gt; 并向 TestB 输入句柄值 -&gt; TestB 访问该事件句柄，将事件置为有信号状态。</p>
<h3 id="5-3-使用命名的内核对象的方式"><a href="#5-3-使用命名的内核对象的方式" class="headerlink" title="5.3 使用命名的内核对象的方式"></a>5.3 使用命名的内核对象的方式</h3><h4 id="5-3-1-实现原理"><a href="#5-3-1-实现原理" class="headerlink" title="5.3.1 实现原理"></a>5.3.1 实现原理</h4><p>这种方式严格的说已经不是文章开头说到的跨进程访问句柄了，有点类似跨进程直接访问内核对象了。<br>该方式实现起来比较简单，就是在调用创建内核对象的<code>Create***</code>函数时，通过<code>pszName</code>参数为内核对象取一个名字。<br>如创建事件 Event 的函数<code>CreateEvent</code>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpEventAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bManualReset,</span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bInitialState,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpName  <span class="comment">// 指定名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE h = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, TRUE, FALSE, <span class="built_in">TEXT</span>(<span class="string">"TestA_Obj"</span>));</span><br></pre></td></tr></tbody></table></figure>

<p>若在其他进程中要访问这个内核对象，只需要使用打开函数<code>Open***</code>打开该内核对象，<strong>系统就会在进程的句柄表中插入一条记录，并返回这条记录的索引，也就是句柄</strong>。需要注意的是，在打开内核对象时需要留意<code>返回值</code>和<code>GetLastError</code>函数的返回值。由于内核对象是有访问权限的，有时候虽然这个名字的内核对象存在，但该进程却不见得有权限可以打开它，这个时候<code>GetLastError</code>函数会返回失败的原因。</p>
<p>以打开事件的函数<code>OpenEvent</code>为例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE h = <span class="built_in">OpenEvent</span>(READ_CONTROL, FALSE, <span class="built_in">TEXT</span>(<span class="string">"TestA_Obj"</span>));</span><br><span class="line"><span class="keyword">if</span> (h == <span class="literal">NULL</span>) {</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == ERROR_ACCESS_DENIED) { <span class="comment">// 没有READ_CONTROL权限</span></span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-3-2-全局命令空间"><a href="#5-3-2-全局命令空间" class="headerlink" title="5.3.2 全局命令空间"></a>5.3.2 全局命令空间</h4><p>不同的会话（Session）有不同的内核对象命名空间（如 windows 服务程序位于<code>Session 0</code>，而普通的用户进程位于<code>Session 1</code>），要通过名称访问其他会话中的内核对象，需要在名称前面加上<code>Session\&lt;当前会话ID&gt;</code>。Windows 提供了一个全局的内核对象命名空间，处于任何会话中的进程都可以访问该命名空间，将内核对象放入全局命令空间的方式很简单：只需要在内核对象名称前加入<code>Global\</code>即可。</p>
<p>如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE h = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, TRUE, FALSE, <span class="built_in">TEXT</span>(<span class="string">"Global\\TestA_Obj"</span>));</span><br></pre></td></tr></tbody></table></figure>

                </div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                    </div>
                    <div>
                        
                            <div class="post-share-container border-box">
    <ul class="share-list-wrap border-box">
        <li class="qq share-item border-box flex-center tooltip"
            data-tooltip-content="分享到 QQ"
        >
            <i class="fa-brands fa-qq"></i>
        </li>
        <li class="wechat share-item border-box flex-center tooltip tooltip-img"
            data-tooltip-content="分享到微信"
            data-tooltip-img-tip="微信扫一扫"
            data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;"
        >
            <i class="fa-brands fa-weixin"></i>
        </li>
        <li class="weibo share-item border-box flex-center tooltip"
            data-tooltip-content="分享到微博"
        >
            <i class="fa-brands fa-weibo"></i>
        </li>
    </ul>
</div>

                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/post/128186902.html"
                                   title="C++的API设计规范"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">C++的API设计规范</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/post/4155207961.html"
                                   title="C++实现编译时断言"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">C++实现编译时断言</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    


    <div class="comments-container border-box">
        <div id="comments-anchor" class="comment-area-title border-box">
            <i class="fas fa-comments"></i>&nbsp;评论
        </div>
        <div class="comment-plugin-fail border-box">
    <span class="fail-tip">评论插件加载失败</span>
    <button class="reload keep-button">点击重新加载</button>
</div>
<div class="comment-plugin-loading flex-center border-box">
    <i class="loading-icon fa-solid fa-spinner fa-spin"></i>
    <span class="load-tip">正在加载评论插件</span>
</div>
<script data-pjax>
  window.KeepCommentPlugin = {}
  window.KeepCommentPlugin.hideLoading = () => {
    const cplDom = document.querySelector('.comments-container .comment-plugin-loading')
    cplDom.style.display = 'none'
  }
  window.KeepCommentPlugin.loadFailHandle = () => {
    window.KeepCommentPlugin.hideLoading()
    const cpfDom = document.querySelector('.comments-container .comment-plugin-fail')
    cpfDom.style.display = 'flex'
    cpfDom.querySelector('.reload').addEventListener('click', () => {
      window.location.reload()
    })
  }
</script>

        
            

    <div class="twikoo-container">
        <div id="twikoo-comment"></div>
        <script 
                src="//cdn.jsdelivr.net/npm/twikoo@1.6.21/dist/twikoo.all.min.js"
                async
                onerror="window.KeepCommentPlugin.loadFailHandle()"
        ></script>
        <script 
                async
                onerror="window.KeepCommentPlugin.loadFailHandle()"
        >
          window.KeepCommentPlugin.initTwikoo = () => {
            if (window?.twikoo) {
              twikoo.init({
                el: '#twikoo-comment',
                envId: 'https://twikoo.jiangxueqiao.com',
                region: 'zh-CN',
                lang: 'zh-CN' || 'zh-CN'
              })
              window.KeepCommentPlugin.hideLoading()
            } else {
              setTimeout(() => {
                window.KeepCommentPlugin.initTwikoo()
              }, 1000)
            }
          }

          if ('false' === 'true') {
            setTimeout(() => {
              window.KeepCommentPlugin.initTwikoo()
            }, 1200)
          } else {
            window.addEventListener('DOMContentLoaded', window.KeepCommentPlugin.initTwikoo)
          }
        </script>
    </div>


        
    </div>





                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="nav-text">一、什么是内核对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">二、内核对象的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-text">三、内核对象的访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81"><span class="nav-text">四、内核对象的销毁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-text">4.1 引用计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%94%80%E6%AF%81%E6%96%B9%E5%BC%8F"><span class="nav-text">4.2 正确的销毁方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E8%8E%B7%E5%8F%96%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-text">4.3 获取内核对象的引用计数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%AE%BF%E9%97%AE"><span class="nav-text">五、内核对象跨进程访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">5.1 使用句柄继承的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E4%BD%BF%E7%94%A8-DuplicateHandle-%E6%96%B9%E5%BC%8F"><span class="nav-text">5.2 使用 DuplicateHandle 方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E4%BD%BF%E7%94%A8%E5%91%BD%E5%90%8D%E7%9A%84%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">5.3 使用命名的内核对象的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">5.3.1 实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-%E5%85%A8%E5%B1%80%E5%91%BD%E4%BB%A4%E7%A9%BA%E9%97%B4"><span class="nav-text">5.3.2 全局命令空间</span></a></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;<span>2017</span>&nbsp;-&nbsp;2024
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">江雪桥</a>
                
            </div>

            
                <div class="icp-info info-item default">
                    <a class=""
                       target="_blank"
                       href="https://beian.miit.gov.cn"
                    >
                        鄂ICP备2020015399号-6
                    </a>
                </div>
            

            
        

        <div class="count-item info-item default">
            

            

            
        </div>
    </div>
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-toggle-theme-mode flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        
            <li class="tools-item go-to-comments-tablet flex-center">
                <i class="fas fa-comment"></i>
            </li>
        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="nav-text">一、什么是内核对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">二、内核对象的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-text">三、内核对象的访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81"><span class="nav-text">四、内核对象的销毁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-text">4.1 引用计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%94%80%E6%AF%81%E6%96%B9%E5%BC%8F"><span class="nav-text">4.2 正确的销毁方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E8%8E%B7%E5%8F%96%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-text">4.3 获取内核对象的引用计数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%AE%BF%E9%97%AE"><span class="nav-text">五、内核对象跨进程访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">5.1 使用句柄继承的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E4%BD%BF%E7%94%A8-DuplicateHandle-%E6%96%B9%E5%BC%8F"><span class="nav-text">5.2 使用 DuplicateHandle 方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E4%BD%BF%E7%94%A8%E5%91%BD%E5%90%8D%E7%9A%84%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">5.3 使用命名的内核对象的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">5.3.1 实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-%E5%85%A8%E5%B1%80%E5%91%BD%E4%BB%A4%E7%A9%BA%E9%97%B4"><span class="nav-text">5.3.2 全局命令空间</span></a></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>



<!-- common -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local-search -->

    
<script src="/js/local-search.js"></script>



<!-- lazyload -->

    
<script src="/js/lazyload.js"></script>



<div class="">
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        
            
<script src="/js/post/toc.js"></script>

        

        <!-- copyright-info -->
        

        <!-- share -->
        
            
<script src="/js/post/share.js"></script>

        
    

    <!-- category-page -->
    

    <!-- links-page -->
    

    <!-- photos-page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->



</body>
</html>
