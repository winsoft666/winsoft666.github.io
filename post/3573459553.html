<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#177cb0"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.png" color="#177cb0">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"jiangxueqiao.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.26.0","exturl":false,"sidebar":{"position":"right","width_expanded":260,"width_dual_column":260,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"vs2015"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":true,"height":300},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":false,"async":true,"duration":200,"transition":{"menu_item":null,"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":null}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="在数字时代的攻防战场上，Windows 注入与 Hook 技术如影随形，它们始终是开发者与安全研究员的“终极兵器库”。无论是逆向工程师通过动态调试破解加密算法，还是恶意软件通过进程注入窃取敏感信息，这项技术始终游走在合法与非法的灰色边缘。它既是系统底层机制的“潘多拉魔盒”，也是守护软件安全的“达摩克利斯之剑”——掌握它，你既能修复高危漏洞，也可能成为攻击者的帮凶。">
<meta property="og:type" content="article">
<meta property="og:title" content="代码的隐形战场：Windows进程注入与API Hook完全指南">
<meta property="og:url" content="https://jiangxueqiao.com/post/3573459553.html">
<meta property="og:site_name" content="独钓寒江雪">
<meta property="og:description" content="在数字时代的攻防战场上，Windows 注入与 Hook 技术如影随形，它们始终是开发者与安全研究员的“终极兵器库”。无论是逆向工程师通过动态调试破解加密算法，还是恶意软件通过进程注入窃取敏感信息，这项技术始终游走在合法与非法的灰色边缘。它既是系统底层机制的“潘多拉魔盒”，也是守护软件安全的“达摩克利斯之剑”——掌握它，你既能修复高危漏洞，也可能成为攻击者的帮凶。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiangxueqiao.com/images/blog/minhook-yuanli.png">
<meta property="og:image" content="https://jiangxueqiao.com/images/blog/pe.jpg">
<meta property="og:image" content="https://jiangxueqiao.com/images/blog/mVZKxlt7bk.png">
<meta property="og:image" content="https://jiangxueqiao.com/images/blog/IMAGE_EXPORT_DIRECTORY.jpg">
<meta property="article:published_time" content="2025-11-23T13:11:02.000Z">
<meta property="article:modified_time" content="2026-01-12T16:33:41.057Z">
<meta property="article:author" content="jiangxueqiao.com">
<meta property="article:tag" content="Hook">
<meta property="article:tag" content="注入">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiangxueqiao.com/images/blog/minhook-yuanli.png">


<link rel="canonical" href="https://jiangxueqiao.com/post/3573459553.html">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jiangxueqiao.com/post/3573459553.html","path":"post/3573459553.html","title":"代码的隐形战场：Windows进程注入与API Hook完全指南"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>代码的隐形战场：Windows进程注入与API Hook完全指南 | 独钓寒江雪</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js" defer></script>
  <script async src="https://hm.baidu.com/hm.js?fbb46283a7b4d42d425356f8779708d5"></script>







  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>




  <script src="/js/third-party/fancybox.js" defer></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">独钓寒江雪</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">用C++的优雅，驯服Windows的狂野</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5"><span class="nav-number">1.</span> <span class="nav-text">注册表方式注入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DLL-%E6%AC%BA%E9%AA%97%E6%B3%A8%E5%85%A5"><span class="nav-number">2.</span> <span class="nav-text">DLL 欺骗注入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5"><span class="nav-number">3.</span> <span class="nav-text">消息钩子注入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5"><span class="nav-number">4.</span> <span class="nav-text">远程线程注入</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86"><span class="nav-number">4.1.</span> <span class="nav-text">注入原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-DLL-%E5%8F%A5%E6%9F%84"><span class="nav-number">4.2.</span> <span class="nav-text">获取 DLL 句柄</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%96%E6%B6%88%E6%B3%A8%E5%85%A5"><span class="nav-number">4.3.</span> <span class="nav-text">取消注入</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ShellCode-%E7%89%88%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5"><span class="nav-number">5.</span> <span class="nav-text">ShellCode 版远程线程注入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EIP-RIP-%E5%8A%AB%E6%8C%81%E6%B3%A8%E5%85%A5"><span class="nav-number">6.</span> <span class="nav-text">EIP&#x2F;RIP 劫持注入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F%E7%9A%84%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="nav-number">7.</span> <span class="nav-text">基于文件映射方式的内存访问</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F-APC-%E6%B3%A8%E5%85%A5"><span class="nav-number">8.</span> <span class="nav-text">用户模式 APC 注入</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#QueueUserAPC"><span class="nav-number">8.1.</span> <span class="nav-text">QueueUserAPC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Early-Bird"><span class="nav-number">8.2.</span> <span class="nav-text">Early Bird</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Inline-Hook"><span class="nav-number">9.</span> <span class="nav-text">Inline Hook</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IAT-Hook"><span class="nav-number">10.</span> <span class="nav-text">IAT Hook</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EAT-Hook"><span class="nav-number">11.</span> <span class="nav-text">EAT Hook</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9-Hook"><span class="nav-number">12.</span> <span class="nav-text">硬件断点 Hook</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E8%BF%87%E6%97%B6%E7%9A%84%E5%86%85%E6%A0%B8-Hook-%E6%8A%80%E6%9C%AF"><span class="nav-number">13.</span> <span class="nav-text">一些过时的内核 Hook 技术</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#VT-Hook"><span class="nav-number">14.</span> <span class="nav-text">VT Hook</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jiangxueqiao.com</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">150</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/winsoft666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;winsoft666" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:smart7178@163.com" title="E-Mail → mailto:smart7178@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://jiangxueqiao.com/online-tools" title="https:&#x2F;&#x2F;jiangxueqiao.com&#x2F;online-tools">在线工具</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiangxueqiao.com/post/3573459553.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiangxueqiao.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独钓寒江雪">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="代码的隐形战场：Windows进程注入与API Hook完全指南 | 独钓寒江雪">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          代码的隐形战场：Windows进程注入与API Hook完全指南
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-11-23 21:11:02" itemprop="dateCreated datePublished" datetime="2025-11-23T21:11:02+08:00">2025-11-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-01-13 00:33:41" itemprop="dateModified" datetime="2026-01-13T00:33:41+08:00">2026-01-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E2%91%A4Windows%E5%BC%80%E5%8F%91%E4%B8%8E%E8%B0%83%E8%AF%95%E7%A7%98%E7%B1%8D/" itemprop="url" rel="index"><span itemprop="name">⑤Windows开发与调试秘籍</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>在数字时代的攻防战场上，Windows 注入与 Hook 技术如影随形，它们始终是开发者与安全研究员的“终极兵器库”。无论是逆向工程师通过动态调试破解加密算法，还是恶意软件通过进程注入窃取敏感信息，这项技术始终游走在合法与非法的灰色边缘。它既是系统底层机制的“潘多拉魔盒”，也是守护软件安全的“达摩克利斯之剑”——掌握它，你既能修复高危漏洞，也可能成为攻击者的帮凶。</p>
<span id="more"></span>

<h1 id="注册表方式注入"><a href="#注册表方式注入" class="headerlink" title="注册表方式注入"></a>注册表方式注入</h1><p>这是一种最简单的注入方式，我们只需要开发正常的 DLL，然后在注册表<code>AppInit_DLLs</code>项中指定该 DLL 的名称，待系统<code>User32.dll</code>被加载到新进程时，该 DLL 也会被加载到目标进程。这是因为 User32.dll 会在 DLL_PROCESS_ATTACH 通知处理过程中读取该注册表值，并依次加载该项中的每个 DLL。</p>
<p>AppInit_DLLs 注册表项的路径如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs</span><br></pre></td></tr></table></figure>

<p>如果是在 x64 系统上，将 32 位 DLL 注入到 32 位进程，需要使用<code>Wow6432Node</code>路径（下面的 LoadAppInit_DLLs 也是一样）：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs</span><br></pre></td></tr></table></figure>

<p>AppInit_DLLs 中的文件名通过逗号或空格来分割，因此在文件名中要避免使用空格。另外 AppInit_DLLs 中只有第一个文件可以包含路径，后面的文件的路径则将被忽略，出于这个原因，我们最好将 DLL 文件拷贝到 Windows 的系统目录中。</p>
<p>一切准备妥当后，还需将 LoadAppInit_DLLs 注册表项的值修改为 1，路径如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs</span><br></pre></td></tr></table></figure>

<p>这种注入方式虽然简单，但存在很大的弊端，因为 DLL 是通过 User32.dll 加载到目标进程中去的，这也就要求被注入的目标进程必须使用了 User32.dll，虽然基于 GUI 的程序都会使用这个 DLL 文件，但命令行程序一般不会加载 User32.dll，所以可能无法通过这种方式被注入。而且这种方式会导致系统上所有使用了 User32.dll 的程序都会被注入 DLL，很多时候这也并不是我们所期望的。</p>
<h1 id="DLL-欺骗注入"><a href="#DLL-欺骗注入" class="headerlink" title="DLL 欺骗注入"></a>DLL 欺骗注入</h1><p>我们在启动一个可执行程序时，操作系统会先为进程创建虚拟地址空间，然后把可执行模块映射到进程的地址空间中，之后会遍历导入段（即 PE 的导入表），定位所依赖的 DLL 并映射到该进程的地址空间中。由于导入段中只包含了 DLL 的名称，不包含 DLL 的路径，因此加载程序会按照如下顺序在磁盘上查找 DLL（优先级从高到低）：</p>
<ul>
<li>包含可执行文件的目录。</li>
<li>Windows 系统目录，通常为 C:\Windows\System32，可以使用 GetSystemDirectory 函数获取。</li>
<li>Windows 目录，通常为 C:\Windows，可以使用 GetWindowsDirectory 函数获取。</li>
<li>进程的当前工作目录。</li>
<li>PATH 环境变量中所列出的目录。</li>
</ul>
<blockquote>
<p>上面是程序启动时，操作系统查找程序依赖 DLL 的标准流程。在使用 LoadLibrary 加载 DLL 时，如果没有指定全路径，而是仅仅指定了文件名或相对路径，LoadLibrary 也会使用上面顺序进行搜索。但如果使用 SetDllDirectroy 函数设置了 DLL 搜索目录，或者使用 LoadLibraryEx 函数并设置了 LOAD_WITH_ALTERED_SEARCH_PATH 标志，此时程序搜索 DLL 的方式会与上面的标准搜索顺序所有不同，详见《Windows 核心编程》。</p>
</blockquote>
<p>DLL 欺骗注入也叫 DLL 劫持，就是在上面 DLL 的搜索路径中放入我们自己 DLL，来欺骗系统或应用进行加载。</p>
<p>使用 Depends 工具查看程序依赖的 DLL，选择一个 DLL 来伪造。</p>
<p>需要注意，<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</code>注册表中指定的 DLL 不能伪造。</p>
<p>伪造 DLL 需要与原 DLL 的导出函数完全一致，并提供相同的功能，否则程序会加载失败或功能异常，因此我们在选择 DLL 时，尽量选择功能简单的 DLL，如 version.dll、hid.dll 等。</p>
<p>编写伪造 DLL 的流程通常如下：</p>
<ul>
<li>在 DllMain 函数中加载原 DLL。</li>
<li>通常在 DllMain 函数中还会执行相关逻辑，如 Hook 某个函数等（非必须）。</li>
<li>使用函数转发器技术将导出函数的功能转发到跳板函数，并在跳板函数中调用原 DLL 中对应函数的功能，确保伪造 DLL 能够提供与原 DLL 一致的功能。</li>
</ul>
<p>上述操作是一件繁琐的、费时费力的事情，好在已有前辈开发了工具来根据原 DLL 自动生成相应的 VS 工程，下面是我修改后的版本，支持 x86 和 x64 架构：<br><a target="_blank" rel="noopener" href="https://github.com/winsoft666/AheadLib">https://github.com/winsoft666/AheadLib</a></p>
<h1 id="消息钩子注入"><a href="#消息钩子注入" class="headerlink" title="消息钩子注入"></a>消息钩子注入</h1><p>Windows 提供了 SetWindowsHookEx 函数来为指定线程安装一个消息钩子。当指定线程中的特定消息被钩住时，系统就会将我们的 DLL（前提是钩子的处理过程是位于 DLL 中的）加载到该线程所属进程的地址空间中，并且在该地址空间中调用我们的 DLL 中的钩子处理过程函数，从而实现 DLL 注入功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HHOOK <span class="title">SetWindowsHookExA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] <span class="type">int</span>       idHook,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HOOKPROC  lpfn,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HINSTANCE hmod,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD     dwThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>操作系统同时允许开发人员为“同一个线程”的“同一个消息类型”指定多个钩子，这样就形成了一个“钩子链”（Hook Chain），当我们的钩子处理函数（由 lpfn 参数指定）将消息处理完之后，可以选择将消息丢弃，不让钩子链后面的钩子进行处理，也可以在钩子处理函数的最后调用 CallNextHookEx 函数，让消息继续传递下去，从而让其他钩子有处理的机会。</p>
<p>SetWindowsHookEx 函数返回了<code>HHOOK</code>类型的钩子句柄，而且 CallNextHookEx 和 UnhookWindowsHookEx 函数都需要使用这个句柄作为参数。因此，如果我们将“注入逻辑”放在独立的 exe 中，将“钩子处理过程”放到独立的 dll 中，那么我们需要通过其他途径将该句柄从 exe 传递到 dll 中，确保在“钩子处理过程”中能够使用该句柄调用 CallNextHookEx。</p>
<p>为了避免传递钩子句柄的麻烦，我们通常将注入、取消注入、钩子处理过程都写在一个 DLL 中。在 DLL 中导出开始和停止函数，外部程序调用这两个函数就可以实现注入和取消注入的功能了。</p>
<h1 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h1><h2 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h2><p>远程线程注入方式使用的关键系统 API 为 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread">CreateRemoteThread</a>，原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  HANDLE                 hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPSECURITY_ATTRIBUTES  lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  SIZE_T                 dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPVOID                 lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  DWORD                  dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_ LPDWORD                lpThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>CreateRemoteThread 相比 CreateThread 只是新增了 hProcess 句柄参数，该参数用于指定远程线程所在的目标进程。</p>
<p>可以通过任意方式获取目标进程的句柄，但需要确保该句柄具有合适的访问权限，避免后续的函数调用失败，通常应具有如下权限，具体见 API 文档：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ</span><br></pre></td></tr></table></figure>

<p>通过远程线程方式实现 DLL 注入主要是在<code>lpStartAddress</code>和<code>lpParameter</code>这 2 个参数上面做文章。</p>
<p>lpStartAddress 参数用于指定远程线程的处理过程函数，函数原型分别如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数原型与加载 DLL 所使用的 API（Kernel32::LoadLibraryA 或 Kernel32::LoadLibraryW）的原型基本相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMODULE WINAPI <span class="title">LoadLibrary</span><span class="params">(LPCTSTR lpFileName)</span></span>;</span><br></pre></td></tr></table></figure>

<p>虽然不是完全相同，但都是接收一个指针参数，返回一个值（<strong>在不同架构的软件中，返回值所占字节数有区别，见下面注解</strong>），并且调用约定也都是<code>WINAPI</code>。因此，我们可以利用它们之间的相似性，把线程处理函数的地址设为 LoadLibraryA 或 LoadLibraryW 的函数地址。</p>
<blockquote>
<p>在 32 位程序中，DWORD 和 HMODULE 都占 4 字节，而在 64 位程序中，DWORD 占 4 字节，HMODULE 占 8 字节。因此下面介绍的获取 DLL 句柄的方式只适用于 32 位程序。</p>
</blockquote>
<p>目标进程的 LoadLibrary 的地址是多少呢？</p>
<p>通常来说，无论是否开启 ASLR（地址空间布局随机化），DLL 加载到目标进程的基地址都不会是固定的，因此模块中函数的地址也不是固定的。那么我们如何确定目标进程中的 Kernel32::LoadLibraryA 的地址呢？幸运的是，kernel32.dll、user32.dll、 ntdll.dll 等系统 DLL 在不同的进程中的基地址都是一样的，因此我们可以直接使用当前进程中的 LoadLibraryA 函数地址。</p>
<blockquote>
<p>下列系统 DLL 在所有进程中的基地址都是一样的：<br>kernel32.dll、user32.dll、ntdll.dll、gdi32.dll、gdi32full.dll、comdlg32.dll、shell32.dll、advapi32.dll、msvcrt.dll​、ucrtbase.dll、ole32.dll、oleaut32.dll、rpcrt4.dll、ws2_32.dll、shcore.dll、imm32.dll、crypt32.dll</p>
</blockquote>
<p>但不能直接使用下面的方式来传递 LoadLibraryA 或 LoadLibraryW 的地址，因为直接使用 LoadLibraryA 会被解析为我们程序导入段中的 LoadLibraryA 转换函数的地址，这个转换函数的地址只在当前进程有效。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateRemoteThread</span>(hTargeProcess, <span class="literal">NULL</span>, <span class="number">0</span>, LoadLibraryA, ...);</span><br></pre></td></tr></table></figure>

<p>所以我们要通过 GetProAdress 方式获取 LoadLibraryA 地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPVOID pLoadLibraryAddr = (LPVOID)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;kernel32.dll&quot;</span>)), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="built_in">CreateRemoteThread</span>(hTargeProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pLoadLibraryAddr, ...);</span><br></pre></td></tr></table></figure>

<p>解决了 LoadLibraryA 函数地址的问题，再来解决 DLL 路径的问题。DLL 路径字符串（如”C:\InjectDll.dll”）的内存地址位于调用进程的地址空间中，并不位于被注入的目标进程的地址空间中。所以，在目标进程中使用 LoadLibraryA 访问该地址时，会出现访问违规。</p>
<p>为了解决这个问题，我们需要把 DLL 路径字符串存储到被注入进程的地址空间中。通过 Windows 提供的 VirtualAllocEx 和 WriteProcessMemory 函数，可以实现在目标进程地址空间中分配内存和写入内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SIZE_T size = <span class="built_in">strlen</span>(pszDllPath) + <span class="number">1</span>;</span><br><span class="line">LPVOID buffer = <span class="built_in">VirtualAllocEx</span>(hTargeProcess, <span class="literal">NULL</span>, size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (buffer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hTargeProcess, buffer, pszDllPath, size, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，调用 CreateRemoteThread 创建远程线程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LPVOID pLoadLibraryAddr = (LPVOID)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;kernel32.dll&quot;</span>)), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">HANDLE hDll = <span class="built_in">CreateRemoteThread</span>(hTargeProcess,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	pLoadLibraryAddr,</span><br><span class="line">	buffer,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>当 CreateRemoteThread 所创建的线程在远程进程地址空间中被创建的时候，就会立即调用 LoadLibraryA 函数，并使用 DLL 路径作为其参数，从而实现 DLL 的加载。</p>
<h2 id="获取-DLL-句柄"><a href="#获取-DLL-句柄" class="headerlink" title="获取 DLL 句柄"></a>获取 DLL 句柄</h2><p>正常情况下，CreateRemoteThread 返回了线程句柄，待线程结束后通过 GetExitCodeThread 函数获取的线程退出码，线程退出码是线程处理过程函数的返回值，在使用上面方式进行远程线程注入时，GetExitCodeThread 函数获取的退出码则实际是 LoadLibraryA 函数的返回值，也就是线程的句柄。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">GetExitCodeThread</span>(hRemoteThread, (LPDWORD)&amp;hDll);</span><br></pre></td></tr></table></figure>

<p>正如上面一节注解中所介绍的那样，这种获取注入 DLL 句柄的方式仅适用与 32 位程序，因为 64 位程序的句柄占 8 字节，使用 4 字节的 DWORD 类型存储，可能会导致数据截断。但如果不需要获取 DLL 句柄或者注入后再通过遍历进程模块的方式获取 DLL 句柄，则这种注入方式也同时适用于 32&#x2F;64 位程序。</p>
<h2 id="取消注入"><a href="#取消注入" class="headerlink" title="取消注入"></a>取消注入</h2><p>取消注入就是将 DLL 从目标进程卸载，卸载 DLL 所用的 API 是<code>FreeLibrary</code>，但我们不能直接调用这个函数，因为直接调用的话是在我们的进程中卸载 DLL，而不是目标进程中卸载，很显然这样达不到卸载的目的。我们需要和加载 DLL 时一样，将<code>FreeLibrary</code>的地址作为第 4 个参数传给 CreateRemoteThread 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateRemoteThread</span>(hTargeProcess, <span class="literal">NULL</span>, <span class="number">0</span>, FreeLibrary, hDll, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h1 id="ShellCode-版远程线程注入"><a href="#ShellCode-版远程线程注入" class="headerlink" title="ShellCode 版远程线程注入"></a>ShellCode 版远程线程注入</h1><p>ShellCode 版远程线程注入是上一节普通远程线程注入的升级版，不仅可以弥补 64 位远程线程注入无法获取 DLL 句柄的遗憾（普通远程线程注入的遗憾在于 4 字节的 DWORD 不足以存储 64 位的句柄），而且对于后面介绍的 RIP&#x2F;EIP 劫持注入也有一定的铺垫作用。</p>
<p>本节介绍的 ShellCode 使用的都是 64 位寄存器，主要针对 64 位程序，32 位程序还需要做相应的修改。</p>
<p>ShellCode 版远程线程注入的步骤大致如下：</p>
<ol>
<li>获取目标进程句柄（与普通版一样）。</li>
<li>在目标进程分配内存（记作 M1），并写入 DLL 路径（与普通版一样）。</li>
<li>在目标进程中分配 8 字节内存区域（记作 M2），用于存储返回的 DLL 句柄。</li>
<li>构造 ShellCode，该 ShellCode 用于在目标进程中调用 LoadLibrary，并将结果存储到步骤 3 分配的 M2 内存。</li>
<li>在目标进程分配内存（记作 M3），并写入步骤 4 构造的 ShellCode，M3 需要有 PAGE_EXECUTE_READWRITE 保护属性。</li>
<li>将 ShellCode 所在内存 M3 的地址作为 lpStartAddress 参数传递给 CreateRemoteThread 函数，而不再是 LoadLibrary 的地址。</li>
<li>等待线程结束后，从 M2 读取 DLL 句柄的值。</li>
</ol>
<p>ShellCode 看起来很神秘，其实并不高深，它就是一段汇编代码所对应的机器码而已。我们使用简单的汇编指令即可完成汇编代码的编写工作，如 mov、add、sub、lea、call、ret 等，然后将汇编指令转成机器码。</p>
<p>如何将汇编指令转机器码？</p>
<p>网上有很多工具可以使用，如 <a target="_blank" rel="noopener" href="https://github.com/suifei/asm2hex">ASM to Hex Convert</a>、<a target="_blank" rel="noopener" href="https://shell-storm.org/online/Online-Assembler-and-Disassembler/">Online-Assembler-and-Disassembler</a>，也可以借助 x64dbg，在其中修改汇编代码（快捷键 Space），就会自动生成对应的机器码。</p>
<p>下面来讲讲如何使用汇编代码来构造一个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// CreateRemoteThread在调用下面函数时，会将 pDllPathAddress 会作为参数存入到 rcx</span><br><span class="line"></span><br><span class="line">sub rsp, 0x28                     // 在栈上分配0x28字节的区域</span><br><span class="line">mov [rsp+0x8], rcx                // 将当前的rcx值保存到栈，方便调用结束后恢复rcx的值</span><br><span class="line">mov [rsp+0x10], rax               // 将当前的rax值保存到栈，方便调用结束后恢复rax的值</span><br><span class="line">mov rax, LoadLibraryAddress       // 将LoadLibrary函数地址存储到rax</span><br><span class="line">call rax                          // 调用LoadLibrary函数，rcx是其第一个参数，因为前面一直没有修改rcx，所以其中存放的就是DLL路径地址</span><br><span class="line">mov rcx, SaveResultAddress        // 将SaveResultAddress地址（也就是之前分配的M2内存）存储到rcx</span><br><span class="line">mov [rcx], rax                    // 将LoadLibrary函数的返回值rax存储到SaveResultAddress地址</span><br><span class="line">mov rax, [rsp+0x10]               // 恢复rax的值</span><br><span class="line">mov rcx, [rsp+0x8]                // 恢复rcx的值</span><br><span class="line">add rsp, 0x28                     // 释放栈空间</span><br><span class="line">ret                               // 函数返回，虽然是WINAPI调用约定，按理需要函数自身来平衡堆栈，</span><br><span class="line">                                  // 但64位程序第一个参数使用rcx传递，因此不需要在此额外将栈指针增加 0x8 字节平衡堆栈</span><br></pre></td></tr></table></figure>

<p>由于 ShellCode 中的地址都是一次性的，在每次注入时都会改变，所以上面代码中使用的硬编码绝对地址不会出现地址失效的问题。</p>
<p>又因为在上述汇编代码中没有使用堆栈获取局部变量、函数参数，所以也就没有使用和暂存 rbp 寄存器，而在 32 位程序中需要使用 ebp 寄存器来获取参数。</p>
<p>此外，在汇编程序中，没有直接的 <code>call 0x12345678</code> 立即数绝对地址形式，call 指令后的立即数会被认为是相对 RIP&#x2F;EIP 的偏移量。如果需要调用绝对地址需要通过间接方式，如上面汇编代码中的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; ❌ 错误</span><br><span class="line">call LoadLibraryAddress</span><br><span class="line"></span><br><span class="line">; ✅ 正确</span><br><span class="line">mov rax, LoadLibraryAddress</span><br><span class="line">call rax</span><br></pre></td></tr></table></figure>

<p>而且汇编程序也不支持使用立即数作为内存操作数，需要通过寄存器中转方式，如上面汇编代码中的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; ❌ 错误</span><br><span class="line">mov [SaveResultAddress], rax</span><br><span class="line"></span><br><span class="line">; ✅ 正确</span><br><span class="line">mov rcx, SaveResultAddress</span><br><span class="line">mov [rcx], rax</span><br></pre></td></tr></table></figure>

<p>上述汇编代码转成的字节码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BYTE shellCode[] = &#123;</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xEC</span>, <span class="number">0x28</span>,                                     <span class="comment">// sub rsp, 0x28</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x4C</span>, <span class="number">0x24</span>, <span class="number">0x08</span>,                               <span class="comment">// mov [rsp+0x8], rcx</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x10</span>,                               <span class="comment">// mov [rsp+0x10], rax</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// mov rax, LoadLibraryAddress</span></span><br><span class="line">    <span class="number">0xFF</span>, <span class="number">0xD0</span>,                                                 <span class="comment">// call rax</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xB9</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// mov rcx, SaveResultAddress</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x01</span>,                                           <span class="comment">// mov [rcx], rax</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x10</span>,                               <span class="comment">// mov rax, [rsp+0x10]</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x4C</span>, <span class="number">0x24</span>, <span class="number">0x10</span>,                               <span class="comment">// mov rcx, [rsp+0x8]</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xC4</span>, <span class="number">0x28</span>,                                     <span class="comment">// add rsp, 0x28;</span></span><br><span class="line">    <span class="number">0xC3</span>                                                        <span class="comment">// ret</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中第 5、7 两行中的 0x00 是占位符，需要替换为实际的内存地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(DWORD64*)(&amp;shellCode[<span class="number">16</span>]) = (DWORD64)pLoadLibraryAddr;</span><br><span class="line">*(DWORD64*)(&amp;shellCode[<span class="number">28</span>]) = (DWORD64)pSaveResultAddress;</span><br></pre></td></tr></table></figure>

<p>最后通过 CreateRemoteThread 调用该 ShellCode 函数，并传入 DLL 路径地址作为参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hRemoteThread = <span class="built_in">CreateRemoteThread</span>(hTargeProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pShellCodeAddress, pDllPathAddress, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hRemoteThread)</span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hRemoteThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取DLL句柄</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ReadProcessMemory</span>(hTargeProcess, pSaveResultAddress, &amp;hDll, <span class="built_in">sizeof</span>(HMODULE), <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="EIP-RIP-劫持注入"><a href="#EIP-RIP-劫持注入" class="headerlink" title="EIP&#x2F;RIP 劫持注入"></a>EIP&#x2F;RIP 劫持注入</h1><p>EIP&#x2F;RIP 劫持与上面介绍的 ShellCode 版远程线程注入有异曲同工之处，但最大的区别在于 EIP&#x2F;RIP 劫持注入不用调用 CreateRemoteThread 函数，而是直接修改线程的 EIP&#x2F;RIP。</p>
<p>由于已在上面 ShellCode 版远程线程注入中做了相关知识的铺垫，所以本节不会介绍的那么详细。</p>
<p>下面以 64 位程序为例，介绍 RIP 劫持注入的大致步骤：</p>
<ol>
<li>获取目标进程的句柄。</li>
<li>在目标进程分配内存（记作 M1），并写入 DLL 路径。</li>
<li>在目标进程分配 8 字节的内存（记作 M2），用于存储返回的 DLL 句柄。</li>
<li>遍历目标进程的线程，调用 SuspendThread 函数挂起一个目标线程。</li>
<li>调用 GetThreadContext 函数获取挂起线程的 RIP，用于 ShellCode 执行完后跳转到该位置继续执行，不影响目标进程的原有逻辑。</li>
<li>构造 ShellCode，该 ShellCode 用于在目标进程中调用 LoadLibrary，并将结果存储到步骤 3 分配的 M2 内存，然后跳转之前的 RIP。</li>
<li>在目标进程分配内存（记作 M3），并写入步骤 6 构造的 ShellCode，M3 需要有 PAGE_EXECUTE_READWRITE 保护属性。</li>
<li>调用 SetThreadContext 函数修改 RIP 的值为 ShellCode 地址。</li>
<li>调用 ResumeThread 函数恢复线程。</li>
<li>等待短暂地时间后，从 M2 读取 DLL 句柄的值。</li>
</ol>
<p>ShellCode 对应的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sub rsp, 0x28</span><br><span class="line">mov [rsp+0x8], rcx</span><br><span class="line">mov [rsp+0x10], rax</span><br><span class="line">mov rcx, DllPathAddress      // 将DLL路径地址存储到rcx，作为 LoadLibrary 的参数</span><br><span class="line">mov rax, LoadLibraryAddress</span><br><span class="line">call rax                     // 调用 LoadLibrary</span><br><span class="line">mov rcx, SaveResultAddress</span><br><span class="line">mov [rcx], rax               // 将LoadLibrary 返回值存储到 SaveResultAddress</span><br><span class="line">mov rax, [rsp+0x10]</span><br><span class="line">mov rcx, [rsp+0x8]</span><br><span class="line">add rsp, 0x28</span><br><span class="line">mov r11, OriginalRip</span><br><span class="line">jmp rll                      // 跳转到之前的RIP</span><br></pre></td></tr></table></figure>

<p>由于是直接修改 RIP 进行的执行流程跳转，因而会缺少正常函数调用时的 RIP 入栈、参数传递等过程，所以需要手动将 DllPathAddress 赋值给 rcx，并且在代码最后不能调用 ret。</p>
<p>对于 jmp 指令，不能使用<code>jmp OriginalRip</code>这样的方式来实现跳转到绝对地址，需要使用一个寄存器来做间接跳转。</p>
<p>上述汇编代码转成的字节码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BYTE shellCode[] = &#123;</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xEC</span>, <span class="number">0x28</span>,                                     <span class="comment">// sub rsp, 0x28</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x4C</span>, <span class="number">0x24</span>, <span class="number">0x08</span>,                               <span class="comment">// mov [rsp+0x8], rcx</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x10</span>,                               <span class="comment">// mov [rsp+0x10], rax</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xB9</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// mov rcx, DllPathAddress</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// mov rax, LoadLibraryAddress</span></span><br><span class="line">    <span class="number">0xFF</span>, <span class="number">0xD0</span>,                                                 <span class="comment">// call rax</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xB9</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// mov rcx, SaveResultAddress</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x01</span>,                                           <span class="comment">// mov [rcx], rax</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x10</span>,                               <span class="comment">// mov rax, [rsp+0x10]</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x4C</span>, <span class="number">0x24</span>, <span class="number">0x10</span>,                               <span class="comment">// mov rcx, [rsp+0x8]</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xC4</span>, <span class="number">0x28</span>,                                     <span class="comment">// add rsp, 0x28</span></span><br><span class="line">    <span class="number">0x49</span>, <span class="number">0xBB</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// mov r11, OriginalRip</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0xFF</span>, <span class="number">0xE3</span>                                            <span class="comment">// jmp rll</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用 ResumeThread 函数恢复线程后，线程就会执行 ShellCode。由于没有创建新的线程，所以不能像远程线程注入那样等待线程结束后再读取 DLL 句柄，可以等待一个合适的时间后就尝试读取 DLL 句柄。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sleep</span>(<span class="number">200</span>);</span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(hTargeProcess, pSaveResultAddress, &amp;hDll, <span class="built_in">sizeof</span>(HMODULE), <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>获取到 DLL 句柄后，可以再次注入 ShellCode 来调用 FreeLibrary 来释放 DLL。</p>
<h1 id="基于文件映射方式的内存访问"><a href="#基于文件映射方式的内存访问" class="headerlink" title="基于文件映射方式的内存访问"></a>基于文件映射方式的内存访问</h1><p>在前面的远程线程注入和 EIP&#x2F;RIP 注入章节，都使用了 VirtualAllocEx、WriteProcessMemory、ReadProcessMemory 等函数在远程进程中分配内存、读写内存，由于这些函数被广泛使用，已经作为高危函数被 AV&#x2F;EDR 软件所监控。本节并不是介绍一种新的注入方法，而是介绍一种不使用上述函数，通过使用文件映射方式来读写远程内存的方法。</p>
<blockquote>
<p>这种方式目前肯定无法 100% 躲避 AV&#x2F;EDR，毕竟攻防之路永不止境。</p>
</blockquote>
<p>使用文件映射访问目标进程内存及注入的大致步骤如下：</p>
<ol>
<li>调用 CreateFileMapping 函数创建一个文件映射对象，并指定足够的大小，使其可以存储 DLL 路径。如果使用 EIP&#x2F;RIP 劫持方式注入，还需要存储返回的 DLL 句柄、ShellCode。</li>
<li>调用 MapViewOfFile 函数将“文件映射对象”映射到当前进程地址空间，得到虚拟地址 A。</li>
<li>将 DLL 路径、ShellCode 等写入到虚拟地址 A。</li>
<li>调用 MapViewOfFile2 函数将“文件映射对象”映射到目标进程地址空间，得到虚拟地址 B。</li>
<li>根据虚拟地址 B 来计算 DLL 路径在目标进程中的真实地址，以及填充 ShellCode 中的地址占位符。</li>
<li>等待约 50ms。</li>
<li>调用 CreateRemoteThread 或者修改 RIP 来实现注入。</li>
<li>获取 DLL 句柄。如果使用 EIP&#x2F;RIP 注入，则使用虚拟地址 A 读取 DLL 句柄，因为 CPU 会负责数据的同步；如果使用远程线程注入，则直接通过线程退出码来获取 DLL 句柄。</li>
</ol>
<p>为什么第 6 步需要等待 50ms？因为在多核系统中，CPU 进行同步时可能会有一个短暂的延迟，等待 50ms，确保第 5 步修改的数据已经同步到目标进程（目前我还没有找到更好的办法）。</p>
<p>另外，在 DLL 注入之后，最好不要调用 UnmapViewOfFile2 函数来取消对目标进程的映射，否则目标进程中的相关数据会被清除，可能导致其他错误。</p>
<blockquote>
<p>由于 MapViewOfFile2 函数在 Windows 8+ 才引入，所以这种方式支持的操作系统版本有限。</p>
</blockquote>
<p>下面是使用文件映射方式结合 RIP 劫持实现的 DLL 注入的完整示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMODULE <span class="title">MapRipHijackInjectDll64</span><span class="params">(DWORD dwProcessID, LPCTSTR pszDllPath, DWORD&amp; dwGLE)</span> </span>&#123;</span><br><span class="line">    HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hTargeProcess = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hMapping = <span class="literal">NULL</span>;</span><br><span class="line">    LPVOID pLocalAddress = <span class="literal">NULL</span>;</span><br><span class="line">    LPVOID pRemoteAddress = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">SetLastError</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="keyword">if</span> (pszDllPath == <span class="literal">NULL</span> || dwProcessID == <span class="number">0</span>)</span><br><span class="line">            __leave;</span><br><span class="line"></span><br><span class="line">        LPVOID pLoadLibraryAddr = <span class="built_in">GetLoadLibarayAddress</span>();</span><br><span class="line">        <span class="keyword">if</span> (!pLoadLibraryAddr)</span><br><span class="line">            __leave;</span><br><span class="line"></span><br><span class="line">        hTargeProcess = <span class="built_in">OpenProcess</span>(PROCESS_VM_OPERATION, FALSE, dwProcessID);</span><br><span class="line">        <span class="keyword">if</span> (!hTargeProcess)</span><br><span class="line">            __leave;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clang-format off</span></span><br><span class="line">        BYTE shellCode[] = &#123;</span><br><span class="line">            <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xEC</span>, <span class="number">0x28</span>,                                     <span class="comment">// sub rsp, 0x28</span></span><br><span class="line">            <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x4C</span>, <span class="number">0x24</span>, <span class="number">0x08</span>,                               <span class="comment">// mov [rsp+0x8], rcx</span></span><br><span class="line">            <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x10</span>,                               <span class="comment">// mov [rsp+0x10], rax</span></span><br><span class="line">            <span class="number">0x48</span>, <span class="number">0xB9</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// mov rcx, DllPathAddress</span></span><br><span class="line">            <span class="number">0x48</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// mov rax, LoadLibraryAddress</span></span><br><span class="line">            <span class="number">0xFF</span>, <span class="number">0xD0</span>,                                                 <span class="comment">// call rax</span></span><br><span class="line">            <span class="number">0x48</span>, <span class="number">0xB9</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// mov rcx, SaveResultAddress</span></span><br><span class="line">            <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x01</span>,                                           <span class="comment">// mov [rcx], rax</span></span><br><span class="line">            <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x10</span>,                               <span class="comment">// mov rax, [rsp+0x10]</span></span><br><span class="line">            <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x4C</span>, <span class="number">0x24</span>, <span class="number">0x10</span>,                               <span class="comment">// mov rcx, [rsp+0x8]</span></span><br><span class="line">            <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xC4</span>, <span class="number">0x28</span>,                                     <span class="comment">// add rsp, 0x28</span></span><br><span class="line">            <span class="number">0x49</span>, <span class="number">0xBB</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// mov r11, OriginalRip</span></span><br><span class="line">            <span class="number">0x41</span>, <span class="number">0xFF</span>, <span class="number">0xE3</span>                                            <span class="comment">// jmp rll</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// clang-format on</span></span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> SIZE_T dllPathSize = (_tcslen(pszDllPath) + <span class="number">1</span>) * <span class="built_in">sizeof</span>(TCHAR);</span><br><span class="line">        <span class="type">const</span> SIZE_T totalSize = dllPathSize + <span class="built_in">sizeof</span>(shellCode) + <span class="built_in">sizeof</span>(HMODULE);</span><br><span class="line"></span><br><span class="line">        hMapping = <span class="built_in">CreateFileMapping</span>(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, PAGE_EXECUTE_READWRITE, <span class="number">0</span>, totalSize, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!hMapping)</span><br><span class="line">            __leave;</span><br><span class="line"></span><br><span class="line">        pLocalAddress = <span class="built_in">MapViewOfFile</span>(hMapping, FILE_MAP_WRITE, <span class="number">0</span>, <span class="number">0</span>, dllPathSize);</span><br><span class="line">        <span class="keyword">if</span> (!pLocalAddress)</span><br><span class="line">            __leave;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> LPVOID pLocalDllPath = pLocalAddress;</span><br><span class="line">        <span class="type">const</span> LPVOID pLocalSaveResult = (BYTE*)pLocalDllPath + dllPathSize;</span><br><span class="line">        BYTE* pLocalShellCode = (BYTE*)pLocalSaveResult + <span class="built_in">sizeof</span>(HMODULE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先将数据拷贝到本地的内存</span></span><br><span class="line">        <span class="built_in">memcpy</span>(pLocalDllPath, pszDllPath, dllPathSize);</span><br><span class="line">        <span class="built_in">memcpy</span>(pLocalShellCode, shellCode, <span class="built_in">sizeof</span>(shellCode));</span><br><span class="line"></span><br><span class="line">        HANDLE hSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (hSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">            __leave;</span><br><span class="line"></span><br><span class="line">        THREADENTRY32 te32 = &#123;<span class="built_in">sizeof</span>(te32)&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">bool</span> fOk = <span class="built_in">Thread32First</span>(hSnap, &amp;te32); fOk; fOk = <span class="built_in">Thread32Next</span>(hSnap, &amp;te32)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (te<span class="number">32.</span>th32OwnerProcessID == dwProcessID) &#123;</span><br><span class="line">                <span class="comment">// 第一个线程通常是主线程</span></span><br><span class="line">                HANDLE hTargetThread = <span class="built_in">OpenThread</span>(THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_SET_CONTEXT, FALSE, te<span class="number">32.</span>th32ThreadID);</span><br><span class="line">                <span class="keyword">if</span> (!hTargetThread)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">SuspendThread</span>(hTargetThread) == (DWORD)<span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hTargetThread);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                CONTEXT threadCtx = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                threadCtx.ContextFlags = CONTEXT_FULL;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">GetThreadContext</span>(hTargetThread, &amp;threadCtx)) &#123;</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hTargetThread);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 映射到远程内存</span></span><br><span class="line">                pRemoteAddress = <span class="built_in">MapViewOfFile2</span>(hMapping, hTargeProcess, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, PAGE_EXECUTE_READWRITE);</span><br><span class="line">                <span class="keyword">if</span> (!pRemoteAddress) &#123;</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hTargetThread);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据远程内存的地址来填充ShellCode中的占位符</span></span><br><span class="line">                *(DWORD64*)(&amp;pLocalShellCode[<span class="number">16</span>]) = (DWORD64)pRemoteAddress + ((BYTE*)pLocalDllPath - (BYTE*)pLocalAddress);</span><br><span class="line">                *(DWORD64*)(&amp;pLocalShellCode[<span class="number">26</span>]) = (DWORD64)pLoadLibraryAddr;</span><br><span class="line">                *(DWORD64*)(&amp;pLocalShellCode[<span class="number">38</span>]) = (DWORD64)pRemoteAddress + ((BYTE*)pLocalSaveResult - (BYTE*)pLocalAddress);</span><br><span class="line">                *(DWORD64*)(&amp;pLocalShellCode[<span class="number">65</span>]) = (DWORD64)threadCtx.Rip;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在多核系统中，CPU同步会有短暂延迟</span></span><br><span class="line">                <span class="built_in">Sleep</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ShellCode在远程内存中的地址</span></span><br><span class="line">                LPVOID pRemoteShellCodeAddress = (BYTE*)pRemoteAddress + ((BYTE*)pLocalShellCode - (BYTE*)pLocalAddress);</span><br><span class="line"></span><br><span class="line">                threadCtx.Rip = (DWORD64)pRemoteShellCodeAddress;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">SetThreadContext</span>(hTargetThread, &amp;threadCtx)) &#123;</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hTargetThread);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">ResumeThread</span>(hTargetThread) == (DWORD)<span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hTargetThread);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">Sleep</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 读取DLL句柄</span></span><br><span class="line">                hDll = *(HMODULE*)pLocalSaveResult;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">CloseHandle</span>(hTargetThread);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CloseHandle</span>(hSnap);</span><br><span class="line">    &#125; __finally &#123;</span><br><span class="line">        dwGLE = <span class="built_in">GetLastError</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hDll) &#123;</span><br><span class="line">            <span class="comment">// 注入成功后，不要取消对目标进程的映射</span></span><br><span class="line">            <span class="keyword">if</span> (hTargeProcess &amp;&amp; pRemoteAddress) &#123;</span><br><span class="line">                <span class="built_in">UnmapViewOfFile2</span>(hTargeProcess, pRemoteAddress, <span class="number">0</span>);</span><br><span class="line">                pRemoteAddress = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pLocalAddress)</span><br><span class="line">            <span class="built_in">UnmapViewOfFile</span>(pLocalAddress);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hMapping)</span><br><span class="line">            <span class="built_in">CloseHandle</span>(hMapping);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hTargeProcess)</span><br><span class="line">            <span class="built_in">CloseHandle</span>(hTargeProcess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hDll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="用户模式-APC-注入"><a href="#用户模式-APC-注入" class="headerlink" title="用户模式 APC 注入"></a>用户模式 APC 注入</h1><h2 id="QueueUserAPC"><a href="#QueueUserAPC" class="headerlink" title="QueueUserAPC"></a>QueueUserAPC</h2><p>每个线程都有一个 APC 队列，当线程进入可警告状态（Alertable）时，会按照 FIFO 的顺序执行 APC（异步过程调用）。</p>
<p>在用户模式和内核模式都可以实现 APC 注入，本节介绍如何在用户模式实现 APC 注入。用户模式实现 APC 注入主要使用 QueueUserAPC 函数向目标线程插入 APC。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">QueueUserAPC</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PAPCFUNC  pfnAPC,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HANDLE    hThread,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] ULONG_PTR dwData</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与远程线程注入的思路类似，也是利用将 LoadLibrary 地址作为 pfnAPC 参数传入，DLL 路径作为 dwData 参数传入（也需要提前在目标进程分配内存和赋值），来实现在目标进程中的加载 DLL 。</p>
<p>APC 注入的弊端在于，当 APC 插入到队列之后，并不会立即执行，需要等待线程进入可警告状态时才会依次执行，那么线程何时进入可警告状态呢？</p>
<p>线程只有调用 SleepEx、SignalObjectAndWait、WaitForSingleObjectEx、WaitForMultipleObjectsEx 或 MsgWaitForMultipleObjectsEx 函数后才会进入可警告状态。</p>
<p>因此当插入 APC 后，我们还要祈祷线程赶快执行上述函数，否则 DLL 永远不会被注入。虽然为了提高注入的成功率，通常会在目标进程的所有线程中都执行 APC 插入操作，但这样成功率依然无法得到保证。</p>
<p>通过未公开的 NtTestAlert 函数虽然也可以使线程执行并清空当前 APC 队列，当该函数只能作用于当前进程中的当前线程，无法操作远程线程。</p>
<p>目前，还可以使用未公开的 NtQueueApcThreadEx 函数进行 APC 注入，使用该函数插入一个特殊的 APC，可以不用等待线程进入 Alertable 状态，但这种方式对系统的版本有限制。</p>
<h2 id="Early-Bird"><a href="#Early-Bird" class="headerlink" title="Early Bird"></a>Early Bird</h2><p>Early Bird 翻译为中文叫“早起的鸟儿”。顾名思义，就是注入的时机很早。</p>
<p>Early Bird 本质上也是一种 APC 注入技术，其间接利用了 NtTestAlert 函数。因为线程在初始化时会主动调用 NtTestAlert 函数来清空和处理 APC 队列。所以我们可以创建一个挂起的进程（当然其主线程也会被挂起），并调用 QueueUserAPC 函数在该线程中插入一个 APC，然后恢复线程。当线程进入初始化流程后会自动调用 NtTestAlert 来清空并处理 APC 队列中的任务，这样我们插入的 APC 就得以执行。</p>
<p>下面代码通过将 LoadLibrary 地址插入 APC 的方式来展示了 Early Bird 的基本流程，我们也可以将其换成 ShellCode 的地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PFN_NtTestAlert pfnNtTestAlert = (PFN_NtTestAlert)<span class="built_in">GetProcAddress</span>(<span class="built_in">LoadLibraryW</span>(<span class="string">L&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtTestAlert&quot;</span>);</span><br><span class="line">LPVOID pLoadLibraryAddr = <span class="built_in">GetLoadLibarayAddress</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择合适的程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    WCHAR szPath[MAX_PATH] = &#123;<span class="string">L&quot;a 64bit process path&quot;</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    WCHAR szPath[MAX_PATH] = &#123;<span class="string">L&quot;a 32bit process path&quot;</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">STARTUPINFOW si = &#123;<span class="built_in">sizeof</span>(si)&#125;;</span><br><span class="line">PROCESS_INFORMATION pi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建挂起的进程</span></span><br><span class="line"><span class="built_in">CreateProcessW</span>(<span class="literal">NULL</span>, szPath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> SIZE_T dllPathSize = (_tcslen(pszDllPath) + <span class="number">1</span>) * <span class="built_in">sizeof</span>(TCHAR);</span><br><span class="line">LPVOID pRemoteDllPath = <span class="built_in">VirtualAllocEx</span>(pi.hProcess, <span class="literal">NULL</span>, dllPathSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(pi.hProcess, pRemoteDllPath, pszDllPath, dllPathSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入APC</span></span><br><span class="line"><span class="built_in">QueueUserAPC</span>((PAPCFUNC)pLoadLibraryAddr, pi.hThread, (ULONG_PTR)pRemoteDllPath);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ResumeThread</span>(pi.hThread);</span><br></pre></td></tr></table></figure>

<h1 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h1><p>Inline Hook（内联挂钩）是一种直接修改目标函数开头的指令，使其跳转到自定义的代理函数，从而实现 Hook 的技术。</p>
<p>基本步骤如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">原始函数：</span><br><span class="line">7FFA12345678: 55                    push rbp</span><br><span class="line">7FFA12345679: 48 89 E5              mov rbp, rsp</span><br><span class="line">7FFA1234567C: 48 83 EC 20           sub rsp, 20h</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Inline Hook 后：</span><br><span class="line">7FFA12345678: E9 83 11 22 33        jmp MyHookFunction  ; 修改为跳转指令</span><br><span class="line">7FFA1234567D: EC 20                 ; 被覆盖的原有指令（部分破坏）</span><br></pre></td></tr></table></figure>

<p>从上面基本步骤可以看出，<code>jmp MyHookFunction</code>指令占用 5 字节，使用替换之前指令，会导致第 3 条指令仅部分被替换，这也是 Inline Hook 的技术挑战之一：不同指令长度不同，需要完整覆盖指令边界。</p>
<p>另外，jmp 指令使用相对跳转（目标地址 &#x3D; 当前 EIP + 相对偏移），因此还需要计算当前指令相对 EIP 的偏移地址。</p>
<p>在执行完 MyHookFunction 函数后，如果需要继续执行原始函数怎么呢？可以在 MyHookFunction 中还原被覆盖的原有指令吗？类似下面的做法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在调用前还原原始指令，调用后再重新hook</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyHookFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 还原原始代码</span></span><br><span class="line">    <span class="built_in">RestoreOriginalCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用原始函数</span></span><br><span class="line">    <span class="built_in">OriginalFunction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新hook ← ❌ 这里有问题！</span></span><br><span class="line">    <span class="built_in">RehookFunction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是错误的，这样做在多线程情况下，可能会出现竞态条件问题，线程 A 正在执行原始函数，而线程 B 可能会在进行重新 Hook，导致无法拦截。而且每次修改指令都需要更改内存保护属性，这种反复修改的代价也很高。</p>
<p>可以通过引入跳板机制来解决上述问题，以 Hook MessageBoxA 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; 原始函数被修改后：</span><br><span class="line">MessageBoxA:</span><br><span class="line">    jmp MyMessageBoxA  ; 5字节（x86）或14字节（x64）</span><br><span class="line">    ... 被覆盖的原始指令 ...</span><br><span class="line"></span><br><span class="line">; 跳板函数：</span><br><span class="line">MessageBoxA_Trampoline:</span><br><span class="line">    ; 1. 被覆盖的原始指令</span><br><span class="line">    push ebp</span><br><span class="line">    mov ebp, esp</span><br><span class="line">    sub esp, 20h</span><br><span class="line">    ; 2. 跳回原始函数的剩余部分</span><br><span class="line">    jmp MessageBoxA+5</span><br></pre></td></tr></table></figure>

<p>在任何时候，需要调用原始 MessageBoxA 时，直接调用 MessageBoxA_Trampoline 即可。</p>
<div style="text-aligin:center;"><img data-src="../images/blog/minhook-yuanli.png" width="360px" /></div>

<p>上面的实现方法虽然不难，但仍然有很多需要考虑的情况，特别是要开发一个通用的 Inline Hook 库，比如需要考虑如何界定待 Hook 函数的指令边界，确保没有出现本节一开始的部分指令被替换的情况等。</p>
<p>说到这里就不得不推出今天的主角 – <a target="_blank" rel="noopener" href="https://github.com/TsudaKageyu/minhook">minhook</a>，该库是目前 Windows 上使用最广泛的 Inline Hook 解决方案，完美解决了上述问题，而且使用起来也非常简单，下面通过几行代码来演示该库的使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(WINAPI * PFN_MessageBoxW)</span><span class="params">(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)</span></span>;</span><br><span class="line"></span><br><span class="line">LPVOID pfnTraget = <span class="literal">NULL</span>;                <span class="comment">// 等同于MessageBoxW的原始地址</span></span><br><span class="line">PFN_MessageBoxW pfnTrampoline = <span class="literal">NULL</span>;   <span class="comment">// 跳板函数，用于在Detour函数中调用原始的MessageBoxW，不能直接调用pfnTraget</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">MyMessageBoxW</span><span class="params">(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pfnTrampoline</span>(hWnd, <span class="string">L&quot;MessageBoxW has been hooked by IAT-Hook!&quot;</span>, TITLE, uType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化MinHook</span></span><br><span class="line">MH_STATUS mhStatus = <span class="built_in">MH_Initialize</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook User32.dll::MessageBoxW</span></span><br><span class="line">mhStatus = <span class="built_in">MH_CreateHookApiEx</span>(</span><br><span class="line">    <span class="string">L&quot;User32.dll&quot;</span>,</span><br><span class="line">    <span class="string">&quot;MessageBoxW&quot;</span>,</span><br><span class="line">    (LPVOID)MyMessageBoxW,</span><br><span class="line">    (LPVOID*)&amp;pfnTrampoline,</span><br><span class="line">    (LPVOID*)&amp;pfnTraget);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用指定钩子</span></span><br><span class="line">mhStatus = <span class="built_in">MH_EnableHook</span>(pfnTraget);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当不需要钩子时，移除指定钩子</span></span><br><span class="line"><span class="built_in">MH_RemoveHook</span>(pfnTraget);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后，反初始化MinHook</span></span><br><span class="line">mhStatus = <span class="built_in">MH_Uninitialize</span>();</span><br></pre></td></tr></table></figure>

<h1 id="IAT-Hook"><a href="#IAT-Hook" class="headerlink" title="IAT Hook"></a>IAT Hook</h1><p>IAT 的导入地址表（Import Address Table）的简写，该表记录了程序从哪些 DLL 导入了哪些函数。</p>
<p>Windows 应用程序都会依赖系统库或其他第三方库，虽然通过 MT(d)编译的程序会静态链接 CRT，但其他系统库仍然会出现在 IAT 中，因为这些系统库无法被静态链接到应用程序中。</p>
<p>IAT Hook 的原理：针对隐式调用的函数，编译器在生成代码时，会将 <code>call MessageBox</code> 指令指向 IAT 中的一个条目，我们 Hook 掉这个条目（将其中的地址改为自己函数地址），程序执行时就会跳转到我们自己的代码。</p>
<p>但是 IAT Hook 对显式调用（LoadLibrary -&gt; GetProcAddress）的函数没有效果，因为 GetProcAddress 函数是从 DLL 的导出表（EAT）中查找的函数原始内存地址，这个过程根本不会查阅调用者自身的 IAT 表，所以 Hook 无法生效。</p>
<blockquote>
<p>如果要对显示调用的函数进行 Hook，可以使用后面章节介绍的 EAT Hook。</p>
</blockquote>
<p>既然是 IAT Hook，那么肯定先要找 IAT 表。根据下图描述的 PE 文件结构，我们可以解析出 IAT 数据。</p>
<p><img data-src="/images/blog/pe.jpg"></p>
<p>在解析 IAT 数据之前，先要找到与导入表相关的数据目录项，大致步骤为：</p>
<ol>
<li>首先根据 DOS 头中的 e_lfanew 字段定位到 NT 头。</li>
<li>然后找到 NT 头中的 Optional 头。</li>
<li>在 Optional 头的尾部存储了一个 DataDirectorys 数组（数组中每个元素都是 IMAGE_DATA_DIRECTORY 类型），该数组中索引为 1 的项中存储的是“导入表”的偏移和大小。</li>
<li>根据镜像基地址加上偏移就找到了“导入表数据目录项”了。</li>
</ol>
<p>IMAGE_DATA_DIRECTORY 类型定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DATA_DIRECTORY</span> &#123;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>其中，VirtualAddress 中存储的不是绝对地址，而是相对与镜像基址的偏移（RVA），在下面介绍的结构体中的元素所存储的地址也都是 RVA。</p>
<p>VirtualAddress 所指向的是 IMAGE_IMPORT_DESCRIPTOR 数组（导入表描述符），数组中每一个 IMAGE_IMPORT_DESCRIPTOR 元素代表一个依赖的 DLL。</p>
<p>IMAGE_IMPORT_DESCRIPTOR 定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;</span><br><span class="line">        DWORD   OriginalFirstThunk;   <span class="comment">// 存储导入名称表INT的 RVA</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   ForwarderChain;</span><br><span class="line">    DWORD   Name;               <span class="comment">// 存储对应 DLL 文件名字符串的 RVA</span></span><br><span class="line">    DWORD   FirstThunk;         <span class="comment">// 存储导入地址表IAT的 RVA。加载到内存后，加载器会将函数的真实内存地址填充到此表中</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>我们知道 DLL 的导出函数分为按名称导出和按序号导出，同样从 DLL 中导入函数也对应这两种情况。</p>
<p>IMAGE_IMPORT_DESCRIPTOR 结构中的 OriginalFirstThunk 字段所指向的数组用于存储导入函数的名称或序号，我们将该数组称为导入名称表（INT），数组中的元素为 IMAGE_THUNK_DATA 类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_THUNK_DATA32</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD ForwarderString;      <span class="comment">// PBYTE</span></span><br><span class="line">        DWORD Function;             <span class="comment">// PDWORD</span></span><br><span class="line">        DWORD Ordinal;</span><br><span class="line">        DWORD AddressOfData;        <span class="comment">// PIMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>

<p>而 IMAGE_IMPORT_DESCRIPTOR 结构中的 FirstThunk 字段所数组用于存储函数导入后的真实内存地址，我们将该数组称为导入地址表（IAT），数组中的元素也是 IMAGE_THUNK_DATA 类型。</p>
<p>两个数组中的元素类型都是 IMAGE_THUNK_DATA 类型，但在 INT 表中主要使用 AddressOfData 和 Ordinal 字段，其中 AddressOfData 字段存储函数名称的 RAV，Ordinal 字段用于判断当前函数是按名称还是按序号导入（1 为函数名，否则为序号），而在 IAT 表中则主要使用 Function 字段，其中存储的是函数真实地址。</p>
<p>上面出现的 3 个数组（IMAGE_IMPORT_DESCRIPTOR 数组、INT 数组、IAT 数组）都没有提供专门的字段来获取数组元素的个数，那么在遍历数组时，如何判断最后一个元素呢？</p>
<p>通过指针递增的方式来依次遍历每个元素，但元素中的所有字段都为 0 时，表示该元素为数组中的最后一个元素。</p>
<p>说了这么多，读者可能有些混乱了，我画了一个图可能会对理解整个流程有所帮助。</p>
<div style="text-aligin:center;"><img data-src="../images/blog/mVZKxlt7bk.png" width="660px" /></div>

<p>在找到指定模块的指定函数之后，将<code>u1.Function</code>所指向的导入函数地址修改为我们自己函数的地址，就可以实现 Hook 了。当然别忘了保存原始的函数地址，以便后面进行 Unhook 或调用。</p>
<p>下面是 32 位程序使用 IAT Hook user32.dll::MessageBoxW 的完整示例代码（64 位程序将代码中的结构体修改为对应的的 64 位结构体即可）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">PFN_MessageBoxW originalMessageBoxW = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitIATHook86</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基地址</span></span><br><span class="line">    <span class="type">uint8_t</span>* pModule = (<span class="type">uint8_t</span>*)<span class="built_in">GetModuleHandle</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DOS头</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pModule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NT头</span></span><br><span class="line">    PIMAGE_NT_HEADERS32 pNTHeaders = (PIMAGE_NT_HEADERS32)(pModule + pDosHeader-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导入表数据目录项</span></span><br><span class="line">    <span class="type">const</span> IMAGE_DATA_DIRECTORY importDir = pNTHeaders-&gt;OptionalHeader.DataDirectory[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)(pModule + importDir.VirtualAddress);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pImportDesc-&gt;Characteristics == <span class="number">0</span>)  <span class="keyword">break</span>; <span class="comment">// 最后一个</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 导入的模块名</span></span><br><span class="line">        <span class="type">const</span> std::string dllName = <span class="built_in">ReadStringUntilZero</span>((<span class="type">const</span> <span class="type">char</span>*)(pModule + pImportDesc-&gt;Name));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">StrToLower</span>(dllName) != <span class="string">&quot;user32.dll&quot;</span>) &#123;</span><br><span class="line">            pImportDesc += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 导入模块中的函数名称</span></span><br><span class="line">        PIMAGE_THUNK_DATA32 pINT_Thunk = (PIMAGE_THUNK_DATA32)(pModule + pImportDesc-&gt;OriginalFirstThunk);  <span class="comment">// OriginalFirstThunk = INT</span></span><br><span class="line">        PIMAGE_THUNK_DATA32 pIAT_Thunk = (PIMAGE_THUNK_DATA32)(pModule + pImportDesc-&gt;FirstThunk);          <span class="comment">// FirstThunk = IAT</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pINT_Thunk-&gt;u<span class="number">1.</span>Ordinal == <span class="number">0</span>)  <span class="comment">// 最后一个</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(pINT_Thunk-&gt;u<span class="number">1.</span>Ordinal &amp; IMAGE_ORDINAL_FLAG32)) &#123;  <span class="comment">//高位不为1时，使用名称导入</span></span><br><span class="line">                <span class="type">const</span> PIMAGE_IMPORT_BY_NAME pImportByName = (PIMAGE_IMPORT_BY_NAME)(pModule + pINT_Thunk-&gt;u<span class="number">1.</span>AddressOfData);</span><br><span class="line">                <span class="type">const</span> std::string funName = <span class="built_in">ReadStringUntilZero</span>(pImportByName-&gt;Name);</span><br><span class="line">                <span class="keyword">if</span> (funName == <span class="string">&quot;MessageBoxW&quot;</span>) &#123;</span><br><span class="line">                    originalMessageBoxW = (PFN_MessageBoxW)pIAT_Thunk-&gt;u<span class="number">1.F</span>unction;</span><br><span class="line">                    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">VirtualProtect</span>(&amp;pIAT_Thunk-&gt;u<span class="number">1.F</span>unction, <span class="built_in">sizeof</span>(DWORD), PAGE_READWRITE, &amp;oldProtect)) &#123;</span><br><span class="line">                        pIAT_Thunk-&gt;u<span class="number">1.F</span>unction = (DWORD)MyMessageBoxW;</span><br><span class="line">                        <span class="built_in">VirtualProtect</span>(&amp;pIAT_Thunk-&gt;u<span class="number">1.F</span>unction, <span class="built_in">sizeof</span>(DWORD), oldProtect, &amp;oldProtect);</span><br><span class="line">                        result = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pINT_Thunk += <span class="number">1</span>;</span><br><span class="line">            pIAT_Thunk += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        pImportDesc += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="EAT-Hook"><a href="#EAT-Hook" class="headerlink" title="EAT Hook"></a>EAT Hook</h1><p>EAT 是导入地址表（Export Address Table）的简写，该表记录了 DLL 导出了哪些函数。</p>
<p>与上面介绍的 IAT Hook 不同，IAT Hook 修改的是可执行程序自身的导入表，而 EAT Hook 修改的是 DLL 的导出表。</p>
<p>查找 EAT 的步骤与上面的查找 IAT 的步骤类似，先找到导出表数据目录项（位于 Optional -&gt; DataDirectorys 数组的第 0 项），然后定位并解析 IMAGE_EXPORT_DIRECTORY 数组。</p>
<p>IMAGE_EXPORT_DIRECTORY 定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_EXPORT_DIRECTORY</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD   Characteristics;       <span class="comment">// 保留,始终为0x00000000</span></span><br><span class="line">    DWORD   TimeDateStamp;         <span class="comment">// 文件的产生时间戳</span></span><br><span class="line">    WORD    MajorVersion;          <span class="comment">// 主版本号</span></span><br><span class="line">    WORD    MinorVersion;          <span class="comment">// 次版本号</span></span><br><span class="line">    DWORD   Name;                  <span class="comment">// 指向文件名的RVA</span></span><br><span class="line">    DWORD   Base;                  <span class="comment">// 导出函数的起始序号</span></span><br><span class="line">    DWORD   NumberOfFunctions;     <span class="comment">// 导出函数总数</span></span><br><span class="line">    DWORD   NumberOfNames;         <span class="comment">// 以名称导出函数的总数</span></span><br><span class="line">    DWORD   AddressOfFunctions;    <span class="comment">// 导出函数地址表的RVA，也就是EAT</span></span><br><span class="line">    DWORD   AddressOfNames;        <span class="comment">// 函数名称地址表的RVA，这个表里面的索引需要通过AddressOfNameOrdinals获取</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals; <span class="comment">// 函数名序号表的RVA，将序号表里面的元素作为索引传入AddressOfNames，获取函数地址</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>IMAGE_EXPORT_DIRECTORY 中各个字段的作用及关系如下：</p>
<div style="text-aligin:center;"><img data-src="../images/blog/IMAGE_EXPORT_DIRECTORY.jpg" width="560px" /></div>

<p>其中，NumberOfNames 字段记录了当前 DLL 按名称导出的函数的总数；</p>
<p>AddressOfNames 字段所指向的表中存储了导出函数的名称（按序号导出的函数不在该表），而 AddressOfFunctions 字段所指向的表中存储了每个函数的地址（包含按名称导出和按序号导出的函数）。因此 AddressOfNames 和 AddressOfFunctions 表不是一一对应的关系，AddressOfFunctions 表中的元素可能比 AddressOfNames 表多。它们之间通过 AddressOfNameOrdinals 表建立连接，AddressOfNames 与 AddressOfNameOrdinals 表是一一对应的关系，通过 AddressOfNames 表的索引可以在 AddressOfNameOrdinals 表中查询到函数在 AddressOfFunctions 表中的索引。</p>
<p>需要注意：</p>
<ul>
<li>AddressOfNameOrdinals 所指向的是 WORD 数组，而不是 DWORD 数组。</li>
<li>IMAGE_EXPORT_DIRECTORY 中存储的 RAV 是相对于模块基地址的偏移，而且 AddressOfFunctions 中存储的也是 RAV（IAT 中存储的却是绝对地址）。</li>
</ul>
<p>下面是 32 位程序使用 EAT Hook user32.dll::MessageBoxW 的完整示例代码（64 位程序将代码中的结构体修改为对应的的 64 位结构体即可）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">PFN_MessageBoxW originalMessageBoxW = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitEATHook86</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span>* pBase = (<span class="type">uint8_t</span>*)<span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;User32.dll&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DOS头</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NT头</span></span><br><span class="line">    PIMAGE_NT_HEADERS32 pNTHeaders = (PIMAGE_NT_HEADERS32)(pBase + pDosHeader-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> PIMAGE_EXPORT_DIRECTORY pExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + exportDir.VirtualAddress);</span><br><span class="line">    <span class="type">const</span> WORD* pNameIndexTable = (WORD*)(pBase + pExportDir-&gt;AddressOfNameOrdinals);  <span class="comment">// 2个字节</span></span><br><span class="line">    <span class="type">const</span> DWORD* pNameAddressTable = (DWORD*)(pBase + pExportDir-&gt;AddressOfNames);</span><br><span class="line">    DWORD* pFuncAddressTable = (DWORD*)(pBase + pExportDir-&gt;AddressOfFunctions); <span class="comment">// EAT</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (DWORD j = <span class="number">0</span>; j &lt; pExportDir-&gt;NumberOfNames; j++) &#123;</span><br><span class="line">        <span class="type">const</span> WORD index = pNameIndexTable[j];  <span class="comment">// 2个字节</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* pName = (<span class="type">const</span> <span class="type">char</span>*)(pBase + pNameAddressTable[j]);</span><br><span class="line">        <span class="type">const</span> std::string funName = <span class="built_in">ReadStringUntilZero</span>(pName);</span><br><span class="line">        <span class="keyword">if</span> (funName == <span class="string">&quot;MessageBoxW&quot;</span>) &#123;</span><br><span class="line">            originalMessageBoxW = (PFN_MessageBoxW)(pBase + pFuncAddressTable[index]);</span><br><span class="line">            DWORD oldProtect;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">VirtualProtect</span>((LPVOID)&amp;pFuncAddressTable[index], <span class="built_in">sizeof</span>(DWORD), PAGE_READWRITE, &amp;oldProtect)) &#123;</span><br><span class="line">                pFuncAddressTable[index] = (DWORD)MyMessageBoxW - (DWORD)pBase;  <span class="comment">// 此处存储的是RAV</span></span><br><span class="line">                <span class="built_in">VirtualProtect</span>((LPVOID)&amp;pFuncAddressTable[index], <span class="built_in">sizeof</span>(DWORD), oldProtect, &amp;oldProtect);</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="硬件断点-Hook"><a href="#硬件断点-Hook" class="headerlink" title="硬件断点 Hook"></a>硬件断点 Hook</h1><p>硬件断点 Hook 的核心在于利用 CPU 的调试寄存器（DR0 ~ DR3）触发 EXCEPTION_SINGLE_STEP 异常，并通过 VEH 异常处理函数来劫持程序的执行流程，也可以通过该方式来劫持 ldrLoadDll 函数来实现 DLL 注入。</p>
<p>主要步骤如下：</p>
<ol>
<li><p>注册 VEH 处理函数：使用 AddVectoredExceptionHandler 函数注册一个异常处理回调函数，并通常将第一个参数设为 1，以确保你的处理函数最先被调用。</p>
</li>
<li><p>遍历并暂停线程：因为硬件断点是线程相关的，需要使用 CreateToolhelp32Snapshot 等函数遍历目标进程中的所有线程。对于每个需要设置的线程，先调用 SuspendThread 将其暂停。</p>
</li>
<li><p>设置线程上下文：使用 GetThreadContext 获取线程的上下文结构（CONTEXT）。然后配置调试寄存器：</p>
<ul>
<li>将 DR0 到 DR3（中的一个）设置为你想要监控的内存地址。</li>
<li>配置 DR7 控制寄存器，以启用特定的断点并设置其触发条件（如执行、写入）和长度。</li>
</ul>
</li>
<li><p>恢复线程执行：使用 SetThreadContext 应用新的上下文，然后调用 ResumeThread 恢复线程运行</p>
</li>
</ol>
<blockquote>
<p>关于调试寄存器的具体功能，可以参考之前的文章：<a href="/post/470495318.html" title="x86架构常用寄存器及汇编指令">x86架构常用寄存器及汇编指令</a>。</p>
</blockquote>
<p>其中：</p>
<ul>
<li>DR7 寄存器中的 <code>L0 ~ L3</code> 位分别记录了 <code>DR0 ~ DR3</code> 局部断点是否启用。<code>G0 ~ G3</code> 分别记录了 <code>DR0 ~ DR3</code> 全局断点是否启用。</li>
<li><code>LEN0 ~ LEN3</code> 分别记录 <code>DR0 ~ DR3</code> 断点的长度，每个占 2 位。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">HWBP_LEN</span> &#123;</span><br><span class="line">    HWBP_LEN_1 = <span class="number">0</span>,  <span class="comment">// 二进制00，对应1 byte</span></span><br><span class="line">    HWBP_LEN_2 = <span class="number">1</span>,  <span class="comment">// 二进制01，对应2 bytes</span></span><br><span class="line">    HWBP_LEN_8 = <span class="number">2</span>,  <span class="comment">// 二进制10，对应8 bytes（仅x64）</span></span><br><span class="line">    HWBP_LEN_4 = <span class="number">3</span>   <span class="comment">// 二进制11，对应4 bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>R/W0 ~ R/W3</code> 分别记录 <code>DR0 ~ DR3</code> 断点的类型，每个占 2 位。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">HWBP_TYPE</span> &#123;</span><br><span class="line">    HWBP_EXECUTE = <span class="number">0</span>,</span><br><span class="line">    HWBP_WRITE = <span class="number">1</span>,</span><br><span class="line">    HWBP_READWRITE = <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在设置硬件断点时，不需要使用 DR6 寄存器，但是异常处理回调中，却可以使用 DR6 寄存器来确定当前 EXCEPTION_SINGLE_STEP 异常是由哪个调试寄存器触发的，DR6 的第 <code>0 ~ 3</code> 位分别对应 <code>DR0 ~ DR3</code> 寄存器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> regIndex = <span class="number">-1</span>; <span class="comment">// DR0 ~ DR3</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;Dr6 &amp; <span class="number">0x1</span>)</span><br><span class="line">    regIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ctx-&gt;Dr6 &amp; <span class="number">0x2</span>)</span><br><span class="line">    regIndex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ctx-&gt;Dr6 &amp; <span class="number">0x4</span>)</span><br><span class="line">    regIndex = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ctx-&gt;Dr6 &amp; <span class="number">0x8</span>)</span><br><span class="line">    regIndex = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>要配置线程的调试寄存器，首先要获取一个该线程没有被使用的调试寄存器。下面代码展示了如何通过 DR7 寄存器的 <code>L0 ~ L3</code> 位来判断调试寄存器是否已经被启用，返回的索引 <code>0 ~ 3</code> 分别代表 <code>DR0 ~ DR3</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindAvailableDebugRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CONTEXT ctx = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;</span><br><span class="line"></span><br><span class="line">    HANDLE hThread = <span class="built_in">GetCurrentThread</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">GetThreadContext</span>(hThread, &amp;ctx))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查哪些调试寄存器可用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(ctx.Dr7 &amp; (<span class="number">1</span> &lt;&lt; (i * <span class="number">2</span>))))</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取到可用的调试寄存器后，就可以将需要断住的内存地址赋值给该寄存器，当然，别忘了在 DR7 中配置局部启用该寄存器以及断点的类型（执行）和长度（1 字节）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">CONTEXT ctx = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;</span><br><span class="line"><span class="built_in">GetThreadContext</span>(hThread, &amp;ctx);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> regIndex = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置断点地址</span></span><br><span class="line"><span class="keyword">switch</span> (regIndex) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ctx.Dr0 = address;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ctx.Dr1 = address;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ctx.Dr2 = address;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ctx.Dr3 = address;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx.Dr7 |= (<span class="number">1</span> &lt;&lt; (regIndex * <span class="number">2</span>)); <span class="comment">// 局部启用位</span></span><br><span class="line">ctx.Dr7 |= (<span class="built_in">static_cast</span>&lt;DWORD&gt;(type) &lt;&lt; (<span class="number">16</span> + regIndex * <span class="number">4</span>)); <span class="comment">// 设置类型</span></span><br><span class="line">ctx.Dr7 |= (<span class="built_in">static_cast</span>&lt;DWORD&gt;(len) &lt;&lt; (<span class="number">18</span> + regIndex * <span class="number">4</span>)); <span class="comment">// 设置长度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">SetThreadContext</span>(hThread, &amp;ctx);</span><br></pre></td></tr></table></figure>

<p>当断点位置处的代码被执行时，会进入 AddVectoredExceptionHandler 的异常处理回调函数。因为 EXCEPTION_SINGLE_STEP 类型的异常才是硬件断点异常，所以我们在回调函数中只处理 EXCEPTION_SINGLE_STEP 类型的异常，其他类型的异常直接返回 EXCEPTION_CONTINUE_SEARCH。</p>
<p>通过 PCONTEXT 中的 EIP&#x2F;RIP 寄存器获取当前触发断点的地址，判断该地址是否为我们下断点的地址。如果是的，我们可以通过寄存器(x64)或堆栈(x86)来获取和修改参数的值。这个时候如果直接返回 EXCEPTION_CONTINUE_EXECUTION，程序会再次执行断点处的代码，从而再次进入异常处理回调函数，这样陷入了死循环（递归触发）。要解决这个问题，我们需要在返回 EXCEPTION_CONTINUE_EXECUTION 前清除断点（即清除 DR7 和 DR6 中的相关位）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ClearHardwareBreadpoint</span><span class="params">(PCONTEXT ctx)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> regIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;Dr6 &amp; <span class="number">0x1</span>)</span><br><span class="line">        regIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ctx-&gt;Dr6 &amp; <span class="number">0x2</span>)</span><br><span class="line">        regIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ctx-&gt;Dr6 &amp; <span class="number">0x4</span>)</span><br><span class="line">        regIndex = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ctx-&gt;Dr6 &amp; <span class="number">0x8</span>)</span><br><span class="line">        regIndex = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (regIndex != <span class="number">-1</span>) &#123;</span><br><span class="line">        ctx-&gt;Dr7 &amp;= ~(<span class="number">1</span> &lt;&lt; (regIndex * <span class="number">2</span>)); <span class="comment">// 清除Dr7中的局部启用位</span></span><br><span class="line">        ctx-&gt;Dr7 &amp;= ~(<span class="number">0x0F</span> &lt;&lt; (<span class="number">16</span> + regIndex * <span class="number">4</span>)); <span class="comment">// 清除类型和长度位</span></span><br><span class="line">        ctx-&gt;Dr6 &amp;= ~(<span class="number">1</span> &lt;&lt; regIndex); <span class="comment">// 清除DR6上的指定位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> regIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LONG CALLBACK <span class="title">VectoredExceptionHandler</span><span class="params">(PEXCEPTION_POINTERS pExceptionInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pExceptionInfo || !pExceptionInfo-&gt;ExceptionRecord) &#123;</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD exceptionCode = pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理硬件断点异常</span></span><br><span class="line">    <span class="keyword">if</span> (exceptionCode == EXCEPTION_SINGLE_STEP) &#123;</span><br><span class="line">        DWORD_PTR exceptionAddress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">        exceptionAddress = pExceptionInfo-&gt;ContextRecord-&gt;Rip;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        exceptionAddress = pExceptionInfo-&gt;ContextRecord-&gt;Eip;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否在MessageBoxW地址</span></span><br><span class="line">        <span class="keyword">if</span> (exceptionAddress == (DWORD_PTR)originalMessageBoxW) &#123;</span><br><span class="line">            PCONTEXT ctx = pExceptionInfo-&gt;ContextRecord;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">            ctx-&gt;R8 = (DWORD64)kReplacedCaption;</span><br><span class="line">            ctx-&gt;Rdx = (DWORD64)kReplacedMsg;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> clearedRegIndex = <span class="built_in">ClearHardwareBreadpoint</span>(ctx);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你只打算 Hook 一次 MessageBoxW，流程就到此结束了。但通常情况下，我们需要 Hook 每次对 MessageBoxW 的调用，所以我们需要找到一个合适的时机再次对 MessageBoxW 设置硬件断点。</p>
<p>有两个时机可以再次对 MessageBoxW 设置断点：</p>
<ul>
<li><p>时机 1：从函数起始地址向下查找有效的 ret 指令，在该指令处设置断点，当断点触发时再次为 MessageBoxW 设置断点。这种方式是可行的，但是 ret 指令有多种形式，如 ret、ret 4、ret 8 等，查找 ret 指令的逻辑会比较复杂。</p>
</li>
<li><p>时机 2：我们知道 call 指令会将函数的返回地址压入堆栈，因此我们可以通过 Rsp&#x2F;Esp 来获取函数返回地址，然后在返回地址上下断点，当断点触发时，再次在 MessageBoxW 上下断点，这种方式似乎更加优雅。</p>
</li>
</ul>
<p>下面介绍“时机 2”的实现方法（以 64 为程序为例）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG CALLBACK <span class="title">VectoredExceptionHandler</span><span class="params">(PEXCEPTION_POINTERS pExceptionInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pExceptionInfo || !pExceptionInfo-&gt;ExceptionRecord)</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line"></span><br><span class="line">    DWORD exceptionCode = pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理硬件断点异常</span></span><br><span class="line">    <span class="keyword">if</span> (exceptionCode == EXCEPTION_SINGLE_STEP) &#123;</span><br><span class="line">        DWORD_PTR exceptionAddress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        exceptionAddress = pExceptionInfo-&gt;ContextRecord-&gt;Rip;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否在MessageBoxW地址</span></span><br><span class="line">        <span class="keyword">if</span> (exceptionAddress == (DWORD_PTR)originalMessageBoxW) &#123;</span><br><span class="line">            PCONTEXT ctx = pExceptionInfo-&gt;ContextRecord;</span><br><span class="line">            ctx-&gt;R8 = (DWORD64)kReplacedCaption;</span><br><span class="line">            ctx-&gt;Rdx = (DWORD64)kReplacedMsg;</span><br><span class="line">            messageBoxWReturnAddress = *(DWORD_PTR*)ctx-&gt;Rsp;</span><br><span class="line">            <span class="type">int</span> clearedRegIndex = <span class="built_in">ClearHardwareBreadpoint</span>(ctx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在返回地址处设置断点</span></span><br><span class="line">            <span class="keyword">if</span> (messageBoxWReturnAddress &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">SetHardwareBreakpoint</span>(ctx, clearedRegIndex,(DWORD_PTR) messageBoxWReturnAddress, HWBP_EXECUTE, HWBP_LEN_1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (exceptionAddress == messageBoxWReturnAddress) &#123;</span><br><span class="line">            PCONTEXT ctx = pExceptionInfo-&gt;ContextRecord;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> clearedRegIndex = <span class="built_in">ClearHardwareBreadpoint</span>(ctx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新设置硬件断点</span></span><br><span class="line">            <span class="built_in">SetHardwareBreakpoint</span>(ctx, clearedRegIndex, (DWORD_PTR) originalMessageBoxW, HWBP_EXECUTE, HWBP_LEN_1);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意：在异常处理回调函数中设置硬件断点时，直接设置 <code>PEXCEPTION_POINTERS-&gt;PCONTEXT</code> 结构体中的寄存器即可，不要使用<code>SetThreadContext</code>函数，否则会出现断点不生效的问题。</p>
<h1 id="一些过时的内核-Hook-技术"><a href="#一些过时的内核-Hook-技术" class="headerlink" title="一些过时的内核 Hook 技术"></a>一些过时的内核 Hook 技术</h1><p>Windows 自 Vista 版本以来，就在 x64 系统中提供了一种内置的安全功能，该功能称为 PatchGuard（PG），用于保护内核的关键区域免遭修改，如果触发该机制就会导致系统蓝屏（BSOD）。</p>
<p>PatchGuard 通过内核模式线程定时检测以下关键区域的完整性：</p>
<ul>
<li>系统服务描述符表（SSDT）：监控函数入口地址是否被篡改。</li>
<li>全局描述符表（GDT）：校验中断处理程序的合法性。</li>
<li>中断描述符表（IDT）：保护内存段描述符结构。</li>
<li>系统映像（ntoskrnl.exe、ndis.sys、hal.dll）。</li>
<li>处理器 MSR（系统调用）</li>
<li>内核模块列表：验证加载驱动模块是否有效的数字签名。</li>
</ul>
<p>因此，在 x64 系统上，针对上面区域的 Hook 都已不再稳定有效。</p>
<h1 id="VT-Hook"><a href="#VT-Hook" class="headerlink" title="VT Hook"></a>VT Hook</h1><p>这个有点复杂，待我整理好后再更新！</p>

    </div>

    
    
    

    <footer class="post-footer"><div style="
    background-color: #ffffff; 
    border: 1px solid #e1e4e8; 
    padding: 24px; 
    margin: 28px 0; 
    border-radius: 12px;
    text-align: left;
    box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    font-size: 1.1em;
    font-weight: 600;
">
  <p style="margin: 0; color: #2c3e50; line-height: 1.6;">
    限于篇幅等原因，文中可能只展示了关键代码片段。如果您希望获取完整的、开箱即用的解决方案，可以随时联系我。
  </p>
</div>
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/coffie_wechat.png" alt="jiangxueqiao.com 微信">
        <span>微信</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>jiangxueqiao.com
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://jiangxueqiao.com/post/3573459553.html" title="代码的隐形战场：Windows进程注入与API Hook完全指南">https://jiangxueqiao.com/post/3573459553.html</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Hook/" rel="tag"># Hook</a>
              <a href="/tags/%E6%B3%A8%E5%85%A5/" rel="tag"># 注入</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/470495318.html" rel="prev" title="x86架构常用寄存器及汇编指令">
                  <i class="fa fa-angle-left"></i> x86架构常用寄存器及汇编指令
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/1112470146.html" rel="next" title="C++ Qt应用在macOS平台的编译与发布">
                  C++ Qt应用在macOS平台的编译与发布 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">鄂ICP备2020015399号-6 </a>
  </div>
  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-rocket"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">jiangxueqiao.com</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"winsoft666","repo":"blog-comment","client_id":"Ov23libVrm4js5jotUI4","client_secret":"ab2e3a6d1daa72bfcb968ff049246f8df2ce8988","admin_user":"winsoft666","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"886062b2ef7ae0d5819b2b3fe15744dc"}</script>
<script src="/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
