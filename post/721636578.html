<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Windows注入与拦截(2)--DLL注入的方式 - CodeSilo</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="CodeSilo"><meta name="msapplication-TileImage" content="img/pi-200.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="CodeSilo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="200x200" href="img/pi-200.png"><meta name="description" content="一、使用注册表方式注入1.1 注入方法如题，通过注册表的方式来实现 DLL 注入，我们只需要针对特定的注册表项进行修改即可，有一点需要注意的是：如果被注入的进程是 64 位进程，则注入的 DLL 也需要是 64 位的，同理，注入 32 位的进程也需要是 32 位的 DLL。 另外，根据被注入进程的位数（32 或 64）不同，注册表的位置也不同。"><meta property="og:type" content="blog"><meta property="og:title" content="Windows注入与拦截(2)--DLL注入的方式"><meta property="og:url" content="https://jiangxueqiao.com/post/721636578.html"><meta property="og:site_name" content="CodeSilo"><meta property="og:description" content="一、使用注册表方式注入1.1 注入方法如题，通过注册表的方式来实现 DLL 注入，我们只需要针对特定的注册表项进行修改即可，有一点需要注意的是：如果被注入的进程是 64 位进程，则注入的 DLL 也需要是 64 位的，同理，注入 32 位的进程也需要是 32 位的 DLL。 另外，根据被注入进程的位数（32 或 64）不同，注册表的位置也不同。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jiangxueqiao.com/img/og_image.png"><meta property="article:published_time" content="2021-05-02T01:41:58.000Z"><meta property="article:modified_time" content="2023-09-27T06:05:01.176Z"><meta property="article:author" content="江雪桥"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://jiangxueqiao.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jiangxueqiao.com/post/721636578.html"},"headline":"Windows注入与拦截(2)--DLL注入的方式","image":["https://jiangxueqiao.com/img/og_image.png"],"datePublished":"2021-05-02T01:41:58.000Z","dateModified":"2023-09-27T06:05:01.176Z","author":{"@type":"Person","name":"江雪桥"},"publisher":{"@type":"Organization","name":"CodeSilo","logo":{"@type":"ImageObject","url":"https://blog-static.jiangxueqiao.com/blog/icarus-theme/codesilo.png"}},"description":"一、使用注册表方式注入1.1 注入方法如题，通过注册表的方式来实现 DLL 注入，我们只需要针对特定的注册表项进行修改即可，有一点需要注意的是：如果被注入的进程是 64 位进程，则注入的 DLL 也需要是 64 位的，同理，注入 32 位的进程也需要是 32 位的 DLL。 另外，根据被注入进程的位数（32 或 64）不同，注册表的位置也不同。"}</script><link rel="canonical" href="https://jiangxueqiao.com/post/721636578.html"><link rel="icon" href="https://blog-static.jiangxueqiao.com/blog/icarus-theme/favicon.png"><link rel="stylesheet" href="https://blog-static.jiangxueqiao.com/blog/icarus-theme/js/all.min.css"><link rel="stylesheet" href="https://blog-static.jiangxueqiao.com/blog/icarus-theme/js/highlight.js/11.7.0/styles/xt256.css"><link rel="stylesheet" href="https://blog-static.jiangxueqiao.com/blog/icarus-theme/font/css2/Oxanium-Roboto-Mono.css"><link rel="stylesheet" href="/css/cyberpunk.css"><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?fbb46283a7b4d42d425356f8779708d5";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://blog-static.jiangxueqiao.com/blog/icarus-theme/js/lightgallery/1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://blog-static.jiangxueqiao.com/blog/icarus-theme/js/justifiedGallery/3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://blog-static.jiangxueqiao.com/blog/icarus-theme/js/pace-js/1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://blog-static.jiangxueqiao.com/blog/icarus-theme/codesilo.png" alt="CodeSilo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">时间轴</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="https://jiangxueqiao.com/post/2185937873.html">留言</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Email" href="mailto:smart7178@163.com"><i class="fa fa-envelope"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/winsoft666"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-02T01:41:58.000Z" title="2021/5/2 09:41:58">2021-05-02</time>发表</span><span class="level-item"><time dateTime="2023-09-27T06:05:01.176Z" title="2023/9/27 14:05:01">2023-09-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/">① 专栏集锦</a><span> / </span><a class="link-muted" href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8B%A6%E6%88%AA/">Windows注入与拦截</a></span><span class="level-item twikoo_visitors" id="/post/721636578.html" data-flag-title="Windows注入与拦截(2)--DLL注入的方式"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="twikoo_visitors"><i class="fa fa-spinner fa-spin"></i></span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Windows注入与拦截(2)--DLL注入的方式</h1><div class="content"><h1 id="一、使用注册表方式注入"><a href="#一、使用注册表方式注入" class="headerlink" title="一、使用注册表方式注入"></a>一、使用注册表方式注入</h1><h2 id="1-1-注入方法"><a href="#1-1-注入方法" class="headerlink" title="1.1 注入方法"></a>1.1 注入方法</h2><p>如题，通过注册表的方式来实现 DLL 注入，我们只需要针对特定的注册表项进行修改即可，有一点需要注意的是：<strong>如果被注入的进程是 64 位进程，则注入的 DLL 也需要是 64 位的，同理，注入 32 位的进程也需要是 32 位的 DLL。</strong></p>
<p>另外，根据被注入进程的位数（32 或 64）不同，注册表的位置也不同。</p>
<span id="more"></span>

<h3 id="1-1-1-注入-64-位系统上的-32-位进程"><a href="#1-1-1-注入-64-位系统上的-32-位进程" class="headerlink" title="1.1.1 注入 64 位系统上的 32 位进程"></a>1.1.1 注入 64 位系统上的 32 位进程</h3><ol>
<li>将被注入的 DLL 名称填入到<code>AppInit_DLLs</code>注册表项：</li>
</ol>
<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>AppInit_DLLs</code>中的文件名通过逗号或空格来分割，所以我们在文件名中要避免使用空格。另外<code>AppInit_DLLs</code>中的第一个文件可以包含路径，而后面的文件的路径则将被忽略。出于这个原因，我们最好将 DLL 文件放到 Windows 的系统目录中。</p>
</blockquote>
<ol start="2">
<li>并将<code>LoadAppInit_DLLs</code>注册表项的值修改为<code>1</code>：</li>
</ol>
<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-1-2-注入-64-位进程"><a href="#1-1-2-注入-64-位进程" class="headerlink" title="1.1.2 注入 64 位进程"></a>1.1.2 注入 64 位进程</h3><p>“注入到 64 位进程”和“注入 64 位系统上的 32 位进程”的步骤类似，区别在于：</p>
<p>1). 注册表位置不一样，注入 64 位进程的注册表分别位于：</p>
<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs</span><br></pre></td></tr></tbody></table></figure>

<p>2). 被注入 DLL 需要是 64 位版本。</p>
<h2 id="1-2-为什么可以这么做？"><a href="#1-2-为什么可以这么做？" class="headerlink" title="1.2 为什么可以这么做？"></a>1.2 为什么可以这么做？</h2><p>当系统的<code>User32.dll</code>被加载到一个新的进程时，会收到<code>DLL_PROCESS_ATTACH</code>通知，<code>User32.dll</code>在该通知处理过程中读取<code>AppInit_DLLs</code>注册表值，并调用<code>LoadLibrary</code>来加载该项中指定的每个 dll。</p>
<h2 id="1-3-这么做有什么弊端？"><a href="#1-3-这么做有什么弊端？" class="headerlink" title="1.3 这么做有什么弊端？"></a>1.3 这么做有什么弊端？</h2><p>从上面一节我们知道被注入的 DLL 是通过<code>User32.dll</code>加载到目标进程中去的，这也就要求被注入的目标进程必须使用了<code>User32.dll</code>，基于 GUI 的程序都会使用这个 DLL 文件，而命令行程序一般不会加载<code>User32.dll</code>，所以无法通过这种方式被注入。</p>
<p>系统上所有使用了<code>User32.dll</code>的程序都会被注入，很多时候这也并不是我们想要的。</p>
<h1 id="二、使用钩子方式注入"><a href="#二、使用钩子方式注入" class="headerlink" title="二、使用钩子方式注入"></a>二、使用钩子方式注入</h1><h2 id="2-1-钩子技术介绍"><a href="#2-1-钩子技术介绍" class="headerlink" title="2.1 钩子技术介绍"></a>2.1 钩子技术介绍</h2><p>Windows 提供了 3 个 API 让我们可以很方便使用钩子技术将 DLL 文件注入到进程之中：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装指定消息类型的钩子到钩子链中</span></span><br><span class="line"><span class="function">HHOOK <span class="title">SetWindowsHookEx</span><span class="params">(<span class="type">int</span> idHook,</span></span></span><br><span class="line"><span class="params"><span class="function">    HOOKPROC lpfn,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hMod,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从钩子链中删除钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnhookWindowsHookEx</span><span class="params">(HHOOK hhk</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将消息转发到钩子链上的下一个钩子</span></span><br><span class="line"><span class="function">LRESULT <span class="title">CallNextHookEx</span><span class="params">(HHOOK hhk,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCode,</span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>Hook</code>中文名“钩子”，我们可以把它想象成一个“鱼钩”，用来钩住指定类型的消息。“钩子”可以指定需要钩住哪个线程的消息，可以是当前线程，也可以是所有线程。</p>
<p>当“指定线程”的“指定消息”被钩住时，系统就会将我们的 DLL（如果钩子的处理过程位于 DLL 中）加载到该线程所属进程的地址空间中，并且在该地址空间中调用我们的 DLL 中的钩子处理过程函数，从而实现了注入功能。</p>
<p>我们通过<code>SetWindowsHookEx</code>函数来安装一个钩子，操作系统同时也允许开发人员为“同一个线程”的“同一个消息类型”指定多个钩子，这样就形成了一个<code>“钩子链”</code>（<code>Hook Chain</code>）。</p>
<h3 id="2-1-1-SetWindowsHookEx"><a href="#2-1-1-SetWindowsHookEx" class="headerlink" title="2.1.1 SetWindowsHookEx"></a>2.1.1 SetWindowsHookEx</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HHOOK <span class="title">SetWindowsHookExA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] <span class="type">int</span>       idHook,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HOOKPROC  lpfn,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HINSTANCE hmod,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD     dwThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>idHook参数</code>：指定我们需要勾住的消息类型；<br><code>lpfn参数</code>：函数指针。当 idHook 指定的消息触发时，系统将会调用 lpfn 函数指针。<br><code>hMod参数</code>：lpfn 函数指针所在 DLL 的句柄。有 2 种情况下这个参数需要传 NULL：</p>
<ol>
<li>lpfn 函数的代码位于本进程内时。</li>
<li>只需要勾住本进程的消息时，即 dwThreadId 参数指定的线程位于当前进程。</li>
</ol>
<p><code>dwThreadId参数</code>：线程 ID，用于指定勾住哪个线程的消息。如果传 0，则表示勾住所有线程的指定消息。</p>
<blockquote>
<p>SetWindowsHookEx 详细的参数解释可以参考 MSDN：<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644990(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms644990(v=vs.85).aspx</a></p>
</blockquote>
<h3 id="2-1-2-CallNextHookEx"><a href="#2-1-2-CallNextHookEx" class="headerlink" title="2.1.2 CallNextHookEx"></a>2.1.2 CallNextHookEx</h3><p>当我们的钩子处理函数将消息处理完之后，我们可以选择将消息丢弃，不让钩子链上的后面的钩子处理；也可以选择将消息继续传递下去，从而让其他钩子有处理的机会。</p>
<p>如果需要让其他钩子有处理的机会，我们可以在钩子处理函数的最后调用<code>CallNextHookEx</code>函数。</p>
<h3 id="2-1-3-UnhookWindowsHookEx"><a href="#2-1-3-UnhookWindowsHookEx" class="headerlink" title="2.1.3 UnhookWindowsHookEx"></a>2.1.3 UnhookWindowsHookEx</h3><p><code>UnhookWindowsHookEx</code>函数用于将指定钩子从钩子链中移除。</p>
<p>即使不调用<code>UnhookWindowsHookEx</code>，在调用<code>SetWindowsHookEx</code>的进程退出后，钩子也将被自动移除。</p>
<h2 id="2-2-钩子实例"><a href="#2-2-钩子实例" class="headerlink" title="2.2 钩子实例"></a>2.2 钩子实例</h2><p><code>SetWindowsHookEx</code>函数返回一个<code>HHOOK</code>类型的钩子句柄，<code>CallNextHookEx</code>和<code>UnhookWindowsHookEx</code>函数都需要使用这个句柄作为参数。</p>
<p>如果我们将“注入逻辑”放在独立的 exe 中，将“钩子处理过程”放到独立的 dll 中，那么为了在“钩子处理过程”中调用<code>CallNextHookEx</code>时能够拿到钩子的句柄，我们需要通过其他途径将该句柄从 exe 传递到 dll 中。</p>
<p>所以为了避免传递“钩子句柄”的麻烦，我们将“注入逻辑”和“钩子处理过程”都写入到一个 DLL 之中。我们只需要调用这个 DLL 的导出函数就可以将这个 DLL 注入到指定线程所属的进程中。</p>
<p>示例 DLL 名称为<code>InjectDLL</code>，用于勾住指定窗口的<code>WH_GETMESSAGE</code>消息，我们也可以指定其他的消息类型，如键盘消息等。完整的消息类型可以参考 MSDN 上关于<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644990(v=vs.85).aspx">SetWindowsHookEx</a>函数的解释。</p>
<p><code>InjectDLL</code>的完整代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HHOOK g_hook = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved)</span> </span>{</span><br><span class="line">    <span class="keyword">switch</span>(fdwReason) {</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提权函数</span></span><br><span class="line"><span class="comment">// 参考：https://blog.csdn.net/china_jeffery/article/details/79173417</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">BOOL <span class="title">EnablePrivilege</span><span class="params">(LPCTSTR szPrivilege, BOOL fEnable)</span> </span>{</span><br><span class="line">  BOOL fOk = FALSE;</span><br><span class="line">  HANDLE hToken = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) {</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, szPrivilege, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line">    tp.Privileges-&gt;Attributes = fEnable ? SE_PRIVILEGE_ENABLED : <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tp, <span class="built_in">sizeof</span>(TOKEN_PRIVILEGES), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fOk = (<span class="built_in">GetLastError</span>() == ERROR_SUCCESS);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fOk;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 钩子处理过程</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">HookProc_GetMsg</span><span class="params">(<span class="type">int</span> code, WPARAM wParam, LPARAM lParam)</span> </span>{</span><br><span class="line">  <span class="type">char</span> szMsg[<span class="number">512</span>] = { <span class="number">0</span> };</span><br><span class="line">  <span class="built_in">sprintf_s</span>(szMsg, <span class="number">512</span>, <span class="string">"code: %d, wParam: %d, lParam: %d"</span>, code, wParam, lParam);</span><br><span class="line">  <span class="built_in">OutputDebugStringA</span>(szMsg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">CallNextHookEx</span>(g_hook, code, wParam, lParam);;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出函数，安装钩子</span></span><br><span class="line"><span class="function">HHOOK <span class="title">InjectDllByHook</span><span class="params">(HWND hwnd)</span> </span>{</span><br><span class="line">  DWORD dwThreadId = <span class="number">0</span>;</span><br><span class="line">  HHOOK hHook = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  __try {</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">EnablePrivilege</span>(SE_DEBUG_NAME, TRUE)) {</span><br><span class="line">      __leave;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过窗口句柄获取到窗口所属线程</span></span><br><span class="line">    dwThreadId = <span class="built_in">GetWindowThreadProcessId</span>(hwnd, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (dwThreadId == <span class="number">0</span>) {</span><br><span class="line">      __leave;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取DLL自身的句柄</span></span><br><span class="line">    HMODULE hModule = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">GetModuleHandleExW</span>(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,</span><br><span class="line">      (LPCWSTR)InjectDllByHook, &amp;hModule);</span><br><span class="line"></span><br><span class="line">    hHook = <span class="built_in">SetWindowsHookEx</span>(WH_GETMESSAGE, (HOOKPROC)HookProc_GetMsg, hModule, dwThreadId);</span><br><span class="line">  }</span><br><span class="line">  __finally {</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (hHook);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出函数，卸载钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">EjectDllByHook</span><span class="params">(HHOOK hook)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">UnhookWindowsHookEx</span>(hook);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以直接调用该 DLL 的导出函数<code>InjectDllByHook</code>，实现 Hook 指定窗口（也可以改成线程，因为<code>InjectDllByHook</code>函数内部也是通过窗口查找到对应线程的）的指定消息。当指定的消息类型被勾住时，我们的 DLL 也就被加载到了该窗口所属的进程地址空间了，从而实现了注入。</p>
<h1 id="三、使用远程线程方式注入"><a href="#三、使用远程线程方式注入" class="headerlink" title="三、使用远程线程方式注入"></a>三、使用远程线程方式注入</h1><h2 id="3-1-远程线程注入原理"><a href="#3-1-远程线程注入原理" class="headerlink" title="3.1 远程线程注入原理"></a>3.1 远程线程注入原理</h2><p>“注册表注入方式”由于不能精确指定需要注入的进程，而且只能注入到 GUI 程序中，灵活性较差；“钩子注入方式”虽然能够精确指定注入的线程，但只能针对特定类型的消息进行 Hook，从而间接的实现注入，对于类似 windows 服务类的程序就束手无策了。</p>
<p>本节介绍的“远程线程的注入方式”是在实际中使用最为广泛的一种注入方式，它即可以精确指定需要注入的进程，又可以注入到非 GUI 程序中。</p>
<p>远程线程注入方式使用的关键 API 为<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682437(v=vs.85).aspx">CreateRemoteThread</a>，原型如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  HANDLE                 hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPSECURITY_ATTRIBUTES  lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  SIZE_T                 dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPVOID                 lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  DWORD                  dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_ LPDWORD                lpThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>CreateRemoteThread</code>的参数和我们平时创建本地线程使用的<code>CreateThread</code>的参数类似，新增了<code>hProcess</code>句柄参数用于指定在哪个进程创建远程线程，通过<code>OpenProcess</code>可以获取到进程句柄，但需要注意权限问题。</p>
<p><strong>通过远程线程方式实现 DLL 注入主要是在<code>lpStartAddress</code>和<code>lpParameter</code>这 2 个参数上面做文章。</strong><br><code>lpStartAddress</code>参数和<code>CreateThread</code>函数的一样，都是线程的处理过程函数，函数原型如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>我们知道加载 DLL 使用的 API 是<code>LoadLibraryA</code>或<code>LoadLibraryW</code>，原型如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMODULE WINAPI <span class="title">LoadLibrary</span><span class="params">(LPCTSTR lpFileName)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>对比<code>LoadLibrary</code>和线程处理函数(<code>LPTHREAD_START_ROUTINE</code>)的原型，我们发现两者的函数的原型基本相同。虽然不是完全相同，但都是接收一个指针参数，而且都是返回一个值，并且调用约定也都是<code>WINAPI</code>。</p>
<p>我们完全可以利用下它们之间的相似性，把线程处理函数的地址设为<code>LoadLibraryA</code>或<code>LoadLibraryW</code>，类似下面这样：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcessRemote,</span><br><span class="line">  <span class="literal">NULL</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  LoadLibraryA,</span><br><span class="line">  <span class="string">"C:\\InjectDll.dll"</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>当<code>CreateRemoteThread</code>创建的新线程在远程进程地址空间中被创建的时候，就会立即调用<code>LoadLibraryA</code>函数，并传入 DLL 路径的地址作为其参数。</strong></p>
<h2 id="3-2-注意事项"><a href="#3-2-注意事项" class="headerlink" title="3.2 注意事项"></a>3.2 注意事项</h2><p>按照上面的介绍的方法很容易就能实现远程线程注入，实际上也的确是很容易实现，只是还有 3 个地方需要注意：LoadLibrary 函数地址、DLL 路径字符串地址、取消注入。</p>
<h3 id="3-2-1-LoadLibrary-函数地址问题"><a href="#3-2-1-LoadLibrary-函数地址问题" class="headerlink" title="3.2.1 LoadLibrary 函数地址问题"></a>3.2.1 LoadLibrary 函数地址问题</h3><p>我们不能向上面的代码那样直接把<code>LoadLibraryA</code>或<code>LoadLibraryW</code>作为第 4 个参数传给<code>CreateRemoteThread</code>函数。这其中涉及模块的导入段等问题，如果在调用<code>CreateRemoteThread</code>时直接引用<code>LoadLibraryA</code>，则该引用会被解析为我们被注入 DLL 的导入段中的<code>LoadLibraryA</code>转换函数的地址，如果把这个转换函数的地址作为远程线程的起始地址传入，其结果很可能是访问违规。</p>
<p>为了强制代码略过转换函数并直接调用<code>LoadLibraryA</code>函数，我们必须通过 GetProcAddress 来得到<code>LoadLibraryA</code>的确切地址。如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HMODULE hKernel32 = <span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">"kernel32.dll"</span>));</span><br><span class="line">LPVOID pLoadLibraryAAddr = (LPVOID)<span class="built_in">GetProcAddress</span>(hKernel32, <span class="string">"LoadLibraryA"</span>);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-2-2-DLL-路径字符串地址问题"><a href="#3-2-2-DLL-路径字符串地址问题" class="headerlink" title="3.2.2 DLL 路径字符串地址问题"></a>3.2.2 DLL 路径字符串地址问题</h3><p>DLL 路径字符串<code>"C:\\InjectDll.dll"</code>的内存地址位于调用进程的地址空间中，并不位于被注入的进程的地址空间中。所以当<code>LoadLibraryA</code>用这个地址去被注入进程的地址空间中访问的时候，DLL 路径的字符串并不在那里，这很有可能导致远程线程访问违规。</p>
<blockquote>
<p>如果对进程的地址空间不了解，可以参考：- <a href="/post/3219980417.html" title="《Windows内存体系》">《Windows内存体系》</a>系列文章。</p>
</blockquote>
<p>为了解决这个问题，我们需要把 DLL 的路径字符串存储到被注入进程的地址空间中。Windows 提供的<code>VirtualAllocEx</code>函数可以实现在其他进程的地址空间中分配内存块。实现过程大致如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hTargeProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwProcessID); <span class="comment">// dwProcessID为被注入目标进程的进程ID</span></span><br><span class="line"><span class="keyword">if</span> (!hTargeProcess) {</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">SIZE_T dllPathSize = <span class="built_in">strlen</span>(pszDllPath); <span class="comment">// pszDllPath存储了DLL的路径</span></span><br><span class="line">pVM4DllPath = <span class="built_in">VirtualAllocEx</span>(hTargeProcess, <span class="literal">NULL</span>, dllPathSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (!pVM4DllPath) {</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hTargeProcess, pVM4DllPath, pszDllPath, dllPathSize, <span class="literal">NULL</span>)) {</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-2-3-取消注入问题"><a href="#3-2-3-取消注入问题" class="headerlink" title="3.2.3 取消注入问题"></a>3.2.3 取消注入问题</h3><p>取消注入就是将 DLL 从目标进程卸载，卸载 DLL 所用的 API 是<code>FreeLibrary</code>，但我们不能直接调用这个函数，因为直接调用的话是在我们的进程中卸载 DLL，而不是目标进程中卸载，很显然这样达不到卸载的目的。我们需要和加载 DLL 时一样，将<code>FreeLibrary</code>的地址作为第 4 个参数传给<code>CreateRemoteThread</code>函数，但同样需要通过<code>GetProcAddress</code>来得到<code>FreeLibrary</code>的确切地址：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">"Kernel32"</span>)), <span class="string">"FreeLibrary"</span>);</span><br><span class="line"><span class="keyword">if</span>(pfnThreadRtn) {</span><br><span class="line">    hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pfnThreadRtn, me.modBaseAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-3-实例"><a href="#3-3-实例" class="headerlink" title="3.3 实例"></a>3.3 实例</h2><p>本实例中的<code>InjectDllByRemoteThread</code>和<code>EjectDllByRemoteThread</code>两个函数使用远程线程的方式分别实现了注入和取消注入的功能。</p>
<h3 id="3-3-1-InjectDllByRemoteThread-函数"><a href="#3-3-1-InjectDllByRemoteThread-函数" class="headerlink" title="3.3.1 InjectDllByRemoteThread 函数"></a>3.3.1 InjectDllByRemoteThread 函数</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InjectDllByRemoteThread</span><span class="params">(DWORD dwProcessID, <span class="type">const</span> <span class="type">char</span>* pszDllPath)</span> </span>{</span><br><span class="line">  BOOL bRet = FALSE;</span><br><span class="line">  <span class="type">const</span> DWORD dwThreadSize = <span class="number">50</span> * <span class="number">1024</span>;</span><br><span class="line">  HANDLE hTargeProcess = <span class="literal">NULL</span>;</span><br><span class="line">  HANDLE hRemoteThread = <span class="literal">NULL</span>;</span><br><span class="line">  PVOID pVM4LoadLibrary = <span class="literal">NULL</span>;</span><br><span class="line">  PVOID pVM4DllPath = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  __try {</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">EnablePrivilege</span>(SE_DEBUG_NAME, TRUE)) {</span><br><span class="line">      __leave;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    hTargeProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwProcessID);</span><br><span class="line">    <span class="keyword">if</span> (!hTargeProcess) {</span><br><span class="line">      __leave;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    SIZE_T dllPathSize = <span class="built_in">strlen</span>(pszDllPath);</span><br><span class="line">    pVM4DllPath = <span class="built_in">VirtualAllocEx</span>(hTargeProcess, <span class="literal">NULL</span>, dllPathSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!pVM4DllPath) {</span><br><span class="line">      __leave;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hTargeProcess, pVM4DllPath, pszDllPath, dllPathSize, <span class="literal">NULL</span>)) {</span><br><span class="line">      __leave;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    HMODULE hKernel32 = <span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">"kernel32.dll"</span>));</span><br><span class="line">    LPVOID pLoadLibraryAAddr = (LPVOID)<span class="built_in">GetProcAddress</span>(hKernel32, <span class="string">"LoadLibraryA"</span>);</span><br><span class="line"></span><br><span class="line">    hRemoteThread = <span class="built_in">CreateRemoteThread</span>(hTargeProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (<span class="built_in">DWORD</span>(WINAPI *)(LPVOID))pLoadLibraryAAddr, pVM4DllPath, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hRemoteThread) {</span><br><span class="line">      __leave;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hRemoteThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    DWORD dwExitCode = <span class="number">0</span>;</span><br><span class="line">    BOOL B = <span class="built_in">GetExitCodeThread</span>(hRemoteThread, &amp;dwExitCode);</span><br><span class="line"></span><br><span class="line">    bRet = TRUE;</span><br><span class="line">  }</span><br><span class="line">  __finally {</span><br><span class="line">    <span class="keyword">if</span> (hTargeProcess &amp;&amp; pVM4DllPath) {</span><br><span class="line">      <span class="built_in">VirtualFreeEx</span>(hTargeProcess, pVM4DllPath, dwThreadSize, MEM_RELEASE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hRemoteThread) {</span><br><span class="line">      <span class="built_in">CloseHandle</span>(hRemoteThread);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hTargeProcess) {</span><br><span class="line">      <span class="built_in">CloseHandle</span>(hTargeProcess);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bRet;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-3-2-EjectDllByRemoteThread-函数"><a href="#3-3-2-EjectDllByRemoteThread-函数" class="headerlink" title="3.3.2 EjectDllByRemoteThread 函数"></a>3.3.2 EjectDllByRemoteThread 函数</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EjectDllByRemoteThread</span><span class="params">(DWORD dwProcessID, LPCWSTR pszDllPath)</span> </span>{</span><br><span class="line">    BOOL bOk = FALSE;</span><br><span class="line">    HANDLE hTHSnapshot = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>, hThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    __try {</span><br><span class="line">        hTHSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPMODULE, dwProcessID);</span><br><span class="line">        <span class="keyword">if</span>(hTHSnapshot == INVALID_HANDLE_VALUE) {</span><br><span class="line">            __leave;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        MODULEENTRY32W me = {<span class="built_in">sizeof</span>(me)};</span><br><span class="line">        BOOL bFound = FALSE;</span><br><span class="line">        BOOL bMoreMods = <span class="built_in">Module32FirstW</span>(hTHSnapshot, &amp;me);</span><br><span class="line">        <span class="keyword">for</span>(; bMoreMods; bMoreMods = <span class="built_in">Module32NextW</span>(hTHSnapshot, &amp;me)) {</span><br><span class="line">            bFound = (_wcsicmp(me.szModule, pszDllPath) == <span class="number">0</span>) ||</span><br><span class="line">                (_wcsicmp(me.szExePath, pszDllPath) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(bFound) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!bFound) {</span><br><span class="line">            __leave;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        hProcess = <span class="built_in">OpenProcess</span>(</span><br><span class="line">            PROCESS_QUERY_INFORMATION |</span><br><span class="line">            PROCESS_CREATE_THREAD |</span><br><span class="line">            PROCESS_VM_OPERATION,  <span class="comment">// For CreateRemoteThread</span></span><br><span class="line">            FALSE, dwProcessID);</span><br><span class="line">        <span class="keyword">if</span>(hProcess == <span class="literal">NULL</span>) {</span><br><span class="line">            __leave;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)</span><br><span class="line">            <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">"Kernel32"</span>)), <span class="string">"FreeLibrary"</span>);</span><br><span class="line">        <span class="keyword">if</span>(pfnThreadRtn == <span class="literal">NULL</span>) {</span><br><span class="line">            __leave;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pfnThreadRtn, me.modBaseAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(hThread == <span class="literal">NULL</span>) {</span><br><span class="line">            __leave;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">        bOk = TRUE;</span><br><span class="line">    }</span><br><span class="line">    __finally {</span><br><span class="line">        <span class="keyword">if</span>(hTHSnapshot != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">CloseHandle</span>(hTHSnapshot);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(hThread != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(hProcess != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(bOk);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-3-3-DllMain-函数"><a href="#3-3-3-DllMain-函数" class="headerlink" title="3.3.3 DllMain 函数"></a>3.3.3 DllMain 函数</h3><p>使用远程线程的方式进行 DLL 注入，我们一般在 DllMain 的<code>DLL_PROCESS_ATTACH</code>条件分支开始业务逻辑（通常会另外创建一个子线程，将业务逻辑放到子线程中处理），<code>DLL_PROCESS_DETACH</code>条件分支出结束业务逻辑。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved)</span> </span>{</span><br><span class="line">  HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(fdwReason) {</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        {</span><br><span class="line">      g_hDllModule = hModule;</span><br><span class="line">      <span class="comment">// 使用注册表方式和CreateRemoteThread方式注入时，一般在此处创建线程</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">      hThread = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, PluginProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">if</span> (hThread) {</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hThread); <span class="comment">// 关闭句柄，防止句柄泄漏</span></span><br><span class="line">      }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        {</span><br><span class="line">          <span class="comment">// 结束业务逻辑</span></span><br><span class="line">          <span class="comment">// ......</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</div><div class="article-licensing box"><div class="licensing-title"><p>Windows注入与拦截(2)--DLL注入的方式</p><p><a href="https://jiangxueqiao.com/post/721636578.html">https://jiangxueqiao.com/post/721636578.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>江雪桥</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-05-02</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-09-27</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/post/782629701.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">理解C/C++运行时库</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/1504192511.html"><span class="level-item">Windows注入与拦截(1)--DLL注入基础</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content twikoo" id="twikoo"></div><script src="https://blog-static.jiangxueqiao.com/blog/icarus-theme/js/twikoo/1.6.6/dist/twikoo.all.min.js"></script><script>twikoo.init({
            envId: 'https://twikoo.jiangxueqiao.com',
            
            lang: "zh-CN",
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://blog-static.jiangxueqiao.com/blog/icarus-theme/pi-200.png" alt="Jiang Xueqiao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Jiang Xueqiao</p><p class="is-size-6 is-block">Software Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Wuhan, Hubei</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">156</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">26</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">30</p></a></div></div></nav></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-26T11:07:09.000Z">2023-11-26</time></p><p class="title"><a href="/post/1533480858.html">Windows窗口调试利器-WinSpyPlus</a></p><p class="categories"><a href="/categories/%E2%91%A2-Power-By-Me/">③ Power By Me</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-26T09:39:23.000Z">2023-11-26</time></p><p class="title"><a href="/post/2510508225.html">Windows API的不同返回状态</a></p><p class="categories"><a href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/">① 专栏集锦</a> / <a href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/">Windows核心编程</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/post/711494356.html"><img src="https://blog-static.jiangxueqiao.com/blog/img/qt-logo.png" alt="Qt自定义和美化菜单"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-11-07T06:00:00.000Z">2023-11-07</time></p><p class="title"><a href="/post/711494356.html">Qt自定义和美化菜单</a></p><p class="categories"><a href="/categories/%E2%91%A1-C/">② C++</a> / <a href="/categories/%E2%91%A1-C/Qt/">Qt</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-02T05:45:13.000Z">2023-11-02</time></p><p class="title"><a href="/post/3832058229.html">为什么SetParent会失败</a></p><p class="categories"><a href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/">① 专栏集锦</a> / <a href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/">Windows核心编程</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-31T15:55:23.000Z">2023-10-31</time></p><p class="title"><a href="/post/2065788833.html">窗口如何逃脱显示桌面指令</a></p><p class="categories"><a href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/">① 专栏集锦</a> / <a href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/">Windows核心编程</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/"><span class="level-start"><span class="level-item">① 专栏集锦</span></span><span class="level-end"><span class="level-item tag">63</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E5%86%85%E5%AD%98%E4%BD%93%E7%B3%BB/"><span class="level-start"><span class="level-item">Windows内存体系</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E5%A5%97%E6%8E%A5%E5%AD%97I-O%E6%A8%A1%E5%9E%8B/"><span class="level-start"><span class="level-item">Windows套接字I/O模型</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">Windows核心编程</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/Windows%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8B%A6%E6%88%AA/"><span class="level-start"><span class="level-item">Windows注入与拦截</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/%E6%89%93%E5%8C%85%E7%8B%82%E9%AD%94%E4%B9%8BNSIS%E6%95%99%E7%A8%8B/"><span class="level-start"><span class="level-item">打包狂魔之NSIS教程</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/%E6%8B%A8%E5%BC%80%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%9A%84%E8%BF%B7%E9%9B%BE/"><span class="level-start"><span class="level-item">拨开字符编码的迷雾</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%A0-%E4%B8%93%E6%A0%8F%E9%9B%86%E9%94%A6/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"><span class="level-start"><span class="level-item">网络协议</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E2%91%A1-C/"><span class="level-start"><span class="level-item">② C++</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E2%91%A1-C/Qt/"><span class="level-start"><span class="level-item">Qt</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E2%91%A2-Power-By-Me/"><span class="level-start"><span class="level-item">③ Power By Me</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%A3-Electron/"><span class="level-start"><span class="level-item">④ Electron</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%A4-%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">⑤ 音视频编程</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E2%91%A4-%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B/WebRTC/"><span class="level-start"><span class="level-item">WebRTC</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E2%91%A5-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">⑥ 服务器开发</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%A6-%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95/"><span class="level-start"><span class="level-item">⑦ 软件调试</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%A7-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"><span class="level-start"><span class="level-item">⑧ 软件架构</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%A8-%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">⑨ 数据库</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%A9-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">⑩ 编程基础</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E2%91%A9-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/CMake/"><span class="level-start"><span class="level-item">CMake</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%A9-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%89%B9%E5%A4%84%E7%90%86/"><span class="level-start"><span class="level-item">批处理</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E2%91%AA-%E5%BC%80%E6%BA%90%E5%BA%93/"><span class="level-start"><span class="level-item">⑪ 开源库</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%AB-Web%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">⑫ Web开发</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%AC-%E7%BE%8E%E6%96%87%E8%B5%8F%E6%9E%90/"><span class="level-start"><span class="level-item">⑬ 美文赏析</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%AD-%E6%9D%82%E5%BF%B5/"><span class="level-start"><span class="level-item">⑭ 杂念</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E2%91%AE-%E7%88%B1%E6%8A%98%E8%85%BE/"><span class="level-start"><span class="level-item">⑮ 爱折腾</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、使用注册表方式注入"><span class="level-left"><span class="level-item">一、使用注册表方式注入</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-注入方法"><span class="level-left"><span class="level-item">1.1 注入方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-1-注入-64-位系统上的-32-位进程"><span class="level-left"><span class="level-item">1.1.1 注入 64 位系统上的 32 位进程</span></span></a></li><li><a class="level is-mobile" href="#1-1-2-注入-64-位进程"><span class="level-left"><span class="level-item">1.1.2 注入 64 位进程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-2-为什么可以这么做？"><span class="level-left"><span class="level-item">1.2 为什么可以这么做？</span></span></a></li><li><a class="level is-mobile" href="#1-3-这么做有什么弊端？"><span class="level-left"><span class="level-item">1.3 这么做有什么弊端？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二、使用钩子方式注入"><span class="level-left"><span class="level-item">二、使用钩子方式注入</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-钩子技术介绍"><span class="level-left"><span class="level-item">2.1 钩子技术介绍</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-1-SetWindowsHookEx"><span class="level-left"><span class="level-item">2.1.1 SetWindowsHookEx</span></span></a></li><li><a class="level is-mobile" href="#2-1-2-CallNextHookEx"><span class="level-left"><span class="level-item">2.1.2 CallNextHookEx</span></span></a></li><li><a class="level is-mobile" href="#2-1-3-UnhookWindowsHookEx"><span class="level-left"><span class="level-item">2.1.3 UnhookWindowsHookEx</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-2-钩子实例"><span class="level-left"><span class="level-item">2.2 钩子实例</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、使用远程线程方式注入"><span class="level-left"><span class="level-item">三、使用远程线程方式注入</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-远程线程注入原理"><span class="level-left"><span class="level-item">3.1 远程线程注入原理</span></span></a></li><li><a class="level is-mobile" href="#3-2-注意事项"><span class="level-left"><span class="level-item">3.2 注意事项</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-2-1-LoadLibrary-函数地址问题"><span class="level-left"><span class="level-item">3.2.1 LoadLibrary 函数地址问题</span></span></a></li><li><a class="level is-mobile" href="#3-2-2-DLL-路径字符串地址问题"><span class="level-left"><span class="level-item">3.2.2 DLL 路径字符串地址问题</span></span></a></li><li><a class="level is-mobile" href="#3-2-3-取消注入问题"><span class="level-left"><span class="level-item">3.2.3 取消注入问题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-3-实例"><span class="level-left"><span class="level-item">3.3 实例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-3-1-InjectDllByRemoteThread-函数"><span class="level-left"><span class="level-item">3.3.1 InjectDllByRemoteThread 函数</span></span></a></li><li><a class="level is-mobile" href="#3-3-2-EjectDllByRemoteThread-函数"><span class="level-left"><span class="level-item">3.3.2 EjectDllByRemoteThread 函数</span></span></a></li><li><a class="level is-mobile" href="#3-3-3-DllMain-函数"><span class="level-left"><span class="level-item">3.3.3 DllMain 函数</span></span></a></li></ul></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://blog-static.jiangxueqiao.com/blog/icarus-theme/codesilo.png" alt="CodeSilo" height="28"></a><p class="is-size-7"><span class="is-size-7">© 2017~2023 江雪桥</span>  <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" style="color:#000">鄂ICP备2020015399号-6</a>  </p><p class="is-size-7">网站风格：<a target="_blank" rel="noopener" href="https://www.cyberpunk.net/gb/zh-cn/" style="color:#75d4ef">赛博朋克（cyberpunk）</a></p><p class="is-size-7">内容同步发布到以下站点：<a href="https://jiangxueqiao.com" style="color:#fc1e1e">jiangxueqiao.com</a>    <a target="_blank" rel="noopener" href="https://winsoft666.github.io" style="color:#fc1e1e">winsoft666.github.io</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/winsoft666"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://blog-static.jiangxueqiao.com/blog/icarus-theme/js/jquery/3.3.1/dist/jquery.min.js"></script><script src="https://blog-static.jiangxueqiao.com/blog/icarus-theme/js/moment/2.22.2/min/moment-with-locales.min.js"></script><script src="https://blog-static.jiangxueqiao.com/blog/icarus-theme/js/clipboard/2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://blog-static.jiangxueqiao.com/blog/icarus-theme/js/lightgallery/1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://blog-static.jiangxueqiao.com/blog/icarus-theme/js/justifiedGallery/3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://blog-static.jiangxueqiao.com/blog/icarus-theme/js/mathjax/2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>