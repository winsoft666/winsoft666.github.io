[{"title":"Modern CMake 简明教程（上）","url":"/post/3678619994.html","content":"CMake 是一个开源、跨平台的构建系统生成器（Build-system Generator）。\nCMake 是构建系统生成器，而不是构建系统，CMake 支持生成不同构建系统所支持的工程文件，如 Visual Studio，XCode，Makefile 等。\n本教程作为 CMake 的简明教程，不会事无巨细的讲述 CMake 的每一个语法，而是以实用为目的，介绍 CMake 的基础语法和常用指令。\n虽然只是简明教程，但通过本教程，你仍然可以掌握 CMake 的脉络，熟练应用 CMake 于项目中。\n\nModern CMakeCMake 距今已有 20 多年的历史，CMake 从 3.0 开始引入 Target 概念，有了 Target 和 Property 的定义，CMake 也就更加地现代化。\n我们将引入 Target 概念之前（也就是 3.0 之前）的 CMake 称之为老式 CMake，之后的称之为现代 CMake（Modern CMake）。\n现代 CMake 是围绕 Target 和 Property 来定义的，在现代 CMake 中不应该出现诸如下面的指令：\n\nadd_compile_options\ninclude_directories\nlink_directories\nlink_libraries\n\n因为这些指令都是目录级别的，在该目录（含子目录）上定义的所有目标都会继承这些属性，这样会导致出现很多隐藏依赖和多余属性的情况。\n我们最好直接针对 Target 进行操作，如：\nadd_executable(hello main.cpp)# 老式写法include_directories(./include)# 现代写法target_include_directories(hello PRIVATE ./include)\n\n本文讲述的知识点只适用于现代 CMake，让我们脱掉沉重的历史包袱，轻装上阵吧！\n基础概念所有的构建系统都需要通过某个入口点来定义项目（如 Visual Studio 的 .sln 文件），CMake 作为构建系统生成器也不例外，CMake 使用的是 CMakeLists.txt 的文件，该文件以 UTF-8 编码（也支持 UTF-8 BOM 文件头），其中存储了符合 CMake 语言规范的脚本代码。\n项目结构CMake 没有强制规定 CMakeLists.txt 文件的位置以及项目的目录结构，但目前大多数项目都会采用相似的目录结构。\n如果项目名称为 my_project，且该项目包含一个名为 lib 的库和一个名为 app 的程序，则目录结构通常如下面所示：\n- my_project  - .gitignore  - README.md  - LICENSE.md  - CMakeLists.txt  - cmake    - FindSomeLib.cmake    - something_else.cmake  - include    - my_project      - lib.h  - src    - CMakeLists.txt    - lib.cpp  - apps    - CMakeLists.txt    - app.cpp  - tests    - CMakeLists.txt    - testlib.cpp  - docs    - CMakeLists.txt  - extern    - googletest  - scripts    - helper.py\n\n当然，上面的名称并不是一成不变的，可以根据自己的喜好来定义，例如 my_project 可以是任意的项目名，如果不喜欢复数，可以将 tests 改成test，如果没有 python 代码，也可以移除 python 目录，cmake 目录则用于存放 CMake 辅助脚本。\n从上面的目录结构可以看到，CMakeLists.txt 文件分散在各个子目录中，但在 include 目录中没有 CMakeList.txt 文件，这样是为了防止暴露不必要的文件给库的使用者，因为 include 目录中存放的是库的头文件，在安装时通常都会将该目录拷贝到指定位置（如Linux系统的 &#x2F;usr&#x2F;include）。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;extern 目录用于存放第三方依赖库的源码，这些库可以通过 git submodule 的形式来管理，也可以直接将源码拷贝到此，并提交到项目 git 中。但无论使用哪种方式，依赖库最好能支持 CMake，这样可以方便的使用 add_subdirectory 命令将项目添加到工程中（如果你对 add_subdirectory 命令的具体用法还不了解，这没关系，现在你只需要知道该命令可以添加任何包含 CMakeLists.txt 的目录到项目中即可）。\n一个简单的示例在学习 CMake 之前，我们先将 CMake 玩起来。我们先从一个简单的示例开始，了解 CMake 的基本玩法。\n该示例是只包含一个 main.cpp 文件，我们期望编译该文件能生成 hello_cmake 程序。\n目录结构如下：\n- hello_cmake  - main.cpp  - CMakeLists.txt\n\nmain.cpp 文件的内容非常简单：\n#include &lt;stdio.h&gt;int main() &#123;    printf(&quot;hello cmake&quot;);    return 0;&#125;\n\nCMakeLists.txt 内容如下：\n# 设置 CMake 的最低版本cmake_minimum_required(VERSION 3.16)# 设置项目名称project (hello_cmake)# 添加一个名为 hello_cmake 的目标# 目标类型为可执行文件# 使用 main.cpp 来编译生成 hello_cmake 可执行文件（如hello_cmake.exe）add_executable(hello_cmake main.cpp)\n\n完成上面步骤，我们就可以使用 CMake GUI 或命令行（当然你需要提前安装 CMake，这不在本文的介绍范围之内）就可以生成相应的工程了。\n\n通过 CMake 命令行生成 Visual Studio 工程的命令如下：\ncmake.exe -G &quot;Visual Studio 15 2017&quot; -S .\\hello_cmake -B .\\hello_cmake\\build\n\n源码外构建我们通常会将构建目录指定到一个单独的子目录内，这个目录名称的通常是 build。如果不这样做，CMake 生成的工程文件和临时缓存文件会污染源码目录。这种方式有个学名叫“源码外构建” (out-of-source build)。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;使用源码外构建时，我们通常还会将 build 目录添加到 .gitignore 文件中。\n工作流程编写 CMake 脚本的基本流程如下：\n\n在脚本第一行使用 cmake_minimum_required 指定运行当前脚本所需的 CMake 最低版本。\n使用 project 指定项目名称。\n使用 add_executable 或 add_library 创建目标。\n为目标设置包含目录、链接库等属性（可选）。\n安装（可选）。\n\n编写完 CMake 脚本以后，就可以使用 CMake GUI 或命令行来生成对应的工程文件了。以 Visual Studio 为例，对于有 my_lib 库 和 app 应用程序的项目，CMake 会生成如下图所示的 5 个项目：\n\n下面介绍 CMake 自动生成的一些项目的作用：\n\n编译 ALL_BUILD 项目会自动编译除 INSTALL 项目外的所有项目。\n编译 INSTALL 项目会执行 CMake 脚本中指定的安装操作。\n编译 ZERO_CHECK 项目会再次执行 CMake 脚本，重新生成项目。因此若 CMake 脚本有更新，既可以使用 CMake 工具来重新生成项目，也可以是重新编译 ZERO_CHECK 项目。\n\n注释在 CMake 中使用 # 来声明单行注释，这是我们使用最多的注释方法。虽然也支持使用 #[[ ]] 来声明多行注释（也称块注释），但是使用的比较少，例如:\n#[[  这是多行注释也称块注释  你明白了吗？]]\n\nCMake最低版本cmake_minimum_required 是我们接触到第一个 CMake 指令，该指令用于指定编译该脚本所需的最低 CMake 版本。\n你可以在 CMakeList.txt 文件的第一行都使用该指令来指定运行当前脚本需要的最低 CMake 版本，但我们通常只需要在主 CMakeList.txt （何为主 CMakeList.txt？见下面的“项目名称”小节） 中的第一行使用该指令即可。\ncmake_minimum_required(VERSION &lt;min&gt;[...&lt;policy_max&gt;] [FATAL_ERROR])\n\n如果运行 CMake 的版本低于要求的版本，则将停止处理该脚本并返回错误。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;我们始终应该选择一个比编译器晚发布的 CMake 版本，因为只有这样，CMake 才能支持新的编译器选项。但最低版本不应低于 3.0，实际项目中通常最低版本不会低于 3.16（该版本于2020年09月15日发布），本教程也是以此为标准进行讲解的。\n项目名称使用 project 指定项目名称。\n项目名称区别于目标（Target）名称，以 Visual Studio 为例，project 指定的名称对应“解决方案名称”，而 add_executable 或 add_library 等指定的名称才对应具体项目名和生成的“目标文件名”。\n设置项目名称后，CMake 会自动定义一些变量（变量的具体用法会在稍后的“3.1 变量”小节进行介绍）。为了方便介绍各个变量的含义，假设我们是通过如下命令来运行 CMake 的:\ncmake.exe -G &quot;Visual Studio 15 2017&quot; -S D:\\hello_cmake -B D:\\hello_cmake\\build\n\n下面列举了一些 CMake 自动定义的变量：\n\nPROJECT_NAME项目名称，如 hello_cmake\nCMAKE_PROJECT_NAME如果 CMakeLists.txt 位于项目的顶级目录，还会定义 CMAKE_PROJECT_NAME 变量，值与 PROJECT_NAME 一致。\nPROJECT_SOURCE_DIR项目的根目录（绝对路径），即 -S 参数指定的目录，如 D:\\hello_cmake\n&lt;PROJECT-NAME&gt;_SOURCE_DIR值与 PROJECT_SOURCE_DIR 相同，只是变量名不同，如 hello_cmake_SOURCE_DIR  \nPROJECT_BINARY_DIR项目的构建目录（绝对路径），即 -B 参数指定的目录，如 D:\\hello_cmake\\build\n&lt;PROJECT-NAME&gt;_BINARY_DIR值与 PROJECT_BINARY_DIR 相同，只是变量名不同，如 hello_cmake_BINARY_DIR\n\n主CMakeLists.txt主 CMakeLists.txt 即项目根目录下的 CMakeLists.txt 文件。可以通过检查 CMAKE_PROJECT_NAME 与 PROJECT_NAME 变量是否相同来判断当前的 CMakeLists.txt 文件是否为主 CMakeLists.txt。\nif(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)endif()\n\n目标类型既然现代 CMake 是围绕目标（Target）工作的，Target 如此重要，那我们首先就需要创建一个 Target。\n在 C&#x2F;C++ 开发中，常见的 Target 类型有：可执行文件、静态库、动态库，CMake 还额外提供了一个 MODULE 类型。\n下面列举了不同类型的目标的创建方式。\n可执行文件使用 add_executable 指令可以创建可执行文件类型的目标。\nadd_executable(my_exe main.cpp)\n\n动态库和静态库通过为 add_library 指令指定不同的参数，可以创建动态库和静态库。\nadd_library(&lt;name&gt; [&lt;type&gt;] [EXCLUDE_FROM_ALL] &lt;sources&gt;...)\n\n# 动态库add_library(my_lib SHARED main.cpp)# 静态库add_library(my_lib STATIC main.cpp)\n\n我们也可以在 add_library 中不指定类型参数，改为通过设置 BUILD_SHARED_LIBS 变量来切换静态库和动态库。下面示例在脚本中设置了 BUILD_SHARED_LIBS 变量值为 ON （ON &#x2F; OFF 对应 CMake 中的开&#x2F;关）：\ncmake_minimum_required(VERSION 3.16)project (hello_cmake)set(BUILD_SHARED_LIBS ON)add_library(hello_cmake main.cpp)\n\n也可以通过命令行参数进行指定 BUILD_SHARED_LIBS 变量：\ncmake.exe -G &quot;Visual Studio 15 2017&quot; -DBUILD_SHARED_LIBS=ON -S .\\hello_cmake -B .\\hello_cmake\\build\n\n亦可以在 GUI 界面上设置 BUILD_SHARED_LIBS 变量，如：\n\n基础语法变量变量的定义在 CMake 中使用 set 和 unset 命令来定义和取消定义变量。\nCMake 的变量没有类型一说，因为其变量值始终是字符串类型。\n基于上述原因，在 CMake 中不能直接使用 +、-、*、\\ 等操作符对变量进行数学运算，需要使用 math 指令，也不能直接使用 &gt;、&lt;、== 等操作符对变量进行逻辑运算，需要使用 LESS、EQUAL 进行判断，详见下面的“条件判断”章节。\nCMake 的变量名是大小写敏感的，而且其变量名不像其他语言那样有各种限制，它可以包含任何字符，如空格、问号等，但如果变量名中包含#（该符号用于行注释），则需要使用 \\# 进行转义。\n下面的语句都是合法的：\nset(abc 123)set(ABC &quot;123&quot;)set(&quot;ab c&quot; &quot;456&quot;)set(&quot;ab?c&quot; &quot;789&quot;)set(&quot;/usr/bin/bash&quot; &quot;987&quot;)set(&quot;C:\\\\Program Files\\\\&quot; &quot;654&quot;)set(&quot; &quot; &quot;321&quot;)set(\\# &quot;321&quot;)unset(a)\n\n虽然 CMake 允许变量名为任意字符串，但我们仍然建议在变量名称中仅包含字母、数字、- 和 _ ，而且字母为大写字母，如：\n# 建议的命名方式set(QT_VERSION &quot;5.15.2&quot;)set(LIB_NAME &quot;my_lib&quot;)\n\nCMake 还会保留一些标识符，我们在定义变量时尽量不要使用这些名称（你执意要用，CMake 也不会报错）：\n\n以 CMAKE_ 开头的。\n以 _CMAKE_ 开头的。\n以 _&lt;cmake command&gt; 开头的，如 _file，完整的 command 列表见：cmake-commands。\n\n在定义完变量以后，就可以通过 ${variable} 的形式进行引用了，如：\nset(QT_VERSION &quot;5.15.2&quot;)message(STATUS &quot;QT_VERSION is $&#123;QT_VERSION&#125;&quot;)\n\n在 CMake 中，还可以通过引用变量的方式来定义新的变量：\nset(a &quot;xyz&quot;)set(b &quot;$&#123;a&#125;_321&quot;)set($&#123;a&#125;_1 &quot;456&quot;)set(variable_$&#123;a&#125; &quot;$&#123;a&#125; + $&#123;b&#125; + 15&quot;)message(&quot;b: &#x27;$&#123;b&#125;&#x27;&quot;) # b: &#x27;xyz_321&#x27;message(&quot;xyz_1: &#x27;$&#123;xyz_1&#125;&#x27;&quot;) # xyz_1: &#x27;456&#x27;message(&quot;variable_xyz: &#x27;$&#123;variable_xyz&#125;&#x27;&quot;) # variable_xyz: &#x27;xyz + xyz_321 + 15&#x27;\n\n环境变量的引用方式有所不同，在下面的环境变量章节会详细介绍，而且在 if 条件中可以省略 ${}，直接使用变量名，如 if(QT_VERSION)。\nCMake 还允许使用未定义的变量，未定义的变量的值为空字符串。\nCMake 也允许重复定义变量，变量的值采用最后定义的值。\n调试输出message为了方便调试脚本，我们可以使用 messsage 指令来输出变量和调试信息。\nmessage([&lt;mode&gt;] &quot;message text&quot; ...)\n\n&lt;mode&gt; 关键字是可选的，它用于指定消息的类型，消息类型会影响 CMake 对该消息的处理方式。\n常用的消息类型有：\n\nFATAL_ERROR致命错误（红色），只有该类型会导致脚本终止执行。\nWARNING警告（红色），脚本继续执行。\nNOTICE（默认）需要特别关注的消息（红色），脚本继续执行。\nSTATUS普通输出，正常颜色，脚本也会继续执行。\n\nmessage(&quot;Current version is 1.0.0.1&quot;)message(STATUS &quot;BUILD_SHARED_LIBS value is $&#123;BUILD_SHARED_LIBS&#125;&quot;)\n\ncmake_print_variables如果只是单纯地想打印变量的值，使用 messsage 显得有些繁琐，我们可以使用 cmake_print_variables 函数来打印变量的值，该函数以 variable=value 格式输出每个变量的值，方便进行观察。\n由于该函数由 CMake 的 CMakePrintHelpers 模块提供，因此在使用之前，需要先 include(CMakePrintHelpers)：\ninclude(CMakePrintHelpers)set(MY_NAME &quot;jack&quot;)set(MY_ADDRESS &quot;Hubei&quot;)cmake_print_variables(MY_NAME MY_ADDRESS) # MY_NAME=&quot;jack&quot; ; MY_ADDRESS=&quot;Hubei&quot;\n\n列表列表就是简单地包含一系列值，使用空格分割每个值：\nset(MY_LIST a b &quot;c&quot; 1 2 $&#123;MY_NAME&#125; 3)\n\n也可以使用 ; 来代替空格：\nset(MY_LIST &quot;a;b;c;1;2;$&#123;MY_NAME&#125;;3&quot;)set(MY_LIST a;b;c;1;2;$&#123;MY_NAME&#125;;3)\n\nlist 命令list 命令提供了众多针对列表的操作，如获取元素个数、查找、添加、删除、排序等。\n# 获取元素个数list(LENGTH &lt;list&gt; &lt;out-var&gt;)# 获取指定下标（可以指定多个下标）的元素list(GET &lt;list&gt; &lt;element index&gt; [&lt;index&gt; ...] &lt;out-var&gt;)# 拼接2个列表list(JOIN &lt;list&gt; &lt;glue&gt; &lt;out-var&gt;)# 获取指定位置指定长度的一段列表list(SUBLIST &lt;list&gt; &lt;begin&gt; &lt;length&gt; &lt;out-var&gt;)# 查找，&lt;out-var&gt;中存储查找到的元素下标，如果没找到则为-1list(FIND &lt;list&gt; &lt;value&gt; &lt;out-var&gt;)# 在列表尾部添加若干元素list(APPEND &lt;list&gt; [&lt;element&gt;...])# 按条件过滤列表list(FILTER &lt;list&gt; &lt;INCLUDE|EXCLUDE&gt; REGEX &lt;regular_expression&gt;)# 在指定位置插入若干元素list(INSERT &lt;list&gt; &lt;index&gt; [&lt;element&gt;...])# 弹出尾部的若干元素（如果没有指定&lt;out-var&gt;变量，则只弹出一个）list(POP_BACK &lt;list&gt; [&lt;out-var&gt;...])# 弹出头部的若干元素（如果没有指定&lt;out-var&gt;变量，则只弹出一个）list(POP_FRONT &lt;list&gt; [&lt;out-var&gt;...])# 将若干元素插入到列表的头部，如果&lt;list&gt;没有被定义，则相当于创建了一个新的列表list(PREPEND &lt;list&gt; [&lt;element&gt;...])# 移除列表中的若干元素list(REMOVE_ITEM &lt;list&gt; &lt;value&gt;...)# 移除列表中指定位置（可以指定多个）的元素list(REMOVE_AT &lt;list&gt; &lt;index&gt;...)# 删除列表中的重复项目。保留项目的相对顺序，但如果遇到重复项，则仅保留第一个实例。list(REMOVE_DUPLICATES &lt;list&gt;)# 按照&lt;ACTION&gt;对列表元素进行转换list(TRANSFORM &lt;list&gt; &lt;ACTION&gt; [&lt;SELECTOR&gt;] [OUTPUT_VARIABLE &lt;output variable&gt;])# 列表反转list(REVERSE &lt;list&gt;)# 列表排序list(SORT &lt;list&gt; [COMPARE &lt;compare&gt;] [CASE &lt;case&gt;] [ORDER &lt;order&gt;])\n\n下面仅简单地演示 2 个列表功能的用法：\nset(NAME_LIST jack jim jeff tom)list(LENGTH NAME_LIST NAME_COUNT)message(STATUS &quot;name count: $&#123;NAME_COUNT&#125;&quot;) # name count: 4list(FIND NAME_LIST jim JIM_INDEX)message(STATUS &quot;jim at: $&#123;JIM_INDEX&#125;&quot;) # jim at: 1\n\n遍历列表可以使用 foreach 来遍历列表，下面示例演示了如何使用 foreach 遍历输出 MY_LIST 列表中每个元素，其中 _ITEM 变量的作用域仅限 foreach 代码块。\nset(MY_LIST hello world)foreach(_ITEM $&#123;MY_LIST&#125;)  message(STATUS &quot;$&#123;_ITEM&#125;&quot;)endforeach()\n\n我们还可以使用 while 来遍历列表，详见下面的“循环”章节。\n双引号的作用学习到这里，也许你会感到困扰，在定义变量时，为什么有时候使用双引号把值包围起来，有时候又不使用呢？\n我们已经学习完了列表的相关知识，现在就可以解释加不加引号的区别了。\n在定义变量时，若变量值中包含空格，此时不使用双引号包裹，则等同于定义列表；使用双引号包裹，则等同于定义字符串变量。\n# 定义的MY_VAR为列表，包含2个元素：hello、worldset(MY_VAR hello world)# 定义的MY_VAR为字符串set(MY_VAR &quot;hello world&quot;)\n\n对于列表类型的变量，在使用时是否使用双引号包裹也会有区别：有双引号包裹时，会将数组元素以分号作为分隔符进行拼接，否则会直接拼接各元素。\nset(MY_LIST hello world)message(STATUS &quot;$&#123;MY_LIST&#125;&quot;) # hello;worldmessage(STATUS $&#123;MY_LIST&#125;) # helloworld\n\n三种不同的变量CMake 中的变量分为普通变量、缓存变量和环境变量，三者都可以通过 set 指令进行定义。\n普通变量下面使用 set 定义的变量就是普通变量。\nset(MY_NAME &quot;jack&quot;)\n\n也可以在 CMake 命令行中通过 -D 参数定义普通变量，如下面示例定义了 BUILD_SHARED_LIBS 和 TEST 变量：\ncmake.exe -G &quot;Visual Studio 15 2017&quot; -DBUILD_SHARED_LIBS=ON -DTEST=123 -S .\\hello_cmake -B .\\hello_cmake\\build\n\n缓存变量缓存变量也是通过 set 指令定义的，但需要添加额外的参数：\nset(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])\n\n下面示例定义了一个名为 LIB_VERSION 的缓存变量：\ncmake_minimum_required(VERSION 3.16)set(LIB_VERSION &quot;1.0.0.1&quot; CACHE STRING &quot;the version of library&quot;)project (hello_cmake)add_library(hello_cmake main.cpp)message(STATUS &quot;LIB_VERSION = $&#123;LIB_VERSION&#125;&quot;)\n\n\n使用 CMake GUI 程序执行该脚本，可以看到界面上多出了一个名为 LIB_VERSION 的文本输入框，而且输入框有默认值 1.0.0.1。\n将输入框中的文本修改为 1.0.0.2，再次执行该脚本，可以发现调试输出的内容是 LIB_VERSION = 1.0.0.2，而且无论我们执行多少次脚本，始终输出的都是该内容。\n这是因为 CMake 会将缓存变量及其值存储到 “构建目录\\CMakeCache.txt” 文件中，下次运行脚本时，会优先从该文件中加载变量，该文件内容格式大致如下：\n# build\\CMakeCache.txt 文件......//the version of libraryLIB_VERSION:STRING=1.0.0.2......\n\n其中，&lt;type&gt; 用于指定变量的输入类型。请注意，&lt;type&gt; 指定的不是变量的类型，因为 CMake 的所有变量都是字符串类型。&lt;type&gt; 指定的是输入类型，仅用于帮助 CMake GUI 程序显示不同的用户输入控件，如文本输入框、复选框、文件选择对话框等。 \n&lt;type&gt; 的取值必须是下面列表中的一个：\n\nBOOL开关ON或OFF，在 CMake GUI 上提供一个复选框。\nPATH文件夹的路径，在 CMake GUI 上提供一个文本输入框和一个按钮来打开文件夹选择对话框。\nFILEPATH文件的路径，在 CMake GUI 上提供一个文本输入框和一个按钮来打开文件选择对话框。\nSTRING文本字符串，在 CMake GUI 上提供一个文本输入框。\nSTRINGS文本字符串，但在 CMake GUI 上会提供一个下拉列表选择框。\nINTERNAL虽然也是文本字符串，但不会显示在 CMake GUI 上，因此用户无法在界面上修改该变量的值。\n\n如果我们不希望某些缓存变量直接展示 CMake GUI 上，可以使用 mark_as_advanced 指令将缓存变量设置为高级状态，这样除非用户打开了 “Show Advanced” 选项，否则高级变量不会显示在 CMake GUI 中。在脚本模式下，高级&#x2F;非高级状态是无效的。\nset(DEBUG_LIBNAME_SUFFIX &quot;-d&quot; CACHE STRING &quot;Optional suffix to append to the library name for a debug build&quot;)mark_as_advanced(DEBUG_LIBNAME_SUFFIX)\n\noption虽然 option 也可用于定义缓存变量，但其只能定义“开&#x2F;关”类型的变量。\noption(ENABLE_TEST &quot;enable test or not&quot; ON)\n\n如果未指定初始值，默认为 OFF。\n环境变量环境变量的定义方式如下：\nset(ENV&#123;&lt;variable&gt;&#125; [&lt;value&gt;])\n\n环境变量在引用时，需要在前面添加 ENV 标识，如 $ENV{&lt;variable&gt;}\n示例：\nset(ENV&#123;USER_NAME&#125; &quot;jack&quot;)message(STATUS &quot;User name is $ENV&#123;USER_NAME&#125;&quot;)\n\nCMake 程序在启动时，会加载系统的环境变量，同时还会设置一些内置的环境变量，内置的环境变量见 cmake-env-variables。\nCMake 虽然会加载系统的环境变量，我们也可以修改该环境变量，但该修改操作不会影响到系统的环境变量。\n定义或加载的环境变量只会作用于当前的 CMake 进程，而且对当前进程所运行的所有脚本都可见，但不会影响到其他 CMake 进程和系统中的其他进程。\n变量作用域在上面介绍三种不同的变量时，我一直在竭力避免讨论一个话题，那就是变量的作用域。事实上，上面三种变量还有个不同之处就是作用域的不同。\n缓存变量和环境变量都是全局的，它们可以跨文件、目录、函数进行读写，因此作用域主要针对普通变量而言。\nCMake 中作用域分为“目录级别作用域”和“函数作用域”（也可以使用 block() 来显式的创建一个作用域，但这种使用方式非常少）。\n函数有自己的作用域，在函数中定义的变量只能在函数体中使用，函数体外无法访问。除非在定义变量时添加 PARENT_SCOPE 来将变量作用域设置为上一级目录。\ninclude使用 include 指令可以加载和执行其他 CMake 脚本文件（名称通常为 *.cmake），include 会在 CMAKE_MODULE_PATH 变量指定的目录列表中搜索指定文件。\n使用 include 指令加载cmake文件时，无需指定 .cmake 后缀，指定文件名即可，假设在 A（CMakeLists.txt或*.cmake）中调用 include(B) 加载 B.cmake ，则 A 和 B 之间可以相互读写彼此的变量（包含普通变量、缓存变量和环境变量）。\n当然，在 B.cmake 文件中也可以使用 include 指令加载执行其他的 cmake 文件。\nadd_subdirectory使用 add_subdirectory 指令可以添加一个子目录到项目构建中，但是被添加的子目录中必须包含 CMakeLists.txt 文件。\n假设在 A (CMakeLists.txt文件) 中调用 add_subdirectory(lib) 添加了 lib 子目录，则 lib 目录中的 CMakeLists.txt 可以读写 A 中的普通变量，但 A 不能读写 lib 目录 CMakeLists.txt 的普通变量。但可以在定义变量时添加 PARENT_SCOPE 选项来突破该限制，将变量作用域设置为上一级作用域，即父目录的作用域，如：\n# lib\\CMakeLists.txt 文件set(LIB_NAME &quot;MyTestLib&quot; PARENT_SCOPE)\n\nadd_subdirectory(lib)# 可以访问 LIB_NAME 变量message(STATUS &quot;$&#123;LIB_NAME&#125;&quot;)\n\n数学运算在前面章节已经提到了 CMake 中的值都是以字符串类型存储的，不能直接使用数学运算符符进行运算，需要使用 math 指令进行数学运算。\nmath 的语法如下：\nmath(EXPR &lt;variable&gt; &quot;&lt;expression&gt;&quot; [OUTPUT_FORMAT &lt;format&gt;])\n\n其中，&lt;variable&gt;变量如果没有定义，math 会自动定义该变量；\nOUTPUT_FORMAT 选项用于指定计算结果的进制（十六进制或十进制）：\n\nHEXADECIMAL  十六进制\nDECIMAL 十进制（默认）\n\nmath 支持如下运算符：\n+ - * / % | &amp; ^ ~ &lt;&lt; &gt;&gt;  (...)\n\n示例：\n# value 等于 &quot;300&quot;math(EXPR value &quot;100 * 3&quot;)# value 等于 &quot;1000&quot;math(EXPR value &quot;100 * 0xA&quot;)# value 等于 &quot;0x12c&quot;math(EXPR value &quot;100 * 3&quot; OUTPUT_FORMAT HEXADECIMAL)set(value 3)math(EXPR value &quot;100 * $&#123;value&#125;&quot;)   # value 等于 &quot;300&quot;# value 等于 &quot;306&quot;math(EXPR value &quot;(100 + 2) * 3&quot;)      \n\n\n条件判断在 CMake 中，使用 if 进行条件判断，语法如下：\nif(&lt;condition&gt;)  &lt;commands&gt;elseif(&lt;condition&gt;) # 可选的，可以有多个  &lt;commands&gt;else()              # 可选的  &lt;commands&gt;endif()\n\n与众多语言中的 if 一样，当括号中的条件为真时，才执行指定的 commands。\n示例：\nset(a 9)if(a LESS 10)    message(STATUS &quot;a &lt; 10&quot;)else()    message(STATUS &quot;a &gt;= 10&quot;)endif()\n\nelse() 和 endif() 括号中的内容可以为空，但如果需要指定，则就必须与 if 中的条件完全一致，如下面示例所示：\nset(a 9)if(a LESS 10)    message(STATUS &quot;a &lt; 10&quot;)else(a LESS 10)    message(STATUS &quot;a &gt;= 10&quot;)endif(a LESS 10)\n\n我们通常不在 else() 和 endif() 中指定条件，因为这样太繁琐了。\n真值与假值何为真，何为假，人生真真假假，难以分辨，程序的真假却清清楚楚。\n下列常量始终为真（不区分大小写）：\n\n1 和其他非零数字（包含浮点型），如 1、2、3.14\nON\nYES\nTRUE\nY\n\n下列常量始终为假（不区分大小写）：\n\n0\nOFF\nNO\nFALSE\nN\nIGNORE\nNOTFOUND\n空字符串\n被引号包裹的字符串（除始终为真的字符串外，如 TRUE、Y 等）\n\n逻辑运算符在 CMake 中，逻辑运算符的与、或、非分别使用 AND、OR、NOT 表示。\nif(NOT &lt;condition&gt;)if(&lt;cond1&gt; AND &lt;cond2&gt;)if(&lt;cond1&gt; OR &lt;cond2&gt;)if((condition) AND (condition OR (condition)))\n\n关系运算符由于 CMake 变量都是以字符串类型存储的，因此即便是数字也不能直接使用 &gt;、&lt;、== 这样的运算符来直接比较。\n针对数值类型，CMake 支持的关系运算符如下：\n\nLESS  小于\nLESS_EQUAL  小于等于\nGREATER  大于\nGREATER_EQUAL  大于等于\nEQUAL  等于\n\nCMake 还支持字符串比较，即从左到右依次比较字符串中的每个字符，出现不相同时立即返回，类似于 C 语言中的 strcmp 函数。\n\nSTRLESS  \nSTRLESS_EQUAL \nSTRGREATER \nSTRGREATER_EQUAL \nSTREQUAL\n\n存在性校验CMake 提供了一些判断变量是否定义、目标是否创建、元素是否存在于列表中、文件&#x2F;目录是否存在等方法。\n# 给定名称是否是可以调用的指令if(COMMAND &lt;command-name&gt;)# 给定名称是否是已创建的目标，即通过add_executable()、add_library() 或 add_custom_target() 命令创建if(TARGET &lt;target-name&gt;)# 给定名称的普通变量、缓存变量、环境变量是否已定义if(DEFINED &lt;name&gt;|CACHE&#123;&lt;name&gt;&#125;|ENV&#123;&lt;name&gt;&#125;)# 给定的元素是否包含在列表中if(&lt;variable|string&gt; IN_LIST &lt;variable&gt;)# 给定的文件或目录是否存在if(EXISTS &lt;path-to-file-or-directory&gt;)\n\n循环CMake 有两种循环方式：\n\nforeach  \nwhile\n\n二者都可以使用 break() 提前退出循环和 continue() 跳过本次循环。\nforeach下面是 foreach 的基本语法形式，这种形式在之前的“遍历列表”章节已经使用到了：\nforeach(&lt;loop_var&gt; &lt;items&gt;)  &lt;commands&gt;endforeach()\n\n示例：\nset(MY_LIST 1 2 3 4 5 6 7)foreach(_ITEM $&#123;MY_LIST&#125;)  message(STATUS &quot;$&#123;_ITEM&#125;&quot;)endforeach()\n\nforeach 还支持下面两种语法形式，这两种形式都不需要指定列表 &lt;items&gt; 参数，作用类似于 C 语言中的 for 语句：\n# 循环 [0 ~ &lt;stop&gt;]，步长为 1foreach(&lt;loop_var&gt; RANGE &lt;stop&gt;)# 循环 [&lt;start&gt; ~ &lt;stop&gt;]，步长为 &lt;step&gt;（可选）foreach(&lt;loop_var&gt; RANGE &lt;start&gt; &lt;stop&gt; [&lt;step&gt;])\n\n示例：\nforeach(_I RANGE 3)  message(STATUS &quot;$&#123;_I&#125;&quot;) # 依次输出 0 1 2 3endforeach()foreach(_I RANGE 2 5)  message(STATUS &quot;$&#123;_I&#125;&quot;) # 依次输出 2 3 4 5endforeach()foreach(_I RANGE 2 5 2)  message(STATUS &quot;$&#123;_I&#125;&quot;) # 依次输出 2 4endforeach()\n\nwhilewhile 的语法形式如下，其中 &lt;condition&gt; 为真时（参考 if 条件判断章节），执行代码块中的 commands 命令。\nwhile(&lt;condition&gt;)  &lt;commands&gt;endwhile()\n\n下面示例演示了如何使用 while 来遍历列表：\nset(MY_LIST 1 2 3)list(LENGTH MY_LIST LIST_COUNT)set(INDEX 0)while(INDEX LESS LIST_COUNT)  list(GET MY_LIST $&#123;INDEX&#125; VALUE) # 获取 $&#123;INDEX&#125; 位置的元素  message(STATUS &quot;element at $&#123;INDEX&#125; = $&#123;VALUE&#125;&quot;)  math(EXPR INDEX &quot;$&#123;INDEX&#125; + 1&quot;) # 自增 INDEXendwhile()\n\n上面示例依次输出如下内容：\nelement at 0 = 1element at 1 = 2element at 2 = 3\n\n\n函数和宏函数使用 function 定义函数：\nfunction(&lt;name&gt; [&lt;arg1&gt; ...])  &lt;commands&gt;endfunction()\n\n函数有自己的作用域，而宏没有自己的作用域，在函数体里面定义的普通变量默认只能在函数体中被访问，除非在定义时指定了 PARENT_SCOPE 选项，或者改为定义缓存变量、环境变量。\n函数在被调用时，函数名是不区分大小写的，如我们定义了名为 foo 的函数，就可以使用 foo()、Foo()、FOO() 等形式来调用，但我们还是建议保持与函数定义时的名称一致。\n参数关于函数的参数，我们可以在定义函数时就指定各个参数的名称，如：\nfunction(my_func NAME AGE)  message(STATUS &quot;name: $&#123;NAME&#125;&quot;) # name: jack   message(STATUS &quot;age: $&#123;AGE&#125;&quot;) # age: 18endfunction()my_func(&quot;jack&quot; 18)\n\n在调用函数时，调用参数（实参）的个数可以超过定义的参数个数（形参），但不能少于定义的参数个数，否则会报错。超出的参数，可以通过下面的形式获取：\n\n使用 ARGV0, ARGV1, ARGV2, ... 变量获取函数的每个参数。\n使用 ARGV 变量获取函数的参数列表，通过 ARGN 变量获取参数的个数。\n\n返回值使用 return() 可以从函数体中提前返回，但不能直接使用 return() 带出返回值，需要借用 set(&lt;variable&gt; &lt;value&gt; PARENT_SCOPE) 方式，来间接的带出返回值。\n下面示例演示了函数的定义、调用、参数的获取以及返回值的用法。\nfunction(my_func NAME AGE)  message(STATUS &quot;name: $&#123;NAME&#125;&quot;) # name: jack  message(STATUS &quot;parameter count: $&#123;ARGC&#125;&quot;) # parameter count: 3  message(STATUS &quot;parameter list: $&#123;ARGV&#125;&quot;) # parameter list: jack;18;Hubei  message(STATUS &quot;parameter 0: $&#123;ARGV0&#125;&quot;) # parameter 0: jack  message(STATUS &quot;parameter 2: $&#123;ARGV1&#125;&quot;) # parameter 2: Hubei  set(FUNC_RET &quot;OK&quot; PARENT_SCOPE)endfunction()my_func(&quot;jack&quot; 18 &quot;Hubei&quot;)message(STATUS &quot;return value: $&#123;FUNC_RET&#125;&quot;) # return value: OK\n\n但在实际项目中，除需要传入不定个数的参数情况外，我们通常在定义函数时，就约定好了参数名称和返回参数的名称，如下面示例：\nfunction(my_func NAME AGE OUT_RET)  # 使用 $&#123;NAME&#125; $&#123;AGE&#125; 访问参数  message(STATUS &quot;name: $&#123;NAME&#125;&quot;) # name: jack  set(OUT_RET &quot;OK&quot; PARENT_SCOPE)endfunction()my_func(&quot;jack&quot; 18 OUT_RET)message(STATUS &quot;return value: $&#123;OUT_RET&#125;&quot;) # return value: OK\n\n宏使用 macro 定义宏：\nmacro(&lt;name&gt; [&lt;arg1&gt; ...])  &lt;commands&gt;endmacro()\n\nCMake 中的宏和 C 语言中的宏一样，是在调用处进行语句替换后再执行，因此在宏中使用 return() 时要格外小心，可能会终止整个脚本的执行。\n建议优先使用函数。\n字符串操作字符串操作由 string 指令提供，详见官方文档。\n内置变量本节列举了在项目中经常用到的 CMake 内置变量。\n\nCMAKE_SOURCE_DIR始终存储的是项目的根目录。\n\nCMAKE_BINARY_DIR始终存储的是项目的根构建目录。\n\nPROJECT_SOURCE_DIR与 CMAKE_SOURCE_DIR 一样，也始终存储的是项目的根目录，但该变量需要使用 project 创建项目以后，才会被定义。\n\nPROJECT_BINARY_DIR与 CMAKE_BINARY_DIR 一样，也始终存储的是项目的构建目录，但该变量需要使用 project 创建项目以后，才会被定义。\n\nCMAKE_CURRENT_SOURCE_DIR存储的是当前正在执行脚本所在的目录。\n\nCMAKE_CURRENT_BINARY_DIR一个工程中可能包括多个项目，每个项目的构建目录不同，该变量存储的是当前项目的构建目录。\n\nCMAKE_CURRENT_LIST_FILE当前脚本代码所在文件的完整路径。\n\nCMAKE_CURRENT_LIST_LINE当前脚本代码所在行数。\n\nCMAKE_MODULE_PATH通过设置改变变量，可以控制 CMake 查找 .cmake 文件的路径，在使用 include 时就可以直接使用文件名了。如：\nset(CMAKE_MODULE_PATH &quot;$&#123;CMAKE_SOURCE_DIR&#125;/cmake&quot;)include(utils)\n\n需要注意的是，当在 include 中仅指定了文件名时，不能再添加 .cmake 扩展名，否则会导致查找不到相应文件。\n\nWIN32在 Windows 系统上，定义该变量，值为 1。\n\nAPPLE在 Apple 系统上，定义该变量，值为 1。\n\nUNIX在类 UNIX 系统上，定义该变量，值为 1。\n\nCMAKE_SYSTEM_NAME当前构建所选定目标系统，但该变量需要使用 project 创建项目以后，才会被定义。\n该变量常见的值有：Android、iOS、Linux、FreeBSD、MSYS、Windows、Darwin，完整的列表见：CMAKE_SYSTEM_NAME。\nif (CMAKE_SYSTEM_NAME STREQUAL &quot;Linux&quot;)  message(STATUS &quot;current platform: Linux &quot;)elseif (CMAKE_SYSTEM_NAME STREQUAL &quot;Windows&quot;)  message(STATUS &quot;current platform: Windows&quot;)elseif (CMAKE_SYSTEM_NAME STREQUAL &quot;FreeBSD&quot;)  message(STATUS &quot;current platform: FreeBSD&quot;)elseif (CMAKE_SYSTEM_NAME STREQUAL &quot;Darwin&quot;)  message(STATUS &quot;current platform: macOS&quot;)elseif (CMAKE_SYSTEM_NAME STREQUAL &quot;Android&quot;)  message(STATUS &quot;current platform: Android&quot;)elseif (CMAKE_SYSTEM_NAME STREQUAL &quot;iOS&quot;)  message(STATUS &quot;current platform: iOS&quot;)else ()  message(STATUS &quot;other platform: $&#123;CMAKE_SYSTEM_NAME&#125;&quot;)endif()\n\nMSVC当编译器是 Microsoft Visual C++ 的某个版本或模拟 Visual C++ cl 命令行语法的其他编译器时设置为 true。\n\nMSVC_VERSION正在使用的 Microsoft Visual C&#x2F;C++ 版本（如果有）。如果正在使用模拟 Visual C++ 的编译器，则此变量将设置为 _MSC_VER 预处理器定义所给定的模拟工具集版本。\n\n\n目标的属性属性调试在介绍如何设置目标的属性之前，我们先学习一下如何调试输出目标属性，方便在开发中检查属性设置是否出错。\n使用 CMakePrintHelpers 模块提供 cmake_print_properties 函数可以打印输出目标的属性，该函数的原型如下：\ncmake_print_properties(&lt;TARGETS       [&lt;target1&gt; ...] |                        SOURCES       [&lt;source1&gt; ...] |                        DIRECTORIES   [&lt;dir1&gt; ...]    |                        TESTS         [&lt;test1&gt; ...]   |                        CACHE_ENTRIES [&lt;entry1&gt; ...]  &gt;                       PROPERTIES [&lt;prop1&gt; ...]         )\n\n以打印输出目标的“包含目录”属性为例：\nadd_library(hello_cmake main.cpp)target_include_directories(hello_cmake PRIVATE &quot;include&quot;)include(CMakePrintHelpers)cmake_print_properties(TARGETS hello_cmake PROPERTIES INCLUDE_DIRECTORIES) \n\n输出： \nProperties for TARGET hello_cmake:  hello_cmake.INCLUDE_DIRECTORIES = &quot;D:/cmake-sample/hello_cmake/include&quot;\n\n包含目录使用 target_include_directories 指定目标包含一个或多个目录。指定的目录路径可以是绝对路径也可以是相对路径，如果是相对路径，则该路径是相对于当前脚本文件的。\ntarget_include_directories(&lt;target&gt; [SYSTEM] [AFTER|BEFORE]  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])\n\n这就相当于在 Visual Studio 中设置“附加包含目录”。\n\n可以针对一个目标重复调用 target_include_directories，会按照调用顺序依次附加包含目录，也可以使用 BEFORE 选项，将本次设置的包含目录插入到最前面。\n我们需要特别花精力理解 INTERFACE、PUBLIC、PRIVATE 三者的区别，这三者的区别，我们先按下不表，稍后介绍。\n在使用 PUBLIC、PRIVATE 设置包含目录时，会自动设置 INCLUDE_DIRECTORIES 属性；在使用 INTERFACE 设置包含目录时，会自动设置 INTERFACE_INCLUDE_DIRECTORIES 属性。\n示例：\ntarget_include_directories(hello_cmake \tPUBLIC &quot;include&quot;\tPRIVATE &quot;./extern/jsoncpp&quot;)target_include_directories(hello_cmake BEFORE\tPUBLIC &quot;include&quot;\tPRIVATE &quot;./extern/rpclib&quot;)\n\n预编译宏使用 target_compile_definitions 设置目标的预编译宏。\ntarget_compile_definitions(&lt;target&gt;  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])\n\n可以针对一个目标重复调用 target_compile_definitions，附加多个预编译宏。\n使用 PUBLIC、PRIVATE 设置包含目录时，会自动设置 COMPILE_DEFINITIONS 属性；使用 INTERFACE 设置包含目录时，会自动设置 INTERFACE_COMPILE_DEFINITIONS 属性。\n示例：\n# 定义2个预编译宏target_compile_definitions(hello_cmake\tPUBLIC USING_BOOST USING_THRIFT)# 再定义一个预编译宏target_compile_definitions(hello_cmake\tINTERFACE USING_ZLIB)\n\n依赖库使用 target_link_libraries 指令设置目标的依赖库，该指令有很多原型，但常用的原型有：\ntarget_link_libraries(&lt;target&gt;                     [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]                     [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)\n\nitem 可以是如下几种类型：\n\nlib 文件的绝对路径或相对路径，CMake 不会校验文件是否存在\n其他的 CMake 目标。\n表达式生成器（见“生成器表达式”章节）。\n以 - 开头的链接标志，但从 CMake 3.13 版本开始，可以直接使用 target_link_options() 替代。\n\n可以针对一个目标重复调用 target_link_libraries，附加多个依赖库。\n&lt;PRIVATE|PUBLIC|INTERFACE&gt; 可以省略，如果省略，则默认为 PUBLIC。\n使用 PUBLIC、PRIVATE 设置依赖库时，会自动设置 LINK_LIBRARIES 属性；使用 INTERFACE 设置依赖库时，会自动设置 INTERFACE_LINK_LIBRARIES 属性。\nINTERFACE、PUBLIC 和 PRIVATEINTERFACE、PUBLIC 和 PRIVATE 用于指定属性的可见性传递方案。\n\n\n\n目标类型\n可见性传递\n自身是否应用该属性\n使用者是否应用该属性\n\n\n\n可执行文件\nINTERFACE\n否\n否（可执行文件不存在使用者）\n\n\n可执行文件\nPUBLIC\n是\n否（可执行文件不存在使用者）\n\n\n可执行文件\nPRIVATE\n是\n否（可执行文件不存在使用者）\n\n\n库（动态或静态）\nINTERFACE\n否\n是\n\n\n库（动态或静态）\nPUBLIC\n是\n是\n\n\n库（动态或静态）\nPRIVATE\n是\n否\n\n\n编译和链接选项通过 target_compile_options 指令设置编译选项。\ntarget_compile_options(&lt;target&gt; [BEFORE]  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])\n\n通过 target_link_options 指令设置链接选项。\ntarget_link_options(&lt;target&gt; [BEFORE]  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])\n\n这两个指令的用法与前面介绍的 target_include_directories 类似。\n示例：\n# 编译选项target_compile_options(my_lib PRIVATE /utf8)# 链接选项target_link_options(app PRIVATE /NOLOGO)\n\n其他属性CMake 为目标还提供了其他属性，详见 target-properties ，总计约有 400 多个，涵盖了开发中会用到的绝大多数属性，例如其中以 VS_ 开头的属性是专门为 Visual Studio 所准备的。\n针对这些属性，需要使用 set_target_properties 指令进行设置。\n例如，使用 OUTPUT_NAME 和 DEBUG_OUTPUT_NAME 设置目标的输出文件名。\nset_target_properties(zoe PROPERTIES \tOUTPUT_NAME Zoe\tDEBUG_OUTPUT_NAME Zoe-d)\n","categories":["②跨平台编译与部署"],"tags":["CMake"]},{"title":"代码的隐形战场：Windows进程注入与API Hook完全指南","url":"/post/3573459553.html","content":"在数字时代的攻防战场上，Windows 注入与 Hook 技术如影随形，它们始终是开发者与安全研究员的“终极兵器库”。无论是逆向工程师通过动态调试破解加密算法，还是恶意软件通过进程注入窃取敏感信息，这项技术始终游走在合法与非法的灰色边缘。它既是系统底层机制的“潘多拉魔盒”，也是守护软件安全的“达摩克利斯之剑”——掌握它，你既能修复高危漏洞，也可能成为攻击者的帮凶。\n\n\n注册表方式注入这是一种最简单的注入方式，我们只需要开发正常的 DLL，然后在注册表AppInit_DLLs项中指定该 DLL 的名称，待系统User32.dll被加载到新进程时，该 DLL 也会被加载到目标进程。这是因为 User32.dll 会在 DLL_PROCESS_ATTACH 通知处理过程中读取该注册表值，并依次加载该项中的每个 DLL。\nAppInit_DLLs 注册表项的路径如下：\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\AppInit_DLLs\n\n如果是在 x64 系统上，将 32 位 DLL 注入到 32 位进程，需要使用Wow6432Node路径（下面的 LoadAppInit_DLLs 也是一样）：\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\AppInit_DLLs\n\nAppInit_DLLs 中的文件名通过逗号或空格来分割，因此在文件名中要避免使用空格。另外 AppInit_DLLs 中只有第一个文件可以包含路径，后面的文件的路径则将被忽略，出于这个原因，我们最好将 DLL 文件拷贝到 Windows 的系统目录中。\n一切准备妥当后，还需将 LoadAppInit_DLLs 注册表项的值修改为 1，路径如下：\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\LoadAppInit_DLLs\n\n这种注入方式虽然简单，但存在很大的弊端，因为 DLL 是通过 User32.dll 加载到目标进程中去的，这也就要求被注入的目标进程必须使用了 User32.dll，虽然基于 GUI 的程序都会使用这个 DLL 文件，但命令行程序一般不会加载 User32.dll，所以可能无法通过这种方式被注入。而且这种方式会导致系统上所有使用了 User32.dll 的程序都会被注入 DLL，很多时候这也并不是我们所期望的。\nDLL 欺骗注入我们在启动一个可执行程序时，操作系统会先为进程创建虚拟地址空间，然后把可执行模块映射到进程的地址空间中，之后会遍历导入段（即 PE 的导入表），定位所依赖的 DLL 并映射到该进程的地址空间中。由于导入段中只包含了 DLL 的名称，不包含 DLL 的路径，因此加载程序会按照如下顺序在磁盘上查找 DLL（优先级从高到低）：\n\n包含可执行文件的目录。\nWindows 系统目录，通常为 C:\\Windows\\System32，可以使用 GetSystemDirectory 函数获取。\nWindows 目录，通常为 C:\\Windows，可以使用 GetWindowsDirectory 函数获取。\n进程的当前工作目录。\nPATH 环境变量中所列出的目录。\n\n\n上面是程序启动时，操作系统查找程序依赖 DLL 的标准流程。在使用 LoadLibrary 加载 DLL 时，如果没有指定全路径，而是仅仅指定了文件名或相对路径，LoadLibrary 也会使用上面顺序进行搜索。但如果使用 SetDllDirectroy 函数设置了 DLL 搜索目录，或者使用 LoadLibraryEx 函数并设置了 LOAD_WITH_ALTERED_SEARCH_PATH 标志，此时程序搜索 DLL 的方式会与上面的标准搜索顺序所有不同，详见《Windows 核心编程》。\n\nDLL 欺骗注入也叫 DLL 劫持，就是在上面 DLL 的搜索路径中放入我们自己 DLL，来欺骗系统或应用进行加载。\n使用 Depends 工具查看程序依赖的 DLL，选择一个 DLL 来伪造。\n需要注意，HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs注册表中指定的 DLL 不能伪造。\n伪造 DLL 需要与原 DLL 的导出函数完全一致，并提供相同的功能，否则程序会加载失败或功能异常，因此我们在选择 DLL 时，尽量选择功能简单的 DLL，如 version.dll、hid.dll 等。\n编写伪造 DLL 的流程通常如下：\n\n在 DllMain 函数中加载原 DLL。\n通常在 DllMain 函数中还会执行相关逻辑，如 Hook 某个函数等（非必须）。\n使用函数转发器技术将导出函数的功能转发到跳板函数，并在跳板函数中调用原 DLL 中对应函数的功能，确保伪造 DLL 能够提供与原 DLL 一致的功能。\n\n上述操作是一件繁琐的、费时费力的事情，好在已有前辈开发了工具来根据原 DLL 自动生成相应的 VS 工程，下面是我修改后的版本，支持 x86 和 x64 架构：https://github.com/winsoft666/AheadLib\n消息钩子注入Windows 提供了 SetWindowsHookEx 函数来为指定线程安装一个消息钩子。当指定线程中的特定消息被钩住时，系统就会将我们的 DLL（前提是钩子的处理过程是位于 DLL 中的）加载到该线程所属进程的地址空间中，并且在该地址空间中调用我们的 DLL 中的钩子处理过程函数，从而实现 DLL 注入功能。\nHHOOK SetWindowsHookExA(  [in] int       idHook,  [in] HOOKPROC  lpfn,  [in] HINSTANCE hmod,  [in] DWORD     dwThreadId);\n\n操作系统同时允许开发人员为“同一个线程”的“同一个消息类型”指定多个钩子，这样就形成了一个“钩子链”（Hook Chain），当我们的钩子处理函数（由 lpfn 参数指定）将消息处理完之后，可以选择将消息丢弃，不让钩子链后面的钩子进行处理，也可以在钩子处理函数的最后调用 CallNextHookEx 函数，让消息继续传递下去，从而让其他钩子有处理的机会。\nSetWindowsHookEx 函数返回了HHOOK类型的钩子句柄，而且 CallNextHookEx 和 UnhookWindowsHookEx 函数都需要使用这个句柄作为参数。因此，如果我们将“注入逻辑”放在独立的 exe 中，将“钩子处理过程”放到独立的 dll 中，那么我们需要通过其他途径将该句柄从 exe 传递到 dll 中，确保在“钩子处理过程”中能够使用该句柄调用 CallNextHookEx。\n为了避免传递钩子句柄的麻烦，我们通常将注入、取消注入、钩子处理过程都写在一个 DLL 中。在 DLL 中导出开始和停止函数，外部程序调用这两个函数就可以实现注入和取消注入的功能了。\n远程线程注入注入原理远程线程注入方式使用的关键系统 API 为 CreateRemoteThread，原型如下：\nHANDLE WINAPI CreateRemoteThread(  _In_  HANDLE                 hProcess,  _In_  LPSECURITY_ATTRIBUTES  lpThreadAttributes,  _In_  SIZE_T                 dwStackSize,  _In_  LPTHREAD_START_ROUTINE lpStartAddress,  _In_  LPVOID                 lpParameter,  _In_  DWORD                  dwCreationFlags,  _Out_ LPDWORD                lpThreadId);\n\nCreateRemoteThread 相比 CreateThread 只是新增了 hProcess 句柄参数，该参数用于指定远程线程所在的目标进程。\n可以通过任意方式获取目标进程的句柄，但需要确保该句柄具有合适的访问权限，避免后续的函数调用失败，通常应具有如下权限，具体见 API 文档：\nPROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ\n\n通过远程线程方式实现 DLL 注入主要是在lpStartAddress和lpParameter这 2 个参数上面做文章。\nlpStartAddress 参数用于指定远程线程的处理过程函数，函数原型分别如下：\nDWORD WINAPI ThreadProc(LPVOID lpParameter);\n\n该函数原型与加载 DLL 所使用的 API（Kernel32::LoadLibraryA 或 Kernel32::LoadLibraryW）的原型基本相同：\nHMODULE WINAPI LoadLibrary(LPCTSTR lpFileName);\n\n虽然不是完全相同，但都是接收一个指针参数，返回一个值（在不同架构的软件中，返回值所占字节数有区别，见下面注解），并且调用约定也都是WINAPI。因此，我们可以利用它们之间的相似性，把线程处理函数的地址设为 LoadLibraryA 或 LoadLibraryW 的函数地址。\n\n在 32 位程序中，DWORD 和 HMODULE 都占 4 字节，而在 64 位程序中，DWORD 占 4 字节，HMODULE 占 8 字节。因此下面介绍的获取 DLL 句柄的方式只适用于 32 位程序。\n\n目标进程的 LoadLibrary 的地址是多少呢？\n通常来说，无论是否开启 ASLR（地址空间布局随机化），DLL 加载到目标进程的基地址都不会是固定的，因此模块中函数的地址也不是固定的。那么我们如何确定目标进程中的 Kernel32::LoadLibraryA 的地址呢？幸运的是，kernel32.dll、user32.dll、 ntdll.dll 等系统 DLL 在不同的进程中的基地址都是一样的，因此我们可以直接使用当前进程中的 LoadLibraryA 函数地址。\n\n下列系统 DLL 在所有进程中的基地址都是一样的：kernel32.dll、user32.dll、ntdll.dll、gdi32.dll、gdi32full.dll、comdlg32.dll、shell32.dll、advapi32.dll、msvcrt.dll​、ucrtbase.dll、ole32.dll、oleaut32.dll、rpcrt4.dll、ws2_32.dll、shcore.dll、imm32.dll、crypt32.dll\n\n但不能直接使用下面的方式来传递 LoadLibraryA 或 LoadLibraryW 的地址，因为直接使用 LoadLibraryA 会被解析为我们程序导入段中的 LoadLibraryA 转换函数的地址，这个转换函数的地址只在当前进程有效。\nCreateRemoteThread(hTargeProcess, NULL, 0, LoadLibraryA, ...);\n\n所以我们要通过 GetProAdress 方式获取 LoadLibraryA 地址：\nLPVOID pLoadLibraryAddr = (LPVOID)GetProcAddress(GetModuleHandle(TEXT(&quot;kernel32.dll&quot;)), &quot;LoadLibraryA&quot;);CreateRemoteThread(hTargeProcess, NULL, 0, pLoadLibraryAddr, ...);\n\n解决了 LoadLibraryA 函数地址的问题，再来解决 DLL 路径的问题。DLL 路径字符串（如”C:\\InjectDll.dll”）的内存地址位于调用进程的地址空间中，并不位于被注入的目标进程的地址空间中。所以，在目标进程中使用 LoadLibraryA 访问该地址时，会出现访问违规。\n为了解决这个问题，我们需要把 DLL 路径字符串存储到被注入进程的地址空间中。通过 Windows 提供的 VirtualAllocEx 和 WriteProcessMemory 函数，可以实现在目标进程地址空间中分配内存和写入内存。\nSIZE_T size = strlen(pszDllPath) + 1;LPVOID buffer = VirtualAllocEx(hTargeProcess, NULL, size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);if (buffer) &#123;    if (!WriteProcessMemory(hTargeProcess, buffer, pszDllPath, size, NULL)) &#123;        // ......    &#125;&#125;\n\n最后，调用 CreateRemoteThread 创建远程线程：\nLPVOID pLoadLibraryAddr = (LPVOID)GetProcAddress(GetModuleHandle(TEXT(&quot;kernel32.dll&quot;)), &quot;LoadLibraryA&quot;);HANDLE hDll = CreateRemoteThread(hTargeProcess,\tNULL,\t0,\tpLoadLibraryAddr,\tbuffer,\t0,\tNULL);\n\n当 CreateRemoteThread 所创建的线程在远程进程地址空间中被创建的时候，就会立即调用 LoadLibraryA 函数，并使用 DLL 路径作为其参数，从而实现 DLL 的加载。\n获取 DLL 句柄正常情况下，CreateRemoteThread 返回了线程句柄，待线程结束后通过 GetExitCodeThread 函数获取的线程退出码，线程退出码是线程处理过程函数的返回值，在使用上面方式进行远程线程注入时，GetExitCodeThread 函数获取的退出码则实际是 LoadLibraryA 函数的返回值，也就是线程的句柄。\nHMODULE hDll = NULL;GetExitCodeThread(hRemoteThread, (LPDWORD)&amp;hDll);\n\n正如上面一节注解中所介绍的那样，这种获取注入 DLL 句柄的方式仅适用与 32 位程序，因为 64 位程序的句柄占 8 字节，使用 4 字节的 DWORD 类型存储，可能会导致数据截断。但如果不需要获取 DLL 句柄或者注入后再通过遍历进程模块的方式获取 DLL 句柄，则这种注入方式也同时适用于 32&#x2F;64 位程序。\n取消注入取消注入就是将 DLL 从目标进程卸载，卸载 DLL 所用的 API 是FreeLibrary，但我们不能直接调用这个函数，因为直接调用的话是在我们的进程中卸载 DLL，而不是目标进程中卸载，很显然这样达不到卸载的目的。我们需要和加载 DLL 时一样，将FreeLibrary的地址作为第 4 个参数传给 CreateRemoteThread 函数：\nCreateRemoteThread(hTargeProcess, NULL, 0, FreeLibrary, hDll, 0, NULL);\n\nShellCode 版远程线程注入ShellCode 版远程线程注入是上一节普通远程线程注入的升级版，不仅可以弥补 64 位远程线程注入无法获取 DLL 句柄的遗憾（普通远程线程注入的遗憾在于 4 字节的 DWORD 不足以存储 64 位的句柄），而且对于后面介绍的 RIP&#x2F;EIP 劫持注入也有一定的铺垫作用。\n本节介绍的 ShellCode 使用的都是 64 位寄存器，主要针对 64 位程序，32 位程序还需要做相应的修改。\nShellCode 版远程线程注入的步骤大致如下：\n\n获取目标进程句柄（与普通版一样）。\n在目标进程分配内存（记作 M1），并写入 DLL 路径（与普通版一样）。\n在目标进程中分配 8 字节内存区域（记作 M2），用于存储返回的 DLL 句柄。\n构造 ShellCode，该 ShellCode 用于在目标进程中调用 LoadLibrary，并将结果存储到步骤 3 分配的 M2 内存。\n在目标进程分配内存（记作 M3），并写入步骤 4 构造的 ShellCode，M3 需要有 PAGE_EXECUTE_READWRITE 保护属性。\n将 ShellCode 所在内存 M3 的地址作为 lpStartAddress 参数传递给 CreateRemoteThread 函数，而不再是 LoadLibrary 的地址。\n等待线程结束后，从 M2 读取 DLL 句柄的值。\n\nShellCode 看起来很神秘，其实并不高深，它就是一段汇编代码所对应的机器码而已。我们使用简单的汇编指令即可完成汇编代码的编写工作，如 mov、add、sub、lea、call、ret 等，然后将汇编指令转成机器码。\n如何将汇编指令转机器码？\n网上有很多工具可以使用，如 ASM to Hex Convert、Online-Assembler-and-Disassembler，也可以借助 x64dbg，在其中修改汇编代码（快捷键 Space），就会自动生成对应的机器码。\n下面来讲讲如何使用汇编代码来构造一个函数。\n// CreateRemoteThread在调用下面函数时，会将 pDllPathAddress 会作为参数存入到 rcxsub rsp, 0x28                     // 在栈上分配0x28字节的区域mov [rsp+0x8], rcx                // 将当前的rcx值保存到栈，方便调用结束后恢复rcx的值mov [rsp+0x10], rax               // 将当前的rax值保存到栈，方便调用结束后恢复rax的值mov rax, LoadLibraryAddress       // 将LoadLibrary函数地址存储到raxcall rax                          // 调用LoadLibrary函数，rcx是其第一个参数，因为前面一直没有修改rcx，所以其中存放的就是DLL路径地址mov rcx, SaveResultAddress        // 将SaveResultAddress地址（也就是之前分配的M2内存）存储到rcxmov [rcx], rax                    // 将LoadLibrary函数的返回值rax存储到SaveResultAddress地址mov rax, [rsp+0x10]               // 恢复rax的值mov rcx, [rsp+0x8]                // 恢复rcx的值add rsp, 0x28                     // 释放栈空间ret                               // 函数返回，虽然是WINAPI调用约定，按理需要函数自身来平衡堆栈，                                  // 但64位程序第一个参数使用rcx传递，因此不需要在此额外将栈指针增加 0x8 字节平衡堆栈\n\n由于 ShellCode 中的地址都是一次性的，在每次注入时都会改变，所以上面代码中使用的硬编码绝对地址不会出现地址失效的问题。\n又因为在上述汇编代码中没有使用堆栈获取局部变量、函数参数，所以也就没有使用和暂存 rbp 寄存器，而在 32 位程序中需要使用 ebp 寄存器来获取参数。\n此外，在汇编程序中，没有直接的 call 0x12345678 立即数绝对地址形式，call 指令后的立即数会被认为是相对 RIP&#x2F;EIP 的偏移量。如果需要调用绝对地址需要通过间接方式，如上面汇编代码中的：\n; ❌ 错误call LoadLibraryAddress; ✅ 正确mov rax, LoadLibraryAddresscall rax\n\n而且汇编程序也不支持使用立即数作为内存操作数，需要通过寄存器中转方式，如上面汇编代码中的：\n; ❌ 错误mov [SaveResultAddress], rax; ✅ 正确mov rcx, SaveResultAddressmov [rcx], rax\n\n上述汇编代码转成的字节码如下：\nBYTE shellCode[] = &#123;    0x48, 0x83, 0xEC, 0x28,                                     // sub rsp, 0x28    0x48, 0x89, 0x4C, 0x24, 0x08,                               // mov [rsp+0x8], rcx    0x48, 0x89, 0x44, 0x24, 0x10,                               // mov [rsp+0x10], rax    0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax, LoadLibraryAddress    0xFF, 0xD0,                                                 // call rax    0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rcx, SaveResultAddress    0x48, 0x89, 0x01,                                           // mov [rcx], rax    0x48, 0x8B, 0x44, 0x24, 0x10,                               // mov rax, [rsp+0x10]    0x48, 0x8B, 0x4C, 0x24, 0x10,                               // mov rcx, [rsp+0x8]    0x48, 0x83, 0xC4, 0x28,                                     // add rsp, 0x28;    0xC3                                                        // ret&#125;;\n\n其中第 5、7 两行中的 0x00 是占位符，需要替换为实际的内存地址：\n*(DWORD64*)(&amp;shellCode[16]) = (DWORD64)pLoadLibraryAddr;*(DWORD64*)(&amp;shellCode[28]) = (DWORD64)pSaveResultAddress;\n\n最后通过 CreateRemoteThread 调用该 ShellCode 函数，并传入 DLL 路径地址作为参数：\nHANDLE hRemoteThread = CreateRemoteThread(hTargeProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pShellCodeAddress, pDllPathAddress, 0, NULL);if (hRemoteThread)    // 等待线程结束    WaitForSingleObject(hRemoteThread, INFINITE);    // 读取DLL句柄    if (ReadProcessMemory(hTargeProcess, pSaveResultAddress, &amp;hDll, sizeof(HMODULE), NULL)) &#123;    &#125;&#125;\n\nEIP&#x2F;RIP 劫持注入EIP&#x2F;RIP 劫持与上面介绍的 ShellCode 版远程线程注入有异曲同工之处，但最大的区别在于 EIP&#x2F;RIP 劫持注入不用调用 CreateRemoteThread 函数，而是直接修改线程的 EIP&#x2F;RIP。\n由于已在上面 ShellCode 版远程线程注入中做了相关知识的铺垫，所以本节不会介绍的那么详细。\n下面以 64 位程序为例，介绍 RIP 劫持注入的大致步骤：\n\n获取目标进程的句柄。\n在目标进程分配内存（记作 M1），并写入 DLL 路径。\n在目标进程分配 8 字节的内存（记作 M2），用于存储返回的 DLL 句柄。\n遍历目标进程的线程，调用 SuspendThread 函数挂起一个目标线程。\n调用 GetThreadContext 函数获取挂起线程的 RIP，用于 ShellCode 执行完后跳转到该位置继续执行，不影响目标进程的原有逻辑。\n构造 ShellCode，该 ShellCode 用于在目标进程中调用 LoadLibrary，并将结果存储到步骤 3 分配的 M2 内存，然后跳转之前的 RIP。\n在目标进程分配内存（记作 M3），并写入步骤 6 构造的 ShellCode，M3 需要有 PAGE_EXECUTE_READWRITE 保护属性。\n调用 SetThreadContext 函数修改 RIP 的值为 ShellCode 地址。\n调用 ResumeThread 函数恢复线程。\n等待短暂地时间后，从 M2 读取 DLL 句柄的值。\n\nShellCode 对应的汇编代码如下：\nsub rsp, 0x28mov [rsp+0x8], rcxmov [rsp+0x10], raxmov rcx, DllPathAddress      // 将DLL路径地址存储到rcx，作为 LoadLibrary 的参数mov rax, LoadLibraryAddresscall rax                     // 调用 LoadLibrarymov rcx, SaveResultAddressmov [rcx], rax               // 将LoadLibrary 返回值存储到 SaveResultAddressmov rax, [rsp+0x10]mov rcx, [rsp+0x8]add rsp, 0x28mov r11, OriginalRipjmp rll                      // 跳转到之前的RIP\n\n由于是直接修改 RIP 进行的执行流程跳转，因而会缺少正常函数调用时的 RIP 入栈、参数传递等过程，所以需要手动将 DllPathAddress 赋值给 rcx，并且在代码最后不能调用 ret。\n对于 jmp 指令，不能使用jmp OriginalRip这样的方式来实现跳转到绝对地址，需要使用一个寄存器来做间接跳转。\n上述汇编代码转成的字节码如下：\nBYTE shellCode[] = &#123;    0x48, 0x83, 0xEC, 0x28,                                     // sub rsp, 0x28    0x48, 0x89, 0x4C, 0x24, 0x08,                               // mov [rsp+0x8], rcx    0x48, 0x89, 0x44, 0x24, 0x10,                               // mov [rsp+0x10], rax    0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rcx, DllPathAddress    0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax, LoadLibraryAddress    0xFF, 0xD0,                                                 // call rax    0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rcx, SaveResultAddress    0x48, 0x89, 0x01,                                           // mov [rcx], rax    0x48, 0x8B, 0x44, 0x24, 0x10,                               // mov rax, [rsp+0x10]    0x48, 0x8B, 0x4C, 0x24, 0x10,                               // mov rcx, [rsp+0x8]    0x48, 0x83, 0xC4, 0x28,                                     // add rsp, 0x28    0x49, 0xBB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov r11, OriginalRip    0x41, 0xFF, 0xE3                                            // jmp rll&#125;;\n\n调用 ResumeThread 函数恢复线程后，线程就会执行 ShellCode。由于没有创建新的线程，所以不能像远程线程注入那样等待线程结束后再读取 DLL 句柄，可以等待一个合适的时间后就尝试读取 DLL 句柄。\nSleep(200);ReadProcessMemory(hTargeProcess, pSaveResultAddress, &amp;hDll, sizeof(HMODULE), NULL);\n\n获取到 DLL 句柄后，可以再次注入 ShellCode 来调用 FreeLibrary 来释放 DLL。\n基于文件映射方式的内存访问在前面的远程线程注入和 EIP&#x2F;RIP 注入章节，都使用了 VirtualAllocEx、WriteProcessMemory、ReadProcessMemory 等函数在远程进程中分配内存、读写内存，由于这些函数被广泛使用，已经作为高危函数被 AV&#x2F;EDR 软件所监控。本节并不是介绍一种新的注入方法，而是介绍一种不使用上述函数，通过使用文件映射方式来读写远程内存的方法。\n\n这种方式目前肯定无法 100% 躲避 AV&#x2F;EDR，毕竟攻防之路永不止境。\n\n使用文件映射访问目标进程内存及注入的大致步骤如下：\n\n调用 CreateFileMapping 函数创建一个文件映射对象，并指定足够的大小，使其可以存储 DLL 路径。如果使用 EIP&#x2F;RIP 劫持方式注入，还需要存储返回的 DLL 句柄、ShellCode。\n调用 MapViewOfFile 函数将“文件映射对象”映射到当前进程地址空间，得到虚拟地址 A。\n将 DLL 路径、ShellCode 等写入到虚拟地址 A。\n调用 MapViewOfFile2 函数将“文件映射对象”映射到目标进程地址空间，得到虚拟地址 B。\n根据虚拟地址 B 来计算 DLL 路径在目标进程中的真实地址，以及填充 ShellCode 中的地址占位符。\n等待约 50ms。\n调用 CreateRemoteThread 或者修改 RIP 来实现注入。\n获取 DLL 句柄。如果使用 EIP&#x2F;RIP 注入，则使用虚拟地址 A 读取 DLL 句柄，因为 CPU 会负责数据的同步；如果使用远程线程注入，则直接通过线程退出码来获取 DLL 句柄。\n\n为什么第 6 步需要等待 50ms？因为在多核系统中，CPU 进行同步时可能会有一个短暂的延迟，等待 50ms，确保第 5 步修改的数据已经同步到目标进程（目前我还没有找到更好的办法）。\n另外，在 DLL 注入之后，最好不要调用 UnmapViewOfFile2 函数来取消对目标进程的映射，否则目标进程中的相关数据会被清除，可能导致其他错误。\n\n由于 MapViewOfFile2 函数在 Windows 8+ 才引入，所以这种方式支持的操作系统版本有限。\n\n下面是使用文件映射方式结合 RIP 劫持实现的 DLL 注入的完整示例代码：\nHMODULE MapRipHijackInjectDll64(DWORD dwProcessID, LPCTSTR pszDllPath, DWORD&amp; dwGLE) &#123;    HMODULE hDll = NULL;    HANDLE hTargeProcess = NULL;    HANDLE hMapping = NULL;    LPVOID pLocalAddress = NULL;    LPVOID pRemoteAddress = NULL;    SetLastError(0);    __try &#123;        if (pszDllPath == NULL || dwProcessID == 0)            __leave;        LPVOID pLoadLibraryAddr = GetLoadLibarayAddress();        if (!pLoadLibraryAddr)            __leave;        hTargeProcess = OpenProcess(PROCESS_VM_OPERATION, FALSE, dwProcessID);        if (!hTargeProcess)            __leave;        // clang-format off        BYTE shellCode[] = &#123;            0x48, 0x83, 0xEC, 0x28,                                     // sub rsp, 0x28            0x48, 0x89, 0x4C, 0x24, 0x08,                               // mov [rsp+0x8], rcx            0x48, 0x89, 0x44, 0x24, 0x10,                               // mov [rsp+0x10], rax            0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rcx, DllPathAddress            0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax, LoadLibraryAddress            0xFF, 0xD0,                                                 // call rax            0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rcx, SaveResultAddress            0x48, 0x89, 0x01,                                           // mov [rcx], rax            0x48, 0x8B, 0x44, 0x24, 0x10,                               // mov rax, [rsp+0x10]            0x48, 0x8B, 0x4C, 0x24, 0x10,                               // mov rcx, [rsp+0x8]            0x48, 0x83, 0xC4, 0x28,                                     // add rsp, 0x28            0x49, 0xBB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov r11, OriginalRip            0x41, 0xFF, 0xE3                                            // jmp rll        &#125;;        // clang-format on        const SIZE_T dllPathSize = (_tcslen(pszDllPath) + 1) * sizeof(TCHAR);        const SIZE_T totalSize = dllPathSize + sizeof(shellCode) + sizeof(HMODULE);        hMapping = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, 0, totalSize, NULL);        if (!hMapping)            __leave;        pLocalAddress = MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, dllPathSize);        if (!pLocalAddress)            __leave;        const LPVOID pLocalDllPath = pLocalAddress;        const LPVOID pLocalSaveResult = (BYTE*)pLocalDllPath + dllPathSize;        BYTE* pLocalShellCode = (BYTE*)pLocalSaveResult + sizeof(HMODULE);        // 先将数据拷贝到本地的内存        memcpy(pLocalDllPath, pszDllPath, dllPathSize);        memcpy(pLocalShellCode, shellCode, sizeof(shellCode));        HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);        if (hSnap == INVALID_HANDLE_VALUE)            __leave;        THREADENTRY32 te32 = &#123;sizeof(te32)&#125;;        for (bool fOk = Thread32First(hSnap, &amp;te32); fOk; fOk = Thread32Next(hSnap, &amp;te32)) &#123;            if (te32.th32OwnerProcessID == dwProcessID) &#123;                // 第一个线程通常是主线程                HANDLE hTargetThread = OpenThread(THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_SET_CONTEXT, FALSE, te32.th32ThreadID);                if (!hTargetThread)                    continue;                if (SuspendThread(hTargetThread) == (DWORD)-1) &#123;                    CloseHandle(hTargetThread);                    continue;                &#125;                CONTEXT threadCtx = &#123;0&#125;;                threadCtx.ContextFlags = CONTEXT_FULL;                if (!GetThreadContext(hTargetThread, &amp;threadCtx)) &#123;                    CloseHandle(hTargetThread);                    continue;                &#125;                // 映射到远程内存                pRemoteAddress = MapViewOfFile2(hMapping, hTargeProcess, 0, NULL, 0, 0, PAGE_EXECUTE_READWRITE);                if (!pRemoteAddress) &#123;                    CloseHandle(hTargetThread);                    break;                &#125;                // 根据远程内存的地址来填充ShellCode中的占位符                *(DWORD64*)(&amp;pLocalShellCode[16]) = (DWORD64)pRemoteAddress + ((BYTE*)pLocalDllPath - (BYTE*)pLocalAddress);                *(DWORD64*)(&amp;pLocalShellCode[26]) = (DWORD64)pLoadLibraryAddr;                *(DWORD64*)(&amp;pLocalShellCode[38]) = (DWORD64)pRemoteAddress + ((BYTE*)pLocalSaveResult - (BYTE*)pLocalAddress);                *(DWORD64*)(&amp;pLocalShellCode[65]) = (DWORD64)threadCtx.Rip;                // 在多核系统中，CPU同步会有短暂延迟                Sleep(50);                // ShellCode在远程内存中的地址                LPVOID pRemoteShellCodeAddress = (BYTE*)pRemoteAddress + ((BYTE*)pLocalShellCode - (BYTE*)pLocalAddress);                threadCtx.Rip = (DWORD64)pRemoteShellCodeAddress;                if (!SetThreadContext(hTargetThread, &amp;threadCtx)) &#123;                    CloseHandle(hTargetThread);                    break;                &#125;                if (ResumeThread(hTargetThread) == (DWORD)-1) &#123;                    CloseHandle(hTargetThread);                    break;                &#125;                Sleep(100);                // 读取DLL句柄                hDll = *(HMODULE*)pLocalSaveResult;                CloseHandle(hTargetThread);                break;            &#125;        &#125;        CloseHandle(hSnap);    &#125; __finally &#123;        dwGLE = GetLastError();        if (!hDll) &#123;            // 注入成功后，不要取消对目标进程的映射            if (hTargeProcess &amp;&amp; pRemoteAddress) &#123;                UnmapViewOfFile2(hTargeProcess, pRemoteAddress, 0);                pRemoteAddress = NULL;            &#125;        &#125;        if (pLocalAddress)            UnmapViewOfFile(pLocalAddress);        if (hMapping)            CloseHandle(hMapping);        if (hTargeProcess)            CloseHandle(hTargeProcess);    &#125;    return hDll;&#125;\n\n用户模式 APC 注入QueueUserAPC每个线程都有一个 APC 队列，当线程进入可警告状态（Alertable）时，会按照 FIFO 的顺序执行 APC（异步过程调用）。\n在用户模式和内核模式都可以实现 APC 注入，本节介绍如何在用户模式实现 APC 注入。用户模式实现 APC 注入主要使用 QueueUserAPC 函数向目标线程插入 APC。\nDWORD QueueUserAPC(  [in] PAPCFUNC  pfnAPC,  [in] HANDLE    hThread,  [in] ULONG_PTR dwData);\n\n与远程线程注入的思路类似，也是利用将 LoadLibrary 地址作为 pfnAPC 参数传入，DLL 路径作为 dwData 参数传入（也需要提前在目标进程分配内存和赋值），来实现在目标进程中的加载 DLL 。\nAPC 注入的弊端在于，当 APC 插入到队列之后，并不会立即执行，需要等待线程进入可警告状态时才会依次执行，那么线程何时进入可警告状态呢？\n线程只有调用 SleepEx、SignalObjectAndWait、WaitForSingleObjectEx、WaitForMultipleObjectsEx 或 MsgWaitForMultipleObjectsEx 函数后才会进入可警告状态。\n因此当插入 APC 后，我们还要祈祷线程赶快执行上述函数，否则 DLL 永远不会被注入。虽然为了提高注入的成功率，通常会在目标进程的所有线程中都执行 APC 插入操作，但这样成功率依然无法得到保证。\n通过未公开的 NtTestAlert 函数虽然也可以使线程执行并清空当前 APC 队列，当该函数只能作用于当前进程中的当前线程，无法操作远程线程。\n目前，还可以使用未公开的 NtQueueApcThreadEx 函数进行 APC 注入，使用该函数插入一个特殊的 APC，可以不用等待线程进入 Alertable 状态，但这种方式对系统的版本有限制。\nEarly BirdEarly Bird 翻译为中文叫“早起的鸟儿”。顾名思义，就是注入的时机很早。\nEarly Bird 本质上也是一种 APC 注入技术，其间接利用了 NtTestAlert 函数。因为线程在初始化时会主动调用 NtTestAlert 函数来清空和处理 APC 队列。所以我们可以创建一个挂起的进程（当然其主线程也会被挂起），并调用 QueueUserAPC 函数在该线程中插入一个 APC，然后恢复线程。当线程进入初始化流程后会自动调用 NtTestAlert 来清空并处理 APC 队列中的任务，这样我们插入的 APC 就得以执行。\n下面代码通过将 LoadLibrary 地址插入 APC 的方式来展示了 Early Bird 的基本流程，我们也可以将其换成 ShellCode 的地址。\nPFN_NtTestAlert pfnNtTestAlert = (PFN_NtTestAlert)GetProcAddress(LoadLibraryW(L&quot;ntdll.dll&quot;), &quot;NtTestAlert&quot;);LPVOID pLoadLibraryAddr = GetLoadLibarayAddress();// 选择合适的程序#ifdef _WIN64    WCHAR szPath[MAX_PATH] = &#123;L&quot;a 64bit process path&quot;&#125;;#else    WCHAR szPath[MAX_PATH] = &#123;L&quot;a 32bit process path&quot;&#125;;#endifSTARTUPINFOW si = &#123;sizeof(si)&#125;;PROCESS_INFORMATION pi = &#123;0&#125;;// 创建挂起的进程CreateProcessW(NULL, szPath, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi);const SIZE_T dllPathSize = (_tcslen(pszDllPath) + 1) * sizeof(TCHAR);LPVOID pRemoteDllPath = VirtualAllocEx(pi.hProcess, NULL, dllPathSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);WriteProcessMemory(pi.hProcess, pRemoteDllPath, pszDllPath, dllPathSize, NULL);// 插入APCQueueUserAPC((PAPCFUNC)pLoadLibraryAddr, pi.hThread, (ULONG_PTR)pRemoteDllPath);ResumeThread(pi.hThread);\n\nInline HookInline Hook（内联挂钩）是一种直接修改目标函数开头的指令，使其跳转到自定义的代理函数，从而实现 Hook 的技术。\n基本步骤如下：\n原始函数：7FFA12345678: 55                    push rbp7FFA12345679: 48 89 E5              mov rbp, rsp7FFA1234567C: 48 83 EC 20           sub rsp, 20h...Inline Hook 后：7FFA12345678: E9 83 11 22 33        jmp MyHookFunction  ; 修改为跳转指令7FFA1234567D: EC 20                 ; 被覆盖的原有指令（部分破坏）\n\n从上面基本步骤可以看出，jmp MyHookFunction指令占用 5 字节，使用替换之前指令，会导致第 3 条指令仅部分被替换，这也是 Inline Hook 的技术挑战之一：不同指令长度不同，需要完整覆盖指令边界。\n另外，jmp 指令使用相对跳转（目标地址 &#x3D; 当前 EIP + 相对偏移），因此还需要计算当前指令相对 EIP 的偏移地址。\n在执行完 MyHookFunction 函数后，如果需要继续执行原始函数怎么呢？可以在 MyHookFunction 中还原被覆盖的原有指令吗？类似下面的做法：\n// 在调用前还原原始指令，调用后再重新hookvoid MyHookFunction() &#123;    // 还原原始代码    RestoreOriginalCode();    // 调用原始函数    OriginalFunction();    // 重新hook ← ❌ 这里有问题！    RehookFunction();&#125;\n\n这是错误的，这样做在多线程情况下，可能会出现竞态条件问题，线程 A 正在执行原始函数，而线程 B 可能会在进行重新 Hook，导致无法拦截。而且每次修改指令都需要更改内存保护属性，这种反复修改的代价也很高。\n可以通过引入跳板机制来解决上述问题，以 Hook MessageBoxA 为例：\n; 原始函数被修改后：MessageBoxA:    jmp MyMessageBoxA  ; 5字节（x86）或14字节（x64）    ... 被覆盖的原始指令 ...; 跳板函数：MessageBoxA_Trampoline:    ; 1. 被覆盖的原始指令    push ebp    mov ebp, esp    sub esp, 20h    ; 2. 跳回原始函数的剩余部分    jmp MessageBoxA+5\n\n在任何时候，需要调用原始 MessageBoxA 时，直接调用 MessageBoxA_Trampoline 即可。\n\n\n上面的实现方法虽然不难，但仍然有很多需要考虑的情况，特别是要开发一个通用的 Inline Hook 库，比如需要考虑如何界定待 Hook 函数的指令边界，确保没有出现本节一开始的部分指令被替换的情况等。\n说到这里就不得不推出今天的主角 – minhook，该库是目前 Windows 上使用最广泛的 Inline Hook 解决方案，完美解决了上述问题，而且使用起来也非常简单，下面通过几行代码来演示该库的使用。\ntypedef int(WINAPI * PFN_MessageBoxW)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);LPVOID pfnTraget = NULL;                // 等同于MessageBoxW的原始地址PFN_MessageBoxW pfnTrampoline = NULL;   // 跳板函数，用于在Detour函数中调用原始的MessageBoxW，不能直接调用pfnTragetint WINAPI MyMessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType) &#123;    return pfnTrampoline(hWnd, L&quot;MessageBoxW has been hooked by IAT-Hook!&quot;, TITLE, uType);&#125;// 初始化MinHookMH_STATUS mhStatus = MH_Initialize();// Hook User32.dll::MessageBoxWmhStatus = MH_CreateHookApiEx(    L&quot;User32.dll&quot;,    &quot;MessageBoxW&quot;,    (LPVOID)MyMessageBoxW,    (LPVOID*)&amp;pfnTrampoline,    (LPVOID*)&amp;pfnTraget);// 启用指定钩子mhStatus = MH_EnableHook(pfnTraget);// ......// 当不需要钩子时，移除指定钩子MH_RemoveHook(pfnTraget);// 最后，反初始化MinHookmhStatus = MH_Uninitialize();\n\nIAT HookIAT 的导入地址表（Import Address Table）的简写，该表记录了程序从哪些 DLL 导入了哪些函数。\nWindows 应用程序都会依赖系统库或其他第三方库，虽然通过 MT(d)编译的程序会静态链接 CRT，但其他系统库仍然会出现在 IAT 中，因为这些系统库无法被静态链接到应用程序中。\nIAT Hook 的原理：针对隐式调用的函数，编译器在生成代码时，会将 call MessageBox 指令指向 IAT 中的一个条目，我们 Hook 掉这个条目（将其中的地址改为自己函数地址），程序执行时就会跳转到我们自己的代码。\n但是 IAT Hook 对显式调用（LoadLibrary -&gt; GetProcAddress）的函数没有效果，因为 GetProcAddress 函数是从 DLL 的导出表（EAT）中查找的函数原始内存地址，这个过程根本不会查阅调用者自身的 IAT 表，所以 Hook 无法生效。\n\n如果要对显示调用的函数进行 Hook，可以使用后面章节介绍的 EAT Hook。\n\n既然是 IAT Hook，那么肯定先要找 IAT 表。根据下图描述的 PE 文件结构，我们可以解析出 IAT 数据。\n\n在解析 IAT 数据之前，先要找到与导入表相关的数据目录项，大致步骤为：\n\n首先根据 DOS 头中的 e_lfanew 字段定位到 NT 头。\n然后找到 NT 头中的 Optional 头。\n在 Optional 头的尾部存储了一个 DataDirectorys 数组（数组中每个元素都是 IMAGE_DATA_DIRECTORY 类型），该数组中索引为 1 的项中存储的是“导入表”的偏移和大小。\n根据镜像基地址加上偏移就找到了“导入表数据目录项”了。\n\nIMAGE_DATA_DIRECTORY 类型定义如下：\ntypedef struct _IMAGE_DATA_DIRECTORY &#123;    DWORD   VirtualAddress;    DWORD   Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;\n\n其中，VirtualAddress 中存储的不是绝对地址，而是相对与镜像基址的偏移（RVA），在下面介绍的结构体中的元素所存储的地址也都是 RVA。\nVirtualAddress 所指向的是 IMAGE_IMPORT_DESCRIPTOR 数组（导入表描述符），数组中每一个 IMAGE_IMPORT_DESCRIPTOR 元素代表一个依赖的 DLL。\nIMAGE_IMPORT_DESCRIPTOR 定义如下：\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;    union &#123;        DWORD   Characteristics;        DWORD   OriginalFirstThunk;   // 存储导入名称表INT的 RVA    &#125; DUMMYUNIONNAME;    DWORD   TimeDateStamp;    DWORD   ForwarderChain;    DWORD   Name;               // 存储对应 DLL 文件名字符串的 RVA    DWORD   FirstThunk;         // 存储导入地址表IAT的 RVA。加载到内存后，加载器会将函数的真实内存地址填充到此表中&#125; IMAGE_IMPORT_DESCRIPTOR;\n\n我们知道 DLL 的导出函数分为按名称导出和按序号导出，同样从 DLL 中导入函数也对应这两种情况。\nIMAGE_IMPORT_DESCRIPTOR 结构中的 OriginalFirstThunk 字段所指向的数组用于存储导入函数的名称或序号，我们将该数组称为导入名称表（INT），数组中的元素为 IMAGE_THUNK_DATA 类型：\ntypedef struct _IMAGE_THUNK_DATA32 &#123;    union &#123;        DWORD ForwarderString;      // PBYTE        DWORD Function;             // PDWORD        DWORD Ordinal;        DWORD AddressOfData;        // PIMAGE_IMPORT_BY_NAME    &#125; u1;&#125; IMAGE_THUNK_DATA32;\n\n而 IMAGE_IMPORT_DESCRIPTOR 结构中的 FirstThunk 字段所数组用于存储函数导入后的真实内存地址，我们将该数组称为导入地址表（IAT），数组中的元素也是 IMAGE_THUNK_DATA 类型。\n两个数组中的元素类型都是 IMAGE_THUNK_DATA 类型，但在 INT 表中主要使用 AddressOfData 和 Ordinal 字段，其中 AddressOfData 字段存储函数名称的 RAV，Ordinal 字段用于判断当前函数是按名称还是按序号导入（1 为函数名，否则为序号），而在 IAT 表中则主要使用 Function 字段，其中存储的是函数真实地址。\n上面出现的 3 个数组（IMAGE_IMPORT_DESCRIPTOR 数组、INT 数组、IAT 数组）都没有提供专门的字段来获取数组元素的个数，那么在遍历数组时，如何判断最后一个元素呢？\n通过指针递增的方式来依次遍历每个元素，但元素中的所有字段都为 0 时，表示该元素为数组中的最后一个元素。\n说了这么多，读者可能有些混乱了，我画了一个图可能会对理解整个流程有所帮助。\n\n\n在找到指定模块的指定函数之后，将u1.Function所指向的导入函数地址修改为我们自己函数的地址，就可以实现 Hook 了。当然别忘了保存原始的函数地址，以便后面进行 Unhook 或调用。\n下面是 32 位程序使用 IAT Hook user32.dll::MessageBoxW 的完整示例代码（64 位程序将代码中的结构体修改为对应的的 64 位结构体即可）。\nPFN_MessageBoxW originalMessageBoxW = NULL;bool InitIATHook86() &#123;    // 基地址    uint8_t* pModule = (uint8_t*)GetModuleHandle(NULL);    // DOS头    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pModule;    // NT头    PIMAGE_NT_HEADERS32 pNTHeaders = (PIMAGE_NT_HEADERS32)(pModule + pDosHeader-&gt;e_lfanew);    // 导入表数据目录项    const IMAGE_DATA_DIRECTORY importDir = pNTHeaders-&gt;OptionalHeader.DataDirectory[1];    bool result = false;    PIMAGE_IMPORT_DESCRIPTOR pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)(pModule + importDir.VirtualAddress);    do &#123;        if (pImportDesc-&gt;Characteristics == 0)  break; // 最后一个        // 导入的模块名        const std::string dllName = ReadStringUntilZero((const char*)(pModule + pImportDesc-&gt;Name));        if (StrToLower(dllName) != &quot;user32.dll&quot;) &#123;            pImportDesc += 1;            continue;        &#125;        // 导入模块中的函数名称        PIMAGE_THUNK_DATA32 pINT_Thunk = (PIMAGE_THUNK_DATA32)(pModule + pImportDesc-&gt;OriginalFirstThunk);  // OriginalFirstThunk = INT        PIMAGE_THUNK_DATA32 pIAT_Thunk = (PIMAGE_THUNK_DATA32)(pModule + pImportDesc-&gt;FirstThunk);          // FirstThunk = IAT        do &#123;            if (pINT_Thunk-&gt;u1.Ordinal == 0)  // 最后一个                break;            if (!(pINT_Thunk-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG32)) &#123;  //高位不为1时，使用名称导入                const PIMAGE_IMPORT_BY_NAME pImportByName = (PIMAGE_IMPORT_BY_NAME)(pModule + pINT_Thunk-&gt;u1.AddressOfData);                const std::string funName = ReadStringUntilZero(pImportByName-&gt;Name);                if (funName == &quot;MessageBoxW&quot;) &#123;                    originalMessageBoxW = (PFN_MessageBoxW)pIAT_Thunk-&gt;u1.Function;                    DWORD oldProtect = 0;                    if (VirtualProtect(&amp;pIAT_Thunk-&gt;u1.Function, sizeof(DWORD), PAGE_READWRITE, &amp;oldProtect)) &#123;                        pIAT_Thunk-&gt;u1.Function = (DWORD)MyMessageBoxW;                        VirtualProtect(&amp;pIAT_Thunk-&gt;u1.Function, sizeof(DWORD), oldProtect, &amp;oldProtect);                        result = true;                    &#125;                &#125;            &#125;            pINT_Thunk += 1;            pIAT_Thunk += 1;        &#125; while (true);        pImportDesc += 1;    &#125; while (true);    return result;&#125;\n\nEAT HookEAT 是导入地址表（Export Address Table）的简写，该表记录了 DLL 导出了哪些函数。\n与上面介绍的 IAT Hook 不同，IAT Hook 修改的是可执行程序自身的导入表，而 EAT Hook 修改的是 DLL 的导出表。\n查找 EAT 的步骤与上面的查找 IAT 的步骤类似，先找到导出表数据目录项（位于 Optional -&gt; DataDirectorys 数组的第 0 项），然后定位并解析 IMAGE_EXPORT_DIRECTORY 数组。\nIMAGE_EXPORT_DIRECTORY 定义如下：\ntypedef struct _IMAGE_EXPORT_DIRECTORY&#123;    DWORD   Characteristics;       // 保留,始终为0x00000000    DWORD   TimeDateStamp;         // 文件的产生时间戳    WORD    MajorVersion;          // 主版本号    WORD    MinorVersion;          // 次版本号    DWORD   Name;                  // 指向文件名的RVA    DWORD   Base;                  // 导出函数的起始序号    DWORD   NumberOfFunctions;     // 导出函数总数    DWORD   NumberOfNames;         // 以名称导出函数的总数    DWORD   AddressOfFunctions;    // 导出函数地址表的RVA，也就是EAT    DWORD   AddressOfNames;        // 函数名称地址表的RVA，这个表里面的索引需要通过AddressOfNameOrdinals获取    DWORD   AddressOfNameOrdinals; // 函数名序号表的RVA，将序号表里面的元素作为索引传入AddressOfNames，获取函数地址&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;\n\nIMAGE_EXPORT_DIRECTORY 中各个字段的作用及关系如下：\n\n\n其中，NumberOfNames 字段记录了当前 DLL 按名称导出的函数的总数；\nAddressOfNames 字段所指向的表中存储了导出函数的名称（按序号导出的函数不在该表），而 AddressOfFunctions 字段所指向的表中存储了每个函数的地址（包含按名称导出和按序号导出的函数）。因此 AddressOfNames 和 AddressOfFunctions 表不是一一对应的关系，AddressOfFunctions 表中的元素可能比 AddressOfNames 表多。它们之间通过 AddressOfNameOrdinals 表建立连接，AddressOfNames 与 AddressOfNameOrdinals 表是一一对应的关系，通过 AddressOfNames 表的索引可以在 AddressOfNameOrdinals 表中查询到函数在 AddressOfFunctions 表中的索引。\n需要注意：\n\nAddressOfNameOrdinals 所指向的是 WORD 数组，而不是 DWORD 数组。\nIMAGE_EXPORT_DIRECTORY 中存储的 RAV 是相对于模块基地址的偏移，而且 AddressOfFunctions 中存储的也是 RAV（IAT 中存储的却是绝对地址）。\n\n下面是 32 位程序使用 EAT Hook user32.dll::MessageBoxW 的完整示例代码（64 位程序将代码中的结构体修改为对应的的 64 位结构体即可）。\nPFN_MessageBoxW originalMessageBoxW = NULL;bool InitEATHook86() &#123;    uint8_t* pBase = (uint8_t*)LoadLibrary(TEXT(&quot;User32.dll&quot;));    // DOS头    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBase;    // NT头    PIMAGE_NT_HEADERS32 pNTHeaders = (PIMAGE_NT_HEADERS32)(pBase + pDosHeader-&gt;e_lfanew);    const PIMAGE_EXPORT_DIRECTORY pExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + exportDir.VirtualAddress);    const WORD* pNameIndexTable = (WORD*)(pBase + pExportDir-&gt;AddressOfNameOrdinals);  // 2个字节    const DWORD* pNameAddressTable = (DWORD*)(pBase + pExportDir-&gt;AddressOfNames);    DWORD* pFuncAddressTable = (DWORD*)(pBase + pExportDir-&gt;AddressOfFunctions); // EAT    bool result = false;    for (DWORD j = 0; j &lt; pExportDir-&gt;NumberOfNames; j++) &#123;        const WORD index = pNameIndexTable[j];  // 2个字节        const char* pName = (const char*)(pBase + pNameAddressTable[j]);        const std::string funName = ReadStringUntilZero(pName);        if (funName == &quot;MessageBoxW&quot;) &#123;            originalMessageBoxW = (PFN_MessageBoxW)(pBase + pFuncAddressTable[index]);            DWORD oldProtect;            if (VirtualProtect((LPVOID)&amp;pFuncAddressTable[index], sizeof(DWORD), PAGE_READWRITE, &amp;oldProtect)) &#123;                pFuncAddressTable[index] = (DWORD)MyMessageBoxW - (DWORD)pBase;  // 此处存储的是RAV                VirtualProtect((LPVOID)&amp;pFuncAddressTable[index], sizeof(DWORD), oldProtect, &amp;oldProtect);                result = true;                break;            &#125;        &#125;    &#125;    return result;&#125;\n\n硬件断点 Hook硬件断点 Hook 的核心在于利用 CPU 的调试寄存器（DR0 ~ DR3）触发 EXCEPTION_SINGLE_STEP 异常，并通过 VEH 异常处理函数来劫持程序的执行流程，也可以通过该方式来劫持 ldrLoadDll 函数来实现 DLL 注入。\n主要步骤如下：\n\n注册 VEH 处理函数：使用 AddVectoredExceptionHandler 函数注册一个异常处理回调函数，并通常将第一个参数设为 1，以确保你的处理函数最先被调用。\n\n遍历并暂停线程：因为硬件断点是线程相关的，需要使用 CreateToolhelp32Snapshot 等函数遍历目标进程中的所有线程。对于每个需要设置的线程，先调用 SuspendThread 将其暂停。\n\n设置线程上下文：使用 GetThreadContext 获取线程的上下文结构（CONTEXT）。然后配置调试寄存器：\n\n将 DR0 到 DR3（中的一个）设置为你想要监控的内存地址。\n配置 DR7 控制寄存器，以启用特定的断点并设置其触发条件（如执行、写入）和长度。\n\n\n恢复线程执行：使用 SetThreadContext 应用新的上下文，然后调用 ResumeThread 恢复线程运行\n\n\n其中：\n\nDR7 寄存器中的 L0 ~ L3 位分别记录了 DR0 ~ DR3 局部断点是否启用。G0 ~ G3 分别记录了 DR0 ~ DR3 全局断点是否启用。\nLEN0 ~ LEN3 分别记录 DR0 ~ DR3 断点的长度，每个占 2 位。enum HWBP_LEN &#123;    HWBP_LEN_1 = 0,  // 二进制00，对应1 byte    HWBP_LEN_2 = 1,  // 二进制01，对应2 bytes    HWBP_LEN_8 = 2,  // 二进制10，对应8 bytes（仅x64）    HWBP_LEN_4 = 3   // 二进制11，对应4 bytes&#125;;\nR/W0 ~ R/W3 分别记录 DR0 ~ DR3 断点的类型，每个占 2 位。enum HWBP_TYPE &#123;    HWBP_EXECUTE = 0,    HWBP_WRITE = 1,    HWBP_READWRITE = 3&#125;;\n\n在设置硬件断点时，不需要使用 DR6 寄存器，但是异常处理回调中，却可以使用 DR6 寄存器来确定当前 EXCEPTION_SINGLE_STEP 异常是由哪个调试寄存器触发的，DR6 的第 0 ~ 3 位分别对应 DR0 ~ DR3 寄存器。\nint regIndex = -1; // DR0 ~ DR3if (ctx-&gt;Dr6 &amp; 0x1)    regIndex = 0;else if (ctx-&gt;Dr6 &amp; 0x2)    regIndex = 1;else if (ctx-&gt;Dr6 &amp; 0x4)    regIndex = 2;else if (ctx-&gt;Dr6 &amp; 0x8)    regIndex = 3;\n\n要配置线程的调试寄存器，首先要获取一个该线程没有被使用的调试寄存器。下面代码展示了如何通过 DR7 寄存器的 L0 ~ L3 位来判断调试寄存器是否已经被启用，返回的索引 0 ~ 3 分别代表 DR0 ~ DR3。\nint FindAvailableDebugRegister() &#123;    CONTEXT ctx = &#123;0&#125;;    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;    HANDLE hThread = GetCurrentThread();    if (!GetThreadContext(hThread, &amp;ctx))        return -1;    // 检查哪些调试寄存器可用    for (int i = 0; i &lt; 4; i++) &#123;        if (!(ctx.Dr7 &amp; (1 &lt;&lt; (i * 2))))            return i;    &#125;    return -1;&#125;\n\n在获取到可用的调试寄存器后，就可以将需要断住的内存地址赋值给该寄存器，当然，别忘了在 DR7 中配置局部启用该寄存器以及断点的类型（执行）和长度（1 字节）。\nCONTEXT ctx = &#123;0&#125;;ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;GetThreadContext(hThread, &amp;ctx);int regIndex = ...;// 设置断点地址switch (regIndex) &#123;    case 0:        ctx.Dr0 = address;        break;    case 1:        ctx.Dr1 = address;        break;    case 2:        ctx.Dr2 = address;        break;    case 3:        ctx.Dr3 = address;        break;&#125;ctx.Dr7 |= (1 &lt;&lt; (regIndex * 2)); // 局部启用位ctx.Dr7 |= (static_cast&lt;DWORD&gt;(type) &lt;&lt; (16 + regIndex * 4)); // 设置类型ctx.Dr7 |= (static_cast&lt;DWORD&gt;(len) &lt;&lt; (18 + regIndex * 4)); // 设置长度SetThreadContext(hThread, &amp;ctx);\n\n当断点位置处的代码被执行时，会进入 AddVectoredExceptionHandler 的异常处理回调函数。因为 EXCEPTION_SINGLE_STEP 类型的异常才是硬件断点异常，所以我们在回调函数中只处理 EXCEPTION_SINGLE_STEP 类型的异常，其他类型的异常直接返回 EXCEPTION_CONTINUE_SEARCH。\n通过 PCONTEXT 中的 EIP&#x2F;RIP 寄存器获取当前触发断点的地址，判断该地址是否为我们下断点的地址。如果是的，我们可以通过寄存器(x64)或堆栈(x86)来获取和修改参数的值。这个时候如果直接返回 EXCEPTION_CONTINUE_EXECUTION，程序会再次执行断点处的代码，从而再次进入异常处理回调函数，这样陷入了死循环（递归触发）。要解决这个问题，我们需要在返回 EXCEPTION_CONTINUE_EXECUTION 前清除断点（即清除 DR7 和 DR6 中的相关位）。\nint ClearHardwareBreadpoint(PCONTEXT ctx) &#123;    int regIndex = -1;    if (ctx-&gt;Dr6 &amp; 0x1)        regIndex = 0;    else if (ctx-&gt;Dr6 &amp; 0x2)        regIndex = 1;    else if (ctx-&gt;Dr6 &amp; 0x4)        regIndex = 2;    else if (ctx-&gt;Dr6 &amp; 0x8)        regIndex = 3;    if (regIndex != -1) &#123;        ctx-&gt;Dr7 &amp;= ~(1 &lt;&lt; (regIndex * 2)); // 清除Dr7中的局部启用位        ctx-&gt;Dr7 &amp;= ~(0x0F &lt;&lt; (16 + regIndex * 4)); // 清除类型和长度位        ctx-&gt;Dr6 &amp;= ~(1 &lt;&lt; regIndex); // 清除DR6上的指定位    &#125;    return regIndex;&#125;LONG CALLBACK VectoredExceptionHandler(PEXCEPTION_POINTERS pExceptionInfo) &#123;    if (!pExceptionInfo || !pExceptionInfo-&gt;ExceptionRecord) &#123;        return EXCEPTION_CONTINUE_SEARCH;    &#125;    DWORD exceptionCode = pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;    // 处理硬件断点异常    if (exceptionCode == EXCEPTION_SINGLE_STEP) &#123;        DWORD_PTR exceptionAddress = 0;#ifdef _WIN64        exceptionAddress = pExceptionInfo-&gt;ContextRecord-&gt;Rip;#else        exceptionAddress = pExceptionInfo-&gt;ContextRecord-&gt;Eip;#endif        // 检查是否在MessageBoxW地址        if (exceptionAddress == (DWORD_PTR)originalMessageBoxW) &#123;            PCONTEXT ctx = pExceptionInfo-&gt;ContextRecord;#ifdef _WIN64            ctx-&gt;R8 = (DWORD64)kReplacedCaption;            ctx-&gt;Rdx = (DWORD64)kReplacedMsg;#else#endif            int clearedRegIndex = ClearHardwareBreadpoint(ctx);            return EXCEPTION_CONTINUE_EXECUTION;        &#125;    &#125;    return EXCEPTION_CONTINUE_SEARCH;&#125;\n\n如果你只打算 Hook 一次 MessageBoxW，流程就到此结束了。但通常情况下，我们需要 Hook 每次对 MessageBoxW 的调用，所以我们需要找到一个合适的时机再次对 MessageBoxW 设置硬件断点。\n有两个时机可以再次对 MessageBoxW 设置断点：\n\n时机 1：从函数起始地址向下查找有效的 ret 指令，在该指令处设置断点，当断点触发时再次为 MessageBoxW 设置断点。这种方式是可行的，但是 ret 指令有多种形式，如 ret、ret 4、ret 8 等，查找 ret 指令的逻辑会比较复杂。\n\n时机 2：我们知道 call 指令会将函数的返回地址压入堆栈，因此我们可以通过 Rsp&#x2F;Esp 来获取函数返回地址，然后在返回地址上下断点，当断点触发时，再次在 MessageBoxW 上下断点，这种方式似乎更加优雅。\n\n\n下面介绍“时机 2”的实现方法（以 64 为程序为例）。\nLONG CALLBACK VectoredExceptionHandler(PEXCEPTION_POINTERS pExceptionInfo) &#123;    if (!pExceptionInfo || !pExceptionInfo-&gt;ExceptionRecord)        return EXCEPTION_CONTINUE_SEARCH;    DWORD exceptionCode = pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;    // 处理硬件断点异常    if (exceptionCode == EXCEPTION_SINGLE_STEP) &#123;        DWORD_PTR exceptionAddress = 0;        exceptionAddress = pExceptionInfo-&gt;ContextRecord-&gt;Rip;        // 检查是否在MessageBoxW地址        if (exceptionAddress == (DWORD_PTR)originalMessageBoxW) &#123;            PCONTEXT ctx = pExceptionInfo-&gt;ContextRecord;            ctx-&gt;R8 = (DWORD64)kReplacedCaption;            ctx-&gt;Rdx = (DWORD64)kReplacedMsg;            messageBoxWReturnAddress = *(DWORD_PTR*)ctx-&gt;Rsp;            int clearedRegIndex = ClearHardwareBreadpoint(ctx);            // 在返回地址处设置断点            if (messageBoxWReturnAddress &gt; 0) &#123;                SetHardwareBreakpoint(ctx, clearedRegIndex,(DWORD_PTR) messageBoxWReturnAddress, HWBP_EXECUTE, HWBP_LEN_1);            &#125;            return EXCEPTION_CONTINUE_EXECUTION;        &#125;        else if (exceptionAddress == messageBoxWReturnAddress) &#123;            PCONTEXT ctx = pExceptionInfo-&gt;ContextRecord;            int clearedRegIndex = ClearHardwareBreadpoint(ctx);            // 重新设置硬件断点            SetHardwareBreakpoint(ctx, clearedRegIndex, (DWORD_PTR) originalMessageBoxW, HWBP_EXECUTE, HWBP_LEN_1);            return EXCEPTION_CONTINUE_EXECUTION;        &#125;    &#125;    return EXCEPTION_CONTINUE_SEARCH;&#125;\n\n需要注意：在异常处理回调函数中设置硬件断点时，直接设置 PEXCEPTION_POINTERS-&gt;PCONTEXT 结构体中的寄存器即可，不要使用SetThreadContext函数，否则会出现断点不生效的问题。\n一些过时的内核 Hook 技术Windows 自 Vista 版本以来，就在 x64 系统中提供了一种内置的安全功能，该功能称为 PatchGuard（PG），用于保护内核的关键区域免遭修改，如果触发该机制就会导致系统蓝屏（BSOD）。\nPatchGuard 通过内核模式线程定时检测以下关键区域的完整性：\n\n系统服务描述符表（SSDT）：监控函数入口地址是否被篡改。\n全局描述符表（GDT）：校验中断处理程序的合法性。\n中断描述符表（IDT）：保护内存段描述符结构。\n系统映像（ntoskrnl.exe、ndis.sys、hal.dll）。\n处理器 MSR（系统调用）\n内核模块列表：验证加载驱动模块是否有效的数字签名。\n\n因此，在 x64 系统上，针对上面区域的 Hook 都已不再稳定有效。\nVT Hook这个有点复杂，待我整理好后再更新！\n","categories":["⑤Windows开发与调试秘籍"],"tags":["Hook","注入"]},{"title":"Modern CMake 简明教程（中）","url":"/post/2304457467.html","content":"CMake 是一个开源、跨平台的构建系统生成器（Build-system Generator）。\n本文是 Modern CMake 简明教程系列的中篇，上篇请移步   Modern-CMake简明教程-上 ‘《Modern CMake 简明教程（上）》’ \n本教程默认 CMake 最低版本为 3.16，即 cmake_minimum_required(VERSION 3.16)。\n\n生成器表达式不知你是否思考过这样一个问题：我们在编译项目时，通常有不同的配置，如 Debug 和 Release，如何在不同的配置中定义不同的预编译宏、包含不同的目录、依赖不同的库呢？\n其实要解决这个问题，并不困难，只需要使用到 CMake 中的 生成器表达式。我们在开源项目的 CMake 脚本中经常看到的 $&lt;...&gt; 这样的表达式就是生成器表达式，但通常都会嵌套使用，如 $&lt;$&lt;...&gt;:...&gt;。\n生成器表达式通常有下面几种形式：\n\n$&lt;condition:true_string&gt;\n$&lt;IF:condition,true_string,false_string&gt;\n$&lt;BOOL:string&gt;\n特定的语法形式，如 $&lt;CONFIG:cfgs&gt; 表示当前配置存在于 cfgs 列表中时，表达式结果为 1，否则为 0。\n\n前三种形式比较简单，最后一种形式虽然有多种类型，但我们通常只需要记忆几种常用的，有需要时查阅官方文档。\n$&lt;condition:true_string&gt;condition 只允许为 0 或 1，其他任何值都会报错。\n当 condition 为 1 时，表达式返回 true_string；\n当 condition 为 0 时，表达式返回空字符串。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;\n如：\nset(ENABLE_JSONCPP 1)target_include_directories(    my_lib PUBLIC     $&lt;$&#123;ENABLE_JSONCPP&#125;:$&#123;CMAKE_SOURCE_DIR&#125;/jsoncpp/include&gt;  )\n\n$&lt;IF:condition,true_string,false_string&gt;condition 只允许为 0 或 1，其他任何值都会报错。\n当 condition 为 1 时，表达式返回 true_string；\n当 condition 为 0 时，表达式返回 false_string。\n如下面示例，当设置了 ENABLE_JSONCPP 为 1 时，包含 jsoncpp 头文件，否则包含 rapidjson 头文件：\nset(ENABLE_JSONCPP 1)target_include_directories(    my_lib PUBLIC     $&lt;IF:$&#123;ENABLE_JSONCPP&#125;,$&#123;CMAKE_SOURCE_DIR&#125;/jsoncpp/include,$&#123;CMAKE_SOURCE_DIR&#125;/rapidjson/include&gt;  )\n\n$&lt;BOOL:string&gt;前面 2 种形式的 condition 都只允许为 0 或 1，这种限制未免有些呆板，如果 ENABLE_JSONCPP 的值不是 1 ，而是 ON 时，该怎么办呢？\n此时可以使用 $&lt;BOOL:string&gt; 将其转换成 0 或 1。\n何时转换成 0，何时转换成 1？可以参考前面的  Modern-CMake简明教程-上 ‘《Modern CMake 简明教程（上）》’  的“条件判断”章节，在该章节中介绍的所有为假的情况都会转换成 0，其他情况则转换成 1。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;该表达式的作用注定了其单独使用意义不大，通常都是和其他表达式一起使用，如将上面示例中的 ENABLE_JSONCPP 设置为 ON：\nset(ENABLE_JSONCPP ON)target_include_directories(    my_lib PUBLIC     $&lt;IF:$&lt;BOOL:$&#123;ENABLE_JSONCPP&#125;&gt;,$&#123;CMAKE_SOURCE_DIR&#125;/jsoncpp/include,$&#123;CMAKE_SOURCE_DIR&#125;/rapidjson/include&gt;  )\n\n逻辑运算运算符表达式也支持与、或、非三种逻辑运算，语法如下：\n$&lt;AND:conditions&gt;$&lt;OR:conditions&gt;$&lt;NOT:condition&gt;\n\n其中，condition 都只允许是 0 或 1，conditions（复数形式）表示可以是由逗号分割的多个条件列表。\n其他常见表达式条件CMake 还支持很多类型的生成器表达式，下面列举了一些常见的表达式，这些表达式通常都是用来作为上面介绍的表达式中的条件。\n# 字符串比较，string1 与 string2 相等则为 1，反之为 0$&lt;STREQUAL:string1,string2&gt;# 数值比较，相等为 1，反之为 0$&lt;EQUAL:value1,value2&gt;# 版本比较，v1 小于 v2 时为 1，反之为 0$&lt;VERSION_LESS:v1,v2&gt;# 其他版本比较$&lt;VERSION_GREATER:v1,v2&gt;$&lt;VERSION_EQUAL:v1,v2&gt;$&lt;VERSION_LESS_EQUAL:v1,v2&gt;$&lt;VERSION_GREATER_EQUAL:v1,v2&gt;# string 存在于 list列表中时为 1，反之为 0$&lt;IN_LIST:string,list&gt;# 当前配置名称$&lt;CONFIG&gt;# 当前配置存在于cfgs列表中时为 1，反之为 0$&lt;CONFIG:cfgs&gt;# 平台ID，见 CMAKE_SYSTEM_NAME$&lt;PLATFORM_ID&gt;# 当前平台ID存在于 platform_ids 列表中时为 1，反之为 0$&lt;PLATFORM_ID:platform_ids&gt;# C++编译器版本$&lt;CXX_COMPILER_VERSION&gt;# C++编译器版本与 version 匹配时为 1，反之为 0# $&lt;CXX_COMPILER_VERSION:version&gt;# 当前的C++编译器ID$&lt;CXX_COMPILER_ID&gt;# 当前的C++编译器ID存在于 compiler_ids 列表中时为 1，反之为 0$&lt;CXX_COMPILER_ID:compiler_ids&gt;# 目标存在时为 1，反之为 0$&lt;TARGET_EXISTS:tgt&gt;# 返回tgt目标的prop属性的值，如果未设置该属性，则返回空字符串$&lt;TARGET_PROPERTY:tgt,prop&gt;# 返回正在计算表达式的目标上的prop属性的值，如果未设置该属性，则返回空字符串$&lt;TARGET_PROPERTY:prop&gt;# 当使用 install(EXPORT) 导出属性时，返回 ... 内容，否则返回空$&lt;INSTALL_INTERFACE:...&gt;# 当使用 export()导出属性或者被同一构建系统内的另一个目标使用时，返回 ... 内容，否则返回空$&lt;BUILD_INTERFACE:...&gt;\n\n转义字符在生成器表达式中如果需要使用特殊字符，可以使用其转移字符。\n# &gt;$&lt;ANGLE-R&gt;# ,$&lt;COMMA&gt;# ;$&lt;SEMICOLON&gt;# &quot;# 需要 CMake &gt;= 3.30$&lt;QUOTE&gt;\n\n安装侠义的“安装”是将目标编译生成的文件拷贝到指定位置，CMake 中的安装包含但不限于拷贝文件，还可以执行脚本、修改权限等操作。\n上面这句话中，涉及到了2个术语，有必要解释一下。\n“目标编译生成的文件”在 CMake 中有个学名，叫 Output Artifacts，直译为输出工件，我更愿意将其翻译为“输出品”，不同类型的目标有不同的输出品，例如在 Windows 平台上，可执行程序输出 .exe 文件，动态库输出 .dll 文件（也可能包含 .lib 文件），静态库输出 .lib 文件…..\n\n请牢记 Artifacts 这个单词，在后面的很多定义中都会出现该词。\n\n“指定位置”，顾名思义，我们可以指定一个安装位置。CMake 会从 CMAKE_INSTALL_PREFIX 变量中读取安装位置，该变量有默认值，我们也可以修改该变量来改变安装位置。\n在不同的操作系统上，CMAKE_INSTALL_PREFIX 的默认值不同：\n\nWindows 系统：C:/Program Files/${PROJECT_NAME}写入该目录需要管理员权限，因此如果安装失败，请检查是否具有管理员权限。\nUNIX 系统：/usr/local\n\nCMAKE_INSTALL_PREFIX 指定的位置是安装目录的根目录，不同类型的输出品会存放在其不同的子目录中，如 .lib 文件存放在 lib 目录，.dll 和 .exe 文件存放在 bin 目录，头文件存放在 include 目录，这些子目录的具体名称可以通过 GNUInstallDirs 提供的若干变量来获取，如 CMAKE_INSTALL_BINDIR、CMAKE_INSTALL_LIBDIR、CMAKE_INSTALL_INCLUDEDIR 等。\nCMake 定义了下列常用的输出品种类（artifact-kind），这些种类在后面的 install 选项中会使用到：\n\nARCHIVE这种类型的输出品包含下列文件（默认位于 lib 目录）：   \n静态库，Windows 上是 .lib 文件，Linux 上是 .a 文件，但在 macOS 上标记为 FRAMEWORK 的除外。\n动态库的导入库，如 .lib 文件。\n在macOS系统上，为启用 ENABLE_EXPORTS 的共享库所创建的链接器导入文件（但标记为 FRAMEWORK 的情况除外）。\n\n\nLIBRARY这种类型的输出品很少用到。\nRUNTIME这种类型的输出品包含下来文件（默认位于 bin 目录）：   \n各个系统所支持的可执行文件，如 Windows 上的 .exe。\n动态库，如 .dll 和 .so 文件。\n\n\nOBJECTS与对象库（使用add_library(&lt;name&gt; OBJECT ...)方式定义）关联的对象文件。\nFRAMEWORK在 macOS 上，标有 FRAMEWORK 属性的静态库和共享库都被视为 FRAMEWORK 类型。\nBUNDLE在 macOS 上，标有 MACOSX_BUNDLE 属性的可执行文件被视为 BUNDLE 类型。\nPUBLIC_HEADER  \nPRIVATE_HEADER\n\ninstall使用 install 指令可以定义在安装时需要执行的操作，install 可以定义很多类型的操作，包含但不限于拷贝输出品到指定位置、执行脚本等。\n下面是 install 指令支持的调用形式：\ninstall(TARGETS &lt;target&gt;... [...])install(IMPORTED_RUNTIME_ARTIFACTS &lt;target&gt;... [...])install(&#123;FILES | PROGRAMS&#125; &lt;file&gt;... [...])install(DIRECTORY &lt;dir&gt;... [...])install(SCRIPT &lt;file&gt; [...])install(CODE &lt;code&gt; [...])install(EXPORT &lt;export-name&gt; [...])install(RUNTIME_DEPENDENCY_SET &lt;set-name&gt; [...])\n\n通过执行 make install 命令或者编译 CMake 生成的 INSTALL 项目，就可以执行 install 指令预先定义的安装操作。\n不同的安装命令安装 Target所谓安装 Target 就是将目标的输出品及其关联文件拷贝到指定位置。\ninstall(TARGETS &lt;target&gt;... [EXPORT &lt;export-name&gt;]        [RUNTIME_DEPENDENCIES &lt;arg&gt;...|RUNTIME_DEPENDENCY_SET &lt;set-name&gt;]        [&lt;artifact-option&gt;...]        [&lt;artifact-kind&gt; &lt;artifact-option&gt;...]...        [INCLUDES DESTINATION [&lt;dir&gt; ...]]        )\n\n&lt;artifact-option&gt; 用于指定与输出品相关的选项，可以是下面选项中的一个或多个（常用的选项主要是 DESTINATION 和 PERMISSIONS）：\n[DESTINATION &lt;dir&gt;][PERMISSIONS &lt;permission&gt;...][CONFIGURATIONS &lt;config&gt;...][COMPONENT &lt;component&gt;][NAMELINK_COMPONENT &lt;component&gt;][OPTIONAL] [EXCLUDE_FROM_ALL][NAMELINK_ONLY|NAMELINK_SKIP]\n\n第一组 &lt;artifact-option&gt; 所设置的选项应用于在本次调用中没有指定输出品类型时。\n我们通常会为不同类型的输出品指定不同的选项，如下面示例为不同类型的输出品指定了不同的安装位置：\nset_target_properties(hello_cmake PROPERTIES PUBLIC_HEADER include/my_lib.h)install(TARGETS hello_cmake    ARCHIVE DESTINATION $&#123;CMAKE_INSTALL_LIBDIR&#125;  # 仅为演示，这样写多此一举    RUNTIME DESTINATION $&#123;CMAKE_INSTALL_BINDIR&#125;  # 仅为演示，这样写多此一举    PUBLIC_HEADER DESTINATION $&#123;CMAKE_INSTALL_INCLUDEDIR&#125;/my_lib)\n\n\n在实际项目中，我们不会使用 PUBLIC_HEADER 来安装头文件，而是使用下面介绍的 install(DIRECTORY ... ) 命令。\n\nEXPORT选项EXPORT 是一个非常有用的选项，当我们的项目需要作为库被第三方使用时，为了让第三方能够通过 find_package 所查找到所安装的库，就需要在安装时生成 xxxConfig.cmake 文件。\n当然，仅仅通过在此指定 EXPORT 选项还不够，此处的 EXPORT 选项仅仅表示将 Target 所安装的输出品绑定到 &lt;export-name&gt; 上，后面我们还需要使用单独的 install(EXPORT ...) 语句来生成 xxxConfig.cmake 文件，详见下面的 “安装导出依赖项” 节。\n拷贝目录拷贝目录到指定位置，语法如下：\ninstall(DIRECTORY dirs...        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;        [FILE_PERMISSIONS &lt;permission&gt;...]        [DIRECTORY_PERMISSIONS &lt;permission&gt;...]        [USE_SOURCE_PERMISSIONS] [OPTIONAL] [MESSAGE_NEVER]        [CONFIGURATIONS &lt;config&gt;...]        [COMPONENT &lt;component&gt;] [EXCLUDE_FROM_ALL]        [FILES_MATCHING]        [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]         [EXCLUDE] [PERMISSIONS &lt;permission&gt;...]] [...])\n\n可以使用 TYPE 或 DESTINATION 来指定目标路径，其中 TYPE 的取值来自于 GNUInstallDirs 提供的若干变量，如 BIN 等同于 CMAKE_INSTALL_BINDIR 变量。\n示例：\ninstall(DIRECTORY ./common TYPE INCLUDE)install(DIRECTORY ./common DESTINATION &quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;&quot;)\n\n拷贝文件拷贝文件到指定位置，语法如下：\ninstall(FILES &lt;file&gt;...        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;        [PERMISSIONS &lt;permission&gt;...]        [CONFIGURATIONS &lt;config&gt;...]        [COMPONENT &lt;component&gt;]        [RENAME &lt;name&gt;] [OPTIONAL] [EXCLUDE_FROM_ALL])\n\n执行脚本在安装时执行脚本文件或者脚本代码，语法如下：\ninstall([[SCRIPT &lt;file&gt;] [CODE &lt;code&gt;]]        [ALL_COMPONENTS | COMPONENT &lt;component&gt;]        [EXCLUDE_FROM_ALL] [...])\n\n如果脚本文件的路径是相对路径，则该路径相对于当前项目的根目录（即 CMAKE_SOURCE_DIR 变量存储的路径）。\n示例：\ninstall(SCRIPT &quot;./my_lib/helper.cmake&quot;)\n\ninstall(CODE &quot;message(\\&quot;Sample install message.\\&quot;)&quot;)\n\n安装导出依赖项如果在安装 Target（见上面的5.2.1节） 时已经指定了 EXPORT 选项，则可以通过 install(EXPORT ...) 的形式来安装需要导出的依赖性，即生成 xxxConfig.cmake 文件，该文件名不是固定的，可以通过 FILE 选项来指定其他名称，但必须是 .cmake 类型的文件。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;\ninstall(EXPORT &lt;export-name&gt; DESTINATION &lt;dir&gt;        [NAMESPACE &lt;namespace&gt;] [FILE &lt;name&gt;.cmake]        [PERMISSIONS &lt;permission&gt;...]        [CONFIGURATIONS &lt;config&gt;...]        [CXX_MODULES_DIRECTORY &lt;directory&gt;]        [EXPORT_LINK_INTERFACE_LIBRARIES]        [COMPONENT &lt;component&gt;]        [EXCLUDE_FROM_ALL]        [EXPORT_PACKAGE_DEPENDENCIES])\n\n&lt;export-name&gt; 选项所指定的名称需要与在 install(TARGET ... EXPORT ...) 语句中指定名称一致。\n通常为了防止和其他库命名冲突，我们会使用 NAMESPACE 添加命名空间。\n在生成 xxxConfig.cmake 文件以后，就可以使用 find_package 来查找并引用依赖库了：\nfind_package(MyLib REQUIRED)target_link_libraries(OtherApp PRIVATE my_lib::my_lib)\n\n与 CMake 交互CMake 与构建项目交互的方式有两种:\n\n使用 configure_file 指令动态生成配置文件，通过配置文件的方式来将数据传递给项目，如在 C&#x2F;C++ 项目中动态生成 .h 文件。\n使用 file 指令创建配置文件，file 指令的功能非常强大，包含众多与文件相关的操作，如读写文件、下载上传文件、遍历目录等。\n\n本节只介绍 configure_file 指令，该指令用于根据模板文件在指定位置生成新的文件。\nconfigure_file(&lt;input&gt; &lt;output&gt;               [NO_SOURCE_PERMISSIONS | USE_SOURCE_PERMISSIONS |                FILE_PERMISSIONS &lt;permissions&gt;...]               [COPYONLY] [ESCAPE_QUOTES] [@ONLY]               [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])\n\n我们首先需要通过 &lt;input&gt; 选项来指定一个模板文件，虽然模板文件可以是任意的后缀名，但我们通常使用 .in 后缀名，例如我们需要通过模板文件生成 version.h 文件，则模板文件名为 version.h.in。\nconfigure_file 指令会将 &lt;input&gt; 模板文件中的诸如 @VAR@、${VAR}、$CACHE{VAR}、$ENV{VAR} 形式的变量都替换为对应变量的值，如果变量没有被定义，则替换为空字符串。\n我们通常还会指定 @ONLY 选项，指定该选项后，就只有 @VAR@ 形式的变量会被替换，而其他形式的变量会保留不变，这种方式虽然在生成 .h 文件时没有什么用途，但谁又说 configure_file 只能生成 .h 文件了？如果是生成 .cmake 文件，是不是就有作用了咧。\n// version.h.in#define VERSION_MAJOR @VERSION_MAJOR@#define VERSION_MINOR @VERSION_MINOR@#define VERSION_PATCH @VERSION_PATCH@#define BUILD_TIMESTAMP &quot;@BUILD_TIMESTAMP@&quot;\n\n# CMakeLists.txtstring(TIMESTAMP BUILD_TIMESTAMP &quot;%Y-%m-%d %H:%M:%S&quot;)set(VERSION_MAJOR 1)set(VERSION_MINOR 0)set(VERSION_PATCH 1)configure_file (    &quot;$&#123;CMAKE_SOURCE_DIR&#125;/include/version.h.in&quot;    &quot;$&#123;CMAKE_SOURCE_DIR&#125;/include/version.h&quot;)\n\n执行 CMake 脚本，动态生成的 version.h 内容如下：\n#define VERSION_MAJOR 1#define VERSION_MINOR 0#define VERSION_PATCH 1#define BUILD_TIMESTAMP &quot;2024-09-30 16:51:57&quot;\n\n上述变量替换的方式有一个弊端：虽然能动态替换模板语句中变量的值，但却不能控制语句是否存在。比如我们经常在 C&#x2F;C++ 项目中根据宏是否被定义来做判断，而不是根据宏的值来做判断：\n#ifdef BUILD_SHARED_LIBS#endif\n\n这个是时候就需要使用另外一个语法形式了：#cmakedefine VAR ...，在这种形式中是直接使用变量名的，而不需要使用 @ @ 进行包裹。\n当定义了 VAR 变量时，将替换为（…就是模板文件中 VAR 后面的内容）：\n#define VAR ...\n\n当没有定义 VAR 变量时，将替换为：\n/* #undef VAR */\n","categories":["②跨平台编译与部署"],"tags":["CMake"]},{"title":"Modern CMake 简明教程（下）","url":"/post/201509401.html","content":"CMake 是一个开源、跨平台的构建系统生成器（Build-system Generator）。\n本文是 Modern CMake 简明教程系列的下篇，上篇请移步至   Modern-CMake简明教程-上 ‘《Modern CMake 简明教程（上）》’ ，中篇请移步至   Modern-CMake简明教程-中 ‘《Modern CMake 简明教程（中）》’ 。\n本教程默认 CMake 最低版本为 3.16，即 cmake_minimum_required(VERSION 3.16)。\n\n集成第三方库在项目中集成第三方库是一种非常常见的需求，CMake 提供了两种方式来集成第三方库。\n第一种：直接集成第三方库的源码。\n说到集成第三方库的源码，我们第一时间想到的可能就是将其源码直接拷贝到项目目录中，然后提交到 git 仓库，更加高级一点可能会使用 git submodule 的方式。但我以为这两种方式都不够优雅，无法很好的管理、更新依赖库，特别是在项目的依赖库的比较多时。\nCMake 提供了两个模块（两种方式）来集成第三方库的源码：\n\nFetchContent该模块支持在 CMake 生成项目时就下载第三方库，还会自动将第三方库添加到项目中，不需要手动调用 add_subdirectory。\nExternalProject该模板支持在构建（编译）项目时下载第三方库。显然 ExternalProject 的下载时机要晚于 FetchContent 。\n\n第二种：使用预编译好的第三方库。\n这种方式需要先单独编译安装第三方库，然后使用 find_package 查找该库，最后设置目标的相关属性，如包含目录、依赖库等。\nFetchContentFetchContent 的使用大致分为两个步骤。\n步骤一： 使用 FetchContent_Declare 命令记录要获取的内容，可以多次调用 FetchContent_Declare 命令来记录获取多个内容。\nFetchContent_Declare 的定义如下：\nFetchContent_Declare(  &lt;name&gt;  &lt;contentOptions&gt;...  [EXCLUDE_FROM_ALL]  [SYSTEM]  [OVERRIDE_FIND_PACKAGE |   FIND_PACKAGE_ARGS args...])\n\n其中，&lt;name&gt; 可以是任何不带空格的字符串，并且该名称不区分大小写，但通常我们仅使用字母、数字和下划线。\n下面示例分别演示了如何从 Git 仓库、https链接、SVN仓库获取内容：\nFetchContent_Declare(  googletest  GIT_REPOSITORY https://github.com/google/googletest.git  GIT_TAG        703bd9caab50b139428cea1aaff9974ebee5742e # release-1.10.0)FetchContent_Declare(  myCompanyIcons  URL      https://intranet.mycompany.com/assets/iconset_1.12.tar.gz  # 下载完后，会自动解压  URL_HASH MD5=5588a7b18261c20068beabfb4f530b87)FetchContent_Declare(  myCompanyCertificates  SVN_REPOSITORY svn+ssh://svn.mycompany.com/srv/svn/trunk/certs  SVN_REVISION   -r12345)\n\n步骤二： 调用 FetchContent_MakeAvailable 命令开始获取上面声明的内容。\n如：\nFetchContent_MakeAvailable(googletest myCompanyIcons myCompanyCertificates)\n\n结果如果 FetchContent 执行成功，下面几个变量会设置：\n\n&lt;lowercaseName&gt;_POPULATED始终被设置为 TRUE\n&lt;lowercaseName&gt;_SOURCE_DIR目标内容的源码目录\n&lt;lowercaseName&gt;_BINARY_DIR目标内容的构建目录\n\n使用代理限于国内的网络环境，在获取内容时，很可能出现下载失败的情况，此时可以尝试使用 http 和 https 代理来解决该问题。\n通过设置相应的环境变量即可设置 http(s) 代理，如：\nset(ENV&#123;http_proxy&#125; &quot;http://127.0.0.1:7890&quot;)set(ENV&#123;https_proxy&#125; &quot;http://127.0.0.1:7890&quot;)\n\nfind_packagefind_package 用于查找已经安装到本机的包，将查找结果存储在 &lt;PackageName&gt;_FOUND 变量中（查找到包，值为 1，否则 为 0），包的安装路径存储在 &lt;PackageName&gt;_DIR 变量中，通常还会定义一些变量来指明包的版本、头文件目录的路径、.lib 或 .a 文件的路径等，这些变量名称的格式会根据查找方式的不同、包的不同而不同。\nfind_package 使用起来比较简单，通常我们只需要使用它的基础定义：\nfind_package(&lt;PackageName&gt; [&lt;version&gt;] [REQUIRED] [COMPONENTS &lt;components&gt;...])\n\n\n&lt;PackageName&gt;指定包的名称，是唯一的必选参数。\n&lt;version&gt;指定需要查找包的版本，major[.minor[.patch[.tweak]]]，支持多种形式的版本，如 3、3.1、3.1.2 等，可以指定匹配大版本还是小版本匹配等，也可以通过指定 EXACT 选项来要求版本完全一致，当然也可以完全省略版本约束。\nREQUIRED参数用于指定该包是必须找到，如果没有找到则停止执行该 CMake 脚本。\n\n\nfind_package 的完整定义可以见：full-signature\n\n下面示例用于查找大版本为 3 的 OpenCV 包：\nfind_package(OpenCV 3 REQUIRED)message(STATUS &quot;OpenCV_DIR = $&#123;OpenCV_DIR&#125;&quot;)message(STATUS &quot;OpenCV_INCLUDE_DIRS = $&#123;OpenCV_INCLUDE_DIRS&#125;&quot;)message(STATUS &quot;OpenCV_LIBS = $&#123;OpenCV_LIBS&#125;&quot;)\n\n不同的查找模式find_package 有两种查找包的方式，优先使用 Module 模式，如果 Module 模式没有查找到，再使用 Config 模式查找。\nModule 模式find_package 使用 Module 模式查找包就是查找 Find&lt;PackageName&gt;.cmake 文件的过程，会尝试在下面位置中查找该文件，优先级从高到低依次为：\n\nCMAKE_PREFIX_PATH该变量是以分号分隔的列表，默认为空，由用户设置；也可以定义环境变量 CMAKE_PREFIX_PATH，环境变量 $ENV{CMAKE_PREFIX_PATH} 定义的列表会附加到 ${CMAKE_PREFIX_PATH} 变量的后面。\nCMAKE_MODULE_PATH 该变量也是以分号分隔的列表，默认为空，由用户设置。\n\nFind&lt;PackageName&gt;.cmake 文件从何而来？\n如果你是库的开发者，你是不需要提供 Find&lt;PackageName&gt;.cmake 文件的，你只需要按照文章 《  Modern-CMake简明教程-中 》“安装导出依赖项”章节介绍的那样，在安装时生成 &lt;PackageName&gt;Config.cmake（或 &lt;lowercasePackageName&gt;-config.cmake 文件）即可，该文件可以用于 find_package 的 Config 模式查找。\n对于那些没有按照规范提供上述 Config 文件的库，才需要使用者来编写 Find&lt;PackageName&gt;.cmake，辅助查找包的安装路径。\nConfig 模式find_package 指令在大多情况下都是通过 Config 模式来查找到包的具体位置的。\nfind_package 使用 Config 模式查找包就是查找 &lt;PackageName&gt;Config.cmake或 &lt;lowercasePackageName&gt;-config.cmake 文件的过程。\n在 Config 模式下，&lt;PackageName&gt; 可以通过 NAMES 参数来指定多个需要匹配查找的包名（PackageName），例如下面查找 Qt5 或 Qt6 的方式：\nfind_package(QT NAMES Qt6 Qt5 REQUIRED COMPONENTS Widgets)\n\n而且在该模式下，find_package 查找 config 文件的步骤也非常复杂，尤其是可以根据不同开关来查找不同的路径，下面介绍几个常用的查找 config 文件的位置（完整的见官方文档），按优先级从高到低依次为：\n\n&lt;PackageName&gt;_DIR 变量或环境变量所指定的目录，默认为空。\nCMAKE_PREFIX_PATH、CMAKE_FRAMEWORK_PATH、CMAKE_APPBUNDLE_PATH 变量或环境变量所指定的目录，该变量是以分号分隔的列表，默认为空。\nPATH 环境变量所指定的目录，该变量是以分号分隔的列表，默认为系统 PATH 环境变量的值。如果该变量中的路径以 bin 或 sbin 结尾，则自动回退到上一级目录进行查找。\n\n与 Module 模式不同的是，在上述几个位置中，除了第 1 个指定的目录是“根目录”，CMake 只会在该目录的根目录下查找 &lt;PackageName&gt;Config.cmake或 &lt;lowercasePackageName&gt;-config.cmake 文件，不会进入其子目录中查找，如设置 OpenCV_DIR 为 /home/jack，CMake 只会查验如下文件：\n/home/jack/OpenCVConfig.cmake/home/jack/opencv-config.cmake\n\n而第 2、3 所指定的目录都是“路径前缀”，CMake 不仅会在根目录下查找 &lt;PackageName&gt;Config.cmake或 &lt;lowercasePackageName&gt;-config.cmake 文件，还会进入其子目录内查找。当然 CMake 不会无脑的遍历所有子目录，而且只在特定的子目录内进行查找，不同系统环境下所查找的子目录也不同，具体如下表所示。\n\n\n\n查找路径\n系统环境\n\n\n\n&lt;prefix&gt;/(cmake|CMake)/\nWindows\n\n\n&lt;prefix&gt;/&lt;name&gt;*/\nWindows\n\n\n&lt;prefix&gt;/&lt;name&gt;*/(cmake|CMake)/\nWindows\n\n\n&lt;prefix&gt;/&lt;name&gt;*/(cmake|CMake)/&lt;name&gt;*/\nWindows\n\n\n&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/\nUninx\n\n\n&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/\nUninx\n\n\n&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/(cmake|CMake)/\nUninx\n\n\n&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/\nWindows、Uninx\n\n\n&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/\nWindows、Uninx\n\n\n&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/(cmake|CMake)/\nWindows、Uninx\n\n\n在上表中，&lt;prefix&gt;就是第 2、3 项所指定的路径前缀；&lt;name&gt; 为包名，不区分大小写，&lt;name&gt;* 的意思是包名后面还可以接一些字符，如 OpenCV-3.0。\n结果获取无论是哪种查找模式，我们都需要获取查找的结果。目前我能确定的是，这两种查找模式都会定义 &lt;PackageName&gt;_FOUND 和 &lt;PackageName&gt;_DIR 变量，对于不同的库还会定义不同的变量，如何知道他们到底定义了哪些变量呢？&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;我有一个粗暴但好用的方法：在调试时，遍历当前 CMake 中的所有变量。\n下面 dump_all_variables 函数会输出当前 CMake 的所有变量：\nfunction(dump_all_variables)    get_cmake_property(_VARS VARIABLES)    foreach (_V $&#123;_VARS&#125;)        message(STATUS &quot;&gt;&gt;&gt;&gt;&gt;&gt; $&#123;_V&#125; = $&#123;$&#123;_V&#125;&#125;&quot;)    endforeach()endfunction()\n\n使用：\ndump_all_variables()\n\n集成 Qt在项目中集成 Qt 库需要先使用 find_package 查找 Qt 的安装位置。对于 Qt4， CMake 使用 Module 模式进行查找（FindQt4.cmake 由 CMake 提供），而 对于 Qt5、Qt6，则是使用 Config 模式进行查找，相应的 config 文件位于类似下面的目录中 D:\\Qt\\5.15.2\\msvc2019\\lib\\cmake。\n具体从哪些位置查找 Qt，参见上面的“find_package”章节。\n示例：\nfind_package(Qt6 COMPONENTS Widgets DBus REQUIRED)add_executable(publisher publisher.cpp)target_link_libraries(publisher Qt6::Widgets Qt6::DBus)find_package(Qt5 COMPONENTS Gui DBus REQUIRED)add_executable(subscriber1 subscriber1.cpp)target_link_libraries(subscriber1 Qt5::Gui Qt5::DBus)find_package(Qt4 REQUIRED)add_executable(subscriber2 subscriber2.cpp)target_link_libraries(subscriber2 Qt4::QtGui Qt4::QtDBus)\n\n众所周知，编译 Qt 代码需要依赖 Qt 提供的一些工具来生成相关的 C++ 代码，如：\n\nmoc元对象编译器，将 Qt 扩展的 C++ 语法（如 Q_OBJECT）转换成标准 C++ 语法。\nrcc把 .qrc 资源文件编译成标准 C++ 代码。\nuic把 .ui 文件编译成标准 C++ 代码。\n\n在 CMake 中要使用这些工具并不复杂，只需要提前开启相关特性，CMake 就会自动调用相关工具。\nset(CMAKE_AUTOMOC ON)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTORCC ON)\n\n下面是一个简单的 CMake Qt 项目示例，该示例仅使用了 Qt 的 QWidget 模块。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;源文件结构如下：\nCMakeLists.txtmain.cppmainwindow.cppmainwindow.hmainwindow.ui\n\nCMakeLists.txt 内容如下：\ncmake_minimum_required(VERSION 3.16)project(hello_qt)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTOMOC ON)set(CMAKE_AUTORCC ON)find_package(Qt5 REQUIRED COMPONENTS Widgets)add_executable(hello_qt    main.cpp    mainwindow.cpp    mainwindow.h    mainwindow.ui)target_link_libraries(hello_qt PRIVATE Qt5::Widgets)if(MSVC)    target_compile_options(hello_qt PRIVATE /execution-charset:utf-8)    set_target_properties(hello_qt PROPERTIES        WIN32_EXECUTABLE TRUE        VS_DEBUGGER_ENVIRONMENT &quot;PATH=$&#123;Qt5_DIR&#125;/../../../bin;%PATH%&quot;    )endif()install(TARGETS hello_qt)\n\n在上面示例中，设置了可执行字符集为 utf-8，这种方式可以防止 Qt 在 MSVC 环境下出现中文乱码，详见之前的文章   编程基础&#x2F;拨开字符编码的迷雾 。\n设置 WIN32_EXECUTABLE 属性是为了让链接器使用 /SUBSYSTEM:WINDOWS 子系统，如下图所示：\n\n而设置 VS_DEBUGGER_ENVIRONMENT 属性是为了设置 Visual Studio 的调试环境（如下图所示），确保在调试时能找到 Qt 的相关 dll 文件。\n\n\n在之前的   Modern-CMake简明教程-上  中已经介绍了目标属性的设置。\n\nMSVC设置 MSVC 运行库MSVC 的运行库有 MD &#x2F; MDd 和 MT &#x2F; MTd 之分，下图是 Visual Studio 中设置运行库的界面。\n\nCMake 针对 MSVC 环境默认使用的是 MD &#x2F; MDd 运行库，通过下面的方式可以将运行库设置为 MT &#x2F; MTd：\n# 需要 CMake 3.15 及以上版本set(CMAKE_MSVC_RUNTIME_LIBRARY &quot;MultiThreaded$&lt;$&lt;CONFIG:Debug&gt;:Debug&gt;&quot;)\n\n预编译头文件CMake 在 3.16 版本中提供了 target_precompile_headers 指令来添加预编译头文件，语法如下：\ntarget_precompile_headers(&lt;target&gt;  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [header1...]  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [header2...] ...])\n\n在 3.16 版本之前，需要支持预编译头，可以参考网络上的解决方案：\n定义 USE_MSVC_PCH 宏：\nmacro(USE_MSVC_PCH PCH_TARGET PCH_HEADER_FILE PCH_SOURCE_FILE)    if(MSVC)        # 获取预编译头文件的文件名，通常是stdafx        get_filename_component(PCH_NAME $&#123;PCH_HEADER_FILE&#125; NAME_WE)                # 生成预编译文件的路径        if(CMAKE_CONFIGURATION_TYPES)            # 如果有配置选项（Debug/Release），路径添加以及配置选项            SET(PCH_DIR &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/PCH/$&#123;CMAKE_CFG_INTDIR&#125;&quot;)        else()            SET(PCH_DIR &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/PCH&quot;)        endif()            # 创建预编译文件的路径        file(MAKE_DIRECTORY $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/PCH)            # 设置项目属性，使用预编译头文件        set_target_properties($&#123;PCH_TARGET&#125; PROPERTIES COMPILE_FLAGS             &quot;/Yu$&#123;PCH_HEADER_FILE&#125; /FI$&#123;PCH_HEADER_FILE&#125; /Fp$&#123;PCH_DIR&#125;/$&#123;PCH_NAME&#125;.pch&quot;)            # 预编译源文件（stdafx.cpp）设置属性，创建预编译文件        set_source_files_properties($&#123;PCH_SOURCE_FILE&#125; PROPERTIES COMPILE_FLAGS            &quot;/Yc$&#123;PCH_HEADER_FILE&#125;&quot;)                # 把预编译文件寄到清除列表        set_directory_properties(PROPERTIES            ADDITIONAL_MAKE_CLEAN_FILES $&#123;PCH_DIR&#125;/$&#123;PCH_NAME&#125;.pch)    endif()endmacro()\n\n然后使用该宏添加预编译头文件：\nUSE_MSVC_PCH(test_app stdafx.h stdafx.cpp)\n\n相关资料https://github.com/ttroy50/cmake-examples\nhttps://github.com/Akagi201/learning-cmake\nhttps://github.com/KDE/extra-cmake-modules\nhttps://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1\nhttps://hsf-training.github.io/hsf-training-cmake-webpage/aio/index.html\nhttps://github.com/rpavlik/cmake-modules\nhttps://github.com/onqtam/awesome-cmake\nhttps://github.com/Lectem/cpp-boilerplate\nhttps://github.com/CLIUtils/modern_cmake\nhttps://github.com/dev-cafe/cmake-cookbook\nhttps://github.com/BrightXiaoHan/CMakeTutorial\nhttps://cliutils.gitlab.io/modern-cmake/\nhttps://cgold.readthedocs.io/en/latest/\nhttps://www.siliceum.com/en/blog/post/cmake_01_cmake-basics\n","categories":["②跨平台编译与部署"],"tags":["CMake"]},{"title":"我删除了一部分文章","url":"/post/2403283032.html","content":"今天我做了一个重要的决定，我删除了博客中的大部分文章，后面我也会逐步闭源我的开源项目。\n我写技术文章一方面是作为自己的公开笔记，方便自己查阅，另一方面希望能帮助到后来者，让他们少走弯路，能够得到他们的一点赞美。软件行业也就是在这个你帮我，我帮你的良性循环下蓬勃发展起来的吧。\n但是AI时代的到来，让一切变了味。AI厂商忽视版权、开源协议等限制，将软件开发者为之付出心血的技术文章、开源代码用作其模型训练的素材，并整天吹捧着用AI大模型来取代程序员。暂且不谈AI能否取代程序员，就说没有程序员的无私奉献（数不尽的技术文章和开源代码），哪来这些AI大模型，这种杀鸡取卵的做法能否长久，让我们拭目以待吧。\n为什么现在炒的最火热AI应用总是集中在AI编程方面，因为过去的这些年，程序员为AI提供了太多训练素材。话说AI若真是屠龙之术，为何总盯着程序员的这一亩三分地，何不去搞我们国家被别人掐脖子的行业，真正的造福于民。\n曾一度我还在嘲笑那些构筑行业壁垒的行为，觉得软件行业的开源、分享是一件多么伟大的事情。现在看来，这是一件愚蠢的行为，当然很多人会反驳我的这个观点，他们可能会问既然开源这么不好，为什么Google把安卓系统开源了？这里的原因我不过多解释，请自行问AI。\n行业的健康发展建立在从业人员幸福指数提升的基础上，这好比一个国家即使再发达，它的人民生活的不幸福，那生活在这个国家又有什么意义了。\n我预测以后进行知识无偿知识分享的人会越来越少，而且越来越多的开源项目会逐渐走向闭源，这虽然不利用行业的发展，但对从业人员来说却是一件好事情。\n"},{"title":"玩转Qt 2D绘图之仪表盘实例","url":"/post/29874871.html","content":"在前面的《玩转 Qt 2D 绘图》系列文章中，已经介绍了 2D 绘图中常用的知识，本文主要通过一个汽车仪表盘的实例来综合应用前面所介绍知识点，并且还介绍了一些 Qt 绘图的常用技巧。\n相关文章：\n\nQt&#x2F;玩转Qt-2D绘图之坐标系 \nQt&#x2F;玩转Qt-2D绘图之画家的工具 \nQt&#x2F;玩转Qt-2D绘图之画家\n\n\n\n实例效果图如下：\n\n\n本实例主要涉及如下知识点：\n\n坐标系的缩小、旋转、位移\n绘制线条、圆、饼状图、多边形、文本\n画笔、画刷的应用\n三角函数的应用\n\n废话不多说，下面开始分布讲解仪表盘的绘制步骤。为了便于后面的描述，我们先将控件上的各个元素进行标注：\n\n\n坐标系设置圆的半径仪表盘是一个圆，因此需要先确定圆的中心点和半径，中心点位于 QWidget 的中心，而 QWidget 可能并不是正方形，因此只能以最短边来确定圆的半径。\nconst qreal width = this-&gt;width();const qreal height = this-&gt;height();const qreal side = qMin(width, height); // 最短边const qreal radius = side / 2.0; // 半径\n\n坐标系缩放假设当外圆的半径为 100 时，我们将内圆的半径设计为 85，中心圆的半径设计为 45，刻度数字字体设计为 10px，等等。 \n由于仪表板控件是一个通用型的控件，因此在实际应用中，其长宽并不固定为100px，其可以为任意值，为了保持美观和协调性，外圆、内圆、中心圆、数字字体等元素的大小都需要根据控件的大小而动态的改变。我们可以通过百分比的方式来设置各个元素的大小，如：\nqreal r1 = side / 2.0; // 外圆半径qreal r2 = r1 * 0.85; // 内圆半径为外圆的85%qreal r3 = r1 * 0.45; // 中心圆的半径// 字体大小则根据 半径100 -&gt; 10px 这个基础来缩小和放大qreal fz = 10 * (r1 / 100.0);\n\n看了上面的代码，相信大家已经有了明显的感受：需要手动计算百分比，太繁琐了，而且字体大小的缩放也不够线性。\n的确如此，针对这些问题，我们可以通过下面的方案来解决。\n在实际项目开发中，控件的样式通常不是程序员自己凭空想象的，而是经过设计师或美工设计出来的，设计师通过蓝湖、figma 等工具将效果图交付给开发人员，这些工具都带有尺寸标注功能，开发人员可以方便的获取设计尺寸。我们在开发时可以直接以设计尺寸来进行开发，不再计算百分比，改为动态的对坐标系进行缩放来适应实际尺寸。\nconst qreal width = this-&gt;width();const qreal height = this-&gt;height();const qreal side = qMin(width, height);painter.scale(side / 200.0, side / 200.0);  // 设计师所设计的的长宽为200*200\n\n坐标系原点为了方便绘制，我们通常还将坐标系的原点移动到圆的中心点位置，当然这不是必须的。\npainter.translate(width / 2, height / 2);\n\n绘制外圆控件是包含各种不同的元素，如外圆、内圆、刻度、指针等，一层一层的叠加在 QWidget 上面，从而组成了一个完整的控件。在绘制时，我们通常从最底层元素开始绘制，然后再一层一层地绘制上层元素。\n本实例中，我们先绘制外圆，然后绘制内圆，一层一层的叠加（本文的章节顺序即为元素的绘制顺序）。\n// 绘制外圆painter.save();&#123;    painter.setPen(Qt::NoPen);    painter.setBrush(QColor(80, 80, 80));    painter.drawEllipse(QPointF(0, 0), 100.0, 100.0);&#125;painter.restore();\n\n\n\n绘制内圆painter.save();&#123;    painter.setPen(Qt::NoPen);    painter.setBrush(QColor(60, 60, 60));    painter.drawEllipse(QPointF(0, 0), 85.0, 85.0);&#125;painter.restore();\n\n\n\n绘制三色饼状图// startAngle_ 和 endAngle_ 起始和结束角度// qreal startAngle_ = -30;// qreal endAngle_ = 210;painter.save();&#123;    qreal end = endAngle_;    qreal spanAngles = (endAngle_ - startAngle_) * 0.7;  // 0 ~ 70%    painter.setPen(Qt::NoPen);    painter.setBrush(QColor(24, 189, 155));    painter.drawPie(-55, -55, 110, 110, (end - spanAngles) * 16, spanAngles * 16);    end -= spanAngles;    spanAngles = (endAngle_ - startAngle_) * 0.15;  // 70% ~ 85%    painter.setBrush(QColor(218, 218, 0));    painter.drawPie(-55, -55, 110, 110, (end - spanAngles) * 16, spanAngles * 16);    end -= spanAngles;    spanAngles = (endAngle_ - startAngle_) * 0.15;  // 85% ~ 100%    painter.setBrush(QColor(255, 107, 107));    painter.drawPie(-55, -55, 110, 110, (end - spanAngles) * 16, spanAngles * 16);&#125;painter.restore();\n\n\n\n绘制中心圆绘制中心圆，用于覆盖饼圆的中心。\npainter.save();&#123;    painter.setPen(Qt::NoPen);    painter.setBrush(QColor(100, 100, 100));    painter.drawEllipse(QPointF(0, 0), 45, 45);&#125;painter.restore();\n\n\n\n绘制刻度线// majorScaleNum_ 指定有多少个大刻度线// scaleNumPerMajor_ 指定每2个大刻度线间隔内有多少个小刻度线// int majorScaleNum_ = 10;// int scaleNumPerMajor_ = 10;painter.save();&#123;    QPen pen;    pen.setColor(QColor(255, 255, 255));    pen.setCapStyle(Qt::RoundCap);    pen.setWidthF(1.0);    painter.setPen(pen);    int totalScaleNum = majorScaleNum_ * scaleNumPerMajor_;    qreal angleStep = (endAngle_ - startAngle_) / (qreal)totalScaleNum;    painter.rotate(360 - endAngle_);  // rotate 按顺时针方向旋转    for (int i = 0; i &lt;= totalScaleNum; i++) &#123;        if (i % scaleNumPerMajor_ == 0) &#123;            // 绘制大刻度            painter.drawLine(QPointF(57.0, 0.0), QPointF(72.0, 0.0));        &#125;        else &#123;            // 绘制小刻度            painter.drawLine(QPointF(57.0, 0.0), QPointF(64.0, 0.0));        &#125;        painter.rotate(angleStep);    &#125;&#125;painter.restore();\n\n\n\n绘制刻度数字因为数字始终是从左到右的方向绘制的，而绘制刻度时会改变坐标轴的方向，因此数字不能与刻度一起绘制。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;使用三角函数计算文字矩形区域下横线中间点位置。\npainter.save();&#123;    QPen pen;    pen.setColor(QColor(255, 255, 255));    painter.setPen(pen);    QFont font;    font.setPixelSize(10);    painter.setFont(font);    QFontMetrics fm(font);    int txtHeight = fm.height();    qreal angleStep = (endAngle_ - startAngle_) / majorScaleNum_;    qreal stepNum = (maxValue_ - minValue_) / majorScaleNum_;    for (int i = 0; i &lt;= majorScaleNum_; i++) &#123;        qreal angle = startAngle_ + i * angleStep;        qreal x = qCos(qDegreesToRadians(angle)) * 74.0;        qreal y = -qSin(qDegreesToRadians(angle)) * 74.0;  // 纵坐标与数学坐标系相反        QString txt = QString::number((int)((majorScaleNum_ - i) * stepNum));  // 大数在右边，小数在左边，先绘制大数        int txtWidth = fm.horizontalAdvance(txt);        if (IS_NEARLY_EQUAL(x, 0.0)) &#123;            painter.drawText(QRectF(x - txtWidth / 2, y - txtHeight, txtWidth, txtHeight), Qt::AlignCenter, txt);        &#125;        else if (IS_NEARLY_EQUAL(y, 0.0)) &#123;            painter.drawText(QRectF(x, y - txtHeight / 2, txtWidth, txtHeight), Qt::AlignVCenter | Qt::AlignLeft, txt);        &#125;        else &#123;            if (x &gt; 0.0)                painter.drawText(QRectF(x, y - txtHeight / 2, txtWidth, txtHeight), Qt::AlignVCenter | Qt::AlignLeft, txt);            else                painter.drawText(QRectF(x - txtWidth, y - txtHeight / 2, txtWidth, txtHeight), Qt::AlignVCenter | Qt::AlignRight, txt);        &#125;    &#125;&#125;painter.restore();\n\n\n\n绘制当前指针指针样式实际为三个点组成的三角形。\n// maxValue_ 和 minValue_ 为设置的刻度最大值和最小值// qreal minValue_ = 0.0;// qreal maxValue_ = 100.0;const qreal anglePerValue = (endAngle_ - startAngle_) / (maxValue_ - minValue_);painter.save();&#123;    painter.setPen(Qt::NoPen);    painter.setBrush(QColor(255, 107, 107, 204));    QPolygon pts;    pts.setPoints(3, 0, 5, 0, -5, 64, 0);    qreal rotateAngle = 360.0 - endAngle_;    rotateAngle += anglePerValue * (curValue_ - minValue_);    painter.rotate(rotateAngle);    painter.drawPolygon(pts);&#125;painter.restore();\n\n\n\n绘制中心小圆painter.save();&#123;    painter.setPen(Qt::NoPen);    // 红色圆    painter.setBrush(QColor(255, 107, 107));    painter.drawEllipse(QPointF(0.0, 0.0), 20.0, 20.0);    // 白色圆    painter.setBrush(QColor(255, 255, 255));    painter.drawEllipse(QPointF(0.0, 0.0), 16.0, 16.0);&#125;painter.restore();\n\n\n\n绘制当前值painter.save();&#123;    QFont font = painter.font();    font.setPixelSize(14);    font.setBold(true);    painter.setFont(font);    painter.setPen(QColor(0, 0, 0));    painter.drawText(-16, -16, 32, 32, Qt::AlignCenter, QString::number(curValue_));&#125;painter.restore();\n\n\n\n至此，大功告成，齐活！\n","categories":["④Qt奇趣屋"]},{"title":"玩转Qt 2D绘图之画家","url":"/post/1967189103.html","content":"在 Qt 2D 世界中，图形基本都由点、线、矩形、多边形、椭圆、圆、折线、曲线、文本、贴图等基本元素辅以着色而构成，而且 QPainter 类已经提供了这些元素的绘制方法，花点时间掌握这些方法，也就掌握了 Qt 2D 图形控件的制作，余下的就是勤学多练、孰能生巧了。\n\n\n点在 Qt 中使用 QPoint 或 QPointF 类型来表示一个点的坐标。\nQPoint 和 QPointF 的区别在于：QPoint 使用整型表示 X 和 Y 坐标，而 QPointF 使用 qreal 浮点类型表示 X 和 Y 坐标。下面如无特殊说明，所介绍的方法都适用于两个类型。\nQPoint 类型虽然提供了 isNull 方法来判断对象是否为空，在 X 和 Y 坐标均为 0 时，isNull 返回 true，其他情况返回 false。在使用 QPoint::isNull 方法时要留意这个情况。\n可以使用 QPoint::manhattanLength 方法返回 x 和 y 坐标的绝对值之和（也叫曼哈顿距离），如：\nQPoint pt(-2, 4);pt.manhattanLength(); // 6\n\n两点距离使用两点间的距离公式可以快速计算两点的距离：\n$\\left | AB \\right |&#x3D;\\sqrt{ {(x1-x2)}^2 + {(y1-y2)}^2 }$\n#include &lt;QtMath&gt;QPointF pt1(-2, 4);QPointF pt2(4, 8);qreal distance = qSqrt(qPow(pt1.x() - pt2.x(), 2.0) + qPow(pt1.y() - pt2.y(), 2.0)); // 7.21\n\ndrawPoint 与 drawPointsdrawPoint 用于绘制单个点：\nvoid drawPoint(const QPointF &amp;position)void drawPoint(const QPoint &amp;position)void drawPoint(int x, int y)\n\ndrawPoints 用于一次性绘制多个点：\nvoid drawPoints(const QPointF *points, int pointCount)void drawPoints(const QPolygonF &amp;points)void drawPoints(const QPoint *points, int pointCount)void drawPoints(const QPolygon &amp;points)\n\nQPolygon继承自 QVector&lt;QPoint&gt;，而QPolygonF继承自 QVector&lt;QPointF&gt;。\n折线折线是由多个点相连组成的非闭合线条（相邻的两个点连接成直线，但首位不相连）。\nvoid drawPolyline(const QPointF *points, int pointCount)void drawPolyline(const QPolygonF &amp;points)void drawPolyline(const QPoint *points, int pointCount)void drawPolyline(const QPolygon &amp;points)\n\n下面示例演示了折线的一种绘制方法，为了使线条更加圆润，我们还设置了线条的起落笔样式和相交点样式。\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  painter.setPen(QPen(Qt::red, 6, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));  QPolygon pg;  pg &lt;&lt; QPoint(20, 200) &lt;&lt; QPoint(80, 10) &lt;&lt; QPoint(140, 200) &lt;&lt; QPoint(200, 10);  painter.drawPolyline(pg);&#125;\n\n\n多边形多边形是在折线的基础上首尾相连而来，并且可以使用画刷对多边形的闭合区域进行填充。\n仍然使用上面示例中定义的点来绘制多边形，设置 QPainter 画刷颜色为蓝色：\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  painter.setPen(QPen(Qt::red, 6, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));  QPolygon pg;  pg &lt;&lt; QPoint(20, 200) &lt;&lt; QPoint(80, 10) &lt;&lt; QPoint(140, 200) &lt;&lt; QPoint(200, 10);  painter.setBrush(Qt::blue);  painter.drawPolygon(pg);&#125;\n\n\n线两点（QPoint 或 QPointF）可以确定一条直线，Qt 提供了 QLine 和 QLineF 类型来描述线段。\n使用 drawLine 方法可以绘制一条直线，使用 drawLines 方法则可以一次性绘制多条直线。\nvoid drawLine(const QLineF &amp;line)void drawLine(const QLine &amp;line)void drawLine(int x1, int y1, int x2, int y2)void drawLine(const QPoint &amp;p1, const QPoint &amp;p2)void drawLine(const QPointF &amp;p1, const QPointF &amp;p2)void drawLines(const QLineF *lines, int lineCount)void drawLines(const QVector&lt;QLineF&gt; &amp;lines)void drawLines(const QPointF *pointPairs, int lineCount)void drawLines(const QVector&lt;QPointF&gt; &amp;pointPairs)void drawLines(const QLine *lines, int lineCount)void drawLines(const QVector&lt;QLine&gt; &amp;lines)void drawLines(const QPoint *pointPairs, int lineCount)void drawLines(const QVector&lt;QPoint&gt; &amp;pointPairs)\n\n椭圆与圆椭圆椭圆有长轴、短轴、焦点等概念，建议在学习绘制椭圆之前先了解椭圆的这些概念，可以参考之前的文章   编程基础&#x2F;回顾2D绘图的数学知识  中的“椭圆”章节。\nQt 提供了 QPainter::drawEllipse 方法绘制椭圆，方法原型如下：\nvoid drawEllipse(const QRectF &amp;rectangle)void drawEllipse(const QRect &amp;rectangle)void drawEllipse(int x, int y, int width, int height)void drawEllipse(const QPointF &amp;center, qreal rx, qreal ry)void drawEllipse(const QPoint &amp;center, int rx, int ry)\n\ndrawEllipse 方法虽然有 5 种重载形式，但总体来说，都是传递一个矩形区域给 drawEllipse 方法，因为根据传入的矩形可以确定椭圆的长轴、短轴和焦点，其中长轴等于矩形的长，短轴等于矩形的高，2 个焦点分别位于 2 个长半轴的中间。\n下面示例先绘制了一个浅灰色的矩形（用于观察椭圆的绘制），然后在使用该矩形绘制椭圆。\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  QRectF rect(50, 50, 300, 200);  // 浅灰色的矩形  painter.setPen(Qt::lightGray);  painter.drawRect(rect);  // 红色椭圆  painter.setPen(Qt::red);  painter.drawEllipse(rect);&#125;\n\n\n圆圆是椭圆的一种特殊情况，当椭圆的长轴等于短轴时，所绘制出来的就是圆了。\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  // 宽 = 高  QRectF rect(50, 50, 300, 300);  painter.drawEllipse(rect);&#125;\n\n矩形在 Qt 中使用 QRect 和 QRectF 类型来表示矩形，在使用 QRect 时需要关注 QRect 的历史遗留问题，详见：  Qt&#x2F;玩转Qt-2D绘图之坐标系  的“QRect 遗留问题”章节。\n矩形的合法性QRect 和 QRectF 类型均提供了 isEmpty、isNull、isValid 方法，但 QRect 由于历史遗留问题，官方文档中对各个方法的定义看起来比较怪异，进行逻辑下面对其进行了逻辑运算，方便理解。\nQRect\nisEmpty() == left() &gt; right() || top() &gt; bottom()            == left() &gt; left() + width() - 1 || top() &gt; top() + height() - 1            == 1 &gt; width() || 1 &gt; height()isNull()  == (right() == left() - 1 &amp;&amp; bottom() == top() - 1)            == (left() + width() - 1 == left() - 1 &amp;&amp; top() + height() - 1 == top() - 1)            == (width() == 0 &amp;&amp; height() == 0)isValid() == left() &lt;= right() &amp;&amp; top() &lt;= bottom()            == left() &lt;= left() + width() - 1 &amp;&amp; top() &lt;= top() + height() - 1            == 1 &lt;= width() &amp;&amp; 1 &lt;= height()\n\nQRectF\nisEmpty() == width() &lt;= 0 || height() &lt;= 0isNull()  == width() == 0 &amp;&amp; height() == 0isValid() == width() &gt; 0 &amp;&amp; height() &gt; 0\n\n从上述定义可以发现，当前矩形的宽或高为负数时，isNull 返回的却是 false。\ndrawRect 与 drawRects&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;使用 drawRect 方法绘制单个矩形，使用 drawRects 方法一次性绘制多个矩形。\nvoid drawRect(const QRectF &amp;rectangle)void drawRect(int x, int y, int width, int height)void drawRect(const QRect &amp;rectangle)void drawRects(const QRectF *rectangles, int rectCount)void drawRects(const QVector&lt;QRectF&gt; &amp;rectangles)void drawRects(const QRect *rectangles, int rectCount)void drawRects(const QVector&lt;QRect&gt; &amp;rectangles)\n\n下面是一个简单的使用示例：\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  painter.drawRect(QRect(20, 20, 200, 200));  painter.setPen(Qt::red);  QVector&lt;QRect&gt; rects;  rects &lt;&lt; QRect(60, 60, 200, 200)        &lt;&lt; QRect(100, 100, 200, 200);  painter.drawRects(rects);&#125;\n\n\n圆角矩形上面绘制的矩形都不是圆角，在 Qt 中绘制圆角矩形有两种方式：\n\nQPainter::drawRoundedRect，本节主要介绍这种方法，这种方法绘制的圆角矩形的 4 个角的曲度一样。\nQPainter 还提供了 drawRoundRect 方法也可以绘制圆角矩形，但该方法已经被标记为弃用，因此不建议继续使用。\n\nQPainter::drawPath 通过路径的方式来绘制圆角矩形，这种方法绘制的圆角矩形的 4 个角的曲度可以不一样，该方法会在下面章节介绍。\n\n\nvoid QPainter::drawRoundedRect(const QRectF &amp;rect, qreal xRadius, qreal yRadius, Qt::SizeMode mode = Qt::AbsoluteSize)\n\n下面示例为了演示圆角矩形和普通的直角矩形的不同，先绘制了一个浅灰色直角矩形，然后再相同区域绘制了一个红色圆角矩形。\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  QRectF rect(50, 50, 300, 200);  // 先绘制一个浅灰色的矩形  painter.setPen(Qt::lightGray);  painter.drawRect(rect);  // 然后绘制一个红色圆角矩形  //  qreal xRadius = 20;  qreal yRadius = 40;  painter.setPen(QPen(Qt::red, 1, Qt::DashDotLine));  painter.drawRoundedRect(rect, xRadius, yRadius);&#125;\n\n\n7.4 xRadius 与 yRadiusxRadius 与 yRadius 参数决定了圆角的曲度，drawRoundedRect 方法绘制的圆角矩形的四个角采用同一个曲度。那么 xRadius 与 yRadius 参数是如何决定圆角的曲度的呢？\nxRadius 参数实际为椭圆的长半轴，yRadius 参数实际为椭圆的短半轴。\n\n关于椭圆的相关知识，可以参考之前的文章   编程基础&#x2F;回顾2D绘图的数学知识  中的“椭圆”章节。\n\n通过 xRadius 和 yRadius 参数确定了椭圆的长轴和短轴，那么在什么位置画椭圆呢？答案是：贴着四个顶角分别画 4 个椭圆来确定曲度。\n下面代码在上面示例的基础上，分别在左上角和右下角位置画了 2 个深黄色的椭圆，可以看到椭圆与圆角是刚好重合的。\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  QRectF rect(50, 50, 300, 200);  // 先绘制一个浅灰色的矩形  painter.setPen(Qt::lightGray);  painter.drawRect(rect);  // 然后绘制一个红色圆角矩形  //  qreal xRadius = 20;  qreal yRadius = 40;  painter.setPen(QPen(Qt::red, 1, Qt::DashDotLine));  painter.drawRoundedRect(rect, xRadius, yRadius);  // ~~~ 新增如下代码 ~~~  painter.setPen(QPen(Qt::darkYellow, 1, Qt::DashLine));  painter.drawEllipse(QRectF(rect.left(), rect.top(), xRadius * 2, yRadius * 2));  painter.drawEllipse(QRectF(rect.right() - xRadius * 2, rect.bottom() - yRadius * 2, xRadius * 2, yRadius * 2));&#125;\n\n\n椭圆上的一段线弧线（Arc）使用 drawArc 方法可以绘制一段弧线：\nvoid drawArc(const QRectF &amp;rectangle, int startAngle, int spanAngle)void drawArc(const QRect &amp;rectangle, int startAngle, int spanAngle)void drawArc(int x, int y, int width, int height, int startAngle, int spanAngle)\n\n在前面介绍的椭圆绘制方法中，我们通过指定一个矩形区域就可以绘制一个椭圆，而 drawArc 方法绘制曲线的则是该椭圆上的某一段弧线。通过 startAngle 参数指定弧线的起始角度，spanAngle 参数指定弧线所跨越的角度。\n需要注意：\n在 QPainter 的绘图函数中指定角度（不是弧度）时，以正三点钟方向为 0 度，角度按逆时针方向增长，整个圆按 5760 度计算（即 16 * 360）。\n在 GDI+ 中，也是以正三点钟方向为 0 度，但角度是按顺时针方向增长的，且整个圆按 360 度计算。\n下面的示例绘制一段红色的弧线，弧线从 30 度方向开始，弧线跨越了 120 度。\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  QRectF rect(50, 50, 300, 200);  // 浅灰色的矩形  painter.setPen(Qt::lightGray);  painter.drawRect(rect);  // 蓝色的椭圆  painter.setPen(Qt::blue);  painter.drawEllipse(rect);  // 红色的弧线  painter.setPen(Qt::red);  painter.drawArc(rect, 30 * 16, 120 * 16);&#125;\n\n实际绘制效果如下图所示：\n\n从上图可以看到，弧线实际是椭圆上的某一段曲线。\n饼状图（Pie）使用 drawPie 可以绘制饼状图，饼状图是在上面弧线（Arc）的基础上，分别将弧线的首尾与中心点相连而来，因此 drawPie 方法的参数也与 drawArc 方法一样。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;QPainter 在绘制饼状图时，会使用当前的画刷填充饼状图。\n下面的示例绘制了一个具有红色轮廓、黄色填充的饼状图。\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  QRectF rect(50, 50, 300, 200);  // 浅灰色的矩形  painter.setPen(Qt::lightGray);  painter.drawRect(rect);  // 蓝色的椭圆  painter.setPen(Qt::blue);  painter.drawEllipse(rect);  // 饼状图：红色的轮廓，黄色的填充  painter.setPen(Qt::red);  painter.setBrush(Qt::yellow);  painter.drawPie(rect, 30 * 16, 120 * 16);&#125;\n\n\n和弦图（Chrod）\n此处将 Chrod 按照英文直译成“和弦”可能不太准确\n\n和弦图（Chrod）与饼状图（Pie）一样，也是在弧线的基础上变化而来，将弧线的首尾相接就可得到和弦图（Chrod）。\n使用 drawChord 方法可以绘制和弦图，drawChord 方法的参数与 drawArc 一样。\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  QRectF rect(50, 50, 300, 200);  // 浅灰色的矩形  painter.setPen(Qt::lightGray);  painter.drawRect(rect);  // 蓝色的椭圆  painter.setPen(Qt::blue);  painter.drawEllipse(rect);  // 和弦图：红色的轮廓，黄色的填充  painter.setPen(Qt::red);  painter.setBrush(Qt::yellow);  painter.drawChord(rect, 30 * 16, 120 * 16);&#125;\n\n\n路径前面介绍了线、矩形、椭圆、圆、弧线、饼状图等形状，路径则是由若干个这些形状（不限于这些形状）组成的一个集合，路径可以是闭合的，也可以不闭合。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;在 Qt 中使用QPainterPath对象来定义一个路径，并使用如下方法向路径中添加形状：\n\naddEllipse 添加一个椭圆或圆到路径中\naddRect 添加一个矩形到路径中\naddRoundedRect 添加一个圆角矩形到路径中\naddText 将用指定字体绘制的文件所形成的闭合形状添加到路径中\nlineTo 添加一条直线到路径中\narcTo 添加一段圆弧到路径中arcTo 的原型如下，和 drawArc 方法类似，也需要指定起始角度和跨越角度，但与 drawArc 方法不同的是，arcTo 方法指定的角度是以 360 度整圆计算的，因此不需要乘以 16。void QPainterPath::arcTo(const QRectF &amp;rectangle, qreal startAngle, qreal sweepLength)\ncubicTo 添加一个三次贝塞尔曲线到路径中\nquadTo 添加一个二次贝塞尔曲线到路径中\n\n在上面方法中，命名格式为“*To”的方法，如 lineTo、arcTo、quadTo 等，都是基于“当前位置”来添加形状的，默认的当前位置为当前的坐标原点 (0,0) 处，我们可以使用 QPainterPath::currentPosition 方法获取当前位置。\n\n我们知道可以通过 QPainter::translate 等方法变换逻辑坐标，QPainterPath 的当前位置也会受逻辑坐标变换的影响。\n\n在使用 lineTo 添加直线到路径中时，只有指定直线的结束点，会自动将当前位置与结束点相连，形成一条直线，并重设当前位置为该结束点。\n在使用 arcTo、cubicTo、quadTo 添加曲线到到路径中时，会自动将当前位置与曲线起点相连，并重设当前位置为曲线结束点。\n我们使用一个示例来说明当前位置和结束点的关系，下面示例先添加一条直线，然后添加一个曲线，最好再添加一条直线：\n// 示例：当前位置void Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  QPainterPath path;  path.lineTo(80, 50);  path.arcTo(QRectF(50, 50, 300, 200), 30, 120);  path.lineTo(200, 200);  painter.drawPath(path);&#125;\n\n实际效果如下图所示：\n\n填充规则路径可以是闭合的也可以是非闭合的，例如上面的当前位置示例中的路径是非闭合的，但如果为 QPainter 指定了画刷，QPainter 会自动使用一条直线连接该非闭合形状的首尾，使其闭合，进而使用画刷对其填充。\nQPainterPath 有两种填充规则，可以通过QPainterPath::setFillRule方法来设置填充规则：\n\nQt::OddEvenFill\n奇偶填充规则，从一点向图形外引一条水平线，该线和图形的边线相交，如果交点的个数为奇数，则该点在图形中。\n\nQt::WindingFill非零弯曲规则，从一点向图形外引一条水平线，该线与图形的边线相交。如果边线是顺时针绘制的，则记为 1，如果边线是逆时针绘制的，则记为-1。最后将所有结果相加的和为 0 则该点在图形中。（矩形和椭圆都按顺时针绘制）\n\n\n\n文本文字有颜色、字体、样式等属性。\nQt 不仅可以绘制纯色的文本，还可以使用渐变色、图片等内容来填充文字，比如下面两种方式都可以用来绘制渐变色的文字：\n\n先将文字转变成路径（参考QPainterPath::addText），然后使用渐变画刷填充该路径。\n直接为 QPen 设置渐变画刷。\n\n通过为 QPainter 设置 QFont 对象来修改字体，字体有字体族、字号、粗体、斜体、下划线、删除线等样式或效果：\nQFont font;font.setFamilies(&#123;&quot;Microsoft YaHei&quot;, &quot;Arial&quot;&#125;);  // 字体族font.setPixelSize(26);                  // 字号font.setBold(true);                     // 粗体font.setItalic(true);                   // 斜体font.setUnderline(true);                // 下划线font.setStrikeOut(true);                // 删除线painter.setFont(font);\n\n使用 QPainter::drawText 方法绘制文本，该方法原型有很多种，但大多是通过下面 2 个原型进行重载而来的：\nvoid QPainter::drawText(const QRectF &amp;rectangle, int flags, const QString &amp;text, QRectF *boundingRect = nullptr)void QPainter::drawText(const QRectF &amp;rectangle, const QString &amp;text, const QTextOption &amp;option = QTextOption())\n\n间距间距分为两种情况：\n\n每个字符的间距，如单个英文字母或单个汉字的间距，称为 Letter Spacing。\n每个英文单词的间距，称为 Word Spacing。\n\n单词间距使用 QFont::setWordSpacing 和 QFont::wordSpacing 方法设置和获取单词的间距。\nvoid QFont::setWordSpacing(qreal spacing)\n\n当 setWordSpacing 参数大于 0 时，单词间距增加相应的像素；小于 0 时，间距减少相应的像素。\n字符间距使用 QFont::setLetterSpacing 和 QFont::letterSpacing 方法设置和获取字符的间距。\nvoid QFont::setLetterSpacing(QFont::SpacingType type, qreal spacing)\n\n字符间距支持百分比和绝对值两种设置方法，通过 QFont::SpacingType 枚举类型指定。\n\nQFont::PercentageSpacing\n百分比方式。值为 100 时表示不做任何改变，200 表示间距扩大到原来的一倍，-200 表示间距缩小到原来的一倍。\n\nQFont::AbsoluteSpacing\n绝对值方式，与设置单词间距的方式一样。\n\n\n小型大写字母小型大写字母（英语：small capitals，简称 small caps）是西文字体设计中的一种字符形式。这些字母的形状（字形）和大写字母相同但尺寸较小，比如在表示键盘快捷键的时候也常用小型大写字母。\n在 Qt 中通过设置 QFont 的 Capitalization 样式为 SmallCaps 风格来使用小型大写字母样式，如：\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  QPen pen;  pen.setBrush(Qt::red);  pen.setWidthF(20);  QFont font;  font.setPixelSize(26);  font.setCapitalization(QFont::SmallCaps);                            ^^^^^^^^^^^^^  painter.setFont(font);  painter.drawText(10, 30, &quot;The Keyboard Shortcut is Ctrl + Shift + K&quot;);&#125;\n\n效果如下图所示（留意全小写的“is”和其他首字母大写的单词）：\n\nCapitalization 还支持设置如下风格：\n\nQFont::MixedCase 默认，不做更改\nQFont::AllUppercase 全部小写\nQFont::AllLowercase 全部大写\nQFont::Capitalize 首字母大写\n\n计算绘制文本所需空间有两种方式可以计算按指定字体绘制文本所需的空间。\n方式一：使用 QPainter::drawText\n使用如下函数原型：\nvoid QPainter::drawText(const QRectF &amp;rectangle, int flags, const QString &amp;text, QRectF *boundingRect = nullptr)\n\n将参数 rectangle 的 宽和高都设置为 0，函数会通过 boundingRect 参数返回绘制文本所需要的宽和高。\n方式二：使用 QFontMetricsF\nQFontMetrics 或 QFontMetricsF 可以按照指定字体来计算给定字符和字符串的宽和高。\n这种方式的弊端在于：不能将绘制风格（如居中对齐、多行文本）带入其中进行计算，只能计算给定的单行字符串按照指定的字体显示所需的宽高。\nQFont font;font.setPixelSize(36);QFontMetricsF fm(font);qDebug() &lt;&lt; fm.horizontalAdvance(&quot;Hello World&quot;); // 字符串所占宽度qDebug() &lt;&lt; fm.height(); // 字体的高度\n\n贴图QPainter 提供了 drawPixmap 和 drawImage 两个常用的贴图函数，drawPixmap 用于绘制 QPixmap 对象，而 drawImage 用于绘制 QImage 对象，QImage 与 QPixmap 间是可以相互转化，因此 drawPixmap 和 drawImage 方法的效果是一样的。\ndrawPixmap 方法在屏幕上绘制速度更快，而 drawImage 方法则在 QPrinter 和其他设备上绘制的更快。\n需要注意：QPicture 对象用于记录绘制步骤，而 QPainter::drawPicture 方法用于重复 QPicture 对象所记录的步骤。\ndrawPixmap 和 drawImage 方法有多个重载的原型，其参数从左到右依次为：\n目标区域 -&gt; QPixmap/QImage -&gt; 源区域\n\n目标区域会应用当前 QWidget 的 devicePixelRatio，而源区域则与 devicePixelRatio 无关，具体参考   Qt&#x2F;Qt开发路上的“绊脚石”与“垫脚石” \n","categories":["④Qt奇趣屋"]},{"title":"玩转Qt 2D绘图之画家的工具","url":"/post/1336811290.html","content":"软件是对现实世界的抽象，在设计软件接口时通常也会参考现实世界来进行设计。\n在现实世界中，画家使用画笔、画刷这些工具在宣纸上作画，而在 Qt 中，画家是 QPainter 对象（画家的大脑则是 QPaintEngine），纸张可以是 QPaintDevice 的任何子类对象，如 QWidget、QImage、QPixmap、QGLPixelBuffer 等；在 QPainter 选好纸张后，就可以使用画笔来勾勒物体的轮廓了，Qt 中的画笔是 QPen 对象；画完轮廓后，可能还需要使用画刷来填充轮廓，Qt 中的画刷是 QBrush 对象。\n\n\nQPaintDevice本节介绍 QPaintDevice 的几个常用方法。\ndevicePixelRatio() 与 devicePixelRatioF()\n用于获取DPI的缩放倍数，需要先在程序中开启DPI缩放特性：\nint main(int argc, char *argv[])&#123;    QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling);    QGuiApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);#if (QT_VERSION &gt;= QT_VERSION_CHECK(5, 14, 0))    QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough);#endif    // .......&#125;\n\n从 Qt 5.14 版本开始，Qt可以支持小数位的 DPI 缩放，如 1.25、1.75 等。如需获取小数位DPI值，需要先设置Qt::HighDpiScaleFactorRoundingPolicy::PassThrough策略，然后通过 devicePixelRatioF 方法获取。\nwidth() 与 height()\n用于获取 QPaintDevice 的宽和高，这个数值不会随着坐标系的改变而改变，而且也不会随着 DPI 的改变而改变。\nwidthMM() 与 heightMM()\n用于获取 QPaintDevice 在屏幕上实际显示的宽和高，单位为毫米。\nQPen画笔有宽度（width&#x2F;widthF）、颜料（brush）、线条样式（Style）、一条线起笔和落笔的样式（CapStyle）、两条线相交处的样式（JoinStyle）等属性。\n宽度void QPen::setWidth(int width)void QPen::setWidthF(qreal width)\n\n如果指定的宽度小于 0，将不会绘制任何内容；如果指定的宽度等于 0，将被视为 1 个像素宽度；如果指定的宽度大于等于 1，则按指定的宽度来绘制。\nQPen的画刷void QPen::setBrush(const QBrush &amp;brush)\n\nQPen 有画刷属性，QPainter 对象也画刷属性（下面章节会介绍），二者都有填充之意，QPen 的画刷是用来填充画笔所画的线条（可以理解为画笔的颜料）的，而QPainter 的画刷是用来填充画笔所画的轮廓区域的，如填充矩形里面的区域。\n画刷可以是纯色、渐变色，也可以是图片。\n线条样式void QPen::setStyle(Qt::PenStyle style)\n\n\n起落笔样式void QPen::setCapStyle(Qt::PenCapStyle style)\n\n\n拐点样式void QPen::setJoinStyle(Qt::PenJoinStyle style)\n\n\n实例下面示例指定了画笔的如下属性：\n\n画笔的宽度为 70px\n使用红色画刷\n线条样式为通过若干空格分割的点线状\n线条起笔和落笔处为圆形\n线条拐点处也为圆形\n\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  QPen pen;  pen.setWidth(70);  pen.setBrush(Qt::red);  pen.setStyle(Qt::DotLine);  pen.setCapStyle(Qt::RoundCap);  pen.setJoinStyle(Qt::RoundJoin);  painter.setPen(pen);  painter.drawLine(50, 50, 600, 50);  painter.drawLine(600, 50, 600, 600);&#125;\n\n实际绘制出来的效果如下图所示：\n\n上面画笔使用红色作为颜料，也可以使用渐变色作为颜料，当然还可以使用图片作为颜料。\n下面我们将颜料更改为一个红色的心形♥图片：\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  QPen pen;  pen.setWidth(70);  pen.setBrush(QImage(&quot;:/heart.png&quot;)); // 仅修改了此行代码                    ~~~~~~~~~~~~~~  pen.setStyle(Qt::DotLine);  pen.setCapStyle(Qt::RoundCap);  pen.setJoinStyle(Qt::RoundJoin);  painter.setPen(pen);  painter.drawLine(50, 50, 600, 50);  painter.drawLine(600, 50, 600, 600);&#125;\n\n绘制的效果如下：\n\nQBrushQPen 与 QPainter 都有画刷属性，这里的 QBrush 是指的 QPainter 的画刷。虽然与 QPen 的画刷都为 QBrush 类型，但二者是有区别的，QPen 的画刷是用来填充画笔所画线条（可以理解为画笔的颜料）的，而 QPainter 的画刷是用来填充画笔所画的轮廓所包围的区域，如填充矩形里面的区域。\n如下面示例：\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  QPen pen;  pen.setWidth(6);  pen.setBrush(Qt::red);  painter.setPen(pen);  painter.setBrush(Qt::blue);  painter.drawRect(50, 50, 200, 200);&#125;\n\n实际绘制的矩形如下图所示：\n\nQBrush 有样式（Style）、颜色（Color）、渐变色（Gradient）、纹理图片（Texture）等属性。\n样式画刷的作用是填充区域，画刷的样式则是用来指定通过什么模式来填充区域的。\n下图列出了 QBrush 支持的样式：\n\nQBrush的初始样式是 Qt::NoBrush，即不做填充操作，该值显然是没有任何意义的，下面是一个错误的使用示例；\n// 错误示例QBrush brush;brush.setColor(Qt::red); // 画刷仍然是 Qt::NoBrush样式，不会填充任何颜色\n\n我们可以通过构造函数和 setStyle 方法来设置样式：\nQBrush(Qt::BrushStyle style)void setStyle(Qt::BrushStyle style)\n\n当通过不同的方式构造 QBrush 对象时，QBrush 的样式也会自动被设置为不同的值：\n// 样式自动被设置为渐变样式：Qt::LinearGradientPattern, Qt::RadialGradientPattern 或 Qt::ConicalGradientPatternQBrush(const QGradient &amp;gradient) // 样式自动被设置为纹理样式Qt::TexturePatternQBrush(const QImage &amp;image)          QBrush(const QPixmap &amp;pixmap)QBrush(Qt::GlobalColor color, const QPixmap &amp;pixmap)QBrush(const QColor &amp;color, const QPixmap &amp;pixmap)\n\n纹理图片上面2.6节的实例中，在设置心形图片作为QPen的画刷时，使用的就是纹理图片。\n下面汇总了设置 QBrush 纹理图片的几种方法：\n// 通过构造函数QBrush(const QImage &amp;image)QBrush(const QPixmap &amp;pixmap)QBrush(Qt::GlobalColor color, const QPixmap &amp;pixmap)QBrush(const QColor &amp;color, const QPixmap &amp;pixmap)// 通过成员方法void setTexture(const QPixmap &amp;pixmap)void setTextureImage(const QImage &amp;image)\n\n通过上面方式设置纹理图片后，QBrush 样式会被自动修改为 Qt::TexturePattern，因为纹理图片只能与 Qt::TexturePattern 样式配合使用，否则纹理图片将失效。\n纯色可以为画刷指定纯色或渐变色，纯色使用 QColor 对象表示。\n常用的构造 QColor 对象的方式有如下几种：\nQColor(&quot;#FFFFFF&quot;); //  r g bQColor(&quot;#AAFFFFFF&quot;); // a r g bQColor(255, 255, 255, 255); // r g b aQColor(Qt::red); // Qt::GlobalColor 枚举值\n\n渐变色QBrush 只提供了一种方式来指定渐变色：\nQBrush(const QGradient &amp;gradient)\n\n在Qt中，渐变色使用 QGradient 及其子类表示，目前Qt支持三种类型的渐变：\n\n线性渐变，对应 QLinearGradient 类。\n锥形渐变，对应 QConicalGradient 类。\n径向渐变，又分为简单径向渐变和扩展径向渐变，二者都对应 QRadialGradient 类。\n\n下图是一个从左到右，由白到黑的渐变过程：\n\n填充方向既然可以从左到右、从右到左的、从里到外，是可以360度旋转等等，不同的填充方向造就了不同类型的渐变，上述三种类型的渐变主要区别也在填充方向的不同。\n线性渐变QLinearGradient 构造函数如下：\nQLinearGradient(qreal x1, qreal y1, qreal x2, qreal y2)QLinearGradient(const QPointF &amp;start, const QPointF &amp;finalStop)\n\n通过指定一个起点和一个终点就可以确定一条线段的长度及方向，这个方向就是填充方向，渐变范围基于该长度而确定（详见后面的“渐变范围”章节）。\n线性渐变的方向可以是水平的，也可以是垂直的，还可以是斜着的，具体方向由线段与X轴的夹角来决定。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;下面我们定义一个起点为(0,0)、终点为(0,400)，垂直方向的线性渐变，然后使用该渐变填充位置在 (0,0)，宽高为 200x400 的矩形（请注意矩形的位置和大小，这个与渐变的起止位置有关，后面会详细介绍）：\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  QLinearGradient linearGrad(QPointF(0, 0), QPointF(0, 400));  linearGrad.setColorAt(0, Qt::black);  linearGrad.setColorAt(1, Qt::white);  QBrush brush(linearGrad);  painter.setBrush(brush);  painter.drawRect(0, 0, 200, 400);&#125;\n\n效果如下图所示：\n\n由于是垂直方面的渐变，所以渐变色从上到下变化的，颜色起始于黑色，终止于白色。\n渐变色的起止颜色由setColorAt方法设置，该方法原型如下：\nvoid QGradient::setColorAt(qreal position, const QColor &amp;color)\n\nsetColorAt 不仅接受颜色参数，还支持 postion 参数，position 参数的范围是[0,1]。线性渐变通过起止位置确定了一条带方向的线段，而 position 参数则用于确定线段上的一个具体位置，结合position和color参数就可以表示在某一位置的颜色值。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;可以使用 setColorAt 方法指定多个在[0,1]之间的位置及该位置的颜色，Qt会自动在多个颜色之间插入过渡色，达到平滑过渡的效果。\n现在我们在 0.3 位置插入一个骚气的红色，0.5位置插入黄色，其他都保持不变：\nlinearGrad.setColorAt(0, Qt::black);linearGrad.setColorAt(0.3, Qt::red);linearGrad.setColorAt(0.8, Qt::yellow);linearGrad.setColorAt(1, Qt::white);\n\n效果如下图所示：\n\n渐变范围在上面一节，我们强调了所绘制的矩形的位置&#x2F;大小与渐变的起止位置有关，而且又强调了 position 参数所确定是线段上的具体位置。其根本原因就在于渐变是有位置和范围的。\n对于线性渐变而言，渐变的范围是起始点和终止点间的线段，但颜色在垂直于该线段的方向却是无限扩充的，下面示例可以很好的说明这一特性。\n// Qt2DSample窗口长宽为600x600void Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  QLinearGradient linearGrad(QPointF(150, 150), QPointF(450, 450));  linearGrad.setColorAt(0, Qt::yellow);  linearGrad.setColorAt(0.5, Qt::red);  linearGrad.setColorAt(1, Qt::white);  QBrush brush(linearGrad);  painter.setBrush(brush);  painter.drawRect(0, 0, 600, 600);  // 不使用画刷，绘制 左上角 -&gt; 右下角 为线性渐变起止点的矩形  painter.setBrush(Qt::NoBrush);  painter.drawRect(150, 150, 300, 300);&#125;\n\n效果如下图所示：\n\n从上图可以看到，渐变色在垂直于渐变线段（中间矩形的左上角和右下角连成的斜线）方向无限扩展，但为什么在渐变范围边界以外还有颜色呢？如左上角的黄色和右下角的白色，这个与渐变的另一个属性特性有关 – 渐变传播，后面章节有详细介绍。\n锥向渐变QConicalGradient 类的构造函数如下：\nQConicalGradient(qreal cx, qreal cy, qreal angle)QConicalGradient(const QPointF &amp;center, qreal angle)\n&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;锥向渐变通过中心点（center）和起始角度来（angle）来所连接的直线确定填充的初始方向，然后从该直线开始逆时针进行360度填充，而且每个角度的颜色都是无限向外传播的。\n\n// Qt2DSample窗口长宽为200x200void Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  // 设定中心点刚好在窗口中心，起始角度为45度  QConicalGradient conicalGrad(QPointF(100, 100), 45);  conicalGrad.setColorAt(0, Qt::yellow);  conicalGrad.setColorAt(0.5, Qt::red);  conicalGrad.setColorAt(1, Qt::white);  QBrush brush(conicalGrad);  painter.setBrush(brush);  // 绘制的矩形区域为整个窗口大小  painter.drawRect(0, 0, 200, 200);&#125;\n\n效果如下图所示，渐变色从45度开始渐变，并且每个角度都无限向外传播，填充满了整个矩形：\n\n径向渐变径向渐变分为简单径向渐变和扩展径向渐变，在介绍二者的不同之前，我们先看看QRadialGradient 类的构造函数可以大致分为以下三类：\n// 指定中心点、半径、焦点位置、焦半径QRadialGradient(const QPointF &amp;center, qreal centerRadius, const QPointF &amp;focalPoint, qreal focalRadius)// 仅指定中心点、半径，此时焦点位置与中心点重合QRadialGradient(const QPointF &amp;center, qreal radius)// 指定中心点、半径、焦点位置QRadialGradient(const QPointF &amp;center, qreal radius, const QPointF &amp;focalPoint)\n\n\n中心点（center）和半径（centerRadius）组成了一个圆，记为圆A，径向渐变的范围只限于圆A以内，圆A以外的区域按照指定的渐变传播方式进行传播；\n\n焦点（focalPoint）为平面上的的一个点，简单径向渐变和扩展径向渐变对焦点的位置有不同的要求，这个区别在后面会介绍；\n\n焦半径（focalRadius）则是围绕焦点所作的另外一个圆（记为圆B）的半径。\n\n\n扩展径向渐变是在简单径向渐变的基础上额外使用了 focalRadius（焦点半径）这个参数。\n简单径向渐变焦点和圆A圆弧上的每一个点都可以组成一条线段，如果按照1度取一个点，就有360个线段，简单径向渐变就是对这360个线段都进行线性渐变。\n对于简单径向渐变而言，允许焦点位于圆弧上和圆外，如果焦点位于圆外，会自动将其退缩到圆弧上。\n下面是一个简单径向渐变的例子：\n// Qt2DSample窗口长宽为600x600void Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  // 焦点位于圆内右上角部分  QRadialGradient radialGrad(QPointF(300, 300), 200, QPointF(400, 200));  radialGrad.setColorAt(0, Qt::white);  radialGrad.setColorAt(1, Qt::black);  QBrush brush(radialGrad);  painter.setBrush(brush);  painter.drawRect(0, 0, 600, 600);&#125;\n\n效果如下图所示，径向渐变的范围只限于圆内，圆外的区域默认采用PadSpread方式传播：\n\n扩展径向渐变扩展径向渐变使用焦点和焦半径又组成了一个圆B，与简单径向渐变类似，也是通过对圆A圆弧上的每个点的连线做线性渐变来实现，但这次不是焦点与圆A圆弧上的点进行连线，而是“圆B圆弧上的点”与“圆A圆弧上的点”的连线，对这些连线做线性渐变。\n圆B始终填充起始颜色。\n与简单径向渐变不同的是，圆B必须完全在圆A里面。\n下面是一个扩展径向渐变的例子：\n// Qt2DSample窗口长宽为600x600void Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  // 焦点位于圆内右上角部分，焦半径为30  QRadialGradient radialGrad(QPointF(300, 300), 200, QPointF(400, 200), 30);  radialGrad.setColorAt(0, Qt::white);  radialGrad.setColorAt(1, Qt::black);  QBrush brush(radialGrad);  painter.setBrush(brush);  painter.drawRect(0, 0, 600, 600);&#125;\n\n效果如下图所示：\n\n渐变传播在Qt中通过 setSpread 方法设置渐变传播方式：\nvoid QGradient::setSpread(QGradient::Spread method)\n\nQGradient::Spread枚举定义了三种传播方式：\n\nQGradient::PadSpread\nQGradient::RepeatSpread\nQGradient::ReflectSpread\n\n默认为传播方式为 QGradient::PadSpread，而且由锥向渐变的行为可知，锥向渐变是没有渐变传播一说的，因此它始终都是360度渐变。\n下图形象说明了三种传播方式的差异：\n\n\nPadSpread 方式延续了起点与终点处各自的颜色，无限传播\nRepeatSpread 方式不断重复渐变边界内的这一颜色的渐变模式\nReflectSpread 方式将渐变边界内的模式不断往外镜像反射\n\n渐变主题设计一个漂亮的渐变色并非易事，Qt提供了内置的渐变主题(Preset)，这些主题通过 QGradient::Preset 枚举类型提供（该枚举从 Qt 5.12 开始引入）。\n\n从Qt官方文档得知，QGradient::Preset预置渐变主题方案是基于https://webgradients.com/实现的。\n\nQGradient 类支持通过QGradient::Preset 枚举类型直接构造：\nQGradient::QGradient(QGradient::Preset preset)\n\n下面是使用QGradient::Preset的示例：\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  QGradient grad(QGradient::HealthyWater);  QBrush brush(grad);  painter.setBrush(brush);  painter.drawRect(0, 0, 600, 600);&#125;\n\n网站推荐下面几个网站也提供了漂亮的渐变色方案，可以用作参考：\n\ngrabient.com\nuigradients.com\nwebgradients.com\n\n","categories":["④Qt奇趣屋"]},{"title":"玩转Qt 2D绘图之坐标系","url":"/post/847642761.html","content":"Qt 中提供了强大的 2D 绘图系统，可以使用相同的 API 在屏幕和绘图设备上进行绘制，主要基于 QPainter、QPaintDevice 和 QPaintEngine 这三个类实现，其中：\n\nQPainter 执行具体的绘图操作，QPainter 类提供了大量的 GUI 编程所需的函数，如 drawLine、drawImage 等。\nQPaintDevice 是一个基类，提供绘图设备的抽象接口，它是一个二维空间的抽象，可以使用 QPainter 在其上进行绘制，常见的继承该类的绘图设备有 QImage、QPixmap、QWidget、QOpenGLPaintDevice 等。\nQPaintEngine 提供了一些抽象接口，用于实现 QPainter 在不同的设备上进行绘制。QPaintEngine 由 QPaintDevice 创建并管理。\n\n\n\n在 Qt 官方文档中有一张图可以很好说明 Qt 各个坐标系变换方式（暂不用关注图上的坐标值）：\n\n我们在使用 QPainter 绘图时需要传入元素坐标，传入的坐标就是图上的世界坐标系（World Coordinates），世界坐标经过矩阵变换（这一步是可选的）后再传递给窗口坐标系（Window Coordinates），窗口坐标系上的元素的坐标还需经过窗口到视口的坐标变换（线性变换），最后在设备坐标系（Device Coordinates）的视口区域内绘制。\n世界坐标系世界坐标系也称之为逻辑坐标系，使用的单位叫逻辑单位。\n在真实的世界地理中，我们通常使用经纬度来表示某一个具体位置，如武汉的坐标为(东经 114°,北纬 30°)，而在 Qt 绘图时使用的逻辑单位是像素。\nQt 的像素支持非整数数量，如 0.5 个像素，而实际设备（如显示器、打印机等）只支持整数数量的像素显示，因此从逻辑坐标到设备坐标需要经过相应的转换过程。\n在 Qt 中，我们提供给 QPainter 的都是逻辑坐标，这种坐标与具体的设备类型无关。\n窗口坐标系上图中的窗口是打了引号的，这说明该窗口是实际不存在的，这个窗口指的是窗口坐标系左上角原点到右下角的一个虚拟矩形窗口。\n默认情况下，窗口坐标系和逻辑坐标系都等同于设备坐标系，三者重合，但我们可以使用QPaintet::setWindow方法重设窗口坐标系的原点和范围，有了左上角原点和长&#x2F;宽，也就得到一个新的“窗口”。\n在绘图时传递给 QPainter 的逻辑坐标需要先经过矩阵变换（常见的矩阵变换有 QPainter 的 translate、scale、rotate、shear 等方法，后面章节会介绍），然后再传递给窗口坐标系。\n设备坐标系也称之为物理坐标（Physical Coordinates），坐标原点位于左上角，X 轴水平向右增长，Y 轴垂直向下增长。\n不同的设备坐标单位通常不同，如显示器通常以像素为单位，而打印机通常以点为单位。\n需要注意的是设备坐标系的原点和范围始终等同于实际绘制设备，不会跟随逻辑坐标系、窗口坐标系以及视口（viewport）的改变而改变。\n视口视口（viewport）是设备环境中的一个矩形框，使用设备坐标系表示。默认情况下，视口左上角位置为设备坐标系的原点，大小为实际绘制目标设备的大小。\n视口存在的意义是为了指定在显示设备的什么位置，以多大的范围来完全显示指定的窗口内容，如果窗口内容超出了视口区域，超出部分将不会显示。\n我们可以用 QPainter::setViewport 方法来改变视口的位置和大小，QPainter::setViewport 的参数都是基于设备坐标系的，如果指定的视口区域超出了设备外，设备外的内容将不会显示。\n实例讲解为了更好说明各个坐标系及视口之间的关系，我们通过一个实例来具体说明。首先创建一个长宽为 400x400 的窗口，并且程序未开启 DPI 缩放特性：\nresize(400, 400);\n\n绘制代码如下：\nvoid Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.translate(100, 200);  painter.setWindow(QRect(200, 300, 600, 600));  painter.setViewport(QRect(100, 100, 300, 300));  painter.drawRect(QRect(300, 100, 200, 200));&#125;\n\n下图使用不同的颜色绘制了不同的坐标系及视口、窗口的位置和区域：\n\n第 1 行代码QPainter painter(this)：\n表明我们是在当前 QWidget 实例上进行绘制，因此设备坐标系原点为(0,0)，坐标系的范围为 QWidget 的长宽 400x400，坐标单位为像素，对应上图绿色部分。\n此时还未设置视口，因此视口默认等同于设备坐标系的范围，即(0,0,400,400)，该部分未在上图画出。\n第 2 行代码painter.translate(100, 200):\n将逻辑坐标系的原点偏移(100,200)个像素。\n在进行偏移时，值为正表示向方向移动，值为负表示向负方向移动。\n第 3 行代码painter.setWindow(QRect(200, 300, 600, 600))：\n设置窗口坐标系原点为(200, 300)，窗口范围是 600x600，对应上图红色部分。\n第 4 行代码painter.setViewport(QRect(100, 100, 300, 300))：\n设置视口为 QRect(100, 100, 300, 300)，即在设备坐标系上的使用 QRect(100, 100, 300, 300)区域来显示上面 600x600 的窗口，对应上图蓝色部分。\n\n第 2、3、4 行代码是没有先后顺序的，因为三个设置函数所影响的目标是不同的。\n\n第 5 行代码painter.drawRect(QRect(300, 100, 200, 200))：\n在 (300,100) 位置绘制 200x200 的正方形，此处传递的是逻辑坐标，而逻辑坐标系已在第 2 行代码处进行了偏移，因此根据新的逻辑坐标系，正方形左上角位置是 (300+100, 100+200) &#x3D; (400, 300)，又因为此处逻辑坐标系未做缩放操作（缩放操作由 QPainter::scale 提供），因此正方形的长宽保持不变，仍为 200x200，即 QRect(400,300,200,200)。\n然后将正方形 QRect(400,300,200,200) 传递给窗口坐标系，该正方形在窗口坐标系 (200,300,600,600) 上面的位置和大小对应上图粉红色部分。\n最后用设备坐标系上的视口区域来显示该窗口，由于窗口坐标系和设备坐标系的原点及范围不相同，因此还需要做线性转化：\n在(200, 300, 600, 600) 范围上显示的正方形 (400, 300, 200, 200)转化为在视口(100, 100, 300, 300) 范围上显示的正方形 (x, y, w, h)\n\n从上面可以看出窗口范围是视口的600 / 300 = 2倍，因此在视口上的原点和长宽分别为：\nx = 100 + (400 - 200) / 2 = 200y = 100 + (300 - 300) / 2 = 100w = 200 / 2 = 100h = 200 / 2 = 100\n\n计算得到需要在视口 (100, 100, 300, 300) 上绘制的正方形为 (200,100,100,100) ，实际绘制的正方形如下图所示：\n\n移动原点到窗口中央默认情况下，坐标原点在窗口的左上角，X 轴水平向右增长，Y 轴垂直向下增长。现在将坐标原点移动到窗口中央，但不改变 X 轴和 Y 轴的方向。\n// Qt2DSample窗口长宽为400x400void Qt2DSample::paintEvent(QPaintEvent* e) &#123;  QPainter painter(this);  painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);  const int w = width();  const int h = height();  // 将坐标原点移动到窗口中央  painter.translate(w / 2.0, h / 2.0);  // 也可以使用下面的方式：  // painter.setWindow(w / 2.0, h / 2.0, w, h);  // painter.translate(w, h);  // 绘制测试矩形  painter.drawRect(QRect(0, 0, 100, 100));&#125;\n\n实际绘制的矩形在窗口中的位置如下图所示：\n\nQRect 遗留问题在介绍 QRect 的遗留问题之前，我们需要先了解 Qt 中锯齿与抗锯齿的相关内容。\n7.1 抗锯齿下图展示了在绘制一条斜线时，未开启抗锯齿（左边）和开启了抗锯齿后（右边）两者的效果。\n\n抗锯齿就是绘图引擎通过在元素的边缘填充不同的颜色来实现平滑边缘的效果。\nQt 默认绘图的元素是有锯齿的，当使用 1 像素宽的画笔绘制时，实际像素将渲染到我们定义坐标的右下方，如下图所示：\n\n当画笔宽度为偶数时，像素将围绕定义坐标进行对称渲染，如下图所示：\n\n当画笔宽度为奇数时，整除后多余的 1 像素将渲染到定义坐标的右下方，如下图所示：\n\n7.2 QRect 实际宽高基于上述原因，QRect::right() 和 QRect::bottom() 的值并不等于矩形真正右下角的坐标。\nQRect::QRect(int aleft, int atop, int awidth, int aheight) noexcept    : x1(aleft), y1(atop), x2(aleft + awidth - 1), y2(atop + aheight - 1) &#123;&#125;void QRect::setWidth(int w) noexcept&#123; x2 = (x1 + w - 1); &#125;void QRect::setHeight(int h) noexcept&#123; y2 = (y1 + h - 1); &#125;int QRect::width() const noexcept&#123; return  x2 - x1 + 1; &#125;int QRect::height() const noexcept&#123; return  y2 - y1 + 1; &#125;\n\n从上面 QRect 的源码可知，QRect::width() 和 QRect::height() 方法返回的是矩形的实际宽高，但 QRect::right() 和 QRect::bottom() 方法返回的不是矩形的实际右边和底部：\nQRect::right() 返回的实际是 QRect::left() + QRect::width() - 1QRect::bottom() 返回的实际是 QRect::top() + QRect::height() - 1\n\n这属于 QRect 的历史遗留问题，Qt 为了兼容之前老的代码，对该部分未作修改，我们可以使用下面方式获取 QRect 真实的 right 和 bottom：\nQRect::x() + QRect::width()QRect::y() + QRect::height()\n\n也可以使用 QRectF类型来代替 QRect 类型，QRectF类型没有上述问题。\n7.3 开启抗锯齿在 Qt 中开启抗锯齿也非常简单，下面代码开启了抗锯齿：\npainter.setRenderHints(    QPainter::Antialiasing |    // 消除基础元素（如线、点）边缘的锯齿    QPainter::TextAntialiasing  // 消除文字边缘的锯齿);\n\n开启抗锯齿以后，像素将始终围绕定义坐标进行对称渲染，并且会自动在边缘填充颜色来平滑边缘，如下图所示：\n\n逻辑坐标矩阵变换Qt 提供了方法来直接对世界坐标（也可称为逻辑坐标）进行矩阵变换：\nvoid QPainter::setWorldTransform(const QTransform &amp;matrix, bool combine = false)\n&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;还提供方法来开启和关闭世界坐标的矩阵变换操作：\nvoid QPainter::setWorldMatrixEnabled(bool enable)\n\n同时 QPainter 还是提供了 translate、scale、rotate、shear 等快捷方法实现对逻辑坐标的矩阵变换操作。\n需要注意的是在调用了 translate、scale、rotate、shear 方法后，QPainter 会自动开启对世界坐标的矩阵转换。\n为了更好的介绍是逻辑坐标的转化过程，现在假设在坐标变换之前存在 点 A(x, y) 和 矩形 B(x, y, w, h)\ntranslatevoid QPainter::translate(const QPointF &amp;offset)void QPainter::translate(const QPoint &amp;offset)void QPainter::translate(qreal dx, qreal dy)\n\nX 和 Y 轴分别平移距离 m 和 n，平移后，点 A 的坐标为(x + m, y + n)，矩形 B 的坐标为(x + m, y + n, w, h)\nm 和 n 可以为负数。\nscalevoid QPainter::scale(qreal sx, qreal sy)\n\nX 和 Y 轴分别缩放 m 和 n 倍 ，缩放后，点 A 的坐标为(x _ m, y _ n)，矩形 B 的坐标为 (x _ m, y _ n, w _ m, h _ n)\nm 和 n 可以为负数，如：\n点 A(50,100) -&gt; scale(-10, 2) -&gt; (-500,200)\n点 A(-50,100) -&gt; scale(-10, 2) -&gt; (500,200)\nrotatevoid QPainter::rotate(qreal angle)\n&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;按顺时针将 X 和 Y 轴同时旋转 angle 度（注意 angle 参数的单位是度，而不是弧度），其中0度为正三点钟方向。\n\nrotate 是顺时针旋转，而使用 QPainter::drawArc 等方法绘制圆弧或扇形时，是按逆时针方向绘制的。\n\n对于单个点进行旋转是没有意义的，\nshearvoid QPainter::shear(qreal sh, qreal sv)\n\n对 X 和 Y 轴分别进行扭曲变换。\n","categories":["④Qt奇趣屋"]},{"title":"基于Qt的无边框窗体实现","url":"/post/2402568381.html","content":"Qt 虽然提供了诸如 Qt::FramelessWindowHint 之类的属性可以移除窗体的边框，但是移除边框之后，窗体的一些默认行为同时也被移除了，如鼠标拖动改变大小、双击标题栏最大化等，这些行为需要开发者自己来实现。\n本文主要介绍实现无边框窗体的几种方案，并在最后分享了作者实现的方案。\n笔者认为，一个完美的无边框窗体解决方案需要支持如下功能：\n\n支持通过使用鼠标拖拽来改变窗体位置和大小；\n支持双击标题栏最大化窗体和还原窗体；\n支持 Windows Areo Snap 特性；\n支持系统阴影；\n支持跨不同 DPI 的屏幕拖拽；\n适应分辨率和 DPI 改变；\n\n\n\n在 Qt 中实现无边框窗体有 2 种方案：\nHook 方案通过重载 nativeEvent 函数拦截 Windows 消息（如 WM_NCHITTEST）来实现，大致步骤如下：\n\n给窗体设置 WS_THICKFRAME | WS_CAPTION 属性从而还原窗体边框和标题栏，这样窗体就可以接收到 WM_NCHITTEST 消息。\n在 WM_NCCALCSIZE 消息处理中再移除边框和标题栏。\n在 WM_NCHITTEST 消息处理中通过判断鼠标位置来设置鼠标行为（ HTLEFT, HTRIGHT 等）。\n\n这种方案的优点是可以支持Windows Areo Snap和系统阴影的特性，但是针对 Windows 消息处理起来很复杂而且需要兼容 Qt 的各个版本，目前我还没有找到一个通过这种方案来完美实现无边框的解决方案。\n据我所知，有如下的开源项目是通过这种方式来实现的，但都有些许问题，如不支持跨不同 DPI 屏幕拖拽、不能适应分辨率和 DPI 改变、WM_NCHITTEST有时无响应等。另外，在设置了背景透明属性之后（如 Qt::WA_TranslucentBackground），系统阴影特性也将消失。\n\nqtdevs&#x2F;FramelessHelper: https://github.com/qtdevs/FramelessHelper\nwangwenx190&#x2F;framelesshelper: https://github.com/wangwenx190/framelesshelper\n\n纯 Qt 方案这种方案不 Hook windows 的 WM_NCHITTEST、WM_NCCALCSIZE 消息，也不改变窗体样式，通过纯 Qt 方式实现。通过对每个 Widget 设置MouseTracking，来使每个 Widget 都可以响应鼠标事件（mouseMoveEvent、mousePressEvent、mouseReleaseEvent 等），然后这些事件中判断鼠标位置来设置鼠标的形状和行为。\n这种方式虽然对鼠标位置的判断逻辑比较繁琐，但兼容性较好，较纯粹，不需要处理 Windows 的各个消息。\nQt-FramelessWindow👉 我根倾向于使用纯 Qt 方案，简单、稳定、兼容性好，不用关注那些烦人的 Windows 消息。针对该方案的实现，可以参考笔者的开源项目【Qt-FramelessWindow】，目前可以支持上述除“Windows Areo Snap”和“系统阴影”特性之外的所有无边框窗体的特性，而且仅有一个头文件，使用起来也非常方便。\n\nQt-FramelessWindow: https://github.com/winsoft666/Qt-FramelessWindow\n\n\n","categories":["④Qt奇趣屋"]},{"title":"突破抓包限制：Hook实战解密HTTPS流量与SSL双向认证","url":"/post/657651408.html","content":"传统的抓包工具（如 Fiddler、Wireshark）在面对愈发严格的安全措施时，如 HTTPS 双向认证（mTLS）、内存加载证书、证书绑定等，它们往往显得力不从心。本文旨在带你超越传统抓包的边界，不仅会回顾抓包工具的核心原理，更将深入 Hook 注入技术，实战演示如何通过拦截关键函数，动态获取 SSL 证书、解密 HTTPS 明文流量。\n这可能是全网最具深度的关于抓包文章。\n\n\n抓包工具Fildder 原理Fiddler 通过扮演中间人的角色（对客户端扮演服务器，对服务器扮演客户端）来实现 HTTP 抓包和 HTTPS 流量解密的功能。\nFiddler 在启动后，会自动在本地建立一个代理服务器（端口默认为 8888），并通过调用 Windows 的 WinHttpSetDefaultProxyConfiguration 等函数，将自己设置为系统默认的 HTTP&#x2F;HTTPS 代理。许多应用程序（如浏览器）默认会遵循系统的这个代理设置，因此它们发出的网络请求都会首先被发送到 Fiddler。\n\n可以在系统的“设置” -&gt; “网络和 Internet” -&gt; “代理”中看到“使用代理服务器”的选项被自动开启，并且代理 IP 为：http&#x3D;127.0.0.1:8888;https&#x3D;127.0.0.1:8888;\n\n当 Fiddler 收到 HTTP 请求时，因为不涉及数据包解密，Fiddler 直接进行转发即可。\n当需要解密 HTTPS 请求时，Fiddler 会在本地生成一个自签名的根证书（Fiddler Root Certificate），并将这个根证书安装到操作系统的“受信任的根证书颁发机构”存储中。\n\n\n以请求 https://sample.com 为例，Fiddler 会使用自签名的根证书私钥来为 sample.com 域名动态的伪造一张证书，并返回给浏览器（因为对于浏览器而言，它的服务器是 Fildder），浏览器使用这个假证书来进行 SSL 加密，然后将加密数据包发送给 Fiddler，Fiddler 使用假证书的私钥来解密数据包进行显示、修改等，然后 Fiddler 从 sample.com 服务器请求真正的证书，并使用真证书对数据包再次加密，然后发送给 sample.com 服务器；\nsample.com 服务器将响应发送给 Fiddler（因为对 sample.com 服务器而言，发起请求的客户端是 Fildder），Fiddler 使用真证书来解密数据包进行展示，然后使用假证书来再次加密数据包，最后转发给浏览器。\n\n\nProxifier 原理Proxifier 在 Windows 系统中主要使用 LSP（Layered Service Provider，分层服务提供程序）​ 技术实现对网络流量的拦截，属于应用层的流量拦截，无需安装驱动，大多数游戏加速器也会使用该项目技术。\nProxifier 是透明流量转发，不负责解密 HTTPS 流量，解密操作由后续的软件进行。通常使用 Proxifier 将指定进程的流量转发到 Fildder 或 Charles，然后再使用这些工具进行解包分析。\n通常还需要将 Proxifier 的“名称解析”-&gt;“DNS 设置”修改为“通过代理解析主机名称”。\n\n\n下面来解释为什么要这样设置。\n应用程序 -&gt; Proxifier -&gt; Fiddler\n\n若没有将 DNS 设置为“通过代理解析主机名称”，当本地 DNS 缓存中存在 baidu.com 域名解析条目时，会直接将 baidu.com 域名解析为对应的 IP，从而将 TSL 握手请求包中的域名修改为 IP 后再转发给 Fiddler。Fiddler 在动态伪造证书时是需要知道域名的，如果不知道，Fiddler 就不知道要伪造哪个证书，无法伪造证书。\n\n\nWireshark 原理Wireshark 的工作流程始于捕获，当选择一个网络接口（如 Wi-Fi 或以太网网卡）开始抓包时，Wireshark 会通过底层驱动（如 Npcap 或 WinPcap）将网卡设置为混杂模式。在此模式下，网卡会捕获所有流经它的网络数据包。\n捕获到的原始数据是二进制比特流，Wireshark 的内置的协议解析器会按照网络协议栈（如 Ethernet → IP → TCP → HTTP）逐层解码这些二进制数据，将晦涩的代码转换为人类可读的协议字段和含义。因此要熟练掌握 Wireshark 的使用，需要先了解网络协议栈，可以参考：  网络编程&#x2F;网络协议-1-基础概念 。\nWireshark 还提供了一个分为三部分的界面供我们深入检查数据包：数据包列表、数据包详情和数据包字节流。通常会需要结合显示过滤器（如 http.request.method &#x3D;&#x3D; “GET”）来精准筛选流量，或通过“Follow TCP Stream”功能重构完整的会话内容。\n虽然 Wireshark 也可以捕获和分析 HTTP(s)流量，但在这方面还是不如 Fiddler 等工具专业，所以我们通常只使用其来捕获除 HTTP(s)以外的流量。\n浏览器 HTTP 抓包先来一个开胃前菜。网页抓包是调试前端 API 接口最基础的技能，浏览器内置的开发者工具是完成这项任务的首选利器。\n以主流的 Chrome 浏览器为例，按 F12 或 Ctrl+Shift+I 就可以打开开发者工具，其“Network（网络）面板”中记录了所有由浏览器发起的网络请求，包括 HTML、CSS、JS、图片、XHR&#x2F;Fetch（API 接口）等。\n但有些网页会禁用浏览器的调试工具，防止用户进行抓包和调试，它们通常采用包括但不限于下面的方式：\n\n使用 addEventListener 来拦截 F12、 Ctrl+Shift+I 等快捷键以及右键菜单事件\n因为只有在打开调试工具的情况下，debugger语句才会生效。根据这个机制，可以通过 debugger 上下语句执行的时间差来判断调试器是否打开。\n也可以通过无限执行debugger语句来干扰调试。\n\n目前已经有开源组件 disable-devtool 可以快速搞定禁用调试工具，这个组件使用的检测&#x2F;禁用手段也更加多样化。\n遇到这种禁用调试工具的网站时，如果只需要抓包，使用 Fildder 或 Charles 无意是最简单的方法。\n基于 libcurl 的 HTTP 抓包许多命令行工具和应用程序使用 libcurl 库进行网络通信。默认情况下，libcurl 并不会自动遵循系统代理设置，除非在代码中显式指定。\ncurl_easy_setopt(pCURL, CURLOPT_PROXY, &quot;127.0.0.1:8888&quot;);\n\n对于一些支持设置 HTTP 代理的软件，我们可以尝试将代理设置为本地的 Fildder 代理端口（如 127.0.0.1:8888），然后使用 Fiddler 进行抓包分析。\n而对于大多数不支持代理设置的软件，通常需要使用 Proxifier 将该软件进程的流量转发到 Fiddler 代理端口，然后使用 Fildder 进行抓包分析。\nHTTPS 双向认证根据之前的文章   网络编程&#x2F;网络协议-7-HTTP与HTTPS协议 《网络协议(7)–HTTP与HTTPS协议》 所介绍的 SSL&#x2F;TSL 握手的过程可以知道，在握手过程中，不仅客户端可以校验服务器的证书，服务器也可以校验客户端的证书，这个叫 HTTPS 双向认证（mutual TLS），简称 mTLS。libcurl 作为一个成熟的网络库，对 mTLS 提供了很好的支持。\n客户端校验服务器证书通过如下代码可以开启 libcurl 客户端对服务器证书的校验：\ncurl_easy_setopt(pCURL, CURLOPT_SSL_VERIFYPEER, 1L);curl_easy_setopt(pCURL, CURLOPT_SSL_VERIFYHOST, 1L);\n\n在开启服务器证书校验后，还需要指定 CA 包（Certificate Authority bundle，包含多个信任的根证书，用于验证服务器证书链）才能正常请求。有两种方式指定 CA 包，一种是通过 CURLOPT_CAINFO 选项来从本地文件路径加载：\ncurl_easy_setopt(pCURL, CURLOPT_CAINFO, &quot;D:\\\\certs\\\\ca.crt&quot;);\n\n另一种是通过 CURLOPT_CAINFO_BLOB 选项来从内存加载：\n  const char* strCA = R&quot;(-----BEGIN CERTIFICATE-----.......-----END CERTIFICATE-----)&quot;;  struct curl_blob blob;  blob.data = (void*)strCA;  blob.len = strlen(strCA);  blob.flags = CURL_BLOB_COPY;  curl_easy_setopt(pCURL, CURLOPT_CAINFO_BLOB, &amp;blob);\n\n服务器校验客户端证书像网银、企业内部服务等这些对安全级别要求较高的应用，服务器通常需要校验客户端的证书，即 TLS 握手的 ServerHello 响应中包含“客户端证书请求”，此时客户端就需要发送相应的证书给服务器。\nlibcurl 通过 CURLOPT_SSLCERT 和 CURLOPT_SSLKEY 选项指定客户端证书和私钥的本地路径（如果通过内存加载则分别对应 CURLOPT_SSLCERT_BLOB 和 CURLOPT_SSLKEY_BLOB 选项），还是可以使用 CURLOPT_SSLCERTTYPE 选项指定证书类型（默认为 PEM 类型）以及 CURLOPT_KEYPASSWD 选项指定私钥的密码（可选）。\nlibcurl 在收到服务器的“客户端证书请求”后，会自动将相应的信息发送给服务器。\n创建证书及私钥如何来创建双向证书所需的证书呢？在创建证书及私钥之前，需要先弄清除，公钥、私钥、CA 和证书的关系（详见   网络编程&#x2F;网络协议-7-HTTP与HTTPS协议 《网络协议(7)–HTTP与HTTPS协议》 中的“证书的申请”章节）。\n\n公钥和私钥是非对称加密中的概念，私钥保密，公钥公开。\n证书里面会包含公钥，证书也是公开的，但证书对应的私钥需要保密。所以在我的文章中一般将证书等同于公钥。\nCA &#x3D; Certificate Authority，直译为证书机构。使用 CA 证书的私钥来签发证书，然后用 CA 证书来验证所签发的证书。\n\n回到本节的双向校验过程中来，客户端验证服务器的证书也就是使用 CA 证书来验证服务器的证书，服务器验证客户端证书也就是使用 CA 证书来验证客户端的证书，因为客户端和服务器的证书都是通过 CA 证书私钥来签发的。\nCA私钥 ---签发--&gt; (服务器证书 + 私钥)CA私钥 ---签发--&gt; (客户端证书 + 私钥)CA公钥 ---验证--&gt; 服务器证书CA公钥 ---验证--&gt; 客户端证书\n\n我们可以使用 openssl 来生成上述证书，大致步骤如下。\n\n创建 CA 的私钥和证书。\n\n# CA私钥openssl genrsa -out ca.key 4096# 使用私钥 ca.key 生成一个自签名的根证书 ca.crt，有效期为10年# -nodes 不加密私钥（no DES）# /C=CN 国家=中国 /ST=Beijing 省份=北京 /L=Beijing 城市=北京 /O=Test CA 组织=Test CA /OU=IT 部门=IT /CN=Test Root CA 通用名称=Test Root CA# CA:true 表示这是一个CA证书# 允许该证书用于签发其他证书（keyCertSign）和签发证书吊销列表（cRLSign）openssl req -x509 -new -nodes -key ca.key -sha256 -days 3650 -out ca.crt ^  -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=Test CA/OU=IT/CN=Test Root CA&quot; ^  -addext &quot;basicConstraints=critical,CA:true&quot; ^  -addext &quot;keyUsage=critical,keyCertSign,cRLSign&quot;\n\n\n创建服务器的私钥和证书。\n\n# 私钥openssl genrsa -out server.key 2048# 生成服务端 CSR（请求证书），设置主题与常用用途# CN=localhost 表示服务器域名为localhost，但现在已被废弃，优先使用下面的subjectAltNameopenssl req -new -key server.key -out server.csr ^  -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=Test Server/OU=IT/CN=localhost&quot;# 创建扩展文件server.ext# extendedKeyUsage为serverAuth表示这是一个用于服务器验证的证书# 由于是本地测试，所以ip和域名为localhost、127.0.0.1、IP:::1# 这里的DNS不是域名解析服务器，而是指域名(echo authorityKeyIdentifier=keyid,issuerecho basicConstraints=CA:FALSEecho keyUsage=digitalSignature, keyEnciphermentecho extendedKeyUsage=serverAuthecho subjectAltName=DNS:localhost,IP:127.0.0.1,IP:::1) &gt; server.ext# 使用CA签发一个自签名的证书openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial ^  -out server.crt -days 365 -sha256 -extfile server.ext\n\n\n创建客户端的私钥和证书。\n\nopenssl genrsa -out client.key 2048# 客户端 CSR# extendedKeyUsage为clientAuthopenssl req -new -key client.key -out client.csr ^  -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=Test Client/OU=IT/CN=test-user&quot;# 创建扩展文件client.ext# extendedKeyUsage=clientAuth表示这是一个用于客户端验证的证书(echo authorityKeyIdentifier=keyid,issuerecho basicConstraints=CA:FALSEecho keyUsage=digitalSignature, keyEnciphermentecho extendedKeyUsage=clientAuth) &gt; client.ext# 使用CA签发一个自签名的证书openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial ^  -out client.crt -days 365 -sha256 -extfile client.ext\n\n绕过对服务器证书的校验在抓取 libcurl 的 HTTPS 包时，如果提示如下的错误，说明 libcurl 开启了对服务器证书的校验，并且证书校验失败。\n\n\n要解决 Fiddler 解密失败的问题，我们需要理解两种场景下证书校验的差异：\n\n没有 Fiddler 的情况。\n客户端（libcurl）向服务器发起 TLS 握手请求，其中包含 ClientHello 消息。服务器返回 ServerHello、证书（以及其它消息）。客户端收到证书后，会使用自定义的 CA 证书包来验证服务器证书。如果验证通过（即服务器证书是由自定义 CA 证书包中的某个根证书签名的），则握手继续；否则，握手失败。\n\n有 Fiddler 的情况（且 Fiddler 作为中间人代理）。\n客户端实际上是与 Fiddler 建立 TLS 连接，而不是直接与目标服务器建立连接。因此，客户端会向 Fiddler 请求证书（因为 Fiddler 此时扮演服务器的角色）。Fiddler 会动态生成一个目标服务器域名的证书，并用 Fiddler 自己的根证书签名。客户端收到这个证书后，同样会用自定义的 CA 包来验证。如果自定义 CA 包中包含了 Fiddler 的根证书，则验证通过；否则，验证失败。\n\n\n如果 libcurl 是通过文件路径方式来指定的 CA 包，我们可以找到该文件，通过将 Fiddler 根证书添加到该文件中的方式，来使程序再次信任 Fiddler 的根证书。大致步骤如下：\n\n导出 Fiddler 的根证书（打开 Fiddler → Tools​ → Options​ → HTTPS​ → Actions​ → Export Root Certificate to Desktop）\n\n把证书转成与 libcurl 程序所指定证书一样的格式，如转成 pem 格式。\nopenssl x509 -in FiddlerRoot.cer -out FiddlerRoot.pem -outform PEM\n\n将 pem 内容添加到原有的 CA 包尾部（或者完全替换原有 CA 包的内容）。\n\n\n如果在 Fiddler 之前使用了 Proxifier 转发流量，不要忘记在 Proxifier 中将 DNS 设置“通过代理解析主机名称”。\n如果 libcurl 是通过内存加载的 CA 包，可以采用注入 + Hook 的方式将 CA 包重定向到我们指定的文件，见下面的章节。\nlibcurl 与 Schannellibcurl 中的 Schannel 和 OpenSSL 都是用于处理 HTTPS (SSL&#x2F;TLS) 连接的底层安全库，它们的主要区别在于：OpenSSL 跨平台的第三方加密库；而 Schannel (Security Support Provider Interface) 是 Windows 平台自带的微软实现，原生集成。可以在编译 libcurl 时选择以何种方式支持 HTTPS。\n当使用 OpenSSL 作为底层安全库时，可以使用上面介绍的方法来抓取 HTTPS 流量。\n但是，当使用 Schannel 作为底层安全库时，默认会验证证书的吊销状态，而 Fiddler 生成的证书没有有效的吊销信息，会导致返回CERT_TRUST_REVOCATION_STATUS_UNKNOWN错误。\n使用如下命令查看 Fiddler 导出的证书的吊销状态：\ncertutil -verify FiddlerRoot.cer\n\n通常会输出如下结果：\n证书是一个 CA 证书无法检查分支证书吊销状态\n\n如果能修改 libcurl 程序的代码，可以禁用吊销状态检查：\ncurl_easy_setopt(curl, CURLOPT_SSL_OPTIONS, CURLSSLOPT_NO_REVOKE);\n\n当然大多数情况下，都无法修改程序的代码，那么如何跳过吊销状态检查呢？嘿嘿\n绕过对客户端证书的校验找到客户端使用的证书和私钥文件（如果私钥有密码，还要先想办法获取到密码），通过如下命令来生成 pfx 文件：\nopenssl pkcs12 -export -out client.pfx -inkey client.key -in client.crt\n\n双击 pfx 文件，导入到系统中（理论上是不需要该步骤了，但可能是因为 Schannel 存在 bug 的缘故，如果不将 pfx 导入到系统，fiddler 会解析证书失败）。\n编辑 Fiddler 的 Rules，在 OnBeforeRequest 函数中添加类似如下内容：\nif (oSession.uriContains(&quot;localhost&quot;)) &#123;  oSession[&quot;https-Client-Certificate&quot;] = &quot;D:\\\\certs\\\\client.pfx&quot;;&#125;\n\n如果 libcurl 是通过内存加载的客户端证书、私钥，可以采用注入 + Hook 的方式将获取到这些信息，见下面的章节。\nHook libcurl 获取证书信息当目标程序通过内存（BLOB）方式加载证书和私钥时，我们无法直接修改文件。此时，Hook（钩子）​ 技术便成为关键手段。通过拦截程序对 libcurl API 的调用，我们可以动态读取、修改甚至替换这些敏感信息。\n涉及到的 libcurl 选项如下：\nCURLOPT_CAINFO_BLOBCURLOPT_SSLCERT_BLOBCURLOPT_SSLKEY_BLOBCURLOPT_KEYPASSWD\n\n通过分析 libcurl（8.13.0 版本）的代码，发现 curl_easy_setopt 调用路径如下：\nCURLcode curl_easy_setopt(CURL *d, CURLoption tag, ...)CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)CURLcode setopt_blob(struct Curl_easy *data, CURLoption option, struct curl_blob *blob)或CURLcode setopt_cptr(struct Curl_easy *data, CURLoption option, char *ptr)\n\nHook Curl_vsetopt 一个函数就可以截获和修改我们所需要的信息。\nlibcurl 没有导出 Curl_vsetopt 函数，所以需要通过特征码来搜索函数地址。使用 IDA Pro 分析 32 位 libcurl.dll 发现，可以通过函数的前几个指令作为特征码来搜索函数地址，因此 函数特征码为 0x8B, 0x4C, 0x24, 0x08, 0x81, 0xF9, 0x10, 0x27, 0x00, 0x00。\n8B4C24 08                | mov ecx,dword ptr ss:[esp+8]            | _Curl_vsetopt81F9 10270000            | cmp ecx,2710                            |\n\n编写 DLL，在 DLL 中通过特征码查找函数地址，然后使用 MinHook 库来 Hook 该函数。\n在查找函数特征码时，需要区分动态链接和静态链接 libcurl 库的情况。动态链接时，直接从 libcurl.dll 模块查找；静态链接时，从主模块中查找。\n查找 Curl_vsetopt 函数地址的代码如下：\nPVOID dllBase = NULL;ULONG sizeOfImage = 0L;PFN_Curl_vsetopt pfnCurlVSetOpt = NULL;PVOID processBase = NULL;ULONG sizeOfProcessImage = 0L;// 从LDR中查找libcurl.dll模块的基地址// 若查找不到，可能是静态链接，从主模块查找PPEB peb = NtCurrentTeb()-&gt;ProcessEnvironmentBlock;PPEB_LDR_DATA ldr = peb-&gt;Ldr;PLIST_ENTRY pListHead = &amp;ldr-&gt;InLoadOrderModuleList;for (PLIST_ENTRY pListEntry = pListHead-&gt;Flink; pListEntry != pListHead; pListEntry = pListEntry-&gt;Flink) &#123;\tPLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);\tif (!processBase) &#123;\t\tprocessBase = pEntry-&gt;DllBase;\t\tsizeOfProcessImage = pEntry-&gt;SizeOfImage;\t&#125;\tstd::wstring moduleName(pEntry-&gt;BaseDllName.Buffer, pEntry-&gt;BaseDllName.Length / 2);\tif (StrIsEqual(moduleName, L&quot;libcurl.dll&quot;, true)) &#123;\t\tdllBase = pEntry-&gt;DllBase;\t\tsizeOfImage = pEntry-&gt;SizeOfImage;\t\tbreak;\t&#125;&#125;if (dllBase == NULL || sizeOfImage == 0) &#123;\tdllBase = processBase;\tsizeOfImage = sizeOfProcessImage;\tTraceW(L&quot;[CurlHook] Cannot find libcurl.dll module, try to search the whole process image(ImageBase: 0x%p, Size: %u).\\n&quot;, dllBase, sizeOfImage);&#125;const size_t patternSize = sizeof(pattern);BYTE* foundAddr = NULL;SearchPattern((BYTE*)dllBase, sizeOfImage, pattern, patternMask, (BYTE**)&amp;pfnCurlVSetOpt);if (!pfnCurlVSetOpt) &#123;\tTraceW(L&quot;[CurlHook] Cannot find Curl_vsetopt function.\\n&quot;);\treturn;&#125;TraceW(L&quot;[CurlHook] Found pattern at address: 0x%p\\n&quot;, pfnCurlVSetOpt);\n\n使用 MinHook 库 Hook 查找到的函数，代码如下：\nMH_STATUS mhStatus = MH_Initialize();if (mhStatus != MH_OK) &#123;\tTraceW(L&quot;[CurlHook] MH_Initialize failed: %d\\n&quot;, mhStatus);\treturn;&#125;mhStatus = MH_CreateHook(pfnCurlVSetOpt, My_Curl_vsetopt, (LPVOID*)&amp;pfnCurlVsetoptTrampoline);if (mhStatus != MH_OK) &#123;\tTraceW(L&quot;[CurlHook] MH_CreateHook failed: %d\\n&quot;, mhStatus);\treturn;&#125;mhStatus = MH_EnableHook(pfnCurlVSetOpt);if (mhStatus != MH_OK) &#123;\tTraceW(L&quot;[CurlHook] MH_EnableHook failed: %d\\n&quot;, mhStatus);\treturn;&#125;TraceW(L&quot;[CurlHook] Hook succeeded.\\n&quot;);\n\n最后，在我们的 detour 函数中根据 option 来做相应的处理：\nCURLcode My_Curl_vsetopt(struct Curl_easy* data, int option, va_list param) &#123;\tif (option == 40309) &#123; // CURLOPT_CAINFO_BLOB\t\t// 附加Fiddler的CA到末尾，然后返回\t\tFile file(PathJoin(GetCurrentExeDirectoryW(), L&quot;FiddlerCA.pem&quot;));\t\tif (file.open(L&quot;rb&quot;)) &#123;\t\t\tstd::string strFiddlerCA = file.readAll();\t\t\tfile.close();\t\t\tTraceA(&quot;[CurlHook] FiddlerCA.pem %s\\n&quot;, strFiddlerCA.c_str());\t\t\tcurl_blob* blob = va_arg(param, struct curl_blob*);\t\t\tstd::string newCA = std::string((const char*)blob-&gt;data, blob-&gt;len) + &quot;\\n&quot; + strFiddlerCA;\t\t\tgBuffer = malloc(newCA.length());\t\t\tif (gBuffer) &#123;\t\t\t\tmemset(gBuffer, 0, newCA.length());\t\t\t\tmemcpy(gBuffer, newCA.c_str(), newCA.length());\t\t\t\tstruct curl_blob myBlob;\t\t\t\tmyBlob.data = gBuffer;\t\t\t\tmyBlob.len = newCA.length();\t\t\t\tmyBlob.flags = blob-&gt;flags;\t\t\t\tTraceW(L&quot;[CurlHook] Append CA success.\\n&quot;);\t\t\t\treturn Wrapped_Curl_vsetopt(data, option, &amp;myBlob);\t\t\t&#125;\t\t&#125;\t\treturn pfnCurlVsetoptTrampoline(data, option, param);\t&#125;\tif (option == 40291 || option == 40292) &#123;\t\t// 转存到文件\t\tcurl_blob* blob = *((struct curl_blob**)param);\t\tstd::wstring filePath;\t\tif (option == 40291) // CURLOPT_SSLCERT_BLOB\t\t\tfilePath = PathJoin(GetCurrentExeDirectoryW(), L&quot;DumpClient.cert&quot;);\t\telse if (option == 40292) // CURLOPT_SSLKEY_BLOB\t\t\tfilePath = PathJoin(GetCurrentExeDirectoryW(), L&quot;DumpClient.key&quot;);\t\tFile file(filePath);\t\tif (file.open(L&quot;w&quot;)) &#123;\t\t\tfile.writeFrom(blob-&gt;data, blob-&gt;len);\t\t\tfile.close();\t\t&#125;\t\treturn pfnCurlVsetoptTrampoline(data, option, param);\t&#125;\tif (option == 10026) &#123; // CURLOPT_KEYPASSWD\t\tchar* pwd = *((char**)param);\t\tTraceA(&quot;[CurlHook] CURLOPT_KEYPASSWD: %s\\n&quot;, pwd);\t\treturn pfnCurlVsetoptTrampoline(data, option, param);\t&#125;\treturn pfnCurlVsetoptTrampoline(data, option, param);&#125;static CURLcode Wrapped_Curl_vsetopt(struct Curl_easy* data, int option, ...) &#123;\tva_list args;\tva_start(args, option);\tCURLcode result = pfnCurlVsetoptTrampoline(data, option, args);\tva_end(args);\treturn result;&#125;\n\nHook OpenSSL 获取明文libcurl 通过 OpenSSL 提供对 SSL 和 TLS 协议的支持，因此我们可以 Hook OpenSSL 库的函数来截获加密前的请求明文以及解密后的响应明文。\n写一个简单的 OpenSSL 示例程序，单步调试后可以发现，OpenSSL 内部会分别调用 SSL_write 函数写入待加密的报文数据，SSL_read 函数读取解密后的报文数据。\n因此我们只需要 Hook 这两个函数就可以截获请求和响应的明文，而且这两个函数都是 OpenSSL 的导出函数，在程序使用动态链接 OpenSSL 库的情况下，我们只需要查找 IAT 就可以获取函数地址。\n本节以静态链接 OpenSSL 库为例，通过特征码来查找这两个函数的地址。\n从 OpenSSL 3.5.0 版本中查看 SSL_read 和 SSL_write 函数的定义如下：\nint SSL_read(SSL *s, void *buf, int num)&#123;    int ret;    size_t readbytes;    if (num &lt; 0) &#123;        ERR_raise(ERR_LIB_SSL, SSL_R_BAD_LENGTH);        return -1;    &#125;    ret = ssl_read_internal(s, buf, (size_t)num, &amp;readbytes);    /*     * The cast is safe here because ret should be &lt;= INT_MAX because num is     * &lt;= INT_MAX     */    if (ret &gt; 0)        ret = (int)readbytes;    return ret;&#125;int SSL_write(SSL *s, const void *buf, int num)&#123;    int ret;    size_t written;    if (num &lt; 0) &#123;        ERR_raise(ERR_LIB_SSL, SSL_R_BAD_LENGTH);        return -1;    &#125;    ret = ssl_write_internal(s, buf, (size_t)num, 0, &amp;written);    /*     * The cast is safe here because ret should be &lt;= INT_MAX because num is     * &lt;= INT_MAX     */    if (ret &gt; 0)        ret = (int)written;    return ret;&#125;\n\nSSL_read 与 SSL_write 函数的定义非常类似，而且在 OpenSSL 源码中还有很多类似的函数，因此不能简单的使用前几个指令作为特征码进行搜索。\n进一步分析 ERR_raise 宏，其定义如下：\n# define ERR_raise(lib, reason) ERR_raise_data((lib),(reason),NULL)# define ERR_raise_data                                         \\    (ERR_new(),                                                 \\     ERR_set_debug(OPENSSL_FILE,OPENSSL_LINE,OPENSSL_FUNC),     \\     ERR_set_error)void ERR_set_debug(const char *file, int line, const char *func);\n\n其中，ERR_set_debug 函数的参数分别是源文件路径、代码所在行、函数名称，代码行是一个整数常量，可以很方便地作为特征码来使用，也就是下面汇编代码中的 push 94Bh。\n\n\n因此 SSL_read 与 SSL_write 函数的特征码分别如下：\nstatic BYTE sslReadPattern[] = &#123;    0x8B, 0x44, 0x24, 0x0C,        // mov     eax, [esp+arg_8]    0x85, 0xC0,                    // test    eax, eax    0x79, 0x00,                    // jns     short loc_6343D6    0xE8, 0x00, 0x00, 0x00, 0x00,  // call    sub_454800    0x68, 0x00, 0x00, 0x00, 0x00,  // push    offset aSslRead    0x68, 0x4B, 0x09, 0x00, 0x00,  // push    94Bh&#125;;static char sslReadPatternMask[] = u8R&quot;(xxxxxxx?x????x????xxxxx)&quot;;static BYTE sslWritePattern[] = &#123;    0x8B, 0x44, 0x24, 0x0C,        // mov     eax, [esp+arg_8]    0x85, 0xC0,                    // test    eax, eax    0x79, 0x00,                    // jns     short loc_6343D6    0xE8, 0x00, 0x00, 0x00, 0x00,  // call    xxx    0x68, 0x00, 0x00, 0x00, 0x00,  // push    offset aSslWrite    0x68, 0x71, 0x0A, 0x00, 0x00,  // push    0A71h&#125;;static char sslWritePatternMask[] = u8R&quot;(xxxxxxx?x????x????xxxxx)&quot;;\n\n在找到函数地址之后，同样使用 MinHook 库进行 Hook，将截获到的请求和响应内容写入到日志文件：\nint MySSLRead(void* s, void* buf, int num) &#123;    int readbytes = pfnSSLReadTrampoline(s, buf, num);    if (readbytes &gt; 0) &#123;        logFile.writeFrom(buf, readbytes);    &#125;    return readbytes;&#125;int MySSLWrite(void* s, void* buf, int num) &#123;    int written = pfnSSLWriteTrampoline(s, buf, num);    if (written &gt; 0) &#123;        logFile.writeFrom(buf, written);    &#125;    return written;&#125;\n\nWinHTTPFiddler 可以抓取使用 WinINET API 接口发送的流量，但是无法抓 WinHTTP API 接口发送流量。尝试了各种办法依然无法抓取，最后只好使用 Proxifier 来将流量转发到 Fiddler。\n同样别忘记在 Proxifier 中将 DNS 设置“通过代理解析主机名称”。\nElectron HTTP 抓包Electron 应用默认不走系统代理，所以使用 Fiddler 无法直接抓包。使用 Electron 程序内置的调试工具进行抓包非常直观，而且不用考虑 HTTPS 双向认证的问题，可以优先尝试打开调试工具。\n方法 1\n如果能直接打开调试工具（如快捷键 Ctrl+Shift+I 或 F12 等），这是最简单的方式。\n方法 2\n如需抓取渲染进程的包，则使用 --remote-debugging-port=9222 --remote-allow-origins=* 命令行启动 Electron 程序，然后在浏览器中通过 http://localhost:9222 访问调试工具。\n如需抓取主进程的包，则使用--inspect=9222命令行启动 Electron 程序，并进行相应配置，详见   Web与Electron&#x2F;Electron启动和禁用调试工具的方法 \n方法 3\n使用 asar 命令解压 app.asar 资源包，并在 js 代码中查找 new BrowserWindow，针对需要抓包的 BrowserWindow 对象启动 devTools 并调用 openDevTools 函数打开调试工具（也粗暴一点就把所有的都加上），然后再使用 asar 命令重新打包资源包。\nmainWindow = new BrowserWindow(&#123;  width: 800,  height: 600,  webPreferences: &#123;    devTools: true, // 启动devTools  &#125;,&#125;);// 打开调试工具mainWindow.webContents.openDevTools(&#123; mode: &quot;detach&quot; &#125;);\n\n有的 Electron 应用会校验 asar 资源包的哈希值（如 WeMod），防止被修改之后重新打包，此时需要使用 IDA Pro 屏蔽掉该逻辑。\n方法 4\n虽然大多数情况下都可以打开调试工具的，除非方法不到位，但如果实在无法打开，还可以使用 Proxifier 将流量转发到 Filddler，然后使用 Fiddler 抓包分析。按照这种方法，如果遇到了 HTTPS 双向认证，则需要从资源文件和源码中获取到证书、私钥等信息。\nCEF HTTP 抓包CEF 应用可以通过设置远程调试端口来进行调试，也就是使用下面的命令行来启动 CEF 应用（指定一个 1024~65535 之间的端口号），然后在浏览器中通过 http://localhost:34444 访问调试工具。\ncef_app.exe -remote-debugging-port=34444\n\n调试端口屏蔽与反屏蔽但开发者也可以在代码中屏蔽远程调试命令行参数，下面介绍几种屏蔽调试参数的方法，同时也介绍了对于逆向分析人员如何绕过该屏蔽方法的手段。\n方法 1：不提供 devtools_resources.pak 文件。\n这种情况只需要从 cef 官网下载对应版本的 devtools_resources.pak 文件放到 libcef.dll 同级目录即可。\n方法 2：禁用命令行参数解析。\nCefSettings settings;settings.command_line_args_disabled = 1;CefInitialize(args, settings, application, windows_sandbox_info);\n\nCefInitialize 函数的调用路径如下：\nlibcef_dll_wrapper.dll!bool CefInitialize(const CefMainArgs&amp; args, const CefSettings&amp; settings, CefRefPtr&lt;CefApp&gt; application, void* windows_sandbox_info)libcef.dll!int cef_initialize(const struct _cef_main_args_t* args, const struct _cef_settings_t* settings, cef_app_t* application, void* windows_sandbox_info)\n\ncef_initialize 函数是 libcef.dll 的导出函数，所以我们只需要 Hook 该函数，并将 CefSettings.command_line_args_disabled 修改为 0 即可绕过该禁用。\n方法 3：在 OnBeforeCommandLineProcessing 回调函数移除命令行参数中的 remote-debugging-port。\n// 移除remote-debugging-port参数void ClientAppBrowser::OnBeforeCommandLineProcessing(\tconst CefString&amp; process_type,\tCefRefPtr&lt;CefCommandLine&gt; command_line) &#123;\tif (command_line-&gt;HasSwitch(&quot;remote-debugging-port&quot;)) &#123;\t// remove remote-debugging-port\t// ......\t&#125;&#125;\n\nOnBeforeCommandLineProcessing 函数由 libcef_dll 项目中的 app_on_before_command_line_processing 函数所调用，但由于 app_on_before_command_line_processing 函数不是导出函数，因此查找该函数的地址可能会费点功夫。\nHook BoringSSL上述方法虽然可以在大部分情况下打开调试工具，但有些情况下还是可能无法打开调试功能，比如开发者对 CEF 进行魔改。在无法打开调试工具时，使用 Proxifier + Fiddler 的组合就可以轻易的抓取 HTTP 数据包。\n如果需要抓取 HTTPS 数据包，可以使用 Hook BoringSSL 的方式。\n因为 CEF 使用了 OpenSSL 的 BoringSSL 分支，因此在抓取 HTTPS 数据包时，可以通过 Hook BoringSSL 的 SSL_read 和 SSL_write 函数来截获发送和接收的数据包，具体方法与上面小节介绍的 Hook OpenSSL 的 SSL_read 和 SSL_write 函数的方法类似。\n","categories":["③网络编程入门到实战"],"tags":["Hook","注入","HTTPS","Fiddler"]},{"title":"Node插件开发(2)-调用方式","url":"/post/235943795.html","content":"本文主要介绍如何在 Node-API 中实现不同类型的接口，主要有下面几种类型：\n\n同步调用\n基于 Napi::AsyncWorker 的异步调用，通过回调函数返回\n异步调用，返回 Promise\n基于 Napi::ThreadSafeFunction 的异步调用，通过回调函数返回\n\n\n\n同步调用同步调用会阻塞 Node.js 的主进程，适合接口能快速返回的场景。\nNapi::Number Add(const Napi::CallbackInfo&amp; info) &#123;    Napi::Env env = info.Env();    if (info.Length() != 2)        throw Napi::TypeError::New(env, &quot;Wrong number of arguments&quot;);    if (!info[0].IsNumber() || !info[1].IsNumber())        throw Napi::TypeError::New(env, &quot;Wrong arguments&quot;);    const int ret = info[0].ToNumber().Int32Value() + info[1].ToNumber().Int32Value();    return Napi::Number::New(env, ret);&#125;\n\n异步回调在 Node-API 中，不能在系统子线程中直接调用 JavaScript 函数，但可以借助 Napi::AsyncWorker 类来实现异步执行任务，在 Napi::AsyncWorker 类的 Execute 虚函数中执行具体的任务，并在其 OnOK 或 OnError 虚函数中执行 JavaScript 回调函数，通过回调的方式来返回结果到 JavaScript。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;如果在 Execute 函数中需要返回错误，可以调用 SetError 函数来设置错误信息，调用 SetError 函数后，OnError 函数就会被自动执行。需要注意的是，SetError 函数不会终止 Execute 函数的执行流程，通常会在 SetError 调用之后紧接 return 语句。\n当 Execute 函数执行完以后，如果期间没有调用 SetError 函数，则 OnOK 函数也会被自动执行。\n我们需要在 OnOK 或 OnError 中调用回调函数来将结果返回到 JavaScript，通常保持与 Node.js 官方模块的接口一样（当不是强制的），回调函数有 2 个参数 callback(err, result)，失败时 err 不为 Null，成功时 err 为 Null。\n下面示例以异步方式计算正整数 N 的 10 次方为例，通过回调方式返回计算结果。\nclass Power10AsyncWorker : public Napi::AsyncWorker &#123;   public:    Power10AsyncWorker(const Napi::Function&amp; callback, int32_t n) :        Napi::AsyncWorker(callback),        n_(n) &#123;    &#125;    void Execute() override &#123;        if (n_ &lt;= 0) &#123;            // N小于0则返回错误            SetError(&quot;N must larger than 0&quot;);            return;        &#125;        result_ = 1;        for (int i = 0; i &lt; 10; i++) &#123;            // 由于CPU计算10次方太快了，这里每次暂停10ms，模拟耗时操作            std::this_thread::sleep_for(std::chrono::milliseconds(10));            result_ *= n_;        &#125;    &#125;    void OnOK() override &#123;        Callback().Call(&#123;Env().Null(), Napi::Value::From(Env(), result_)&#125;);    &#125;    void OnError(const Napi::Error&amp; e) override &#123;        Callback().Call(&#123;e.Value(), Env().Null()&#125;);    &#125;   private:    int32_t n_ = 0;    int32_t result_ = 0; // 存储结果&#125;;\n\n定义接口GetPower10，支持 2 个参数：整数 N 和回调函数。\nvoid GetPower10(const Napi::CallbackInfo&amp; info) &#123;    Napi::Env env = info.Env();    if (info.Length() != 2)        throw Napi::TypeError::New(env, &quot;Wrong number of arguments&quot;);    if (!info[0].IsNumber() || !info[1].IsFunction())        throw Napi::TypeError::New(env, &quot;Wrong arguments&quot;);    int32_t n = info[0].ToNumber().Int32Value();    Napi::Function callback = info[1].As&lt;Napi::Function&gt;();    (new Power10AsyncWorker(callback, n))-&gt;Queue();&#125;\n\n返回 Promise 对象下面示例以异步计算正整数 N 的 20 次方为例，介绍如何返回 Promise 对象。当 N 小于 0 时，Promise 设置为 reject 状态。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;\nclass Power20AsyncWorker : public Napi::AsyncWorker &#123;   public:    Power20AsyncWorker(const Napi::Env&amp; env, const Napi::Promise::Deferred&amp; deferred, int32_t n) :        Napi::AsyncWorker(env),        deferred_(deferred),        n_(n) &#123;    &#125;    void Execute() override &#123;        if (n_ &lt;= 0) &#123;            // 小于0时返回错误            SetError(&quot;N must larger than 0&quot;);            return;        &#125;        result_ = 1;        for (int i = 0; i &lt; 20; i++) &#123;            // 由于CPU计算20次方太快了，每次暂停10ms，模拟耗时操作            std::this_thread::sleep_for(std::chrono::milliseconds(10));            result_ *= n_;        &#125;    &#125;    void OnOK() override &#123;        deferred_.Resolve(Napi::Number::New(Env(), result_));    &#125;    void OnError(const Napi::Error&amp; e) override &#123;        deferred_.Reject(e.Value());    &#125;   private:    Napi::Promise::Deferred deferred_;    int32_t n_ = 0;    int32_t result_ = 0; // 存储结果&#125;;\n\nNapi::Value GetPower20(const Napi::CallbackInfo&amp; info) &#123;    Napi::Env env = info.Env();    if (info.Length() != 1)        throw Napi::TypeError::New(env, &quot;Wrong number of arguments&quot;);    if (!info[0].IsNumber())        throw Napi::TypeError::New(env, &quot;Wrong arguments&quot;);    int32_t n = info[0].ToNumber().Int32Value();    Napi::Function callback = info[1].As&lt;Napi::Function&gt;();    Napi::Promise::Deferred deferred = Napi::Promise::Deferred::New(env);    (new Power20AsyncWorker(env, deferred, n))-&gt;Queue();    return deferred.Promise();&#125;\n\nThreadSafeFunction前面的示例都没有自己启动系统子线程，而是通过 Napi::AsyncWorker 实现的异步调用，在本示例中我们使用 C++ 11 的 std::thread 开启系统子线程，在子线程中执行任务并调用回调函数返回结果。\n要实现在系统子线程中调用 JavaScript 回调函数，需要借助于 Napi::ThreadSafeFunction 类来实现。\n下面示例演示了在系统子线程中计算正整数 N 的 30 次方，并通过回调方式返回计算结果。\nvoid GetPower30(const Napi::CallbackInfo&amp; info) &#123;    Napi::Env env = info.Env();    if (info.Length() != 2)        throw Napi::TypeError::New(env, &quot;Wrong number of arguments&quot;);    if (!info[0].IsNumber() || !info[1].IsFunction())        throw Napi::TypeError::New(env, &quot;Wrong arguments&quot;);    int32_t n = info[0].ToNumber().Int32Value();    Napi::Function callback = info[1].As&lt;Napi::Function&gt;();    std::thread* nativeThread = nullptr;    Napi::ThreadSafeFunction tsfn = Napi::ThreadSafeFunction::New(        env,        callback,        &quot;Resource Name&quot;,             // Name        0,                           // Unlimited queue        1,                           // Only one thread will use this initially        [nativeThread](Napi::Env) &#123;  // Finalizer used to clean threads up            if (nativeThread &amp;&amp; nativeThread-&gt;joinable()) &#123;                nativeThread-&gt;join();            &#125;        &#125;);    nativeThread = new std::thread([n, tsfn]() &#123;        struct CallParam &#123;            std::string error;            int32_t result = 0;        &#125;;        CallParam* param = new CallParam();        if (n &gt; 0) &#123;            param-&gt;result = 1;            for (int i = 0; i &lt; 30; i++) &#123;                param-&gt;result *= n;            &#125;        &#125;        else &#123;            param-&gt;error = &quot;N must larger than 0&quot;;        &#125;        auto callback = [](Napi::Env env, Napi::Function jsCallback, CallParam* param) &#123;            if (jsCallback &amp;&amp; param) &#123;                try &#123;                    if (param-&gt;error.empty()) &#123;                        jsCallback.Call(&#123;env.Null(), Napi::Number::New(env, param-&gt;result)&#125;);                    &#125;                    else &#123;                        Napi::Error err = Napi::Error::New(env, param-&gt;error);                        jsCallback.Call(&#123;err.Value(), env.Null()&#125;);                    &#125;                &#125; catch (std::exception&amp; e) &#123;#if (defined _WIN32 || defined WIN32)                    OutputDebugStringA(e.what());#endif                &#125;            &#125;            if (param) &#123;                delete param;            &#125;        &#125;;        napi_status status = tsfn.BlockingCall(param, callback);        if (status != napi_ok) &#123;            // TODO How to handle error        &#125;        tsfn.Release();    &#125;);&#125;\n","categories":["⑦现代Web与Electron桌面应用"],"tags":["Electron"]},{"title":"Node插件开发(1)-快速入门","url":"/post/819381949.html","content":"在使用 Electron 开发客户端时，如果现有 Node 模块所提供的功能无法满足需要，我们可以使用 C++ 开发自定义的 Node 模块，也称插件（addon）。\nNode.js 插件的扩展名为 .node，是二进制文件，其本质上是通过动态链接库（.dll 或 .so）重命名而来。\n\n\n选择 Node-API开发 Node.js 扩展的方式有三种：\n\nNode-API（以前叫 N-API）\nnan\n直接使用 v8、libuv 等库进行开发\n\n除非是为了使用 Node-API 未公开的接口，否则建议使用 Node-API 进行开发。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;因为 Node-API 是二进制（ABI）兼容的，它将底层 JavaScript 引擎与上层插件隔离开了，JavaScripty 引擎的修改不会影响我们开发的上层插件，我们基于某个版本编译的插件在不需要重新编译的情况下，就可以运行在其他版本的 Node.js 中。\n安装编译环境Node 插件使用 C++开发，因此在不同的系统上采用不同的编译环境。在 Linux 环境通常使用 GCC 和 LLVM；\nMac 环境通常使用 Xcode；\nWindows 环境通常使用 Visual Studio，如果不想安装完整的 Visual Studio，可以使用如下命令仅安装必要的工具链：\nnpm install --global windows-build-tools\n\nNode 插件通常使用 node-gyp 进行编译，node-gyp 基于 Google 的 gyp-next 构建系统，node-gyp 已经与 npm 捆绑在一起，但我们在使用 node-gyp 之前还需要先安装 Python。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;至此 Node 插件开发的环境已经搭建完成。\n搭建工程\n本文以在 Windows 下开发 Node 插件为例，其他系统环境在编译选项方面略有不同\n\npackage.json&#123;  &quot;name&quot;: &quot;node-addson-sample&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;private&quot;: true,  &quot;description&quot;: &quot;A sample node addson sample&quot;,  &quot;dependencies&quot;: &#123;    &quot;bindings&quot;: &quot;^1.5.0&quot;,    &quot;node-addon-api&quot;: &quot;^7.1.0&quot;  &#125;,  &quot;scripts&quot;: &#123;    &quot;build-debug&quot;: &quot;node-gyp --debug --arch=x64 configure rebuild&quot;,    &quot;build-release&quot;: &quot;node-gyp --release --arch=x64 configure rebuild&quot;,    &quot;test&quot;: &quot;node test.js&quot;  &#125;&#125;\n\n\n使用npm install安装依赖项。\n\n各个依赖项的作用如下：\n\nnode-addon-api用于提供了 Node-API 相关的头文件；\n\nbindings用于帮助插件开发者快速导入编译后的.node 插件，方便调试，这个依赖是非必须；\n\n\nbuild-debug和build-release脚本分别用于编译 Debug 和 Release 版本的插件；\ntest脚本用于执行测试用例；\n32 位插件指定 arch 为 ia32（--arch=ia32）就可以编译 32 位版本的 Node 插件。&lt;原文出自: jiangxueqiao.com，请尊重原创&gt;需要注意：64 位版本 Node.js 只能加载 64 位的 Node 插件，32 位版本的 Node.js 也只能加载 32 位的 Node 插件，否则会报错：\nError: \\\\?\\D:\\node-addon-sample\\build\\Debug\\node-addon-sample.node is not a valid Win32 application.\n\n编译脚本Node-API 支持 GYP 和 CMake.js 两种编译方式，这里选择使用 GYP 方式。\n新建binding.gyp文件，内容如下：\n&#123;  &quot;targets&quot;: [    &#123;      &quot;target_name&quot;: &quot;node-addson-sample&quot;, # ***.node      &quot;cflags!&quot;: [ &quot;-fno-exceptions&quot; ],      &quot;cflags_cc!&quot;: [ &quot;-fno-exceptions&quot; ],      # 指定需要编译的源文件      &quot;sources&quot;: [ &quot;main.cpp&quot; ],      &quot;include_dirs&quot;: [        &quot;&lt;!@(node -p \\&quot;require(&#x27;node-addon-api&#x27;).include\\&quot;)&quot;      ],      # 预编译宏      &quot;defines&quot;: [        &quot;NAPI_CPP_EXCEPTIONS&quot;, # 在Node-API中启用C++异常      ],      &quot;conditions&quot;: [        [          # Windows平台编译选项          &quot;OS == &#x27;win&#x27;&quot;, &#123;            &quot;configurations&quot;: &#123;              # Debug编译选项              &quot;Debug&quot;: &#123;                # 预编译宏                &quot;defines&quot;: [ &quot;DEBUG&quot;, &quot;_DEBUG&quot; ],                &quot;cflags&quot;: [ &quot;-g&quot;, &quot;-O0&quot; ],                &quot;conditions&quot;: [                  [                    &quot;target_arch==&#x27;x64&#x27;&quot;, &#123;                      &quot;msvs_configuration_platform&quot;: &quot;x64&quot;,                    &#125;                  ],                ],                &quot;msvs_settings&quot;: &#123;                  &quot;VCCLCompilerTool&quot;: &#123;                    # 0 - MultiThreaded (/MT)                    # 1 - MultiThreadedDebug (/MTd)                    # 2 - MultiThreadedDLL (/MD)                    # 3 - MultiThreadedDebugDLL (/MDd)                    &quot;RuntimeLibrary&quot;: 1, # /MTd                    &quot;Optimization&quot;: 0, # /Od, no optimization                    &quot;MinimalRebuild&quot;: &quot;false&quot;,                    &quot;OmitFramePointers&quot;: &quot;false&quot;,                    &quot;BasicRuntimeChecks&quot;: 3, # /RTC1                    &quot;AdditionalOptions&quot;: [                      &quot;/EHsc&quot;                    ],                  &#125;,                  &quot;VCLinkerTool&quot;: &#123;                    &quot;LinkIncremental&quot;: 2, # Enable incremental linking                    # 附加依赖库                    &quot;AdditionalDependencies&quot;: [                    ],                  &#125;,                &#125;,                # 附加包含目录                &quot;include_dirs&quot;: [                ],              &#125;,              # Debug编译选项              &quot;Release&quot;: &#123;                # 预编译宏                &quot;defines&quot;: [ &quot;NDEBUG&quot; ],                &quot;msvs_settings&quot;: &#123;                  &quot;VCCLCompilerTool&quot;: &#123;                    &quot;RuntimeLibrary&quot;: 0, # /MT                    &quot;Optimization&quot;: 3, # /Ox, full optimization                    &quot;FavorSizeOrSpeed&quot;: 1, # /Ot, favour speed over size                    &quot;InlineFunctionExpansion&quot;: 2, # /Ob2, inline anything eligible                    &quot;WholeProgramOptimization&quot;: &quot;false&quot;, # Dsiable /GL, whole program optimization, needed for LTCG                    &quot;OmitFramePointers&quot;: &quot;true&quot;,                    &quot;EnableFunctionLevelLinking&quot;: &quot;true&quot;,                    &quot;EnableIntrinsicFunctions&quot;: &quot;true&quot;,                    &quot;RuntimeTypeInfo&quot;: &quot;false&quot;,                    &quot;ExceptionHandling&quot;: &quot;2&quot;, # /EHsc                    &quot;AdditionalOptions&quot;: [                      &quot;/MP&quot;, # compile across multiple CPUs                    ],                    &quot;DebugInformationFormat&quot;: 3,                    &quot;AdditionalOptions&quot;: [                    ],                  &#125;,                  &quot;VCLibrarianTool&quot;: &#123;                    &quot;AdditionalOptions&quot;: [                      &quot;/LTCG&quot;, # link time code generation                    ],                  &#125;,                  &quot;VCLinkerTool&quot;: &#123;                    &quot;LinkTimeCodeGeneration&quot;: 1, # link-time code generation                    &quot;OptimizeReferences&quot;: 2, # /OPT:REF                    &quot;EnableCOMDATFolding&quot;: 2, # /OPT:ICF                    &quot;LinkIncremental&quot;: 1, # disable incremental linking                    # 附加依赖库                    &quot;AdditionalDependencies&quot;: [                    ],                  &#125;,                &#125;,                # 附加包含目录                &quot;include_dirs&quot;: [                ],              &#125;            &#125;          &#125;,        ]      ]    &#125;  ]&#125;\n\nbinding.gyp 中的编译选项大多与特定平台的编译器有关，具体可以查阅相关编译器文档，如 Windows 平台可以查询MSVC 文档。\n可以使用如下命令指定需要使用的 Visual Stuido 版本：\nnpm config set msvs_version 20xx\n\nnode-gyp 官方提供了一些示例，我们可以从这些示例中获取不少灵感：\nbinding.gyp-files-in-the-wild\nGYP 官方文档：\nhttps://gyp.gsrc.io/docs/UserDocumentation.md\n第一个 API现在新建main.cpp，在该文件中定义我们的第一个 API，API 名为Add，支持传入 2 个整数参数，返回整数相加的和。\n#include &lt;napi.h&gt;// 同步调用// 计算两个整数相加结果并返回Napi::Number Add(const Napi::CallbackInfo&amp; info) &#123;    Napi::Env env = info.Env();    if (info.Length() != 2)        throw Napi::TypeError::New(env, &quot;Wrong number of arguments&quot;);    if (!info[0].IsNumber() || !info[1].IsNumber())        throw Napi::TypeError::New(env, &quot;Wrong arguments&quot;);    const int ret = info[0].ToNumber().Int32Value() + info[1].ToNumber().Int32Value();    return Napi::Number::New(env, ret);&#125;\n\n在定义完 API 之后，还需要将 API 导出，在文件末尾添加如下代码：\n// 导出函数Napi::Object Init(Napi::Env env, Napi::Object exports) &#123;    exports.Set(Napi::String::New(env, &quot;Add&quot;), Napi::Function::New(env, Add));    return exports;&#125;NODE_API_MODULE(addon, Init)\n\n如果忘记导出 API，加载 Node 插件时会报错：\nError: Module did not self-register: &#x27;\\\\?\\D:\\node-addson-sample\\build\\Debug\\node-addson-sample.node&#x27;.\n\n现在执行npm run build-debug编译 Debug 版本插件，编译生成的 node 插件路径为build\\Debug\\node-addson-sample.node。\n测试用例新建test.js，测试代码如下：\nconst sample = require(&quot;bindings&quot;)(&quot;node-addson-sample.node&quot;);console.log(sample.Add(100, 200)); // 输出300\n\n使用bindings模块可以不用考虑插件的具体位置，该模块会自动帮我们在项目目录下遍历查找。\n数据类型在napi.h头文件中有很多继承自Napi::Value的子类，这些类分别对应 JavaScript 中的数据类型，如：\n\nNapi::Boolean -&gt; Boolean\nNapi::Number -&gt; Number\nNapi::String -&gt; String\nNapi::Function -&gt; Function\nNapi::Symbol -&gt; Symbol\nNapi::Array -&gt; Array\nNapi::Object -&gt; Object\n\nNode-Api 还定义 Promise、Date、Buffer 等数据类型。\nNull 和 UndefinedNull 和 Undefined 比较特殊，没有定义专门的类，由Env类的成员函数返回。\nenv.Null()env.Undefined()\n\n创建对象有两种方式可以用来创建指定类型的对象，以创建 Boolean 类型为例：\nNapi::Boolean::New(env, true)Napi::Value::From(env, false)\n\n以创建一个对象数组为例介绍对象和数组的使用方法：\nNapi::Array result = Napi::Array::New(env);for (size_t i = 0; i &lt; 3; i++) &#123;    Napi::Object obj = Napi::Object::New(env);    obj.Set(Napi::String::New(env, &quot;filePath&quot;), Napi::String::New(env, &quot;/root/&quot; + std::to_string(i) + &quot;.txt&quot;));    obj.Set(Napi::String::New(env, &quot;fileSize&quot;), Napi::Number::New(env, i * 100));    result.Set(Napi::Number::New(env, i), obj);&#125;\n\n类型校验Napi::Value提供了若干方法用于判断当前对象是否为指定类型，如：\n\nIsUndefined\nIsNull\nIsBoolean\nIsNumber\nIsString\nIsSymbol\nIsArray\nIsObject\nIsFunction\nIsPromise\nIsBuffer\n\n异常可以在编译脚本binding.gyp中通过预编译宏指定是否启用 C++异常：\nNAPI_CPP_EXCEPTIONSNAPI_DISABLE_CPP_EXCEPTIONS\n\n如果启用 C++异常，则Napi::Error会继承自 std::exception。\nclass Error : public ObjectReference#ifdef NAPI_CPP_EXCEPTIONS    ,              public std::exception#endif  // NAPI_CPP_EXCEPTIONS...\n\n在启动 C++异常的情况下，从 Node 插件抛出异常的方式如下：\nthrow Napi::TypeError::New(env, &quot;Wrong number of arguments&quot;);\n\n将会中断当前函数 throw 后面代码的执行。\nTypeError 继承自 Error，通常用于表示与类型错误相关的异常。类似的错误类型还有RangeError等，也可以直接抛出Error类型的错误：\nthrow Napi::Error::New(env, &quot;Wrong number of arguments&quot;);\n\n在没有启用 C++ 异常的情况下，采用如下方式从 Node 插件抛出异常：\nNapi::TypeError::New(env, &quot;Wrong number of arguments&quot;).ThrowAsJavaScriptException();return;\n\n抛出异常后需要使用 return 语句终止下面流程的执行。\n\nNode-API 官方文档：node-addon-api docNode.js 官方 addon 示例：node-addon-examples\n\n","categories":["⑦现代Web与Electron桌面应用"],"tags":["Electron"]}]