[{"title":"Lua杂记","path":"/post/3843160677.html","content":"自从接触了 JerryScript（见开源库jerryscript使用备忘），本以为再也不会用到 Lua 了，关于 Lua 的记忆已经逐渐在我的脑海中删除，但最近维护的几个老项目又都使用了 Lua，真是命运的捉弄啊。 来吧，刷新记忆！ 一、基础 Lua区分大小写 注释格式1234-- 行注释--[[块注释--]] 局部变量使用local声明, 其他的全部为全局变量，变量的默认值为nil 只有false和nil为假，其他的全部为真 Lua中字符串都是不可变的常量 使用..可以连接字符串 Lua没有整形，都是实数 可以在字符串前放置操作符#来获取字符串长度，某些情况下对table也适用 关系操作符: &lt; &gt; &#x3D;&#x3D; &gt;&#x3D; &lt;&#x3D;，不等于使用~=，而不是!= and, or, not 逻辑操作符返回的不一定是true和false，这点与C++不同，它返回的是对应表达式的运行结果 支持多重赋值12-- a为0， b为1， c为nila,b,c = 0,1 控制结构1234567if exp then -- somethingelseif exp then -- somethingelse -- somethingend 123while &lt;exp is true&gt; do -- somethingend 123repeat -- somethinguntil &lt;exp is true&gt; 123for var=exp1, exp2, exp3 do -- somethingend 123for i,v in ipairs(a) do -- somethingend 123for i in pairs(a) do -- somethingend 二、函数 函数也是值 2.1 多重返回值Lua中函数可以返回多个值，但有下面的特殊情况： 函数作为单独的语句时，会丢弃所有返回值 函数作为表达式的一部分时，只保留第一个返回值 在多重赋值中，函数作为最后一个表达式时，会保留尽可能多的返回值 将函数调用放在一对括号中，会迫使其只返回一个值 2.2 变长参数123456789function add(...) local ret = 0 for i,v in ipairs(&#123;...&#125;) do -- 或 for i,v in ipairs&#123;...&#125; do ret = ret + v end return retendprint(add(1,2,9)) 123function foo(...) local a,b,c = ...end 12345-- 跟踪函数foo的调用function FooCallLog(...) print(&quot;Call foo:&quot;, ...) return foo(...)end 123456789101112-- 使用函数select访问变长参数function add(...) local ret = 0 for i = 1, select(&quot;#&quot;, ...) do -- select(&quot;#&quot;, ...)获取参数个数 local arg = select(i, ...) -- select(n, ...) 获取第n个参数 ret = ret + arg end return retendprint(add(1,3,5)) 2.3 闭合（Closure）函数1234567891011121314function newCounter() -- 该函数返回一个匿名函数 local i = 0 return function () -- 在匿名函数内部，变量i是一个“非局部的变量” i = i + 1 return i endendc1 = newCounter()print(c1()) -- 输出：1print(c1()) -- 输出：2c2 = newCounter()print(c2()) -- 输出：1 2.4 非全局函数将一个函数存储到一个局部变量中，即得到了一个“局部函数”。 12345678local lib=&#123;foo = function(x,y) return x + y end,goo = function(x,y) return x - y end &#125; 123local lib=&#123;&#125;function lib.foo(x,y) return x + y endfunction lib.goo(x,y) return x - y end 对与递归程序等，为了防止局部函数为尚定义完毕，就要被编译，可以使用前置定义的方式: 12345678local factfact = function(n) if n == 0 then return 1 else return fact(n-1) endend 三、编译、执行与错误3.1 loadstring123a = 20f = loadstring(&quot;local a = 10; print(a)&quot;)f() -- 输出：10 3.2 pcall12345678910111213function foo(n) if n &gt; 0 then print(n) else error(&quot;n need &gt; 0&quot;) endendif pcall(foo, -1) then print(&quot;ok&quot;)else print(&quot;error&quot;)end pcall也可以执行匿名函数。 四、协同程序Lua将所有和协同程序相关的函数存储在名为“coroutine”的table中。一个协同程序可以有4种状态：suspended, running, dead, normal。 12345678910111213141516171819202122232425co = coroutine.create(function() coroutine.yield() for i = 0, 2 do if i == 2 then error(&quot;oh No.&quot;) end print(i) endend)print(coroutine.resume(co)) -- 当创建协同程序时，其处于suspended状态print(coroutine.resume(co)) -- resume是在保护模式中运行的print(coroutine.resume(co))--[[ 输出：true01false D:\\MyLua\\Basic\\coroutine.lua:5: oh No.false cannot resume dead coroutine--]] 五、元表与元方法Lua中每个值都有一个元表，table和userdata可以有各自独立的元表，而其他类型的值则共享其类型所属的单一元表。 Lua在创建新的table时不会创建元表。除了标准的字符串程序库外，其他的类型在默认情况下都没有元表。 12345t=&#123;&#125;print(getmetatable(t)) --&gt;nilprint(getmetatable(&quot;hi&quot;)) --&gt; table: 0x80772e0print(getmetatable(10)) --&gt; nil 可以在元表中定义的原方法(或字段)如下： __add 加 __sub 减 __mul 乘 __div 除 __unm 相反数 __mod 取模 __pow 乘幂 __eq 等于 __lt 小于 __le 大于 __concat 连接 __tostring 字符串转化 __metatable 保护元表123456789101112131415161718local mt = &#123;&#125;mt.__tostring = function(t) local l = &#123;&#125; for e in pairs(t) do l[#l + 1] = e end return &quot;&#123;&quot; .. table.concat(l, &quot;, &quot;) .. &quot;&#125;&quot;endages = &#123;Jeff = 18, Jim = 19, Lucy = 20&#125;print(ages) --&gt; table: 0x003286e8setmetatable(ages, mt)print(ages) --&gt; &#123;Lucy, Jeff, Jim&#125;mt.__metatable = &quot;not your business&quot;print(getmetatable(ages)) --&gt; not your business __index Table访问 __newindex Table更新123456789101112131415161718192021222324252627282930-- 跟踪Table访问的示例local index = &#123;&#125;local mt=&#123;__index = function(t, k) print(string.format(&quot;*access to element %s, value %s&quot;, k, t[index][k])) return t[index][k]end,__newindex = function(t, k, v) print(&quot;*update of element &quot; .. tostring(k) .. &quot;to &quot; .. tostring(v)) t[index][k] = vend&#125;function track(t) local proxy = &#123;&#125; -- __index和__newindex都是在table中没有所需访问的index时才发挥作用 proxy[index] = t -- 类似多维数组 setmetatable(proxy, mt) return proxyendages = &#123;Jeff = 18, Jim = 19, Lucy = 20&#125;ages = track(ages)print(ages.Jeff)address = &#123;Jeff = &quot;WuHan&quot;, Jim = &quot;Beijin&quot;, Lucy = &quot;Taiyuan&quot;&#125;address = track(address);print(address.Jim) 六、模块与包6.1 模块搜索对于require(“foo”)语句，Lua会先在预定路径中搜索foo.lua，如果没有搜索到才会搜索foo.DLL。 require在搜索Lua文件时，会在变量package.path存放的路径中进行搜索，Lua启动后便以环境变量LUA_PATH的值来初始化该变量； 而搜索DLL文件的路径则存放在package.cpath中，同理，Lua启动后会用LUA_CPATH环境变量的值来初始化该变量。 12345print(package.path)--[[;.\\?.lua;C:\\Program Files (x86)\\ZeroBrane\\bin\\lua\\?.lua;--]] require会用模块名来替换每个“?”，依次匹配搜索，直到搜索成功。 6.2 基本模块编写编译一个模块最简单的方法就是：创建一个table，并将所有需要导出的函数放入其中，最后返回这个table。 12345678910-- file: basic_mod.luabasicmod = &#123;&#125;basicmod.name = &quot;basic mod&quot;function basicmod.func1() print(&quot;func1&quot;)endreturn basicmod 调用该模块： 123require(&quot;basic_mod&quot;)print(basicmod.name) --&gt; basic modprint(basicmod.func1()) --&gt; func1 但是上面的写法会导致模块中的每个函数或成员前面都带有该模块的名称，更改模块名称会牵一发而动全身，针对这个问题，可以进行如下改进： 1234567891011-- file: basic_mod.lualocal M = &#123;&#125; -- 借用一个局部table变量basicmod = MM.name = &quot;basic mod&quot;function M.func1() print(&quot;func1&quot;)endreturn basicmod 实际上，可以完全避免写模块名，因为require会将模块名作为参数传递给模块： 1234567891011-- file: basic_mod.lualocal modname = ...local M = &#123;&#125;_G[modname] = Mpackage.loaded[modname] = MM.name = &quot;basic mod&quot;function M.func1() print(&quot;func1&quot;)end 123require(&quot;basic_mod&quot;) -- 此时模块函数存储的table名称就是模块的文件名print(basic_mod.name)print(basic_mod.func1()) 在Lua5.1中，提供了一个新的函数module，简化模块的编写： 1234567module(..., package.seeall)name = &quot;basic mod&quot;function func1() -- 函数前不需要加入模块名限定 print(&quot;func1&quot;)end 七、面向对象使用this（或self）参数是所有面向对象语言的核心。大多数面向对象语言都能对程序员隐藏this参数，从而使得程序员不必显示的声明这个参数。 Lua只需要使用冒号就能隐藏该参数，冒号的作用就是在一个方法的定义中添加一个额外的隐藏参数，以及在一个方法的调用中添加一个额外的实参，冒号只是一种语法便利，并没有引入任何新的东西。 12345678910Account = &#123;balance = 0&#125;function Account.cost(v) Account.balance = Account.balance - v -- 只能针对全局名称Account来工作endAccount.cost(100) -- 调用正常a = Account; Account = nila.cost(100) -- 错误：attempt to index global &#x27;Account&#x27; (a nil value) 改进如下： 123456789Account = &#123;balance = 0&#125;function Account.cost(self, v) self.balance = self.balance - vendAccount.cost(Account, 100)a = Account; Account = nila.cost(a, 100) 使用冒号改进： 123456789Account = &#123;balance = 0&#125;function Account:cost(v) self.balance = self.balance - vendAccount:cost(100)a = Account; Account = nila:cost(100)","tags":["Lua"],"categories":["编程基础"]},{"title":"Wireshark过滤器规则速学","path":"/post/556603567.html","content":"Wireshark 中有两种过滤器： 捕获过滤器：用于在数据包捕获阶段过滤数据包，只捕获符合条件的数据包，这样可以减少捕获不必要的数据包，从而提高性能。 显示过滤器：用于在已经捕获的数据包中过滤出符合条件的数据包进行显示，它使用的是 Wireshark 自己的语法。 一、捕获过滤器在 Wireshark 的开始页面或者在捕获选型页面中选择需要捕获的网络适配器，然后输入捕获过滤器规则，设置完成之后，点击“开始”按钮即可使用该规则在对应适配器上进行网络流量抓取。 1.1 BPF语法捕获过滤器使用的是 BPF（Berkeley Packet Filter）语法，BPF语法规则如下： 一个过滤表达式（expression）由一个或多个原语（primitives）组成。 一个原语（primitive）由一个或多个限定词（qualifiers）组成，限定词之间使用空格分隔。 每组限定词最后跟着值，表示最后的计算结果等于该值时条件成立，而不支持大于、小于等其他比较运算符。 原语之间使用逻辑操作符（operators）连接，逻辑操作符可以使用 and、or、not 表示，也可以使用 &amp;&amp;、||、!。 如下图所示： 如下面的捕获过滤器表示：只捕获源 IP地址 为 192.168.1.100 且目的 TCP 端口为 80 的数据包。 1ip src 192.168.1.100 and tcp dst port 80 Wireshark是非常遵守网络协议的，在过滤器中的ip表示的是ip协议，而不是我们通常认为的ip地址。 各个限定词出现的先后顺序也是按照网络协议的规则而来的，比如IP协议有源地址和目标地址之说，因此针对源地址和目标地址的捕获表达式分别如下： 12ip src 192.168.1.100ip dest 192.168.1.101 捕获过滤器不支持直接过滤应用层的协议，如http、ftp等，因为为了保证效率，在捕获时还未进行协议解析。 1.2 常用捕获过滤规则地址过滤 host 192.168.1.33：捕获与 192.168.1.33 这个 IPv4 地址相关的所有流量。 host 2308:8277:420:152a:819:41f0:28fa:8862： 捕获与这个 IPv6 地址相关的所有流量。 host www.baidu.com： 捕获与域名 www.baidu.com 相关的所有流量。 ether host 52:54:99:2f:37:b1： 捕获与这个 MAC 地址相关的所有流量。 src host 192.168.1.33：只捕获源地址为 192.168.1.33 的流量。 dest host 192.168.1.33：只捕获目标地址为 192.168.1.33 的流量。 端口过滤 port 8080：捕获 8080 端口的流量，包括流入或流出的，这里无关使用的是哪一种传输层协议，tcp、udp还是其他，只要端口为8080就都捕获。 !src port 8080 不捕获掉源端口为 8080 流量。 协议过滤 icmp：只捕获 icmp 协议产生的流量。 !ip6: 不捕获 IPv6 的流量。 二、显示过滤器显示过滤器的规则与捕获过滤器类似，但有些地方不一样。 显示过滤器的限定词之间使用.进行分割，而捕获过滤器使用的是空格； 捕获过滤器只支持等于这一种比较运算符，而显示过滤器支持更多的比较运算符，如==、&gt;、&lt;、!=、&gt;=、&lt;=。 虽然逻辑运算符与捕获过滤器类似，但多了一种异或运算符，使用 xor 表示。 下面示例表示：捕获ip源地址不等于192.168.1.1，并且tcp协议端口号为80的流量。 1ip.src != 192.168.1.1 and tcp.port &gt; 80 不同于捕获过滤器，显示过滤器的规则需要更加地明确，如： 对端口号的指定需要加上协议限定词，如tcp.port == 80，而不能像捕获过滤器那样不管协议，只要是该端口就捕获，如 port 80。 显示过滤器不能使用host，因为 host 太笼统了，既可以表示ip源&#x2F;目标地址，也可以表示域名，在显示过滤器中可以使用 ip.src 、ip.dest或http.host 替代。 2.1 小技巧显示过滤器规则有很多，我们都需要记住吗？记不住，也没必要，我们只需要记住常用的规则就可以了。 在使用Wireshark抓包时，我们可以选择报文中的某一项，点击右键，选择“作为过滤器应用”即可使用该项作为过滤器，如下图所示：","tags":["Wireshark"],"categories":["编程基础"]},{"title":"2025蛇来运转","path":"/post/2721888631.html","content":"写下这一行预示着2024年的工作即将结束，农历蛇年即将到来。 蛇，象征着智慧与灵动，蜿蜒前行，希望在新的一年里，面对生活的曲折，也能够以灵活的姿态应对，凭借智慧化解难题。 愿2025年蛇来运转！ 物来顺应，未来不迎。 当时不杂，既过不恋。","categories":["杂念"]},{"title":"Windows系统各版本占比对技术选型的影响","path":"/post/2306363290.html","content":"49420f43dcd4ffad5e1774efbcfcadee1df58b08bd2027afeeff190f6d3914caa3f5046f3f5bad5b765f8cbb26ace04d6965f94871d34eafdab6cc28b4206ec5923d3968c22469732531493518815210892145cff461ac8a8fb2a237750d7842771878571b9008bad5d5f30e6d3ad86bb644fda522166f202c972259dfc028974b69f095caa8d5b77cd27cdedaa4ac899377d20a00be9995f7881bcd106590837ff386be93f1c195600fc5a244fd5242024464d283358d629d5a87c4d0eaae5e2d740a0e2aae6c40dc2854859529b59faa10704c399588f138db6097f16f67d8ac1d14d3755bdbe14e4f91356508b7329982a479767417beddd0509fe77f57e029a43c689b1e52663654395e320c1d3047615969ebe89793a7eee4b630f2928de8b6a63a88a3871cf91937634430faa3b86745ddbad29154a6101df9c75a082356c4cf0de32adb1676f79e344339db3cf8d1c7f5cefc092d1cedfad1c16fae5864b31085efe02d77010801d8224cb3857e2de8719e70fc6734ec47b69b186d05cccfa011002cbdb47fc6eaaa799cf078bdeb6073fd16d37c8bcd216992edd1ebba4011707a8f4e6fcd4df8811be78bf8b8109f72b2cc90e495bc3649b5bce9fe8b87a3fcdb8ccfd7466844ebe65cd6a71ae3d2263a72987685f523b9fd1b4c69e9a5ddf49f747d2883e99cc0d7c797eb8be5255189ee61942373f0c7e26bc64583ab28ff5cc4d44802597c55b5600724c3e398eef5520ca68ddb2decf045814518c6596eab4f5ffac9ebb52f5ab8ba2a00b60f9c3c7ba49e997437fc1af88ce660abcf4f30f627411f1f04d3829b3460d3cb1e911e8cee55f6f32f06ec7926dd1a4630d6f9fd6f91da9041b184aa77e4aadd053a291b668369c924df2550bf585d4986ba62ed656faef12906d6308a6450bd5846aeb2eb40ee66ee11dc855cc536717270ff5dcaaf2dd8a5723c7613dc3729f575052e867914f89ff0c8f5dff4bbe457f0cca56215e0208654f0ebfb1b12d23a5f4dc28287e6d2825ddc8de1e50302cc8d366e9d1137d85dca5de87a88e145834a99e420527fc26e89b865267dba5f54741f4a87441293edb964bd28e53f26eace6bc1aac24ba98942b99b8052b7cfbd6b94f3ef499fad333134768d2d0ae0374b3f1483e13cb514ecdc32aa6f1a07529adf59f5cdcde3eac413bb95c4afef5b4719cfa2835342b0064043f0555afbb93fcda255a99bbd3ec3acba8ad41d7525218f3c13f3d1eea5972c6eaf74edfe2313e9dde97df19291fcaf7deaaeaac0ea1581881750e8f1f4c10fe14f359a73e73158bd08c17a52704de5dfa78669d34e7d30adfb5e3ffbf7a0a243ed7d1855ae899603be66d43cc45243489399683d020e2501a9af0aaa6a86ec4b35b8a41517f27f71429de269e262baa4345e9115c08e41210c999b7a7cec809d3c088b075503f5a6732cd96b4d65821557df8242080e3882c43b1e34d3394facdd7508c3b43c682417d8a1da4b8a7304719b0da91ff0fb37576bb16a68ce296532df6c89504dedfed221055fca8fa34b164d69b9f18f6d11d2da4c921ac51501b152590b2bca2e1cda04883baa2d65f93ead7ee4e39d312f38d0fde8246dea9ec789501d96dd7f710b85a209300199d070771e77e5789dc40e61eea41a38d5d4a0881dc2972177aeb49472d660dd32e3ec9a83bc122d9d63c48c53f2d77bdd5bf0032861835bdf2d5cf0b0e1a0f8443c5380001e6d75dad4c08382d9bd23bd07bf336d4753bc7cd743034c874216f736f6d0489855e9cd2f8f50eada41f25616949c6f3ffc070ddedadb81f2224acedf7ee4c6b7f78e2a295dc950849b557bb0ba4385c910fa0fb1791c71c12c6c4205625977431fa78e3c542543e49a00390db01dd7d2b3ae7e50a9f63a96fcc1dd40e52c126a4c2c548217ef9367e1d58a87eb5b5ee841fbf9d8f391e624c050d5f9444a11fe1ec36f7b242e29494e65555b996aa1a0f766ba960794d864577ec73e7810fb6c2fc36ca3d75fb2076ef2c849593c6d7b1067316333d2577259ba84eacec00f7f46a7c6c329941cb12c0e381622c2bf42be6d747192550cafd5499ca8b8203d68f59eaf464945a4fe5a8ebbbb9259411a89dbb3f2aef3a1deb1ca7b8c5b83713aa5daa94de6d65f13b73f974e179818dcbb4f6913d483456f1d501a5b6d60c96f761619ad6bc54bd34c99985d3008253e388c138c5bc18ff2435c83ae31d49e341f28f6fbecdcacc1a4935b1bd4b1cc690f417c6526759be6acaf41b4362873822ca0272bdaf75d8b20a498f73e249730ab34565e1454fe7a0581a1be17cf2e893c13e54fd56e2eae382718ffcf21cffd3ce7fadade6ab72119ef219b7c02578a4f21e82a8091f76fde822870429e0d1bfd3e6d6946863afe2d1e89944cce59be41a228d96b6c78808a57a951c8804529f52e64c898339e3c055b165eb4f1f7bd17eb6bddc894e0ec706693e07ff251603b4d2b1bc9db6c3a24a1d7796fa3acd39076b484bfa9539f535e4bf6dbda98b8fe5840621914e9f306184b5460ae34f6eb2a5efef86e3d5c449bb494bb84 文章已被加密，请联系作者获取密码","categories":["项目管理"]},{"title":"Modern CMake 简明教程（下）","path":"/post/201509401.html","content":"CMake 是一个开源、跨平台的构建系统生成器（Build-system Generator）。 本文是 Modern CMake 简明教程系列的下篇，上篇请移步至 《Modern CMake 简明教程（上）》，中篇请移步至 《Modern CMake 简明教程（中）》。 本教程默认 CMake 最低版本为 3.16，即 cmake_minimum_required(VERSION 3.16)。 一、集成第三方库在项目中集成第三方库是一种非常常见的需求，CMake 提供了两种方式来集成第三方库。 第一种：直接集成第三方库的源码。 说到集成第三方库的源码，我们第一时间想到的可能就是将其源码直接拷贝到项目目录中，然后提交到 git 仓库，更加高级一点可能会使用 git submodule 的方式。但我以为这两种方式都不够优雅，无法很好的管理、更新依赖库，特别是在项目的依赖库的比较多时。 CMake 提供了两个模块（两种方式）来集成第三方库的源码： FetchContent该模块支持在 CMake 生成项目时就下载第三方库，还会自动将第三方库添加到项目中，不需要手动调用 add_subdirectory。 ExternalProject该模板支持在构建（编译）项目时下载第三方库。显然 ExternalProject 的下载时机要晚于 FetchContent 。 第二种：使用预编译好的第三方库。 这种方式需要先单独编译安装第三方库，然后使用 find_package 查找该库，最后设置目标的相关属性，如包含目录、依赖库等。 1.1 FetchContentFetchContent 的使用大致分为两个步骤。 步骤一： 使用 FetchContent_Declare 命令记录要获取的内容，可以多次调用 FetchContent_Declare 命令来记录获取多个内容。 FetchContent_Declare 的定义如下： 12345678FetchContent_Declare( &lt;name&gt; &lt;contentOptions&gt;... [EXCLUDE_FROM_ALL] [SYSTEM] [OVERRIDE_FIND_PACKAGE | FIND_PACKAGE_ARGS args...]) 其中，&lt;name&gt; 可以是任何不带空格的字符串，并且该名称不区分大小写，但通常我们仅使用字母、数字和下划线。 下面示例分别演示了如何从 Git 仓库、https链接、SVN仓库获取内容： 1234567891011121314151617FetchContent_Declare( googletest GIT_REPOSITORY https://github.com/google/googletest.git GIT_TAG 703bd9caab50b139428cea1aaff9974ebee5742e # release-1.10.0)FetchContent_Declare( myCompanyIcons URL https://intranet.mycompany.com/assets/iconset_1.12.tar.gz # 下载完后，会自动解压 URL_HASH MD5=5588a7b18261c20068beabfb4f530b87)FetchContent_Declare( myCompanyCertificates SVN_REPOSITORY svn+ssh://svn.mycompany.com/srv/svn/trunk/certs SVN_REVISION -r12345) 步骤二： 调用 FetchContent_MakeAvailable 命令开始获取上面声明的内容。 如： 1FetchContent_MakeAvailable(googletest myCompanyIcons myCompanyCertificates) 1.1.1 结果如果 FetchContent 执行成功，下面几个变量会设置： &lt;lowercaseName&gt;_POPULATED始终被设置为 TRUE &lt;lowercaseName&gt;_SOURCE_DIR目标内容的源码目录 &lt;lowercaseName&gt;_BINARY_DIR目标内容的构建目录 1.1.2 使用代理限于国内的网络环境，在获取内容时，很可能出现下载失败的情况，此时可以尝试使用 http 和 https 代理来解决该问题。 通过设置相应的环境变量即可设置 http(s) 代理，如： 12set(ENV&#123;http_proxy&#125; &quot;http://127.0.0.1:7890&quot;)set(ENV&#123;https_proxy&#125; &quot;http://127.0.0.1:7890&quot;) 1.2 find_packagefind_package 用于查找已经安装到本机的包，将查找结果存储在 &lt;PackageName&gt;_FOUND 变量中（查找到包，值为 1，否则 为 0），包的安装路径存储在 &lt;PackageName&gt;_DIR 变量中，通常还会定义一些变量来指明包的版本、头文件目录的路径、.lib 或 .a 文件的路径等，这些变量名称的格式会根据查找方式的不同、包的不同而不同。 find_package 使用起来比较简单，通常我们只需要使用它的基础定义： 1find_package(&lt;PackageName&gt; [&lt;version&gt;] [REQUIRED] [COMPONENTS &lt;components&gt;...]) &lt;PackageName&gt;指定包的名称，是唯一的必选参数。 &lt;version&gt;指定需要查找包的版本，major[.minor[.patch[.tweak]]]，支持多种形式的版本，如 3、3.1、3.1.2 等，可以指定匹配大版本还是小版本匹配等，也可以通过指定 EXACT 选项来要求版本完全一致，当然也可以完全省略版本约束。 REQUIRED参数用于指定该包是必须找到，如果没有找到则停止执行该 CMake 脚本。 find_package 的完整定义可以见：full-signature 下面示例用于查找大版本为 3 的 OpenCV 包： 12345find_package(OpenCV 3 REQUIRED)message(STATUS &quot;OpenCV_DIR = $&#123;OpenCV_DIR&#125;&quot;)message(STATUS &quot;OpenCV_INCLUDE_DIRS = $&#123;OpenCV_INCLUDE_DIRS&#125;&quot;)message(STATUS &quot;OpenCV_LIBS = $&#123;OpenCV_LIBS&#125;&quot;) 不同的查找模式find_package 有两种查找包的方式，优先使用 Module 模式，如果 Module 模式没有查找到，再使用 Config 模式查找。 Module 模式find_package 使用 Module 模式查找包就是查找 Find&lt;PackageName&gt;.cmake 文件的过程，会尝试在下面位置中查找该文件，优先级从高到低依次为： CMAKE_PREFIX_PATH该变量是以分号分隔的列表，默认为空，由用户设置；也可以定义环境变量 CMAKE_PREFIX_PATH，环境变量 $ENV{CMAKE_PREFIX_PATH} 定义的列表会附加到 ${CMAKE_PREFIX_PATH} 变量的后面。 CMAKE_MODULE_PATH 该变量也是以分号分隔的列表，默认为空，由用户设置。 Find&lt;PackageName&gt;.cmake 文件从何而来？ 如果你是库的开发者，你是不需要提供 Find&lt;PackageName&gt;.cmake 文件的，你只需要按照文章 Modern CMake 简明教程（中） “安装导出依赖项”章节介绍的那样，在安装时生成 &lt;PackageName&gt;Config.cmake（或 &lt;lowercasePackageName&gt;-config.cmake 文件）即可，该文件可以用于 find_package 的 Config 模式查找。 对于那些没有按照规范提供上述 Config 文件的库，才需要使用者来编写 Find&lt;PackageName&gt;.cmake，辅助查找包的安装路径。 Config 模式find_package 指令在大多情况下都是通过 Config 模式来查找到包的具体位置的。 find_package 使用 Config 模式查找包就是查找 &lt;PackageName&gt;Config.cmake或 &lt;lowercasePackageName&gt;-config.cmake 文件的过程。 在 Config 模式下，&lt;PackageName&gt; 可以通过 NAMES 参数来指定多个需要匹配查找的包名（PackageName），例如下面查找 Qt5 或 Qt6 的方式： 1find_package(QT NAMES Qt6 Qt5 REQUIRED COMPONENTS Widgets) 而且在该模式下，find_package 查找 config 文件的步骤也非常复杂，尤其是可以根据不同开关来查找不同的路径，下面介绍几个常用的查找 config 文件的位置（完整的见官方文档），按优先级从高到低依次为： &lt;PackageName&gt;_DIR 变量或环境变量所指定的目录，默认为空。 CMAKE_PREFIX_PATH、CMAKE_FRAMEWORK_PATH、CMAKE_APPBUNDLE_PATH 变量或环境变量所指定的目录，该变量是以分号分隔的列表，默认为空。 PATH 环境变量所指定的目录，该变量是以分号分隔的列表，默认为系统 PATH 环境变量的值。如果该变量中的路径以 bin 或 sbin 结尾，则自动回退到上一级目录进行查找。 与 Module 模式不同的是，在上述几个位置中，除了第 1 个指定的目录是“根目录”，CMake 只会在该目录的根目录下查找 &lt;PackageName&gt;Config.cmake或 &lt;lowercasePackageName&gt;-config.cmake 文件，不会进入其子目录中查找，如设置 OpenCV_DIR 为 /home/jack，CMake 只会查验如下文件： 12/home/jack/OpenCVConfig.cmake/home/jack/opencv-config.cmake 而第 2、3 所指定的目录都是“路径前缀”，CMake 不仅会在根目录下查找 &lt;PackageName&gt;Config.cmake或 &lt;lowercasePackageName&gt;-config.cmake 文件，还会进入其子目录内查找。当然 CMake 不会无脑的遍历所有子目录，而且只在特定的子目录内进行查找，不同系统环境下所查找的子目录也不同，具体如下表所示。 查找路径 系统环境 &lt;prefix&gt;/(cmake|CMake)/ Windows &lt;prefix&gt;/&lt;name&gt;*/ Windows &lt;prefix&gt;/&lt;name&gt;*/(cmake|CMake)/ Windows &lt;prefix&gt;/&lt;name&gt;*/(cmake|CMake)/&lt;name&gt;*/ Windows &lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/ Uninx &lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/ Uninx &lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/(cmake|CMake)/ Uninx &lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/ Windows、Uninx &lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/ Windows、Uninx &lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/(cmake|CMake)/ Windows、Uninx 在上表中，&lt;prefix&gt;就是第 2、3 项所指定的路径前缀；&lt;name&gt; 为包名，不区分大小写，&lt;name&gt;* 的意思是包名后面还可以接一些字符，如 OpenCV-3.0。 结果获取无论是哪种查找模式，我们都需要获取查找的结果。目前我能确定的是，这两种查找模式都会定义 &lt;PackageName&gt;_FOUND 和 &lt;PackageName&gt;_DIR 变量，对于不同的库还会定义不同的变量，如何知道他们到底定义了哪些变量呢？ 我有一个粗暴但好用的方法：在调试时，遍历当前 CMake 中的所有变量。 下面 dump_all_variables 函数会输出当前 CMake 的所有变量： 123456function(dump_all_variables) get_cmake_property(_VARS VARIABLES) foreach (_V $&#123;_VARS&#125;) message(STATUS &quot;&gt;&gt;&gt;&gt;&gt;&gt; $&#123;_V&#125; = $&#123;$&#123;_V&#125;&#125;&quot;) endforeach()endfunction() 使用： 1dump_all_variables() 1.3 集成 Qt在项目中集成 Qt 库需要先使用 find_package 查找 Qt 的安装位置。对于 Qt4， CMake 使用 Module 模式进行查找（FindQt4.cmake 由 CMake 提供），而 对于 Qt5、Qt6，则是使用 Config 模式进行查找，相应的 config 文件位于类似下面的目录中 D:\\Qt\\5.15.2\\msvc2019\\lib\\cmake。 具体从哪些位置查找 Qt，参见上面的“find_package”章节。 示例： 1234567891011find_package(Qt6 COMPONENTS Widgets DBus REQUIRED)add_executable(publisher publisher.cpp)target_link_libraries(publisher Qt6::Widgets Qt6::DBus)find_package(Qt5 COMPONENTS Gui DBus REQUIRED)add_executable(subscriber1 subscriber1.cpp)target_link_libraries(subscriber1 Qt5::Gui Qt5::DBus)find_package(Qt4 REQUIRED)add_executable(subscriber2 subscriber2.cpp)target_link_libraries(subscriber2 Qt4::QtGui Qt4::QtDBus) 众所周知，编译 Qt 代码需要依赖 Qt 提供的一些工具来生成相关的 C++ 代码，如： moc元对象编译器，将 Qt 扩展的 C++ 语法（如 Q_OBJECT）转换成标准 C++ 语法。 rcc把 .qrc 资源文件编译成标准 C++ 代码。 uic把 .ui 文件编译成标准 C++ 代码。 在 CMake 中要使用这些工具并不复杂，只需要提前开启相关特性，CMake 就会自动调用相关工具。 12345set(CMAKE_AUTOMOC ON)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTORCC ON) 下面是一个简单的 CMake Qt 项目示例，该示例仅使用了 Qt 的 QWidget 模块。 源文件结构如下： 12345CMakeLists.txtmain.cppmainwindow.cppmainwindow.hmainwindow.ui CMakeLists.txt 内容如下： 1234567891011121314151617181920212223242526272829cmake_minimum_required(VERSION 3.16)project(hello_qt)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTOMOC ON)set(CMAKE_AUTORCC ON)find_package(Qt5 REQUIRED COMPONENTS Widgets)add_executable(hello_qt main.cpp mainwindow.cpp mainwindow.h mainwindow.ui)target_link_libraries(hello_qt PRIVATE Qt5::Widgets)if(MSVC) target_compile_options(hello_qt PRIVATE /execution-charset:utf-8) set_target_properties(hello_qt PROPERTIES WIN32_EXECUTABLE TRUE VS_DEBUGGER_ENVIRONMENT &quot;PATH=$&#123;Qt5_DIR&#125;/../../../bin;%PATH%&quot; )endif()install(TARGETS hello_qt) 在上面示例中，设置了可执行字符集为 utf-8，这种方式可以防止 Qt 在 MSVC 环境下出现中文乱码，详见之前的文章 拨开字符编码的迷雾(2)--编译器处理文件编码。 设置 WIN32_EXECUTABLE 属性是为了让链接器使用 /SUBSYSTEM:WINDOWS 子系统，如下图所示： 而设置 VS_DEBUGGER_ENVIRONMENT 属性是为了设置 Visual Studio 的调试环境（如下图所示），确保在调试时能找到 Qt 的相关 dll 文件。 在之前的 Modern CMake 简明教程（上） 中已经介绍了目标属性的设置。 二、MSVC2.1 设置 MSVC 运行库MSVC 的运行库有 MD &#x2F; MDd 和 MT &#x2F; MTd 之分，下图是 Visual Studio 中设置运行库的界面。 CMake 针对 MSVC 环境默认使用的是 MD &#x2F; MDd 运行库，通过下面的方式可以将运行库设置为 MT &#x2F; MTd： 12# 需要 CMake 3.15 及以上版本set(CMAKE_MSVC_RUNTIME_LIBRARY &quot;MultiThreaded$&lt;$&lt;CONFIG:Debug&gt;:Debug&gt;&quot;) 2.2 预编译头文件CMake 在 3.16 版本中提供了 target_precompile_headers 指令来添加预编译头文件，语法如下： 123target_precompile_headers(&lt;target&gt; &lt;INTERFACE|PUBLIC|PRIVATE&gt; [header1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [header2...] ...]) 在 3.16 版本之前，需要支持预编译头，可以参考网络上的解决方案： 定义 USE_MSVC_PCH 宏： 1234567891011121314151617181920212223242526272829macro(USE_MSVC_PCH PCH_TARGET PCH_HEADER_FILE PCH_SOURCE_FILE) if(MSVC) # 获取预编译头文件的文件名，通常是stdafx get_filename_component(PCH_NAME $&#123;PCH_HEADER_FILE&#125; NAME_WE) # 生成预编译文件的路径 if(CMAKE_CONFIGURATION_TYPES) # 如果有配置选项（Debug/Release），路径添加以及配置选项 SET(PCH_DIR &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/PCH/$&#123;CMAKE_CFG_INTDIR&#125;&quot;) else() SET(PCH_DIR &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/PCH&quot;) endif() # 创建预编译文件的路径 file(MAKE_DIRECTORY $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/PCH) # 设置项目属性，使用预编译头文件 set_target_properties($&#123;PCH_TARGET&#125; PROPERTIES COMPILE_FLAGS &quot;/Yu$&#123;PCH_HEADER_FILE&#125; /FI$&#123;PCH_HEADER_FILE&#125; /Fp$&#123;PCH_DIR&#125;/$&#123;PCH_NAME&#125;.pch&quot;) # 预编译源文件（stdafx.cpp）设置属性，创建预编译文件 set_source_files_properties($&#123;PCH_SOURCE_FILE&#125; PROPERTIES COMPILE_FLAGS &quot;/Yc$&#123;PCH_HEADER_FILE&#125;&quot;) # 把预编译文件寄到清除列表 set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES $&#123;PCH_DIR&#125;/$&#123;PCH_NAME&#125;.pch) endif()endmacro() 然后使用该宏添加预编译头文件： 1USE_MSVC_PCH(test_app stdafx.h stdafx.cpp) 三、相关资料https://github.com/ttroy50/cmake-examples https://github.com/Akagi201/learning-cmake https://github.com/KDE/extra-cmake-modules https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1 https://hsf-training.github.io/hsf-training-cmake-webpage/aio/index.html https://github.com/rpavlik/cmake-modules https://github.com/onqtam/awesome-cmake https://github.com/Lectem/cpp-boilerplate https://github.com/CLIUtils/modern_cmake https://github.com/dev-cafe/cmake-cookbook https://github.com/BrightXiaoHan/CMakeTutorial https://cliutils.gitlab.io/modern-cmake/ https://cgold.readthedocs.io/en/latest/ https://www.siliceum.com/en/blog/post/cmake_01_cmake-basics","tags":["CMake"],"categories":["CMake"]},{"title":"Modern CMake 简明教程（中）","path":"/post/2304457467.html","content":"CMake 是一个开源、跨平台的构建系统生成器（Build-system Generator）。 本文是 Modern CMake 简明教程系列的中篇，上篇请移步 《Modern CMake 简明教程（上）》 本教程默认 CMake 最低版本为 3.16，即 cmake_minimum_required(VERSION 3.16)。 一、生成器表达式不知你是否思考过这样一个问题：我们在编译项目时，通常有不同的配置，如 Debug 和 Release，如何在不同的配置中定义不同的预编译宏、包含不同的目录、依赖不同的库呢？ 其实要解决这个问题，并不困难，只需要使用到 CMake 中的 生成器表达式。我们在开源项目的 CMake 脚本中经常看到的 $&lt;...&gt; 这样的表达式就是生成器表达式，但通常都会嵌套使用，如 $&lt;$&lt;...&gt;:...&gt;。 生成器表达式通常有下面几种形式： $&lt;condition:true_string&gt; $&lt;IF:condition,true_string,false_string&gt; $&lt;BOOL:string&gt; 特定的语法形式，如 $&lt;CONFIG:cfgs&gt; 表示当前配置存在于 cfgs 列表中时，表达式结果为 1，否则为 0。 前三种形式比较简单，最后一种形式虽然有多种类型，但我们通常只需要记忆几种常用的，有需要时查阅官方文档。 1.1 $&lt;condition:true_string&gt;condition 只允许为 0 或 1，其他任何值都会报错。 当 condition 为 1 时，表达式返回 true_string； 当 condition 为 0 时，表达式返回空字符串。 如： 123456set(ENABLE_JSONCPP 1)target_include_directories( my_lib PUBLIC $&lt;$&#123;ENABLE_JSONCPP&#125;:$&#123;CMAKE_SOURCE_DIR&#125;/jsoncpp/include&gt; ) 1.2 $&lt;IF:condition,true_string,false_string&gt;condition 只允许为 0 或 1，其他任何值都会报错。 当 condition 为 1 时，表达式返回 true_string； 当 condition 为 0 时，表达式返回 false_string。 如下面示例，当设置了 ENABLE_JSONCPP 为 1 时，包含 jsoncpp 头文件，否则包含 rapidjson 头文件： 123456set(ENABLE_JSONCPP 1)target_include_directories( my_lib PUBLIC $&lt;IF:$&#123;ENABLE_JSONCPP&#125;,$&#123;CMAKE_SOURCE_DIR&#125;/jsoncpp/include,$&#123;CMAKE_SOURCE_DIR&#125;/rapidjson/include&gt; ) 1.3 $&lt;BOOL:string&gt;前面 2 种形式的 condition 都只允许为 0 或 1，这种限制未免有些呆板，如果 ENABLE_JSONCPP 的值不是 1 ，而是 ON 时，该怎么办呢？ 此时可以使用 $&lt;BOOL:string&gt; 将其转换成 0 或 1。 何时转换成 0，何时转换成 1？可以参考前面的《Modern CMake 简明教程（上）》 的“条件判断”章节，在该章节中介绍的所有为假的情况都会转换成 0，其他情况则转换成 1。 该表达式的作用注定了其单独使用意义不大，通常都是和其他表达式一起使用，如将上面示例中的 ENABLE_JSONCPP 设置为 ON： 123456set(ENABLE_JSONCPP ON)target_include_directories( my_lib PUBLIC $&lt;IF:$&lt;BOOL:$&#123;ENABLE_JSONCPP&#125;&gt;,$&#123;CMAKE_SOURCE_DIR&#125;/jsoncpp/include,$&#123;CMAKE_SOURCE_DIR&#125;/rapidjson/include&gt; ) 1.4 逻辑运算运算符表达式也支持与、或、非三种逻辑运算，语法如下： 12345$&lt;AND:conditions&gt;$&lt;OR:conditions&gt;$&lt;NOT:condition&gt; 其中，condition 都只允许是 0 或 1，conditions（复数形式）表示可以是由逗号分割的多个条件列表。 1.5 其他常见表达式条件CMake 还支持很多类型的生成器表达式，下面列举了一些常见的表达式，这些表达式通常都是用来作为上面介绍的表达式中的条件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 字符串比较，string1 与 string2 相等则为 1，反之为 0$&lt;STREQUAL:string1,string2&gt;# 数值比较，相等为 1，反之为 0$&lt;EQUAL:value1,value2&gt;# 版本比较，v1 小于 v2 时为 1，反之为 0$&lt;VERSION_LESS:v1,v2&gt;# 其他版本比较$&lt;VERSION_GREATER:v1,v2&gt;$&lt;VERSION_EQUAL:v1,v2&gt;$&lt;VERSION_LESS_EQUAL:v1,v2&gt;$&lt;VERSION_GREATER_EQUAL:v1,v2&gt;# string 存在于 list列表中时为 1，反之为 0$&lt;IN_LIST:string,list&gt;# 当前配置名称$&lt;CONFIG&gt;# 当前配置存在于cfgs列表中时为 1，反之为 0$&lt;CONFIG:cfgs&gt;# 平台ID，见 CMAKE_SYSTEM_NAME$&lt;PLATFORM_ID&gt;# 当前平台ID存在于 platform_ids 列表中时为 1，反之为 0$&lt;PLATFORM_ID:platform_ids&gt;# C++编译器版本$&lt;CXX_COMPILER_VERSION&gt;# C++编译器版本与 version 匹配时为 1，反之为 0# $&lt;CXX_COMPILER_VERSION:version&gt;# 当前的C++编译器ID$&lt;CXX_COMPILER_ID&gt;# 当前的C++编译器ID存在于 compiler_ids 列表中时为 1，反之为 0$&lt;CXX_COMPILER_ID:compiler_ids&gt;# 目标存在时为 1，反之为 0$&lt;TARGET_EXISTS:tgt&gt;# 返回tgt目标的prop属性的值，如果未设置该属性，则返回空字符串$&lt;TARGET_PROPERTY:tgt,prop&gt;# 返回正在计算表达式的目标上的prop属性的值，如果未设置该属性，则返回空字符串$&lt;TARGET_PROPERTY:prop&gt;# 当使用 install(EXPORT) 导出属性时，返回 ... 内容，否则返回空$&lt;INSTALL_INTERFACE:...&gt;# 当使用 export()导出属性或者被同一构建系统内的另一个目标使用时，返回 ... 内容，否则返回空$&lt;BUILD_INTERFACE:...&gt; 1.6 转义字符在生成器表达式中如果需要使用特殊字符，可以使用其转移字符。 123456789101112# &gt;$&lt;ANGLE-R&gt;# ,$&lt;COMMA&gt;# ;$&lt;SEMICOLON&gt;# &quot;# 需要 CMake &gt;= 3.30$&lt;QUOTE&gt; 二、安装侠义的“安装”是将目标编译生成的文件拷贝到指定位置，CMake 中的安装包含但不限于拷贝文件，还可以执行脚本、修改权限等操作。 上面这句话中，涉及到了2个术语，有必要解释一下。 “目标编译生成的文件”在 CMake 中有个学名，叫 Output Artifacts，直译为输出工件，我更愿意将其翻译为“输出品”，不同类型的目标有不同的输出品，例如在 Windows 平台上，可执行程序输出 .exe 文件，动态库输出 .dll 文件（也可能包含 .lib 文件），静态库输出 .lib 文件….. 请牢记 Artifacts 这个单词，在后面的很多定义中都会出现该词。 “指定位置”，顾名思义，我们可以指定一个安装位置。CMake 会从 CMAKE_INSTALL_PREFIX 变量中读取安装位置，该变量有默认值，我们也可以修改该变量来改变安装位置。 在不同的操作系统上，CMAKE_INSTALL_PREFIX 的默认值不同： Windows 系统：C:/Program Files/$&#123;PROJECT_NAME&#125;写入该目录需要管理员权限，因此如果安装失败，请检查是否具有管理员权限。 UNIX 系统：/usr/local CMAKE_INSTALL_PREFIX 指定的位置是安装目录的根目录，不同类型的输出品会存放在其不同的子目录中，如 .lib 文件存放在 lib 目录，.dll 和 .exe 文件存放在 bin 目录，头文件存放在 include 目录，这些子目录的具体名称可以通过 GNUInstallDirs 提供的若干变量来获取，如 CMAKE_INSTALL_BINDIR、CMAKE_INSTALL_LIBDIR、CMAKE_INSTALL_INCLUDEDIR 等。 CMake 定义了下列常用的输出品种类（artifact-kind），这些种类在后面的 install 选项中会使用到： ARCHIVE这种类型的输出品包含下列文件（默认位于 lib 目录）： 静态库，Windows 上是 .lib 文件，Linux 上是 .a 文件，但在 macOS 上标记为 FRAMEWORK 的除外。 动态库的导入库，如 .lib 文件。 在macOS系统上，为启用 ENABLE_EXPORTS 的共享库所创建的链接器导入文件（但标记为 FRAMEWORK 的情况除外）。 LIBRARY这种类型的输出品很少用到。 RUNTIME这种类型的输出品包含下来文件（默认位于 bin 目录）： 各个系统所支持的可执行文件，如 Windows 上的 .exe。 动态库，如 .dll 和 .so 文件。 OBJECTS与对象库（使用add_library(&lt;name&gt; OBJECT ...)方式定义）关联的对象文件。 FRAMEWORK在 macOS 上，标有 FRAMEWORK 属性的静态库和共享库都被视为 FRAMEWORK 类型。 BUNDLE在 macOS 上，标有 MACOSX_BUNDLE 属性的可执行文件被视为 BUNDLE 类型。 PUBLIC_HEADER PRIVATE_HEADER 2.1 install使用 install 指令可以定义在安装时需要执行的操作，install 可以定义很多类型的操作，包含但不限于拷贝输出品到指定位置、执行脚本等。 下面是 install 指令支持的调用形式： 12345678install(TARGETS &lt;target&gt;... [...])install(IMPORTED_RUNTIME_ARTIFACTS &lt;target&gt;... [...])install(&#123;FILES | PROGRAMS&#125; &lt;file&gt;... [...])install(DIRECTORY &lt;dir&gt;... [...])install(SCRIPT &lt;file&gt; [...])install(CODE &lt;code&gt; [...])install(EXPORT &lt;export-name&gt; [...])install(RUNTIME_DEPENDENCY_SET &lt;set-name&gt; [...]) 通过执行 make install 命令或者编译 CMake 生成的 INSTALL 项目，就可以执行 install 指令预先定义的安装操作。 2.2 不同的安装命令2.2.1 安装 Target所谓安装 Target 就是将目标的输出品及其关联文件拷贝到指定位置。 123456install(TARGETS &lt;target&gt;... [EXPORT &lt;export-name&gt;] [RUNTIME_DEPENDENCIES &lt;arg&gt;...|RUNTIME_DEPENDENCY_SET &lt;set-name&gt;] [&lt;artifact-option&gt;...] [&lt;artifact-kind&gt; &lt;artifact-option&gt;...]... [INCLUDES DESTINATION [&lt;dir&gt; ...]] ) &lt;artifact-option&gt; 用于指定与输出品相关的选项，可以是下面选项中的一个或多个（常用的选项主要是 DESTINATION 和 PERMISSIONS）： 1234567[DESTINATION &lt;dir&gt;][PERMISSIONS &lt;permission&gt;...][CONFIGURATIONS &lt;config&gt;...][COMPONENT &lt;component&gt;][NAMELINK_COMPONENT &lt;component&gt;][OPTIONAL] [EXCLUDE_FROM_ALL][NAMELINK_ONLY|NAMELINK_SKIP] 第一组 &lt;artifact-option&gt; 所设置的选项应用于在本次调用中没有指定输出品类型时。 我们通常会为不同类型的输出品指定不同的选项，如下面示例为不同类型的输出品指定了不同的安装位置： 1234567set_target_properties(hello_cmake PROPERTIES PUBLIC_HEADER include/my_lib.h)install(TARGETS hello_cmake ARCHIVE DESTINATION $&#123;CMAKE_INSTALL_LIBDIR&#125; # 仅为演示，这样写多此一举 RUNTIME DESTINATION $&#123;CMAKE_INSTALL_BINDIR&#125; # 仅为演示，这样写多此一举 PUBLIC_HEADER DESTINATION $&#123;CMAKE_INSTALL_INCLUDEDIR&#125;/my_lib) 在实际项目中，我们不会使用 PUBLIC_HEADER 来安装头文件，而是使用下面介绍的 install(DIRECTORY ... ) 命令。 EXPORT选项EXPORT 是一个非常有用的选项，当我们的项目需要作为库被第三方使用时，为了让第三方能够通过 find_package 所查找到所安装的库，就需要在安装时生成 xxxConfig.cmake 文件。 当然，仅仅通过在此指定 EXPORT 选项还不够，此处的 EXPORT 选项仅仅表示将 Target 所安装的输出品绑定到 &lt;export-name&gt; 上，后面我们还需要使用单独的 install(EXPORT ...) 语句来生成 xxxConfig.cmake 文件，详见下面的 “安装导出依赖项” 节。 2.2.2 拷贝目录拷贝目录到指定位置，语法如下： 12345678910install(DIRECTORY dirs... TYPE &lt;type&gt; | DESTINATION &lt;dir&gt; [FILE_PERMISSIONS &lt;permission&gt;...] [DIRECTORY_PERMISSIONS &lt;permission&gt;...] [USE_SOURCE_PERMISSIONS] [OPTIONAL] [MESSAGE_NEVER] [CONFIGURATIONS &lt;config&gt;...] [COMPONENT &lt;component&gt;] [EXCLUDE_FROM_ALL] [FILES_MATCHING] [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;] [EXCLUDE] [PERMISSIONS &lt;permission&gt;...]] [...]) 可以使用 TYPE 或 DESTINATION 来指定目标路径，其中 TYPE 的取值来自于 GNUInstallDirs 提供的若干变量，如 BIN 等同于 CMAKE_INSTALL_BINDIR 变量。 示例： 123install(DIRECTORY ./common TYPE INCLUDE)install(DIRECTORY ./common DESTINATION &quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;&quot;) 2.2.3 拷贝文件拷贝文件到指定位置，语法如下： 123456install(FILES &lt;file&gt;... TYPE &lt;type&gt; | DESTINATION &lt;dir&gt; [PERMISSIONS &lt;permission&gt;...] [CONFIGURATIONS &lt;config&gt;...] [COMPONENT &lt;component&gt;] [RENAME &lt;name&gt;] [OPTIONAL] [EXCLUDE_FROM_ALL]) 2.2.4 执行脚本在安装时执行脚本文件或者脚本代码，语法如下： 123install([[SCRIPT &lt;file&gt;] [CODE &lt;code&gt;]] [ALL_COMPONENTS | COMPONENT &lt;component&gt;] [EXCLUDE_FROM_ALL] [...]) 如果脚本文件的路径是相对路径，则该路径相对于当前项目的根目录（即 CMAKE_SOURCE_DIR 变量存储的路径）。 示例： 1install(SCRIPT &quot;./my_lib/helper.cmake&quot;) 1install(CODE &quot;message(\\&quot;Sample install message.\\&quot;)&quot;) 2.2.5 安装导出依赖项如果在安装 Target（见上面的5.2.1节） 时已经指定了 EXPORT 选项，则可以通过 install(EXPORT ...) 的形式来安装需要导出的依赖性，即生成 xxxConfig.cmake 文件，该文件名不是固定的，可以通过 FILE 选项来指定其他名称，但必须是 .cmake 类型的文件。 123456789install(EXPORT &lt;export-name&gt; DESTINATION &lt;dir&gt; [NAMESPACE &lt;namespace&gt;] [FILE &lt;name&gt;.cmake] [PERMISSIONS &lt;permission&gt;...] [CONFIGURATIONS &lt;config&gt;...] [CXX_MODULES_DIRECTORY &lt;directory&gt;] [EXPORT_LINK_INTERFACE_LIBRARIES] [COMPONENT &lt;component&gt;] [EXCLUDE_FROM_ALL] [EXPORT_PACKAGE_DEPENDENCIES]) &lt;export-name&gt; 选项所指定的名称需要与在 install(TARGET ... EXPORT ...) 语句中指定名称一致。 通常为了防止和其他库命名冲突，我们会使用 NAMESPACE 添加命名空间。 在生成 xxxConfig.cmake 文件以后，就可以使用 find_package 来查找并引用依赖库了： 12find_package(MyLib REQUIRED)target_link_libraries(OtherApp PRIVATE my_lib::my_lib) 三、与 CMake 交互CMake 与构建项目交互的方式有两种: 使用 configure_file 指令动态生成配置文件，通过配置文件的方式来将数据传递给项目，如在 C&#x2F;C++ 项目中动态生成 .h 文件。 使用 file 指令创建配置文件，file 指令的功能非常强大，包含众多与文件相关的操作，如读写文件、下载上传文件、遍历目录等。 本节只介绍 configure_file 指令，该指令用于根据模板文件在指定位置生成新的文件。 12345configure_file(&lt;input&gt; &lt;output&gt; [NO_SOURCE_PERMISSIONS | USE_SOURCE_PERMISSIONS | FILE_PERMISSIONS &lt;permissions&gt;...] [COPYONLY] [ESCAPE_QUOTES] [@ONLY] [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ]) 我们首先需要通过 &lt;input&gt; 选项来指定一个模板文件，虽然模板文件可以是任意的后缀名，但我们通常使用 .in 后缀名，例如我们需要通过模板文件生成 version.h 文件，则模板文件名为 version.h.in。 configure_file 指令会将 &lt;input&gt; 模板文件中的诸如 @VAR@、$&#123;VAR&#125;、$CACHE&#123;VAR&#125;、$ENV&#123;VAR&#125; 形式的变量都替换为对应变量的值，如果变量没有被定义，则替换为空字符串。 我们通常还会指定 @ONLY 选项，指定该选项后，就只有 @VAR@ 形式的变量会被替换，而其他形式的变量会保留不变，这种方式虽然在生成 .h 文件时没有什么用途，但谁又说 configure_file 只能生成 .h 文件了？如果是生成 .cmake 文件，是不是就有作用了咧。 1234567// version.h.in#define VERSION_MAJOR @VERSION_MAJOR@#define VERSION_MINOR @VERSION_MINOR@#define VERSION_PATCH @VERSION_PATCH@#define BUILD_TIMESTAMP &quot;@BUILD_TIMESTAMP@&quot; 123456789101112# CMakeLists.txtstring(TIMESTAMP BUILD_TIMESTAMP &quot;%Y-%m-%d %H:%M:%S&quot;)set(VERSION_MAJOR 1)set(VERSION_MINOR 0)set(VERSION_PATCH 1)configure_file ( &quot;$&#123;CMAKE_SOURCE_DIR&#125;/include/version.h.in&quot; &quot;$&#123;CMAKE_SOURCE_DIR&#125;/include/version.h&quot;) 执行 CMake 脚本，动态生成的 version.h 内容如下： 12345#define VERSION_MAJOR 1#define VERSION_MINOR 0#define VERSION_PATCH 1#define BUILD_TIMESTAMP &quot;2024-09-30 16:51:57&quot; 上述变量替换的方式有一个弊端：虽然能动态替换模板语句中变量的值，但却不能控制语句是否存在。比如我们经常在 C&#x2F;C++ 项目中根据宏是否被定义来做判断，而不是根据宏的值来做判断： 123#ifdef BUILD_SHARED_LIBS#endif 这个是时候就需要使用另外一个语法形式了：#cmakedefine VAR ...，在这种形式中是直接使用变量名的，而不需要使用 @ @ 进行包裹。 当定义了 VAR 变量时，将替换为（…就是模板文件中 VAR 后面的内容）： 1#define VAR ... 当没有定义 VAR 变量时，将替换为： 1/* #undef VAR */","tags":["CMake"],"categories":["CMake"]},{"title":"Modern CMake 简明教程（上）","path":"/post/3678619994.html","content":"CMake 是一个开源、跨平台的构建系统生成器（Build-system Generator）。 CMake 是构建系统生成器，而不是构建系统，CMake 支持生成不同构建系统所支持的工程文件，如 Visual Studio，XCode，Makefile 等。 本教程作为 CMake 的简明教程，不会事无巨细的讲述 CMake 的每一个语法，而是以实用为目的，介绍 CMake 的基础语法和常用指令。 虽然只是简明教程，但通过本教程，你仍然可以掌握 CMake 的脉络，熟练应用 CMake 于项目中。 一、Modern CMakeCMake 距今已有 20 多年的历史，CMake 从 3.0 开始引入 Target 概念，有了 Target 和 Property 的定义，CMake 也就更加地现代化。 我们将引入 Target 概念之前（也就是 3.0 之前）的 CMake 称之为老式 CMake，之后的称之为现代 CMake（Modern CMake）。 现代 CMake 是围绕 Target 和 Property 来定义的，在现代 CMake 中不应该出现诸如下面的指令： add_compile_options include_directories link_directories link_libraries 因为这些指令都是目录级别的，在该目录（含子目录）上定义的所有目标都会继承这些属性，这样会导致出现很多隐藏依赖和多余属性的情况。 我们最好直接针对 Target 进行操作，如： 1234567add_executable(hello main.cpp)# 老式写法include_directories(./include)# 现代写法target_include_directories(hello PRIVATE ./include) 本文讲述的知识点只适用于现代 CMake，让我们脱掉沉重的历史包袱，轻装上阵吧！ 二、基础概念所有的构建系统都需要通过某个入口点来定义项目（如 Visual Studio 的 .sln 文件），CMake 作为构建系统生成器也不例外，CMake 使用的是 CMakeLists.txt 的文件，该文件以 UTF-8 编码（也支持 UTF-8 BOM 文件头），其中存储了符合 CMake 语言规范的脚本代码。 2.1 项目结构CMake 没有强制规定 CMakeLists.txt 文件的位置以及项目的目录结构，但目前大多数项目都会采用相似的目录结构。 如果项目名称为 my_project，且该项目包含一个名为 lib 的库和一个名为 app 的程序，则目录结构通常如下面所示： 1234567891011121314151617181920212223242526- my_project - .gitignore - README.md - LICENSE.md - CMakeLists.txt - cmake - FindSomeLib.cmake - something_else.cmake - include - my_project - lib.h - src - CMakeLists.txt - lib.cpp - apps - CMakeLists.txt - app.cpp - tests - CMakeLists.txt - testlib.cpp - docs - CMakeLists.txt - extern - googletest - scripts - helper.py 当然，上面的名称并不是一成不变的，可以根据自己的喜好来定义，例如 my_project 可以是任意的项目名，如果不喜欢复数，可以将 tests 改成test，如果没有 python 代码，也可以移除 python 目录，cmake 目录则用于存放 CMake 辅助脚本。 从上面的目录结构可以看到，CMakeLists.txt 文件分散在各个子目录中，但在 include 目录中没有 CMakeList.txt 文件，这样是为了防止暴露不必要的文件给库的使用者，因为 include 目录中存放的是库的头文件，在安装时通常都会将该目录拷贝到指定位置（如Linux系统的 &#x2F;usr&#x2F;include）。 extern 目录用于存放第三方依赖库的源码，这些库可以通过 git submodule 的形式来管理，也可以直接将源码拷贝到此，并提交到项目 git 中。但无论使用哪种方式，依赖库最好能支持 CMake，这样可以方便的使用 add_subdirectory 命令将项目添加到工程中（如果你对 add_subdirectory 命令的具体用法还不了解，这没关系，现在你只需要知道该命令可以添加任何包含 CMakeLists.txt 的目录到项目中即可）。 2.2 一个简单的示例在学习 CMake 之前，我们先将 CMake 玩起来。我们先从一个简单的示例开始，了解 CMake 的基本玩法。 该示例是只包含一个 main.cpp 文件，我们期望编译该文件能生成 hello_cmake 程序。 目录结构如下： 123- hello_cmake - main.cpp - CMakeLists.txt main.cpp 文件的内容非常简单： 123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;hello cmake&quot;); return 0;&#125; CMakeLists.txt 内容如下： 12345678910# 设置 CMake 的最低版本cmake_minimum_required(VERSION 3.16)# 设置项目名称project (hello_cmake)# 添加一个名为 hello_cmake 的目标# 目标类型为可执行文件# 使用 main.cpp 来编译生成 hello_cmake 可执行文件（如hello_cmake.exe）add_executable(hello_cmake main.cpp) 完成上面步骤，我们就可以使用 CMake GUI 或命令行（当然你需要提前安装 CMake，这不在本文的介绍范围之内）就可以生成相应的工程了。 通过 CMake 命令行生成 Visual Studio 工程的命令如下： 1cmake.exe -G &quot;Visual Studio 15 2017&quot; -S .\\hello_cmake -B .\\hello_cmake\\build 2.3 源码外构建我们通常会将构建目录指定到一个单独的子目录内，这个目录名称的通常是 build。如果不这样做，CMake 生成的工程文件和临时缓存文件会污染源码目录。这种方式有个学名叫“源码外构建” (out-of-source build)。 使用源码外构建时，我们通常还会将 build 目录添加到 .gitignore 文件中。 2.4 工作流程编写 CMake 脚本的基本流程如下： 在脚本第一行使用 cmake_minimum_required 指定运行当前脚本所需的 CMake 最低版本。 使用 project 指定项目名称。 使用 add_executable 或 add_library 创建目标。 为目标设置包含目录、链接库等属性（可选）。 安装（可选）。 编写完 CMake 脚本以后，就可以使用 CMake GUI 或命令行来生成对应的工程文件了。以 Visual Studio 为例，对于有 my_lib 库 和 app 应用程序的项目，CMake 会生成如下图所示的 5 个项目： 下面介绍 CMake 自动生成的一些项目的作用： 编译 ALL_BUILD 项目会自动编译除 INSTALL 项目外的所有项目。 编译 INSTALL 项目会执行 CMake 脚本中指定的安装操作。 编译 ZERO_CHECK 项目会再次执行 CMake 脚本，重新生成项目。因此若 CMake 脚本有更新，既可以使用 CMake 工具来重新生成项目，也可以是重新编译 ZERO_CHECK 项目。 2.5 注释在 CMake 中使用 # 来声明单行注释，这是我们使用最多的注释方法。虽然也支持使用 #[[ ]] 来声明多行注释（也称块注释），但是使用的比较少，例如: 1234#[[ 这是多行注释也称块注释 你明白了吗？]] 2.6 CMake最低版本cmake_minimum_required 是我们接触到第一个 CMake 指令，该指令用于指定编译该脚本所需的最低 CMake 版本。 你可以在 CMakeList.txt 文件的第一行都使用该指令来指定运行当前脚本需要的最低 CMake 版本，但我们通常只需要在主 CMakeList.txt （何为主 CMakeList.txt？见下面的“项目名称”小节） 中的第一行使用该指令即可。 1cmake_minimum_required(VERSION &lt;min&gt;[...&lt;policy_max&gt;] [FATAL_ERROR]) 如果运行 CMake 的版本低于要求的版本，则将停止处理该脚本并返回错误。 我们始终应该选择一个比编译器晚发布的 CMake 版本，因为只有这样，CMake 才能支持新的编译器选项。但最低版本不应低于 3.0，实际项目中通常最低版本不会低于 3.16（该版本于2020年09月15日发布），本教程也是以此为标准进行讲解的。 2.7 项目名称使用 project 指定项目名称。 项目名称区别于目标（Target）名称，以 Visual Studio 为例，project 指定的名称对应“解决方案名称”，而 add_executable 或 add_library 等指定的名称才对应具体项目名和生成的“目标文件名”。 设置项目名称后，CMake 会自动定义一些变量（变量的具体用法会在稍后的“3.1 变量”小节进行介绍）。为了方便介绍各个变量的含义，假设我们是通过如下命令来运行 CMake 的: 1cmake.exe -G &quot;Visual Studio 15 2017&quot; -S D:\\hello_cmake -B D:\\hello_cmake\\build 下面列举了一些 CMake 自动定义的变量： PROJECT_NAME项目名称，如 hello_cmake CMAKE_PROJECT_NAME如果 CMakeLists.txt 位于项目的顶级目录，还会定义 CMAKE_PROJECT_NAME 变量，值与 PROJECT_NAME 一致。 PROJECT_SOURCE_DIR项目的根目录（绝对路径），即 -S 参数指定的目录，如 D:\\hello_cmake &lt;PROJECT-NAME&gt;_SOURCE_DIR值与 PROJECT_SOURCE_DIR 相同，只是变量名不同，如 hello_cmake_SOURCE_DIR PROJECT_BINARY_DIR项目的构建目录（绝对路径），即 -B 参数指定的目录，如 D:\\hello_cmake\\build &lt;PROJECT-NAME&gt;_BINARY_DIR值与 PROJECT_BINARY_DIR 相同，只是变量名不同，如 hello_cmake_BINARY_DIR 主CMakeLists.txt主 CMakeLists.txt 即项目根目录下的 CMakeLists.txt 文件。可以通过检查 CMAKE_PROJECT_NAME 与 PROJECT_NAME 变量是否相同来判断当前的 CMakeLists.txt 文件是否为主 CMakeLists.txt。 123if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)endif() 2.8 目标类型既然现代 CMake 是围绕目标（Target）工作的，Target 如此重要，那我们首先就需要创建一个 Target。 在 C&#x2F;C++ 开发中，常见的 Target 类型有：可执行文件、静态库、动态库，CMake 还额外提供了一个 MODULE 类型。 下面列举了不同类型的目标的创建方式。 可执行文件使用 add_executable 指令可以创建可执行文件类型的目标。 1add_executable(my_exe main.cpp) 动态库和静态库通过为 add_library 指令指定不同的参数，可以创建动态库和静态库。 1add_library(&lt;name&gt; [&lt;type&gt;] [EXCLUDE_FROM_ALL] &lt;sources&gt;...) 12345# 动态库add_library(my_lib SHARED main.cpp)# 静态库add_library(my_lib STATIC main.cpp) 我们也可以在 add_library 中不指定类型参数，改为通过设置 BUILD_SHARED_LIBS 变量来切换静态库和动态库。下面示例在脚本中设置了 BUILD_SHARED_LIBS 变量值为 ON （ON &#x2F; OFF 对应 CMake 中的开&#x2F;关）： 1234567cmake_minimum_required(VERSION 3.16)project (hello_cmake)set(BUILD_SHARED_LIBS ON)add_library(hello_cmake main.cpp) 也可以通过命令行参数进行指定 BUILD_SHARED_LIBS 变量： 1cmake.exe -G &quot;Visual Studio 15 2017&quot; -DBUILD_SHARED_LIBS=ON -S .\\hello_cmake -B .\\hello_cmake\\build 亦可以在 GUI 界面上设置 BUILD_SHARED_LIBS 变量，如： 三、基础语法3.1 变量3.1.1 变量的定义在 CMake 中使用 set 和 unset 命令来定义和取消定义变量。 CMake 的变量没有类型一说，因为其变量值始终是字符串类型。 基于上述原因，在 CMake 中不能直接使用 +、-、*、\\ 等操作符对变量进行数学运算，需要使用 math 指令，也不能直接使用 &gt;、&lt;、== 等操作符对变量进行逻辑运算，需要使用 LESS、EQUAL 进行判断，详见下面的“条件判断”章节。 CMake 的变量名是大小写敏感的，而且其变量名不像其他语言那样有各种限制，它可以包含任何字符，如空格、问号等，但如果变量名中包含#（该符号用于行注释），则需要使用 \\# 进行转义。 下面的语句都是合法的： 12345678910set(abc 123)set(ABC &quot;123&quot;)set(&quot;ab c&quot; &quot;456&quot;)set(&quot;ab?c&quot; &quot;789&quot;)set(&quot;/usr/bin/bash&quot; &quot;987&quot;)set(&quot;C:\\\\Program Files\\\\&quot; &quot;654&quot;)set(&quot; &quot; &quot;321&quot;)set(\\# &quot;321&quot;)unset(a) 虽然 CMake 允许变量名为任意字符串，但我们仍然建议在变量名称中仅包含字母、数字、- 和 _ ，而且字母为大写字母，如： 123# 建议的命名方式set(QT_VERSION &quot;5.15.2&quot;)set(LIB_NAME &quot;my_lib&quot;) CMake 还会保留一些标识符，我们在定义变量时尽量不要使用这些名称（你执意要用，CMake 也不会报错）： 以 CMAKE_ 开头的。 以 _CMAKE_ 开头的。 以 _&lt;cmake command&gt; 开头的，如 _file，完整的 command 列表见：cmake-commands。 在定义完变量以后，就可以通过 $&#123;variable&#125; 的形式进行引用了，如： 123set(QT_VERSION &quot;5.15.2&quot;)message(STATUS &quot;QT_VERSION is $&#123;QT_VERSION&#125;&quot;) 在 CMake 中，还可以通过引用变量的方式来定义新的变量： 123456789set(a &quot;xyz&quot;)set(b &quot;$&#123;a&#125;_321&quot;)set($&#123;a&#125;_1 &quot;456&quot;)set(variable_$&#123;a&#125; &quot;$&#123;a&#125; + $&#123;b&#125; + 15&quot;)message(&quot;b: &#x27;$&#123;b&#125;&#x27;&quot;) # b: &#x27;xyz_321&#x27;message(&quot;xyz_1: &#x27;$&#123;xyz_1&#125;&#x27;&quot;) # xyz_1: &#x27;456&#x27;message(&quot;variable_xyz: &#x27;$&#123;variable_xyz&#125;&#x27;&quot;) # variable_xyz: &#x27;xyz + xyz_321 + 15&#x27; 环境变量的引用方式有所不同，在下面的环境变量章节会详细介绍，而且在 if 条件中可以省略 $&#123;&#125;，直接使用变量名，如 if(QT_VERSION)。 CMake 还允许使用未定义的变量，未定义的变量的值为空字符串。 CMake 也允许重复定义变量，变量的值采用最后定义的值。 3.1.2 调试输出message为了方便调试脚本，我们可以使用 messsage 指令来输出变量和调试信息。 1message([&lt;mode&gt;] &quot;message text&quot; ...) &lt;mode&gt; 关键字是可选的，它用于指定消息的类型，消息类型会影响 CMake 对该消息的处理方式。 常用的消息类型有： FATAL_ERROR致命错误（红色），只有该类型会导致脚本终止执行。 WARNING警告（红色），脚本继续执行。 NOTICE（默认）需要特别关注的消息（红色），脚本继续执行。 STATUS普通输出，正常颜色，脚本也会继续执行。 12message(&quot;Current version is 1.0.0.1&quot;)message(STATUS &quot;BUILD_SHARED_LIBS value is $&#123;BUILD_SHARED_LIBS&#125;&quot;) cmake_print_variables如果只是单纯地想打印变量的值，使用 messsage 显得有些繁琐，我们可以使用 cmake_print_variables 函数来打印变量的值，该函数以 variable=value 格式输出每个变量的值，方便进行观察。 由于该函数由 CMake 的 CMakePrintHelpers 模块提供，因此在使用之前，需要先 include(CMakePrintHelpers)： 123456include(CMakePrintHelpers)set(MY_NAME &quot;jack&quot;)set(MY_ADDRESS &quot;Hubei&quot;)cmake_print_variables(MY_NAME MY_ADDRESS) # MY_NAME=&quot;jack&quot; ; MY_ADDRESS=&quot;Hubei&quot; 3.1.3 列表列表就是简单地包含一系列值，使用空格分割每个值： 1set(MY_LIST a b &quot;c&quot; 1 2 $&#123;MY_NAME&#125; 3) 也可以使用 ; 来代替空格： 123set(MY_LIST &quot;a;b;c;1;2;$&#123;MY_NAME&#125;;3&quot;)set(MY_LIST a;b;c;1;2;$&#123;MY_NAME&#125;;3) list 命令list 命令提供了众多针对列表的操作，如获取元素个数、查找、添加、删除、排序等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 获取元素个数list(LENGTH &lt;list&gt; &lt;out-var&gt;)# 获取指定下标（可以指定多个下标）的元素list(GET &lt;list&gt; &lt;element index&gt; [&lt;index&gt; ...] &lt;out-var&gt;)# 拼接2个列表list(JOIN &lt;list&gt; &lt;glue&gt; &lt;out-var&gt;)# 获取指定位置指定长度的一段列表list(SUBLIST &lt;list&gt; &lt;begin&gt; &lt;length&gt; &lt;out-var&gt;)# 查找，&lt;out-var&gt;中存储查找到的元素下标，如果没找到则为-1list(FIND &lt;list&gt; &lt;value&gt; &lt;out-var&gt;)# 在列表尾部添加若干元素list(APPEND &lt;list&gt; [&lt;element&gt;...])# 按条件过滤列表list(FILTER &lt;list&gt; &lt;INCLUDE|EXCLUDE&gt; REGEX &lt;regular_expression&gt;)# 在指定位置插入若干元素list(INSERT &lt;list&gt; &lt;index&gt; [&lt;element&gt;...])# 弹出尾部的若干元素（如果没有指定&lt;out-var&gt;变量，则只弹出一个）list(POP_BACK &lt;list&gt; [&lt;out-var&gt;...])# 弹出头部的若干元素（如果没有指定&lt;out-var&gt;变量，则只弹出一个）list(POP_FRONT &lt;list&gt; [&lt;out-var&gt;...])# 将若干元素插入到列表的头部，如果&lt;list&gt;没有被定义，则相当于创建了一个新的列表list(PREPEND &lt;list&gt; [&lt;element&gt;...])# 移除列表中的若干元素list(REMOVE_ITEM &lt;list&gt; &lt;value&gt;...)# 移除列表中指定位置（可以指定多个）的元素list(REMOVE_AT &lt;list&gt; &lt;index&gt;...)# 删除列表中的重复项目。保留项目的相对顺序，但如果遇到重复项，则仅保留第一个实例。list(REMOVE_DUPLICATES &lt;list&gt;)# 按照&lt;ACTION&gt;对列表元素进行转换list(TRANSFORM &lt;list&gt; &lt;ACTION&gt; [&lt;SELECTOR&gt;] [OUTPUT_VARIABLE &lt;output variable&gt;])# 列表反转list(REVERSE &lt;list&gt;)# 列表排序list(SORT &lt;list&gt; [COMPARE &lt;compare&gt;] [CASE &lt;case&gt;] [ORDER &lt;order&gt;]) 下面仅简单地演示 2 个列表功能的用法： 1234567set(NAME_LIST jack jim jeff tom)list(LENGTH NAME_LIST NAME_COUNT)message(STATUS &quot;name count: $&#123;NAME_COUNT&#125;&quot;) # name count: 4list(FIND NAME_LIST jim JIM_INDEX)message(STATUS &quot;jim at: $&#123;JIM_INDEX&#125;&quot;) # jim at: 1 遍历列表可以使用 foreach 来遍历列表，下面示例演示了如何使用 foreach 遍历输出 MY_LIST 列表中每个元素，其中 _ITEM 变量的作用域仅限 foreach 代码块。 12345set(MY_LIST hello world)foreach(_ITEM $&#123;MY_LIST&#125;) message(STATUS &quot;$&#123;_ITEM&#125;&quot;)endforeach() 我们还可以使用 while 来遍历列表，详见下面的“循环”章节。 3.1.4 双引号的作用学习到这里，也许你会感到困扰，在定义变量时，为什么有时候使用双引号把值包围起来，有时候又不使用呢？ 我们已经学习完了列表的相关知识，现在就可以解释加不加引号的区别了。 在定义变量时，若变量值中包含空格，此时不使用双引号包裹，则等同于定义列表；使用双引号包裹，则等同于定义字符串变量。 12345# 定义的MY_VAR为列表，包含2个元素：hello、worldset(MY_VAR hello world)# 定义的MY_VAR为字符串set(MY_VAR &quot;hello world&quot;) 对于列表类型的变量，在使用时是否使用双引号包裹也会有区别：有双引号包裹时，会将数组元素以分号作为分隔符进行拼接，否则会直接拼接各元素。 1234set(MY_LIST hello world)message(STATUS &quot;$&#123;MY_LIST&#125;&quot;) # hello;worldmessage(STATUS $&#123;MY_LIST&#125;) # helloworld 3.1.5 三种不同的变量CMake 中的变量分为普通变量、缓存变量和环境变量，三者都可以通过 set 指令进行定义。 普通变量下面使用 set 定义的变量就是普通变量。 1set(MY_NAME &quot;jack&quot;) 也可以在 CMake 命令行中通过 -D 参数定义普通变量，如下面示例定义了 BUILD_SHARED_LIBS 和 TEST 变量： 1cmake.exe -G &quot;Visual Studio 15 2017&quot; -DBUILD_SHARED_LIBS=ON -DTEST=123 -S .\\hello_cmake -B .\\hello_cmake\\build 缓存变量缓存变量也是通过 set 指令定义的，但需要添加额外的参数： 1set(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE]) 下面示例定义了一个名为 LIB_VERSION 的缓存变量： 123456789cmake_minimum_required(VERSION 3.16)set(LIB_VERSION &quot;1.0.0.1&quot; CACHE STRING &quot;the version of library&quot;)project (hello_cmake)add_library(hello_cmake main.cpp)message(STATUS &quot;LIB_VERSION = $&#123;LIB_VERSION&#125;&quot;) 使用 CMake GUI 程序执行该脚本，可以看到界面上多出了一个名为 LIB_VERSION 的文本输入框，而且输入框有默认值 1.0.0.1。 将输入框中的文本修改为 1.0.0.2，再次执行该脚本，可以发现调试输出的内容是 LIB_VERSION = 1.0.0.2，而且无论我们执行多少次脚本，始终输出的都是该内容。 这是因为 CMake 会将缓存变量及其值存储到 “构建目录\\CMakeCache.txt” 文件中，下次运行脚本时，会优先从该文件中加载变量，该文件内容格式大致如下： 12345678# build\\CMakeCache.txt 文件......//the version of libraryLIB_VERSION:STRING=1.0.0.2...... 其中，&lt;type&gt; 用于指定变量的输入类型。请注意，&lt;type&gt; 指定的不是变量的类型，因为 CMake 的所有变量都是字符串类型。&lt;type&gt; 指定的是输入类型，仅用于帮助 CMake GUI 程序显示不同的用户输入控件，如文本输入框、复选框、文件选择对话框等。 &lt;type&gt; 的取值必须是下面列表中的一个： BOOL开关ON或OFF，在 CMake GUI 上提供一个复选框。 PATH文件夹的路径，在 CMake GUI 上提供一个文本输入框和一个按钮来打开文件夹选择对话框。 FILEPATH文件的路径，在 CMake GUI 上提供一个文本输入框和一个按钮来打开文件选择对话框。 STRING文本字符串，在 CMake GUI 上提供一个文本输入框。 STRINGS文本字符串，但在 CMake GUI 上会提供一个下拉列表选择框。 INTERNAL虽然也是文本字符串，但不会显示在 CMake GUI 上，因此用户无法在界面上修改该变量的值。 如果我们不希望某些缓存变量直接展示 CMake GUI 上，可以使用 mark_as_advanced 指令将缓存变量设置为高级状态，这样除非用户打开了 “Show Advanced” 选项，否则高级变量不会显示在 CMake GUI 中。在脚本模式下，高级&#x2F;非高级状态是无效的。 12set(DEBUG_LIBNAME_SUFFIX &quot;-d&quot; CACHE STRING &quot;Optional suffix to append to the library name for a debug build&quot;)mark_as_advanced(DEBUG_LIBNAME_SUFFIX) option虽然 option 也可用于定义缓存变量，但其只能定义“开&#x2F;关”类型的变量。 1option(ENABLE_TEST &quot;enable test or not&quot; ON) 如果未指定初始值，默认为 OFF。 环境变量环境变量的定义方式如下： 1set(ENV&#123;&lt;variable&gt;&#125; [&lt;value&gt;]) 环境变量在引用时，需要在前面添加 ENV 标识，如 $ENV&#123;&lt;variable&gt;&#125; 示例： 123set(ENV&#123;USER_NAME&#125; &quot;jack&quot;)message(STATUS &quot;User name is $ENV&#123;USER_NAME&#125;&quot;) CMake 程序在启动时，会加载系统的环境变量，同时还会设置一些内置的环境变量，内置的环境变量见 cmake-env-variables。 CMake 虽然会加载系统的环境变量，我们也可以修改该环境变量，但该修改操作不会影响到系统的环境变量。 定义或加载的环境变量只会作用于当前的 CMake 进程，而且对当前进程所运行的所有脚本都可见，但不会影响到其他 CMake 进程和系统中的其他进程。 3.1.6 变量作用域在上面介绍三种不同的变量时，我一直在竭力避免讨论一个话题，那就是变量的作用域。事实上，上面三种变量还有个不同之处就是作用域的不同。 缓存变量和环境变量都是全局的，它们可以跨文件、目录、函数进行读写，因此作用域主要针对普通变量而言。 CMake 中作用域分为“目录级别作用域”和“函数作用域”（也可以使用 block() 来显式的创建一个作用域，但这种使用方式非常少）。 函数有自己的作用域，在函数中定义的变量只能在函数体中使用，函数体外无法访问。除非在定义变量时添加 PARENT_SCOPE 来将变量作用域设置为上一级目录。 include使用 include 指令可以加载和执行其他 CMake 脚本文件（名称通常为 *.cmake），include 会在 CMAKE_MODULE_PATH 变量指定的目录列表中搜索指定文件。 使用 include 指令加载cmake文件时，无需指定 .cmake 后缀，指定文件名即可，假设在 A（CMakeLists.txt或*.cmake）中调用 include(B) 加载 B.cmake ，则 A 和 B 之间可以相互读写彼此的变量（包含普通变量、缓存变量和环境变量）。 当然，在 B.cmake 文件中也可以使用 include 指令加载执行其他的 cmake 文件。 add_subdirectory使用 add_subdirectory 指令可以添加一个子目录到项目构建中，但是被添加的子目录中必须包含 CMakeLists.txt 文件。 假设在 A (CMakeLists.txt文件) 中调用 add_subdirectory(lib) 添加了 lib 子目录，则 lib 目录中的 CMakeLists.txt 可以读写 A 中的普通变量，但 A 不能读写 lib 目录 CMakeLists.txt 的普通变量。但可以在定义变量时添加 PARENT_SCOPE 选项来突破该限制，将变量作用域设置为上一级作用域，即父目录的作用域，如： 12# lib\\CMakeLists.txt 文件set(LIB_NAME &quot;MyTestLib&quot; PARENT_SCOPE) 1234add_subdirectory(lib)# 可以访问 LIB_NAME 变量message(STATUS &quot;$&#123;LIB_NAME&#125;&quot;) 3.2 数学运算在前面章节已经提到了 CMake 中的值都是以字符串类型存储的，不能直接使用数学运算符符进行运算，需要使用 math 指令进行数学运算。 math 的语法如下： 1math(EXPR &lt;variable&gt; &quot;&lt;expression&gt;&quot; [OUTPUT_FORMAT &lt;format&gt;]) 其中，&lt;variable&gt;变量如果没有定义，math 会自动定义该变量； OUTPUT_FORMAT 选项用于指定计算结果的进制（十六进制或十进制）： HEXADECIMAL 十六进制 DECIMAL 十进制（默认） math 支持如下运算符： 1+ - * / % | &amp; ^ ~ &lt;&lt; &gt;&gt; (...) 示例： 1234567891011121314# value 等于 &quot;300&quot;math(EXPR value &quot;100 * 3&quot;)# value 等于 &quot;1000&quot;math(EXPR value &quot;100 * 0xA&quot;)# value 等于 &quot;0x12c&quot;math(EXPR value &quot;100 * 3&quot; OUTPUT_FORMAT HEXADECIMAL)set(value 3)math(EXPR value &quot;100 * $&#123;value&#125;&quot;) # value 等于 &quot;300&quot;# value 等于 &quot;306&quot;math(EXPR value &quot;(100 + 2) * 3&quot;) 3.3 条件判断在 CMake 中，使用 if 进行条件判断，语法如下： 1234567if(&lt;condition&gt;) &lt;commands&gt;elseif(&lt;condition&gt;) # 可选的，可以有多个 &lt;commands&gt;else() # 可选的 &lt;commands&gt;endif() 与众多语言中的 if 一样，当括号中的条件为真时，才执行指定的 commands。 示例： 1234567set(a 9)if(a LESS 10) message(STATUS &quot;a &lt; 10&quot;)else() message(STATUS &quot;a &gt;= 10&quot;)endif() else() 和 endif() 括号中的内容可以为空，但如果需要指定，则就必须与 if 中的条件完全一致，如下面示例所示： 1234567set(a 9)if(a LESS 10) message(STATUS &quot;a &lt; 10&quot;)else(a LESS 10) message(STATUS &quot;a &gt;= 10&quot;)endif(a LESS 10) 我们通常不在 else() 和 endif() 中指定条件，因为这样太繁琐了。 3.3.1 真值与假值何为真，何为假，人生真真假假，难以分辨，程序的真假却清清楚楚。 下列常量始终为真（不区分大小写）： 1 和其他非零数字（包含浮点型），如 1、2、3.14 ON YES TRUE Y 下列常量始终为假（不区分大小写）： 0 OFF NO FALSE N IGNORE NOTFOUND 空字符串 被引号包裹的字符串（除始终为真的字符串外，如 TRUE、Y 等） 3.3.2 逻辑运算符在 CMake 中，逻辑运算符的与、或、非分别使用 AND、OR、NOT 表示。 1234567if(NOT &lt;condition&gt;)if(&lt;cond1&gt; AND &lt;cond2&gt;)if(&lt;cond1&gt; OR &lt;cond2&gt;)if((condition) AND (condition OR (condition))) 3.3.3 关系运算符由于 CMake 变量都是以字符串类型存储的，因此即便是数字也不能直接使用 &gt;、&lt;、== 这样的运算符来直接比较。 针对数值类型，CMake 支持的关系运算符如下： LESS 小于 LESS_EQUAL 小于等于 GREATER 大于 GREATER_EQUAL 大于等于 EQUAL 等于 CMake 还支持字符串比较，即从左到右依次比较字符串中的每个字符，出现不相同时立即返回，类似于 C 语言中的 strcmp 函数。 STRLESS STRLESS_EQUAL STRGREATER STRGREATER_EQUAL STREQUAL 3.3.4 存在性校验CMake 提供了一些判断变量是否定义、目标是否创建、元素是否存在于列表中、文件&#x2F;目录是否存在等方法。 1234567891011121314# 给定名称是否是可以调用的指令if(COMMAND &lt;command-name&gt;)# 给定名称是否是已创建的目标，即通过add_executable()、add_library() 或 add_custom_target() 命令创建if(TARGET &lt;target-name&gt;)# 给定名称的普通变量、缓存变量、环境变量是否已定义if(DEFINED &lt;name&gt;|CACHE&#123;&lt;name&gt;&#125;|ENV&#123;&lt;name&gt;&#125;)# 给定的元素是否包含在列表中if(&lt;variable|string&gt; IN_LIST &lt;variable&gt;)# 给定的文件或目录是否存在if(EXISTS &lt;path-to-file-or-directory&gt;) 3.4 循环CMake 有两种循环方式： foreach while 二者都可以使用 break() 提前退出循环和 continue() 跳过本次循环。 3.4.1 foreach下面是 foreach 的基本语法形式，这种形式在之前的“遍历列表”章节已经使用到了： 123foreach(&lt;loop_var&gt; &lt;items&gt;) &lt;commands&gt;endforeach() 示例： 12345set(MY_LIST 1 2 3 4 5 6 7)foreach(_ITEM $&#123;MY_LIST&#125;) message(STATUS &quot;$&#123;_ITEM&#125;&quot;)endforeach() foreach 还支持下面两种语法形式，这两种形式都不需要指定列表 &lt;items&gt; 参数，作用类似于 C 语言中的 for 语句： 12345# 循环 [0 ~ &lt;stop&gt;]，步长为 1foreach(&lt;loop_var&gt; RANGE &lt;stop&gt;)# 循环 [&lt;start&gt; ~ &lt;stop&gt;]，步长为 &lt;step&gt;（可选）foreach(&lt;loop_var&gt; RANGE &lt;start&gt; &lt;stop&gt; [&lt;step&gt;]) 示例： 1234567891011foreach(_I RANGE 3) message(STATUS &quot;$&#123;_I&#125;&quot;) # 依次输出 0 1 2 3endforeach()foreach(_I RANGE 2 5) message(STATUS &quot;$&#123;_I&#125;&quot;) # 依次输出 2 3 4 5endforeach()foreach(_I RANGE 2 5 2) message(STATUS &quot;$&#123;_I&#125;&quot;) # 依次输出 2 4endforeach() 3.4.2 whilewhile 的语法形式如下，其中 &lt;condition&gt; 为真时（参考 if 条件判断章节），执行代码块中的 commands 命令。 123while(&lt;condition&gt;) &lt;commands&gt;endwhile() 下面示例演示了如何使用 while 来遍历列表： 123456789set(MY_LIST 1 2 3)list(LENGTH MY_LIST LIST_COUNT)set(INDEX 0)while(INDEX LESS LIST_COUNT) list(GET MY_LIST $&#123;INDEX&#125; VALUE) # 获取 $&#123;INDEX&#125; 位置的元素 message(STATUS &quot;element at $&#123;INDEX&#125; = $&#123;VALUE&#125;&quot;) math(EXPR INDEX &quot;$&#123;INDEX&#125; + 1&quot;) # 自增 INDEXendwhile() 上面示例依次输出如下内容： 123element at 0 = 1element at 1 = 2element at 2 = 3 3.5 函数和宏3.5.1 函数使用 function 定义函数： 123function(&lt;name&gt; [&lt;arg1&gt; ...]) &lt;commands&gt;endfunction() 函数有自己的作用域，而宏没有自己的作用域，在函数体里面定义的普通变量默认只能在函数体中被访问，除非在定义时指定了 PARENT_SCOPE 选项，或者改为定义缓存变量、环境变量。 函数在被调用时，函数名是不区分大小写的，如我们定义了名为 foo 的函数，就可以使用 foo()、Foo()、FOO() 等形式来调用，但我们还是建议保持与函数定义时的名称一致。 参数关于函数的参数，我们可以在定义函数时就指定各个参数的名称，如： 123456function(my_func NAME AGE) message(STATUS &quot;name: $&#123;NAME&#125;&quot;) # name: jack message(STATUS &quot;age: $&#123;AGE&#125;&quot;) # age: 18endfunction()my_func(&quot;jack&quot; 18) 在调用函数时，调用参数（实参）的个数可以超过定义的参数个数（形参），但不能少于定义的参数个数，否则会报错。超出的参数，可以通过下面的形式获取： 使用 ARGV0, ARGV1, ARGV2, ... 变量获取函数的每个参数。 使用 ARGV 变量获取函数的参数列表，通过 ARGN 变量获取参数的个数。 返回值使用 return() 可以从函数体中提前返回，但不能直接使用 return() 带出返回值，需要借用 set(&lt;variable&gt; &lt;value&gt; PARENT_SCOPE) 方式，来间接的带出返回值。 下面示例演示了函数的定义、调用、参数的获取以及返回值的用法。 1234567891011function(my_func NAME AGE) message(STATUS &quot;name: $&#123;NAME&#125;&quot;) # name: jack message(STATUS &quot;parameter count: $&#123;ARGC&#125;&quot;) # parameter count: 3 message(STATUS &quot;parameter list: $&#123;ARGV&#125;&quot;) # parameter list: jack;18;Hubei message(STATUS &quot;parameter 0: $&#123;ARGV0&#125;&quot;) # parameter 0: jack message(STATUS &quot;parameter 2: $&#123;ARGV1&#125;&quot;) # parameter 2: Hubei set(FUNC_RET &quot;OK&quot; PARENT_SCOPE)endfunction()my_func(&quot;jack&quot; 18 &quot;Hubei&quot;)message(STATUS &quot;return value: $&#123;FUNC_RET&#125;&quot;) # return value: OK 但在实际项目中，除需要传入不定个数的参数情况外，我们通常在定义函数时，就约定好了参数名称和返回参数的名称，如下面示例： 12345678function(my_func NAME AGE OUT_RET) # 使用 $&#123;NAME&#125; $&#123;AGE&#125; 访问参数 message(STATUS &quot;name: $&#123;NAME&#125;&quot;) # name: jack set(OUT_RET &quot;OK&quot; PARENT_SCOPE)endfunction()my_func(&quot;jack&quot; 18 OUT_RET)message(STATUS &quot;return value: $&#123;OUT_RET&#125;&quot;) # return value: OK 3.5.2 宏使用 macro 定义宏： 123macro(&lt;name&gt; [&lt;arg1&gt; ...]) &lt;commands&gt;endmacro() CMake 中的宏和 C 语言中的宏一样，是在调用处进行语句替换后再执行，因此在宏中使用 return() 时要格外小心，可能会终止整个脚本的执行。 建议优先使用函数。 3.6 字符串操作字符串操作由 string 指令提供，详见官方文档。 3.7 内置变量本节列举了在项目中经常用到的 CMake 内置变量。 CMAKE_SOURCE_DIR始终存储的是项目的根目录。 CMAKE_BINARY_DIR始终存储的是项目的根构建目录。 PROJECT_SOURCE_DIR与 CMAKE_SOURCE_DIR 一样，也始终存储的是项目的根目录，但该变量需要使用 project 创建项目以后，才会被定义。 PROJECT_BINARY_DIR与 CMAKE_BINARY_DIR 一样，也始终存储的是项目的构建目录，但该变量需要使用 project 创建项目以后，才会被定义。 CMAKE_CURRENT_SOURCE_DIR存储的是当前正在执行脚本所在的目录。 CMAKE_CURRENT_BINARY_DIR一个工程中可能包括多个项目，每个项目的构建目录不同，该变量存储的是当前项目的构建目录。 CMAKE_CURRENT_LIST_FILE当前脚本代码所在文件的完整路径。 CMAKE_CURRENT_LIST_LINE当前脚本代码所在行数。 CMAKE_MODULE_PATH通过设置改变变量，可以控制 CMake 查找 .cmake 文件的路径，在使用 include 时就可以直接使用文件名了。如： 123set(CMAKE_MODULE_PATH &quot;$&#123;CMAKE_SOURCE_DIR&#125;/cmake&quot;)include(utils) 需要注意的是，当在 include 中仅指定了文件名时，不能再添加 .cmake 扩展名，否则会导致查找不到相应文件。 WIN32在 Windows 系统上，定义该变量，值为 1。 APPLE在 Apple 系统上，定义该变量，值为 1。 UNIX在类 UNIX 系统上，定义该变量，值为 1。 CMAKE_SYSTEM_NAME当前构建所选定目标系统，但该变量需要使用 project 创建项目以后，才会被定义。 该变量常见的值有：Android、iOS、Linux、FreeBSD、MSYS、Windows、Darwin，完整的列表见：CMAKE_SYSTEM_NAME。 123456789101112131415if (CMAKE_SYSTEM_NAME STREQUAL &quot;Linux&quot;) message(STATUS &quot;current platform: Linux &quot;)elseif (CMAKE_SYSTEM_NAME STREQUAL &quot;Windows&quot;) message(STATUS &quot;current platform: Windows&quot;)elseif (CMAKE_SYSTEM_NAME STREQUAL &quot;FreeBSD&quot;) message(STATUS &quot;current platform: FreeBSD&quot;)elseif (CMAKE_SYSTEM_NAME STREQUAL &quot;Darwin&quot;) message(STATUS &quot;current platform: macOS&quot;)elseif (CMAKE_SYSTEM_NAME STREQUAL &quot;Android&quot;) message(STATUS &quot;current platform: Android&quot;)elseif (CMAKE_SYSTEM_NAME STREQUAL &quot;iOS&quot;) message(STATUS &quot;current platform: iOS&quot;)else () message(STATUS &quot;other platform: $&#123;CMAKE_SYSTEM_NAME&#125;&quot;)endif() MSVC当编译器是 Microsoft Visual C++ 的某个版本或模拟 Visual C++ cl 命令行语法的其他编译器时设置为 true。 MSVC_VERSION正在使用的 Microsoft Visual C&#x2F;C++ 版本（如果有）。如果正在使用模拟 Visual C++ 的编译器，则此变量将设置为 _MSC_VER 预处理器定义所给定的模拟工具集版本。 四、目标的属性4.1 属性调试在介绍如何设置目标的属性之前，我们先学习一下如何调试输出目标属性，方便在开发中检查属性设置是否出错。 使用 CMakePrintHelpers 模块提供 cmake_print_properties 函数可以打印输出目标的属性，该函数的原型如下： 123456cmake_print_properties(&lt;TARGETS [&lt;target1&gt; ...] | SOURCES [&lt;source1&gt; ...] | DIRECTORIES [&lt;dir1&gt; ...] | TESTS [&lt;test1&gt; ...] | CACHE_ENTRIES [&lt;entry1&gt; ...] &gt; PROPERTIES [&lt;prop1&gt; ...] ) 以打印输出目标的“包含目录”属性为例： 123456add_library(hello_cmake main.cpp)target_include_directories(hello_cmake PRIVATE &quot;include&quot;)include(CMakePrintHelpers)cmake_print_properties(TARGETS hello_cmake PROPERTIES INCLUDE_DIRECTORIES) 输出： 12Properties for TARGET hello_cmake: hello_cmake.INCLUDE_DIRECTORIES = &quot;D:/cmake-sample/hello_cmake/include&quot; 4.2 包含目录使用 target_include_directories 指定目标包含一个或多个目录。指定的目录路径可以是绝对路径也可以是相对路径，如果是相对路径，则该路径是相对于当前脚本文件的。 123target_include_directories(&lt;target&gt; [SYSTEM] [AFTER|BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) 这就相当于在 Visual Studio 中设置“附加包含目录”。 可以针对一个目标重复调用 target_include_directories，会按照调用顺序依次附加包含目录，也可以使用 BEFORE 选项，将本次设置的包含目录插入到最前面。 我们需要特别花精力理解 INTERFACE、PUBLIC、PRIVATE 三者的区别，这三者的区别，我们先按下不表，稍后介绍。 在使用 PUBLIC、PRIVATE 设置包含目录时，会自动设置 INCLUDE_DIRECTORIES 属性；在使用 INTERFACE 设置包含目录时，会自动设置 INTERFACE_INCLUDE_DIRECTORIES 属性。 示例： 1234567target_include_directories(hello_cmake PUBLIC &quot;include&quot; PRIVATE &quot;./extern/jsoncpp&quot;)target_include_directories(hello_cmake BEFORE PUBLIC &quot;include&quot; PRIVATE &quot;./extern/rpclib&quot;) 4.3 预编译宏使用 target_compile_definitions 设置目标的预编译宏。 123target_compile_definitions(&lt;target&gt; &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) 可以针对一个目标重复调用 target_compile_definitions，附加多个预编译宏。 使用 PUBLIC、PRIVATE 设置包含目录时，会自动设置 COMPILE_DEFINITIONS 属性；使用 INTERFACE 设置包含目录时，会自动设置 INTERFACE_COMPILE_DEFINITIONS 属性。 示例： 1234567# 定义2个预编译宏target_compile_definitions(hello_cmake PUBLIC USING_BOOST USING_THRIFT)# 再定义一个预编译宏target_compile_definitions(hello_cmake INTERFACE USING_ZLIB) 4.4 依赖库使用 target_link_libraries 指令设置目标的依赖库，该指令有很多原型，但常用的原型有： 123target_link_libraries(&lt;target&gt; [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...] [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...) item 可以是如下几种类型： lib 文件的绝对路径或相对路径，CMake 不会校验文件是否存在 其他的 CMake 目标。 表达式生成器（见“生成器表达式”章节）。 以 - 开头的链接标志，但从 CMake 3.13 版本开始，可以直接使用 target_link_options() 替代。 可以针对一个目标重复调用 target_link_libraries，附加多个依赖库。 &lt;PRIVATE|PUBLIC|INTERFACE&gt; 可以省略，如果省略，则默认为 PUBLIC。 使用 PUBLIC、PRIVATE 设置依赖库时，会自动设置 LINK_LIBRARIES 属性；使用 INTERFACE 设置依赖库时，会自动设置 INTERFACE_LINK_LIBRARIES 属性。 4.5 INTERFACE、PUBLIC 和 PRIVATEINTERFACE、PUBLIC 和 PRIVATE 用于指定属性的可见性传递方案。 目标类型 可见性传递 自身是否应用该属性 使用者是否应用该属性 可执行文件 INTERFACE 否 否（可执行文件不存在使用者） 可执行文件 PUBLIC 是 否（可执行文件不存在使用者） 可执行文件 PRIVATE 是 否（可执行文件不存在使用者） 库（动态或静态） INTERFACE 否 是 库（动态或静态） PUBLIC 是 是 库（动态或静态） PRIVATE 是 否 4.6 编译和链接选项通过 target_compile_options 指令设置编译选项。 123target_compile_options(&lt;target&gt; [BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) 通过 target_link_options 指令设置链接选项。 123target_link_options(&lt;target&gt; [BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) 这两个指令的用法与前面介绍的 target_include_directories 类似。 示例： 12345# 编译选项target_compile_options(my_lib PRIVATE /utf8)# 链接选项target_link_options(app PRIVATE /NOLOGO) 4.7 其他属性CMake 为目标还提供了其他属性，详见 target-properties ，总计约有 400 多个，涵盖了开发中会用到的绝大多数属性，例如其中以 VS_ 开头的属性是专门为 Visual Studio 所准备的。 针对这些属性，需要使用 set_target_properties 指令进行设置。 例如，使用 OUTPUT_NAME 和 DEBUG_OUTPUT_NAME 设置目标的输出文件名。 123set_target_properties(zoe PROPERTIES OUTPUT_NAME Zoe DEBUG_OUTPUT_NAME Zoe-d)","tags":["CMake"],"categories":["CMake"]},{"title":"开源库jerryscript使用备忘","path":"/post/3353203242.html","content":"以前嵌入脚本首选Lua，但有些年头没有用Lua了，语法也快忘记光了，这些年倒是对 JavaScript 语法愈发熟悉了，于是想看看有没有小巧的 JavaScript 引擎，可以嵌入到 C++程序中使用。嘿，还真有。花时间研究了下 JerryScript 库，也顺手给 JerryScript 提交了几个 PR 被采纳了，有幸成为顶级项目的 Contributor（就是玩儿 ^_^）。 JerryScript 是一个轻量级的 JavaScript 引擎，资源占用极少，它可以运行在资源受限制的设备上，如： 只有几 KB RAM 能运行引擎的设备（&lt;64 KB RAM） 只能为代码引擎提供有限 ROM 空间的设备（&lt;200 KB ROM） JerryScript 使用 C 语言开发，跨平台。 为什么没有选择 QuickJS？说起轻量级的 JavaScript 引擎，很多人都会想到 QuickJS。的确，我一开始也选择了 QuickJS，但一番研究之后，发现 QuickJS 在 Windows 环境下编译实在是不太友好，不仅需要安装 Mingw64，而且修改编译选项也不方便。可能是我能力的问题吧，我还未找到将 QuickJS 编译成 MT 运行库的静态库的方法。 一个库在编译方面做得都不够友好，何况 Windows 也不是冷门的系统，那就没必要委屈自己了，毕竟还有其他的选择。 反观 JerryScript，使用 CMake 进行构建，不需要进行任何修改，一路畅通。 快速上手JerryScript 的接口比较简洁， 而且官方已经提供了丰富的示例，示例地址如下： https://jerryscript.net/api-example/ 下面是一个简单的示例，演示了如何暴露 C++ 的函数给 JS 进行调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &quot;jerryscript.h&quot;// C++ 函数，用于暴露给 JSstatic jerry_value_t print_handler( const jerry_call_info_t* call_info_p, const jerry_value_t arguments[], const jerry_length_t argument_count) &#123; // 没有参数，只打印一个字符串 printf(&quot;Print handler was called &quot;); // 返回 undefined 给JS引擎 return jerry_undefined();&#125;int main(void) &#123; const jerry_char_t script[] = &quot;print ();&quot;; const jerry_length_t script_size = sizeof(script) - 1; // 初始化引擎 jerry_init(JERRY_INIT_EMPTY); // 添加 print 方法到 JavaScript 的全局对象上 // 在JS 中调用 print 方法时，会调用到 C++ print_handler 方法 &#123; jerry_value_t global_object = jerry_current_realm(); jerry_value_t property_name_print = jerry_string_sz(&quot;print&quot;); jerry_value_t property_value_func = jerry_function_external(print_handler); jerry_value_t set_result = jerry_object_set(global_object, property_name_print, property_value_func); // 检查是否有错误发生 if (jerry_value_is_exception(set_result)) &#123; printf(&quot;Failed to add the &#x27;print&#x27; property &quot;); &#125; jerry_value_free(set_result); jerry_value_free(property_value_func); jerry_value_free(property_name_print); jerry_value_free(global_object); &#125; jerry_value_t parsed_code = jerry_parse(script, script_size, NULL); if (!jerry_value_is_exception(parsed_code)) &#123; // 执行 JS 代码 jerry_value_t ret_value = jerry_run(parsed_code); // 释放返回值 jerry_value_free(ret_value); &#125; jerry_value_free(parsed_code); jerry_cleanup(); return 0;&#125;","tags":["开源库","jeffyscript"],"categories":["开源库"]},{"title":"禁用F12作为调试热键","path":"/post/4077884774.html","content":"在Windows系统中，F12永远为调试器所预留，不能被用来注册为快捷键，如我们通常使用F12打开浏览器的调试工具。即便当前未调试应用程序，如果内核模式调试器或实时调试器有驻留，F12也会被预留。 详见：https://msdn.microsoft.com/en-us/library/windows/desktop/ms646309.aspx 可以通过修改注册表来指定其他的按键作为调试器预留快捷键： 1[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug] UserDebuggerHotKey=dword:00000000 比如0x13 (Pause键)。","tags":["Visual Studio"],"categories":["编程基础"]},{"title":"折腾开发环境的一天","path":"/post/2133505170.html","content":"49420f43dcd4ffad5e1774efbcfcadee2bd7039b3241a2ee4fd438f9dcc74bffcb03be0a8e762c996d40e1cac9294e017a4b8e4c93e0474a33c860be2af036d6b41dfb03e04c3b63d0babc52787f6005bb27d44ce9321b20d2e4681608cedc232245320ce1cbfc16328fe36f3b98f22b4208e15d1b870be37373741bf4ec943ab781fa8f4adf3bb226440aa371c14ef2e9fd438e760d72281f3ce1b789ccae0d20a58c8967d6ce10813d5302534aaaa25b4052d4ea35cc3c302c7c203e1d75babaa48ee50227d02722b48076520c8c9e7c237a1f90e05ebd4f9ee16f4996a523a98ff0d7cdc2232dcc269599dd939258b78e114e59c634bec8e1ee687aed2631de401aefaeb931935be74c660be9ff57d37f62e6f0068fc6fe947ad344a442396321eebcdcc97939bb9b8cd88950c1292e8c4370a20f839d23161ed28f3964c49eb965a3260dd9157f117308d75780716151a2ef1af10b299065ff65a705eb541417eb92f9f51895c77b755cebb37e20ef3d74527752e84465ec3bbad4072ed6f24c685c30f49b831736aeb56b0bf0e809cbcca825eb1a2b089c356b156fdcb8768c60ea4d43b98a3ca21026fef2ab8ec25037af77e851e08747395387a2c2f5a202398ed5e61bce68bc63ec9fa62dddfd94393f4feca143f7830346fbbd7bed655a5d6633bc52fa89713efde23d0f491df76b5b674ba0d97cae76b253fd6dc4ac9872406ef294f2a1e8db48e76c7b51f6db23aaf564c5e1891577f3361c530ddf1a14f32d5d162cfb92393235b6d034f84c8e9a8c83a39345f6caeec3c611ee7cb44fd3a36969dc4d0fea09c72adea8c87103f2394c7d78b8b2ca8f03f306ba210db4b9971b8cdb45ccd2cb6cc81feb531f1f1fe144d7edf35802593fd01928bc23bd4f315cb94fb1c348eeda5b0cd3122917b05ee035e916dc31163697b02a490be92a8e39d4353a909c51ab5796629c0b72bb3941c6fe8538051c3ad0b188c5b7b6a0ee9494bbf7575f1fdd4ac3ebed599181351e119b90b0f39f9b2cf86e3e19bad469b87b99e71ca4be204901dff0e3d7c46900004b66344c2ac071bc305f3291ca2face27f90a1e6664c5dbd02f5ceb42975841dabc19eafb285b9c04ce9a6a32b850d1028ca698c3c11d4f12038f558beeddb7ea9b2518f74945801765d1e7045522fc36cb8707d90b3a087c29192bb423533d83dc1d8854ca985e28556c91fb87e595fb3eb7bd5bb75633660b0126fb4c27da3874e776eb161e92b980afa6cc0d16f7a7007cd0f77ed9ed4cc4c0f0ab60f47dc7ddced9afebd7938a92b111c4e08f1d6e1da2ad3710b26d67e712e676c73f325ff3bbc0955e532b15e1ef502ec1072284169b497024e53c70d8dd6cbb900a791d83e9a09864be7ff8a2ec03a41a33e4648570d511169d71818a1645f344332511b9f657d780cd30c4f41e74d6afd27b53c9bb6bbd2c10d8d4b11073b63b33137216f0650e28b7c110a913fab239057fcd1f7d26bc14af2d4f9e236c76785e0144e8b1bdf4c3c7fa493f20bb757650a0596729d34cb54a4d901b917d7062ddd265e222e063475e16bea5b47adcab7b0244a35919fe42b3b464096cc036f0567653e6052d4de5292f9f449fac35a906f0336e8011c9c8f01e900ac75366162b8f944fbce53a38366dc904450c7ff3609b5e28784bbad70fe626e011e948da063e944259070798e37b972be15794e9e9ebd684ac04c4625d28807a7790e5c6f0dc64015de2d91d68c77ddb10761bbadc0a8b3f20f9b0d71a55a8f1a364186fcea3396bcf6a0b8d45877d6bfcac863b89e2294db34adb6befbdfe8236b5f085b4bb7b5585696a7ed08726b1a1cd9bce641752628c1e95d21b85926c1d4cd0cff3485c25b76c56e39559d6cd2fd44eefc677e2848a142793b4a1f26845d30b44131505ad3c3fe8d2de878058c6d5e8200076fb63096bb890bf6a37ee9ceb406d8464ebb47f7ca7f064b723fde1c548207ec1366ea958b169de8f8bedebea2b8ca9f87d9dfa75d469edd637a116413d60139145c13195915905de90bb0bf3cd899844cb860262a35b2afcd3f1b653f9869a6db92e846e364f93867b89406dca0e340b70a4d5b7d84f3913d74f5e47639601a9ee56d9ebfd6041e6680208499e8dfbce57aa895de53b67aada102123835d967135f8b51120609d0d545aaece160a04bc7d27fa15266bbe07d42ad94f5224ad3c81a7cb7537739cb109262ef45ac8752bf1e5f8e005aa3ca83b0beb627080c9928e860d8acaa973133369bc1292a55a496bc725912904e457753e8a7335b556a3a966fed6be0b7b29a3ac7336dde38e6f4a8526c28646b3aebfb5d6cb77746b836f09159eff475e12f055583d6ff402935cf8d0f843b9258d0647e854f1e818cf2a29d66009a4601a604bf711d28399f5d56103b190cdf8aa4bfdac2bbf182449a4ddfe6189a1a7612540ad8c87f4bcba74d4bd293006b64692ff4a7eebff5c705f8244f5eee069db4d6abea34a28e04d2df538b513f05c7bc718ff68d4fd4d206fe1fae981d50829d8589a9f412fe37103b9e44d9138b0a3a7a6ec2f42d47d906a8674098e37e08045003a65ad09efcd693b629d9569ff43f1144791f24fbcf31372c6a9bf2a84b32dbfb83cf1d459efdd0433c92f5948671fc2612ffbb52387f679857059531b9ec864752b1d94848a8aafddd5c1a7f82126d417022aa1438a8240106fff9efb16d958d430a2f1bcbe5e0e875644ea5ebd74bef17269c11e836aface1303c82fb88d7a69c5e9b0b5100438815911f005df326b73856786974bda20c646c8dcd4c3971e4953294fd660ed9012d5376885aa75c0fc94fb0b4df54da3afecbb2eb31aabbca928055208548045b772f9b6d9cac88b72a96884d0bab35f360c84e1ffe21def4cfba527fdd61c7a9219d3fc79b0cfeb1e2448c64f6959de565fc82badc2bb9fa06140f4d9d5b1cba5ecc00f6e8941c47e245493aa267ddd3ba6c7517b3622cd0d6e8f3c36c337ac80aede6df57e4631a9717028971a81df7927b8aa99d3711eee98c83ed6a02faef28be604ba9c83d17f1d5a120f34448a202002e540c42fb7b814d7c7e3b1e8be122eb12665d6bd008b8adf0eeff05e3059422ed452f80b2b97634f4a577e080205b751aee21788585c48952ce4fc57856442db0d4bf2ae5cd5e5bbc2f3089dc5563e6c1607b3d529072b1e42ed3e017201cbdbe89914c4ae8eff21d791cdcd01b3ce9de223376af77b197b7bd2d2230a490603f349b4fb2b23771d38750fbdcb4898882d4fb01b2212bf93dcb171458d9e5da67aa442ac81731929024bfa56221781d68530a517450bbfd751c67f426a62cad6f3ddf019cc9611b336a6b851c5a192d3bdd82730103a920edc36273fc5327d018ffe36411be808e70250ee3b73117422021286e688a317e375eced4e28780195add46650e5d1a70a4b56dc90f93c766afde8e2678c502ca224de309e8a987749244dbbc8c721dfb38abeacca7a5337224eb9fbf9308b162faef0c2e80dfbb41fcc437a9a5b61cc8ae03767ee37b64633c019c381de343bde47825db52a4fea877e9660a93b336a28cb0690900dc7ffd2805e24703dc738e1721b07ab5dd11bfe3fe1a605dbd5207eaa159f2c3adadf5844e2fd0782683277e925ac7d337d2dfdafff253d28f67f386d9c2121a9f8decd6f9307be173ac15167727c5adf388c6b9638f43eb5f7efb4eb2c3f5a86e3ce4d1226aa53468f7325983face5111fe1935637c5b2b9f7298ff14f79c5d094a16ff1eca8a7cc47f293e97d8857a92c14d4e33d229d91badc61aff571b515335b0c1fb994c8be8577cf75499852369422a9eccdc985c050e2172837f9bc6df63e91a2b749042bf4c067c7c5549e1cee7508fbb7de31ea6f5a22b6b2cbb2e97db35c06f13ff7bc4fd2f1089aece1fb367ae77b7ba2f458cf4f37101cbc51b6895043d888fc92c87713d1b04c30b414c12448a56200039694af77f1f4a9182aab4edc290aeace0684b004aa41a12c329301b408fb69d19049c32afdb6f8cee92f1851560d433986bd2a53340146c83c45990a57fefc3f21c6b044cde0cfa62d9af6ec5aec644db012c93572cd1a654e2b8021cccc75acbcc91cbea561e3280cdb886465cca3eed3efc7c2566b9c23a3d545cb56e17db9b61c7c0f03da024bf416054803bd5c4168220f7d31e266b50cd515c2d77cfa9cc694d35d5c7ff021786758c261521c1227db902e3ccae49eafeabed61beefb83b94d68ae59d53816dc07af7f79562c02839a84eb41dc6e318e9f6d74f588a39ae71bbf5b143142d5d7431f64ebffcfcbd7ae7fe79af0ea7676303ccf39edab0f4cf64072c87d674feba4bb1d2b9a59a0dc49cf17beb9a0fc289a15c1f6546b7800e05dd7acdbe7ed0b984a902fedd806d9195084d39a36ce79d191fd3137fe285f39ffc8754176e3b988a6fce8934320b5160bbf30690adc3e90e2c955efe06c2293dc0e7a89725a5089c56e8d821bcb040276a33128c790ec20df310508ef12fd819b62b18756b7033c6c51651bfe3ad1d895e58bf76fdc6604fd09bb6ed916160971f20e2fb630713360826ac6bc56781db10e944ca578dedbd3d030ca55da65d11bc05b5b135d8f27ed55f7d95a46a9d1898a111fa9bef9fb179655136cbde7f413f900e5f6bc04ba9b2f93e13f1bdd0233fd1c1bd5f302504bdab42f93e9dea344372f139bf96ba5c47c9cfe132212009f002c46dd8033be350410b5e39f5158fb65392e85547cdf07abf844bdba2d276ad8a2dc89ae13ebe2228e8a28ef2 文章已被加密，请联系作者获取密码","tags":["Visual Studio","Qt"],"categories":["编程基础"]},{"title":"C99柔性数组","path":"/post/2984623496.html","content":"在讲述柔性数组（Flexible Array）之前，首先要介绍一下不完整类型 (Incomplete Type)。不完全类型是暂时没有完全定义好的类型，缺乏足够的信息（例如长度、类型）去描述一个完整的类型。在C&#x2F;C++中不完全类型有三种不同形式：void、未指定长度的数组以及具有非指定内容的结构和类。 比如通过使用不完整类型可以在头文件中隐藏结构体定义的具体细节，如： 123456// ring_buffer.htypedef struct _ring_buffer_type ringbuf_t;int ring_buffer_create(ringbuf_t **rcb, size_t size);int ring_buffer_write(ringbuf_t * rcb, uint8_t *pdata, size_t len); 123456// ring_buffer.cstruct _ring_buffer_type&#123; uint8_t* data; size_t size; &#125;; 我们在C++中经常使用的“向前声明”也是不完整类型的具体应用。 关于柔性数组所使用的不完整类型则是“未指定长度的数组”： 1int str[]; C99 将柔性数组纳入了标准之中，根据 C99 规定，柔性数组需要满足如下条件： 柔性数组只应用在结构体中。 结构体中不能只有柔性数组一个成员，而且柔性数组必须是结构体的最后一个成员。 由于柔性数组没有指定大小，因此不占用存储空间。 如下面结构体中的 data 数组就是柔性数组： 1234struct Package &#123; int len; char* data[];&#125; 由于 data 数组的长度为0，因此不占用存储空间： 1sizeof(Package) == sizeof(int) 包含柔性数组成员的结构体需要使用 malloc() 函数进行内存的动态分配，并且分配的内存通常大于结构体的大小，多余的空间自动分配给了柔性数组，这样就可以用柔性数组来存储额外的数据了。 123456789101112const char data[20] = &quot;hello&quot;;const int dataLen = strlen(data);Package* pck = (Package*)malloc(sizeof(Package) + dataLen);if (pck) &#123; pck-&gt;len = dataLen; memcpy(pck-&gt;data, data, dataLen); // ... free(pck);&#125;","tags":["C99","柔性数组"],"categories":["C++语言"]},{"title":"了解数字证书","path":"/post/3462229631.html","content":"打开任何一个数字证书售卖网站都可以看到它们通常将数字证书分为两个大类：SSL证书和数字签名证书。 SSL证书的主要作用是对网站进行身份验证和传输数据加密； 数字签名主要用于验证信息的真实性和完整性，根据使用场景的不同大致分为如下几类： 对客户端程序（.exe、.dll、.sys等文件）签名的代码签名证书。 对PDF等文档签名的文档签名证书。 对电子邮件及其附件签名和加密的邮件安全证书。 颁发机构有很多机构都可以颁发数字证书，比如 GlobalSign、DigiCert、Geotrust、Sectigo、WoTrus、Entrust 等，有的机构只能颁发SSL证书，有的机构可以颁发所有类型的证书。 机构有大小之分，所颁发的证书也有知名度和认可度之分，价格也有高低之分。 DV、OV、EV的区别首先介绍一下它们的全称： 12345DV = Domain Validation 域名验证OV = Organization Validation 机构验证EV = Extended Validation 扩展验证 要了解 DV、OV 和 EV 这三类证书之间的区别，首先要了解 DigiCert 等证书颁发机构（CA）是如何颁发证书的。 CA 作为受信任的第三方，它通过验证申请者的几个细节来确定是否可以颁发证书。申请三种类型的证书所需要验证的条件从 DV -&gt; OV -&gt; EV 依次增加，这也就导致了三种类型的证书的可信度也是依次增加的。 在 DV 级别，验证流程相当短，只要求购买者证明其对域名的所有权。验证方式是CA向（WHOIS数据库所列的）域名所有者发送电子邮件。如果您立即需要证书，这算是一种便捷的验证方法，但这种只进行一项检查的验证形式是互联网中最低标准的验证形式，其相应的信任度也应该是最低的。由于 DV 证书只验证域名的所有权，因此 DV 类型的证书只存在于 SSL 证书中。 OV 和 EV 证书的区别在于获取证书所需要的额外的验证条件和步骤。对于EV和OV证书，CA必须验证域名所有者以及与证书相关联的企业的相关详细信息，包括名称、类型、状态和实际地址。 而要获得EV，还需要几个额外步骤，包括验证企业的对外电话号码、开展业务的年限、注册号和管辖权，以及域名欺诈检查、联系人黑名单检查并致电以验证申请者的就业情况。 我们购买证书通常是通过CA机构在国内的代理商来申请和购买的，因此具体需要验证哪些材料，可以咨询代理商（如亚洲诚信、锐成信息、数安时代等等，多如牛毛），通常没有那么复杂，都是钱的事情。 SmartScreen在介绍 OV 和 EV 类型的代码签名证书的区别之前，我们有必要先了解一下 Windows 上的 SmartScreen 特性。 SmartScreen 全称 Microsoft Defender SmartScreen，是 Windows、Internet Explorer 和 Microsoft Edge 提供的一个可防止网络钓鱼、恶意软件网站、应用程序以及潜在恶意文件下载的安全功能。 SmartScreen 通过联机服务检查有关下载的应用程序的数字签名信息，以确定下载程序的信誉。如果此应用程序没有建立信誉，SmartScreen 会认为它是恶意程序的风险较高，就会向用户显示诸如“未知发布者”的警告。 下面是几种可能出现的 SmartScreen 警告的样式： 对于此类警告，微软的建议是“使用代码签名对程序进行数字签名”，“使用属于 Windows 根证书计划的证书颁发机构(CA)颁发的代码签名证书”，以验证发布者的真实身份，确保应用程序代码的完整性。 使用 OV 类型证书签名的程序可能不会立即消除 SmartScreen 警告，需要累计一定的下载量后才会消除，微软没有公布具体的消除规则。但由于 EV 类型签名证书的审核规则更加严格，因此使用 EV 类型证书签名的程序可以立即消除该警告。 代码签名证书OV和EV的区别下面列出了OV和EV类型的代码签名证书的不同之处。 OV类型的代码签名证书也称之为普通或标准型代码签名证书。 区别 OV代码签名证书 EV代码签名证书 审核内容 企业信息 企业信息及其他的信息。绝大多数公司都是可以申请的，只是需要签署更多的材料而已 颁发周期 时间不固定，1周左右 时间不固定，1~2周左右 可签名的软件类型 只支持签名应用软件，如.exe、.dll、.cab、.ocx、.msi、.xpi，不能签名驱动程序 支持签名应用软件和驱动程序 Windows硬件认证（WHQL）亦称徽标认证 不支持 支持 SmartScreen即时信誉 通过累计获得信誉，但微软未公布具体规则 立即获得 如何区分OV和EV代码签名 从上图可以看出，EV证书比OV证书多了很多字段。","tags":["数字证书","代码签名"],"categories":["项目管理"]},{"title":"玩转Qt 2D绘图之仪表盘实例","path":"/post/29874871.html","content":"在前面的《玩转 Qt 2D 绘图》系列文章中，已经介绍了 2D 绘图中常用的知识，本文主要通过一个汽车仪表盘的实例来综合应用前面所介绍知识点，并且还介绍了一些 Qt 绘图的常用技巧。 相关文章： 玩转Qt 2D绘图之坐标系 玩转Qt 2D绘图之画家的工具 玩转Qt 2D绘图之画家 实例效果图如下： 本实例主要涉及如下知识点： 坐标系的缩小、旋转、位移 绘制线条、圆、饼状图、多边形、文本 画笔、画刷的应用 三角函数的应用 废话不多说，下面开始分布讲解仪表盘的绘制步骤。为了便于后面的描述，我们先将控件上的各个元素进行标注： 1. 坐标系设置1.1 圆的半径仪表盘是一个圆，因此需要先确定圆的中心点和半径，中心点位于 QWidget 的中心，而 QWidget 可能并不是正方形，因此只能以最短边来确定圆的半径。 1234const qreal width = this-&gt;width();const qreal height = this-&gt;height();const qreal side = qMin(width, height); // 最短边const qreal radius = side / 2.0; // 半径 1.2 坐标系缩放假设当外圆的半径为 100 时，我们将内圆的半径设计为 85，中心圆的半径设计为 45，刻度数字字体设计为 10px，等等。 由于仪表板控件是一个通用型的控件，因此在实际应用中，其长宽并不固定为100px，其可以为任意值，为了保持美观和协调性，外圆、内圆、中心圆、数字字体等元素的大小都需要根据控件的大小而动态的改变。我们可以通过百分比的方式来设置各个元素的大小，如： 123456qreal r1 = side / 2.0; // 外圆半径qreal r2 = r1 * 0.85; // 内圆半径为外圆的85%qreal r3 = r1 * 0.45; // 中心圆的半径// 字体大小则根据 半径100 -&gt; 10px 这个基础来缩小和放大qreal fz = 10 * (r1 / 100.0); 看了上面的代码，相信大家已经有了明显的感受：需要手动计算百分比，太繁琐了，而且字体大小的缩放也不够线性。 的确如此，针对这些问题，我们可以通过下面的方案来解决。 在实际项目开发中，控件的样式通常不是程序员自己凭空想象的，而是经过设计师或美工设计出来的，设计师通过蓝湖、figma 等工具将效果图交付给开发人员，这些工具都带有尺寸标注功能，开发人员可以方便的获取设计尺寸。我们在开发时可以直接以设计尺寸来进行开发，不再计算百分比，改为动态的对坐标系进行缩放来适应实际尺寸。 1234const qreal width = this-&gt;width();const qreal height = this-&gt;height();const qreal side = qMin(width, height);painter.scale(side / 200.0, side / 200.0); // 设计师所设计的的长宽为200*200 1.3 坐标系原点为了方便绘制，我们通常还将坐标系的原点移动到圆的中心点位置，当然这不是必须的。 1painter.translate(width / 2, height / 2); 2. 绘制外圆控件是包含各种不同的元素，如外圆、内圆、刻度、指针等，一层一层的叠加在 QWidget 上面，从而组成了一个完整的控件。在绘制时，我们通常从最底层元素开始绘制，然后再一层一层地绘制上层元素。 本实例中，我们先绘制外圆，然后绘制内圆，一层一层的叠加（本文的章节顺序即为元素的绘制顺序）。 12345678// 绘制外圆painter.save();{ painter.setPen(Qt::NoPen); painter.setBrush(QColor(80, 80, 80)); painter.drawEllipse(QPointF(0, 0), 100.0, 100.0);}painter.restore(); 3. 绘制内圆1234567painter.save();{ painter.setPen(Qt::NoPen); painter.setBrush(QColor(60, 60, 60)); painter.drawEllipse(QPointF(0, 0), 85.0, 85.0);}painter.restore(); 4. 绘制三色饼状图1234567891011121314151617181920212223// startAngle_ 和 endAngle_ 起始和结束角度// qreal startAngle_ = -30;// qreal endAngle_ = 210;painter.save();{ qreal end = endAngle_; qreal spanAngles = (endAngle_ - startAngle_) * 0.7; // 0 ~ 70% painter.setPen(Qt::NoPen); painter.setBrush(QColor(24, 189, 155)); painter.drawPie(-55, -55, 110, 110, (end - spanAngles) * 16, spanAngles * 16); end -= spanAngles; spanAngles = (endAngle_ - startAngle_) * 0.15; // 70% ~ 85% painter.setBrush(QColor(218, 218, 0)); painter.drawPie(-55, -55, 110, 110, (end - spanAngles) * 16, spanAngles * 16); end -= spanAngles; spanAngles = (endAngle_ - startAngle_) * 0.15; // 85% ~ 100% painter.setBrush(QColor(255, 107, 107)); painter.drawPie(-55, -55, 110, 110, (end - spanAngles) * 16, spanAngles * 16);}painter.restore(); 5. 绘制中心圆绘制中心圆，用于覆盖饼圆的中心。 1234567painter.save();{ painter.setPen(Qt::NoPen); painter.setBrush(QColor(100, 100, 100)); painter.drawEllipse(QPointF(0, 0), 45, 45);}painter.restore(); 6. 绘制刻度线12345678910111213141516171819202122232425262728293031// majorScaleNum_ 指定有多少个大刻度线// scaleNumPerMajor_ 指定每2个大刻度线间隔内有多少个小刻度线// int majorScaleNum_ = 10;// int scaleNumPerMajor_ = 10;painter.save();{ QPen pen; pen.setColor(QColor(255, 255, 255)); pen.setCapStyle(Qt::RoundCap); pen.setWidthF(1.0); painter.setPen(pen); int totalScaleNum = majorScaleNum_ * scaleNumPerMajor_; qreal angleStep = (endAngle_ - startAngle_) / (qreal)totalScaleNum; painter.rotate(360 - endAngle_); // rotate 按顺时针方向旋转 for (int i = 0; i &lt;= totalScaleNum; i++) { if (i % scaleNumPerMajor_ == 0) { // 绘制大刻度 painter.drawLine(QPointF(57.0, 0.0), QPointF(72.0, 0.0)); } else { // 绘制小刻度 painter.drawLine(QPointF(57.0, 0.0), QPointF(64.0, 0.0)); } painter.rotate(angleStep); }}painter.restore(); 7. 绘制刻度数字因为数字始终是从左到右的方向绘制的，而绘制刻度时会改变坐标轴的方向，因此数字不能与刻度一起绘制。 使用三角函数计算文字矩形区域下横线中间点位置。 12345678910111213141516171819202122232425262728293031323334353637painter.save();{ QPen pen; pen.setColor(QColor(255, 255, 255)); painter.setPen(pen); QFont font; font.setPixelSize(10); painter.setFont(font); QFontMetrics fm(font); int txtHeight = fm.height(); qreal angleStep = (endAngle_ - startAngle_) / majorScaleNum_; qreal stepNum = (maxValue_ - minValue_) / majorScaleNum_; for (int i = 0; i &lt;= majorScaleNum_; i++) { qreal angle = startAngle_ + i * angleStep; qreal x = qCos(qDegreesToRadians(angle)) * 74.0; qreal y = -qSin(qDegreesToRadians(angle)) * 74.0; // 纵坐标与数学坐标系相反 QString txt = QString::number((int)((majorScaleNum_ - i) * stepNum)); // 大数在右边，小数在左边，先绘制大数 int txtWidth = fm.horizontalAdvance(txt); if (IS_NEARLY_EQUAL(x, 0.0)) { painter.drawText(QRectF(x - txtWidth / 2, y - txtHeight, txtWidth, txtHeight), Qt::AlignCenter, txt); } else if (IS_NEARLY_EQUAL(y, 0.0)) { painter.drawText(QRectF(x, y - txtHeight / 2, txtWidth, txtHeight), Qt::AlignVCenter | Qt::AlignLeft, txt); } else { if (x &gt; 0.0) painter.drawText(QRectF(x, y - txtHeight / 2, txtWidth, txtHeight), Qt::AlignVCenter | Qt::AlignLeft, txt); else painter.drawText(QRectF(x - txtWidth, y - txtHeight / 2, txtWidth, txtHeight), Qt::AlignVCenter | Qt::AlignRight, txt); } }}painter.restore(); 8. 绘制当前指针指针样式实际为三个点组成的三角形。 123456789101112131415161718192021// maxValue_ 和 minValue_ 为设置的刻度最大值和最小值// qreal minValue_ = 0.0;// qreal maxValue_ = 100.0;const qreal anglePerValue = (endAngle_ - startAngle_) / (maxValue_ - minValue_);painter.save();{ painter.setPen(Qt::NoPen); painter.setBrush(QColor(255, 107, 107, 204)); QPolygon pts; pts.setPoints(3, 0, 5, 0, -5, 64, 0); qreal rotateAngle = 360.0 - endAngle_; rotateAngle += anglePerValue * (curValue_ - minValue_); painter.rotate(rotateAngle); painter.drawPolygon(pts);}painter.restore(); 9. 绘制中心小圆123456789101112painter.save();{ painter.setPen(Qt::NoPen); // 红色圆 painter.setBrush(QColor(255, 107, 107)); painter.drawEllipse(QPointF(0.0, 0.0), 20.0, 20.0); // 白色圆 painter.setBrush(QColor(255, 255, 255)); painter.drawEllipse(QPointF(0.0, 0.0), 16.0, 16.0);}painter.restore(); 10. 绘制当前值123456789101112painter.save();{ QFont font = painter.font(); font.setPixelSize(14); font.setBold(true); painter.setFont(font); painter.setPen(QColor(0, 0, 0)); painter.drawText(-16, -16, 32, 32, Qt::AlignCenter, QString::number(curValue_));}painter.restore(); 至此，大功告成，齐活！ 控件演示程序下载地址： https://github.com/winsoft666/qt-custom-2d-controls","tags":["Qt"],"categories":["Qt"]},{"title":"互联网的黑话","path":"/post/3924191794.html","content":"对于黑话我是拒绝的，但在这个圈子混，又不得不懂一些黑话，以防产生沟通障碍。关键时候说一两句黑话似乎还能显得有B格。 下面是在网上收集的一些黑话，进行了稍许整理，仅供娱乐，请勿当真。 名词解释 PM: 互联网产品经理，是互联网公司中的一种职能，负责互联网产品的计划和推广，以及互联网产品生命周期的演化。 RD：后端开发，属于软件研发工程师的一种，主要职责是后台系统设计与开发、接口设计和功能实现。 FE：前端开发，属于软件研发工程师的一种，使用 HTML、CSS、JavaScript 等专业技能和工具将产品UI设计稿实现成用户可视的app页面、网站页面等。 QA：测试工程师，属于软件测试工程师，工作职责包括：检查软件有没有缺陷（Bug）、测试软件是否具有稳定性（Robustness）、安全性、易操作性等性能。 UI：用户界面设计师，指从事对软件的人机交互、操作逻辑、界面美观的整体设计工作的人。 UE or UX：User Experience 用户体验，指以用户体验为中心的设计。 UED ：User Experience Design 用户体验设计，指以用户为中心的一种设计手段，以用户需求为目标而进行的设计。 HMI：Human Machine Interface 人机界面，人机界面是系统和用户之间进行交互和信息交换的媒介， 它实现信息的内部形式与人类可以接受形式之间的转换。 CLI：Command-line Interface 命令行界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。 CEO：Chief Executive Officer「首席执行官」 CTO：Chief Technology Officer「首席技术官」 COO：Chief Operations Officer「首席运营官」 CFO：首席财务官（Chief Financial Officer），负责公司的财务管理，包括财务报告、预算规划和资本投资决策。 HRBP：为Human Resource Business Partner（人力资源业务合作伙伴），是企业派驻到各个业务或事业部的人力资源管理者，主要协助各业务单元高层及经理在员工发展、人才发掘、能力培养等方面的工作。 SEM：Search Engine Marketing 搜索引擎营销。是一种网络营销形式，就是全面而有效的利用搜索引擎来进行网络营销和推广。 SEO：Search Engine Optimization 搜索引擎优化。利用搜索引擎的搜索规则来提高展示排名。 ASO：App Store Optimizatio 苹果应用商店搜索。指提升APP在各类APP苹果电子市场排行榜和搜索结果排名的过程。 UGC：User Generated Content 用户生成内容，用户将自己原创的内容在网上对他人呈现。 VC：Venture Capital 风险投资，大多是创业投资。 BP：Business Plan 商业计划书，是公司、企业或项目单位为了达到招商融资和其它发展目标，根据一定的格式和内容要求而编辑整理的一个向受众全面展示公司和项目目前状况、未来发展潜力的书面材料。 VR：Virtual Reality 虚拟现实，综合利用计算机图形系统和各种现实及控制等接口设备，在计算机上生成的，可交互的三维环境中提供沉浸感觉的技术。 AR：Augmented Reality 增强现实,它是一种将真实世界信息和虚拟世界信息“无缝”集成的新技术。真实的环境和虚拟的物体实时地叠加到了同一个画面或空间同时存在。 MR：Mediated Reality 介导现实，VR是纯虚拟数字画面，包括AR在内的Mixed Reality是虚拟数字画面+裸眼现实，MR是数字化现实+虚拟数字画面。 B2B：Business to Business 企业对企业的电子商务，如阿里巴巴。 B2C：Business to Customer 企业对个人的电子商务，如京东。 C2C：Customer to Customer 个人对个人的电子商务，如淘宝。 O2O：Online to Offline 线上对线下，线下商务与线上推广相结合。 新零售：未来电子商务平台即将消失，线上线下和物流结合在一起，才会产生新零售。线上是指云平台，线下是指销售门店或生产商，新物流消灭库存，减少囤货量。（电子商务平台消失是指，现有的电商平台分散，每个人都有自己的电商平台） GMV: Gross Merchandise Volumn 商品总交易量。 CLV：每个客户在未来可能为企业带来的收益总和。 IAAS：Infrastructure-as-a-Service 基础设施即服务，消费者通过Internet 可以从完善的计算机基础设施获得服务。这类服务称为基础设施即服务。 PAAS：Platform-as-a-Service 平台即服务，把服务器平台作为一种服务提供的商业模式。 SAAS：Software-as-a-Service 软件即服务，一种通过Internet提供软件的模式，厂商将应用软件统一部署在自己的服务器上，客户可以根据自己实际需求，通过互联网向厂商定购所需的应用软件服务，按定购的服务多少和时间长短向厂商支付费用，并通过互联网获得厂商提供的服务。 ASP：Application Service provider 应用服务提供商，通过构建应用系统运行平台，然后再租给各个不同的用户使用。对用户来说，是以“月租”代替“购买”。 CRM：Customer Relationship Management 客户关系管理，指用计算机自动化分析销售、市场营销、客户服务以及应用等流程的软件系统 ERP：Enterprise Resource Planning 企业资源计划，企业资源计划是指建立在信息技术基础上，以系统化的管理思想，为企业决策层及员工提供决策运行手段的管理平台。 BPM：业务流程管理系统 MRD：Market Requirements Document 市场需求文档，常见的为竞品分析，一般用于立项，基于目前市场数据及竞品等进行项目提出，一般用于提案。 PRD：Product Requirement Document 产品需求文档，一般是说明实现的过程，较为详细。有些公司为了敏捷开发需要很多时候会直接在原型图上面通过注释方式进行更直观的展示。 PMD：Program Managment Document 项目管理文档，一般包括项目进度、项目资源、责任人和项目输出物，常规通过visio进行甘特图绘制管理。该文档一般贯穿整个项目全程，衡量项目进度。 BRD：Business Requirement Document 商业需求文档，是基于商业目标或价值所描述的产品需求内容文档（报告）。其核心的用途就是用于产品在投入研发之前，由企业高层作为决策评估的重要依据。其内容涉及市场分析，销售策略，盈利预测等，通常是供决策层们讨论的演示文档，一般比较短小精炼，没有产品细节。 DRD：Design Requirement Drawing 交互设计文档，一般用来承载交互说明，并交付给前端、测试以及开发工程师参考的文档。 FSD：Functional Specifications Document 功能详细说明，定义产品功能需求的全部细节。FSD一般通过一张张的截屏和一条条功能点来定义产品规格。这是一份可以直接让工程师创建产品的文档。 PSD：Product Specifications Document 产品规格文档，PSD是一个较不流行的缩写，但是在有这样一个文档的机构中，它大体和上面描述的功能规格文档（FSD）相同。 SRS：Software Requirements Specification 软件需求文档，软件需求文档（SRS）是另一较不流行的缩写，在创建SRS的机构中，它在内容和细节上和上面描述的PRD或FSD有些想像。 AARRR模型：Acquisition、Activation、Retention、Revenue、Refer 这个五个单词的缩写，分别对应这一款移动应用生命周期中的5个重要环节。分别为：获取用户、提高活跃度、提高留存率、获取收入、自传播。 RFM用户模型：R(Recency)表示客户最近一次购买的时间有多远，F(Frequency)表示客户在最近一段时间内购买的次数，M (Monetary)表示客户在最近一段时间内购买的金额。 用户增长的S型曲线、J型曲线：指大多数产品，在产品发展周期中，都会遵循S型曲线的增长方式；但有些产品，可能产生J型曲线无限增长。 用户金字塔模型：第一级是社区的管理人员。第二级是用户管理工具。第三级是有价值用户，基本就是在社区里面足够活跃，并且给你的社区贡献有效价值的那些用户。第四级一般性用户。 OO：Object Oriented 面向对象，是一种把面向对象的思想应用于软件开发过程中，指导开发活动的系统方法，是建立在“对象”概念基础上的方法学。 OOA：Object Oriented Analysis 面向对象分析，是确定需求或者业务的角度，按照面向对象的思想来分析业务。 OOD：Object Oriented Design 面向对象设计，是OO方法中一个中间过渡环节。其主要作用是对OOA分析的结果作进一步的规范化整理，以便能够被OOP直接接受。 OOP：Object Oriented Programming 面向对象程序设计，OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。 CMS：Content Management System 内容管理系统，是一种位于WEB 前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统。内容的创作人员、编辑人员、发布人员使用内容管理系统来提交、修改、审批、发布内容。 Adsens：Google AdSense 是一种获取收入的快速简便的方法，适合于各种规模的网站发布商。它可以在网站的内容网页上展示相关性较高的 Google广告，并且这些广告不会过分夸张醒目。 PPC：Pay Per Click 点击付费广告，规则是广告主只有当使用者实际上点击广告以拜访广告主的网站时，才需要支付费用。 DSP：Demand-Side Platform 需求方平台广告，它服务于广告主，帮助广告主在互联网或者移动互联网上进行广告投放，DSP可以使广告主更简单便捷地遵循统一的竞价和反馈方式，对位于多家广告交易平台的在线广告,以合理的价格实时购买高质量的广告库存。 SSP：Sell-Side Platform 供应方平台，通过这一平台，媒体主希望他们的库存广告可以获得最高的有效每千次展示费用，而不必以低价销售出去。 DMP：Data-Management Platform 数据管理平台，数据管理平台能够帮助所有涉及广告库存购买和出售的各方管理其数据、更方便地使用第三方数据、增强他们对所有这些数据的理解、传回数据或将定制数据传入某一平台，以进行更好地定位。 RTB：Real Time Bidding 实时竞价，RTB是一种技术为王的精准营销手段，当一个用户在全网浏览过某种商品，或点击过特殊类目的广告后，其浏览痕迹都会通过cookie记录在案，而通过广告交易平台，你在下一次浏览网页的时候，将被推送符合偏好的广告。 SPAM：搜索引擎垃圾技术，搜索引擎垃圾技术是利用不道德的技巧去提高自己搜索引擎上的排名。 CPC : 网络中最常见的一种广告形式，它是英文单词 Cost Per Click 的缩写意思就是每次点击付费广告。 CPM : Cost Per Thousand 广告投放过程中，1000次展现的费用。 CPA：Cost Per Action 每行动成本。指投放按广告实际效果，即按回应的有效问卷或定单来计费，而不限广告投放量。 CPR：每回应成本，Cost Per Response，以浏览者的每一个回应计费。 CPP: 每购买成本,Cost Per Purchase,广告主为规避广告费用风险，只有在网络用户点击旗帜广告并进行在线交易后，才按销售笔数付给广告站点费用。 CPS：Cost Per Sales 每销售成本，以实际销售产品数量来计算广告费用的广告，这种广告更多的适合购物类、导购类、网址导航类的网站，需要精准的流量才能带来转化。 CPT：Cost Per Time 按时间成本，这种方式的特点是按用户使用时长或使用周期计费，可以从根本上杜绝刷流量、激活作弊，是最真实的、有效的营销方式之一。 DAU：Daily Active User 日活跃用户数量，统计一日（统计日）之内，登录或使用了某个产品的用户数（去除重复登录的用户）。 WAU：Weekly Active Users 七天内登陆过产品的用户数。统计一周之内（统计日）之内，登录或使用了某个产品的用户数（去除重复登录的用户）。 MAU：Monthly Active User 月活跃用户量，统计一月之内（统计日）之内，登录或使用了某个产品的用户数（去除重复登录的用户）。 DOU：Day Old User 日老玩家用户，表示当天登录游戏的老玩家，指非当天新增的用户。 DNU：Day New User 日新增用户，表示当天的新增用户。 ACU：Average Concurrent Users 平均同时在线人数。 PCU：Peak Concurrent Users 最高同时在线人数。 UV：Unique Visitor 唯一访问量，可以理解为页面被多少人看过。 PV：Page View 页面浏览量，可以理解为页面被人看过的总次数。用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计。 RV: Repeat Visitors 重复访客。 ARPU：Average Revenue Per User 平均每活跃用户收益。转化率：用户点击页面后，产生被期望的特定行为的数量，占总量的比。 ARPPU：Average Revenue Per Paying User 每付费用户平均收益。统计周期内，付费用户对产品产生的平均收入。 LTV：Life Time Value LTV 生命周期价值，是产品从用户所有的互动中所得到的全部经济收益的总和。 CAC：Customer Acquisition Cost 用户获取成本，获取用户所花费的成本。 KPI：Key Performance Indicator 关键绩效指标，是企业绩效考核的方法之一。 ROI：Return On Investment 投资回报率，投资回报率（ROI）&#x3D;利润总额&#x2F;投入成本总额×100% 抽离透传：“抽离主观感受”然后进行“透明传播”，就是说在传递信息时，不要传递带着你的情绪、判断，把你得到的信息透明地传递出去。 顶层设计：基本概念是运用系统论的方法，从全局的角度，对某项任务或者某个项目的各方面、各层次、各要素统筹规划，以集中有效资源，高效快捷地实现目标。 底层逻辑：即是哲学中所讲的事物发展的主要矛盾，策划方案中，多用与分析部分，指现象或者事件的根本原因 。 垂直领域：垂直领域，互联网行业术语，为限定群体提供特定服务，包括娱乐、医疗、环保、教育、体育等产业。 存量博弈：存量博弈是指在资源有限的情况下争夺市场份额 增量博弈：增量博弈是在做大蛋糕的过程中通过博弈获取更多或更少的份额，在营销中指在增量市场，抢占市场份额。 组合拳：本意是在拳法当中利用各种单一拳法的组合连续攻击，在营销策划中，指采用多种营销手段来达到最终营销诉求 。 击穿：比喻经受巨大的冲击导致效果显著。贬义上指承受不住冲击崩溃。 闭环：用来描述一个团队可以不借助外力完成一套完整的商业逻辑。 咬合：用来描述在跨部门项目上，部门人员之间的联动效果。 壁垒：古时候指战争中的防御工事，在策划案中，指品牌不可复制、不可超越的专属性优势，多用于战略和策略部分 。 提供情绪价值：拍马屁 汇总1234567891011121314落地、沉淀、给到、响应、同步、对齐、对标、迭代、优化、跟进、升级、交付、聚焦、倒逼、复盘、梳理、输出、提炼、包装、上升、方案、摸索、踩坑、填坑、报备、串联、协同、联动、透传打通、打平、抹平、发力、兼容、量化、细分、重塑、蓄能、引爆、挖掘、背书、背锅、支持、支撑、协调、支援、加持、加速、共建、共创、融合、拉通、拉升、洞察、渗透、咬合、穿梭、辐射扩展、开拓、兜底、降级、容错、容灾、解耦、耦合、复用、封装、抽象、聚合、集成、拆解、抓包、观察、监控、上报、捕获、分发、分层、迁移、回溯、回归、回流、回跳、赋能、通晒、吃透、死磕、树立、跨界、共情、演绎、画饼、打造、反哺、输血、造血、造势、造市、造事、下沉、拉新、转化、留存、促活、付费、营收、盈利、获客、邀请、助力、激励、激活、推广、投放、导流看盖、曝光、裂变、增长、优秀、感恩、比心、笔芯、下跪、致敬、订阅、认证、推送、唤醒、流失、召回、授权、接入、铸造、构筑、构建、搭建、布局、组局、摸鱼、划水、众筹、收割、共享重组、收口、转型、围绕、出击、证言、确认、明确、评估、评审、务实、夯实、预判、预言、变迁、返佣、深入、打磨、攻坚、击穿、破冰、破题、解题、破圈、破局、定量、定性、制约、约束触及、触达、触发、操盘、思考、反思、精简、深耕、突围、补位、抽离、履约、进化、进军、起飞皮实、本分、重磅、垂直、真香、自治、精准、持续、灵活、稳定、可控、活跃 12345678910抓手、漏斗、中台、平台、闭环、风口、打法、玩法、矩阵、纽带、刺激、规模、场景、渠道、入口、维度、格局、形态、生态、体系、认知、体感、感知、心智、调性、战役、合力、心力、赛道基石、基因、因子、模型、通道、链路、水位、水准、姿态、卡点、卡位、头部、腰部、踝部、痛点、爽点、痒点、全域、公域、私域、本我、自我、超我、蓝海、红海、纵向、横向、上限、下限上游、下游、闽值、场域、架构、系统、标配、长尾、态势、锚点、标杆、壁垒、变量、期权、边界、品牌、阵地、高地、洼地、高空、革命、变革、内卷、外包、福报、脑暴、脑洞、圈层、层级段位、环节、闲局、话术、文案、议程、公关、PR稿、配称、力场、魔方、触点、势能、流量、资源、排期、延期、弹窗、浮层、引导、蒙层、幕帘、遮罩、埋点、坑位、楼层、按钮、推送、红包峰值、漏洞、风险、瓶颈、策略、价值、成本、复利、人性、利器、深度、玩家、小白、非菜、羊毛、福利、套路、情怀、标准、规范、报备、社群、产业、载体、服务、粘性、属性、地域、终端版本、口碑、指标、年框、试点、母体、空白、银弹 1234对一下、碰一下、过一下、抢品类、卡认知、占场景、观行业、明竞争、洞自身、开场子、提调子、冷启动、秀肌肉、借东风、断舍离、婷羊毛、砍一刀、走出去、讲故事扁平化、差异化、平台化、结构化、精细化、短平快、常态化、强依赖、不可控 1234567891011121314151617感知度、颗粒度、方法论、组合拳、引爆点、护城河、影响力、资源位、优先级、制高点、可用性易用性、稳定性、便捷性、耦合性、一致性、系统性、端到端、点对点、点线面、上半场、下半场主战场、基本面、基本盘、操盘手、进化论、解释权、最优解、执行力、驱动力、鄙视链人货场生态链、生态圈全渠道全方位、全媒体、流量池、天花板、传话筒、转化率生态位、全场景、新零售、新物种、新品牌、活跃度、颗粒感登云梯、冲击力、视觉锤、孵化器、新篇章、新局势新赛道、新势能、新国货、新国潮、新动力、同理心气氛组、竞争力、存在感、认同感、参与感归属感、使命感、忠诚度、预热期、高峰期、高潮期、上升期、瓶颈期、大数据、云计算.价值观、!区块链、比特币、虚拟币、天使轮、自媒体、新媒体、价格门、超预期、小前台、大中台、凝聚力、向心力 123456支棱起来、快速响应、小步快跑、价值转化、强化认知、资源置换、资源倾斜、资源配置、完善逻辑、去中心化、渠道下沉、用户下沉、降维打击、体验度量、高频触达、快速迭代、持续迭代、持续集成、持续交付、持续观察、躬身入局、顺势而为、打破结界、升维定位、有机结合、起承转合、存量维持、增量博弈、心智角逐、抽离透传、拨几参会、反复确认、综合评估、刻意练习、打破制约.绝境求生、品牌露出、拥抱变化、重新定义、借势营销、内容创业、归因分析、逻辑推理、建立范式、总结沉淀、解决问题、占领心智、高举高打、高开低走、高台跳水、深入产业、拉齐水位、全情投入、如何收口、全面封锁、协同作战、剑走偏锋、弹射起飞 12结果导向、业务导向、资源紧张、人力不足、体感不好、风险可控、逻辑自洽、品效合一、全球领先、人无我有/人有我优/人优我变、势如破竹、势不可挡、石破天惊 12345678910生命周期、复用打法、商业模式、平台战略、集团战略、战略引警、关键路径、决策路径、天使投资、盈利模式、底层逻辑、顶层设计、饥饿营销、行业壁垒、下沉市场、消费认知、人工智能、赛博明克、智慧城市、解决万案、知识付费、私域流量、交付价值、时间价值、共享经济、通证经济、中央厨房、先发优势、真实场景、临门一脚、真香定律、正态分布、幂律分布、二八定律、长尾理论叠加效应、马太效应、沉没成本、边际成本、机会成本、偏好植入、蚂蚁市场、场景占位、产业集群、产业服务、标杆市场、心动情境、利基市场、第二曲线、增长飞轮、垂直领域、可持续性、可替代性、认知优势、新增长点、颠覆态势、最高规制、三位一体、资深玩家、不破不立、精神SPA、用户心智、用户粘性、用户体验、用户认知、用户画像、用户调研、重度用户、沉默用户、活跃用户、用户黏性、千人千面、千人一面、信息茧房、流量红利、流量为王、价格歧视、意识形态、心理账户、情绪G点、品牌势能、服务产业、关键时期、沟通协作、战略合力、品牌航母、品类战舰、行军路线产品尖兵、拳头产品、超级符号、挽留弹窗、时间窗口、定性定量、战略支点、声音印记、社交货币、付费社群、神交已久、财务自由 1234567大数据分析、大数据杀熟、延迟满足感、地毯式轰炸、饱和式攻击、四两拨千斤、开辟新路径、建立新习惯用户无感知、叫好又叫座、优先级很高、拉新成本高、打开率极高、留存率奇高、活跃度新高颠覆式创新、连续创业者、投入产出比、互联网思维、互联网红利、国民总时间、最后一公里、海豚湾模式、最大公约数、现象级事件、沉浸式体验、用户忠诚度、自媒体矩阵、病毒式营销、风口上的猪、战略性投资、战略性亏损、系统性风险","categories":["杂念"]},{"title":"建立专属的账号密码体系","path":"/post/737594544.html","content":"在日常生活中，我们不仅需要记忆6位数字的银行卡密码，还需要记忆各式各样网站和应用的账号密码，可能我们自己也不记得曾经注册过多少个账号。账号和密码如此繁多，管理这些账号和密码，也是一个让人头疼的问题。 最原始的方法是将密码写纸上，放在一个安全的地方，但纸张存在丢失、损坏的风险，而且不方便存取。 改进版则是将纸张电子化，如 Excel，并辅以云盘实现多端同步，这样虽然存取便利性上有一定的改善，但安全性却降低了很多，如果云盘没有历史版本功能，在编辑时稍有失误，可能导致密码全部丢失，另外如果云盘密码泄露、电脑中毒或系统损坏，也可能导致密码泄露或丢失。如果某一天云盘软件突然倒闭了，该怎么办呢？ 目前已经有很多账号密码管理软件，来帮助人们管理账号和密码，如 1Password、KeePass 等，但它们也或多或少存在一些缺陷： 对系统和平台（Windows、Linux、macOS、安卓、iOS等）支持完善的工具大多需要收费，而且费用不便宜；免费的工具通常对系统和平台的支持不够完善，也不好用。 在多端同步方面，收费软件通常支持云端同步，但这样将账号密码存储在他人服务器总归不放心；免费软件通常不支持云端不同，需要自己使用云盘来同步，操作麻烦。 软件可能存在后门，导致账号密码泄露。 软件可能随时停止运营或无法打开。 综上所述，我认为只有记在大脑中的密码才是最安全和方便的。那么，对于大多数没有什么密码学基础的普通人来说，如何形成一套自己的个人账号密码设置体系呢？ 账号密码体系由账号和密码二者构成，一一对应，需要明确的是，我们可能忘记密码，同样我们也可能忘记账号，因此账号和密码同样重要。 1. 账号根据使用场景（国内、网站）和系统注册要求的不同，通常需要准备如下类型的账号。 1.1 手机号码现在基本每个人都有手机号码，而且国内手机号都已实名认证，注册国内网站、应用时优先使用手机号码进行注册，如果支持短信验证码登录，则优先使用短信验证码登录。 1.2 电子邮件需要准备国内和国外两个电子邮件，分别用于注册国内、外的网站和应用。因为国外平台可能不支持国内的邮件服务商，而如果使用国外邮件服务注册国内平台，又可能导致邮件收取缓慢或无法收取，因此建议根据国内外应用分别使用不同的国内外邮件服务。 国内邮件服务推荐： 163 QQ 国外邮件服务推荐： Gmail Outlook 不建议使用小众邮箱，这些邮箱可能随时因为公司经营不善而倒闭或停止服务。 1.3 英文数字账号有的网站支持使用“英文+数字”形式的账号进行注册（当然后期可能因为账号安全性，要求绑定手机号或邮箱），建议使用统一的、不暴露隐私的英文数字账号。 不建议在账号中使用中文、下划线、横线，因为虽然有些的网站支持这些特殊字符，但无法保证所有网站都支持这些字符。 1.4 隐私性在注册国内网站&#x2F;应用时，不需要纠结使用国内手机号、邮箱的隐私性，因为根据国内目前的政策和现状，国内网站和应用基本没有隐私性可言。 2. 密码最安全的密码方案肯定是不同的网站和应用使用不同的随机字符串作为密码，但是这样不方便记忆，而且大多数情况下也不需要这么高强度的安全性。 下面是一种折中的密码生成方案，生成的密码可以符合绝大多数应用的要求，该方案可以在保证密码安全的前提下，方便记忆，如下图所示： 该方案还有很多可改进之处，例如应用名称也可以通过某种固定规则来缩写等。 固定前缀和特殊字符后缀需要根据自己喜好来设定，如固定字符前缀为“he”，特殊字符后缀为“?”。 混淆码则根据应用名称缩写长度（补零之前的长度）的不同而不同，需要自己定义一套规则，如： 长度 混淆码 1 ~ 2 1111 3 ~ 4 2222 5 ~ 7 3333 8 ~ 10 4444 10 以上 5555 上表仅用作示例，抛砖引玉。 根据上述示例规则，下面列举几个网站的密码示例。 12345678知乎heZ00H1111?今日头条heJrtT2222?ChromeheChromE3333? 3. 不重要的账号密码为了防止账号和密码泄露，从而被他人猜测出密码的生成规则，因此在注册小型、非正规、不重要的网站和应用时，建议使用一个专门的账号和密码，即便密码泄露也无关紧要。","tags":["密码"],"categories":["爱折腾"]},{"title":"谈一谈Qt的布局技巧","path":"/post/1495821570.html","content":"1. 手动拖放通过在 Qt Designer 中手动拖放控件，可以快速实现界面布局，如下图所示： 这种方式对初学者非常友好，可以快速上手开发一个界面，增加成就感。但我们需要知道，拖放布局不是 Qt 布局的全部，这种方式仅适合简单的界面布局。 在实际的项目开发中，界面上的控件会比上面示例中的多得多，布局也会更加复杂，而且界面通常还需要反复地调整。在这种情况下，如果继续通过手动拖放的方式来进行布局，在每次界面调整时，我们都需要打破（分拆）原有的布局，并在修改完成之后重新进行布局，可能还需要重新设置布局的 Spacing 和 ContentsMargins，每一次修改都非常费劲。 题外话： 手动拖放控件对手的稳定性要求较高，可能手稍一抖，整个布局就错乱了，又得还原了重新来。 2. 代码布局我通常使用代码的方式来进行 Qt 界面布局，例如下面的代码实现了与上面示例一样的布局效果： 12345678910111213141516171819202122232425262728QLabel* lblUserName = new QLabel(&quot;用户名: &quot;);QLabel* lblPassword = new QLabel(&quot;密码: &quot;);QLineEdit* editUserName = new QLineEdit();QLineEdit* editPassword = new QLineEdit();QPushButton* btnLogin = new QPushButton(&quot;登录&quot;);QPushButton* btnRegister = new QPushButton(&quot;注册&quot;);QHBoxLayout* hUserName = new QHBoxLayout();hUserName-&gt;addWidget(lblUserName);hUserName-&gt;addWidget(editUserName);QHBoxLayout* hPassword = new QHBoxLayout();hPassword-&gt;addWidget(lblPassword);hPassword-&gt;addWidget(editPassword);QHBoxLayout* hButton = new QHBoxLayout();hButton-&gt;addStretch();hButton-&gt;addWidget(btnRegister);hButton-&gt;addWidget(btnLogin);hButton-&gt;addStretch();QVBoxLayout* vMain = new QVBoxLayout();vMain-&gt;addLayout(hUserName);vMain-&gt;addLayout(hPassword);vMain-&gt;addStretch();vMain-&gt;addLayout(hButton);this-&gt;setLayout(vMain); 大家看到上面代码后，第一感觉肯定是“我的个老天，这么复杂”，这个可以理解。但这种方式的好处也非常明显，比如灵活性更大，后期调整、复用、维护也更加方便，而且对于自定义控件比较多的界面，这种方式可以直接创建对应类型的实例，不需要在设计器上进行类型提升。 3. 布局描述语言我在这里不是为了创造一种新的语言，而是受到了 Flutter 界面布局方式的启发，对 Qt 的布局进行了封装，简化了上述布局代码。 下面是上述示例简化后的布局代码： 1234567auto layout = VBox( HBox(lblUserName, editUserName), HBox(lblPassword, editPassword), Stretch(), HBox(Stretch(), btnRegister, btnLogin, Stretch()));setLayout(layout); 从代码量来看，明显少了很多，而且我们还可以通过代码的层次结构快速看出界面的布局结构。 在此省略了 VBox、HBox 等类的实现代码，如果您对上述 Qt 布局方式的具体实现感兴趣，可以在下面留言或者联系我。","tags":["Qt"],"categories":["Qt"]},{"title":"C++异常之我所见","path":"/post/1878135693.html","content":"C++异常所带来的问题当我们在代码中写下一行 throw 语句时，我们就此埋下了一个祸根，从此以后，在该函数调用链中，必须至少有一个调用者需要提供相应的异常捕获，否则一旦异常被抛出，程序就会异常终止。 例如，函数 f() 调用 g()，而 g() 又调用 h()，并且 h() 抛出一个异常，则 g() 和 f()中必须有一个提供了相应的异常捕获，否则程序会异常终止。 由于异常会使代码的执行流程从任意地方跳出，因此我们还需要付出大量的精力来编写正确的异常安全代码，例如使用 RAII（资源获取即初始化）来保证资源正确释放。 如下面的示例，虽然我们在函数 f() 中捕获了异常，避免了程序的异常终止，但异常却中断了函数 g() 的正常执行流程，导致对象 m 没有被正确释放，从而出现了资源泄露。这种情况可能还会变相地增加了程序的调试难度。 1234567891011121314151617181920212223void h() &#123; throw std::exception();&#125;void g() &#123; int* m = new int(); h(); delete m;&#125;void f() &#123; try &#123; g(); &#125; catch (...) &#123; &#125;&#125;int main()&#123; f(); return 0;&#125; 启用异常还会在每个生成的二进制文件中添加额外的数据，从而增加编译时间（可能只是略微增加）并可能增加地址空间的使用。 异常的存在可能会导致开发人员滥用异常，在本不该（或不需要）抛出异常的地方抛出异常。例如，无效的用户输入就不应抛出异常。 即便我们捕获了异常，我们也很难从异常中恢复回来，因为我不能确定异常具体是从调用链的哪一步抛出的，也无法知晓每一步的实现逻辑，因此如果程序中使用了异常，我们除了做好必要的参数检查，尽量避免异常发生，在异常被抛出时，让程序自然的退出也是一个不错的选择。 能完全避免使用异常吗？太难了，我们很难完全避免使用异常。 在 C++ 标准库（STL）中，大多数情况是通过抛出异常的形式来返回错误的，虽然我们可以使用诸如 EASTL 这样的库来替代 STL，但仍然很难避免程序使用的其他库不会使用 STL 以及抛出异常，比如常用的日志库 spldlog、boost库、rpclib库等都会抛出异常。 因此要完全的不使用异常，我们需要从头实现众多的基础组件，这是一个巨大的工作量。 折中的办法虽然我们很难完全避免异常，但我们还是可以努力远离异常的。 下面是我的一点点建议： 可以使用 EASTL 替代 STL，或者仅使用 STL 中不抛出异常的模块。 在选择第三方库时，尽量选择不使用异常的库，通常 C 语言开发的库不会使用异常，如 curl、zlog 等，但需要留意有些 C 语言库可能会使用 exit 和 abort 函数，我觉得使用这两个函数比使用异常更可怕，异常导致程序崩溃至少有迹可循，而这两个函数退出程序时，通常很难排查定位。 保证自己编写的代码不主动抛出异常，例如函数通过返回值的形式返回错误，并且尽可能使用 C++ 17 中的[[nodiscard]]，强制调用者检查返回值。但应避免使用全局状态变量，如 Windows 的 LastError，因为这样会破坏函数调用的局部性。 构造函数也可能会失败，但我们不应使用异常来抛出错误。按照惯例，可以使用两步构造法，在构造函数中只做基本的、不会出错、不会抛出异常的操作或者直接使用空的构造函数，然后提供一个单独的 init 函数来进行初始化，并返回错误码。 异常捕获的粒度不宜太细，如果对每一行可能抛出异常的语句都进行异常捕获，这样会导致代码过于繁琐。如果粒度太粗，又会导致异常难于恢复，失去了捕获的意义。我们要做的是，在调用函数前，对参数进行充分地检查，尽量避免异常的发生，然后仅在关键代码位置进行异常捕获。","tags":["C++","异常"],"categories":["C++语言"]},{"title":"有趣的Unicode表情符号","path":"/post/3984616957.html","content":"本文了转载和收集了一些常用的 Unicode 表情符号，方便查阅。完整的 Unicode 表情符号可以查询下面的网站： unicode官网emoji列表 wikipedia List_of_emojis 几何图形🞀🞁🞂🞃🞄🞅🞇🞉🞌🞍🞑🞒🞓🞔🞕🞖🞗🞘🞚🞛🞜🞝🞞🞠🞡🞢🞣🞤🞥🞦🞧🞨🞩🞪🞫🞬🞭🞮❎✔✅☑︎🞯🞰🞱🞲🞳🞴🞵🞶🞷🞸🞹🞺🞻🞼🞽🞾🞿🟀🟂🟃🟄🟆🟇🟈🟉🟊🟌🟍🟎🟐🟒🟔🟠🟡🟢🟣🟤🟥🟦🟧🟨🟩🟪🟫 表情🤗🤫🤣🙃🙂🥰🤩🤪🤑🤭🤔🤐🤬🥱😩🥺🧐🤓😎🤠🥳😵‍💫🤯🤧😷🤒🤕🤢🤮🥵🥶🥴🤤🤥🤨🤖🤡💩 🙈 🙉 🙊 😀😁😂😃😄😅😆😉😊😋😎😍😘😗😙😚☺😇😐😑😶😏😣😥😮😯😪😫😴😌😛😜😝😒😓😔😕😲😷😖😞😟😤😢😭😦😧😨😬😰😱😳😵😡😠 情感💋💯💢💥💫💦💨🕳💬👁️‍🗨️🗨🗯💭💤 人物👦👧👨👩👴👵👶👱👮👲👳👷👸💂🎅👰👼💆💇🙍🙎🙅🙆💁🙋🙇🙌🙏👤👥🚶🏃👯💃👫👬👭💏💑👪 不同肤色、发型、性别的人👴👴🏻👴🏼👴🏽👴🏾👴🏿💇🦰🦱🦳🦲🧑👨👩👫 手势💪👈👉☝👆👇✌✋👌👍👎✊👊👋👏👐✍ 手机电话📱📲📶📳📴☎📞📟📠 公共社会♻🏧🚮🚰♿🚹🚺🚻🚼🚾⚠🚸⛔🚫🚳🚭🚯🚱🚷🔞💈 动物🙈🙉🙊🐵🐒🐶🐕🐩🐺🐱😺😸😹😻😼😽🙀😿😾🐈🐯🐅🐆🐴🐎🐮🐂🐃🐄🐷🐖🐗🐽🐏🐑🐐🐪🐫🐘🐭🐁🐀🐹🐰🐇🐻🐨🐼🐾🐔🐓🐣🐤🐥🐦🐧🐸🐊🐢🐍🐲🐉🐳🐋🐬🐟🐠🐡🐙🐚🐌🐛🐜🐝🐞🦋 植物💐🌸💮🌹🌺🌻🌼🌷🌱🌲🌳🌴🌵🌾🌿🍀🍁🍂🍃 自然天气🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜☀🌝🌞⭐🌟🌠☁⛅☔⚡❄🔥💧🌊🌈 食物🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍅🍆🌽🍄🌰🍞🍖🍗🍔🍟🍕🍳🍲🍱🍘🍙🍚🍛🍜🍝🍠🍢🍣🍤🍥🍡🍦🍧🍨🍩🍪🎂🍰🍫🍬🍭🍮🍯🍼☕🍵🍶🍷🍸🍹🍺🍻🍴 文体🎪🎭🎨🎰🚣🛀🎫🏆⚽⚾🏀🏈🏉🎾🎱🎳⛳🎣🎽🎿🏂🏄🏇🏊🚴🚵🎯🎮🎲🎷🎸🎺🎻🎬 恐怖😈👿👹👺💀☠👻👽👾💣 十二生肖🐁🐂🐅🐇🐉🐍🐎🐐🐒🐓🐕🐖 时钟🕛🕧🕐🕜🕑🕝🕒🕞🕓🕟🕔🕠🕕🕡🕖🕢🕗🕣🕘🕤🕙🕥🕚🕦⌛⏳⌚⏰⏱⏲🕰 爱心❤💌💝❤️‍🔥❤️‍🩹🧡💛💚💙💜🤎🖤🤍💘❤💓💔💕💖💗💙💚💛💜💝💞💟❣ 交通🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚣🚤🚢✈💺🚁🚟🚠🚡🚀 办公📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💳✉📧📨📩📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂🔒🔓🔏🔐🔑 箭头⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝 八卦☰☱☲☳☴☵☶☷ ䷀䷁䷂䷃䷄䷅䷆䷇䷈䷉䷊䷋䷌䷍䷎䷏䷐䷑䷒䷓䷔䷕䷖䷗䷘䷙䷚䷛䷜䷝䷞䷟䷠䷡䷢䷣䷤䷥䷦䷧䷨䷩䷪䷫䷬䷭䷮䷯䷰䷱䷲䷳䷴䷵䷶䷷䷸䷹䷺䷻䷼䷽䷾䷿ 扑克牌🂠🂡🂢🂣🂤🂥🂦🂧🂨🂩🂪🂫🂬🂭🂮🂱🂲🂳🂴🂵🂶🂷🂸🂹🂺🂻🂼🂽🂾🂿🃁🃂🃃🃄🃅🃆🃇🃈🃉🃊🃋🃌🃍🃎🃏🃑🃒🃓🃔🃕🃖🃗🃘🃙🃚🃛🃜🃝🃞🃟🃠🃡🃢🃣🃤🃥🃦🃧🃨🃩🃪🃫🃬🃭🃮🃯🃰🃱🃲🃳🃴🃵 麻将牌🀀🀁🀂🀃🀄🀅🀆🀇🀈🀉🀊🀋🀌🀍🀎🀏🀐🀑🀒🀓🀔🀕🀖🀗🀘🀙🀚🀛🀜🀝🀞🀟🀠🀡🀢🀣🀤🀥🀦🀧🀨🀩🀪🀫 多米诺骨牌🀰🀱🀲🀳🀴🀵🀶🀷🀸🀹🀺🀻🀼🀽🀾🀿🁀🁁🁂🁃🁄🁅🁆🁇🁈🁉🁊🁋🁌🁍🁎🁏🁐🁑🁒🁓🁔🁕🁖🁗🁘🁙🁚🁛🁜🁝🁞🁟🁠🁡🁢🁣🁤🁥🁦🁧🁨🁩🁪🁫🁬🁭🁮🁯🁰🁱🁲🁳🁴🁵🁶🁷🁸🁹🁺🁻🁼🁽🁾🁿🂀🂁🂂🂃🂄🂅🂆🂇🂈🂉🂊🂋🂌🂍🂎🂏🂐🂑🂒🂓","tags":["Unicode","Emoji"],"categories":["爱折腾"]},{"title":"生活家（转载）","path":"/post/1485983255.html","content":"《红楼梦》第五十回中，一夜大雪后，贾府大观园的姐妹们一起作诗，众姐妹要王熙凤为即景联诗起个头。王熙凤虽只识得几个字，倒也不扭捏，笑道:“我想下雪必刮北风。昨夜听见了一夜的北风，我有了一句，就是‘一夜北风紧’，可使得?”众人听了，都相视笑道：“这句虽粗，不见底下的，这正是会作诗的起法。不但好，而且留了多少地步与后人”。 的确，与大观园里才女们的锦心绣口比起来，“一夜北风紧”甚至算不上诗。不过，凤姐说得没错。大雪将落之时，必是要刮北风的。她不是优秀的诗人，却是一位洞察世事的生活家。 成年后，我与父亲聊起凤姐的“一夜北风紧”，母亲突然问：“这个凤姐是不是一个厉害人物，掌管着整个家族事务?”我吃惊地点头，母亲视力不佳看不成戏文，更没有读过《红楼梦》，她是如何得知的呢？母亲解释:“你想啊，在深宅大院，熟睡的人根本听不到外面的动静。能听到一夜北风的人，肯定是日夜操劳、心里装着事的人啊!” 母亲的话让我想起小时候的无数个清晨，看到院子里有一摊摊水渍，我好奇地问父母:“昨晚下雨了吗？”，“又是刮风又是下雨的，凌晨四五点钟才停。”父母回答。当时我还纳闷儿：我怎么一点儿动静都没有听到呢？现在想来，那时年少无忧无虑，一觉酣睡到天亮，疾风骤雨都与自己无关。而父母为一家人的生计操劳，晚上听到风雨声，会惦记着衣服收了没有，已经结了穗的庄稼会不会被风雨打得七零八落，雨后道路泥泞是否影响出工…… 终于，我懂得了父母，也读懂了凤姐。","tags":["红楼梦"],"categories":["剪切板"]},{"title":"玩转Qt 2D绘图之画家","path":"/post/1967189103.html","content":"在 Qt 2D 世界中，图形基本都由点、线、矩形、多边形、椭圆、圆、折线、曲线、文本、贴图等基本元素辅以着色而构成，而且 QPainter 类已经提供了这些元素的绘制方法，花点时间掌握这些方法，也就掌握了 Qt 2D图形控件的制作，余下的就是勤学多练、孰能生巧了。 一、点在 Qt 中使用 QPoint 或 QPointF 类型表示一个点的坐标。 QPoint 和 QPointF 的区别在于：QPoint 使用整型表示 X 和 Y 坐标，而 QPointF 使用 qreal 浮点类型表示X和Y坐标。下面如无特殊说明，所介绍的方法都适用于两个类型。 QPoint 类型虽然提供了 isNull 方法来判断对象是否为空，在 X 和 Y 坐标均为 0 时，isNull 返回 true，其他情况返回 false。在使用 QPoint::isNull 方法时要留意这个情况。 可以使用 QPoint::manhattanLength 方法返回 x 和 y 坐标的绝对值之和（也叫曼哈顿距离），如： 12QPoint pt(-2, 4);pt.manhattanLength(); // 6 1.1 两点距离使用两点间的距离公式可以快速计算两点的距离： 123456#include &lt;QtMath&gt;QPointF pt1(-2, 4);QPointF pt2(4, 8);qreal distance = qSqrt(qPow(pt1.x() - pt2.x(), 2.0) + qPow(pt1.y() - pt2.y(), 2.0)); // 7.21 1.2 drawPoint 与 drawPointsdrawPoint 用于绘制单个点： 123void drawPoint(const QPointF &amp;position)void drawPoint(const QPoint &amp;position)void drawPoint(int x, int y) drawPoints 用于一次性绘制多个点： 1234void drawPoints(const QPointF *points, int pointCount)void drawPoints(const QPolygonF &amp;points)void drawPoints(const QPoint *points, int pointCount)void drawPoints(const QPolygon &amp;points) QPolygon继承自 QVector&lt;QPoint&gt;，而QPolygonF继承自 QVector&lt;QPointF&gt;。 二、折线折线是由多个点相连组成的非闭合线条（相邻的两个点连接成直线，但首位不相连）。 1234void drawPolyline(const QPointF *points, int pointCount)void drawPolyline(const QPolygonF &amp;points)void drawPolyline(const QPoint *points, int pointCount)void drawPolyline(const QPolygon &amp;points) 下面示例演示了折线的一种绘制方法，为了使线条更加圆润，我们还设置了线条的起落笔样式和相交点样式。 1234567891011void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); painter.setPen(QPen(Qt::red, 6, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin)); QPolygon pg; pg &lt;&lt; QPoint(20, 200) &lt;&lt; QPoint(80, 10) &lt;&lt; QPoint(140, 200) &lt;&lt; QPoint(200, 10); painter.drawPolyline(pg);} 三、多边形多边形是在折线的基础上首尾相连而来，并且可以使用画刷对多边形的闭合区域进行填充。 仍然使用上面示例中定义的点来绘制多边形，设置 QPainter 画刷颜色为蓝色： 123456789101112void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); painter.setPen(QPen(Qt::red, 6, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin)); QPolygon pg; pg &lt;&lt; QPoint(20, 200) &lt;&lt; QPoint(80, 10) &lt;&lt; QPoint(140, 200) &lt;&lt; QPoint(200, 10); painter.setBrush(Qt::blue); painter.drawPolygon(pg);} 四、线两点（QPoint 或 QPointF）可以确定一条直线，Qt 提供了 QLine 和 QLineF 类型来描述线段。 使用 drawLine 方法可以绘制一条直线，使用 drawLines 方法则可以一次性绘制多条直线。 12345678910111213void drawLine(const QLineF &amp;line)void drawLine(const QLine &amp;line)void drawLine(int x1, int y1, int x2, int y2)void drawLine(const QPoint &amp;p1, const QPoint &amp;p2)void drawLine(const QPointF &amp;p1, const QPointF &amp;p2)void drawLines(const QLineF *lines, int lineCount)void drawLines(const QVector&lt;QLineF&gt; &amp;lines)void drawLines(const QPointF *pointPairs, int lineCount)void drawLines(const QVector&lt;QPointF&gt; &amp;pointPairs)void drawLines(const QLine *lines, int lineCount)void drawLines(const QVector&lt;QLine&gt; &amp;lines)void drawLines(const QPoint *pointPairs, int lineCount)void drawLines(const QVector&lt;QPoint&gt; &amp;pointPairs) 五、椭圆与圆5.1 椭圆椭圆有长轴、短轴、焦点等概念，建议在学习绘制椭圆之前先了解椭圆的这些概念，可以参考之前的文章 回顾2D绘图的数学知识 中的“椭圆”章节。 Qt提供了 QPainter::drawEllipse 方法绘制椭圆，方法原型如下： 12345void drawEllipse(const QRectF &amp;rectangle)void drawEllipse(const QRect &amp;rectangle)void drawEllipse(int x, int y, int width, int height)void drawEllipse(const QPointF &amp;center, qreal rx, qreal ry)void drawEllipse(const QPoint &amp;center, int rx, int ry) drawEllipse 方法虽然有5种重载形式，但总体来说，都是传递一个矩形区域给 drawEllipse方法，因为根据传入的矩形可以确定椭圆的长轴、短轴和焦点，其中长轴等于矩形的长，短轴等于矩形的高，2个焦点分别位于2个长半轴的中间。 下面示例先绘制了一个浅灰色的矩形（用于观察椭圆的绘制），然后在使用该矩形绘制椭圆。 1234567891011121314void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); QRectF rect(50, 50, 300, 200); // 浅灰色的矩形 painter.setPen(Qt::lightGray); painter.drawRect(rect); // 红色椭圆 painter.setPen(Qt::red); painter.drawEllipse(rect);} 5.2 圆圆是椭圆的一种特殊情况，当椭圆的长轴等于短轴时，所绘制出来的就是圆了。 123456789void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); // 宽 = 高 QRectF rect(50, 50, 300, 300); painter.drawEllipse(rect);} 六、矩形在 Qt中使用 QRect 和 QRectF 类型来表示矩形，在使用 QRect 时需要关注 QRect 的历史遗留问题，详见：玩转Qt 2D绘图之坐标系 的“QRect遗留问题”章节。 6.1 矩形的合法性QRect和QRectF类型均提供了isEmpty、isNull、isValid方法，但 QRect 由于历史遗留问题，官方文档中对各个方法的定义看起来比较怪异，进行逻辑下面对其进行了逻辑运算，方便理解。 QRect 1234567891011isEmpty() == left() &gt; right() || top() &gt; bottom() == left() &gt; left() + width() - 1 || top() &gt; top() + height() - 1 == 1 &gt; width() || 1 &gt; height()isNull() == (right() == left() - 1 &amp;&amp; bottom() == top() - 1) == (left() + width() - 1 == left() - 1 &amp;&amp; top() + height() - 1 == top() - 1) == (width() == 0 &amp;&amp; height() == 0)isValid() == left() &lt;= right() &amp;&amp; top() &lt;= bottom() == left() &lt;= left() + width() - 1 &amp;&amp; top() &lt;= top() + height() - 1 == 1 &lt;= width() &amp;&amp; 1 &lt;= height() QRectF 123isEmpty() == width() &lt;= 0 || height() &lt;= 0isNull() == width() == 0 &amp;&amp; height() == 0isValid() == width() &gt; 0 &amp;&amp; height() &gt; 0 从上述定义可以发现，当前矩形的宽或高为负数时，isNull 返回的却是 false。 6.2 drawRect 与 drawRects使用 drawRect 方法绘制单个矩形，使用 drawRects 方法一次性绘制多个矩形。 1234567void drawRect(const QRectF &amp;rectangle)void drawRect(int x, int y, int width, int height)void drawRect(const QRect &amp;rectangle)void drawRects(const QRectF *rectangles, int rectCount)void drawRects(const QVector&lt;QRectF&gt; &amp;rectangles)void drawRects(const QRect *rectangles, int rectCount)void drawRects(const QVector&lt;QRect&gt; &amp;rectangles) 下面是一个简单的使用示例： 12345678910111213void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); painter.drawRect(QRect(20, 20, 200, 200)); painter.setPen(Qt::red); QVector&lt;QRect&gt; rects; rects &lt;&lt; QRect(60, 60, 200, 200) &lt;&lt; QRect(100, 100, 200, 200); painter.drawRects(rects);} 6.3 圆角矩形上面绘制的矩形都不是圆角，在Qt中绘制圆角矩形有两种方式： QPainter::drawRoundedRect，本节主要介绍这种方法，这种方法绘制的圆角矩形的4个角的曲度一样。 QPainter还提供了 drawRoundRect 方法也可以绘制圆角矩形，但该方法已经被标记为弃用，因此不建议继续使用。 QPainter::drawPath 通过路径的方式来绘制圆角矩形，这种方法绘制的圆角矩形的4个角的曲度可以不一样，该方法会在下面章节介绍。 1void QPainter::drawRoundedRect(const QRectF &amp;rect, qreal xRadius, qreal yRadius, Qt::SizeMode mode = Qt::AbsoluteSize) 下面示例为了演示圆角矩形和普通的直角矩形的不同，先绘制了一个浅灰色直角矩形，然后再相同区域绘制了一个红色圆角矩形。 12345678910111213141516171819void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); QRectF rect(50, 50, 300, 200); // 先绘制一个浅灰色的矩形 painter.setPen(Qt::lightGray); painter.drawRect(rect); // 然后绘制一个红色圆角矩形 // qreal xRadius = 20; qreal yRadius = 40; painter.setPen(QPen(Qt::red, 1, Qt::DashDotLine)); painter.drawRoundedRect(rect, xRadius, yRadius);} 7.4 xRadius 与 yRadiusxRadius 与 yRadius 参数决定了圆角的曲度，drawRoundedRect 方法绘制的圆角矩形的四个角采用同一个曲度。那么 xRadius 与 yRadius 参数是如何决定圆角的曲度的呢？ xRadius 参数实际为椭圆的长半轴，yRadius 参数实际为椭圆的短半轴。 关于椭圆的相关知识，可以参考之前的文章 回顾2D绘图的数学知识 中的“椭圆”章节。 通过 xRadius 和 yRadius 参数确定了椭圆的长轴和短轴，那么在什么位置画椭圆呢？答案是：贴着四个顶角分别画 4 个椭圆来确定曲度。 下面代码在上面示例的基础上，分别在左上角和右下角位置画了2个深黄色的椭圆，可以看到椭圆与圆角是刚好重合的。 12345678910111213141516171819202122232425void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); QRectF rect(50, 50, 300, 200); // 先绘制一个浅灰色的矩形 painter.setPen(Qt::lightGray); painter.drawRect(rect); // 然后绘制一个红色圆角矩形 // qreal xRadius = 20; qreal yRadius = 40; painter.setPen(QPen(Qt::red, 1, Qt::DashDotLine)); painter.drawRoundedRect(rect, xRadius, yRadius); // ~~~ 新增如下代码 ~~~ painter.setPen(QPen(Qt::darkYellow, 1, Qt::DashLine)); painter.drawEllipse(QRectF(rect.left(), rect.top(), xRadius * 2, yRadius * 2)); painter.drawEllipse(QRectF(rect.right() - xRadius * 2, rect.bottom() - yRadius * 2, xRadius * 2, yRadius * 2));} 七、椭圆上的一段线7.1 弧线（Arc）使用 drawArc 方法可以绘制一段弧线： 1234void drawArc(const QRectF &amp;rectangle, int startAngle, int spanAngle)void drawArc(const QRect &amp;rectangle, int startAngle, int spanAngle)void drawArc(int x, int y, int width, int height, int startAngle, int spanAngle) 在前面介绍的椭圆绘制方法中，我们通过指定一个矩形区域就可以绘制一个椭圆，而 drawArc 方法绘制曲线的则是该椭圆上的某一段弧线。通过 startAngle 参数指定弧线的起始角度，spanAngle 参数指定弧线所跨越的角度。 需要注意： 在 QPainter 的绘图函数中指定角度（不是弧度）时，以正三点钟方向为 0 度，角度按逆时针方向增长，整个圆按 5760 度计算（即 16 * 360）。 在 GDI+ 中，也是以正三点钟方向为 0 度，但角度是按顺时针方向增长的，且整个圆按 360 度计算。 下面的示例绘制一段红色的弧线，弧线从 30 度方向开始，弧线跨越了 120 度。 123456789101112131415161718void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); QRectF rect(50, 50, 300, 200); // 浅灰色的矩形 painter.setPen(Qt::lightGray); painter.drawRect(rect); // 蓝色的椭圆 painter.setPen(Qt::blue); painter.drawEllipse(rect); // 红色的弧线 painter.setPen(Qt::red); painter.drawArc(rect, 30 * 16, 120 * 16);} 实际绘制效果如下图所示： 从上图可以看到，弧线实际是椭圆上的某一段曲线。 7.2 饼状图（Pie）使用 drawPie 可以绘制饼状图，饼状图是在上面弧线（Arc）的基础上，分别将弧线的首尾与中心点相连而来，因此 drawPie 方法的参数也与 drawArc 方法一样。 QPainter 在绘制饼状图时，会使用当前的画刷填充饼状图。 下面的示例绘制了一个具有红色轮廓、黄色填充的饼状图。 12345678910111213141516171819void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); QRectF rect(50, 50, 300, 200); // 浅灰色的矩形 painter.setPen(Qt::lightGray); painter.drawRect(rect); // 蓝色的椭圆 painter.setPen(Qt::blue); painter.drawEllipse(rect); // 饼状图：红色的轮廓，黄色的填充 painter.setPen(Qt::red); painter.setBrush(Qt::yellow); painter.drawPie(rect, 30 * 16, 120 * 16);} 7.3 和弦图（Chrod） 此处将 Chrod 按照英文直译成“和弦”可能不太准确 和弦图（Chrod）与饼状图（Pie）一样，也是在弧线的基础上变化而来，将弧线的首尾相接就可得到和弦图（Chrod）。 使用 drawChord 方法可以绘制和弦图，drawChord 方法的参数与 drawArc 一样。 12345678910111213141516171819void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); QRectF rect(50, 50, 300, 200); // 浅灰色的矩形 painter.setPen(Qt::lightGray); painter.drawRect(rect); // 蓝色的椭圆 painter.setPen(Qt::blue); painter.drawEllipse(rect); // 和弦图：红色的轮廓，黄色的填充 painter.setPen(Qt::red); painter.setBrush(Qt::yellow); painter.drawChord(rect, 30 * 16, 120 * 16);} 八、路径前面介绍了线、矩形、椭圆、圆、弧线、饼状图等形状，路径则是由若干个这些形状（不限于这些形状）组成的一个集合，路径可以是闭合的，也可以不闭合。 在Qt中使用QPainterPath对象来定义一个路径，并使用如下方法向路径中添加形状： addEllipse 添加一个椭圆或圆到路径中 addRect 添加一个矩形到路径中 addRoundedRect 添加一个圆角矩形到路径中 addText 将用指定字体绘制的文件所形成的闭合形状添加到路径中 lineTo 添加一条直线到路径中 arcTo 添加一段圆弧到路径中arcTo 的原型如下，和 drawArc 方法类似，也需要指定起始角度和跨越角度，但与drawArc 方法不同的是，arcTo 方法指定的角度是以360度整圆计算的，因此不需要乘以 16。1void QPainterPath::arcTo(const QRectF &amp;rectangle, qreal startAngle, qreal sweepLength) cubicTo 添加一个三次贝塞尔曲线到路径中 quadTo 添加一个二次贝塞尔曲线到路径中 在上面方法中，命名格式为“To”的方法，如 lineTo、arcTo、quadTo 等，都是基于“当前位置”来添加形状的，默认的当前位置为当前的*坐标原点 (0,0) 处，我们可以使用 QPainterPath::currentPosition 方法获取当前位置。 我们知道可以通过 QPainter::translate 等方法变换逻辑坐标，QPainterPath 的当前位置也会受逻辑坐标变换的影响。 在使用 lineTo 添加直线到路径中时，只有指定直线的结束点，会自动将当前位置与结束点相连，形成一条直线，并重设当前位置为该结束点。 在使用 arcTo、cubicTo、quadTo 添加曲线到到路径中时，会自动将当前位置与曲线起点相连，并重设当前位置为曲线结束点。 我们使用一个示例来说明当前位置和结束点的关系，下面示例先添加一条直线，然后添加一个曲线，最好再添加一条直线： 123456789101112// 示例：当前位置void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); QPainterPath path; path.lineTo(80, 50); path.arcTo(QRectF(50, 50, 300, 200), 30, 120); path.lineTo(200, 200); painter.drawPath(path);} 实际效果如下图所示： 8.1 填充规则路径可以是闭合的也可以是非闭合的，例如上面的当前位置示例中的路径是非闭合的，但如果为 QPainter 指定了画刷，QPainter 会自动使用一条直线连接该非闭合形状的首尾，使其闭合，进而使用画刷对其填充。 QPainterPath 有两种填充规则，可以通过QPainterPath::setFillRule方法来设置填充规则： Qt::OddEvenFill 奇偶填充规则，从一点向图形外引一条水平线，该线和图形的边线相交，如果交点的个数为奇数，则该点在图形中。 Qt::WindingFill非零弯曲规则，从一点向图形外引一条水平线，该线与图形的边线相交。如果边线是顺时针绘制的，则记为1，如果边线是逆时针绘制的，则记为-1。最后将所有结果相加的和为0则该点在图形中。（矩形和椭圆都按顺时针绘制） 九、文本文字有颜色、字体、样式等属性。 Qt 不仅可以绘制纯色的文本，还可以使用渐变色、图片等内容来填充文字，比如下面两种方式都可以用来绘制渐变色的文字： 先将文字转变成路径（参考QPainterPath::addText），然后使用渐变画刷填充该路径。 直接为 QPen 设置渐变画刷。 通过为 QPainter 设置 QFont 对象来修改字体，字体有字体族、字号、粗体、斜体、下划线、删除线等样式或效果： 123456789QFont font;font.setFamilies({\"Microsoft YaHei\", \"Arial\"}); // 字体族font.setPixelSize(26); // 字号font.setBold(true); // 粗体font.setItalic(true); // 斜体font.setUnderline(true); // 下划线font.setStrikeOut(true); // 删除线painter.setFont(font); 使用 QPainter::drawText 方法绘制文本，该方法原型有很多种，但大多是通过下面2个原型进行重载而来的： 12void QPainter::drawText(const QRectF &amp;rectangle, int flags, const QString &amp;text, QRectF *boundingRect = nullptr)void QPainter::drawText(const QRectF &amp;rectangle, const QString &amp;text, const QTextOption &amp;option = QTextOption()) 9.1 间距间距分为两种情况： 每个字符的间距，如单个英文字母或单个汉字的间距，称为 Letter Spacing。 每个英文单词的间距，称为 Word Spacing。 9.1.1 单词间距使用 QFont::setWordSpacing 和 QFont::wordSpacing 方法设置和获取单词的间距。 1void QFont::setWordSpacing(qreal spacing) 当 setWordSpacing 参数大于0时，单词间距增加相应的像素；小于0时，间距减少相应的像素。 9.1.2 字符间距使用 QFont::setLetterSpacing 和 QFont::letterSpacing 方法设置和获取字符的间距。 1void QFont::setLetterSpacing(QFont::SpacingType type, qreal spacing) 字符间距支持百分比和绝对值两种设置方法，通过QFont::SpacingType枚举类型指定。 QFont::PercentageSpacing 百分比方式。值为100时表示不做任何改变，200表示间距扩大到原来的一倍，-200表示间距缩小到原来的一倍。 QFont::AbsoluteSpacing 绝对值方式，与设置单词间距的方式一样。 9.2 小型大写字母小型大写字母（英语：small capitals，简称 small caps）是西文字体设计中的一种字符形式。这些字母的形状（字形）和大写字母相同但尺寸较小，比如在表示键盘快捷键的时候也常用小型大写字母。 在 Qt 中通过设置 QFont 的 Capitalization 样式为 SmallCaps 风格来使用小型大写字母样式，如： 12345678910111213141516void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); QPen pen; pen.setBrush(Qt::red); pen.setWidthF(20); QFont font; font.setPixelSize(26); font.setCapitalization(QFont::SmallCaps); ^^^^^^^^^^^^^ painter.setFont(font); painter.drawText(10, 30, \"The Keyboard Shortcut is Ctrl + Shift + K\");} 效果如下图所示（留意全小写的“is”和其他首字母大写的单词）： Capitalization 还支持设置如下风格： QFont::MixedCase 默认，不做更改 QFont::AllUppercase 全部小写 QFont::AllLowercase 全部大写 QFont::Capitalize 首字母大写 9.3 计算绘制文本所需空间有两种方式可以计算按指定字体绘制文本所需的空间。 方式一：使用 QPainter::drawText 使用如下函数原型： 1void QPainter::drawText(const QRectF &amp;rectangle, int flags, const QString &amp;text, QRectF *boundingRect = nullptr) 将参数 rectangle 的 宽和高都设置为 0，函数会通过 boundingRect 参数返回绘制文本所需要的宽和高。 方式二：使用 QFontMetricsF QFontMetrics 或 QFontMetricsF 可以按照指定字体来计算给定字符和字符串的宽和高。 这种方式的弊端在于：不能将绘制风格（如居中对齐、多行文本）带入其中进行计算，只能计算给定的单行字符串按照指定的字体显示所需的宽高。 123456QFont font;font.setPixelSize(36);QFontMetricsF fm(font);qDebug() &lt;&lt; fm.horizontalAdvance(\"Hello World\"); // 字符串所占宽度qDebug() &lt;&lt; fm.height(); // 字体的高度 十、贴图QPainter 提供了 drawPixmap 和 drawImage 两个常用的贴图函数，drawPixmap 用于绘制 QPixmap 对象，而 drawImage 用于绘制 QImage 对象，QImage 与 QPixmap 间是可以相互转化，因此 drawPixmap 和 drawImage 方法的效果是一样的。 drawPixmap 方法在屏幕上绘制速度更快，而 drawImage 方法则在 QPrinter 和其他设备上绘制的更快。 需要注意：QPicture 对象用于记录绘制步骤，而 QPainter::drawPicture 方法用于重复 QPicture 对象所记录的步骤。 drawPixmap 和 drawImage 方法有多个重载的原型，其参数从左到右依次为： 1目标区域 -&gt; QPixmap/QImage -&gt; 源区域 目标区域会应用当前 QWidget 的 devicePixelRatio，而源区域则与 devicePixelRatio 无关，具体参考 QPixmap使用要点 限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺 您可以通过在 blog-comment 项目中提交Issue来间接地发表评论🍀","tags":["Qt"],"categories":["Qt"]},{"title":"玩转Qt 2D绘图之画家的工具","path":"/post/1336811290.html","content":"软件是对现实世界的抽象，在设计软件接口时通常也会参考现实世界来进行设计。 在现实世界中，画家使用画笔、画刷这些工具在宣纸上作画，而在 Qt 中，画家是 QPainter 对象（画家的大脑则是 QPaintEngine），纸张可以是 QPaintDevice 的任何子类对象，如 QWidget、QImage、QPixmap、QGLPixelBuffer 等；在 QPainter 选好纸张后，就可以使用画笔来勾勒物体的轮廓了，Qt 中的画笔是 QPen 对象；画完轮廓后，可能还需要使用画刷来填充轮廓，Qt 中的画刷是 QBrush 对象。 一、QPaintDevice本节介绍 QPaintDevice 的几个常用方法。 devicePixelRatio() 与 devicePixelRatioF() 用于获取DPI的缩放倍数，需要先在程序中开启DPI缩放特性： 123456789int main(int argc, char *argv[]){ QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling); QGuiApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);#if (QT_VERSION &gt;= QT_VERSION_CHECK(5, 14, 0)) QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough);#endif // .......} 从 Qt 5.14 版本开始，Qt可以支持小数位的 DPI 缩放，如 1.25、1.75 等。如需获取小数位DPI值，需要先设置Qt::HighDpiScaleFactorRoundingPolicy::PassThrough策略，然后通过 devicePixelRatioF 方法获取。 width() 与 height() 用于获取 QPaintDevice 的宽和高，这个数值不会随着坐标系的改变而改变，而且也不会随着 DPI 的改变而改变。 widthMM() 与 heightMM() 用于获取 QPaintDevice 在屏幕上实际显示的宽和高，单位为毫米。 二、QPen画笔有宽度（width/widthF）、颜料（brush）、线条样式（Style）、一条线起笔和落笔的样式（CapStyle）、两条线相交处的样式（JoinStyle）等属性。 2.1 宽度12void QPen::setWidth(int width)void QPen::setWidthF(qreal width) 如果指定的宽度小于 0，将不会绘制任何内容；如果指定的宽度等于 0，将被视为 1 个像素宽度；如果指定的宽度大于等于 1，则按指定的宽度来绘制。 2.2 QPen的画刷1void QPen::setBrush(const QBrush &amp;brush) QPen 有画刷属性，QPainter 对象也画刷属性（下面章节会介绍），二者都有填充之意，QPen 的画刷是用来填充画笔所画的线条（可以理解为画笔的颜料）的，而QPainter 的画刷是用来填充画笔所画的轮廓区域的，如填充矩形里面的区域。 画刷可以是纯色、渐变色，也可以是图片。 2.3 线条样式1void QPen::setStyle(Qt::PenStyle style) 2.4 起落笔样式1void QPen::setCapStyle(Qt::PenCapStyle style) 2.5 拐点样式1void QPen::setJoinStyle(Qt::PenJoinStyle style) 2.6 实例下面示例指定了画笔的如下属性： 画笔的宽度为 70px 使用红色画刷 线条样式为通过若干空格分割的点线状 线条起笔和落笔处为圆形 线条拐点处也为圆形 1234567891011121314151617void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); QPen pen; pen.setWidth(70); pen.setBrush(Qt::red); pen.setStyle(Qt::DotLine); pen.setCapStyle(Qt::RoundCap); pen.setJoinStyle(Qt::RoundJoin); painter.setPen(pen); painter.drawLine(50, 50, 600, 50); painter.drawLine(600, 50, 600, 600);} 实际绘制出来的效果如下图所示： 上面画笔使用红色作为颜料，也可以使用渐变色作为颜料，当然还可以使用图片作为颜料。 下面我们将颜料更改为一个红色的心形♥图片： 123456789101112131415161718void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); QPen pen; pen.setWidth(70); pen.setBrush(QImage(\":/heart.png\")); // 仅修改了此行代码 ~~~~~~~~~~~~~~ pen.setStyle(Qt::DotLine); pen.setCapStyle(Qt::RoundCap); pen.setJoinStyle(Qt::RoundJoin); painter.setPen(pen); painter.drawLine(50, 50, 600, 50); painter.drawLine(600, 50, 600, 600);} 绘制的效果如下： 三、QBrushQPen 与 QPainter 都有画刷属性，这里的 QBrush 是指的 QPainter 的画刷。虽然与 QPen 的画刷都为 QBrush 类型，但二者是有区别的，QPen 的画刷是用来填充画笔所画线条（可以理解为画笔的颜料）的，而 QPainter 的画刷是用来填充画笔所画的轮廓所包围的区域，如填充矩形里面的区域。 如下面示例： 12345678910111213void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); QPen pen; pen.setWidth(6); pen.setBrush(Qt::red); painter.setPen(pen); painter.setBrush(Qt::blue); painter.drawRect(50, 50, 200, 200);} 实际绘制的矩形如下图所示： QBrush 有样式（Style）、颜色（Color）、渐变色（Gradient）、纹理图片（Texture）等属性。 3.1 样式画刷的作用是填充区域，画刷的样式则是用来指定通过什么模式来填充区域的。 下图列出了 QBrush 支持的样式： QBrush的初始样式是 Qt::NoBrush，即不做填充操作，该值显然是没有任何意义的，下面是一个错误的使用示例； 123// 错误示例QBrush brush;brush.setColor(Qt::red); // 画刷仍然是 Qt::NoBrush样式，不会填充任何颜色 我们可以通过构造函数和 setStyle 方法来设置样式： 123QBrush(Qt::BrushStyle style)void setStyle(Qt::BrushStyle style) 当通过不同的方式构造 QBrush 对象时，QBrush 的样式也会自动被设置为不同的值： 12345678// 样式自动被设置为渐变样式：Qt::LinearGradientPattern, Qt::RadialGradientPattern 或 Qt::ConicalGradientPatternQBrush(const QGradient &amp;gradient) // 样式自动被设置为纹理样式Qt::TexturePatternQBrush(const QImage &amp;image) QBrush(const QPixmap &amp;pixmap)QBrush(Qt::GlobalColor color, const QPixmap &amp;pixmap)QBrush(const QColor &amp;color, const QPixmap &amp;pixmap) 3.2 纹理图片上面2.6节的实例中，在设置心形图片作为QPen的画刷时，使用的就是纹理图片。 下面汇总了设置 QBrush 纹理图片的几种方法： 123456789// 通过构造函数QBrush(const QImage &amp;image)QBrush(const QPixmap &amp;pixmap)QBrush(Qt::GlobalColor color, const QPixmap &amp;pixmap)QBrush(const QColor &amp;color, const QPixmap &amp;pixmap)// 通过成员方法void setTexture(const QPixmap &amp;pixmap)void setTextureImage(const QImage &amp;image) 通过上面方式设置纹理图片后，QBrush 样式会被自动修改为 Qt::TexturePattern，因为纹理图片只能与 Qt::TexturePattern 样式配合使用，否则纹理图片将失效。 3.3 纯色可以为画刷指定纯色或渐变色，纯色使用 QColor 对象表示。 常用的构造 QColor 对象的方式有如下几种： 1234QColor(\"#FFFFFF\"); // r g bQColor(\"#AAFFFFFF\"); // a r g bQColor(255, 255, 255, 255); // r g b aQColor(Qt::red); // Qt::GlobalColor 枚举值 3.4 渐变色QBrush 只提供了一种方式来指定渐变色： 1QBrush(const QGradient &amp;gradient) 在Qt中，渐变色使用 QGradient 及其子类表示，目前Qt支持三种类型的渐变： 线性渐变，对应 QLinearGradient 类。 锥形渐变，对应 QConicalGradient 类。 径向渐变，又分为简单径向渐变和扩展径向渐变，二者都对应 QRadialGradient 类。 下图是一个从左到右，由白到黑的渐变过程： 填充方向既然可以从左到右、从右到左的、从里到外，是可以360度旋转等等，不同的填充方向造就了不同类型的渐变，上述三种类型的渐变主要区别也在填充方向的不同。 3.4.1 线性渐变QLinearGradient 构造函数如下： 12QLinearGradient(qreal x1, qreal y1, qreal x2, qreal y2)QLinearGradient(const QPointF &amp;start, const QPointF &amp;finalStop) 通过指定一个起点和一个终点就可以确定一条线段的长度及方向，这个方向就是填充方向，渐变范围基于该长度而确定（详见后面的“渐变范围”章节）。 线性渐变的方向可以是水平的，也可以是垂直的，还可以是斜着的，具体方向由线段与X轴的夹角来决定。 下面我们定义一个起点为(0,0)、终点为(0,400)，垂直方向的线性渐变，然后使用该渐变填充位置在 (0,0)，宽高为 200x400 的矩形（请注意矩形的位置和大小，这个与渐变的起止位置有关，后面会详细介绍）： 1234567891011121314void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); QLinearGradient linearGrad(QPointF(0, 0), QPointF(0, 400)); linearGrad.setColorAt(0, Qt::black); linearGrad.setColorAt(1, Qt::white); QBrush brush(linearGrad); painter.setBrush(brush); painter.drawRect(0, 0, 200, 400);} 效果如下图所示： 由于是垂直方面的渐变，所以渐变色从上到下变化的，颜色起始于黑色，终止于白色。 渐变色的起止颜色由setColorAt方法设置，该方法原型如下： 1void QGradient::setColorAt(qreal position, const QColor &amp;color) setColorAt 不仅接受颜色参数，还支持 postion 参数，position 参数的范围是[0,1]。线性渐变通过起止位置确定了一条带方向的线段，而 position 参数则用于确定线段上的一个具体位置，结合position和color参数就可以表示在某一位置的颜色值。 可以使用 setColorAt 方法指定多个在[0,1]之间的位置及该位置的颜色，Qt会自动在多个颜色之间插入过渡色，达到平滑过渡的效果。 现在我们在 0.3 位置插入一个骚气的红色，0.5位置插入黄色，其他都保持不变： 1234linearGrad.setColorAt(0, Qt::black);linearGrad.setColorAt(0.3, Qt::red);linearGrad.setColorAt(0.8, Qt::yellow);linearGrad.setColorAt(1, Qt::white); 效果如下图所示： 3.4.2 渐变范围在上面一节，我们强调了所绘制的矩形的位置/大小与渐变的起止位置有关，而且又强调了 position 参数所确定是线段上的具体位置。其根本原因就在于渐变是有位置和范围的。 对于线性渐变而言，渐变的范围是起始点和终止点间的线段，但颜色在垂直于该线段的方向却是无限扩充的，下面示例可以很好的说明这一特性。 123456789101112131415161718// Qt2DSample窗口长宽为600x600void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); QLinearGradient linearGrad(QPointF(150, 150), QPointF(450, 450)); linearGrad.setColorAt(0, Qt::yellow); linearGrad.setColorAt(0.5, Qt::red); linearGrad.setColorAt(1, Qt::white); QBrush brush(linearGrad); painter.setBrush(brush); painter.drawRect(0, 0, 600, 600); // 不使用画刷，绘制 左上角 -&gt; 右下角 为线性渐变起止点的矩形 painter.setBrush(Qt::NoBrush); painter.drawRect(150, 150, 300, 300);} 效果如下图所示： 从上图可以看到，渐变色在垂直于渐变线段（中间矩形的左上角和右下角连成的斜线）方向无限扩展，但为什么在渐变范围边界以外还有颜色呢？如左上角的黄色和右下角的白色，这个与渐变的另一个属性特性有关 – 渐变传播，后面章节有详细介绍。 3.4.3 锥向渐变QConicalGradient 类的构造函数如下： 12QConicalGradient(qreal cx, qreal cy, qreal angle)QConicalGradient(const QPointF &amp;center, qreal angle) 锥向渐变通过中心点（center）和起始角度来（angle）来所连接的直线确定填充的初始方向，然后从该直线开始逆时针进行360度填充，而且每个角度的颜色都是无限向外传播的。 1234567891011121314151617// Qt2DSample窗口长宽为200x200void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); // 设定中心点刚好在窗口中心，起始角度为45度 QConicalGradient conicalGrad(QPointF(100, 100), 45); conicalGrad.setColorAt(0, Qt::yellow); conicalGrad.setColorAt(0.5, Qt::red); conicalGrad.setColorAt(1, Qt::white); QBrush brush(conicalGrad); painter.setBrush(brush); // 绘制的矩形区域为整个窗口大小 painter.drawRect(0, 0, 200, 200);} 效果如下图所示，渐变色从45度开始渐变，并且每个角度都无限向外传播，填充满了整个矩形： 3.4.5 径向渐变径向渐变分为简单径向渐变和扩展径向渐变，在介绍二者的不同之前，我们先看看QRadialGradient 类的构造函数可以大致分为以下三类： 12345678// 指定中心点、半径、焦点位置、焦半径QRadialGradient(const QPointF &amp;center, qreal centerRadius, const QPointF &amp;focalPoint, qreal focalRadius)// 仅指定中心点、半径，此时焦点位置与中心点重合QRadialGradient(const QPointF &amp;center, qreal radius)// 指定中心点、半径、焦点位置QRadialGradient(const QPointF &amp;center, qreal radius, const QPointF &amp;focalPoint) 中心点（center）和半径（centerRadius）组成了一个圆，记为圆A，径向渐变的范围只限于圆A以内，圆A以外的区域按照指定的渐变传播方式进行传播； 焦点（focalPoint）为平面上的的一个点，简单径向渐变和扩展径向渐变对焦点的位置有不同的要求，这个区别在后面会介绍； 焦半径（focalRadius）则是围绕焦点所作的另外一个圆（记为圆B）的半径。 扩展径向渐变是在简单径向渐变的基础上额外使用了 focalRadius（焦点半径）这个参数。 简单径向渐变焦点和圆A圆弧上的每一个点都可以组成一条线段，如果按照1度取一个点，就有360个线段，简单径向渐变就是对这360个线段都进行线性渐变。 对于简单径向渐变而言，允许焦点位于圆弧上和圆外，如果焦点位于圆外，会自动将其退缩到圆弧上。 下面是一个简单径向渐变的例子： 123456789101112131415// Qt2DSample窗口长宽为600x600void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); // 焦点位于圆内右上角部分 QRadialGradient radialGrad(QPointF(300, 300), 200, QPointF(400, 200)); radialGrad.setColorAt(0, Qt::white); radialGrad.setColorAt(1, Qt::black); QBrush brush(radialGrad); painter.setBrush(brush); painter.drawRect(0, 0, 600, 600);} 效果如下图所示，径向渐变的范围只限于圆内，圆外的区域默认采用PadSpread方式传播： 扩展径向渐变扩展径向渐变使用焦点和焦半径又组成了一个圆B，与简单径向渐变类似，也是通过对圆A圆弧上的每个点的连线做线性渐变来实现，但这次不是焦点与圆A圆弧上的点进行连线，而是“圆B圆弧上的点”与“圆A圆弧上的点”的连线，对这些连线做线性渐变。 圆B始终填充起始颜色。 与简单径向渐变不同的是，圆B必须完全在圆A里面。 下面是一个扩展径向渐变的例子： 123456789101112131415// Qt2DSample窗口长宽为600x600void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); // 焦点位于圆内右上角部分，焦半径为30 QRadialGradient radialGrad(QPointF(300, 300), 200, QPointF(400, 200), 30); radialGrad.setColorAt(0, Qt::white); radialGrad.setColorAt(1, Qt::black); QBrush brush(radialGrad); painter.setBrush(brush); painter.drawRect(0, 0, 600, 600);} 效果如下图所示： 3.4.6 渐变传播在Qt中通过 setSpread 方法设置渐变传播方式： 1void QGradient::setSpread(QGradient::Spread method) QGradient::Spread枚举定义了三种传播方式： QGradient::PadSpread QGradient::RepeatSpread QGradient::ReflectSpread 默认为传播方式为 QGradient::PadSpread，而且由锥向渐变的行为可知，锥向渐变是没有渐变传播一说的，因此它始终都是360度渐变。 下图形象说明了三种传播方式的差异： PadSpread 方式延续了起点与终点处各自的颜色，无限传播 RepeatSpread 方式不断重复渐变边界内的这一颜色的渐变模式 ReflectSpread 方式将渐变边界内的模式不断往外镜像反射 3.4.7 渐变主题设计一个漂亮的渐变色并非易事，Qt提供了内置的渐变主题(Preset)，这些主题通过 QGradient::Preset 枚举类型提供（该枚举从 Qt 5.12 开始引入）。 从Qt官方文档得知，QGradient::Preset预置渐变主题方案是基于https://webgradients.com/实现的。 QGradient 类支持通过QGradient::Preset 枚举类型直接构造： 1QGradient::QGradient(QGradient::Preset preset) 下面是使用QGradient::Preset的示例： 1234567891011void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); QGradient grad(QGradient::HealthyWater); QBrush brush(grad); painter.setBrush(brush); painter.drawRect(0, 0, 600, 600);} 3.4.8 网站推荐下面几个网站也提供了漂亮的渐变色方案，可以用作参考： grabient.com uigradients.com webgradients.com 限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺 您可以通过在 blog-comment 项目中提交Issue来间接地发表评论🍀","tags":["Qt"],"categories":["Qt"]},{"title":"玩转Qt 2D绘图之坐标系","path":"/post/847642761.html","content":"Qt中提供了强大的 2D 绘图系统，可以使用相同的API在屏幕和绘图设备上进行绘制，主要基于 QPainter、QPaintDevice和 QPaintEngine 这三个类实现，其中： QPainter执行具体的绘图操作，QPainter 类提供了大量的GUI编程所需的函数，如drawLine、drawImage等。 QPaintDevice 是一个基类，提供绘图设备的抽象接口，它是一个二维空间的抽象，可以使用QPainter在其上进行绘制，常见的继承该类的绘图设备有QImage、QPixmap、QWidget、QOpenGLPaintDevice等。 QPaintEngine 提供了一些抽象接口，用于实现QPainter在不同的设备上进行绘制。QPaintEngine 由 QPaintDevice 创建并管理。 在Qt官方文档中有一张图可以很好说明Qt各个坐标系变换方式（暂不用关注图上的坐标值）： 我们在使用QPainter绘图时需要传入元素坐标，传入的坐标就是图上的世界坐标系（World Coordinates），世界坐标经过矩阵变换（这一步是可选的）后再传递给窗口坐标系（Window Coordinates），窗口坐标系上的元素的坐标还需经过窗口到视口的坐标变换（线性变换），最后在设备坐标系（Device Coordinates）的视口区域内绘制。 1. 世界坐标系世界坐标系也称之为逻辑坐标系，使用的单位叫逻辑单位。 在真实的世界地理中，我们通常使用经纬度来表示某一个具体位置，如武汉的坐标为(东经114°,北纬30°)，而在Qt绘图时使用的逻辑单位是像素。 Qt的像素支持非整数数量，如 0.5 个像素，而实际设备（如显示器、打印机等）只支持整数数量的像素显示，因此从逻辑坐标到设备坐标需要经过相应的转换过程。 在Qt中，我们提供给 QPainter 的都是逻辑坐标，这种坐标与具体的设备类型无关。 2. 窗口坐标系上图中的窗口是打了引号的，这说明该窗口是实际不存在的，这个窗口指的是窗口坐标系左上角原点到右下角的一个虚拟矩形窗口。 默认情况下，窗口坐标系和逻辑坐标系都等同于设备坐标系，三者重合，但我们可以使用QPaintet::setWindow方法重设窗口坐标系的原点和范围，有了左上角原点和长/宽，也就得到一个新的“窗口”。 在绘图时传递给 QPainter 的逻辑坐标需要先经过矩阵变换（常见的矩阵变换有QPainter 的 translate、scale、rotate、shear等方法，后面章节会介绍），然后再传递给窗口坐标系。 3. 设备坐标系也称之为物理坐标（Physical Coordinates），坐标原点位于左上角，X轴水平向右增长，Y轴垂直向下增长。 不同的设备坐标单位通常不同，如显示器通常以像素为单位，而打印机通常以点为单位。 需要注意的是设备坐标系的原点和范围始终等同于实际绘制设备，不会跟随逻辑坐标系、窗口坐标系以及视口（viewport）的改变而改变。 4. 视口视口（viewport）是设备环境中的一个矩形框，使用设备坐标系表示。默认情况下，视口左上角位置为设备坐标系的原点，大小为实际绘制目标设备的大小。 视口存在的意义是为了指定在显示设备的什么位置，以多大的范围来完全显示指定的窗口内容，如果窗口内容超出了视口区域，超出部分将不会显示。 我们可以用 QPainter::setViewport 方法来改变视口的位置和大小，QPainter::setViewport 的参数都是基于设备坐标系的，如果指定的视口区域超出了设备外，设备外的内容将不会显示。 5. 实例讲解为了更好说明各个坐标系及视口之间的关系，我们通过一个实例来具体说明。首先创建一个长宽为400x400的窗口，并且程序未开启DPI缩放特性： 1resize(400, 400); 绘制代码如下： 1234567void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.translate(100, 200); painter.setWindow(QRect(200, 300, 600, 600)); painter.setViewport(QRect(100, 100, 300, 300)); painter.drawRect(QRect(300, 100, 200, 200));} 下图使用不同的颜色绘制了不同的坐标系及视口、窗口的位置和区域： 第1行代码QPainter painter(this)： 表明我们是在当前 QWidget 实例上进行绘制，因此设备坐标系原点为(0,0)，坐标系的范围为QWidget的长宽400x400，坐标单位为像素，对应上图绿色部分。 此时还未设置视口，因此视口默认等同于设备坐标系的范围，即(0,0,400,400)，该部分未在上图画出。 第2行代码painter.translate(100, 200): 将逻辑坐标系的原点偏移(100,200)个像素。 在进行偏移时，值为正表示向方向移动，值为负表示向负方向移动。 第3行代码painter.setWindow(QRect(200, 300, 600, 600))： 设置窗口坐标系原点为(200, 300)，窗口范围是600x600，对应上图红色部分。 第4行代码painter.setViewport(QRect(100, 100, 300, 300))： 设置视口为QRect(100, 100, 300, 300)，即在设备坐标系上的使用QRect(100, 100, 300, 300)区域来显示上面600x600的窗口，对应上图蓝色部分。 第2、3、4行代码是没有先后顺序的，因为三个设置函数所影响的目标是不同的。 第5行代码painter.drawRect(QRect(300, 100, 200, 200))： 在 (300,100) 位置绘制 200x200 的正方形，此处传递的是逻辑坐标，而逻辑坐标系已在第2行代码处进行了偏移，因此根据新的逻辑坐标系，正方形左上角位置是 (300+100, 100+200) = (400, 300)，又因为此处逻辑坐标系未做缩放操作（缩放操作由 QPainter::scale 提供），因此正方形的长宽保持不变，仍为200x200，即 QRect(400,300,200,200)。 然后将正方形 QRect(400,300,200,200) 传递给窗口坐标系，该正方形在窗口坐标系 (200,300,600,600) 上面的位置和大小对应上图粉红色部分。 最后用设备坐标系上的视口区域来显示该窗口，由于窗口坐标系和设备坐标系的原点及范围不相同，因此还需要做线性转化： 12345在(200, 300, 600, 600) 范围上显示的正方形 (400, 300, 200, 200)转化为在视口(100, 100, 300, 300) 范围上显示的正方形 (x, y, w, h) 从上面可以看出窗口范围是视口的600 / 300 = 2倍，因此在视口上的原点和长宽分别为： 1234567x = 100 + (400 - 200) / 2 = 200y = 100 + (300 - 300) / 2 = 100w = 200 / 2 = 100h = 200 / 2 = 100 计算得到需要在视口 (100, 100, 300, 300) 上绘制的正方形为 (200,100,100,100) ，实际绘制的正方形如下图所示： 6. 移动原点到窗口中央默认情况下，坐标原点在窗口的左上角，X轴水平向右增长，Y轴垂直向下增长。现在将坐标原点移动到窗口中央，但不改变X轴和Y轴的方向。 123456789101112131415161718// Qt2DSample窗口长宽为400x400void Qt2DSample::paintEvent(QPaintEvent* e) { QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing); const int w = width(); const int h = height(); // 将坐标原点移动到窗口中央 painter.translate(w / 2.0, h / 2.0); // 也可以使用下面的方式： // painter.setWindow(w / 2.0, h / 2.0, w, h); // painter.translate(w, h); // 绘制测试矩形 painter.drawRect(QRect(0, 0, 100, 100));} 实际绘制的矩形在窗口中的位置如下图所示： 7. QRect遗留问题在介绍 QRect 的遗留问题之前，我们需要先了解Qt中锯齿与抗锯齿的相关内容。 7.1 抗锯齿下图展示了在绘制一条斜线时，未开启抗锯齿（左边）和开启了抗锯齿后（右边）两者的效果。 抗锯齿就是绘图引擎通过在元素的边缘填充不同的颜色来实现平滑边缘的效果。 Qt默认绘图的元素是有锯齿的，当使用1像素宽的画笔绘制时，实际像素将渲染到我们定义坐标的右下方，如下图所示： 当画笔宽度为偶数时，像素将围绕定义坐标进行对称渲染，如下图所示： 当画笔宽度为奇数时，整除后多余的1像素将渲染到定义坐标的右下方，如下图所示： 7.2 QRect实际宽高基于上述原因，QRect::right() 和 QRect::bottom() 的值并不等于矩形真正右下角的坐标。 1234567891011121314QRect::QRect(int aleft, int atop, int awidth, int aheight) noexcept : x1(aleft), y1(atop), x2(aleft + awidth - 1), y2(atop + aheight - 1) {}void QRect::setWidth(int w) noexcept{ x2 = (x1 + w - 1); }void QRect::setHeight(int h) noexcept{ y2 = (y1 + h - 1); }int QRect::width() const noexcept{ return x2 - x1 + 1; }int QRect::height() const noexcept{ return y2 - y1 + 1; } 从上面 QRect 的源码可知，QRect::width() 和 QRect::height() 方法返回的是矩形的实际宽高，但 QRect::right() 和 QRect::bottom() 方法返回的不是矩形的实际右边和底部： 123QRect::right() 返回的实际是 QRect::left() + QRect::width() - 1QRect::bottom() 返回的实际是 QRect::top() + QRect::height() - 1 这属于QRect的历史遗留问题，Qt为了兼容之前老的代码，对该部分未作修改，我们可以使用下面方式获取QRect真实的宽和高： 123QRect::x() + QRect::width()QRect::y() + QRect::height() 也可以使用 QRectF类型来代替 QRect 类型，QRectF类型没有上述问题。 7.3 开启抗锯齿在Qt中开启抗锯齿也非常简单，下面代码开启了抗锯齿： 1234painter.setRenderHints( QPainter::Antialiasing | // 消除基础元素（如线、点）边缘的锯齿 QPainter::TextAntialiasing // 消除文字边缘的锯齿); 开启抗锯齿以后，像素将始终围绕定义坐标进行对称渲染，并且会自动在边缘填充颜色来平滑边缘，如下图所示： 8. 逻辑坐标矩阵变换Qt 提供了方法来直接对世界坐标（也可称为逻辑坐标）进行矩阵变换： 1void QPainter::setWorldTransform(const QTransform &amp;matrix, bool combine = false) 还提供方法来开启和关闭世界坐标的矩阵变换操作： 1void QPainter::setWorldMatrixEnabled(bool enable) 同时 QPainter 还是提供了 translate、scale、rotate、shear 等快捷方法实现对逻辑坐标的矩阵变换操作。 需要注意的是在调用了translate、scale、rotate、shear方法后，QPainter 会自动开启对世界坐标的矩阵转换。 为了更好的介绍是逻辑坐标的转化过程，现在假设在坐标变换之前存在 点A(x, y) 和 矩形B(x, y, w, h) 8.1 translate123void QPainter::translate(const QPointF &amp;offset)void QPainter::translate(const QPoint &amp;offset)void QPainter::translate(qreal dx, qreal dy) X和Y轴分别平移距离 m 和 n，平移后，点A的坐标为(x + m, y + n)，矩形B的坐标为(x + m, y + n, w, h) m 和 n 可以为负数。 8.2 scale1void QPainter::scale(qreal sx, qreal sy) X和Y轴分别缩放 m 和 n 倍 ，缩放后，点A的坐标为(x * m, y * n)，矩形B的坐标为 (x * m, y * n, w * m, h * n) m 和 n 可以为负数，如： 点A(50,100) -&gt; scale(-10, 2) -&gt; (-500,200) 点A(-50,100) -&gt; scale(-10, 2) -&gt; (500,200) 8.3 rotate1void QPainter::rotate(qreal angle) 按顺时针将X和Y轴同时旋转angle度（注意angle参数的单位是度，而不是弧度），其中0度为正三点钟方向。 rotate 是顺时针旋转，而使用 QPainter::drawArc 等方法绘制圆弧或扇形时，是按逆时针方向绘制的。 对于单个点进行旋转是没有意义的， 8.4 shear1void QPainter::shear(qreal sh, qreal sv) 对X和Y轴分别进行扭曲变换。 限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺 您可以通过在 blog-comment 项目中提交Issue来间接地发表评论🍀","tags":["Qt"],"categories":["Qt"]},{"title":"回顾2D绘图的数学知识","path":"/post/66759332.html","content":"本篇旨在帮助开发人员回顾在2D图形编程中可能会涉及到的数学知识。 1. 矩形矩形面积 长宽 矩形周长 长宽 2. 两点间的距离在直角坐标系中，设两个点A、B以及坐标分别为 、 ，则A和B两点之间的距离为： 3. 圆通常使用表示圆的半径； 圆的面积 圆的周长 当圆心坐标为(0，0)时，圆的方程式为： ，表示的曲线是以O(0，0)为圆心，以r为半径的圆。 当圆心坐标不为(0，0)时，圆的方程式为： 表示的曲线是以O(a，b)为圆心，以r为半径的圆。 4. 弧度与角度弧度是基于圆的半径的纯计量单位，当角度以弧度给出时，通常不写弧度单位，或有时记为rad。 弧度是指在一个圆中，弧长和半径之比，即：弧度弧长半径。 我们知道，一个圆的周长为 ，所以可得一个圆的弧度为 已知一个圆的角度是，所以 由此可知二者转换关系为： 5. 三角形若三角形的三边分别为a，b，c，其中c为底边，高为h，三角分别为A（），B（），C（），如下图所示，在△ABC中 面积 周长 三角形的三个角相加永远是 ，即 ，因此等边三角形的每个角都是 5.1 正弦/余弦/正切正弦、余弦和正切是基于直角三角形而建立的。 对边斜边 邻边斜边 对边邻边 邻边对边 5.2 余弦定理对于任意三角形，任何一边的平方等于其他两边平方的和减去这两边与它们夹角的余弦的积的两倍。 5.3 勾股定理直角三角形的两条直角边的长度的平方和等于斜边长的平方。 已知 ，结合余弦定理，可以知道勾股定理是余弦定理的特定情况。 6. 正弦曲线水平方向和垂直方向同时做正弦运动，就得到了圆周运动。 下面视频展示了从圆中分解出正弦曲线的过程： (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"video\":{\"url\":\"https://blog-static.jiangxueqiao.com/blog/img/sin-graph.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 标准的正弦曲线函数是 ，下图是一个标准的正弦曲线： 与正弦曲线相关的概念有： 6.1 周期周期：从一个顶点到另一个顶点的距离，标准正弦曲线的周期是 6.2 振幅振幅：从中线（X轴）到顶点的距离，如上图所示。 6.3 相移相移：曲线的左右平移，如下图所示。 6.4 垂直位移垂直位移：曲线的上下平移，如下图所示。 6.5 伸缩变换下图分别绘制了、、的图像。 从上图可知， 所乘以的系数对应曲线周期缩小的倍数。 6.6 平移变换正弦曲线的平移变换遵循“左加右减，上加下减”的规则。 实例下图展示了从 变换到 的过程。 6.7 综合变换正弦曲线可表示为 下图演示了从 变换到 的过程。 6.8 三角函数的值域和公式6.8.1 常用公式 6.8.2 值域 和 值域为 [-1, 1] 和 值域为整个实数集 7. 椭圆椭圆（Ellipse）是平面内到定点F1、F2的距离之和等于常数（大于）的动点P的轨迹，F1、F2称为椭圆的两个焦点。 其数学表达式为： 两焦点F1、F2的距离 7.1 椭圆方程式我们始终用表示长半轴，用表示短半轴，即上图的焦点在X轴时，位于X轴，若焦点在Y轴则位于Y轴。 当两个焦点在X轴时，标准方程为： 当两个焦点在Y轴时，标准方程为： 7.2 椭圆面积椭圆面积 7.3 相关公式 证明如下： 由两点间的距离公式可得： 又因为，即： 表达式化简后： 继续展开和化简，最终可得： 参考椭圆的公式可得： 7.4 椭圆上任意角度点的坐标 上图焦点位于X轴，由椭圆方程式可得： 由正切函数可得： 将 代入上面表达式可得： 最终求得： 可以为正/负值，需要根据角度决定正负。 本文使用latexlive生成数学公式。 限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺 您可以通过在 blog-comment 项目中提交Issue来间接地发表评论🍀","tags":["数学","椭圆"],"categories":["编程基础"]},{"title":"如何通过结构体成员地址获取父地址","path":"/post/3142528002.html","content":"有如下结构体： 12345678struct Test &#123; int a; // .... // 还有若干成员 // ... int y; int z;&#125;; 在只知道成员变量y地址的情况下，如何获取到结构体的首地址？ 可以通过如下宏来实现： 123#define GET_PARENT_ADDRESS(address, type, field) ((type *)( \\ (char*)(address) - \\ (ULONG_PTR)(&amp;((type *)0)-&gt;field))) 使用方法如下： 123456789int main()&#123; Test t = &#123; 1, 2, 3 &#125;; Test* pT = GET_PARENT_ADDRESS(&amp;t.b, Test, b); printf(&quot;a:%d b:%d c:%d &quot;, pT-&gt;a, pT-&gt;b, pT-&gt;c); // 输出a: 1 b:2 c:3 return 0;&#125; 核心原理： 通过将空指针强转成 Test* 类型, 然后再取成员变量b的地址，该操作的作用是：假设 Test 开始在 0x00000000 内存位置上分配内存，并在此基础上得b的内存地址，这样等同于获得了成员 b 的结构体对齐后偏移量。 最后，用 b 的实际内存地址减去b的偏移量就是结构体的首地址。 参考：Microsoft 完成端口CONTAINING_RECORD宏的实现。 本文最初发布在我的CSDN博客：《CONTAINING_RECORD宏的实现原理》，在此基础上稍作整理。 限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺 您可以通过在 blog-comment 项目中提交Issue来间接地发表评论🍀","tags":["C++"],"categories":["C++语言"]},{"title":"不同操作系统所集成的字体","path":"/post/1759569674.html","content":"如果界面所指定的字体在用户系统上未安装，则会自动降级到系统默认字体，这样会导致界面显示异常或达不到预期效果。 对于特殊字体我们通常会集成到软件安装包内，但对于汉字这样的语言，它的文字比较多，因此字体文件比较大，如果集成到安装包内会导致安装包体积变大，所以对于类似中文这样字符比较多的语言字体，我们通常会选择系统自带的字体。 而不同操作系统（如Windows和macOS）所自带的字体不一样，甚至同一操作系统不同的版本（如Windows 7和Windows 11）自带的字体也不一样，因此在选择采用什么字体前，需要弄清我们应用程序支持的操作系统所自带的字体都有哪些，才能更好的做选择。 操作系统的新版本通常只会新增字体，不会移除老的字体。 Windows系统见维基百科： List_of_typefaces_included_with_Microsoft_Windows macOS和iOS系统见apple官网： system-fonts 中文字体的英文名称对照表macOS系统部分字体 中文名 英文名 华文细黑 STHeiti Light 华文黑体 STHeiti 华文楷体 STKaiti 华文宋体 STSong 华文仿宋 STFangsong 俪黑 Pro LiHei Pro Medium 俪宋 Pro LiSong Pro Light 标楷体 BiauKai 苹果俪中黑 Apple LiGothic Medium 苹果俪细宋 Apple LiSung Light Windows系统部分字体 中文名 英文名 新细明体 PMingLiU 细明体 MingLiU 标楷体 DFKai-SB 黑体 SimHei 宋体 SimSun 新宋体 NSimSun 仿宋 FangSong 楷体 KaiTi 仿宋_GB2312 FangSong_GB2312 楷体_GB2312 KaiTi_GB2312 微软正黑体 Microsoft JhengHei 微软雅黑体 Microsoft YaHei 隶书 LiSu 幼圆 YouYuan 华文细黑 STXihei 华文楷体 STKaiti 华文宋体 STSong 华文中宋 STZhongsong 华文仿宋 STFangsong 方正舒体 FZShuTi 方正姚体 FZYaoti 华文彩云 STCaiyun 华文琥珀 STHupo 华文隶书 STLiti 华文行楷 STXingkai 华文新魏 STXinwei 限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺 您可以通过在 blog-comment 项目中提交Issue来间接地发表评论🍀","tags":["字体"],"categories":["编程基础"]},{"title":"基于共享内存的跨平台RPC框架 - Veigar","path":"/post/3008752839.html","content":"1. 背景在项目开发中时常会遇到需要多个进程间交互&#x2F;通信的场景，进程间通信（IPC）的方式有很多，比如文件、注册表、网络、管道、共享内存等。 对于简单的交互场景，我们可以随意选择一种合适的方式，如 Google Chrome 使用的是管道的方式。 但在交互场景复杂的情况下，远程过程调用（RPC）的方式则会更新便捷。 目前开源的、功能相对完善的 C++ RPC 框架都是基于网络方式实现的，这种方式存在服务端和客户端的概念，两端相互调用需要各方都启动一个端口监听服务，既然需要监听端口，那就会存在端口被占用的问题，特别是在 Windows 上还会存在端口假可用的问题，端口虽然监听成功，但客户端仍然无法连接的情况。 我一直想找到一个基于共享内存实现的、跨平台的 C++ RPC 框架，但遗憾的是一直没能结缘，于是我决定烹饪一个。 之所以取名为“Veigar”，因为该词来源于英雄联盟里面的“邪恶小法师-维迦”，我的开源项目取名也大多来自该游戏。 项目地址： https://github.com/winsoft666/veigar 目前该项目已经在多个 Windows 客户端产品中得到应用，Linux 平台也经过了测试。 2. 特性 基于共享内存技术实现。 支持 Windows、Linux 平台。 可以将任何函数暴露给调用方（不限语言，只要实现 msgpack-rpc 即可）。 任何语言编写的程序都可以调用被暴露的函数。 不需要学习 IDL 语言。 不需要添加额外的代码生成步骤，仅需要 C++ 代码。 没有服务端和客户端的概念，每个 Veigar 实例间都可以相互调用。 没有网络问题，如端口占用、半关闭状态等。 没有诡异的端口假可用性问题（特别是在 Windows 系统上）。 3. 编译虽然Veigar的底层是基于msgpack实现的，但已经将其包含到项目中，不需要额外编译和安装msgpack。 虽然在veigar公共头文件引用了msgpack头文件，但这不会污染您的全局msgpack命名空间，因为Veigar中的msgpack命令空间为veigar_msgpack。 Veigar仅支持编译为静态库。 可以使用CMake进行编译构建，也可以使用vcpkg进行安装，如： 1vcpkg install veigar 4. 快速上手在使用Veigar时，仅需要在项目中包含include目录，并链接静态库即可。 4.1 同步调用下面是一个同步调用的示例： 本示例为了使代码更加简洁，没有对函数返回值进行校验，请在实际使用中不要这样做！ 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &quot;veigar/veigar.h&quot;int main(int argc, char** argv) &#123; if (argc != 3) &#123; return 1; &#125; std::string channelName = argv[1]; std::string targetChannelName = argv[2]; veigar::Veigar vg; vg.bind(&quot;echo&quot;, [](const std::string&amp; msg, int i, double d, std::vector&lt;uint8_t&gt; buf) &#123; std::string result; // ... return result; &#125;); vg.init(channelName); std::vector&lt;uint8_t&gt; buf; veigar::CallResult ret = vg.syncCall(targetChannelName, 100, &quot;echo&quot;, &quot;hello&quot;, 12, 3.14, buf); if (ret.isSuccess()) &#123; std::cout &lt;&lt; ret.obj.get().as&lt;std::string&gt;() &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; ret.errorMessage &lt;&lt; std::endl; &#125; vg.uninit(); return 0;&#125; 每个Veigar实例有一个在本机范围内唯一的通道名称（Channel），在调用init函数时需要为Veigar指定通道名称，Veigar不会检测通道的唯一性，需要由调用者来保证通道名称的唯一性。 在上述示例中，需要通过命令行参数指定当前实例的通道名称和目标实例的通道名称，如： 1sample.exe myself other 每个实例都绑定了名为echo的函数，该函数简单的原样返回msg参数字符串。 通过为syncCall函数指定“目标通道名称”、“函数名称”、“函数参数”及“超时毫秒数”就可以同步调用目标函数并得到调用结果。 4.2 拒绝异常我不喜欢异常，因此Veigar也不会通过异常的形式来抛出错误，Veigar会主动捕获所有C++标准库、msgpack、boost异常，以返回值的形式返回给调用者。当调用失败时（!ret.isSuccess())，errorMessage中存储的错误信息就可能是Veigar捕获的异常信息。 4.3 返回Promise的异步调用使用asyncCall函数可以实现异步调用。 下面是返回Promise的异步调用示例： 1234567891011121314151617181920212223242526//// 与同步调用相同// ...std::vector&lt;uint8_t&gt; buf;std::shared_ptr&lt;veigar::AsyncCallResult&gt; acr = vg.asyncCall(targetChannelName, &quot;echo&quot;, &quot;hello&quot;, 12, 3.14, buf);if (acr-&gt;second.valid()) &#123; auto waitResult = acr-&gt;second.wait_for(std::chrono::milliseconds(100)); if (waitResult == std::future_status::timeout) &#123; // timeout &#125; else &#123; veigar::CallResult ret = std::move(acr-&gt;second.get()); if(ret.isSuccess()) &#123; std::cout &lt;&lt; ret.obj.get().as&lt;std::string&gt;() &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; ret.errorMessage &lt;&lt; std::endl; &#125; &#125;&#125;vg.releaseCall(acr-&gt;first);//// 与同步调用相同// ... 与同步调用不同，asyncCall函数返回的是std::shared_ptr&lt;veigar::AsyncCallResult&gt;，而且调用者在获取到CallResult或不再关系调用结果时，需要调用releaseCall函数释放资源。 4.4 基于回调函数的异步调用使用asyncCall函数同样可以实现基于回调函数的异步调用。 下面是基于回调函数的异步调用示例： 12345678910std::vector&lt;uint8_t&gt; buf;vg.asyncCall([](const veigar::CallResult&amp; cr) &#123; if(cr.isSuccess()) &#123; std::cout &lt;&lt; cr.obj.get().as&lt;std::string&gt;() &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; cr.errorMessage &lt;&lt; std::endl; &#125; &#125;, targetChannelName, &quot;echo&quot;, &quot;hello&quot;, 12, 3.14, buf); 该方式不需要调用releaseCall函数释放资源。 4.5 RPC函数参数类型支持常规的 C++ 数据类型，如： bool char, wchar_t int, unsigned int, long, unsigned long, long long, unsigned long long uint8_t, int8_t, int32_t, uint32_t, int64_t, uint64_t float, double 1234veigar::Veigar vg;vg.bind(&quot;func&quot;, [](char c, wchar_t w, int i, int8_t j, int64_t k) &#123; // ......&#125;); 也支持如下 STL 数据类型： std::string std::set std::vector std::map std::string_view (C++ 17) std::optional (C++ 17) 不支持 std::wstring，但是我们可以使用 std::vector 来代替 std::wstring 1234veigar::Veigar vg;vg.bind(&quot;func&quot;, [](std::string s, std::vector&lt;std::string&gt;, std::string_view v, std::map&lt;int, bool&gt; m) &#123; // ......&#125;); 也可以支持自定义数据类型，如： 123456789101112#include &quot;veigar/msgpack/adaptor/define.hpp&quot;struct MyPoint &#123; int x; int y; MSGPACK_DEFINE(x, y);&#125;;veigar::Veigar vg;vg1.bind(&quot;func&quot;, [](MyPoint m) &#123; // ......&#125;); 详细的参数绑定方法见 tests&#x2F;type_test.cpp。 5. 性能使用 examples\\performance-test 程序作为测试用例： 进程 A 使用 4 个线程同时进行同步调用进程 B，每个线程调用 25000 次，平均每次“调用 &lt;–&gt; 返回结果”消耗 12 微妙。 1Used: 1s240ms721μs, Total: 100000 Success: 100000, Timeout: 0, Failed: 0, Average: 12μs/call. 虽然 Veigar 在性能上还有一定的优化提升空间，但就测试结果来看，目前已经远远超越了其他 RPC 框架。","tags":["RPC","Veigar"],"categories":["Power By Me"]},{"title":"Node插件开发(2)-调用方式","path":"/post/235943795.html","content":"本文主要介绍如何在 Node-API 中实现不同类型的接口，主要有下面几种类型： 同步调用 基于 Napi::AsyncWorker 的异步调用，通过回调函数返回 异步调用，返回 Promise 基于 Napi::ThreadSafeFunction 的异步调用，通过回调函数返回 一、同步调用同步调用会阻塞 Node.js 的主进程，适合接口能快速返回的场景。 12345678910111213Napi::Number Add(const Napi::CallbackInfo&amp; info) &#123; Napi::Env env = info.Env(); if (info.Length() != 2) throw Napi::TypeError::New(env, &quot;Wrong number of arguments&quot;); if (!info[0].IsNumber() || !info[1].IsNumber()) throw Napi::TypeError::New(env, &quot;Wrong arguments&quot;); const int ret = info[0].ToNumber().Int32Value() + info[1].ToNumber().Int32Value(); return Napi::Number::New(env, ret);&#125; 二、异步回调在 Node-API 中，不能在系统子线程中直接调用 JavaScript 函数，但可以借助 Napi::AsyncWorker 类来实现异步执行任务，在Napi::AsyncWorker 类的 Execute 虚函数中执行具体的任务，并在其 OnOK 或 OnError 虚函数中执行 JavaScript 回调函数，通过回调的方式来返回结果到 JavaScript。 如果在 Execute 函数中需要返回错误，可以调用 SetError 函数来设置错误信息，调用 SetError 函数后，OnError 函数就会被自动执行。需要注意的是，SetError 函数不会终止 Execute 函数的执行流程，通常会在 SetError 调用之后紧接 return 语句。 当 Execute 函数执行完以后，如果期间没有调用 SetError 函数，则 OnOK 函数也会被自动执行。 我们需要在 OnOK 或 OnError 中调用回调函数来将结果返回到 JavaScript，通常保持与 Node.js 官方模块的接口一样（当不是强制的），回调函数有 2 个参数 callback(err, result)，失败时 err 不为 Null，成功时 err 为 Null。 下面示例以异步方式计算正整数 N 的 10 次方为例，通过回调方式返回计算结果。 12345678910111213141516171819202122232425262728293031323334class Power10AsyncWorker : public Napi::AsyncWorker &#123; public: Power10AsyncWorker(const Napi::Function&amp; callback, int32_t n) : Napi::AsyncWorker(callback), n_(n) &#123; &#125; void Execute() override &#123; if (n_ &lt;= 0) &#123; // N小于0则返回错误 SetError(&quot;N must larger than 0&quot;); return; &#125; result_ = 1; for (int i = 0; i &lt; 10; i++) &#123; // 由于CPU计算10次方太快了，这里每次暂停10ms，模拟耗时操作 std::this_thread::sleep_for(std::chrono::milliseconds(10)); result_ *= n_; &#125; &#125; void OnOK() override &#123; Callback().Call(&#123;Env().Null(), Napi::Value::From(Env(), result_)&#125;); &#125; void OnError(const Napi::Error&amp; e) override &#123; Callback().Call(&#123;e.Value(), Env().Null()&#125;); &#125; private: int32_t n_ = 0; int32_t result_ = 0; // 存储结果&#125;; 定义接口GetPower10，支持2个参数：整数N和回调函数。 1234567891011121314void GetPower10(const Napi::CallbackInfo&amp; info) &#123; Napi::Env env = info.Env(); if (info.Length() != 2) throw Napi::TypeError::New(env, &quot;Wrong number of arguments&quot;); if (!info[0].IsNumber() || !info[1].IsFunction()) throw Napi::TypeError::New(env, &quot;Wrong arguments&quot;); int32_t n = info[0].ToNumber().Int32Value(); Napi::Function callback = info[1].As&lt;Napi::Function&gt;(); (new Power10AsyncWorker(callback, n))-&gt;Queue();&#125; 三、返回 Promise 对象下面示例以异步计算正整数 N 的 20 次方为例，介绍如何返回 Promise 对象。当 N 小于 0 时，Promise 设置为 reject 状态。 123456789101112131415161718192021222324252627282930313233343536class Power20AsyncWorker : public Napi::AsyncWorker &#123; public: Power20AsyncWorker(const Napi::Env&amp; env, const Napi::Promise::Deferred&amp; deferred, int32_t n) : Napi::AsyncWorker(env), deferred_(deferred), n_(n) &#123; &#125; void Execute() override &#123; if (n_ &lt;= 0) &#123; // 小于0时返回错误 SetError(&quot;N must larger than 0&quot;); return; &#125; result_ = 1; for (int i = 0; i &lt; 20; i++) &#123; // 由于CPU计算20次方太快了，每次暂停10ms，模拟耗时操作 std::this_thread::sleep_for(std::chrono::milliseconds(10)); result_ *= n_; &#125; &#125; void OnOK() override &#123; deferred_.Resolve(Napi::Number::New(Env(), result_)); &#125; void OnError(const Napi::Error&amp; e) override &#123; deferred_.Reject(e.Value()); &#125; private: Napi::Promise::Deferred deferred_; int32_t n_ = 0; int32_t result_ = 0; // 存储结果&#125;; 123456789101112131415161718Napi::Value GetPower20(const Napi::CallbackInfo&amp; info) &#123; Napi::Env env = info.Env(); if (info.Length() != 1) throw Napi::TypeError::New(env, &quot;Wrong number of arguments&quot;); if (!info[0].IsNumber()) throw Napi::TypeError::New(env, &quot;Wrong arguments&quot;); int32_t n = info[0].ToNumber().Int32Value(); Napi::Function callback = info[1].As&lt;Napi::Function&gt;(); Napi::Promise::Deferred deferred = Napi::Promise::Deferred::New(env); (new Power20AsyncWorker(env, deferred, n))-&gt;Queue(); return deferred.Promise();&#125; 四、ThreadSafeFunction前面的示例都没有自己启动系统子线程，而是通过 Napi::AsyncWorker 实现的异步调用，在本示例中我们使用 C++ 11 的 std::thread 开启系统子线程，在子线程中执行任务并调用回调函数返回结果。 要实现在系统子线程中调用 JavaScript 回调函数，需要借助于 Napi::ThreadSafeFunction 类来实现。 下面示例演示了在系统子线程中计算正整数 N 的 30 次方，并通过回调方式返回计算结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374void GetPower30(const Napi::CallbackInfo&amp; info) &#123; Napi::Env env = info.Env(); if (info.Length() != 2) throw Napi::TypeError::New(env, &quot;Wrong number of arguments&quot;); if (!info[0].IsNumber() || !info[1].IsFunction()) throw Napi::TypeError::New(env, &quot;Wrong arguments&quot;); int32_t n = info[0].ToNumber().Int32Value(); Napi::Function callback = info[1].As&lt;Napi::Function&gt;(); std::thread* nativeThread = nullptr; Napi::ThreadSafeFunction tsfn = Napi::ThreadSafeFunction::New( env, callback, &quot;Resource Name&quot;, // Name 0, // Unlimited queue 1, // Only one thread will use this initially [nativeThread](Napi::Env) &#123; // Finalizer used to clean threads up if (nativeThread &amp;&amp; nativeThread-&gt;joinable()) &#123; nativeThread-&gt;join(); &#125; &#125;); nativeThread = new std::thread([n, tsfn]() &#123; struct CallParam &#123; std::string error; int32_t result = 0; &#125;; CallParam* param = new CallParam(); if (n &gt; 0) &#123; param-&gt;result = 1; for (int i = 0; i &lt; 30; i++) &#123; param-&gt;result *= n; &#125; &#125; else &#123; param-&gt;error = &quot;N must larger than 0&quot;; &#125; auto callback = [](Napi::Env env, Napi::Function jsCallback, CallParam* param) &#123; if (jsCallback &amp;&amp; param) &#123; try &#123; if (param-&gt;error.empty()) &#123; jsCallback.Call(&#123;env.Null(), Napi::Number::New(env, param-&gt;result)&#125;); &#125; else &#123; Napi::Error err = Napi::Error::New(env, param-&gt;error); jsCallback.Call(&#123;err.Value(), env.Null()&#125;); &#125; &#125; catch (std::exception&amp; e) &#123;#if (defined _WIN32 || defined WIN32) OutputDebugStringA(e.what());#endif &#125; &#125; if (param) &#123; delete param; &#125; &#125;; napi_status status = tsfn.BlockingCall(param, callback); if (status != napi_ok) &#123; // TODO How to handle error &#125; tsfn.Release(); &#125;);&#125; 完整的示例代码以上传自 Github： https://github.com/winsoft666/node-addon-sample","tags":["Electron","Node-API"],"categories":["Electron"]},{"title":"ABI兼容性","path":"/post/529732738.html","content":"ABI 是 Application Binary Interface 的缩写，当我们以二进制形式（非源码形式）发布我们的动态库时，就需要关心ABI兼容（也称二进制兼容）。 对于静态库，更新静态库始终都需要该库的使用方重新编译，因此不存在ABI兼容的说法。 一、什么是ABI兼容假设我们开发了某个动态库（名为 something），以动态库的形式提供：something.h、something.lib、something.dll。 有人使用该动态库开发了程序 w（w可以是可执行程序，也可以是库），即程序w链接了动态库 something，并将程序w打包交付给终端用户，打包文件包含：w.exe、something.dll。 something 库是否具有ABI兼容性决定了在更新 something.dll 时，是否需要重新编译 w.exe？ 如果不需要重新编译 w.exe，则 something 库是二进制兼容的，否则就不是的。 Microsoft C++（MSVC）编译器工具集在 Visual Studio 2015 之前未实现ABI兼容，但在 Visual Studio 2015（含）之后实现了ABI兼容。 详见之前文章：MSVC版本的二进制兼容性 二、与 ABI 有关的知识在理解哪些行为是否会破坏 ABI 兼容性之前，我们需要预先了解一些C++基础知识。 2.1 类如何访问成员变量在 C++ 中，struct 和 class 是通过偏移量来访问成员变量的，如果改变了成员变量的顺序，偏移量也会相应改变。 2.2 虚函数表虚函数是通过虚函数表来管理和访问的，改变虚函数顺序、新增&#x2F;删除虚函数都会改变虚函数表，可以参考之前有关虚函数的文章：深入理解C++虚函数 2.3 Name ManglingC++ 编译器会把函数的名字、参数等信息（或者叫函数签名）编码成一个唯一的字符串，用作链接符号，这样就能在编译期完成检查，从而避免运行时报错，这种行为称作Name Mangling，例如： 1234567namespace wikipedia &#123; class article &#123; public: std::string format(void); &#125;&#125; format 函数经过 Name Mangling 之后变成了：_ZN9wikipedia7article6formatEv Name Mangling使用的算法是可逆的，http://demangler.com/ 网站提供了通过新函数名逆向推演出原有函数名的功能。 2.4 类如何访问成员函数C++ 编译器在编译成员函数时会根据它所在的命名空间、所属类、以及参数等信息，通过 Name Mangling 生成一个新的函数名。 类的成员函数最终被编译成与对象无关的全局函数，为了使该全局函数可以访问类的其他成员函数和变量，编译器在编译成员函数时会额外添加一个参数，把当前对象的指针传递进去，通过指针来访问成员变量&#x2F;成员函数。 2.5 头文件的作用在 C&#x2F;C++ 中，动态链接库通常会附带头文件，这个头文件可以理解成动态库的“使用说明书”，库的使用者会按照头文件使用该库，编译器会根据该头文件生成二进制代码，然后在运行的时候通过装载器(loader)把可执行文件和动态库绑到一起。 3. 破坏ABI兼容性的行为如何判断一个改动是不是二进制兼容，主要看老版的头文件能否与新版本的动态库的实际使用方法兼容。因为新的库必然有新的头文件，但是现有的二进制可执行文件还是按旧的头文件来调用动态库。 总结起来，ABI 不兼容主要是因为： sizeof(class) 大小改变。 数据成员偏移量发生改变。 虚函数表发生改变。 Name Mangling 名发生改变。 下面列举了会破坏 ABI 兼容性的操作。 3.1 添加或删除非静态成员变量因为 sizeof(class) 大小发生改变，如之前占用8个字节，新增一个成员变量后占用12字节，但外部代码new class时仍然只分配了8字节，所以会出问题。 但是，如果动态库提供了创建对象的方法，始终在动态库内部创建对象，则没有该问题，如： 123456class EXPORT_API Koi &#123; public: // ....&#125;;EXPORT_API Koi* GetKoi(); 也可以通过Impl设计模式来解决该问题。 1234567class EXPORT_API Koi &#123; public: // .... private: class Impl; Impl* impl_;&#125;; 123456// 动态库内部class Koi::Impl &#123; public: int a_; // ...&#125; 3.2 改变非静态成员变量的顺序改变了非静态成员变量的顺序就改变了变量的内存偏移，会导致变量读写出错，因此破坏了ABI兼容性。 这个问题也可通过上面 3.1 节的方式来解决。 3.3 修改函数的名称这个导致会 Name Mangling 名发生改变，因此 ABI 不兼容。 3.4 添加默认的模板类型参数如Foo&lt;T&gt; 改为 Foo&lt;T, Alloc=alloc&lt;T&gt; &gt;，这个导致会 Name Mangling 名发生改变，因此不 ABI 兼容。 3.5 为函数添加默认参数现有的动态库使用方（可执行程序或另外一个动态库）是基于老的头文件进行编译的，无法传递该默认参数给新的动态库，因此不 ABI 兼容。 3.6 修改函数参数传递方式如 __cdecl 修改为 __stdcall。函数参数的传递方式有多种，如压栈方式、寄存器方式。如果选择压栈方式，在维持栈平衡上有分调用者维持、函数自身维持，在参数的传递顺序也有多种，从左到右，还是从右到左。 具体介绍可以参考之前的文章：从汇编的角度分析函数调用过程 3.7 添加虚函数添加虚函数会导致虚函数表发生了变化，即便是在最尾端添加虚函数也可能不行，因为当前类可能已经被其他类继承了。 3.8 不同系统的动态库不同操作系统所支持的动态库的二进制格式不一样，因此不同系统的动态库肯定是无法兼容的。 四、不破坏ABI兼容性的行为下面的操作不会破坏 ABI 兼容性： 添加新的类 修改成员变量的名称 更改非虚成员函数的顺序 五、Windows COM 实现 ABI 兼容的方式很多时候，由于功能更新，对接口的修改不可避免的，既然接口已经发生大改动，那显然很难满足ABI兼容性，此时可以通过版本管理的方式来保证 ABI 兼容性，如： 1234567// 版本1class Interface &#123;public: virtual void API sendMessage(const char* message) = 0;&#125;;Interface* CreateInterface(int version); 1234567// 版本2class Interface2 &#123;public: virtual void API sendMessage(const char* message, int messageSize) = 0;&#125;;Interface2* CreateInterface(int version); 上面方式也是 COM 实现 ABI 兼容性的方式，需要在动态库中仍要保留老的接口和实现，以实现向前兼容，这种方式有个弊端就是会存在很多版本的接口，如： 12IDirect3D7, IDirect3D8, IDirect3D9, ID3D10*, ID3D11*IXMLDOMDocument, IXMLDOMDocument2, IXMLDOMDocument3 本文参考了： C++ 工程实践(4)：二进制兼容性","tags":["ABI","运行时库"],"categories":["C++语言"]},{"title":"Node插件开发(1)-快速入门","path":"/post/819381949.html","content":"在使用 Electron 开发客户端时，如果现有 Node 模块所提供的功能无法满足需要，我们可以使用 C++ 开发自定义的 Node 模块，也称插件（addon）。 Node.js 插件的扩展名为 .node，是二进制文件，其本质上是通过动态链接库（.dll 或 .so）重命名而来。 1. 选择Node-API开发Node.js扩展的方式有三种： Node-API（以前叫N-API） nan 直接使用v8、libuv等库进行开发 除非是为了使用 Node-API 未公开的接口，否则建议使用 Node-API 进行开发。 因为Node-API是二进制（ABI）兼容的，它将底层JavaScript引擎与上层插件隔离开了，JavaScripty引擎的修改不会影响我们开发的上层插件，我们基于某个版本编译的插件在不需要重新编译的情况下，就可以运行在其他版本的Node.js中。 2. 安装编译环境Node插件使用C++开发，因此在不同的系统上采用不同的编译环境。在Linux环境通常使用GCC和LLVM； Mac环境通常使用Xcode； Windows环境通常使用Visual Studio，如果不想安装完整的Visual Studio，可以使用如下命令仅安装必要的工具链： 1npm install --global windows-build-tools Node插件通常使用node-gyp进行编译，node-gyp基于Google的gyp-next构建系统，node-gyp已经与npm捆绑在一起，但我们在使用node-gyp之前还需要先安装Python。 至此Node插件开发的环境已经搭建完成。 3.搭建工程 本文以在Windows下开发Node插件为例，其他系统环境在编译选项方面略有不同 3.1 package.json123456789101112131415&#123; &quot;name&quot;: &quot;node-addson-sample&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;private&quot;: true, &quot;description&quot;: &quot;A sample node addson sample&quot;, &quot;dependencies&quot;: &#123; &quot;bindings&quot;: &quot;^1.5.0&quot;, &quot;node-addon-api&quot;: &quot;^7.1.0&quot; &#125;, &quot;scripts&quot;: &#123; &quot;build-debug&quot;: &quot;node-gyp --debug --arch=x64 configure rebuild&quot;, &quot;build-release&quot;: &quot;node-gyp --release --arch=x64 configure rebuild&quot;, &quot;test&quot;: &quot;node test.js&quot; &#125;&#125; 使用npm install安装依赖项。 各个依赖项的作用如下： node-addon-api用于提供了Node-API相关的头文件； bindings用于帮助插件开发者快速导入编译后的.node插件，方便调试，这个依赖是非必须； build-debug和build-release脚本分别用于编译Debug和Release版本的插件； test脚本用于执行测试用例； 32位插件指定arch为ia32（--arch=ia32）就可以编译32位版本的Node插件。 需要注意：64位版本Node.js只能加载64位的Node插件，32位版本的Node.js也只能加载32位的Node插件，否则会报错： 1Error: \\\\?\\D: ode-addon-sample\\build\\Debug ode-addon-sample.node is not a valid Win32 application. 3.2 编译脚本Node-API支持GYP和CMake.js两种编译方式，这里选择使用GYP方式。 新建binding.gyp文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&#123; &quot;targets&quot;: [ &#123; &quot;target_name&quot;: &quot;node-addson-sample&quot;, # ***.node &quot;cflags!&quot;: [ &quot;-fno-exceptions&quot; ], &quot;cflags_cc!&quot;: [ &quot;-fno-exceptions&quot; ], # 指定需要编译的源文件 &quot;sources&quot;: [ &quot;main.cpp&quot; ], &quot;include_dirs&quot;: [ &quot;&lt;!@(node -p \\&quot;require(&#x27;node-addon-api&#x27;).include\\&quot;)&quot; ], # 预编译宏 &quot;defines&quot;: [ &quot;NAPI_CPP_EXCEPTIONS&quot;, # 在Node-API中启用C++异常 ], &quot;conditions&quot;: [ [ # Windows平台编译选项 &quot;OS == &#x27;win&#x27;&quot;, &#123; &quot;configurations&quot;: &#123; # Debug编译选项 &quot;Debug&quot;: &#123; # 预编译宏 &quot;defines&quot;: [ &quot;DEBUG&quot;, &quot;_DEBUG&quot; ], &quot;cflags&quot;: [ &quot;-g&quot;, &quot;-O0&quot; ], &quot;conditions&quot;: [ [ &quot;target_arch==&#x27;x64&#x27;&quot;, &#123; &quot;msvs_configuration_platform&quot;: &quot;x64&quot;, &#125; ], ], &quot;msvs_settings&quot;: &#123; &quot;VCCLCompilerTool&quot;: &#123; # 0 - MultiThreaded (/MT) # 1 - MultiThreadedDebug (/MTd) # 2 - MultiThreadedDLL (/MD) # 3 - MultiThreadedDebugDLL (/MDd) &quot;RuntimeLibrary&quot;: 1, # /MTd &quot;Optimization&quot;: 0, # /Od, no optimization &quot;MinimalRebuild&quot;: &quot;false&quot;, &quot;OmitFramePointers&quot;: &quot;false&quot;, &quot;BasicRuntimeChecks&quot;: 3, # /RTC1 &quot;AdditionalOptions&quot;: [ &quot;/EHsc&quot; ], &#125;, &quot;VCLinkerTool&quot;: &#123; &quot;LinkIncremental&quot;: 2, # Enable incremental linking # 附加依赖库 &quot;AdditionalDependencies&quot;: [ ], &#125;, &#125;, # 附加包含目录 &quot;include_dirs&quot;: [ ], &#125;, # Debug编译选项 &quot;Release&quot;: &#123; # 预编译宏 &quot;defines&quot;: [ &quot;NDEBUG&quot; ], &quot;msvs_settings&quot;: &#123; &quot;VCCLCompilerTool&quot;: &#123; &quot;RuntimeLibrary&quot;: 0, # /MT &quot;Optimization&quot;: 3, # /Ox, full optimization &quot;FavorSizeOrSpeed&quot;: 1, # /Ot, favour speed over size &quot;InlineFunctionExpansion&quot;: 2, # /Ob2, inline anything eligible &quot;WholeProgramOptimization&quot;: &quot;false&quot;, # Dsiable /GL, whole program optimization, needed for LTCG &quot;OmitFramePointers&quot;: &quot;true&quot;, &quot;EnableFunctionLevelLinking&quot;: &quot;true&quot;, &quot;EnableIntrinsicFunctions&quot;: &quot;true&quot;, &quot;RuntimeTypeInfo&quot;: &quot;false&quot;, &quot;ExceptionHandling&quot;: &quot;2&quot;, # /EHsc &quot;AdditionalOptions&quot;: [ &quot;/MP&quot;, # compile across multiple CPUs ], &quot;DebugInformationFormat&quot;: 3, &quot;AdditionalOptions&quot;: [ ], &#125;, &quot;VCLibrarianTool&quot;: &#123; &quot;AdditionalOptions&quot;: [ &quot;/LTCG&quot;, # link time code generation ], &#125;, &quot;VCLinkerTool&quot;: &#123; &quot;LinkTimeCodeGeneration&quot;: 1, # link-time code generation &quot;OptimizeReferences&quot;: 2, # /OPT:REF &quot;EnableCOMDATFolding&quot;: 2, # /OPT:ICF &quot;LinkIncremental&quot;: 1, # disable incremental linking # 附加依赖库 &quot;AdditionalDependencies&quot;: [ ], &#125;, &#125;, # 附加包含目录 &quot;include_dirs&quot;: [ ], &#125; &#125; &#125;, ] ] &#125; ]&#125; binding.gyp中的编译选项大多与特定平台的编译器有关，具体可以查阅相关编译器文档，如Windows平台可以查询MSVC文档。 可以使用如下命令指定需要使用的 Visual Stuido 版本： 1npm config set msvs_version 20xx node-gyp官方提供了一些示例，我们可以从这些示例中获取不少灵感： binding.gyp-files-in-the-wild GYP官方文档： https://gyp.gsrc.io/docs/UserDocumentation.md 3.3 第一个API现在新建main.cpp，在该文件中定义我们的第一个API，API名为Add，支持传入2个整数参数，返回整数相加的和。 1234567891011121314151617#include &lt;napi.h&gt;// 同步调用// 计算两个整数相加结果并返回Napi::Number Add(const Napi::CallbackInfo&amp; info) &#123; Napi::Env env = info.Env(); if (info.Length() != 2) throw Napi::TypeError::New(env, &quot;Wrong number of arguments&quot;); if (!info[0].IsNumber() || !info[1].IsNumber()) throw Napi::TypeError::New(env, &quot;Wrong arguments&quot;); const int ret = info[0].ToNumber().Int32Value() + info[1].ToNumber().Int32Value(); return Napi::Number::New(env, ret);&#125; 在定义完API之后，还需要将API导出，在文件末尾添加如下代码： 12345678// 导出函数Napi::Object Init(Napi::Env env, Napi::Object exports) &#123; exports.Set(Napi::String::New(env, &quot;Add&quot;), Napi::Function::New(env, Add)); return exports;&#125;NODE_API_MODULE(addon, Init) 如果忘记导出API，加载Node插件时会报错： 1Error: Module did not self-register: &#x27;\\\\?\\D: ode-addson-sample\\build\\Debug ode-addson-sample.node&#x27;. 现在执行npm run build-debug编译Debug版本插件，编译生成的node插件路径为build\\Debug ode-addson-sample.node。 3.4 测试用例新建test.js，测试代码如下： 123const sample = require(&quot;bindings&quot;)(&quot;node-addson-sample.node&quot;);console.log(sample.Add(100, 200)); // 输出300 使用bindings模块可以不用考虑插件的具体位置，该模块会自动帮我们在项目目录下遍历查找。 4. 数据类型在napi.h头文件中有很多继承自Napi::Value的子类，这些类分别对应JavaScript中的数据类型，如： Napi::Boolean -&gt; Boolean Napi::Number -&gt; Number Napi::String -&gt; String Napi::Function -&gt; Function Napi::Symbol -&gt; Symbol Napi::Array -&gt; Array Napi::Object -&gt; Object Node-Api还定义Promise、Date、Buffer等数据类型。 4.1 Null和UndefinedNull和Undefined比较特殊，没有定义专门的类，由Env类的成员函数返回。 123env.Null()env.Undefined() 4.2 创建对象有两种方式可以用来创建指定类型的对象，以创建Boolean类型为例： 12Napi::Boolean::New(env, true)Napi::Value::From(env, false) 以创建一个对象数组为例介绍对象和数组的使用方法： 12345678Napi::Array result = Napi::Array::New(env);for (size_t i = 0; i &lt; 3; i++) &#123; Napi::Object obj = Napi::Object::New(env); obj.Set(Napi::String::New(env, &quot;filePath&quot;), Napi::String::New(env, &quot;/root/&quot; + std::to_string(i) + &quot;.txt&quot;)); obj.Set(Napi::String::New(env, &quot;fileSize&quot;), Napi::Number::New(env, i * 100)); result.Set(Napi::Number::New(env, i), obj);&#125; 4.3 类型校验Napi::Value提供了若干方法用于判断当前对象是否为指定类型，如： IsUndefined IsNull IsBoolean IsNumber IsString IsSymbol IsArray IsObject IsFunction IsPromise IsBuffer 5. 异常可以在编译脚本binding.gyp中通过预编译宏指定是否启用C++异常： 123NAPI_CPP_EXCEPTIONSNAPI_DISABLE_CPP_EXCEPTIONS 如果启用C++异常，则Napi::Error会继承自std::exception。 123456class Error : public ObjectReference#ifdef NAPI_CPP_EXCEPTIONS , public std::exception#endif // NAPI_CPP_EXCEPTIONS... 在启动C++异常的情况下，从Node插件抛出异常的方式如下： 1throw Napi::TypeError::New(env, &quot;Wrong number of arguments&quot;); 将会中断当前函数throw后面代码的执行。 TypeError继承自Error，通常用于表示与类型错误相关的异常。类似的错误类型还有RangeError等，也可以直接抛出Error类型的错误： 1throw Napi::Error::New(env, &quot;Wrong number of arguments&quot;); 在没有启用 C++ 异常的情况下，采用如下方式从 Node 插件抛出异常： 12Napi::TypeError::New(env, &quot;Wrong number of arguments&quot;).ThrowAsJavaScriptException();return; 抛出异常后需要使用 return 语句终止下面流程的执行。 Node-API官方文档：node-addon-api docNode.js官方addon示例：node-addon-examples","tags":["Electron","Node-API"],"categories":["Electron"]},{"title":"产品级的Electron项目模板","path":"/post/946276004.html","content":"写在前面已经有了那么多的 Electron 项目模板，为什么还要再造一个？是重复造轮子吗？ 我相信大多数人选择使用 Electron 开发客户端时，或多或少都看上了 Web 开发的高效率，但Web开发人员在客户端和系统编程方面的经验相对缺乏，又加上 Electron 和前端框架（如 Vue ）结合起来也不是那么的轻而易举，开发人员大多会选择基于模板来快速上手搭建Electron项目。 目前，Electron 的模板项目已经有很多，比较流行的有electron-vite、electron-vite-vue等。在这些模板中，有的功能过于完善，代码太复杂，远远超过了很多 Electron 客户端项目本身的代码量，需要花很多时间来熟悉模板，不适合新手快速上手和修改，一旦出现问题也难以维护；有的模板又年久失修，使用的技术早已被淘汰，也不适合用来开发线上产品，而且这些模板都有一个通病，都是在用Web开发的思维来开发客户端。 基于上述原因，我开发了这个 Electron 项目模板，在开发过程中，我一直遵循稳定、易于维护的初衷。 项目地址：https://github.com/winsoft666/electron-vue3-boilerplate 项目介绍基于Vue3 + Electron + TypeScript的客户端程序模板，使用Vite和Electron Forge构建和打包。 真正做到开箱即用，面向跨平台客户端设计，产品级的项目模板。 特性 使用 ViteJS 构建和驱动前端页面，支持热加载（HMR），使开发和调试变得更加高效 ⚡ 支持Electron窗口创建指令，并且可隔离不同窗口的IPC事件 💖 封装简化了IPC的调用方式，并提供了IPC函数快速创建指令，主进程与渲染进程的相互调用从未如此简单 👍 主进程和渲染进程支持热加载 ⚡ 精选依赖包，提升项目稳定性 代码简洁，易掌控，可定制性强 日志文件，主进程和渲染进程可以直接写文件日志 配置文件 主进程和渲染进程均支持axios HTTP请求 文件下载（含哈希校验、进度反馈），渲染进程可直接异步调用 👍 功能完善的无边框窗口 托盘图标和右键菜单，窗口关闭时程序最小化到托盘 客户端程序单实例 基于ESLint的代码规范和自动格式化 使用Electron官方推荐的Electron Forge进行客户端构建和打包 支持NSIS安装包 😎 …… 快速开始 🌈点击右上角绿色的 Use this template 按钮，使用该模板创建一个新的仓库并克隆到本地。 或者.. 直接克隆该项目: 1git clone https://github.com/winsoft666/electron-vue3-boilerplate.git Visual Studio Code推荐使用Visual Studio Code进行项目开发，并安装如下插件： ESLint Vue Language Features (Volar) 安装依赖 ⏬1yarn install 开发 ⚒️1yarn run dev 其他命令1234567891011yarn run dev # 启动应用并支持热加载yarn run build # 构建应用，可发布的包位于&quot;out\\make&quot;目录# 或者yarn run build:win32 # 构建Windows平台 32位应用yarn run build:win64 # 构建Windows平台 64位应用yarn run build:mac # 构建macOS平台应用yarn run build:linux # 构建Linux平台应用yarn run new:page # 创建新的Vue页面yarn run new:window # 创建新的Electron窗口 更多的可选配置项可以参考 Electron Forge CLI docs。 更多介绍可以访问项目主页： https://github.com/winsoft666/electron-vue3-boilerplate 限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺 您可以通过在 blog-comment 项目中提交Issue来间接地发表评论🍀","tags":["Electron"],"categories":["Power By Me"]},{"title":"🐉2024龙行龘龘","path":"/post/1391804423.html","content":"写下这一行预示着2024年的工作开始了，加油！ 物来顺应，未来不迎。 当时不杂，既过不恋。","categories":["杂念"]},{"title":"开源库spdlog使用备忘","path":"/post/2185523635.html","content":"spdlog是一个高性能C++日志库，可以支持仅头文件（header-only）模式使用。 官网地址： https://github.com/gabime/spdlog spdlog是线程安全的，但不是进程安全的，可以多个线程同时使用一个spdlog对象输出日志，但不能多个进程同时往一个文件写入日志。 在spdlog内部使用fmt进行字符串的格式化，因此spdlog字符串格式的方式与fmt库相同，如： 1spdlog::critical(&quot;Support for int: &#123;0:d&#125;; hex: &#123;0:x&#125;; oct: &#123;0:o&#125;; bin: &#123;0:b&#125;&quot;, 42); 一、日志级别大多数日志库都有日志级别的概念，通过设定日志级别可以动态控制我们需要打印输出的日志，spdlog支持如下日志级别： 123456trace = SPDLOG_LEVEL_TRACE // 最低级debug = SPDLOG_LEVEL_DEBUGinfo = SPDLOG_LEVEL_INFOwarn = SPDLOG_LEVEL_WARNerr = SPDLOG_LEVEL_ERRORcritical = SPDLOG_LEVEL_CRITICAL // 最高级 如下代码设置日志级别为info，此时只会打印输出info及比info级别高的日志： 1spdlog::set_level(spdlog::level::info); 二、Logger和Sinkspdlog主要由Logger(记录器)和Sink(输出位置)两部分组成，spdlog的高可拓展性体现在Logger和Sink的可以由用户自定义方面。 每个程序可以创建多个Logger对象，而每个Logger对象又可以包含多个Sink（也就是可以同时输出到多个位置）。 2.1 创建Sink在介绍Logger的创建方法前，我们先看看如何创建Sink对象。 每个Sink都是一个std::shared_ptr&lt;spdlog::sink&gt;对象，创建Sink方法如下： 1auto sink = std::make_shared&lt;spdlog::sinks::stdout_sink_mt&gt;(); spdlog有_mt（multi threaded）和_st（single threaded）两类后缀的sink对象，用于区分是否线程安全。单线程(_st后缀)的sink是非线程安全的，不能被多个线程使用。 spdlog内置了多种不同的sink类型，如可以输出到文件、控制台、tcp&#x2F;udp端口、Windows事件日志、mongo数据库等。完整的sink可以查看源代码的sinks目录，通常一个文件对应一个sink。 虽然内置的Sink可以满足我们的大多数需求，但spdlog依然支持自定义Sink，具体方法参考官方文档：implementing-your-own-sink 下面介绍几种常用内置sink的创建方法。 simple_file_sink一个简单的文件接收器，将日志写入到给定的日志文件，没有任何的限制。 123#include &quot;spdlog/sinks/basic_file_sink.h&quot;// ...auto logger = spdlog::basic_logger_mt(&quot;mylogger&quot;, &quot;log.txt&quot;); 关于日志的输出目录，如上面的data/logs目录，从splog 1.5.0版本开始，spdlog将自动创建包含日志文件的目录。但在此之前，必须手动创建目录。 rotating_file_sink当达到最大文件大小时，关闭文件，并重命名，然后创建一个新的文件。最大文件大小和最大文件数都可以在构造函数中配置。 1234#include &quot;spdlog/sinks/rotating_file_sink.h&quot;// ...auto file_logger = spdlog::rotating_logger_mt(&quot;file_logger&quot;, &quot;data/logs/mylogfile.log&quot;, 1048576 * 5, 3); daily_file_sink每天在指定的时间创建一个新的日志文件，并在文件名后附加一个时间戳。 123#include &quot;spdlog/sinks/daily_file_sink.h&quot;// ...auto daily_logger = spdlog::daily_logger_mt(&quot;daily_logger&quot;, &quot;logs/daily&quot;, 14, 55); 上面代码将创建一个线程安全的sink，该sink将在每天14:55创建一个新的日志文件。 stdout_sink输出到控制台。 12#include &quot;spdlog/sinks/stdout_sinks.h&quot;auto sink = std::make_shared&lt;spdlog::sinks::stdout_sink_mt&gt;(); stdout_sink with colors输出到控制台，并带颜色标记。 12#include &quot;spdlog/sinks/stdout_sinks.h&quot;auto sink = std::make_shared&lt;spdlog::sinks::stdout_color_sink_mt&gt;(); msvc_sink输出到Windows调试接收器（如DbgView）,在spdlog内部实际使用OutputDebugStringA进行日志输出。 123#include &quot;spdlog/sinks/msvc_sink.h&quot;// ...auto sink = std::make_shared&lt;spdlog::sinks::msvc_sink_mt&gt;(false); msvc_sink的构造函数支持check_debugger_present参数，如果该参数为true，则仅在调试环境输出日志到Windows调试接收器。 dup_filter_sink在日志输出时移除重复的日志。如果日志与前一条日志相同，并且间隔时间小于max_skip_duration，则跳过输出该日志。 123456789#include &quot;spdlog/sinks/dup_filter_sink.h&quot;auto dup_filter = std::make_shared&lt;dup_filter_sink_mt&gt;(std::chrono::seconds(5));spdlog::logger l(&quot;logger&quot;, dup_filter);l.info(&quot;Hello&quot;);l.info(&quot;Hello&quot;);l.info(&quot;Hello&quot;);l.info(&quot;Different Hello&quot;); 上面示例输出的日志如下： 123[2019-06-25 17:50:56.511] [logger] [info] Hello[2019-06-25 17:50:56.512] [logger] [info] Skipped 3 duplicate messages..[2019-06-25 17:50:56.512] [logger] [info] Different Hello 2.2 创建Logger在创建完Sink对象后，就可以使用这些Sink来创建Logger对象。 下面示例创建了名为mylogger的同步Logger对象，为该对象配置了2个sink。 123456789auto file_sink = std::make_shared&lt;spdlog::sinks::rotating_file_sink_mt&gt;(&quot;logs/app.log&quot;, 1048576, 7);auto msvc_sink = std::make_shared&lt;spdlog::sinks::msvc_sink_mt&gt;(false);std::vector&lt;spdlog::sink_ptr&gt; sinks = &#123;file_sink, msvc_sink&#125;;auto logger = std::make_shared&lt;spdlog::logger&gt;(&quot;mylogger&quot;, sinks.begin(), sinks.end()); spdlog内部为每个进程都维护一张全局的Logger记录表，记载了每个进程中通过工厂方法创建的Logger实例(某些情况需要用户手动注册)。因而，在使用时只需要知道创建时指定的名称即可获取Logger对象： 123auto logger = spdlog::get(&quot;mylogger&quot;);logger-&gt;info(&quot;some things want to say.&quot;); 三、自定义日志格式日志格式作用在Sink对象上，每个Sink都有一个格式化程序，spdlog的默认日志记录格式为： 1[2014-10-31 23:46:59.678] [my_loggername] [info] Some message 我们可以通过下面方式为当前进程的所有Logger对象的所有Sink都统一设置日志格式： 1spdlog::set_pattern(&quot;*** [%H:%M:%S %z] [thread %t] %v ***&quot;); 也可以通过下面方式为指定的Logger对象的所有Sink设置日志格式： 1some_logger-&gt;set_pattern(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;); 当然可以针对具体的Sink来设置日志格式： 12345some_logger-&gt;sinks()[0]-&gt;set_pattern(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);some_logger-&gt;sinks()[1]-&gt;set_pattern(&quot;..&quot;);// 或some_sink-&gt;set_pattern(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;); 在设置日志格式时，spdlog都会对格式进程预编译，避免每次输出日志都进程格式解析，提升日志性能。 3.1 格式标记下面列出了spdlog的pattern字符串支持的格式标记（类似%flag）。 标记 含义 示例 %v 实际的日志文本 some user text %t 线程ID 1232 %P 进程ID 3456 %n 日志名称 some logger name %l 日志等级全称 debug、info等 %L 日志等级简写 D、I等 %a 简写星期名称 Thu %A 星期名称全程 Thursday %b 简写月份名称 Aug %B 月份名称全程 August %c 日期和时间 Thu Aug 23 15:35:46 2014 %C 两位数表示年份 2014输出14 %Y 四位数表示年份 2014 %D MM&#x2F;DD&#x2F;YY格式的日期 08&#x2F;23&#x2F;14 %m 月份（01-12） 11 %d 天（01-31） 29 %H 24小时制的小时(00-23) 23 %I 12小时制的小时(01-12) 11 %M 分钟（00-59） 59 %S 秒（00-59） 58 %e 毫秒 678 %f 微妙 056789 %F 纳秒 256789123 %p AM&#x2F;PM AM %r 12小时制时间 02:55:02 PM %R 24小时制时间，等同于 %H:%M 23:55 %T或%X ISO 8601时间格式，等同于%H:%M:%S 23:55:59 %z ISO 8601时间格式，时区偏移 ([+&#x2F;-]HH:MM) 如中国是东8区，+08:00 %E 时间戳 1528834770 %% 输出% % %+ spdlog默认格式 [2014-10-31 23:46:59.678] [mylogger] [info] Some message %^ 开始颜色标记（只能使用一次） [mylogger] [info(green)] Some message %$ 结束颜色标记(如%^[+++]%$ %v) (只能使用一次) [+++] Some message %@ 源文件路径和所在行数，等同于%g:%# &#x2F;some&#x2F;dir&#x2F;my_file.cpp:123 %s 源文件名 my_file.cpp %g 源文件的完整路径或相对路径，等同于__FILE__宏 &#x2F;some&#x2F;dir&#x2F;my_file.cpp %# 源码所在行数 123 %! 源码所在函数名 my_func %o 与上条日志的间隔时间（毫秒） 456 %i 与上条日志的间隔时间（微秒） 456 %u 与上条日志的间隔时间（纳秒） 11456 %O 与上条日志的间隔时间（秒） 4 使用示例： 12auto file_sink = std::make_shared&lt;spdlog::sinks::rotating_file_sink_mt&gt;(&quot;logs/app.log&quot;, 1048576, 7);file_sink-&gt;set_pattern(&quot;%Y-%m-%d %H:%M:%S.%e %z %-10n %-8l [%P %t] %v&quot;); 输出日志格式如下： 12023-12-21 09:34:45.691 +08:00 Dock1703122417075610 info [15460 6948] this is log text 源码位置标记如果需要使用源码位置标记，如%s, %g, %#, %!，需要在包含spdlog头文件之前，定义如下宏： 1#define SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_TRACE 3.2 对齐每个格式标记可以通过预先添加宽度标记来实现对齐。 使用-（左对齐）或=（中间对齐）控制对齐方向： 对齐 含义 示例 结果 % 右对齐 %8l “ info” %- 左对齐 %-8l “info “ %&#x3D; 中间对齐 %&#x3D;8l “ info “ 3.3 截断还可以通过添加!标记来进行数据截断，如果宽度超过指定的宽度，则截断结果： 对齐 含义 示例 结果 %! 右对齐并长度超过3个后截断 %3!l “inf” %-! 左对齐并长度超过2个后截断 %-2!l “in” %&#x3D;! 中间对齐并长度超过1个后截断 %&#x3D;1!l “i” 四、输出策略(Flush policy)基于性能考虑，spdlog不会立即输出日志，而是在内部通过日志队列的方式缓存日志，在合适的时候进行批量输出。 如果需要让spdlog立即输出队列中的日志，可以通过下面的几种方式实现。 4.1 手动操作我们可以单独调用Sink的flush函数立即输出队列中的日志，也可以调用Logger对象的flush函数让该对象下的所有sink立即输出。 如果是异步日志，调用flush函数只会给日志队列发送一个flush消息，不会立即刷新。 在程序退出前，spdlog会确保队列中的所有日志都输出完成。如果想手动确保所有日志输出完成后退出程序，可以调用spdlog::shutdown()函数。 4.2 基于日志等级的输出您可以设置将触发自动输出的最低日志级别。例如，每当记录错误或更严重的消息时，这将触发立即输出： 1my_logger-&gt;flush_on(spdlog::level::err); 4.3 定时输出所有已注册的Logger每5秒的定期输出： 1spdlog::flush_every(std::chrono::seconds(5)); 这种方式只能使用在线程安全的sink上（即_mt后缀），因为定时输出任务执行在不同的线程上。 五、异常spdlog在其文档中关于异常的说明，spdlog只会在构造Logger和Sink错误时主动抛出异常，因为spdlog认为这个错误是致命的，但这个并不可信，最多只能认为spdlog在其他情况下不会主动抛出异常，但不能保证其依赖的库（如fmt）不会抛出异常。 而且如果多个进程向同一个文件写入日志，当文件达到最大大小时，spdlog会自动重命名当前文件，并新建一个新的日志文件。如果多个进程向同一个文件写入日志，会导致重命名日志文件失败，splog会将该失败认为是致命错误，并抛出异常。 如果在打印日志时出现了spdlog能够预料的错误（非预料的及三方库抛出的异常仍然会传递到外部），spdlog默认将向stderr打印错误消息，为了避免错误消息充斥屏幕，每个Logger的错误消息输出速率限制为1条消息&#x2F;分钟。 spdlog提供了错误处理方法，来让用户自定义如何处理错误信息，我们可以通过set_error_handler函数来自定义错误处理方法： 123456789// 全局为每个Logger注册错误处理方法spdlog::set_error_handler([](const std::string&amp; msg) &#123; std::cerr &lt;&lt; &quot;my err handler: &quot; &lt;&lt; msg &lt;&lt; std::endl;&#125;);// 分别为特定的Logger注册错误处理方法critical_logger-&gt;set_error_handler([](const std::string&amp; msg) &#123; throw std::runtime_error(msg);&#125;); spdlog不是异常安全的，在使用spdlog时一定要注意异常捕获，否则可能因为一个格式化标记写错导致程序崩溃，本来是想通过日志来排除问题的，结果却因为日志导致程序崩溃，如： 12// 导致程序崩溃logger-&gt;error(&quot;create device enumerator failed, hr: &#123;#x&#125;&quot;, hr); 六、宽窄字符spdlog内部将字符作为char类型处理，如果需要输出wchar_t类型的字符串，需要将其转换为char类型，spdlog仅将char类型字符串原样输出，不做字符编码判断和处理，需要调用者来觉得字符串的编码，建议统一日志字符串的编码格式为UTF-8或ANSI。 七、日志格式spdlog日志字符串的格式化处理使用的是开源fmt库，其详细语法见：Format String Syntax。 下面列举了常用的日志格式化方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869logger-&gt;info(&quot;输出char字符串:&#123;&#125;&quot;, &quot;hello&quot;);// 输出char字符串:hellologger-&gt;info(&quot;输出std::string:&#123;&#125;&quot;, std::string(&quot;hello&quot;));// 输出std::string:hello/** 输出最小长度的字符串，如果长度不足则用固定字符填充，但超出不会截断字符串*/logger-&gt;info(&quot;输出左对齐字符串(最小长度10，空格填充):&#123;:&lt;10&#125;&quot;, &quot;hello&quot;);// 输出左对齐字符串(最小长度10，空格填充):hello logger-&gt;info(&quot;输出左对齐字符串(最小长度10):&#123;:&lt;10&#125;&quot;, &quot;hello my world&quot;);// 输出左对齐字符串(最小长度10):hello my worldlogger-&gt;info(&quot;输出右对齐字符串(最小长度10，空格填充):&#123;:&gt;10&#125;&quot;, &quot;hello&quot;);// 输出右对齐字符串(最小长度10，空格填充): hellologger-&gt;info(&quot;输出居中对齐字符串(最小长度10，空格填充):&#123;:^10&#125;&quot;, &quot;hello&quot;);// 输出居中对齐字符串(最小长度10，空格填充): hello logger-&gt;info(&quot;输出居中对齐字符串(最小长度10，*填充):&#123;:*^10&#125;&quot;, &quot;hello&quot;);// 输出居中对齐字符串(最小长度10，*填充):**hello***logger-&gt;info(&quot;输出整型:&#123;&#125;&quot;, 1234);// 输出整型:1234logger-&gt;info(&quot;输出布尔类型:&#123;&#125;&quot;, true);// 输出布尔类型:truelogger-&gt;info(&quot;输出float:&#123;&#125;&quot;, 3.1415936f);// 输出float:3.1415937logger-&gt;info(&quot;输出double:&#123;&#125;&quot;, 3.1415936);// 输出double:3.1415936/** 输出最小位数（含小数点）的浮点型* 小数点前部的最小位数=总位数-后部固定位数-1，位数不足默认填充空格，超过不截断；* 小数点后部的位数始终固定，位数不足则在尾部添加0，超出则四舍五入后截断；*/logger-&gt;info(&quot;输出浮点型(含小数点最小位数6位（左边填充空格），小数点后始终3位):&#123;:6.3f&#125;&quot;, 3.1415936);// 输出浮点型(含小数点最小位数6位（左边填充空格），小数点后始终3位): 3.142logger-&gt;info(&quot;输出浮点型(含小数点最小位数6位（左边填充空格），小数点后始终3位):&#123;:6.2f&#125;&quot;, 31415926.1);// 输出浮点型(含小数点最小位数6位（左边填充空格），小数点后始终3位):31415926.10logger-&gt;info(&quot;输出小写十六进制:&#123;:x&#125;&quot;, 123);// 输出小写十六进制:7blogger-&gt;info(&quot;输出大写十六进制:&#123;:X&#125;&quot;, 123);// 输出大写十六进制:7Blogger-&gt;info(&quot;输出小写十六进制(带0x前缀):&#123;:#x&#125;&quot;, 123);// 输出小写十六进制(带0x前缀):0x7blogger-&gt;info(&quot;输出大写十六进制(带0x前缀):&#123;:#X&#125;&quot;, 123);// 输出大写十六进制(带0x前缀):0X7Blogger-&gt;info(&quot;输出小写十六进制(固定8位，不足补0):&#123;:08x&#125;&quot;, 123);// 输出小写十六进制(固定8位，不足补0):0000007blogger-&gt;info(&quot;输出小写十六进制(带0x前缀，固定8位，不足补0):&#123;:#010x&#125;&quot;, 123);// 输出小写十六进制(带0x前缀，固定8位，不足补0):0x0000007bHRESULT hr = E_FAIL;logger-&gt;info(&quot;输出HRESULT:&#123;:#010x&#125;&quot;, (unsigned long)hr);// 输出HRESULT:0x80004005","tags":["开源库","日志","spdlog"],"categories":["开源库"]},{"title":"C/C++不同整数类型的区别","path":"/post/2418701368.html","content":"在C&#x2F;C++中涉及的整数相关的类型大致有如下几种： char、unsigned char short、unsigned short int、unsigned int long、unsigned long long long、unsigned long long int8_t、uint8_t int32_t、uint32_t int64_t、uint64_t DWORD DWORD32、DWORD64 size_t、ssize_t SIZE_T、SSIZE_T 一、原生数据类型以下数据类型C&#x2F;C++语言中的原生整数类型，其长度取决于所使用的计算机系统和编译器： short、unsigned short int、unsigned int long、unsigned long long long、unsigned long long 如果需要开发跨平台的、具有良好可移植性的程序，请不要使用这些数据类型。通常情况下，这些数据类型所占字节数如下表所示： 数据类型 字节数 范围 char 1 -128 ~ 127 unsigned char 1 0 ~ 255 short 2 -32,768 ~ 32,767 unsigned short 2 0 ~ 65,535 int 4 -2,147,483,648 ~ 2,147,483,647 unsigned int 0 0 ~ 4,294,967,295 long 4 -2,147,483,648 ~ 2,147,483,647 unsigned long 4 0 ~ 4,294,967,295 long long 8 -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 unsigned long long 8 0 ~ 18,446,744,073,709,551,615 我们要知道，C&#x2F;C++ 语言规范并没有明确规定上述类型所占的字节数，具体占用多少字节需要由编译器来决定。例如，虽然大多数主流编译器为了保证32位系统和64位系统的兼容性，在32位和64位编译器中都将int类型定义为4个字节，但这个并不是强制性约束，随时可能改变。 二、int*_t数据类型int*_t格式的数据类型是固定宽度整数类型，在不同的编译器环境下，其所占用的字节数始终相同（即数据范围也相同），适合用来开发跨平台的程序。 数据类型 字节数 范围 int8_t 1 -128 ~ 127 uint8_t 1 0 ~ 255 int32_t 4 -2,147,483,648 ~ 2,147,483,647 uint32_t 4 0 ~ 4,294,967,295 int64_t 8 -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 uint64_t 8 0 ~ 18,446,744,073,709,551,615 三、size_t和std::size_tsize_t和std::size_t是不同的数据类型，size_t是定义在C语言的头文件，而std::size_t定义在C++标准库的&lt;cstddef&gt;头文件中。 虽然二者是不同的数据类型，但std::size_t在实现上兼容size_t了，二者所占的字节数始终相同。 size_t和std::size_t都是无符号整型，它们在32位编译环境占用4字节，64位编译环境占8字节。 如果需要使用有符号的size_t类型，在Linux上可以使用ssize_t类型，Windows上可以使用SSIZE_T类型。 四、DWORD和DWORD32、DWORD64DWORD是32位无符号整型（范围0 ~ 4,294,967,295） DWORD32也是32位无符号整型（范围0 ~ 4,294,967,295）,而DWORD64是64位无符号整型（范围0 ~ 18,446,744,073,709,551,615）。 DWORD为什么一直是32位无符号整型？ 微软在设计之初是打算让DWORD在不同的编译环境具有不同位数的，但从目前情况来看，这种希望已然破灭，DWORD将永远是32位的无符号整型。 五、一点点建议为了保证程序的可移植性，请在开发中只使用固定字节数的数据类型，如int8_t、int32_t、int64_t。","tags":["C++"],"categories":["C++语言"]},{"title":"Windows窗口调试利器-WinSpyPlus","path":"/post/1533480858.html","content":"在Windows平台进行客户端开发时，不可避免的会遇到需要调试窗口的情况，如查看窗口句柄、窗口位置&#x2F;尺寸、监听窗口消息等。虽然微软随 Visual Stuido 一同发布了 Microsoft Spy++ 工具，但该工具的功能更新缓慢，这么多年过去了基本没有什么变化，比如： 一直未提供单独的安装包。 强制以管理员权限启动，虽然以管理员权限启动可以避免很多问题（如无法监听管理员权限进程窗口的消息等），但这让用户失去了选择非管理员的权力。 不能通过标题或类名来查找窗口。 查找到的窗口不能自动定位到窗口树中。 不能过滤是否显示隐藏窗口、是否显示无标题窗口。 不能查看 Message-Only 窗口。 不能定时导出窗口树到文件中，以便做后续的对比分析。 默认启动的时32位进程，无法监听 64 位进程窗口的消息，监听失败时也未能提示用户。 未提供对窗口的快速操作指令，如显示&#x2F;隐藏、最大化&#x2F;最小化&#x2F;还原、置顶&#x2F;置底等。 基于 Microsoft Spy++ 的以上缺陷或不足，我开发了一个款为WinSpyPlus的工具，该工具解决了上述所有问题，而且功能特性还在不断扩充中。 下载地址 Github（更新及时）: https://github.com/winsoft666/winspyplus-bin 奶牛快传（更新可能延后）： https://cowtransfer.com/s/aa5ab9c1ef2e46 软件截图 限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺 您可以通过在 blog-comment 项目中提交Issue来间接地发表评论🍀","categories":["Power By Me"]},{"title":"Windows API的不同返回状态","path":"/post/2510508225.html","content":"在Windows编程中，我们经常接触到的Windows API返回值类型有： BOOL HRESULT LSTATUS 1. 错误码BOOL类型通常是0表示失败，非0表示成功，在BOOL类型返回失败时，通常还可以通过GetLastError函数获取错误码。错误码与调用线程相关联，每个线程的错误码是独立的，在调用完Windows API后，如下获取错误码，则需要立即获取，否则可能会被后面调用API所设置的错误码所覆盖。 应用程序也可以通过SetLastError函数来设置错误码。 Windows API通常在没有错误发生时，将错误码设置为0，有错误发生时，视具体错误而设置为其他非0值。 微软官方文档：Debug system error codes 常见的错误码123ERROR_SUCCESS = 0 // 成功ERROR_OUTOFMEMORY // 内存不足... 2. HRESULT2.1 HRESULT结构HRESULT是COM返回的错误码，总共32位，它由三个基本部分组成： 高1位表示成功或失败（0表示成功，1表示失败）。 中间11位编码指示错误来源的设施&#x2F;设备。 低16位编码错误编号。 0~32位的作用分别如下： 123456789101112131415161718S - 严重度 - 表示成功/失败 0 - 成功 1 - 失败 (COERROR)R - reserved portion of the facility code, corresponds to NT&#x27;s second severity bit.C - reserved portion of the facility code, corresponds to NT&#x27;s C field.N - reserved portion of the facility code. Used to indicate a mapped NT status value.r - reserved portion of the facility code. Reserved for internal use. Used to indicate HRESULT values that are not status values, but are instead message ids for display strings.Facility - 设备/设施码Code - 设备/设施的状态码 在实际开发中，通常不需要关心其每一位的具体作用，我们使用更多的是下面的几个宏： 使用SUCCEEDED(hr)宏判断是否成功（即hr&gt;&#x3D; 0），FAILED(hr)判断是否失败(即hr&lt; 0)。 使用HRESULT_CODE(hr)宏获取错误码。 使用HRESULT_FACILITY(hr)宏获取设备码。 4字节（32位）整数能表示的最大正整数为7FFF FFFFF（最高位为0），当最高位为1时，则为负数。所以HRESULT能通过是否为负数来判断成功与否。 2.2 常见的HRESULT值123S_OK // 成功S_FALSE // 失败E_FAIL // 失败 2.3 API错误码与HRESULT我们可以使用HRESULT_FROM_WIN32宏将上一节介绍的“Windows API的错误码”转成HRESULT。 3. LSTATUS在Windows API中对LSTATUS的定义比较模糊，比如注册表API（如RegCreateEx等）返回的LSTATUS实际就是第一节介绍的Windows错误码。 所以当遇到返回LSTATUS类型的API时，需要参考API的文档说明。","tags":["Windows"],"categories":["Windows编程"]},{"title":"Qt自定义和美化菜单","path":"/post/711494356.html","content":"在Qt中可以通过QSS对菜单进行样式设置，而且对于非标准菜单项我也可以通过自定义Widget的方法来实现，本文讲述在Qt中QMenu的使用方法。 一、菜单基本使用下面示例演示了右键菜单的创建方法，该菜单包含了图标、选中&#x2F;未选中状态、二级菜单、互斥选择等常用菜单特性，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960QIcon settingIcon(&quot;:/MenuBeauty/setting.png&quot;);// 定义ActionsQAction* action1 = new QAction(&quot;动作1&quot;);QAction* action2 = new QAction(settingIcon, &quot;动作2 有图标&quot;);QAction* action3 = new QAction(&quot;动作3 [未选中]&quot;);action3-&gt;setCheckable(true);action3-&gt;setChecked(false);connect(action3, &amp;QAction::triggered, this, [action3](bool checked) &#123; action3-&gt;setText(checked ? &quot;动作3 [选中]&quot; : &quot;动作3 [未选中]&quot;);&#125;);QAction* action4 = new QAction(&quot;Action4 动作四测试&quot;);QAction* action5 = new QAction(settingIcon, &quot;动作5 禁用&quot;);action5-&gt;setEnabled(false);QAction* action6 = new QAction(settingIcon, &quot;动作6 子菜单&quot;);&#123; // 动作6的子动作 QAction* action6_1 = new QAction(&quot;动作6.1&quot;); action6_1-&gt;setCheckable(true); QAction* action6_2 = new QAction(&quot;动作6.1&quot;); action6_2-&gt;setCheckable(true); QAction* action6_3 = new QAction(&quot;动作6.1&quot;); action6_3-&gt;setCheckable(true); // 动作6的子菜单 QMenu* action6SubMenu = new QMenu(this); action6SubMenu-&gt;addAction(action6_1); action6SubMenu-&gt;addAction(action6_2); action6SubMenu-&gt;addAction(action6_3); // 互斥子菜单项，同时只能选择一个 QActionGroup* action6Group = new QActionGroup(this); action6Group-&gt;setExclusive(true); action6Group-&gt;addAction(action6_1); action6Group-&gt;addAction(action6_2); action6Group-&gt;addAction(action6_3); action6-&gt;setMenu(action6SubMenu);&#125;// 定义菜单QMenu* menu = new QMenu(this);// 添加Actionmenu-&gt;addActions(&#123;action1, action2, action3&#125;);menu-&gt;addSeparator();menu-&gt;addActions(&#123;action4, action5, action6&#125;);// 鼠标右键弹出菜单this-&gt;setContextMenuPolicy(Qt::CustomContextMenu);connect(this, &amp;QWidget::customContextMenuRequested, this, [this, menu](const QPoint&amp; pos) &#123; menu-&gt;exec(this-&gt;mapToGlobal(pos));&#125;); 上述菜单未经过任何美化，样式如下图所示： 二、使用QSS美化菜单现在我们使用如下QSS对上面创建的菜单进行美化，可以美化的项包含背景、文本颜色、边距、图标等。 为了使大家不被颜色值所困扰，下面QSS中的颜色统一使用颜色名称表示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* 菜单的属性 */QMenu &#123; border: 1px solod red; /* 圆角生效的前提是菜单窗口背景透明 */ border-radius: 10px; background-color: blue; font-size: 14px; font-family: &quot;Microsoft YaHei&quot;; /* 设置菜单项最小宽度，此处有bug：虽可自动增长但实际宽度比所需宽度小 */ min-width: 160px; /* 菜单内容上下边距为10px，预留圆角区域 */ padding: 10px 0px 10px 0px;&#125;/* 菜单项的属性 */QMenu::item &#123; border: none; background-color: transparent; color: white; /* 设置菜单项最小高度，可以让菜单项的高适应内容自动增长 */ min-height: 20px; /* 设置菜单项最小宽度，此处有bug：虽可自动增长但实际宽度比所需宽度小 */ min-width: 160px; /* 使菜单项之间及菜单项和图标之间保持一定间隔，设置上下左右边距为8px，此处不能用margin */ padding: 8px 8px;&#125;/* 菜单项-鼠标移入时的属性 */QMenu::item:selected &#123; background-color: green; color: black;&#125;/* 菜单项-禁用时的属性 */QMenu::item:disabled &#123; background-color: gray; color: white;&#125;/* 分割线的属性 */QMenu::separator &#123; height: 1px; background-color: red; /* 左右边距：6px */ margin: 0x 6px 0px 6px;&#125;/* 图标的属性 */QMenu::icon &#123; width: 12px; height: 12px; /* 左边距：12px */ margin: 0 0 0 12px;&#125;/* 指示器的属性 *//* 这里将互斥和非互斥Action的指示器样式设置为一样的，也可以设置为不一样 */QMenu::indicator:non-exclusive:checked, QMenu::indicator:exclusive:checked &#123; width: 12px; height: 12px; /* 左边距：8px */ margin: 0 0 0 8px; image: url(:/MenuBeauty/check.png);&#125;QMenu::indicator:non-exclusive:unchecked, QMenu::indicator:exclusive:unchecked &#123; width: 12px; height: 12px; /* 左边距：8px */ margin: 0 0 0 8px; image: url(:/MenuBeauty/unchecked.png);&#125; 为了使菜单的圆角生效，我们还需要移除菜单的边框、阴影，并将背景设置为透明，代码如下： 12345menu-&gt;setWindowFlags(action6SubMenu-&gt;windowFlags() | Qt::FramelessWindowHint | // 无边框 Qt::NoDropShadowWindowHint // 移除系统阴影);menu-&gt;setAttribute(Qt::WA_TranslucentBackground); // 背景透明 美化后的菜单如下图所示： QSS美好QMenuQMenu支持QSS盒子模型，其通用属性如下： 12345678borderborder-radiusmarginpaddingbackgroundcolorfontborder-image QSS还可以对QMenu的子控件进行设置，支持QMenu子控件如下： 1234567itemindicatorseparatorright-arrowleft-arrowscrollertearoff QMenu不支持伪状态，只有其子控件支持伪状态，支持的伪状态如下： 1234defaultselectedexclusivenon-exclusive 具体的子控件和伪状态的含义，可以参考 QSS基本使用方法 文章。 三、自定义菜单项大多数情况下，上述常规的菜单项就可以满足要求，但在有些情况下，我们的菜单项可能由更加复杂的Widget组合而成，比如下面播放器的菜单： 我们可以使用QWidgetAction来实现上述菜单效果，QWidgetAction可以将一个QWidget放入菜单项的容器内，从而实现自定义菜单项。 下面代码定义了一个包含3个按钮的菜单项，点击按钮会弹出对话框： 123456789101112131415161718192021QWidgetAction* action7 = new QWidgetAction(this);&#123; QWidget* widget = new QWidget(); QHBoxLayout* hl = new QHBoxLayout(widget); auto createPushButtonFn = [this](QString title) &#123; QPushButton* btn = new QPushButton(title); connect(btn, &amp;QPushButton::clicked, this, [this]() &#123; QMessageBox::information(this, &quot;Clicked&quot;, ((QPushButton*)sender())-&gt;text()); &#125;); return btn; &#125;; hl-&gt;addWidget(createPushButtonFn(&quot;Button1&quot;)); hl-&gt;addWidget(createPushButtonFn(&quot;Button2&quot;)); hl-&gt;addWidget(createPushButtonFn(&quot;Button3&quot;)); action7-&gt;setDefaultWidget(widget);&#125;menu-&gt;addAction(action7); 效果如图所示： 我们也可以使用QSS对菜单项内的控件进行样式设置，如： 123456QMenu QPushButton &#123; border: none; border-radius: 10px; background-color: black; color: white;&#125;","tags":["Qt","QMenu"],"categories":["Qt"]},{"title":"为什么SetParent会失败","path":"/post/3832058229.html","content":"SetParent是Windows提供的设置窗口父窗体的API，函数原型比较简单： 1234HWND SetParent( [in] HWND hWndChild, [in, optional] HWND hWndNewParent); 我们通常的使用方法是： 123if(!SetParent(hChild, hParent)) &#123; // Failed&#125; 这种使用方法在大多情况下不会失败，但有时却会失败。究其原因，其在微软官方文档中已有说明SetParent Doc。 由于兼容性问题，SetParent函数不会修改hWndChild窗口的WS_CHILD和WS_POPUP样式，因此： 如果hWndNewParent为NULL，你需要在调用SetParent函数后清除WS_CHILD并设置WS_POPUP样式。 如果hWndNewParent不为NULL并且hWndChild之前是桌面的子窗口，你需要在调用SetParent函数前清除WS_POPUP并设置WS_CHILD样式。 总结上述原因，SetParent的正确使用方法如下： 123456789101112131415161718192021222324bool SetWinParent(HWND hChild, HWND hNewParent) &#123; HWND hOldParent = NULL; if (hNewParent) &#123; LONG newStyle = GetWindowLong(hChild, GWL_STYLE); newStyle &amp;= ~WS_POPUP; newStyle |= WS_CHILD; SetWindowLong(hChild, GWL_STYLE, newStyle); hOldParent = ::SetParent(hChild, hNewParent); &#125; else &#123; hOldParent = ::SetParent(hChild, hNewParent); LONG newStyle = GetWindowLong(hChild, GWL_STYLE); newStyle &amp;= ~WS_CHILD; newStyle |= WS_POPUP; SetWindowLong(hChild, GWL_STYLE, newStyle); &#125; return !!hOldParent;&#125;","tags":["窗口样式"],"categories":["Windows编程"]},{"title":"窗口如何逃脱显示桌面指令","path":"/post/2065788833.html","content":"在 Windows 系统中，我们按下 Win+D 快捷键执行“显示桌面”时，会将桌面上的所有窗口都最小化到任务栏，再次按下还会还原窗口状态。如果在执行显示桌面操作时，有些窗口仍然保持显示状态，不被最小化，这些窗口称之为逃脱了显示桌面指令。 实现逃脱显示桌面的方式有三种，每种方式有不同的应用场景。 一、置顶窗口的方式首先创建 WS_EX_TOOLWINDOW 风格的窗口，WS_EX_TOOLWINDOW 风格的窗口不会出现在任务栏，而且按ALT+TAB时也不会显示，然后为该窗口设置 WS_EX_TOPMOST 样式，使其始终置顶。 可以在创建窗口时通过扩展样式来指定WS_EX_TOOLWINDOW和WS_EX_TOPMOST样式： 12345678910111213HWND hWnd = CreateWindowExW( WS_EX_TOOLWINDOW | WS_EX_TOPMOST, szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); 也可以先创建窗口，然后修改窗口样式： 1234LONG_PTR oldStyle = GetWindowLongPtr(hWnd, GWL_EXSTYLE);oldStyle |= WS_EX_TOOLWINDOW;SetWindowLongPtr(hWnd, GWL_EXSTYLE, oldStyle); 并通过SetWindowPos函数来置顶窗口： 1SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE); 这种方式对系统的兼容性比较好，经测试可以支持Windows XP&#x2F;7&#x2F;8&#x2F;10&#x2F;11系统。但这种方式会导致窗口一直置顶显示，对于不需要置顶显示的窗口，这种方式就不适用了。 二、改变窗口所有者的方式在执行显示桌面指令时，桌面仍然会显示，因此我们可以将窗口的所有者设置为桌面窗口，来确保窗口不受“显示桌面”指令的影响。 2.1 查找桌面窗口在Win7及之前的系统中，桌面窗口是Program Manager窗口的子窗口，如下图所示： 而在Win8及以后的系统，桌面窗口变成了WorkerW窗口的子窗口，如下图所示： 因此在查找桌面窗口句柄时，需要根据不同的系统环境采用不同的查找方式。 123456789101112131415161718192021HWND FindShellDefViewWnd() &#123; HWND hShellDefView = nullptr; // Try Win7 and later HWND hProgmanWnd = FindWindowW(L&quot;Progman&quot;, L&quot;Program Manager&quot;); if (hProgmanWnd) &#123; hShellDefView = FindWindowExW(hProgmanWnd, NULL, L&quot;SHELLDLL_DefView&quot;, NULL); &#125; // Try &gt; Win7 if (!hShellDefView) &#123; // When this fails, then look for the WorkerW windows list to get the correct desktop list handle. HWND hDesktop = GetDesktopWindow(); HWND hWorkerW = NULL; do &#123; hWorkerW = FindWindowExW(hDesktop, hWorkerW, L&quot;WorkerW&quot;, NULL); hShellDefView = FindWindowExW(hWorkerW, NULL, L&quot;SHELLDLL_DefView&quot;, NULL); &#125; while (hShellDefView == NULL &amp;&amp; hWorkerW != NULL); &#125; return hShellDefView;&#125; 2.2 设置窗口拥有者现在我们将窗口的拥有者设置为SHELLDLL_DefView窗口即可逃脱显示桌面的指令了。 12345678bool EscapeShowDesktop(HWND hWnd) &#123; HWND hShellDefView = FindShellDefViewWnd(); if (hShellDefView) &#123; SetWindowLongPtr(hWnd, GWL_HWNDPARENT, (LONG_PTR)hShellDefView); return true; &#125; return false;&#125; 需要注意： 采用这种方式可能会导致当前的活动桌面发生改变，这个行为会对某些Windows API产生影响，如会导致GetAsyncKeyState失效。 三、使用Appbar机制实现Windows提供了API来使应用程序具有模拟系统任务栏的能力，通常将模拟系统任务栏的程序成为Appbar（application desktop toolbar）。Appbar窗口不受显示桌面指令的控制，但该窗口会和任务栏一样占据一部分桌面可用空间，可以通过API控制占用空间的大小和位置。 关于如何使用Appbar的API，可以参考Windows官方文档:Using Application Desktop Toolbars","tags":["窗口样式"],"categories":["Windows编程"]},{"title":"认识Windows顶级(top-level)窗口","path":"/post/1431775047.html","content":"在Windows API中经常会出现关于顶级窗口的描述，如 EnumWindows函数的说明： Enumerates all top-level windows on the screen by passing the handle to each window, in turn, to an application-defined callback function. EnumWindows continues until the last top-level window is enumerated or the callback function returns FALSE. 那么什么样的窗口才算得上是顶级窗口了？ 简而言之，就是没有WM_CHILD属性的窗口都可以称为顶级窗口。","tags":["窗口样式"],"categories":["Windows编程"]},{"title":"Qt中图片按九宫格模式缩放","path":"/post/333631906.html","content":"我们在缩放图片时，都期望能保持图片的原长宽比，因为这样可以防止图片变形，但往往事与愿违，有些时候我们没办法保持原图的长宽比不变，比如需要在保持图片高度不变的情况下，仅横向拉伸图片，此时就会导致图片变形。 为了解决这种问题，我们可以考虑使用九宫格模式进行图片的缩放。 九宫格模式就是将图片切分为九块（不强制切分的每一块必须等分），如下图所示，在图片缩放时，我们通常保持1、3、7、9四个顶点位置的图片不变，对2、4、5、6、8五个区域进行缩放。 1. 使用QSS实现在Qt中实现图片按九宫格缩放最简单的方法是使用QSS的border-image属性来实现，通过上下左右四个边框的宽度或高度来设置1、3、7、9四个顶点的大小。 12345border-image: url(:/Sample/image/NinePatchTest.png);border-left: 210px;border-top: 180px;border-right: 300px;border-bottom: 227px; 为了便于测试，我制作了一个九宫格测试图片（整个图片的宽高为1280*720）： 通过这种方法实现的九宫格缩放有一个弊端： 该方案会始终保持1、3、7、9四个区域图片的宽高不变，如1号区域是210*180，当我们对图片进行放大时，这个行为是没有问题的，但当我们缩小图片时，缩小后的图片宽高不足以容纳4个顶角图片时，缩小操作就会出现非预期的行为，可能如下图所示： 这种弊端还会体现在支持高DPI缩放的Qt程序中，例如在一个支持DPI缩放的程序中，为宽高为640*360的QWidget设置背景图片，我们知道不同的 devicePixelRatio 会导致实际渲染的图片宽高不同，如devicePixelRatio为1时，图片渲染区域为640*360， 而devicePixelRatio为2时，实际渲染区域为1280*720，为了保证程序在不同DPI的环境下都有比较好的界面呈现，我们通常简单得指定一个倍图（如2倍图）让程序自动进行图片缩放（当然也可以使用SVG或针对不同DPI使用不同的图片）。 而使用 border-left 等属性指定的宽度是固定的，顶点图片无法参与到自动缩放中来，从而会导致这一 DPI 适配机制失效。下一节介绍的方法可以解决这一弊端。 2. 使用代码实现九宫格缩放本节介绍如何使用代码来实现九宫格模式缩放图片，实现原理大致如下： 提取九个区域的图片，保持1、3、7、9四个图片不变，对2、4、5、6、8五个区域图片进行缩放，分别得到新的图片，最后再将九个区域的图片合并成一张图。 为了解决上述QSS方案的弊端，我们可以采取先将图片在保持长宽比的情况缩放到相应尺寸： 1QPixmap keepRatioScaledPix = src.scaled(destSize, Qt::KeepAspectRatio, Qt::SmoothTransformation); 由于keepRatioScaledPix实际尺寸肯定与我们想要得到的destSize不匹配，所以我们再把keepRatioScaledPix图片按九宫格模式缩放。 具体实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384QPixmap ScaleByNinePatch(const QPixmap&amp; src, // 原图 QSize destSize, // 目标尺寸 bool keepVertexImageSize, // 是否保持1、3、7、9顶点图片大小不变，设置为true则与QSS方式效果类似（仅类似，因为该函数是直接返回原图） int pos1Width, int pos1Height, int pos3Width, int pos7Height, Qt::TransformationMode mode = Qt::SmoothTransformation) &#123; // 参数校准 pos1Width = qMax(pos1Width, 0); pos1Height = qMax(pos1Height, 0); pos3Width = qMax(pos3Width, 0); pos7Height = qMax(pos7Height, 0); int handlePixW = 0, handlePixH = 0; const QPixmap* handlePix = nullptr; QPixmap keepRatioScaledPix; if (keepVertexImageSize) &#123; // 保持顶点图片大小不变的情况，如果顶点图片宽或高已经大于了目标宽高，则直接返回原图 if (pos1Width + pos3Width &gt; destSize.width() || pos1Height + pos7Height &gt; destSize.height()) return src; handlePixW = src.width(); handlePixH = src.height(); handlePix = &amp;src; &#125; else &#123; const qreal srcW = src.width(); const qreal srcH = src.height(); // 先等比缩放到适合的尺寸 keepRatioScaledPix = src.scaled(destSize, Qt::KeepAspectRatio, mode); handlePixW = keepRatioScaledPix.width(); handlePixH = keepRatioScaledPix.height(); qreal krsPixWidth = handlePixW; qreal krsPixHeight = handlePixH; // 按照之前的比例获取新顶点图片的大小 pos1Width = krsPixWidth * (qreal)pos1Width / srcW; pos1Height = krsPixHeight * (qreal)pos1Height / srcH; pos3Width = krsPixWidth * (qreal)pos3Width / srcW; pos7Height = krsPixHeight * (qreal)pos7Height / srcH; handlePix = &amp;keepRatioScaledPix; &#125; // 提前各个区域图片 QPixmap pix1 = handlePix-&gt;copy(0, 0, pos1Width, pos1Height); QPixmap pix2 = handlePix-&gt;copy(pos1Width, 0, qMax(handlePixW - pos1Width - pos3Width, 0), pos1Height); QPixmap pix3 = handlePix-&gt;copy(qMax(handlePixW - pos3Width, 0), 0, pos3Width, pos1Height); QPixmap pix4 = handlePix-&gt;copy(0, pos1Height, pos1Width, qMax(handlePixH - pos1Height - pos7Height, 0)); QPixmap pix5 = handlePix-&gt;copy(pos1Width, pos1Height, qMax(handlePixW - pos1Width - pos3Width, 0), qMax(handlePixH - pos1Height - pos7Height, 0)); QPixmap pix6 = handlePix-&gt;copy(qMax(handlePixW - pos3Width, 0), pos1Height, pos3Width, qMax(handlePixH - pos1Height - pos7Height, 0)); QPixmap pix7 = handlePix-&gt;copy(0, qMax(handlePixH - pos7Height, 0), pos1Width, pos7Height); QPixmap pix8 = handlePix-&gt;copy(pos1Width, qMax(handlePixH - pos7Height, 0), qMax(handlePixW - pos1Width - pos3Width, 0), pos7Height); QPixmap pix9 = handlePix-&gt;copy(qMax(handlePixW - pos3Width, 0), qMax(handlePixH - pos7Height, 0), pos3Width, pos7Height); // 对2、4、5、6、8区域图片进行缩放 pix2 = pix2.scaled(qMax(destSize.width() - pos1Width - pos3Width, 0), pos1Height, Qt::IgnoreAspectRatio, mode); pix4 = pix4.scaled(pos1Width, qMax(destSize.height() - pos1Height - pos7Height, 0), Qt::IgnoreAspectRatio, mode); pix5 = pix5.scaled(qMax(destSize.width() - pos1Width - pos3Width, 0), qMax(destSize.height() - pos1Height - pos7Height, 0), Qt::IgnoreAspectRatio, mode); pix6 = pix6.scaled(pos3Width, qMax(destSize.height() - pos1Height - pos7Height, 0), Qt::IgnoreAspectRatio, mode); pix8 = pix8.scaled(qMax(destSize.width() - pos1Width - pos3Width, 0), pos7Height, Qt::IgnoreAspectRatio, mode); // 拼接新的图片 QPixmap dest(destSize); dest.fill(Qt::transparent); // 使用透明色填充图片 QPainter painter(&amp;dest); painter.drawPixmap(0, 0, pix1); painter.drawPixmap(pos1Width, 0, pix2); painter.drawPixmap(qMax(destSize.width() - pos3Width, 0), 0, pix3); painter.drawPixmap(0, pos1Height, pix4); painter.drawPixmap(pos1Width, pos1Height, pix5); painter.drawPixmap(qMax(destSize.width() - pos3Width, 0), pos1Height, pix6); painter.drawPixmap(0, qMax(destSize.height() - pos7Height, 0), pix7); painter.drawPixmap(pos1Width, qMax(destSize.height() - pos7Height, 0), pix8); painter.drawPixmap(qMax(destSize.width() - pos3Width, 0), qMax(destSize.height() - pos7Height, 0), pix9); painter.end(); return dest;&#125; 调试小技巧： 可以把每个区域的图片保存到本地，查看图片是否正确，如： 123456789pix1.save(&quot;D:\\\\1.png&quot;);pix2.save(&quot;D:\\\\2.png&quot;);pix3.save(&quot;D:\\\\3.png&quot;);pix4.save(&quot;D:\\\\4.png&quot;);pix5.save(&quot;D:\\\\5.png&quot;);pix6.save(&quot;D:\\\\6.png&quot;);pix7.save(&quot;D:\\\\7.png&quot;);pix8.save(&quot;D:\\\\8.png&quot;);pix9.save(&quot;D:\\\\9.png&quot;); 限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺 您可以通过在 blog-comment 项目中提交Issue来间接地发表评论🍀","tags":["Qt","九宫格"],"categories":["Qt"]},{"title":"小懒（转载）","path":"/post/2501563677.html","content":"人生于世，一味勤，不见得是好事。 与人处，得小懒。管头管脚，大到原则问题，小至鸡毛蒜皮，样样都想插一手。这样的相处模式，除了惹人厌，再难有其他结果。容他人藏点隐私，给彼此留点空间，这样的小懒，比起所谓的无微不至更令人欣赏。 与人言，也得小懒。话不能说得太满，意犹未尽之处，于人于已都是余地。留有这样的余地，日后才好转圜。同样的意思，横冲直撞与婉转留余，可能带来不同的结果。留一线，好相见，这样的留，自然是小懒。 言语中的小懒，还在于倾听。话不说满，这满是话意，也是话频。一味照着自己的频率说，不顾对方的感受，也不理会对方的想法。这种单方面的所谓沟通，比起无言的槛尬，更令人心生庆烦。话不能说得太满，也不能说得太勤，时时带着点小懒，关注对方的心思，给对方表达的机会，这才是两相宜的沟通方式。 独处，也得带点小懒。忙忙碌碌，俗务缠身，这是很多人的常态。但再忙，总得有那么一些时光，一个人，一本书，一盏茶，静享闲暇之乐。紧绷与小懒，劳与逸，两相结合，人生的路才能走得更远。 养儿育女，其实也需要小懒。能干的父母，容易养出懒情的儿女。事无巨细，大包大揽，自然会让儿女养成依赖的习惯。久而久之，习惯就成了本性。到那时，再怎么怨叹，也无济于事。 人生的小懒，不同于彻底躺平的大懒，也不是任由本性的放纵。一路奔跑之余，总得留有那么一点儿时光，来放任自己的小懒。这样的小懒，如春日的阳光，又似秋日的微风，不多不少，却刚刚好。 作者：郭华悦","categories":["剪切板"]},{"title":"MSVC版本的二进制兼容性","path":"/post/3437796039.html","content":"Visual Studio 2013 及更早版本中的 Microsoft C++ (MSVC) 编译器工具集不保证主版本间的二进制兼容性，无法链接由不同版本工具集生成的对象文件、静态库、动态库和可执行文件，因为ABI、对象格式和运行时库不兼容。 微软在 Visual Studio 2015 及更高版本中改变了这个行为。对于自 Visual Studio 2015 以来的所有版本（该版本号都以 14 开头，如Visual Studio 2015、2017、2019 和 2022工具集的版本分别为 v140、v141、v142 和 v143）由其中任一版本编译器编译的运行时库和应用都具有二进制兼容性。 假设你使用 Visual Studio 2015 生成第三方库，你仍可在 Visual Studio 2017、2019 或 2022 生成的应用程序中使用它们，无需使用匹配工具集重新编译。 同时最新版本的 Microsoft Visual C++ 可再发行程序包（运行时库）也兼容所有老版本，无需为不同版本安装不同的运行时库，统一安装最新版本即可。 对二进制兼容性的限制v140、v141、v142 和 v143 工具集与次要版本号更新之间的二进制兼容性方面存在三个重要限制： 你可以混合使用由 v140、v141、v142 和 v143 工具集的不同版本生成的二进制文件。 但是，必须使用至少与应用中最新二进制文件同样新的工具集进行链接。 下面是一个示例：可以将使用任何版本的v141工具集（版本 15.0 到 15.9）编译的应用链接到使用 Visual Studio 2019 版本 16.2 (v142) 编译的静态库。 只是必须使用版本 16.2 或更高版本工具集链接它们。只要使用 16.4 或更高版本工具集，便可以将版本 16.2 库链接到版本 16.4 应用。 应用使用的可再发行程序包具有类似的二进制兼容性限制。 混合使用由工具集的不同受支持版本生成的二进制文件时，可再发行程序包版本必须至少与任何应用组件使用的最新工具集一样新。 使用 &#x2F;GL（全程序优化）编译器开关编译或是使用 &#x2F;LTCG（链接时间代码生成）链接的静态库或对象文件不在各个版本间二进制兼容（包括次要版本更新）。 使用 /GL 和 /LTCG 编译的所有对象文件和库必须将完全相同的工具集用于编译和最终链接。 例如，使用 Visual Studio 2019 版本 16.7 工具集中的 /GL 生成的代码无法链接到使用 Visual Studio 2019 版本 16.8 工具集中的 /GL生成的代码。 编译器会发出错误 C1047。 从 Visual Studio 2015 及更高版本升级 Microsoft Visual C++ 可再发行程序包对于 Visual Studio 2015、2017、2019 和 2022，微软将 Microsoft Visual C++ 可再发行程序包的主版本号保持一致。 这意味着我们一次只能安装可再发行程序包的一个实例。 较新版本会覆盖已安装的任何较旧版本。 例如，一个应用可能会从 Visual Studio 2015 安装可再发行程序包。 随后另一个应用从 Visual Studio 2022 安装可再发行程序包。 2022 版本会覆盖较旧版本，但由于它们具有二进制兼容性，早期应用仍可正常工作。 微软确保最新版本的可再发行程序包具有所有最新的功能、安全更新和 bug 修补程序。 这便是为什么微软始终建议升级到最新可用版本。 同样，已安装了较新版本时，无法安装较旧的可再发行程序包。 如果尝试，则安装程序会报告错误。 如果在已具有 2022 版本的计算机上安装 2017 或 2019 可再发行程序，则会看到如下所示的错误： 10x80070666 - Another version of this product is already installed. Installation of this version cannot continue. To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel. 此错误是微软故意这样设计的，以确保Microsoft Visual C++ 可再发行程序包为最新版本。 本文参考：Visual Studio 版本之间的 C++ 二进制兼容性","tags":["ABI","运行时库","MSVC","Visual Studio"],"categories":["C++语言"]},{"title":"Vcpkg使用仓库最新代码","path":"/post/2065175920.html","content":"在向Vcpkg提交port时，我们会不断地对仓库进行修改和调试。如果采用REF方式指定源码版本，则需要不断地修改REF和SHA512，调试起来比较繁琐，我们可以采用HEAD_REF的方式来简化调试流程。 在portfile.cmake文件中指定HEAD_REF，如： 123456vcpkg_from_github( OUT_SOURCE_PATH SOURCE_PATH REPO winsoft666/ashe HEAD_REF main AUTHORIZATION_TOKEN $ENV&#123;GITHUB_TOKEN&#125;) 安装时指定--head参数： 1vcpkg install ashe:x64-windows-static --head","tags":["CMake","Vcpkg","Github"],"categories":["CMake"]},{"title":"CMake按目录层级进行分组","path":"/post/1531265402.html","content":"为了提高项目的可维护性，我们通常会将不同用途的代码文件放到不同的文件夹中，如头文件放到include目录，源文件放到src目录，第三方库放到3rd目录等。 当使用CMake生成Visual Studio工程时，我们亦希望在Visual Studio中能看到这样的文件结构。当然，我们可以使用source_group指令进行添加，但当目录和层级很多时，这样添加起来就显得比较繁琐了，本文介绍一种懒人方法。 函数group_sources用于遍历传入文件并根据文件所在目录添加source_group指令。 1234567891011121314151617function(group_sources) foreach(_source IN ITEMS $&#123;ARGN&#125;) if (IS_ABSOLUTE &quot;$&#123;_source&#125;&quot;) file(RELATIVE_PATH _source_rel &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot; &quot;$&#123;_source&#125;&quot;) else() set(_source_rel &quot;$&#123;_source&#125;&quot;) endif() # 获取文件所在目录 get_filename_component(_source_path &quot;$&#123;_source_rel&#125;&quot; PATH) # 替换为Windows路径样式 string(REPLACE &quot;/&quot; &quot;\\\\&quot; _source_path_msvc &quot;$&#123;_source_path&#125;&quot;) source_group(&quot;$&#123;_source_path_msvc&#125;&quot; FILES &quot;$&#123;_source&#125;&quot;) endforeach()endfunction() 函数group_sources支持传入多个参数，使用方法如下： 12345file(GLOB_RECURSE HEADER_FILES ./include/*.hpp ./include/*.h)file(GLOB_RECURSE SOURCE_FILES ./src/*.cc ./src/*.cpp)# 安装目录层级对$&#123;HEADER_FILES&#125;和$&#123;SOURCE_FILES&#125;中的文件进行分组group_sources($&#123;HEADER_FILES&#125; $&#123;SOURCE_FILES&#125;)","tags":["CMake"],"categories":["CMake"]},{"title":"做人做事做管理【转载】","path":"/post/1719474789.html","content":"大道至简，越是根源和基本的问题，道理实际上越简单。关于如何做人、做事、做管理的书很多，我看得不多，但是我觉得这些书更多是侧重技术和实现细节上的，而很少从人的思想和观念去讲。从实际根本上去说，如何做人做事是世界观的问题，也是一个哲学话题。很多人和我一样，已经到了30的年纪，是需要去思考一下应该如何做人如何做事的，也需要一套简单、有效、完整的体系来指导自己，而这套体系将是让自己安身立命于这个世界的基石。 职场上如何做人关于在职场上如何做人，我只谨记两个字－－服务。 你要把自己当成一个品牌去爱惜，当成一家公司去经营，你要牢牢记住你之所以能在一家公司立足，是因为公司需要你的服务。 我们经常会抱怨某某银行的工作人员服务态度不好、某某商品的售后服务不好，但从来不去思考自己对公司的服务好不好？公司的任务有没有如期完成，有没有哪个任务是提前完成的，是否所有任务都拖到“最后期限”？工作完成的够不够彻底，是不是答复已经完成了，结果后面又出状况？完成后有没有向上级反馈，是不是等到上级问你完成了没有，你才去报告进度？拖延的任务有没有持续跟进，是不是上级不追了这个任务最后就不了了之了？上面这些问题我都是反复遇见，其实根本原因就是没有意识到你其实在做一项服务，你在公司的发展前景，全都取决你对公司的服务够不够好。设想一下，如果交给你的每件事情都可以迎刃而解、化险为夷，让人感觉稳妥、放心、踏实，你自然会收到更多更重要的“订单”。当你的单多到你忙不过来的时候怎么办？招下属啊，呵呵，恭喜你，你已经是领导了（当然我们也要排除极少数的任人唯亲的公司，大局面是积极向上的）。反之，如果给你一件事情你要拖延，给你一件事情你办不好，给你一件事情就没了下文了，让人不放心，久而久之你就“无单可做”了，那么公司重新请一个人就可以了，干嘛非要用你呢？ 服务不光是对于自己供职的公司，对于公司的客户也是一样的。每一次去客户那里出差前，我总是再三叮嘱自己，我此次之行是为客户做服务的，是去为客户解决问题的。这个心态非常重要，我们做软件系统的，去见客户除了做演示、做培训，很多时候就是处理现场问题，难免遇到客户对系统的投诉，比如系统速度慢、bug多等问题。当你有了这样的心态，你就会谦虚地接受客户的批评，细致地记录客户提出的问题，然后一项项地去思考如何解决，并且应该给客户一份详尽的解决方案。有了这样的心态，你会不自觉地、自然而然地与客户站在一边，让他感到你是在为他着想，帮助他去解决问题的。在你面对客户时，应该有这样一个虔诚的信念：我是去为客户服务的，为他解决他所解决不了的问题的。如果你没有这样的心态，面对投诉很可能就会产生厌烦，而且容易为自己的问题进行辩解。这种做法给客户的感觉就是你竭力在证明你是对的他是错的，这样你就站在客户的对面了。 在客户面前的表现对你的职场发展也是非常有好处的，尤其是接触到一些跨国企业时，你优良的职业素养会为你赢来客户的认同与尊敬。这样当你哪天希望寻找更高的平台，只要放个口风出去，立即就会有Offer了。所以认真服务好客户只赚不赔。 职场上如何做事关于如何做事，也有很多的理论，比如要事第一，把事情分为紧急、重要等等，这些我都不讨论了，我只就我自己的经验来谈一谈。 对于如何做事，我也恪守一个信条：不焦不燥，把心沉下去，将注意力集中于要解决的问题上。 我看过这样一个故事，是说从前有一户人家，家里的菜园中有一块大石头，经常会有人不小心撞到；儿子就问：为什么不把他挖走呢？他的爸爸说：这个石头爷爷的时代就有了，就是因为它那么大，不好挖才一直在那里；又过了一代人，家里的一个媳妇实在受不了，就扛着锄头去挖了，她已经做好了心理准备要挖几天的时间，结果一天就挖完了… …原来那个石头的中间是空的。 我们遇到的很多事情也是一样的，看似棘手、难以解决，实际上只要你认真地去分析、去思考，然后放手去做，往往并没有想象中的那么困难。你需要克服心中的顽石。我发现一些人遇到问题后，很轻易地就会说：这个我做不了，这个实现不了，这个我也没办法。其实就好像看到这块大石头一样，被它的“外表”吓住了，而放弃了应有的行动。 而且我发现了一个有趣的现象，不管多么困难的问题，只要你沉下心去思考如何解决，就好像在冥冥之中上苍在看着你一样，当你拼到最后就要打算认输的时候，往往会出现新的契机和方法。 另外，我发现有些人遇到问题的时候，他想的是这件事如何困难如何难以完成，这样的思维方式是有问题的，是一种保守且退缩的思维；遇到问题的时候，想的应该是如何才能够完成。我一般采取这样几个步骤：1、列出所有的可能性；2、分析各种可能性；3、选择一种实现起来最简单、快速的可能性；4、去实现。 除此以外，我发现一些人在做事的时候，会以“这样做很麻烦”来作为不采纳方案的理由，而不是“这样是否必要”或者“这样是否更好”来作为标准，实际上“麻烦”应该是排在“是否必要”、“是否更好”后面进行考虑的。如果一种实现方式，虽然麻烦，但是很有必要，且对客户来说更好，那么就算麻烦也要去做。但是程序员往往关心的是会不会很麻烦，是不是要修改很多地方，是不是给自己带来很多工作量… …告诉你，你关心的这些不是最重要的。 职场上如何做管理和上面一样，做管理也有很多的细节，我也都不谈了，因为这些都是一本书一本书的讲，而我觉得要简单、有效、好操作，所以我也只说三点。 我觉得做好一个技术经理，只要下面的三点就好了： 1、德行德行其实就是品德，简单地讲就是要善良、诚恳。最重要的，你做事的出发点要是好的，对别人是没有坏心的。 为什么说出发点一定要是好的呢？我们还是以服务客户的例子来说，在为客户解决问题的时候，如果我们的出发点是好的，是站在客户一边尽心尽力去为客户解决问题的，那么即便由于方法、能力、条件等各方面的原因，事情搞砸了或者没有做好，也很容易获得客户的理解和原谅。很可能的情形是，你就算做失败了也一样赢得客户；相反，如果你的出发点是“省麻烦”，“赶紧交差了事”，“完成任务”，如果事情做成了也就算了，一旦失败了，你看看客户会怎么样？告诉你，好的客户会批评你、投诉你，因为他对你还有期望；更多的客户是什么话也不说，直接换个供应商就是了，才懒得理你。 记住永远不要把客户当成傻瓜，你是如何做事情的，客户是很容易感受得到的。所以，面对和服务客户没有那么多的技巧，你不需要有多好的口才和魅力，也用不着忽悠和夸大其词(我发现很多销售人员都是这样，你可以骗客户一次，但就没有第二次了)，你只需要放下身段，兢兢业业地为客户着想，设身处地地解决他的问题就可以。对待下属也是一样的，你对他的奖励也好，惩罚也好，出发点一定要是好的。我对待下属遵循的原则就是：我是在帮助你，帮你把工作做的更好，帮你获得更大的提高，而不是说找你茬儿，跟你过意不去，或者是挤兑你压迫你。德行是基本的，有一个好的德行，至少可以保证你的下属不会讨厌你。 这一点放在做产品上仍然有效，做一个好的产品同样不需要那么多的技巧和花样，从用户实际需求出发，想用户所想，做用户想要的，用户自然买单，盈利也是水到渠成的事情。 2、敬业如果有人问我，下属和经理的区别是什么。我会告诉他：下属等着别人交代事情做，经理想着还有哪些事情可以做。 这其实是一个积极心态的问题，作为一个中层干部，你需要将公司的事情当成自己家的事情来处理，当你有这样的心态，你就是再怎么加班都不会有怨言的，即便分文不取… （有谁见过给自己家装修叫苦不迭的？）如果你可以长期保持这样的状态，你的这种献身精神和敬业精神，会很轻易地感染你的下属和你的同事，你会感觉到在公司左右逢源，而且你也会更有话语权，大家会更重视你的意见，同事和下属也会对你报以更多的信任。当这种情况出现时，管理起下属还会困难吗？但需要注意的是，你的敬业精神不是说体现在无休止的加班上，工作异常繁忙、经常性加班其实是工作没有做好的表现之一，加班只应该出现在紧急情况发生的时候，而不应该是一种常态。 3、技术如果有人问我，技术人员和其他人员最大的区别是什么。我会告诉他：技术人员个个自以为是，认为别人的技术都不如自己。 可能大家不爱听，但我观察到的现象就是这样的，而且往往那些自认为懂得很多的人，实际是还没敲开知识的大门。 很少有人愿意去读别人的代码，彼此都觉得写得好烂。所以，如果想赢得技术人员的钦佩，你需要有压倒性的技术能力。这个压倒性的优势，不是下属70分，你80分，而是下属70分，你要做到100分；下属100分，你要做到150分。所以，缺乏技术能力的人去管理技术人员往往是吃力不讨好的，可能下属表面上服从你，心里根本不当你一回事儿，这样管理起来就存在障碍了。当然，如果你的德行非常好，也非常敬业，技术就显得不那么重要了；而如果你已经满足了前面两条，同时技术也很精湛，那自然是锦上添花了。 上面就是一点点心得，欢迎交流。","categories":["项目管理"]},{"title":"Electron判断程序运行环境","path":"/post/612028078.html","content":"Electron官方未提供判断当前程序运行环境的方法。我认为官方不提供这个方法也是说的过去的，因为Electron扮演的是应用开发框架的角色，而运行环境这些东西本身属于开发者自己的事情，有的开发者喜欢定义“开发、测试、预生产、生成”四个环境，而有的开发者却只定义了一个生产环境，这些都不是框架需要参与的事情。 本文提供了几个定义和判断程序运行环境的方法，开发者可以根据实际情况选取相应的方法。 1. app.isPackagedElectron官方提供了app.isPackaged属性来判断应用是否是经过打包的。 app.isPackaged 的原理是判断进程名称是否为 electron 或 electron.exe，如果名称匹配（不区分大小写）则是打包环境。 通常将打包环境当作生产环境，但这并不是强制性的规则。 我们也可以自己通过代码实现判断程序进程名： 123456789101112131415function isProduction() &#123; if (!process.versions.electron) &#123; // Node.js process return false; &#125; if (process.platform === &quot;darwin&quot;) &#123; return !/\\/Electron\\.app\\//.test(process.execPath); &#125; if (process.platform === &quot;win32&quot;) &#123; return !/\\\\electron\\.exe$/.test(process.execPath); &#125; if (process.platform === &quot;linux&quot;) &#123; return !/\\/electron$/.test(process.execPath); &#125;&#125; 2. 根据命令行参数判断通过在不同环境中为程序添加不同的启动参数，然后在运行时校验这些命令行参数来判断当前的运行环境。 在生产环境中不添加任何启动参数，因此没有启动参数的就为生产环境；如果有启动参数，再根据参数判断是否为测试或预发布等环境。 值得注意的是不同的环境添加启动参数的方式不太一样，比如开发环境不需要打包，可以通过下面方式添加： 1electron . --env=development 而非开发环境往往需要打包，需要在命令行中手动添加，如： 1Demo.exe --env=test 判断方法如下： 12345678910111213141516function isProduction() &#123; if (!process.versions.electron) &#123; // Node.js process return false; &#125; for (const v of process.argv) &#123; if (v === &quot;--env=development&quot; || // 开发环境 v === &quot;--env=test&quot; // 测试环境 ) &#123; return false; &#125; &#125; return true;&#125; 3. 通过环境变量判断这个判断方法与方法2类似，不做过多介绍。需要注意的是，Windows和Unix上添加环境变量的方式略有不同。 Windows: 1set APP_ENV=dev &amp;&amp; electron . Unix: 1APP_ENV=dev electron . 在Electron中通过process.env.APP_ENV方式就可以获取到APP_ENV环境变量。","tags":["Electron"],"categories":["Electron"]},{"title":"Electron启动和禁用调试工具的方法","path":"/post/2191045165.html","content":"1. 启用调试工具Electron中打开调试窗口的方法有多种，但前提都需要在创建Browser Window时启用devTools特性，如： 12345678const win = new BrowserWindow(&#123; width: 1080, height: 768, title: &quot;test window&quot;, webPreferences: &#123; devTools: true &#125;&#125;); 启用devTools特性后，可以通过下面几种方式打开调试窗口： 方式1在代码中使用BrowserWindow.webContents.openDevTools()打开调试窗口。 方式2通过快捷键Ctrl+Shift+I打开调试窗口。 方式3在程序的启动命令行中添加--remote-debugging-port=8888参数，然后使用浏览器打开调试页面http://127.0.0.1:8888即可进行调试。 这种方式默认调试的是渲染进程，如需调试主进程则需要使用--inspect=8888参数。 另外，如果打开调试页面时提示WebSockets request was expected而无法显示调试工具，需要使用访问chrome://inspect/打开inspect页面，配置对应的发现ip和端口，如localhost:8888： 配置完成后，刷新inspect页面后在Remote Target中选择对应的调试目标进行调试。 2. 禁用调试工具在软件上线发布时，我们需要在生产环境完全禁用调试工具，此时只需要将devTools属性设置为false即可，如： 12345678const win = new BrowserWindow(&#123; width: 1080, height: 768, title: &quot;test window&quot;, webPreferences: &#123; devTools: false &#125;&#125;); 上面的代码虽然可以禁用调试工具，但在开发环境中，我们往往需要打开调试工具，因此在每次“开发-&gt;发布版本”时都需要来回修改devTools，容易出现漏改的情况。 可以使用Electron判断程序运行环境介绍的方法来判断当前是否为生产环境，启用&#x2F;禁用devTools的代码可以优化为： 12345678const win = new BrowserWindow(&#123; width: 1080, height: 768, title: &quot;test window&quot;, webPreferences: &#123; devTools: !isProduction() &#125;&#125;);","tags":["Electron","DevTools"],"categories":["Electron"]},{"title":"如何在批处理中执行SQL","path":"/post/4169328538.html","content":"示例如下： 123&quot;%~dp0\\mysql-5.6.19-win32\\bin\\mysql.exe&quot; ^ -h127.0.0.1 -P31060 -uroot ^ --execute=&quot;update mysql.user SET password=PASSWORD(&#x27;123456&#x27;) WHERE user=&#x27;root&#x27;;&quot;;","tags":["批处理","MySQL"],"categories":["Windows批处理"]},{"title":"由HANDLE返回值不确定性引发的思考","path":"/post/3906615635.html","content":"HANDLE类型返回值的不确定性指的是Windows API函数的返回值为HANDLE类型时，有两种表示失败的方式： HANDLE &#x3D;&#x3D; NULL，如CreateEvent等 HANDLE &#x3D;&#x3D; INVALID_HANDLE_VALUE，如CreateFile等 其中，NULL的值始终为0，而INVALID_HANDLE_VALUE的值为-1，其在32位和64位程序中分别等于0xFFFFFFFF和0xFFFFFFFFFFFFFFFF。 具体哪些函数失败时返回NULL，哪些返回INVALID_HANDLE_VALUE了？这个需要查阅MSDN文档来确定。 为什么会出现这两种情况了？根据Windows强大的兼容性，我们不能猜测出这么做是为了向前兼容，为了兼容以前的16位程序，所以一直没有改变。 在16位程序中无效的HANDLE值为INVALID_HANDLE_VALUE，在16位程序中-1为0xFFFF，而到了32位（或64位）时代，-1则为0xFFFFFFFF（或0xFFFFFFFFFFFFFFFF）。 所以我们在判断HANDLE是否合法时，要特别留意，需要根据API的不同来做不同的判断。 需要注意GetCurrentProcess()用于获取当前进程的伪句柄，当前进程的伪句柄值是-1，恰好与INVALID_HANDLE_VALUE值相等。 因此用 WaitForSingleObject 等待 INVALID_HANDLE_VALUE 也就是等同于等待当前进程结束。","tags":["句柄"],"categories":["Windows编程"]},{"title":"留言板","path":"/post/2185937873.html","content":"来都来了，那就留下点什么吧！"},{"title":"工具及开源项目集合","path":"/post/3416050985.html","content":"本文汇总了一些由我开发的软件和开源库，无他。 一、工具1.1 1key.run主打一键启动，可以一键启动本地应用、网页搜索，并内置了日历、科学计算、截图、取色、哈希计算等功能。 👉 获取 1key.run 1.2 PortableStarter另一个软件启用器，但 PortableStarter 不访问网络、不读取注册表，是完全可便携的，打造属于自己的便携工具箱。 👉 获取 PortableStarter 1.3 TinyTu跨平台的图片压缩软件，没有文件大小限制，支持PNG、JPG、GIF等图片格式，离线本地压缩，充分发挥机器算力。 👉 获取 TinyTu 1.4 WinSpyPlusMicrosoft Spy++ 的加强版，在保留原功能的基础上新增若干功能。 👉 获取 WinSpyPlus 1.5 QSSEditor用于编辑和预览 Qt 样式表的小工具，使用 Qt 开发，内置了两套完整的样式，方便学习样式表。 👉 获取 QSSEditor 二、库2.1 Zoe跨平台的 C++ 文件下载库，支持多线程分片下载、断点续传、磁盘缓存、速率限制等功能。 👉 获取 Zoe 2.2 Veigar跨平台的基于共享内存的 C++ RPC 框架，区别于大众化的、基于网络的 RPC 框架，veigar 无需面对端口占用、假可用性等问题。 👉 获取 Veigar 2.3 QWebViewQWebView 提供了一个 Qt 小部件来显示网页并与网页交互，支持 CEF 和 Microsoft WebView2 浏览器内核。 全新的CEF集成方式，可以支持任意的CEF版本。 👉 获取 QWebView 2.4 electron-vue3-boilerplate基于 Vue3 + Electron + TypeScript 的客户端程序模板，使用 Vite 和 Electron Forge 构建和打包，做到开箱即用，面向跨平台客户端设计，产品级的项目模板。 解决了大多 Web 开发不懂客户端技术，客户端开发不懂 Web 技术的困扰。 👉 获取 electron-vue3-boilerplate 2.5 NSIS-UI-PluginNSIS UI 插件，提供一种创建漂亮地、现代化地Windows平台安装界面的方式。 👉 获取 NSIS-UI-Plugin 2.6 Qt-FramelessWindow一个相对完美的 Qt 无边框解决方案。 👉 获取 Qt-FramelessWindow","categories":["Power By Me"]},{"title":"窗口无法接收WM_LBUTTONDBLCLK消息","path":"/post/1955778079.html","content":"在开发中遇到了如下问题： 通过鼠标钩子获取某窗口的消息，发现可以接收到鼠标左键按下（WM_LBUTTONDOWN）的消息，但始终无法接收到鼠标左键双击（WM_LBUTTONDBLCLK）的消息。 经过一番排查，发现 Windows 窗口只有在拥有 CS_DBLCLKS 类样式时才能接收到鼠标双击事件，即在 RegisterClassEx 函数的 WNDCLASSEX.style 参数中指定 CS_DBLCLKS 样式。 但是窗口不是我们自己创建的，能否通过 SetClassLongPtr 函数来通过句柄改变窗口类样式，经过多方尝试最终以失败告终（虽然SetClassLongPtr返回值0，GetLastError也为0）。","tags":["窗口消息"],"categories":["Windows编程"]},{"title":"TinyTu-跨平台图片压缩软件","path":"/post/2053741240.html","content":"我平时压缩图片通常会使用类似 tinify 这样的在线压缩网站，这些网站有很多，但使用起来总是感觉不太舒爽，似乎差了点什么，仔细想想它们或多或少有这些缺点： 有的网站需要收费或者半收费。 支持图片格式不全，例如有的网站仅PNG格式，而有的网站又不支持jpg、gif等。 通常还会限制上传图片的数量和大小，毕竟上传和下载都会消耗服务器的网络带宽，网站为了节省成本做出此限制。 图片的压缩速度较慢，毕竟压缩速度越快对服务器的硬件要求越高，成本也会越高。 1. TinyTu这些毛病我已经忍了许久，今天我不想再忍了，经过我一顿折腾（不得不说，想做得好用还得费点心思），一款名为TinyTu的图片压缩软件应运而生。因为TinyTu是本地客户端软件，所以不会限制图片的数量、大小，而且还可以使用本机GPU进行硬件加速，提升图片压缩速度。 TinyTu起来非常方便，不需要额外配置，只需要拖入图片，然后点击“立即压缩”即可。 目前支持的图片格式有： PNG JPEG Gif TTF 不断扩展中… 2. 下载 Github（更新及时） https://github.com/winsoft666/TinyTu-Setup/releases 奶牛快传（更新可能延后） https://cowtransfer.com/s/7a17d7cc96e242 3. 压缩模式TinyTu目前支持图像清晰度优先、普通压缩、极限压缩三个挡位的压缩模式。 这样极大简化了用户设置，用户只需选择某个压缩模式，TinyTu会自动在文件大小和图片质量间进行权衡，达到最理想的压缩效果。 默认值为“普通压缩”，该挡位已可以媲美很多在线网站的压缩效果。 3.1 高级选项如果预设的三种压缩模式无法满足您的需求，或者您想自定义压缩参数，可以通过单击文件列表中的“高级选项”按钮打开选项界面进行配置。 该功能需要输入序列号激活后才能使用。 4. 输出策略TinyTu目前支持三种保存压缩后新文件的方式： 直接覆盖源文件。 这种方式会直接使用压缩后的文件覆盖源文件（即压缩前的文件）。 输出到源目录（默认） 该方式会将压缩后的文件输出到和源文件相同的文件夹，但会在新文件名后添加“TinyTu”尾缀，如test.png压缩后的图片为test_TinyTu.png。 输出到其他目录。 我们也可以选择其他的文件夹作为压缩后文件的输出目录。 5. 跳过已完成文件该选项默认开启。 有这样一种应用场景，我们向列表中添加了5个文件并已压缩完成，此时需要再添加新的文件继续压缩，通过设置该选项TinyTu会跳过之前已经完成的文件，而不需要我们每次添加新文件前都要清空列表。 6. 工作线程数量默认4个线程，可以同时压缩4个文件。 限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺 您可以通过在 blog-comment 项目中提交Issue来间接地发表评论🍀","tags":["TinyTu"],"categories":["Power By Me"]},{"title":"QListWidget使用记录","path":"/post/3168359900.html","content":"1. 解决无法拖入文件到QListWidget一般而言，只需要做如下操作，QWidget即可支持拖入文件： 12345678setDragDropMode(QAbstractItemView::DropOnly); // 仅支持拖入文件// 重写dragEnterEvent，当拖入文件进入时被调用，可以在该函数中取消拖入操作void dragEnterEvent(QDragEnterEvent* e) override;// 重写dropEvent，当拖入文件并释放鼠标时被调用void dropEvent(QDropEvent* e) override; 但在执行上述操作后，我们拖入文件到QListWidget时，却只能收到dragEnterEvent事件，却无法收到dropEvent事件。 因为还需要重写dragMoveEvent方法，如： 123void dragMoveEvent(QDragMoveEvent* e) &#123; e-&gt;acceptProposedAction();&#125; 2. QListWidgetItem自适应尺寸QListWidget添加item的方法如下： 123456QListWidget* list = new QListWidget();// ...QListWidgetItem* item = new QListWidgetItem();list-&gt;addItem(item); 如需要自定义Item的布局，还可以通过自定义Widget来实现，如： 123456789QListWidget* list = new QListWidget();// ...QListWidgetItem* item = new QListWidgetItem();list-&gt;addItem(item);CustomWidget * customWidget = new CustomWidget();list-&gt;setItemWidget(item, customWidget); // 设置Item的自定义Widget 此时，我们还没有为item设置size hint，item会自动根据item的数据（如text）计算size hint。但如果是自定义的Widget，则无法自动计算size hint，需要手动设置size hint，如： 123456int vScrollbarWidth = 0;if (verticalScrollBar()) vScrollbarWidth = verticalScrollBar()-&gt;width();// 减去纵坐标的宽度item-&gt;setSizeHint(QSize(list-&gt;width() - vScrollbarWidth, widget-&gt;height())); QListWidget的滚动条默认显示策略是ScrollBarAsNeeded，当宽度不够显示Item时，滚动条就会显示出来，此时虽然QListWidget宽度改变了，但Item的宽度却不会改变，Item不会收到ResizeEvent事件。如需Item的宽度跟随QListWidget宽度而改变，则需要关闭滚动条显示，并在 QListWidget 的 ResizeEvent 事件中实时设置每个Item的size hint，代码如下： 12// 关闭滚动条list-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff); 123456789101112131415161718void FileList::resizeEvent(QResizeEvent* e) &#123; int vScrollbarWidth = 0; if (verticalScrollBar()) vScrollbarWidth = verticalScrollBar()-&gt;width(); int w = width(); int cnt = count(); for (int i = 0; i &lt; cnt; i++) &#123; QListWidgetItem* it = item(i); if (it) &#123; CustomWidget* customWidget = dynamic_cast&lt;CustomWidget*&gt;(itemWidget(it)); if (customWidget) &#123; it-&gt;setSizeHint(QSize(w - vScrollbarWidth, customWidget-&gt;height())); &#125; &#125; &#125; QListWidget::resizeEvent(e);&#125;","tags":["Qt","QListWidget"],"categories":["Qt"]},{"title":"Qt静态库编译","path":"/post/3406024791.html","content":"使用Qt静态库违背了Qt的免费使用协议！ 1. 编译编译Qt源码需要提前安装如下工具： nasm perl gperf win_flex_bison llvm python2 openssl 2.1 Windows编译为了方便编译，我已将这些工具和打包脚本提交到了我的开源项目qt-source-compile中。 只需克隆项目到本地，选择对应的批处理文件（如msvc2022-5.15.2-x86-static-mt.bat），然后编辑该文件中的qt_src_folder变量（Qt源码路径）和vcvarsall_path变量（Visual Studio路径），最后运行该批处理即可编译。 2. 疑难问题openssl链接失败错误提示如下： 1ERROR: Feature &#x27;openssl-linked&#x27; was enabled, but the pre-condition &#x27;!features.securetransport &amp;&amp; !features.schannel &amp;&amp; libs.openssl&#x27; failed. 上述错误可能是由于指定openssl的include、lib目录最后包含\\导致。","tags":["Qt","编译"],"categories":["Qt"]},{"title":"Windows的DLL全局共享变量","path":"/post/3002178342.html","content":"同一个DLL文件可以被多个进程加载。当不同的进程将DLL映射到自己的内存空间时，系统会为DLL中的全局和静态变量创建不同的实例，而不会共享同一个变量实例。 那我们如何实现在进程间共享DLL全局变量呢？我们可以在DLL中使用如下语句来创建一个段，用来存放那些需要共享的变量： 1234#pragma data_seg(&quot;AnyName&quot;) // 开始// 声明变量// ....#pragma data_seg() // 结束 共享的变量需要被初始化，并且还要设置链接器开关，使该段在所有映射DLL的进程中成为共享读写属性： 12// 共享读写#pragma comment(linker,&quot;/SECTION:AnyName,RWS&quot;) 经过上述操作，共享的变量就可以跨不同进程进行读写操作了。","tags":["DLL","共享变量"],"categories":["Windows编程"]},{"title":"批处理杂记","path":"/post/3801212176.html","content":"1. exitexit命令用于退出当前的批处理脚本，并返回一个退出代码ExitCode（即返回值）。退出代码通常是一个整数，用于指示脚本执行的状态，例如成功（0）或失败（非零值）。 exit命令的语法为： 1exit [/b] [exitCode] 其中 /b 选项表示仅退出当前批处理脚本的执行，而不会影响调用脚本的父进程。如果不使用 /b 选项，则 exit 命令会终止当前整个的命令处理器进程（CMD.EXE），并返回退出代码给调用者。 exitCode 是一个可选参数，用于指定退出代码。如果未指定退出代码，则默认返回上一个命令的退出代码。 2. 变量延迟扩展SETLOCAL ENABLEDELAYEDEXPANSION的作用是设置本地变量延迟扩展。 CMD在执行命令前会对脚本进行预处理，在这个过程中，如果有类似%value%这样的变量就会对其进行识别，并且查找这个变量对应的值，从而用该值替换掉变量，这个替换值的过程，就叫变量扩展，这个类似于C&#x2F;C++中的宏。 请看下面示例： 123@echo offset a=4set a=5 &amp; echo %a% 结果：4 为什么输出是4而不是5呢？ 原因是批处理是按行读取命令的（另外例如for命令等，其后用一对圆括号闭合的所有语句也当作一行），在执行之前要完成必要的预处理工作，这其中就包括对该行命令中的变量赋值。上例中，批处理在运行到set a=5 &amp; echo %a%之前，先把这一整句读取并做了预处理（对变量a赋了值），此时%a%当然就是4。 明白这个道理之后，我们将上例修改为如下方式，就可以输出结果5。 1234@echo offset a=4set a=5echo %a% 为了能够让批处理感知变量的动态变化，批处理设计了变量延迟，即在读取了一条完整的语句之后，不立即对该行的变量赋值，而会在单条语句执行之前再进行赋值，也就是说“延迟”了对变量的赋值。 1234@echo offSETLOCAL ENABLEDELAYEDEXPANSIONset a=4set a=5 &amp; echo !a! 结果：5 由于启动了变量延迟，得到了输出结果5。 变量延迟的启动语句是SETLOCAL ENABLEDELAYEDEXPANSION，并且变量要用一对叹号括起来，否则就没有变量延迟的效果。 3. 调用npm命令无法返回原批处理需要使用call命令，如： 1call npm install 具体原因参考：批处理运行外部程序 可以使用%errorlevel%获取命令的执行结果（通常0表示成功），如： 123456call npm run build-releaseif %errorlevel% NEQ 0 goto ERROR:ERRORecho Compile Failed 4. 切换脚本的当前目录有些命令依赖批处理程序的当前目录，如npm、yarn这样的命令。假如项目位于D:\\A\\B路径，使用批处理（文件位于D:\\build.bat）进行自动构建： 123@echo offcd D:\\A\\Bcall npm run build 运行上面批处理，构建会失败，通常会提示诸如“D:\\package.json不存在”的错误，原因是npm命令是批处理程序的当前目录查找package.json文件的，批处理程序的当前目录默认为批处理文件所在的目录，即D:\\，D:\\package.json不存在，因此构建失败。 可以使用为cd命令指定/d参数来切换批处理程序的当前目录，上面示例可以修改为： 123@echo offcd /d D:\\A\\Bcall npm run build 5. 批处理命令换行当批处理命令过长，如果都写在一行不便于阅读，可以使用^符号进行分割。 123456call &quot;%qt_src_folder%\\configure.bat&quot; -silent -debug-and-release -force-debug-info -strip ^ -platform win32-msvc -static -static-runtime -no-opengl -no-dbus -no-icu ^ -nomake examples -nomake tests -skip qtwebengine -skip qtlocation ^ -qt-harfbuzz -qt-freetype -qt-zlib -qt-doubleconversion ^ -mp -optimize-size -ltcg -no-pch ^ OPENSSL_LIBS=&quot;-lUser32 -lAdvapi32 -lGdi32 -lWS2_32 -lCRYPT32 -llibcrypto32 -llibssl32&quot; 6. ECHO 处于关闭状态遇到“ECHO 处于关闭状态”提示，通常是因为输出变量为空导致。 此时需要注意如下情况： 批处理变量左右不能有空格。如果有空格，空格会被当成变量名，如set a =1，变量名实际为a 。 开启变量延迟扩展后，引用变量需要使用两个!的方式，如!str_a!。 7. 显示选择项提示用户选择使用CHOICE命令可以提供用户在指定的选项中选择一项，并使用%ERRORLEVEL%获取选择的值。 CHOICE命令语法如下： 12345678910111213141516171819202122232425262728293031CHOICE [/C choices] [/N] [/CS] [/T timeout /D choice] [/M text]描述: 该工具允许用户从选择列表选择一个项目并返回所选项目的索引。参数列表: /C choices 指定要创建的选项列表。默认列表是 &quot;YN&quot;。 /N 在提示符中隐藏选项列表。提示前面的消息得到显示， 选项依旧处于启用状态。 /CS 允许选择分大小写的选项。在默认情况下，这个工具 是不分大小写的。 /T timeout 做出默认选择之前，暂停的秒数。可接受的值是从 0 到 9999。如果指定了 0，就不会有暂停，默认选项 会得到选择。 /D choice 在 nnnn 秒之后指定默认选项。字符必须在用 /C 选 项指定的一组选择中; 同时，必须用 /T 指定 nnnn。 /M text 指定提示之前要显示的消息。如果没有指定，工具只 显示提示。 /? 显示此帮助消息。 注意: ERRORLEVEL 环境变量被设置为从选择集选择的键索引。列出的第一个选择返回 1，第二个选择返回 2，等等。 如果用户按的键不是有效的选择，该工具会发出警告响声。如果该工具检测到错误状态，它会返回 255 的ERRORLEVEL 值。 如果用户按 Ctrl+Break 或 Ctrl+C 键，该工具会返回 0的 ERRORLEVEL 值。 在一个批程序中使用 ERRORLEVEL 参数时，将参数降序排列。 如： 1CHOICE /C YNC /M &quot;确认请按 Y，否请按 N，或者取消请按 C。&quot;","tags":["批处理"],"categories":["Windows批处理"]},{"title":"基于Qt的无边框窗体实现","path":"/post/2402568381.html","content":"Qt虽然提供了诸如 Qt::FramelessWindowHint 之类的属性可以移除窗体的边框，但是移除边框之后，窗体的一些默认行为同时也被移除了，如鼠标拖动改变大小、双击标题栏最大化等，这些行为需要开发者自己来实现。 本文主要介绍实现无边框窗体的几种方案，并在最后分享了作者实现的方案。 笔者认为，一个完美的无边框窗体解决方案需要支持如下功能： 支持通过使用鼠标拖拽来改变窗体位置和大小； 支持双击标题栏最大化窗体和还原窗体； 支持 Windows Areo Snap 特性； 支持系统阴影； 支持跨不同 DPI 的屏幕拖拽； 适应分辨率和 DPI 改变； 在Qt中实现无边框窗体有2种方案： 一、Hook方案通过重载 nativeEvent 函数拦截 Windows 消息（如 WM_NCHITTEST）来实现，大致步骤如下： 给窗体设置 WS_THICKFRAME | WS_CAPTION 属性从而还原窗体边框和标题栏，这样窗体就可以接收到 WM_NCHITTEST 消息。 在 WM_NCCALCSIZE 消息处理中再移除边框和标题栏。 在 WM_NCHITTEST 消息处理中通过判断鼠标位置来设置鼠标行为（ HTLEFT, HTRIGHT等）。 这种方案的优点是可以支持Windows Areo Snap和系统阴影的特性，但是针对Windows消息处理起来很复杂而且需要兼容Qt的各个版本，目前我还没有找到一个通过这种方案来完美实现无边框的解决方案。 据我所知，有如下的开源项目是通过这种方式来实现的，但都有些许问题，如不支持跨不同DPI屏幕拖拽、不能适应分辨率和DPI改变、WM_NCHITTEST有时无响应等。另外，在设置了背景透明属性之后（如 Qt::WA_TranslucentBackground），系统阴影特性也将消失。 qtdevs&#x2F;FramelessHelper: https://github.com/qtdevs/FramelessHelper wangwenx190&#x2F;framelesshelper: https://github.com/wangwenx190/framelesshelper 二、纯Qt方案这种方案不Hook windows的 WM_NCHITTEST、WM_NCCALCSIZE 消息，也不改变窗体样式，通过纯Qt方式实现。通过对每个Widget设置MouseTracking，来使每个Widget都可以响应鼠标事件（mouseMoveEvent、mousePressEvent、mouseReleaseEvent等），然后这些事件中判断鼠标位置来设置鼠标的形状和行为。 这种方式虽然对鼠标位置的判断逻辑比较繁琐，但兼容性较好，较纯粹，不需要处理Windows的各个消息。 三、Qt-FramelessWindow👉 我根倾向于使用纯Qt方案，简单、稳定、兼容性好，不用关注那些烦人的Windows消息。针对该方案的实现，可以参考笔者的开源项目【Qt-FramelessWindow】，目前可以支持上述除“Windows Areo Snap”和“系统阴影”特性之外的所有无边框窗体的特性，而且仅有一个头文件，使用起来也非常方便。 Qt-FramelessWindow: https://github.com/winsoft666/Qt-FramelessWindow 限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺 您可以通过在 blog-comment 项目中提交Issue来间接地发表评论🍀","tags":["Qt"],"categories":["Qt"]},{"title":"基于Hexo搭建静态博客","path":"/post/2737986840.html","content":"Hexo是一个快速、简洁且高效的博客框架，使用Hexo可以快速地生成静态博客框架。在框架生成完成后，可以使用任意文本编辑器语法书写博客。我们可以使用Markdown语法书写博客，Hexo在生成博客时会自动将Markdown解析成Html静态页面。 Hexo官网：https://hexo.io/zh-cn/Hexo中文文档：https://hexo.io/zh-cn/docs/ 一、玩法说明使用Hexo写博客的大致流程如下： 生成博客框架 配置博客 选择自己喜欢的主题 配置博客和主题 写文章 生成博客 发布博客到服务器 其中，第1~4步为前置操作，只需要执行一次。 Hexo只负责生成静态的HTML文件，不提供服务器。如需对外发布博客，我们还需将HTML文件部署到服务器上，可以选择如下的方式： Github Pages、GitLab Pages，免费，访问速度较慢。 Gitee Pages，收费。 对象存储服务，如阿里云OSS、腾讯云COS、七牛云OSS等。当访问量大时，需搭配CDN使用，避免因数据回源产生巨额流量费用。 自己购买服务器使用Nginx搭建Web服务器。当访问量大时，服务器出口带宽要求较高，此时仍然需要搭配对象存储服务和CDN使用。 二、生成博客框架2.1 环境准备在搭建博客框架之前，确保电脑上已经安装如下软件（建议安装最新版本的Node.js，这样可以确保兼容最新版本的Hexo）： Node.js Git 2.2 安装Hexo在所有必备的应用程序安装完成后，即可使用 npm 全局安装 Hexo工具： 1npm install -g hexo-cli 2.3 生成博客框架安装 Hexo 完成后，在指定文件夹下执行如下命令，Hexo 将会在目录下新建博客所需的文件： 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 如果遇到网络错误等问题，请排除是否因为访问国外域名失败导致，可以尝试将npm源切换到国内，参考： NPM和Yarn设置国内源 新建完成后，指定文件夹的目录大致如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml 网站的配置文件，可以在此配置大部分的参数，需要区别于主题的_config.yml配置文件。 package.json 应用程序的信息。 scaffolds 模版文件夹。当新建文章时，Hexo会根据scaffold来创建文件。Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果修改 scaffold&#x2F;post.md 中的 Front-matter （即两个---中间的内容）内容，那么每次新建一篇文章时都会包含这个修改。 source 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件&#x2F;文件夹和隐藏的文件将会被忽略。在生成博客时，Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被直接拷贝过去。 themes 主题文件夹。将下载的主题文件放置到该目录，Hexo 会根据主题来生成静态页面。 三、配置博客Hexo的配置分别站点配置和主题配置，站点配置文件为博客根目录下的_config.yml文件，主题配置文件为位于themes\\&lt;主题目录&gt;中的_config.yml文件。 3.1 站点配置本节介绍博客的站点配置，部分配置的含义如下： title\t网站标题 subtitle\t网站副标题 description\t网站描述，主要用于SEO keywords\t网站的关键词。支持多个关键词。 author 作者名字 language\t网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。 timezone\t网站时区。对于中国大陆地区可以使用 Asia&#x2F;Shanghai。 theme\t当前主题名称，名称为themes目录中的子目录名称。值为false时禁用主题。 per_page\t每页显示的文章量 (0 &#x3D; 关闭分页功能)。 pagination_dir\t指定博客生成后，每页的index.html文件存放目录。 3.2 利用Hexo-abbrlink插件生成唯一文章链接Hexo在生成博客文章链接时，默认是按照年/月/日/标题格式来生成的，可以在站点配置文件中指定new_post_name的值，默认是:year&#x2F;:month&#x2F;:day&#x2F;:title这样的格式。如果你的标题是中文的话，你的URL链接还会包含中文。而且当我们修改原文章的日期或标题后，之前生成的链接将会失效。 为了给每一篇文章指定一个唯一的不含中文的链接，可以利用hexo-abbrlink插件，来解决这个问题。 先安装下hexo-abbrlink： 1npm install hexo-abbrlink --save 修改站点配置文件(_config.yml)： 1234permalink: post/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 生成完后原文章.md文件的Front-matter 内会增加abbrlink字段，值为生成的ID。这个字段确保了在我们修改了Front-matter内的title或date字段之后链接地址不会改变。换句话说，就是本篇文章有了自己的专属链接。 当然，也可以选择不同的算法和进制： crc16 &amp; hex https://post.zz173.com/posts/66c8.html crc16 &amp; dec https://post.zz173.com/posts/65535.html crc32 &amp; hex https://post.zz173.com/posts/8ddf18fb.html crc32 &amp; dec https://post.zz173.com/posts/1690090958.html 注意，配置完成之后，之前的文章的链接有可能会变成了undefined，需要执行hexo clean并重新生成部署。 四、配置主题每个主题的配置内容都不一样，具体参考使用主题的帮助文档。我使用的是hexo-theme-matery主题。 4.1 推荐主题 hexo-theme-aircloud hexo-theme-new-yilia hexo-theme-vexo hexo-theme-next hexo-theme-butterfly hexo-theme-volantis hexo-theme-icarus 可以在Github中搜索Hexo Theme发现更多主题。 五、写文章5.1 生成文章使用如下命令生成新的文章: 1hexo new &lt;文章标题&gt; 执行上述命令后，会在source_posts目录下生成对应的.md文件，文件内容如下： 5.2 Front-matterFront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量。Hexo预定义了一些变量，同时每个主题也会定义一些变量。 5.2.1 Hexo预定义变量 title\t标题，默认为文章的文件名 date\t建立日期，默认为文件建立日期 updated\t更新日期，默认文件更新日期 comments\t是否开启文章的评论功能，true&#x2F;false. tags\t标签（不适用于分页），支持多个。 categories\t分类（不适用于分页），支持多个。 permalink\t覆盖文章的永久链接，永久链接应该以&#x2F;或.html结尾。 keywords: 文章关键字，用于SEO。 如： 12345678910111213141516---title: 从汇编的角度分析函数调用过程categories: - C++ - 汇编abbrlink: 4168021185date: 2022-01-21 15:53:01updated: 2023-01-21 15:53:01keywords: - 函数 - C++ - 汇编tags: - C++ - 传参形式--- 5.2.2 hexo-theme-matery主题定义变量 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 hide false 隐藏文章，如果hide值为true，则文章不会在首页显示 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图各有特色。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。 最简示例1234---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00--- 最全示例123456789101112131415161718---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truehide: falsecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags: - Typora - Markdown--- 5.3 引用站内文章语法如下： 1&#123;% post_link slug [title] %&#125; 其中，slug 表示 _post 目录下的 Markdown 文件名。可以通过 title 指定链接标题。 5.4 按钮语法如下： 1&#123;% button /path/to/url/, text, icon [class], [alt] %&#125; 如： 1&#123;% button https://jiangxueqiao.com, 江雪桥的博客, home fa-fw fa-lg, 江雪桥 %&#125; 5.5 插入图片Markdown 并不会保存插入的图片资源本身，只是记录了获取资源的链接。因此我们需要选择一款合适的图床来支持博客写作，目前各大云服务商都提供了对象存储服务，如七牛云 KODO、又拍云 USS、腾讯云 COS、阿里云 OSS 等。 可以使用PicGo工具上传图片到图床上。 5.6 支持emoji表情Hexo默认的 Markdown 渲染器是 hexo-renderer-marked，这个渲染器不支持 emoji 表情。可以利用 hexo-filter-github-emojis插件实现支持 emoji 表情。 安装插件： 1npm install hexo-filter-github-emojis --save 修改站点配置文件（_config.yml）添加如下配置： 123456githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 在emoji-cheat-sheet中找到想要的表情，粘贴到文章中即可。 五、发布使用如下命令生成静态HTML文件： 1hexo g 生成的HTML文件位于博客根目录的public中，将该目录部署中的所有文件部署到服务器即可。","tags":["Hexo"],"categories":["爱折腾"]},{"title":"Redis慢日志与BigKey","path":"/post/851648499.html","content":"1. 慢日志设置1234# 当命令耗时超过5毫秒时，记录慢日志CONFIG SET slowlog-log-slower-than 5000# 只保留最近500条慢日志CONFIG SET slowlog-max-len 500 2. 查看慢日志123456789101112131415127.0.0.1:6379&gt; SLOWLOG get 51) 1) (integer) 32693 # 慢日志ID 2) (integer) 1593763337 # 执行时间戳 3) (integer) 5299 # 执行耗时(微秒) 4) 1) &quot;LRANGE&quot; # 具体执行的命令和参数 2) &quot;user_list:2000&quot; 3) &quot;0&quot; 4) &quot;-1&quot;2) 1) (integer) 32692 2) (integer) 1593763337 3) (integer) 5044 4) 1) &quot;GET&quot; 2) &quot;user_info:1000&quot;... 3. BigKey如果查询慢日志发现，并不是复杂度过高的命令导致的，而都是 SET &#x2F; DEL 这种简单命令出现在慢日志中，此时需要考虑实例否写入了 BigKey。 BigKey 俗称“大 key”，Redis 是 key-value 的存储方式，当一个 Key 所对应的存储数值过长时，就会出现大 key 的情况。 Redis 在写入数据时，需要为新的数据分配内存，相对应的当从 Redis 中删除数据时，也会释放对应的内存空间。BigKey 会导致分配和释放内存的耗时都比较长。 可以使用下面命令扫描 Redis 中的 BigKey： 1234567891011121314151617181920$ redis-cli -h 127.0.0.1 -p 6379 --bigkeys -i 0.01...-------- summary -------Sampled 829675 keys in the keyspace!Total key length in bytes is 10059825 (avg len 12.13)Biggest string found &#x27;key:291880&#x27; has 10 bytesBiggest list found &#x27;mylist:004&#x27; has 40 itemsBiggest set found &#x27;myset:2386&#x27; has 38 membersBiggest hash found &#x27;myhash:3574&#x27; has 37 fieldsBiggest zset found &#x27;myzset:2704&#x27; has 42 members36313 strings with 363130 bytes (04.38% of keys, avg size 10.00)787393 lists with 896540 items (94.90% of keys, avg size 1.14)1994 sets with 40052 members (00.24% of keys, avg size 20.09)1990 hashs with 39632 fields (00.24% of keys, avg size 19.92)1985 zsets with 39750 members (00.24% of keys, avg size 20.03) 对线上实例进行 bigkey 扫描时，Redis 的 OPS 会突增，为了降低扫描过程中对 Redis 的影响，需要控制扫描的频率，指定 -i 参数即可，它表示扫描过程中每次扫描后休息的时间间隔，单位是秒。","tags":["Redis"],"categories":["服务端开发"]},{"title":"使用Watchtower自动更新Docker","path":"/post/1404510687.html","content":"Watch­tower 官网: https://github.com/containrrr/watchtower Watch­tower 可以用于自动更新 Docker 镜像与容器。Watch­tower 会监视正在运行的容器以及相关的镜像，当检测到 Reg­istry 中的镜像与本地的镜像有差异时，会拉取最新镜像并使用最初部署时相同的参数重新启动相应的容器。 1. 安装运行Watch­tower 本身被打包为 Docker 镜像，因此可以像运行其他容器一样运行它： 1234567docker run -d \\ --name watchtower \\ --restart unless-stopped \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower \\ --cleanup \\ --interval 60 运行 Watch­tower 后，所有容器都会自动更新，也包括 Watch­tower 本身。 默认情况下 Watch­tower 每 5 分钟会轮询一次，可以使用--interval参数指定（单位秒）。 查看帮助文档： 1docker run --rm containrrr/watchtower -h 2. 手动更新前面的使用方式是让 Watch­tower 以 detached（后台）模式在运行并自动更新容器，而 Watch­tower 也支持以 foreground（前台）模式来使用，即运行一次退出并删掉容器，来实现手动更新容器。这对于偶尔更新一次那些不在自动更新列表中的容器非常有用。 对于 foreground 模式，需要加上 --run-once （--run-once 可以简写为 -R）这个专用的选项。下面的例子 Docker 会运行一次 Watch­tower 并检查 aria2-pro 容器的基础镜像更新，最后删掉本次运行创建的 Watch­tower 容器。 12345docker run --rm \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower --cleanup \\ --run-once \\ aria2-pro 3. 更新私有镜像如果是从私有 Docker 仓库获取镜像，则需提供身份验证凭据和环境变量 REPO_USER 和 REPO_PASS，或者通过将宿主机的 docker 配置文件挂载到容器的根目录下。 通过添加环境变量的方式： 123456docker run -d \\ --name watchtower \\ -e REPO_USER=username \\ -e REPO_PASS=password \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower container_to_watch --debug 通过挂载宿主机 docker 配置文件的方式： 12345docker run -d \\ --name watchtower \\ -v /home/&lt;user&gt;/.docker/config.json:/config.json \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower container_to_watch --debug","tags":["Docker","Watch­tower"],"categories":["服务端开发"]},{"title":"Redis常见异常及处理方案","path":"/post/44844734.html","content":"1. 缓存雪崩在短时间内本应交由 Redis 处理的大量请求，都发送到了数据库进行处理，从而导致对数据库的压力迅速增大，严重时数据库可能崩溃，从而导致整个系统崩溃，就像雪崩一样，引发连锁效应，所以叫缓存雪崩。 出现上述情况的常见原因主要有以下两点： 大量缓存数据同时过期，导致本应请求到缓存的需重新从数据库中获取数据。 redis 本身出现故障，无法处理请求，那自然会再请求到数据库那里。 针对大量缓存数据同时过期的情况： 实际设置过期时间时，应当尽量避免大量 key 同时过期的场景，如果真的有，那就通过随机、微调、均匀设置等方式设置过期时间，从而避免同一时间过期。 添加互斥锁，使得构建缓存的操作不会在同一时间进行。 双 key 策略，主 key 是原始缓存，备 key 为拷贝缓存，主 key 失效时，可以访问备 key，主 key 缓存失效时间设置为短期，备 key 设置为长期。 后台更新缓存策略，采用定时任务或者消息队列的方式进行 redis 缓存更新或移除等。 针对 Redis 本身出现故障的情况： 在预防层面，可以通过主从节点的方式构建高可用的集群，也就是实现主 Redis 实例挂掉后，能有其他从库快速切换为主库，继续提供服务。 如果事情已经发生了，那就要为了防止数据库被大量的请求搞崩溃，可以采用服务熔断或者请求限流的方法。当然服务熔断相对粗暴一些，停止服务直到 redis 服务恢复，请求限流相对温和一些，保证一些请求可以处理，不是一刀切，不过还是看具体业务情况选择合适的处理方案。 2. 缓存击穿缓存击穿一般出现在高并发系统中，是大量用户同时并发请求缓存中没有但数据库中有的数据，也就是同时读 Redis 缓存，但缓存中没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大。 和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。 出现这种情况一般因为某个热点数据缓存过期，由于是热点数据，请求并发量大，所以过期的时候还是会有大量请求同时过来，来不及更新缓存就全部打到数据库了。 针对这种情况有两种常见的处理方案： 简单粗暴的对热点数据不设置过期时间，这样不会过期，自然也就不会出现上述情况了，如果后续想清理，可以通过后台进行清理。 添加互斥锁，即当过期之后，除了请求过来的第一个查询的请求可以获取到锁请求到数据库，并再次更新到缓存中，其他的会被阻塞住，直到锁被释放，同时新的缓存也被更新上去了，后续请求又会请求到缓存上，这样就不会出现缓存击穿了。 3. 缓存穿透缓存穿透是指数据既不在 Redis 中，也不在数据库中，这样就导致每次请求过来的时候，在缓存中找不到对应 key 之后，每次都还要去数据库再查询一遍，发现数据库也没有，相当于进行了两次无用的查询。 这样请求就可以绕过缓存直接查数据库，如果这个时候有人想恶意攻击系统，就可以故意使用空值或者其他不存在的值进行频繁请求，那么就会对数据库造成比较大的压力。 针对缓存穿透，一般有以下三种处理方案： 非法请求的限制，主要是指参数校验、鉴权校验等，从而一开始就把大量的非法请求拦截在外，这在实际业务开发中是必要的手段。 缓存空值或者默认值，如果从缓存取不到的数据，在数据库中也没有取到，那我们仍然把这个空结果进行缓存，同时设置一个较短的过期时间。通过这个设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库，可以防止有大量恶意请求是反复用同一个 key 进行攻击。 使用布隆过滤器快速判断数据是否存在。 那什么是布隆过滤器呢，简单来说，就是可以引入了多个相互独立的哈希函数，保证在给定的空间和误判率下，完成元素判重。因为我们知道，存在 hash 碰撞这样一种情况，那如果只使用一个 hash 函数，则碰撞冲突的概率明显会变大，那为了减少这种冲突，我们可以多引入几个 hash 函数，而布隆过滤器算法的核心思想就是利用多个不同的 hash 函数来解决这样一种冲突。它的优点是空间效率高，查询时间短，远超其他算法，而它的缺点就是会存在一定的误识别率，它不能完全保证请求过来的 key 通过布隆过滤器的校验就一定有这个数据，毕竟理论上还是会存在冲突情况，无论概率多小。但是，只要没有通过布隆过滤器的校验，那么这个 key 就一定不存在，只要利用这一点其实就已经可以过滤掉大部分不存在的 key 的请求了，在正常场景下已然足够了。 4. 缓存预热缓存预热就是系统上线前后，将相关的缓存数据直接加载到缓存系统中去，而不依赖用户触发请求时才加入。这样就可以避免在用户请求的时候，先查询数据库再将数据缓存的问题。用户直接查询事先被预热的缓存数据，这样可以避免那么系统上线初期，对于高并发的流量，都会访问到数据库中，对数据库造成流量的压力。 根据数据不同量级，可以有以下几种做法： 数据量不大：项目启动的时候自动进行加载。 数据量较大：后台定时刷新缓存。 数据量极大：只针对热点数据进行预加载缓存操作。 5. 缓存降级当缓存失效或缓存服务出现故障时，我们为了防止数据库发生雪崩而不去访问数据库，但此时仍然想要保证服务的主体功能是基本可用的。因此对于不重要的缓存数据，我们可以采取服务降级策略。 一般做法有以下两种： 直接访问内存部分的数据缓存。 直接返回系统设置的默认值。","tags":["Redis"],"categories":["服务端开发"]},{"title":"Windows平台文件自签名","path":"/post/667140500.html","content":"本文使用的工具都是 Windows SDK 自带的，可以采用单独安装 Windows SDK的方式，也可以通过安装 Visual Studio 来附带安装 Windows SDK。 123456# 在弹出界面设置密码123456makecert.exe -sv test.pvk -r -n &quot;CN=test.com&quot; test.cercert2spc.exe test.cer test.spcpvk2pfx.exe -pvk test.pvk -pi 123456 -spc test.spc -pfx test.pfx -f 使用 SignTool 工具对 EXE 文件签名： 1signtool.exe sign /f test.pfx /p 123456 Setup.exe","tags":["签名","数字证书"],"categories":["Windows编程"]},{"title":"Windows音频环回录制","path":"/post/2236960039.html","content":"所谓音频环回录制就是录制扬声器播放的声音。播放到扬声器的声音已经过混合，Windows 提供了 WASAPI 来获取这种混合的音频信号。 本文将录制到原始音频样本数据写入到文件，可以使用Audacity导入原始数据试听。 在 Audacity 中导入原始数据时需要选择正确的音频参数，否则会导致无法播放。 初始化设备声明相关变量： 12345IMMDeviceEnumerator* pDeviceEnum = NULL;IMMDevice* pDevice = NULL;IAudioClient* pAudioClient = NULL;WAVEFORMATEX* pWaveFormat = NULL;IAudioCaptureClient* pAudioCaptureClient = NULL; 获取默认音频输出设备并初始化环回录制服务： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455HRESULT InitRecord() &#123; HRESULT hr; hr = CoCreateInstance(CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, IID_IMMDeviceEnumerator, (void**)&amp;pDeviceEnum); if (FAILED(hr)) &#123; printf(&quot;Create device enumerator failed, hr: 0x%x&quot;, hr); return hr; &#125; hr = pDeviceEnum-&gt;GetDefaultAudioEndpoint(eRender, eConsole, &amp;pDevice); if (FAILED(hr)) &#123; printf(&quot;Get default audio device failed, hr: 0x%x&quot;, hr); return hr; &#125; hr = pDevice-&gt;Activate(IID_IAudioClient, CLSCTX_ALL, NULL, (void**)&amp;pAudioClient); if (FAILED(hr)) &#123; printf(&quot;Create audio client failed, hr: 0x%x&quot;, hr); return hr; &#125; hr = pAudioClient-&gt;GetMixFormat(&amp;pWaveFormat); if (FAILED(hr)) &#123; printf(&quot;Get mix format failed, hr: 0x%x&quot;, hr); return hr; &#125; printf(&quot;Channel: %d, SamplesPerSec: %d, BitsPerSample: %d &quot;, pWaveFormat-&gt;nChannels, pWaveFormat-&gt;nSamplesPerSec, pWaveFormat-&gt;wBitsPerSample); hr = pAudioClient-&gt;Initialize(AUDCLNT_SHAREMODE_SHARED, AUDCLNT_STREAMFLAGS_LOOPBACK, BUFFER_TIME_100NS, 0, pWaveFormat, NULL); if (FAILED(hr)) &#123; // 兼容Nahimic音频驱动 // https://github.com/rainmeter/rainmeter/commit/0a3dfa35357270512ec4a3c722674b67bff541d6 // https://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/bd8cd9f2-974f-4a9f-8e9c-e83001819942/iaudioclient-initialize-failure // 初始化失败，尝试使用立体声格式进行初始化 pWaveFormat-&gt;nChannels = 2; pWaveFormat-&gt;nBlockAlign = (2 * pWaveFormat-&gt;wBitsPerSample) / 8; pWaveFormat-&gt;nAvgBytesPerSec = pWaveFormat-&gt;nSamplesPerSec * pWaveFormat-&gt;nBlockAlign; hr = pAudioClient-&gt;Initialize(AUDCLNT_SHAREMODE_SHARED, AUDCLNT_STREAMFLAGS_LOOPBACK, BUFFER_TIME_100NS, 0, pWaveFormat, NULL); if (FAILED(hr)) &#123; printf(&quot;Initialize audio client failed, hr: 0x%x&quot;, hr); return hr; &#125; &#125; hr = pAudioClient-&gt;GetService(IID_IAudioCaptureClient, (void**)&amp;pAudioCaptureClient); if (FAILED(hr)) &#123; printf(&quot;Get audio capture client failed, hr: 0x%x&quot;, hr); return hr; &#125; return S_OK;&#125; 采样在初始化成功后，开启独立线程按固定间隔获取缓冲区中的音频样本。exitFlag用于控制线程是否退出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 线程处理函数void QueryAudioSampleThread() &#123; UINT32 bufferFrameCount = 0; HRESULT hr = pAudioClient-&gt;GetBufferSize(&amp;bufferFrameCount); if (FAILED(hr)) &#123; printf(&quot;Get buffer frame count failed, hr: 0x%x&quot;, hr); return; &#125; // 根据实际缓冲区中的样本数计算实际填满缓冲区需要的时间 REFERENCE_TIME hnsActualDuration = (double)BUFFER_TIME_100NS * bufferFrameCount / pWaveFormat-&gt;nSamplesPerSec; UINT32 packetLength = 0; BYTE* buffer = NULL; UINT32 numFramesAvailable = 0; DWORD flags = 0; while (!exitFlag.load()) &#123; // 等待半个缓冲周期 Sleep(hnsActualDuration / 10000 / 2); hr = pAudioCaptureClient-&gt;GetNextPacketSize(&amp;packetLength); if (FAILED(hr)) &#123; printf(&quot;Get next package size failed, hr: 0x%x&quot;, hr); break; &#125; while (packetLength &gt; 0) &#123; hr = pAudioCaptureClient-&gt;GetBuffer(&amp;buffer, &amp;numFramesAvailable, &amp;flags, NULL, NULL); if (FAILED(hr)) &#123; printf(&quot;Get capture buffer failed, hr: 0x%x&quot;, hr); break; &#125; // 将捕获到的样本写入文件 if (!WriteSample(buffer, numFramesAvailable * pWaveFormat-&gt;nChannels * pWaveFormat-&gt;wBitsPerSample / 8)) &#123; printf(&quot;Write sample to file failed&quot;); &#125; hr = pAudioCaptureClient-&gt;ReleaseBuffer(numFramesAvailable); if (FAILED(hr)) &#123; printf(&quot;Release capture buffer failed, hr: 0x%x&quot;, hr); break; &#125; hr = pAudioCaptureClient-&gt;GetNextPacketSize(&amp;packetLength); if (FAILED(hr)) &#123; printf(&quot;Get next package size failed, hr: 0x%x&quot;, hr); break; &#125; &#125; &#125;&#125; Sample和Frame的含义pWaveFormat-&gt;nSamplesPerSec表示每秒采样的次数，如48000的采样率就是每秒采48000个Sample，一个Sample 是一个声道的一个采样。 而Frame 则是一个时间点的Sample集合，举例来说，一个线性的PCM 双声道音频文件每个Frame有2个Sample，一个左声道Sample，和一个右声道Sample。 释放设备和内存在录制结束后释放设备和内存： 1234567891011void UnInitRecord() &#123; if (pWaveFormat) &#123; CoTaskMemFree(pWaveFormat); pWaveFormat = NULL; &#125; SAFE_RELEASE(pDeviceEnum); SAFE_RELEASE(pDevice); SAFE_RELEASE(pAudioClient); SAFE_RELEASE(pAudioCaptureClient);&#125; 完整示例代码见：AudioLoopbackRecord.cpp","tags":["WASAPI","Loopback","Audacity","环回录制"],"categories":["Windows编程"]},{"title":"史铁生：职业事业（节选）","path":"/post/1173742882.html","content":"选择一项事业（或者找一条能够载渡精神的船）的时候，应该想起兵书上的一句话：知己知彼，百战不殆。没有谁是为了失败而工作的，因为注定的失败不能引导出一个如醉如痴的过程。 所谓知己，就是要知道自己的兴趣何在？自己的禀赋何在？如果你喜欢文学，可你偏偏不肯舍弃一个学化学的机会，且不说没有兴趣你的化学很难学好，即便你小有成就那也是你的悲剧。如果你是一个数学天才，比如说是一个潜在的陈景润，可你对此昏然不知偏要去当一个写小说的，结果多半不妙。 所谓知彼，就是得知道客观条件允许你干什么。如果你热爱起足球的时候已经 40 多岁，你最好安心作一个球迷，千万别学马拉多纳了。如果你羡慕三毛，你也有文学才能，但是你的双腿一动都不能动，你就不要向往撒哈拉，你不如写一写自己心中的沙漠。 我一贯相信，每个人都有自己的所长，倘能扬长避短谁都能有所作为；相反如果弃长取短，天才也能成为蠢才，不信让陈景润与托尔斯泰调换一下工作试试看。对事业的选择，要根据“知己知彼”的原则，可别为“热门”或时髦所左右。 然后还得需要点勇气，需要冒一点风险，没有什么办法能保证你肯定有一条金光大道。我开始想写作的时候，人们提醒我说，你哪儿都去不了不能深入生活，你凭什么能干这一行呢？我自己心里也打鼓。可是我忍不住地想写。我有纸也有笔，还有好多想法，别人一天有 24 小时的生活，我一天也有 24 小时的生活，所有的生活一样都有品味不尽的深意，我就偷偷地写了一点，自己觉得还有希望，于是豁出去了，写！如果你看不出你的选择有什么不对头，你得豁得出去，你得敢于试试，一条道走到黑或者不撞南墙不回头。当然那时我已经在街道生活组挣着自己的饭钱了，我想我最不济是个 0，不会是个负数了。","tags":["史铁生"],"categories":["剪切板"]},{"title":"获取其他进程的命令行参数","path":"/post/3666245140.html","content":"本文介绍如何根据进程 ID 获取进程命令行参数，使用 Windows NTDLL 提供的未公开 API 实现。 由于需要使用到 Windows 应用层未公开的 API，而且这些 API 在 Windows 头文件中未提供函数定义，因此我们需要使用 GetProcessAddress 动态地从 ntdll.dll 中获取函数地址。 动态获取函数地址本不是一件困难的事情，但是当涉及调用函数比较多时，这个操作就显得比较繁琐了，我们可以直接使用下面的库来简化上述操作。https://github.com/winsoft666/ntdll 下面介绍如何使用ntdll库来根据进程 ID 获取进程命令行参数。 首先需要包含头文件： 1#include &quot;ntdll.h&quot; 并引入对应 lib：x86 tdll.lib或x64 tdll.lib。 拿去用吧具体获取命令行参数的方式已封装到下面GetProcessCommandLine函数，方便读者食用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 返回值为0表示成功DWORD GetProcessCommandLine(unsigned int pid, std::wstring&amp; strResult) &#123; BOOL result = false; SetLastError(0); HANDLE hProcess = NULL; PPEB ppebCopy = NULL; PRTL_USER_PROCESS_PARAMETERS pRtlProcParamCopy = NULL; PWSTR wBufferCopy = NULL; do &#123; hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); if (!hProcess) break; PROCESS_BASIC_INFORMATION basicInfo; ZeroMemory(&amp;basicInfo, sizeof(PROCESS_BASIC_INFORMATION)); NTSTATUS status = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &amp;basicInfo, sizeof(PROCESS_BASIC_INFORMATION), NULL); if (!NT_SUCCESS(status)) break; PPEB ppeb = basicInfo.PebBaseAddress; ppebCopy = (PPEB)malloc(sizeof(PEB)); if (!ppebCopy) break; result = ReadProcessMemory(hProcess, ppeb, ppebCopy, sizeof(PEB), NULL); if (!result) break; PRTL_USER_PROCESS_PARAMETERS pRtlProcParam = ppebCopy-&gt;ProcessParameters; pRtlProcParamCopy = (PRTL_USER_PROCESS_PARAMETERS)malloc(sizeof(RTL_USER_PROCESS_PARAMETERS)); if (!pRtlProcParamCopy) break; result = ReadProcessMemory(hProcess, pRtlProcParam, pRtlProcParamCopy, sizeof(RTL_USER_PROCESS_PARAMETERS), NULL); if (!result) break; PWSTR wBuffer = pRtlProcParamCopy-&gt;CommandLine.Buffer; USHORT len = pRtlProcParamCopy-&gt;CommandLine.Length; wBufferCopy = (PWSTR)malloc(len + 2); if (!wBufferCopy) break; memset(wBufferCopy, 0, len + 2); result = ReadProcessMemory(hProcess, wBuffer, wBufferCopy, // command line goes here len, NULL); if (result) strResult = wBufferCopy; &#125; while (false); DWORD dwGLE = 0; if (!result) &#123; dwGLE = GetLastError(); &#125; if (ppebCopy) free(ppebCopy); if (pRtlProcParamCopy) free(pRtlProcParamCopy); if (wBufferCopy) free(wBufferCopy); if (hProcess) CloseHandle(hProcess); return dwGLE;&#125;","tags":["进程","ntdll"],"categories":["Windows编程"]},{"title":"开源库rpclib使用备忘","path":"/post/1963116418.html","content":"rpclib是一个 C++的 RPC 库，基于 MessagePack 进行二进制序列化和反序列化，底层使用 TCP 进行进程间通信。其功能与 Facebook 的 Thrift、Google 的 Protocol Buffers 相似，但 rpclib 更加轻量级，不需要依赖 Boost，而且不用声明接口描述文件。 rpclib 官网： https://github.com/rpclib/rpclib 1. 编译使用 CMake 生成对应编译系统的项目文件，编译即可，也可以使用 vcpkg 进行安装，如： 1vcpkg install rpclib:x86-windows-static 2. 简单应用rpclib 有服务端和客户端概念，只能由客户端调用服务端，接受服务端的返回值，服务端不能主动调用客户端函数。如需实现两端双向调用，则需要在两端分别启动一个服务端和客户端，并彼此相连。 rpclib 库的错误是通过 C++异常抛出的，因此在使用该库时需要使用 try...catch 进行异常捕获。 2.1 服务端在服务端完成端口监听，及函数的绑定操作。 12345678910111213141516#include &quot;rpc/server.h&quot;try &#123; std::shared_ptr&lt;rpc::server&gt; rpcServer = std::make_shared&lt;rpc::server&gt;(&quot;0.0.0.0&quot;, 8001); // 8001为监听端口 // 绑定Add函数，供客户端调用 rpcServer-&gt;bind(&quot;Add&quot;, [](int x, int y) -&gt; int &#123; return x + y; &#125;); rpcServer-&gt;async_run(); // 异步启动Server循环，也可以使用run()同步启动&#125;catch(std::exception&amp; e) &#123; // ...&#125; 2.2 客户端客户端通过 IP 和端口连接服务端，并调用服务端的函数。 1234567891011121314#include &quot;rpc/client.h&quot;try &#123; std::shared_ptr&lt;rpc::client&gt; rpcClient = std::make_shared&lt;rpc::client&gt;(&quot;127.0.0.1&quot;, 8001); // 服务端监听端口 rpcClient-&gt;set_timeout(200); // 设置同步调用的超时时间 int result = rpcClient-&gt;call(&quot;Add&quot;, 100, 200).as&lt;int&gt;(); // 调用Add函数，参数为100,200 // result为Add函数的返回值&#125;catch(std::exception&amp; e) &#123; // ...&#125; 2.3 支持的参数和返回值类型rpclib 使用 MessagePack 进行序列化，支持的数据类型与 MessagePack 相同。支持如下 C++类型： bool char* double float char，不支持 wchar_t short int long long long std::string，不支持 std::wstring std::vector std::array std::map std::shared_ptr std::unique_ptr 3. 广告在这里推荐我的veigar框架，一个基于共享内存的rpc框架，与rpclib相比有如下的优势： 没有服务端和客户端的概念，每个Veigar实例间都可以相互调用。 没有网络问题，如端口占用、半关闭状态等。 没有诡异的端口假可用性问题（特别是在Windows系统上）。","tags":["RPC","开源库","rpclib"],"categories":["开源库"]},{"title":"搭建JavaScript和TypeScript开发调试环境","path":"/post/997636699.html","content":"一、安装Visual Studio CodeVisual Studio Code（简称VSCode）是由微软开发的一个开源的、跨平台的代码编辑器。Visual Studio Code的优势就是有丰富的扩展包，大多数功能都可以通过安装扩展包的方式来实现。 打开Visual Studio Code官网https://code.visualstudio.com/，根据系统选择对应的版本进行安装： 安装选项可以根据个人喜欢来指定，没有强制的要求。但建议勾选如下4项： 二、配置Visual Studio Code2.1 将默认语言设置为中文安装完Visual Studio Code之后，其界面的默认语言是英文，我们只需要安装“简体中文的语言包”就可以将语言修改为中文：点击左侧“扩展”图标，打开扩展工具栏，输入“Chinese”搜索简体中文语言扩展包，安装完重启Visual Studio Code即可。 三、调试环境选择启动Visual Studio Code，按下快捷键F5，可以看到Visual Studio Code已经内置了几种调试环境的配置：但我们需要使用这些配置还需要安装对应的运行时环境如Node.js、Chrome。 Visual Studio Code也可以调试C++，C#，Python，Go，C++等语言，但需要在launch.json中进行适当的配置，后面在讲解使用Node.js调试TypeScript的时候会介绍如何配置launch.json。 因为Node.js可以直接运行Javascript脚本文件，所以这里我们选择使用Node.js来调试JavaScript。 在开始调试前，我们还需要安装Node.js运行时环境，打开Node.js中文官网https://nodejs.org/zh-cn/，选择长期支持版，下载安装即可（安装完成之后可能需要重启Visual Studio Code）： 四、调试JavaScript打开Visual Studio Code，新建一个JavaScript文件，输入任意JavaScript代码并保存，如：点击左侧工具栏的“运行”图标（快捷键Ctrl+Shift+D）并选择“运行和调试”（或者按F5快捷键），在弹出的调试环境下拉框中中选择“Node.js”，此时就会使用Node.js来运行当前脚本。 此时是看不到console.log的输出，因为其输出到了”调试控制台”，我们需要在“查看”菜单中打开“调试控制台”，再次使用上面步骤运行JavaScript文件即可在“调试控制台”看到运行的输出了。 4.1 断点设置&#x2F;取消断点：用鼠标点击行号左侧区域（即下图画绿框的区域）即可设置断点，再次点击便是取消断点；也可以使用快捷键F9来设置&#x2F;取消断点.设置断点后，F5开始调试代码，代码运行到断点处便会暂停，此时我们可以在左侧区域查看当前上下文涉及的”局部变量”和”全局变量”、”调用堆栈”、以及”断点列表”。 4.2 调试快捷键 F5 开始调试或在代码暂停后继续执行到下一处断点 F10 单步执行 F11 单步步入，F10遇到函数不会调试进入函数内部，而F11却可以步入到函数内部 Shift+F11 单步跳出 Shift+F5 停止调试 五、调试TypeScriptNode.js是不能直接运行TypeScript脚本的，我们使用Node.js运行TypeScript脚本一般采用如下方法：使用TypeScript官方提供的tcs工具将TypeScript脚本转化为JavaScript，然后再使用Node.js运行js脚本，大致流程如下： 12tcs --outFile index.js index.tsnode index.js 而Node.js的扩展模块ts-node可以简化上述操作（其内部也是使用的tcs和node），将上面二步操作合二为一： 1ts-node index.ts 所以，我们这里采用ts-node模块来作为TypeScript脚本的运行时环境。 由于我们采用了ts-node工具来运行TypeScript脚本，Visual Studio Code没有内置该工具的调试配置，所以我们需要在luanch.json中自定义一个适用于ts-node的调试环境配置。 注意：如果需要自定义配置，那么工程文件必须在一个单独的目录中，并使用Visual Studio Code打开这个目录（对着目录点右键选择使用Visual Studio Code打开即可） 大致步骤如下： 新建项目目录（假设叫TSDemo） 使用Visual Studio Code打开该目录，并在“查看”菜单中选择打开“终端”（之所以在Visual Studio Code中打开终端，纯属是为了方便，因为在Visual Studio Code中打开终端，终端会自动切换到项目当前目录，且不用多个窗口之间切换）。 在终端中依此执行如下命令： 12345678# 生成package.json文件npm init -y# 安装typescriptnpm install typescript -S # 安装ts-node npm install ts-node -S luanch.json的路径为项目目录\\.vscode\\luanch.json，按照下图依此点击左侧工具栏“运行”-&gt;“创建launch.json文件”： 打开自动生成的luanch.json文件，在configurations节添加如下配置： 12345678910111213141516&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Current TS File&quot;, &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/node_modules/ts-node/dist/bin.js&quot;, &quot;args&quot;: [ &quot;$&#123;relativeFile&#125;&quot; ], &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;, &quot;protocol&quot;: &quot;inspector&quot; &#125; ]&#125; 打开需要调试的TypeScript文件，快捷键F5开始调试。 因为ts-node既可以执行TypeScript，也可以执行JavaScript，所以这种方式也可以用来调试JavaScript脚本。","tags":["JavaScript","TypeScript"],"categories":["Web编程"]},{"title":"正则规则速查","path":"/post/3005885000.html","content":"本文不是一个完整的正则表达式的教程，仅适用于已掌握正则表达式语法，需要进行规则速查的开发人员。 一、元字符 字符 说明 ^ 一行开始 $ 一行结束 \\b 单词的开始或结束 . 除换行符外的任意字符 \\w 单词字符（包括字母、数字、下划线和汉字） \\W 任意的非单词字符（包括字母、数字、下划线和汉字） \\s 任意的空白字符，如空格、制表符、换行符、中文全角空格等 \\S 任意的非空白字符 \\d 任意的数字 \\D 任意的非数字字符 二、字符集合 字符集合 说明 [aeiou] aeiou 字符集中的任何字符 [^aeiou] 除 aeiou 字符集之外的字符 [0-9a-z] 字符集合 0 到 9，a 到 z 中的任何字符 [^0-9a-z] 除字符集合 0 到 9， a 到 z 中的任何字符 三、限定符 字符 说明 {n} 重复次数&#x3D;n 次 {n,} 重复次数&gt;&#x3D;n 次 {n,m} n&lt;&#x3D;重复次数&lt;&#x3D;m * 重复次数&gt;&#x3D;0 + 重复次数&gt;&#x3D;1 ? 0&lt;&#x3D;重复次数&lt;&#x3D;1 *? 尽可能少地使用重复的第一个匹配 +? 尽可能少地使用重复但至少使用一次 ?? 使用零次重复（如有可能）或一次重复 四、分组分组又称为子表达式，即把一个正则表达式的全部或部分分成一个或多个组。其中，分组使用的字符为(和)，即左圆括号和右圆括号。分组之后，可以将字符为(和)之中的表达式看成一个整体来处理。 以下正则表达式可以匹配重复出现字符串“abc”一次或两次的字符串。此时，表达式将“abc”看成一个整体来进行重复匹配。 1(abc)&#123;1,2&#125; 当一个正则表达式被分组之后，每一个组将自动被赋予一个组号，该组号可以代表该组的表达式。其中，组号的编制规则为：从左到右、以分组的左括号(为标志，第一个分组的组号为 1，第二个分组的组号为 2，以此类推。可以使用 \\数字 的方式来引用分组。如\\1，\\2。 五、贪婪与非贪婪比如说匹配输入串 A: 101000000000100 使用1.*1将会匹配到 1010000000001, 匹配方法: 先匹配至输入串 A 的最后, 然后向前匹配, 直到可以匹配到 1, 称之为贪婪匹配。 使用1.*?1将会匹配到 101, 匹配方法: *匹配下一个 1 之前的所有字符, 称之为非贪婪匹配。 所有带有量词的都是非贪婪匹配: .*?, .+?, .&#123;2,6&#125;?, .??。 六、在线正则验证工具 https://c.runoob.com/front-end/854/ http://www.yunjson.com/reg/ https://tool.oschina.net/regex/","tags":["正则"],"categories":["编程基础"]},{"title":"Git杂记","path":"/post/2042033077.html","content":"本文记录 Git 使用中的一些零碎知识，方便自己查阅，亦希望成人之美。 一、gitignore 文件规则 所有空行或#开头的行都会被忽略； 文件或目录前加 &#x2F;表示仓库根目录； 匹配模式最后跟反斜杠 &#x2F; 指明是目录而非文件，忽略该目录下的所有文件，但不忽略该目录； 在模式前加!，指明不忽略某个文件或目录； 支持标准的 glob 模式匹配 * 匹配零个或多个任意字符； ? 只匹配一个任意字符； [abc]匹配任何一个列在方括号中的字符； [0-9] 表示匹配所有 0 到 9 的数字，同理有[a-z]等； 二、清空仓库历史提交1234567891011121314151617# 1. 创建新分支，如名称latest_branchgit checkout --orphan latest_branch# 2. 添加所有文件git add .# 3. 提交git commit -m &quot;自定义提交说明&quot;# 4. 删除原来的主分支（master）git branch -D master# 5. 将当前分支重命名为mastergit branch -m master# 6. 强制推送到远端git push -f origin master 有些仓库有 master 分支保护，不允许强制 push，需要在远程仓库项目把分支保护关掉才能推送。 推送前需要使用git remote -v 查看关联的远程仓库的信息（主要是远程库的别名）。虽然远程库的别名默认是 origin ,但可能设置过其他的别名（而非 origin）。","tags":["Git"],"categories":["编程基础"]},{"title":"Qt加载字体文件","path":"/post/2767065786.html","content":"本文仅简单记录如何使用 Qt 加载外部字体文件，并遍历字体名称和样式名称。 1234567891011121314151617181920212223242526272829303132333435363738bool LoadFont(const QString&amp; fontPath) &#123; const int fontId = QFontDatabase::addApplicationFont(fontPath); if (fontId == -1) &#123; return false; &#125; // 遍历字体名和样式名#if QT_VERSION &gt;= QT_VERSION_CHECK(6, 0, 0) const QStringList fontFamilyList = fontDb.applicationFontFamilies(fontId); QString fontFamily; foreach (fontFamily, fontFamilyList) &#123; qDebug() &lt;&lt; &quot;Family:&quot; &lt;&lt; fontFamily; const QStringList fontStyleList = QFontDatabase::styles(fontFamily); QString fontStyle; foreach (fontStyle, fontStyleList) &#123; qDebug() &lt;&lt; &quot;\\tStyle:&quot; &lt;&lt; fontStyle; &#125; &#125;#else QFontDatabase fontDb; const QStringList fontFamilyList = fontDb.applicationFontFamilies(fontId); QString fontFamily; foreach (fontFamily, fontFamilyList) &#123; qDebug() &lt;&lt; &quot;Family:&quot; &lt;&lt; fontFamily; const QStringList fontStyleList = fontDb.styles(fontFamily); QString fontStyle; foreach (fontStyle, fontStyleList) &#123; qDebug() &lt;&lt; &quot;\\tStyle:&quot; &lt;&lt; fontStyle; &#125; &#125;#endif return true;&#125; 限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺 您可以通过在 blog-comment 项目中提交Issue来间接地发表评论🍀","tags":["Qt","字体"],"categories":["Qt"]},{"title":"聊聊桌面客户端开发的技术选型","path":"/post/3110746169.html","content":"桌面客户端也叫 PC 客户端，桌面操作系统（如Windows、MacOS、Ubuntu 等系统）上的软件都可以称为桌面客户端软件，客户端软件的开发有多种技术选型方式，而且每种方式各有优劣。 采用不同的方式通常会导致在开发周期、技术人员招聘、软件性能、安装包体积等方面有比较大的差别。本文结合我这些年的客户端开发经验，聊一聊在客户端开发方面的各种技术选型以及他们的优劣。 一、技术方案汇总1.1 WinFormsWinForms（Windows Forms）是微软推出的 UI 框架，可以使用 C# 和 Visual Basic 作为开发语言。 WinForms 框架适合开发传统 UI 元素和界面的应用程序，比如工业、医疗领域的管理、控制软件。 当然，WinForms 也能开发出绚丽、非标准化的界面效果，但需要花费较多的时间，对开发人员的技术要求也更高。 基于 WinForms 开发的应用程序需要依赖.Net Framework 运行时，如果用户电脑上未安装.Net Framework 运行时，软件安装包需要自带运行时，并自动为用户安装，否则程序会无法运行。 使用 WinForms 开发的应用程序体积本身很小，但为了适应不同的用户电脑环境，安装包需要检测用户电脑上的.Net Framework 运行时版本是否与软件所需版本匹配，如果不匹配则需要自动安装相应的.Net Framework 运行时。 .Net Framework 很难做成便携版，通常需要使用微软提供的安装包进行安装，安装.Net Framework 运行时分为在线和离线安装两种方式： 离线安装方式。将微软提供的.Net Framework 离线安装包（不同版本体积不同，如 4.8 版本的离线安装包约 115M 左右）打包进程序安装包，安装时进行释放和安装。这种方式会增加程序安装包的体积。 在线安装方式。将微软提供的.Net Framework 在线安装工具（体积很小，约 1.5M 左右）打包进程序安装包，安装时进行释放和在线安装，这种方式虽然可以减少安装包体积，但在线安装需要实时从微软服务器下载资源，受限于用户网络环境，很可能会安装失败。 1.1.1 .Net Framework 版本兼容性在.Net Framework 4.5 版本之前，其各个版本之间不相互兼容（无论是向前还是向后都无法兼容），但从 4.5 及以后的版本就可以保证向后兼容了。 举例说明： 如果程序使用.Net Framework 3.5 版本开发，则只能基于该版本的运行时运行。 如果程序使用.Net Framework 4.6 版本开发，则用户电脑上只需要安装&gt;=4.6 版本的运行时即可运行。 1.1.2 系统自带.Net Framework 版本从 Windows Vista 开始，Windows 系统会自带.Net Framework 运行时，但各个系统自带的运行时版本不同。 下表列出了不同系统自带的.Net Framework 运行时的最低版本： 为什么是最低版本了？因为用户可能通过系统升级的方式更新了.Net Framework 运行时的版本。 操作系统 .Net Framework 运行时版本 Windows XP 1.0 Windows Vista 2.0 Windows 7 3.5 Windows 8 4.5 Windows 10 4.6 ~ 4.7 Windows 11 4.8+ 不同系统所支持的.Net Framework 最高版本也有所不同： Windows XP 最高支持.NET Framework 4.0 Windows 7 最高支持.NET Framework 4.6.2 Windows 8.1 最高支持.NET Framework 4.6.2 Windows 10 和 Windows 11 可以支持任意版本的.NET Framework 1.1.3 .Net Core .Net Core 官网： https://dotnet.microsoft.com/en-us/ .Net Core 是微软开发的一个开源的、跨平台的（支持 Windows、MacOS、Linux 等系统）通用软件开发框架。在.Net Core 出现之前，开发人员只能基于.Net Framwork 开发 WinForms 应用程序，.Net Core 出现之后，开发人员多了一种选择。 .Net Core 与.Net Framework 最大的不同在于.Net Core 是开源和跨平台的，基于.Net Core 开发的应用程序可以运行在不同的操作系统上，如 Windows、Linux、MacOS。 .Net Core 还处于快速的更新迭代中，之前的老版本对 WinForms 及 WPF 的支持不太好（甚至不支持），建议采用最新版本的.Net Core 进行开发。 使用.Net Core 开发的应用的体积本身非常小，但在打包分发时也需要携带.Net Core 运行时。不同于.Net Framework，.Net Core 运行时既支持安装包的方式，也支持便携版的方式。 以.Net Core 6.0 版本为例，微软官方提供的 WindowsDesktop 的运行时大小为 50M，我们可以根据程序实际依赖情况，安装包只包含程序依赖的文件，从而缩减安装包体积（缩减后约 20M 左右）。 1.2 WPFWPF（Windows Presentation Foundation）也是微软推出的 UI 框架。与 WinForms 一样，可以使用 C#和 Visual Basic 语言进行开发，WPF也支持.Net Framework 和.Net Core 两种开发平台。 使用 WPF 框架开发的应用程序界面更加炫酷，界面组件可随意定制化，适合用于对界面要求较高的应用。 WPF 程序的性能稍逊与 WinForms 应用，不过这种性能差别在计算机硬件性能快速提升的今天已在逐渐的被淡化，因此在进行技术选型时基本可以忽略的 WPF 性能问题了。 需要注意的是，WPF 应用在启动时通常较慢，比如用户打开应用后需要花费大概 1 秒左右的时间才能看见主界面。 1.3 MFCMFC（Microsoft Foundation Classes）是微软提供的一个基础类库，对 Windows 系统 API 进行了封装，包含一些基础控件，从而减少应用开发人员的工作量。MFC 应用程序的开发语言为 C++，MFC 提供的控件都是常规的 Windows 风格，和 WinForms 一样，如果需要开发炫丽、交互复杂的界面，需要开发人员花费精力自己绘制，会降低不少开发效率。 MFC 比较适合应用在对软件性能要求较高、调用系统 API 较多、界面交互较简单的软件上。 小知识：MFC又被戏称为“麻烦C”，大抵是因为用它开发界面比较麻烦吧。 1.4 DirectUIDirectUI 是一类技术的统称，即 Paint on parent dc directly，直接在父窗体上进行绘制。该技术是对 MFC 的一种改进，使用DirectUI开发的界面，整个窗口只有一个句柄，而不是像 MFC 一样，每个控件都有一个句柄。 目前流行的 DirectUI 界面库大多由个人开发并开源，由于没有专门的团队进行维护，因此使用该类界面库的公司通常需要自己维护一个分支进行 Bug 修复和添加新功能。 常用的 DirectUI 界面库有： duilib 作者已基本不维护。 DuiLib_Ultimate 其他人维护的一个 duilib 版本。 GacUI …… 建议选择公司技术人员比较熟悉的DirectUI库，最好能熟悉源码，可以进行 Bug 修复和功能定制开发。 DirectUI 界面库通常都是轻量级的，因此其开发的应用程序体积都会比较小。 1.5 QtQt 是一个跨平台的 C++图像界面开发框架，不仅支持 Windows、MacOS、Linux 等 PC 操作系统，还支持嵌入式 QNX、VxWorks 及 Android、iOS 等操作系统。 Qt 的应用非常广泛，是目前使用最广的 C++ 图像界面框架。Qt 应用程序的开发语言为 C++，Qt 比 MFC 上手更快，而且在控件定制、 UI 绘制上也比 MFC 方便。 以 Qt 5.15.2 版本为例，Qt 应用程序打包后的体积最小到 6MB 左右，如果使用更老版本的 Qt，体积还可以更小。 1.5.1 Qt 版权问题Qt 分为开源版本和商业版本，开源版本可以免费使用，商业版本需要付费才能使用。 开源版本既可以免费使用也可以用于商业用途，但需要遵守相应的规则。Qt中的大多数模块采用LGPL开源协议，少部分模块采用的是GPL协议，在开发商业软件是我们应选择LGPL协议的模块，并采用Qt动态链接库的方式（而不是静态库的方式）。 对应有些必须静态链接的模块，如QtMain，Qt采用BSD协议，允许在商业软件中使用。 慎用采用GPL协议的模块，该协议具有传染性，它要求所有使用这些模块的软件都要开源，因此要慎用GPL协议的模块。 可以在 https://www.qt.io/product/features 网站查询Qt模块对应的开源协议。 另外如果有对 Qt 源码进行修改，需要公布修改部分的源码。 1.5.2 Qt 版本选择Qt 5.6版本是Qt最后一个支持Windows XP的版本，而Qt 6 也不再支持Windows 7及其以下的版本。 另外，从Qt 6版本开始，官方不在提供32位的预编译二进制文件。 1.6 CEF CEF 官网： https://bitbucket.org/chromiumembedded/cef/wiki/Home。 CEF（Chromium Embedded Framework ）是 Google 公司开发的一个跨平台的浏览器内核框架（号称与 Chrome 浏览器为同一内核），以开源库的方式提供，可以内嵌到第三方程序中用于显示网页以及与网页进行交互。 CEF 自身主要使用 C++进行开发，目前也有 CEF 的其他语言的绑定，比如 CefSharp 就是 C# 的绑定。因此基于 CEF 技术方案，可以使用 C++、C#或其他语言作为开发语言，但据我了解大多使用的还是 C++。 在开发中，我们通常不会直接使用 CEF，而是进行二次封装，将其封装成组件，该组件用于打开 Web 页面，由 Web 页面负责界面交互，并通过Javascript 和 C++或 C#交互。 CEF 虽然是作为一个库来提供的，但其接口却及其复杂难用（像一坨屎一样），目前还没有一个对其封装的比较好的库，包括我自己硬着头皮封装的 QCefWidget 也不是那么完善，也有一些小问题。 CEF 经历了 CEF1 和 CEF3 两个大版本，CEF1 现已基本被淘汰，目前主流的是 CEF3（CEF 2623 版本是最后一个支持 Windows XP 的版本）。 由于版权问题，CEF 默认不支持 MP4 解码，如需支持，需要自行下载源码进行编译（这个过程可能会耗时 1 天左右）。 亦可以使用我编译好的CEF：https://github.com/winsoft666/cef_binary 采用 CEF 内嵌 Web 页面的方式，虽然可以借助 Web 开发的优势，极大提升软件开发效率，Web 页面更新起来也比客户端的升级更加方便，但由于其本质还是客户端内嵌浏览器，因此软件内存占用会比较高，通常一个简单的程序可能会占用 100MB 左右内存。在性能方面，也远远不及上面介绍的其他原生开发方式。 CEF 不同版本的体积差距较大，2623 版本压缩后大约 25MB，而 89.0.18 版本压缩后大约 60MB。不同版本对 Web 新特效的支持程度不同，在不在乎安装包体积的情况下可以选择最新版本，如果需要考虑安装包体积，则需要做出权衡。 采用该技术方案需要由 Web 开发者开发客户端内嵌页面，C++开发者开发客户端主体框架。由于 Web 页面无法直接访问系统资源，因此还需 Web 与 C++进行交互，并由 C++完成系统功能的开发。 1.7 Microsoft WebView2微软基于 Chromium 开源项目开发了Edge浏览器，同时也提供了 WebView2 组件，基于该组件可以实现在客户端中嵌入Web页面，实现 JavaScript 和本地程序的相互调用。 WebView2 组件支持 Windows7 及以上平台，但 Windows7 系统肯定是没有自带该组件的，需要单独下载安装。如果用户有更新过 Windows 10、11系统，很可能系统已集成组件，不需要额外下载安装。 Microsoft WebView2 的接口使用起来比 CEF 舒爽多了。 1.8 Electron前面提到使用 CEF 时需要二次封装，而 CEF 的接口又不是那么易于使用，所以封装一个功能完整、稳定运行的 CEF 组件需要花费不少时间。Electron 则是基于 CEF 进行了深层次的封装，Electron 相比自己封装 CEF 会更加稳定，还可以节省开发和后期维护的时间。 Electron 和 CEF 最大的不同之处是 Electron 可以直接调用 Node.js 的模块，如文件、系统、网络等模块，基于这些模块，理论上可以使用 JavaScript 完成客户端应用的开发，但这也仅限于理论上，实际上大多数的 Web 开发者缺少客户端软件开发经验，甚至缺少系统方面的理论基础，因此很难完全依靠 Web 开发者开发出功能完备的客户端软件。 基于 Electron 开发客户端时，大多数时候还需要 C++开发者开发 Node 模块来供 JavaScript 调用。 1.9 其他图像界面库除了上面介绍的方案，还要很多其他的优秀界面库，这些库各有特色，目前它们的使用者还没有上面的多。 下面列举了一些我所知道的优秀界面库，欢迎补充： RmlUi yue elements imgui …… 二、选型建议在进行技术选型时，需要综合考虑客户端需要支持的系统环境、安装包大小、界面效果、动画性能、系统功能的数量、开发周期、技术人员储备等因素，通常没有标准答案。 下面根据几种常见的情况，给出了一点点建议，仅供参考。 如果程序只需要支持 Windows 平台，对安装包大小不敏感，开发周期想要尽可能缩短，可以选择的比较多，如 Microsoft WebView2、 WinForms、 WPF、CEF 等。 如果程序只需要支持 Windows 平台，对安装包大小比较敏感，开发时间充裕可以选择原生开发 MFC、DirectUI、Qt，想加快开发进度可以使用网页开发 Microsoft WebView2。 如果程序只需要支持 Windows 平台，对安装包大小比较敏感，界面效果要求较高，开发周期想要尽可能缩短，可以选择 Microsoft WebView2。 如果程序只需要支持 Windows 平台，对安装包大小比较敏感，功能以系统功能为主，可以选择 MFC、DirectUI、Qt。 如果程序需要支持 Windows、macOS 平台，对安装包大小不敏感，开发周期想要尽可能缩短，选择 Electron。 如果程序需要支持 Windows、macOS 平台，对安装包大小比较敏感，选择 Qt。 如果程序需要支持国产系统（如麒麟系统、统信系统等），可能只能选择 Qt 了，因为 Electron、.Net Core 等框架可能还未对这些系统进行完全适配，需要自己去填坑，而且还需要考虑是否在信创白名单中。","categories":["项目管理"]},{"title":"戴建业：阅读习惯与人生未来（转载）","path":"/post/1878076142.html","content":"人有丑俊，书有浅深。就像人有种种色色一样，书也分不同的性质和层次。 东汉思想家王充将当时的书分为三种：作、述、论。他的名著《论衡》刚杀青时，有人恭维他“可谓作者”，也就是说他的著作算得上是“作”。王充谦逊地说自己的书“非作也，亦非述也，论也”。他把自己的代表作取名为《论衡》。原创性著作可称为“作”，它们横空出世而自铸伟词，属于前无古人且后启来者的经典。或阐述他人之思，或综贯百家之绪，或引申前人之学，虽然没有原创性，但能自成一家言，这一类书籍称为“述”；或记录“思想火花”，或更正当时邪说，或分析一时变故，按王充的说法，属于“杂说”一类的东西统称之为“论”。 今天书籍的种类更为繁多，有经典著作与流行书籍之别，有专业著作与大众读物之殊，有文字读物与视频读物之异……网络上的绝大多数读物没有“书”的形态，但它们赢得了绝大多数读者。这些东西多数不会成书，它们的作者也不想著书。 可喜的是，随着互联网的发达和手机的普及，人类有可能真正实现“知识的普惠”，任何层次任何形式的书籍都能轻易得到，前人蔑视的“引车卖浆之流”都能阅读。地铁里，公交上，休息时，随时随地都能看到“低头一族”。 “引车卖浆之流”意思是拉大车的，做小买卖的。指平民百姓。 不过，这种情况让人“亦喜亦忧”——随着知识的日益普及化，知识也日益浅表化和碎片化。 知识的浅表化不仅在社会大众中存在，在研究生和学者中也很普遍，区别只在五十步与百步之间。譬如要写一篇李白诗中“月亮”意象的论文，前人就得通读李白全集，今人只需要在电脑中敲上“月亮”二字，李白诗歌中所有与“月亮”有关的诗句都蹦了出来。你根本用不着读李白集，甚至用不着去完整地读一首李白诗，一篇上万字的论文就糊弄出来了。前人说李白诗“豪放飘逸”，李诗何以“豪放”，又如何“飘逸”，写文章的作者可能两眼茫然，对前人的评论缺乏深刻的理解，对李白诗歌也缺乏深度的体验。钱锺书谈到李白诗中的月亮，今天学者也谈到李白诗中的月亮，表面上看“月亮还是那个月亮”，但此“月亮”非彼“月亮”。 知识碎片化的情况更为严重。过去获取知识大多来于书本，书本上的知识具有一定的系统性，而且还需要一定的逻辑证明或事实依据，这种知识往往系统完整，而且还具有逻辑上的连贯性。今天，无论是日常生活，还是学术研究，我们都不必积累大量的知识，更不必建立自己的知识结构，什么知识都可以“谷歌”“百度”，什么材料都可以去文献检索。无须穷经皓首，无须博闻强记，无须学识渊博，在生活与研究中照样畅通无阻，在任何一个领域都潇洒无忧。只要你会“谷歌”，会“百度”，会搜索，无知可以显得有知，不学也可以显得博学。 长此以往，我们既难以认知哲人理论体系的深刻严谨，也难以体验诗人情感的博大崇高，甚至无法感受艺术作品的细腻美妙，因而认识会越来越浮浅，心灵会越来越荒芜，审美会越来越庸俗。从来不去碰一碰原创性的经典，我们自己怎么可能会有原创性？ 阅读大体上可以分为三大类：消遣性阅读、鉴赏性阅读与挑战性阅读。 消遣性阅读纯粹是为了消磨时光，比如在手机上刷刷天南地北的奇闻，看看男女明星的恩怨，上购物网上看看今年穿什么裙子，上旅游网上看看去哪些地方自驾游……这种阅读表面上是在“看”，其实是一无所“看”，因为他本来就没有打算去“看”什么，所以他才会什么都“看”。他阅读只是为了排遣无聊，希望这百无聊赖的日子赶快溜走，盼只盼“马儿呀快快地走”，这就是所谓“不做无聊之事，何以遣有涯之生”。 鉴赏性阅读包括听轻盈优美的音乐，看赏心悦目的画册，读文字优美的游记，读情节曲折的小说等等。这类阅读轻松愉快，紧张思考之余，下班归来之后，听听音乐，翻翻画册，品品字帖，读读小品，既能使自己身心放松，又能提高自己的审美能力，还可以使自己情感丰富细腻，这种阅读有“一石三鸟”的多重好处。 最后一种阅读就是挑战性阅读。人类流传下来的伟大经典，还有专业公认的名著，这一类经典著作都是挑战性阅读的读物。要想挑战自己的智力极限，要想攀登灵魂的珠穆朗玛峰，最佳选择就是挑战性阅读，去阅读那些伟大的经典，去结交那些非凡的智者或崇高的伟人。 一位西方作家曾不无调侃地说，所谓“经典著作”就是人人说好，但人人不读的那些书籍。的确，经典大多数是在人们书架上被“供奉”，并不是在人们案头上被阅读。为什么会出现这种情况呢？或深度超出了自己的智力范围，初读往往不知所云，如罗素的《数学原理》、弗雷格的《算术基础》；或行文过于晦涩艰深，超出了一般读者忍受的极限，如康德的《纯粹理性批判》、海德格尔的《存在与时间》；或自己缺乏必要的知识准备，或时代相隔十分遥远，今人无法领略书中的美感，如屈原的骚赋、杜甫的诗歌、但丁的《神曲》。这些经典是人类的精神宝库，但大多数人不得其门而入，它只向那些勤奋坚毅者敞开大门。 经典绝不能“随便翻翻”，再三思考琢磨才能探骊得珠，反复咀嚼才能品咂出它的味道。经典不是心灵的“可口可乐”，我们可以咕噜咕噜地一饮而尽，它需要我们不断钻研才能常读常新，如先秦的《庄子》、司马迁的《史记》、马克思的《资本论》、黑格尔的《精神现象学》，你越读越觉得奇妙无比。倘若真正读懂了这些经典，你会有一种“一览众山小”的开豁；倘若终身浸润于伟大的经典之中，你将“身心获益靡涯，文笔增华有望”。 “探骊得珠”的原意是骊珠，相传为藏在骊龙颔下的宝珠，骊龙栖息深渊中，欲取得骊珠，必须潜入深渊，待骊龙入睡后，再俟机窃取；指获得极为珍贵的宝物；后引申为写作文章能抓住重点，深得题旨的精髓。 可惜，有“会当凌绝顶”雄心的人很多，但最后实现“凌绝顶”志向的人极少。古人常常感叹，“学者如牛毛，成者如麟角”，学无所成的原因是没有定力。人与人拉开差距的关键，大多不是智力的高下，而是毅力与恒心的大小。包括我在内的许多朋友，“会当凌绝顶”的雄心不过一时心血来潮，还没有爬到半山腰就见难而返。 弃难图易是人的天性，“东海西海，心同理同”，套用王尔德的话说，所有人都有惰性，连我也有惰性：只要能读消遣读物我就不读经典，只要能读中文我就不想读英文，只要能读现代文学我就不想读古代文学，只要能看电视我就不想读书，只要能玩手机我就不会看电视…… 当然，今天人们无法拒绝手机阅读和网络阅读。问题是，能否让网络空间也飘溢书香？是否也能在手机上咀嚼经典？看来人们已经发现了问题的严重性，就像大家拒绝快餐食品一样，人们会逐渐改变消遣式浏览，在网络空间中培养挑战性阅读的习惯，同时在纸质书本与网络空间培植深度阅读的土壤。 稍稍留意一下就不难发现，不同的阅读和思考习惯，短时间内看不出有什么差别，时间一长就出现天差地别：有的才华出众，有的“泯然众人”。你自己选择了什么样的阅读习惯，你就为自己选择了什么样的人生。","tags":["戴建业"],"categories":["剪切板"]},{"title":"QPixmap使用要点","path":"/post/170290456.html","content":"本文记录在使用 QPixmap 时容易感到困惑和犯错的地方，方便自己查阅，亦希望能成人之美。 1. QPixmap 成员函数 QPixmap::size() 值与程序的 devicePixelRatio 无关，输出的是图片原始尺寸。 AspectRatioMode 取值： Qt::IgnoreAspectRatio 忽略图片原长宽比，将图片缩放到指定尺寸 Qt::KeepAspectRatio 在保持图片原长宽比和图片所有元素的情况下，尽量填充满目标矩形。 Qt::KeepAspectRatioByExpanding 在保持长宽比的情况下，拉伸图片保证填充满目标矩形，可能会舍弃部分图片元素。 scaledToWidth、scaledToHeight 函数可以实现在保持原图片长宽比的前提下，将图片缩放到指定的宽或者高。 drawPixmap 函数的参数从左到右依次是：目标区域 -&gt; pix -&gt; 源区域。目标区域会考虑当前 Widget 的 devicePixelRatio，而源区域则与 devicePixelRatio 无关。 2. 开启程序 DPI 缩放12345 QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling); QGuiApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);#if (QT_VERSION &gt;= QT_VERSION_CHECK(5, 14, 0)) QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough);#endif 3. QPixmap::devicePixelRatio首先 QPixmap::devicePixelRatio 仅适用于开启了 DPI 缩放的程序。 高分辨率版本的图片有大于 1 的设备像素比（即QPixmap::devicePixelRatio），如果该值匹配底层 QPaintDevice 的值，它将直接绘制到设备上，而不应用额外的转换。 该值用于指定当前 QPixmap 图片是基于 1 倍图的几倍缩放图。 需要注意的是，在使用drawPixmap函数时，如果该目标区域参数未指定宽和高，QPixmap::devicePixelRatio 才生效。 如下面的 drawPixmap 原型： 1234567void QPainter::drawPixmap(int x, int y, const QPixmap &amp;pixmap, int sx, int sy, int sw, int sh)void QPainter::drawPixmap(const QPointF &amp;point, const QPixmap &amp;pixmap, const QRectF &amp;source)void QPainter::drawPixmap(const QPoint &amp;point, const QPixmap &amp;pixmap, const QRect &amp;source)void QPainter::drawPixmap(const QPointF &amp;point, const QPixmap &amp;pixmap)void QPainter::drawPixmap(const QPoint &amp;point, const QPixmap &amp;pixmap)void QPainter::drawPixmap(int x, int y, const QPixmap &amp;pixmap) 示例（程序已开启 DPI 缩放）： 123456789101112void QtWidgetsApplication1::paintEvent(QPaintEvent* e)&#123; qDebug() &lt;&lt; this-&gt;devicePixelRatioF(); // 当前程序的DPI缩放为1.5 QPainter painter(this); QPixmap pix(&quot;D:\\\\gril.png&quot;); // gril.png图片实际尺寸为400*400 // 告知程序该图片是基于1倍图进行4倍放大后的，即1倍图为宽高为400/4 pix.setDevicePixelRatio(4); // 实际绘制的图片宽度为150*150，左上角坐标为150*150 painter.drawPixmap(QPoint(100,100), pix);&#125; 限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺 您可以通过在 blog-comment 项目中提交Issue来间接地发表评论🍀","tags":["Qt","QPixmap"],"categories":["Qt"]},{"title":"QSS设置滚动条样式","path":"/post/140071237.html","content":"本文简单记录如何使用 QSS 设置滚动条的样式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/*垂直滚动条*/QScrollBar:vertical &#123; background: transparent; /*背景色*/ width: 10px; /*宽度*/ margin: 0px 0px 0px 0px; /**/ padding-top: 12px; /*距离上面12px*/ padding-bottom: 12px; /*距离底部12px*/&#125;/*横向滚动条*/QScrollBar:horizontal &#123; background: transparent; /*背景色*/ height: 10px; /*高度*/ margin: 0px 0px 0px 0px; padding-left: 12px; /*距离左边12px*/ padding-right: 12px; /*距离右边12px*/&#125;/*垂直/横向滚动条Hover效果*/QScrollBar:vertical:hover,QScrollBar:horizontal:hover &#123; background: rgba(0, 0, 0, 30); /*背景色*/ border-radius: 5px; /*圆角*/&#125;/*垂直滚动条 - 滑块*/QScrollBar::handle:vertical &#123; background: rgba(0, 0, 0, 50); width: 10px; border-radius: 5px; border: none;&#125;/*横向滚动条 - 滑块*/QScrollBar::handle:horizontal &#123; background: rgba(0, 0, 0, 50); height: 10px; border-radius: 5px; border: none;&#125;/*垂直/横向滚动条滑块Hover效果*/QScrollBar::handle:vertical:hover,QScrollBar::handle:horizontal:hover &#123; background: rgba(0, 0, 0, 100);&#125;/*垂直滚动条下部分块*/QScrollBar::add-page:vertical &#123; width: 10px; background: transparent;&#125;/*垂直滚动条上面部分块*/QScrollBar::sub-page:vertical &#123; width: 10px; background: transparent;&#125;/*横向滚动条右边部分块*/QScrollBar::add-page:horizontal &#123; height: 10px; background: transparent;&#125;/*横向滚动条左边部分块*/QScrollBar::sub-page:horizontal &#123; height: 10px; background: transparent;&#125;/* ----------- 对于扁平化设计风格，下面的样式可以不用设置 ----------- *//*垂直滚动条顶部三角形位置*/QScrollBar::sub-line:vertical &#123; height: 12px; width: 10px; background: transparent; subcontrol-position: top;&#125;/*垂直滚动条顶部三角形图标*/QScrollBar::up-arrow:vertical &#123; image: url(:/client/images/scrollbar_arrowup_normal.png);&#125;/*垂直滚动条顶部三角形图标 鼠标Hover效果*/QScrollBar::up-arrow:vertical:hover &#123; image: url(:/client/images/scrollbar_arrowup_down.png);&#125;/*垂直滚动条顶部三角形图标 鼠标按下效果*/QScrollBar::up-arrow:vertical:pressed &#123; image: url(:/client/images/scrollbar_arrowup_highlight.png);&#125;/*垂直滚动条底部三角形位置*/QScrollBar::add-line:vertical &#123; height: 12px; width: 10px; background: transparent; subcontrol-position: bottom;&#125;/*垂直滚动条底部三角形图标*/QScrollBar::down-arrow:vertical &#123; image: url(:/client/images/scrollbar_arrowdown_normal.png);&#125;/*垂直滚动条底部三角形图标 鼠标Hover效果*/QScrollBar::down-arrow:vertical:hover &#123; image: url(:/client/images/scrollbar_arrowdown_down.png);&#125;/*垂直滚动条底部三角形图标 鼠标按下效果*/QScrollBar::down-arrow:vertical:pressed &#123; image: url(:/client/images/scrollbar_arrowdown_highlight.png);&#125;/*横向滚动条左侧三角形位置*/QScrollBar::sub-line:horizontal &#123; height: 10px; width: 12px; background: transparent; subcontrol-position: left;&#125;/*横向滚动条左侧三角形图标*/QScrollBar::left-arrow:horizontal &#123; image: url(:/client/images/scrollbar_arrowleft_normal.png);&#125;/*横向滚动条左侧三角形图标 鼠标Hover效果*/QScrollBar::left-arrow:horizontal:hover &#123; image: url(:/client/images/scrollbar_arrowleft_down.png);&#125;/*横向滚动条左侧三角形图标 鼠标按下效果*/QScrollBar::left-arrow:horizontal:pressed &#123; image: url(:/client/images/scrollbar_arrowleft_highlight.png);&#125;/*横向滚动条右侧三角形部分*/QScrollBar::add-line:horizontal &#123; height: 10px; width: 12px; background: transparent; subcontrol-position: right;&#125;/*横向滚动条右侧三角形图标*/QScrollBar::right-arrow:horizontal &#123; image: url(:/client/images/scrollbar_arrowright_normal.png);&#125;/*横向滚动条右侧三角形图标 鼠标Hover效果*/QScrollBar::right-arrow:horizontal:hover &#123; image: url(:/client/images/scrollbar_arrowright_down.png);&#125;/*横向滚动条右侧三角形图标 鼠标按下效果*/QScrollBar::right-arrow:horizontal:pressed &#123; image: url(:/client/images/scrollbar_arrowright_highlight.png);&#125;","tags":["Qt","QSS","滚动条"],"categories":["Qt"]},{"title":"Qt子线程中更新UI","path":"/post/3531733309.html","content":"本文介绍两种在Qt子线程（非UI线程）中更新UI组件的常用方法。 1. 使用信号槽这是一种非常常规的方式，通过自定义信号、槽，连接该信号和槽，在子线程中发送信号，在槽中更新 UI。 定义信号和槽： 1234signals: void updateUi(int v);private slots: void onUpdateUi(int v); 在子线程中发送信号： 12345678910// 连接信号connect(this, &amp;UpdateUIInSubThread::updateUi, this, &amp;UpdateUIInSubThread::onUpdateUi, Qt::AutoConnection);std::thread t = std::thread([this]() &#123; for (int i = 0; i &lt; 10000; i++) &#123; emit updateUi(i); // 发送信号 std::this_thread::sleep_for(std::chrono::milliseconds(50)); &#125;&#125;);t.detach(); 在槽函数中更新 UI： 1234void UpdateUIInSubThread::onUpdateUi(int v)&#123; ui.label-&gt;setText(QString::number(v));&#125; 这种方式需要单独额外定义信号和槽，使用起来比较繁琐。 2. 使用invokeMethodQMetaObject::invokeMethod 函数的原型如下： 1template &lt;typename Functor, typename FunctorReturnType&gt; bool QMetaObject::invokeMethod(QObject *context, Functor function, Qt::ConnectionType type = Qt::AutoConnection, FunctorReturnType *ret = nullptr) 该函数可以在context的事件循环中执行function函数。 123456789101112std::thread t = std::thread([this]() &#123; for (int i = 0; i &lt; 10000; i++) &#123; if (QMetaObject::invokeMethod(this, [i, this]() &#123; ui.label-&gt;setText(QString::number(i)); &#125;)) &#123; qDebug() &lt;&lt; &quot;Update UI success&quot;; &#125; std::this_thread::sleep_for(std::chrono::milliseconds(50)); &#125;&#125;);t.detach(); 由于在子线程中更新 UI，因此信号和槽肯定使用的是 QueuedConnection 的连接方式，所以无法将FunctorReturnType返回给调用者，否则会出现如下错误： 1QMetaObject::invokeMethod: Unable to invoke methods with return values in queued connections 当然上述示例中也可以不使用 lambda 表达式，直接调用槽函数： 12345678std::thread t = std::thread([this]() &#123; for (int i = 0; i &lt; 10000; i++) &#123; QMetaObject::invokeMethod(this, &quot;onUpdateUi&quot;, Qt::AutoConnection, Q_ARG(int, i)); std::this_thread::sleep_for(std::chrono::milliseconds(50)); &#125;&#125;);t.detach();","tags":["Qt","线程"],"categories":["Qt"]},{"title":"Qt弹窗外部点击时自动关闭","path":"/post/3677374843.html","content":"本文介绍在 Qt 编程中如何实现当鼠标点击弹窗外部区域时，该弹窗可以自动关闭的效果。 1. ActivationChange 事件弹窗通过监听 Activation 改变事件，来判断自身是否还是当前的活动窗口，如果不是则关闭自身。 在 QWidget 里面重写 event，捕获 QEvent::ActivationChange 事件： 123456789bool UserCenterDlg::event(QEvent* e) &#123; if (e-&gt;type() == QEvent::ActivationChange) &#123; QWidget* curActiveWin = QApplication::activeWindow(); if (curActiveWin != this) &#123; this-&gt;close(); &#125; &#125; return QWidget::event(e);&#125; 2. Qt::WA_NoMouseReplay 介绍 摘自 Qt 帮助文档： Qt::WA_NoMouseReplay: Used for pop-up widgets. Indicates that the most recent mouse press event should not be replayed when the pop-up widget closes. The flag is set by the widget’s author and cleared by the Qt kernel every time the widget receives a new mouse event. Qt::WA_NoMouseReplay 属性可以用来避免如下情况的发生：在鼠标点击 Popup Widget 外部区域时，该 Widget 接收到自身的 Activation 状态发生改变，关闭自身，但在该 Widget 在关闭后，Qt 依然会将鼠标点击事件继续向下传递，从而窗口外区域下面的控件也会被点击。 由于 Qt::WA_NoMouseReplay 属性只对具有 Popup 属性的 Widget 起作用，因此只能使用 QWidget，不能使用 QDialog，并设置 Qt::Popup 属性。 1setWindowFlags(windowFlags() | Qt::Popup); 何时设置 Qt::WA_NoMouseReplay 属性了？ 重写 mousePressEvent，在鼠标按下事件发生时，设置 Qt::WA_NoMouseReplay 属性。 1234void UserCenterDlg::mousePressEvent(QMouseEvent* e) &#123; setAttribute(Qt::WA_NoMouseReplay); QWidget::mousePressEvent(e);&#125; 3. 自定义 closed 信号QWidget 没有关闭信号，我们可以自定义关闭信号，该信号在 closeEvent 中触发。 1234void UserCenterDlg::closeEvent(QCloseEvent* e) &#123; emit closed(); QWidget::closeEvent(e);&#125; 限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺 您可以通过在 blog-comment 项目中提交Issue来间接地发表评论🍀","tags":["Qt"],"categories":["Qt"]},{"title":"开源库nlohmann json使用备忘","path":"/post/1128187204.html","content":"nlohmann&#x2F;json 是一个用于解析 JSON 的开源 C++库，口碑一流，无需额外安装其他第三方库，还支持单个头文件模式，使用起来非常方便直观。 1. 编译从官网https://github.com/nlohmann/json的 Release 页面下载单个json.hpp即可直接使用，无需单独编译。 2. 使用示例下面以示例的方式罗列 nlohmann&#x2F;json 库的基本使用方法。 2.1 生成 JSON方式 112345678910111213141516171819int main()&#123; using json = nlohmann::json; json j; j[&quot;pi&quot;] = 3.141; j[&quot;happy&quot;] = true; j[&quot;name&quot;] = &quot;Niels&quot;; j[&quot;nothing&quot;] = nullptr; j[&quot;answer&quot;][&quot;everything&quot;] = 42; j[&quot;list&quot;] = &#123; 1, 0, 2 &#125;; j[&quot;object&quot;] = &#123; &#123;&quot;currency&quot;, &quot;USD&quot;&#125;, &#123;&quot;value&quot;, 42.99&#125; &#125;; // 转成字符串 std::string strJSON = j.dump(2); // 2个空格的缩进 std::cout &lt;&lt; strJSON; return 0;&#125; 输出如下： 1234567891011121314&#123; &quot;answer&quot;: &#123; &quot;everything&quot;: 42 &#125;, &quot;happy&quot;: true, &quot;list&quot;: [1, 0, 2], &quot;name&quot;: &quot;Niels&quot;, &quot;nothing&quot;: null, &quot;object&quot;: &#123; &quot;currency&quot;: &quot;USD&quot;, &quot;value&quot;: 42.99 &#125;, &quot;pi&quot;: 3.141&#125; 方式 212345678910111213141516171819int main()&#123; using json = nlohmann::json; json j = &#123; &#123;&quot;pi&quot;, 3.141&#125;, &#123;&quot;happy&quot;, true&#125;, &#123;&quot;name&quot;, &quot;Niels&quot;&#125;, &#123;&quot;nothing&quot;, nullptr&#125;, &#123;&quot;answer&quot;, &#123;&#123;&quot;everything&quot;, 42&#125;&#125;&#125;, &#123;&quot;list&quot;, &#123;1, 0, 2&#125;&#125;, &#123;&quot;object&quot;, &#123;&#123;&quot;currency&quot;, &quot;USD&quot;&#125;, &#123;&quot;value&quot;, 42.99&#125;&#125;&#125; &#125;; // 转成字符串 std::string strJSON = j.dump(2); std::cout &lt;&lt; strJSON; return 0;&#125; 输出内容与方式 1 一样。 方式 312345678910111213141516171819202122232425262728293031323334int main()&#123; using json = nlohmann::json; json j; j[&quot;pi&quot;] = 3.141; j[&quot;happy&quot;] = true; j[&quot;name&quot;] = &quot;Niels&quot;; j[&quot;nothing&quot;] = nullptr; json j_answer; j_answer[&quot;everything&quot;] = 42; j[&quot;answer&quot;] = j_answer; json j_list = json::array(); j_list.push_back(1); j_list.push_back(0); j_list.push_back(2); j[&quot;list&quot;] = j_list; json j_object; j_object[&quot;currency&quot;] = &quot;USD&quot;; j_object[&quot;value&quot;] = 42.99; j[&quot;object&quot;] = j_object; // 转成字符串 std::string strJSON = j.dump(2); std::cout &lt;&lt; strJSON; return 0;&#125; 输出内容与方式 1 一样。 2.2 解析 JSON12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int main()&#123; using json = nlohmann::json; std::string strJSON = u8R&quot;( &#123; &quot;answer&quot;: &#123; &quot;everything&quot;: 42 &#125;, &quot;happy&quot;: true, &quot;list&quot;: [ 1, 0, 2 ], &quot;name&quot;: &quot;Niels&quot;, &quot;nothing&quot;: null, &quot;object&quot;: &#123; &quot;currency&quot;: &quot;USD&quot;, &quot;value&quot;: 42.99 &#125;, &quot;pi&quot;: 3.141 &#125; )&quot;; auto jsonObj = json::parse(strJSON); std::cout &lt;&lt; jsonObj[&quot;pi&quot;].get&lt;float&gt;() &lt;&lt; std::endl; // 3.141 std::cout &lt;&lt; jsonObj[&quot;pi&quot;].get&lt;double&gt;() &lt;&lt; std::endl; // 3.141 std::cout &lt;&lt; std::boolalpha &lt;&lt; jsonObj[&quot;happy&quot;].get&lt;bool&gt;() &lt;&lt; std::endl; // true std::cout &lt;&lt; jsonObj[&quot;name&quot;].get&lt;std::string&gt;() &lt;&lt; std::endl; // Niels assert(jsonObj[&quot;nothing&quot;] == nullptr); std::cout &lt;&lt; jsonObj[&quot;answer&quot;][&quot;everything&quot;].get&lt;int&gt;() &lt;&lt; std::endl; // 42 std::cout &lt;&lt; jsonObj[&quot;list&quot;].size() &lt;&lt; std::endl; // 3 std::cout &lt;&lt; jsonObj[&quot;list&quot;][0].get&lt;int&gt;() &lt;&lt; std::endl; // 1 std::cout &lt;&lt; jsonObj[&quot;list&quot;][1].get&lt;int&gt;() &lt;&lt; std::endl; // 0 std::cout &lt;&lt; jsonObj[&quot;list&quot;][2].get&lt;int&gt;() &lt;&lt; std::endl; // 2 std::cout &lt;&lt; jsonObj[&quot;object&quot;][&quot;currency&quot;].get&lt;std::string&gt;() &lt;&lt; std::endl; // USD std::cout &lt;&lt; jsonObj[&quot;object&quot;][&quot;value&quot;].get&lt;float&gt;() &lt;&lt; std::endl; // 42.99 // 依次输出: // 1 // 0 // 2 for (json::iterator it = jsonObj[&quot;list&quot;].begin(); it != jsonObj[&quot;list&quot;].end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; std::endl; &#125; return 0;&#125; 3. 异常处理当解析和生成 JSON 出错时，nlohmann&#x2F;json 会抛出异常，因此在解析和生成 JSON 时，需要进行异常捕获。 1234567891011121314151617181920int main()&#123; using json = nlohmann::json; std::string strJSON = u8R&quot;( &#123; &quot;pi&quot;: 3.141 &#125; )&quot;; try &#123; auto jsonObj = json::parse(strJSON); std::cout &lt;&lt; jsonObj[&quot;ppp&quot;].get&lt;float&gt;() &lt;&lt; std::endl; &#125; catch (std::exception&amp; e) &#123; std::cout &lt;&lt; e.what() &lt;&lt; std::endl; &#125; return 0;&#125; 4. 判断成员是否存在12345678910111213141516int main()&#123; using json = nlohmann::json; std::string strJSON = u8R&quot;( &#123; &quot;pi&quot;: 3.141 &#125; )&quot;; auto jsonObj = json::parse(strJSON); std::cout &lt;&lt; std::boolalpha &lt;&lt; jsonObj.contains(&quot;pi&quot;) &lt;&lt; std::endl; // true std::cout &lt;&lt; std::boolalpha &lt;&lt; jsonObj.contains(&quot;ppp&quot;) &lt;&lt; std::endl; // false return 0;&#125;","tags":["JSON","开源库"],"categories":["开源库"]},{"title":"C++字符串和字符字面量","path":"/post/487899896.html","content":"C++支持各种字符串和字符类型，并提供了表达每种类型字面值的方法。在源代码中，我们使用字符集来表示字符或字符串。同时我们还可以使用通用字符名和转义字符来通过基本的源字符集表示任何字符串。而原始字符串能够避免对转义字符进行转义，并可用于表示所有类型的字符串。 1. 字符和字符串字面量1234567891011121314151617181920int main()&#123; // Character literals auto c0 = &#x27;A&#x27;; // char auto c1 = u8&#x27;A&#x27;; // char auto c2 = L&#x27;A&#x27;; // wchar_t auto c3 = u&#x27;A&#x27;; // char16_t auto c4 = U&#x27;A&#x27;; // char32_t // Multicharacter literals auto m0 = &#x27;abcd&#x27;; // int, value 0x61626364 // String literals auto s0 = &quot;hello&quot;; // const char* auto s1 = u8&quot;hello&quot;; // const char* before C++20, encoded as UTF-8, // const char8_t* in C++20 auto s2 = L&quot;hello&quot;; // const wchar_t* auto s3 = u&quot;hello&quot;; // const char16_t*, encoded as UTF-16 auto s4 = U&quot;hello&quot;; // const char32_t*, encoded as UTF-32&#125; 2. 原始字符串12345678910int main()&#123; // Raw string literals containing unescaped \\ and &quot; auto R0 = R&quot;(&quot;Hello \\ world&quot;)&quot;; // const char* auto R1 = u8R&quot;(&quot;Hello \\ world&quot;)&quot;; // const char* before C++20, encoded as UTF-8, // const char8_t* in C++20 auto R2 = LR&quot;(&quot;Hello \\ world&quot;)&quot;; // const wchar_t* auto R3 = uR&quot;(&quot;Hello \\ world&quot;)&quot;; // const char16_t*, encoded as UTF-16 auto R4 = UR&quot;(&quot;Hello \\ world&quot;)&quot;; // const char32_t*, encoded as UTF-32&#125; 3. 字符串后缀字符串后缀就是在字符串后面加s，如： 1234567891011121314auto S0 = &quot;hello&quot;s; // std::stringauto S1 = u8&quot;hello&quot;s; // std::string before C++20, std::u8string in C++20auto S2 = L&quot;hello&quot;s; // std::wstringauto S3 = u&quot;hello&quot;s; // std::u16stringauto S4 = U&quot;hello&quot;s; // std::u32stringstd::string_view sv = &quot;abc\\0\\0def&quot;sv;// 和原始字符串一起使用auto S5 = R&quot;(&quot;Hello \\ world&quot;)&quot;s; // std::string from a raw const char*auto S6 = u8R&quot;(&quot;Hello \\ world&quot;)&quot;s; // std::string from a raw const char* before C++20, encoded as UTF-8, // std::u8string in C++20auto S7 = LR&quot;(&quot;Hello \\ world&quot;)&quot;s; // std::wstring from a raw const wchar_t*auto S8 = uR&quot;(&quot;Hello \\ world&quot;)&quot;s; // std::u16string from a raw const char16_t*, encoded as UTF-16auto S9 = UR&quot;(&quot;Hello \\ world&quot;)&quot;s; // std::u32string from a raw const char32_t*, encoded as UTF-32 和不加后缀的区别如下： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;void print_with_zeros(auto const note, std::string const&amp; s)&#123; std::cout &lt;&lt; note; for (const char c : s) c ? std::cout &lt;&lt; c : std::cout &lt;&lt; &quot;₀&quot;; std::cout &lt;&lt; &quot; (size = &quot; &lt;&lt; s.size() &lt;&lt; &quot;) &quot;;&#125;int main()&#123; using namespace std::string_literals; std::string s1 = &quot;abc\\0\\0def&quot;; std::string s2 = &quot;abc\\0\\0def&quot;s; print_with_zeros(&quot;s1: &quot;, s1); print_with_zeros(&quot;s2: &quot;, s2); std::cout &lt;&lt; &quot;abcdef&quot;s.substr(1,4) &lt;&lt; &#x27; &#x27;;&#125; 输出： 123s1: abc (size = 3)s2: abc₀₀def (size = 8)bcde 4. 自定义字符串后缀字符串后缀是通过操作符的重载实现的： 1std::string operator&quot;&quot;s( const char *str, std::size_t len ); 我们也可以自定义操作符的重载来实现其他的字符串后缀，自定义的后缀建议以下划线开头，否则会产生编译警告： 1warning C4455: “operator &quot;&quot;mm”: 已保留不以下划线开头的文本后缀标识符 下面自定义_mm、_m、_km后缀分别表示毫米、米、千米： 1234567891011121314151617181920long double operator&quot;&quot; _mm(long double x) &#123; return x / 1000;&#125;long double operator&quot;&quot; _m(long double x) &#123; return x;&#125;long double operator&quot;&quot; _km(long double x) &#123; return x * 1000;&#125;int main()&#123; std::cout &lt;&lt; 1.0_mm &lt;&lt; std::endl; // 0.001 std::cout &lt;&lt; 1.0_m &lt;&lt; std::endl; // 1 std::cout &lt;&lt; 1.0_km &lt;&lt; std::endl; // 1000 return 0;&#125;","tags":["C++","字符串"],"categories":["C++语言"]},{"title":"CentOS7申请免费LetsEncrypt证书并续期","path":"/post/2025031576.html","content":"本文介绍在 CentOS7 环境下，使用 Certbot 申请免费的 Lets Encrypt SSL 证书，并自动续期。 1. 环境准备安装 Python3： 1yum install python3 安装 Certbot 和 Python 虚拟环境： 123456789# 假设certbot安装到/root/certbotmkdir -p /root/certbotcd /root/certbotpython3 -m venv venvsource venv/bin/activate# 升级pippip install --upgrade pip 阿里云注册并解析的域名，执行如下命令： 12# 安装certbotpip install certbot certbot-nginx certbot-dns-aliyun -i https://pypi.tuna.tsinghua.edu.cn/simple 2. 阿里云子账号创建阿里云子账号（https://ram.console.aliyun.com），并分配 AliyunDNSFullAccess 权限。 为子账号生成 access_key 和 access_secret。 创建/root/certbot/aliyun.ini文件，内容如下： 12dns_aliyun_access_key = XXXXXdns_aliyun_access_key_secret = XXXXX 使用如下命令修改该文件权限： 1chmod 600 /root/certbot/aliyun.ini 3. 申请证书以申请 mytools123.com 证书为例： 12345/root/certbot/venv/bin/certbot certonly \\-a dns-aliyun \\--dns-aliyun-credentials /root/certbot/aliyun.ini \\-d mytools123.com \\-d &quot;*.mytools123.com&quot; 执行成功后，生成的证书位于/etc/letsencrypt/live/mytools123.com目录 4. 手动续期Lets Encrypt 的证书有效期只有 3 个月，到期后需要手动续期。 12345# --dry-run 的是模拟更新证书/root/certbot/venv/bin/certbot renew -a dns-aliyun --dns-aliyun-credentials /root/certbot/aliyun.ini --dry-run# 正式更新证书/root/certbot/venv/bin/certbot renew -a dns-aliyun --dns-aliyun-credentials /root/certbot/aliyun.ini 5. 自动续期可以创建定时续期脚本，来实现自动续期。 创建脚本文件/root/renew_cert.sh，内容如下： 12# 更新证书/root/certbot/venv/bin/certbot renew -a dns-aliyun --dns-aliyun-credentials /root/certbot/aliyun.ini 为 sh 添加可执行权限： 1chmod +x /root/renew_cert.sh 新建定时任务： 1crontab -e 新增如下内容： 10 0,12 * * * python -c &#x27;import random; import time; time.sleep(random.random() * 3600)&#x27; &amp;&amp; /root/renew_cert.sh","tags":["CentOS","LetsEncrypt","SSL"],"categories":["服务端开发"]},{"title":"Vcpkg访问Github私有仓库","path":"/post/1904533666.html","content":"Vcpkg 默认只支持从公共代码仓库进行下载编译，本文介绍如何使用 Vcpkg 从私有仓库进行源码下载&#x2F;编译&#x2F;安装。 1.在 Github 中添加 TOKEN 2. 添加 Windows 环境变量：VCPKG_KEEP_ENV_VARS值为GITHUB_TOKEN GITHUB_TOKEN值为第一步生成的 TOKEN 3.修改 portfile.cmake在vcpkg\\ports目录下，找到对应库的 portfile.cmake 文件，加入AUTHORIZATION_TOKEN参数。 123456vcpkg_from_github( OUT_SOURCE_PATH SOURCE_PATH REPO xxx/xxx HEAD_REF main AUTHORIZATION_TOKEN $ENV&#123;GITHUB_TOKEN&#125;)","tags":["CMake","Vcpkg","Github"],"categories":["CMake"]},{"title":"Windows实现文件强制占用","path":"/post/434128163.html","content":"本文介绍在 Windows 系统上实现使某个文件无法被用户或其他程序删除。 实现的原理大致如下： 通过DuplicateHandle拷贝文件句柄给另外一个进程（一般是系统进程），因为系统进程不会被关闭，所以达到了占用某个文件，不让其他进程删除、读取、写入等。 DuplicateHandle的用法参考：- Windows内核对象 因为需要拷贝文件句柄给系统进程，所以涉及到打开系统进程，可能需要提权操作，一般授权给进程SE_DEBUG_NAME权限即可。 实现一个用于锁住文件的函数LockFile，将文件句柄复制给系统csrss.exe进程，函数实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758bool LockFile(LPCTSTR lpFilePath) &#123; if (lpFilePath == NULL) return false; // 查找进程csrss.exe // DWORD dwCsrssProcessID = 0; PROCESSENTRY32 pe; pe.dwSize = sizeof(PROCESSENTRY32); HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); while (Process32Next(hSnapShot, &amp;pe)) &#123; if (lstrcmpi(pe.szExeFile, TEXT(&quot;csrss.exe&quot;)) == 0) &#123; dwCsrssProcessID = pe.th32ProcessID; break; &#125; &#125; CloseHandle(hSnapShot); // 未找到 if (dwCsrssProcessID == 0) &#123; return false; &#125; HANDLE hProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwCsrssProcessID); // 打开失败，可能是当前进程未提权导致，需要提前进行提权操作 if (hProcess == NULL) &#123; return false; &#125; HANDLE hFile = CreateFile(lpFilePath, GENERIC_READ | GENERIC_EXECUTE | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) &#123; CloseHandle(hProcess); return false; &#125; HANDLE hTargetHandle = INVALID_HANDLE_VALUE; BOOL bRet = DuplicateHandle(GetCurrentProcess(), hFile, hProcess, &amp;hTargetHandle, 0, FALSE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE ); CloseHandle(hProcess); return (bRet == TRUE);&#125;","tags":["句柄"],"categories":["Windows编程"]},{"title":"Vcpkg安装port历史版本","path":"/post/1142527271.html","content":"截至 2023-05-22：vcpkg 仅支持在 manifest 模式下指定 port 的版本，在命令行模式下不支持指定 port 版本。 本文介绍如何在 Vcpkg 命令行模式下安装 port 时如何指定版本。 使用 Git 命令查看当前 Vcpkg 仓库的 baseline： 1git rev-parse HEAD 创建vcpkg_json目录，并在该目录下创建vcpkg.json文件（以 openssl 为例）： 1234567891011&#123; &quot;name&quot;: &quot;cc&quot;, &quot;version&quot;: &quot;1.0.1&quot;, &quot;builtin-baseline&quot;: &quot;7b30311f0a79d395bf2d933d82fec1853c6a4e77&quot;, &quot;dependencies&quot;: [ &#123;&quot;name&quot;: &quot;openssl&quot;&#125; ], &quot;overrides&quot;: [ &#123; &quot;name&quot;: &quot;openssl&quot;, &quot;version-string&quot;: &quot;1.1.1n#1&quot; &#125; ]&#125; 使用如下命令安装： 1vcpkg install --triplet &quot;x64-windows&quot; &quot;--x-manifest-root=D:\\vcpkg_json\\\\&quot; &quot;--x-install-root=D:CODE\\vcpkg\\installed\\\\&quot;","tags":["CMake","Vcpkg"],"categories":["CMake"]},{"title":"CentOS7更新国内阿里源","path":"/post/1822204079.html","content":"依次执行如下命令： 1yum install -y wget 12345# 备份并下载阿里云的base和epel源mv -f /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backupwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repomv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backupwget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 123yum clean allyum makecacheyum -y update","tags":["CentOS"],"categories":["服务端开发"]},{"title":"CMake依赖库查找相关问题","path":"/post/2291877732.html","content":"1. 如何查找 Vcpkg 安装的依赖库在 CMake 工具中指定跨平台工具链，如图： 指定 Toolchain 文件D:/sourcecode/vcpkg/scripts/buildsystems/vcpkg.cmake。 2. 如何查找本机安装的 Qt 库设置环境变量CMAKE_PREFIX_PATH，值为 Qt 的安装目录，如C:\\Qt\\5.15.2\\msvc2019，然后启动 CMake 即可。 也可以使用如下批处理来临时设置和启动： 123@echo offset CMAKE_PREFIX_PATH=C:\\Qt\\5.15.2\\msvc2019start &quot;&quot; &quot;C:\\Program Files\\CMake\\bin\\cmake-gui.exe&quot;","tags":["CMake","Vcpkg"],"categories":["CMake"]},{"title":"NPM和Yarn设置国内源","path":"/post/908211703.html","content":"淘宝镜像源的域名已由之前的npm.taobao.org变更为npmmirror.com，见阿里云公告。目前老域名（npm.taobao.org）的证书已过期，若继续使用老域名会出现certificate has expired的错误提示。 1. Yarn 设置查看当前使用的镜像源： 1yarn config get registry 全局修改： 123456789101112yarn config set registry https://registry.npmmirror.com yarn config set disturl https://npmmirror.com/mirrors/nodeyarn config set sass_binary_site https://npmmirror.com/mirrors/node-sassyarn config set puppeteer_download_host https://npmmirror.com/mirrorsyarn config set chromedriver_cdnurl https://npmmirror.com/mirrors/chromedriveryarn config set operadriver_cdnurl https://npmmirror.com/mirrors/operadriveryarn config set phantomjs_cdnurl https://npmmirror.com/mirrors/phantomjsyarn config set selenium_cdnurl https://npmmirror.com/mirrors/seleniumyarn config set node_inspector_cdnurl https://npmmirror.com/mirrors/node-inspectoryarn config set sentrycli_cdnurl https://npmmirror.com/mirrors/sentry-cliyarn config set electron_mirror https://npmmirror.com/mirrors/electron/yarn cache clean 临时修改源： 1yarn save 软件名 --registry https://registry.npmmirror.com/ 如需还原到默认源，将上述命令中的 npmmirror.com 替换为 yarnpkg.com。 2. NPM 设置全局设置： 1234npm set registry https://registry.npmmirror.comnpm cache clean --force 如需还原到默认源，将上述命令中的 npmmirror.com 替换为 npmjs.org。 NPM v8版本之前支持的一些配置参数，如electron_mirror、disturl等，在v9及后面的版本都不再支持，可以在 https://docs.npmjs.com/cli/v11/using-npm/config#config-settings 页面查看npm支持的所有配置参数。 其他常用命令： 12345678# 查看当前使用的镜像源npm get registry# 输出当前配置npm config list# 输出config命令的帮助npm help config","tags":["Web","Yarn","NPM"],"categories":["Web编程"]},{"title":"LLVM-Obfuscator代码混淆","path":"/post/2256274631.html","content":"LLVM-Obfuscator 可用于混淆程序的代码逻辑，本文介绍如何使用 LLVM-Obfuscator 进行代码逻辑的混淆。 1. 安装 VS Clang 组件 2. 编译 LLVM-Obfuscator使用 heroims 的 Fork 版本：heroims&#x2F;obfuscator 2.1 Clone 最新 13.x 分支1git clone -b llvm-13.x https://github.com/obfuscator-llvm/obfuscator.git 2.2 安装 mingw从https://github.com/niXman/mingw-builds-binaries/releases 下载 32 位和 64 位 MingW: i686-12.2.0-release-posix-dwarf-msvcrt-rt_v10-rev2.7z x86_64-12.2.0-release-posix-seh-msvcrt-rt_v10-rev2.7z 分别解压到不同的目录。 2.3 编译 64 位 LLVM-Obfuscator打开 CMD，将 64 位 MingW 的 bin 目录添加到 PATH 环境变量： 1SET PATH=%PATH%;C:\\mingw64\\x86_64-12.2.0-release-posix-seh-msvcrt-rt_v10-rev2\\bin 在命令行进入 LLVM-Obfuscator 所在目录，开始编译： 123456mkdir build64cd build64cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_CREATE_XCODE_TOOLCHAIN=ON -DLLVM_ENABLE_NEW_PASS_MANAGER=OFF -G &quot;MinGW Makefiles&quot; ../llvmmingw32-make.exe -j8 2.4 编译 32 位 LLVM-Obfuscator重新打开 CMD，将 32 位 MingW 的 bin 目录添加到 PATH 环境变量： 1SET PATH=%PATH%;C:\\mingw32\\i686-12.2.0-release-posix-dwarf-msvcrt-rt_v10-rev2\\bin 在命令行进入 LLVM-Obfuscator 所在目录，开始编译： 1234mkdir build32cd build32cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_CREATE_XCODE_TOOLCHAIN=ON -DLLVM_ENABLE_NEW_PASS_MANAGER=OFF -G &quot;MinGW Makefiles&quot; ../llvmmingw32-make.exe -j8 3. 用编译输出覆盖到 VS ClangVisual Studio 的 Clang 位于C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\Llvm目录，分别将编译的 32 位和 64 位bin目录中的文件覆盖到 VS Clang 的bin目录中（注意：在覆盖之前，最好先备份）。 4. 设置环境变量在编译完之后，将 32 位和 64 位 MingW 的bin目录路径都添加到 PATH 环境变量中。因为 VS 编译时会启动 clang.exe，而 clang.exe 需要依赖 MingW。 5. VS 工程配置 命令行其他选项如下： 1-D__CUDACC__ -D_ALLOW_COMPILER_AND_STL_VERSION_MISMATCH -mllvm -bcf -mllvm -bcf_prob=73 -mllvm -bcf_loop=1 -mllvm -sub -mllvm -sub_loop=5 -mllvm -fla -mllvm -split_num=5 -mllvm -aesSeed=DEADBEEFDEADCODEDEADBEEFDEADCODE 6. 混淆配置参数开启控制流扁平化-mllvm -fla 开启控制流扁平化 -mllvm -split 激活基本块划分。一起使用时能提高打平能力。 -mllvm -split_num=3 如果激活控制流打平，对每一个基本块应用三次控制流打平。默认使用 1 次。 开启指令替换-mllvm -sub 开启指令替换 -mllvm -sub_loop=3 如果激活了指令替换，使用这个选项在一个函数中应用 3 次指令替换。默认应用 1 次。 开启虚假控制流-mllvm -bcf 开启虚假控制流。 bcf可以配合下面参数使用： -mllvm -bcf_loop=3 设置函数混淆次数为 3 次 不加此选项默认为 1 次。 -mllvm -bcf_prob=40 设置代码块被混淆的概率是 40%，默认 30% 7. CMakeList 中配置混淆参数12345678910111213141516#debug and release all enableSET(CMAKE_CXX_FLAGS &quot;-mllvm -fla -mllvm -sub -mllvm -sobf &quot;)#so体积优化，（按需开启）#SET(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g2 -ggdb&quot;)#SET(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV&#123;CXXFLAGS&#125; -Os -Wall -s&quot;)#设置llvm debug模式混淆编译SET(CMAKE_C_FLAGS_DEBUG &quot;$&#123;CMAKE_C_FLAGS_DEBUG&#125; -mllvm -fla&quot;)SET(CMAKE_CXX_FLAGS_DEBUG &quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -mllvm -fla&quot;)#设置llvm release模式混淆编译SET(CMAKE_C_FLAGS_RELEASE &quot;$&#123;CMAKE_C_FLAGS_RELEASE&#125; -mllvm -fla -mllvm -sub -mllvm -bcf&quot;)SET(CMAKE_CXX_FLAGS_RELEASE &quot;$&#123;CMAKE_CXX_FLAGS_RELEASE&#125; -mllvm -fla -mllvm -sub -mllvm -bcf&quot;)SET(CMAKE_CXX_FLAGS_RELEASE &quot;$&#123;CMAKE_CXX_FLAGS_RELEASE&#125; -s -O3 -Wall -fvisibility=hidden -mllvm -fla&quot;)","tags":["C++","LLVM","混淆"],"categories":["C++语言"]},{"title":"一个Dockerfile同时运行多个进程","path":"/post/2409581593.html","content":"Docker 容器的哲学是一个 Docker 容器只运行一个进程。 但如果需要在一个容器内运行多个进程或服务，可以采取将入口文件设置为 Bash Shell 脚本，在脚本内运行多个程序的方式。 1234567891011#!/bin/bash# start 1start1 &gt; /var/log/start1.log 2&gt;&amp;1 &amp;# start 2start2 &gt; /var/log/start2.log 2&gt;&amp;1 &amp;# just keep this script runningwhile [[ true ]]; do sleep 1done 在 Dockerfile 的入口中运行 run.sh： 1234FROM ubuntu:latest...COPY ./run.sh /ENTRYPOINT [&quot;run.sh&quot;]","tags":["Docker"],"categories":["服务端开发"]},{"title":"C++构造函数排雷","path":"/post/3768553066.html","content":"一、默认构造函数1.1 什么是默认构造函数？我们一般会认为默认构造函数就是编译器自动生成的那个构造函数，其实这种理解不全面。准确的说，默认构造函数就是在调用时不需要显示地传入实参的构造函数。根据这个原则，下面 2 种构造函数都是默认构造函数： 1234567class Sample &#123;public: // 默认构造函数。 Sample() &#123; // do something &#125;&#125;; 1234567class Sample &#123;public: // 默认构造函数。虽然有形参，但有默认值，调用的时候可以不显示的传入实参。 Sample(int m = 10) &#123; // do something &#125;&#125;; 1.2 默认构造函数调用时机如果定义一个对象时没有使用初始化式，编译器就会使用默认构造函数。如： 1Sample s; 1.3 编译器何时生成默认构造函数有一句很经典的话可以用来回答这个问题：惟有默认构造函数”被编译器需要“的时候，编译器才会生成默认构造函数。 那我们只需知道什么时候“被编译器需要”，就可以知道什么情况下会生成默认构造函数了。下面几种情况下，编译需要生成默认构造函数： 当该类的类对象数据成员有默认构造函数时。 当该类的基类有默认构造函数时。 当该类的基类为虚基类时。 当该类有虚函数时。 1.4 注意事项1. 避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在 无参数的默认构造函数和带缺省参数的默认构造函数同时存在时，编译器会产生二义性，从而生成编译错误。 12345678910111213141516171819202122class Sample &#123;public: // 默认构造函数 Sample() &#123; // do something printf(&quot;Sample()&quot;); &#125; // 默认构造函数 Sample(int m = 10) &#123; // do something printf(&quot;Sample(int m = 10)&quot;); &#125;&#125;;int main()&#123; Sample s; // error C2668: “Sample::Sample”: 对重载函数的调用不明确 return 0;&#125; 2. 使用无参构造函数创建对象时，不应在对象名后面加上括号 使用无参构造函数创建对象时，不应在对象名后面加上括号，否则会产生编译警告“warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?)”。因为编译器误认为Sample s();语句时要声明返回值为Sample对象的函数s，而又没找到函数s的定义，所以产生了警告。 12345678910111213141516class Sample &#123;public: // 默认构造函数 Sample() &#123; // do something printf(&quot;Sample()&quot;); &#125;&#125;;int main()&#123; Sample s(); // warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?) return 0;&#125; 二、构造函数初始化列表2.1 何为构造函数初始化列表1234567891011121314class Sample &#123;public: // 构造函数内部赋值 Sample(int a) &#123; a_ = a; &#125; // 构造函数初始化列表 Sample(int a) : a_(a) &#123; &#125;private: int a_;&#125;; 上面的代码中，Sample类的 2 个构造函数的功能是一样的，都是初始化成员变量a_，区别在于一个采用的是构造函数内部赋值的方式来初始化的，另一个采用的是构造函数初始化列表初始化列表的方式来初始化的。 2.1 何时必须使用初始化列表如果按照上面所说的，既然 2 种初始化成员变量的方式所起得作用是一样的，那么在哪些情况下必须使用构造函数初始化列表的了？下面 2 种情况的成员变量必须使用构造函数初始化列表的方式来初始化： 成员变量是 const 常量。 成员变量是引用类型。 下面例子演示了成员变量是const常量和引用类型时，如何初始化它们： 123456789class Sample &#123;public: Sample() : kCount(11), name_(std::string(&quot;jeff&quot;)) &#123; &#125;private: std::string &amp;name_; const int kCount;&#125;; 2.3 初始化列表的顺序问题使用构造函数初始化列表进行成员变量初始化时，要注意成员变量的初始化顺序。举个例子来说明，现有类SeqSample有 3 个成员变量a_, b_, c_，构造函数被设计为将a_, b_, c_都初始化为m，也就是a_ == b_ == c_ == m： 123456789101112131415161718192021class SeqSample &#123;public: SeqSample(int m) : a_(m), b_(a_), c_(b_) &#123; &#125;private: int b_; int a_; int c_;&#125;;int main()&#123; SeqSample ss(1); return 0;&#125; 通过调试器观察到执行构造函数初始化之后，成员变量a_, b_, c_的值分别为： 123b_ = -858993460a_ = 1c_ = -858993460 而不是我们期望的a_ = 1 b_ = 1 c_ = 1。 出现这种问题的原因在于：编译器对构造函数初始化列表中的变量进行初始化的时候，不是按照变量初始化列表中的顺序来进行初始化的，而是按照变量在类中的声明顺序来初始化的。 所以，在初始化列表中的变量有依赖关系时（如上面的b_依赖于a_的初始化结果），要特别注意这种情况。 2.4 初始化列表的另一个好处先模糊的把这个好处说出来，不太明白的，可以看下面的示例：若成员变量是类对象，则使用构造函数的初始化列表可以减少一次默认构造函数的调用。 测试代码如下（声明了一个Apple类，一个Test类，Test 类中有 2 个 Apple 对象apple1_, apple2_，唯一不同的是，apple1_通过初始化列表来初始化，apple2_通过函数体中的赋值语句来初始化）： 12345678910111213141516171819202122232425262728293031323334class Apple &#123;public: Apple() &#123; printf(&quot;默认构造函数 &quot;); &#125; Apple(const Apple &amp;that) &#123; printf(&quot;复制构造函数 &quot;); &#125; Apple&amp; operator = (const Apple&amp;that) &#123; printf(&quot;赋值运算符重载 &quot;); return *this; &#125;&#125;;class Test &#123;public: Test(const Apple &amp;apple) : apple1_(apple) &#123; apple2_ = apple; &#125;private: Apple apple1_; Apple apple2_;&#125;;int main()&#123; Apple apple; Test t(apple); return 0;&#125; 运行结果： 1234默认构造函数复制构造函数默认构造函数赋值运算符重载 4 行输出分别由不同的语句产生，如图： apple1_(apple)直接执行的复制构造函数，所以只产生一行输出；而apple2_ = apple;却是先使用默认构造函数构造了一个 apple2对象，然后再通过赋值运算符将 apple 的内容更新到 apple2中，所以产生了 2 行输出。 2.5 构造函数初始化列表的异常捕获构造的函数的初始化列表也可以使用异常捕获，具体使用方式如下： 12345678910111213class Foo &#123;public: Foo::Foo(int n) try :size(n), array(new int[n]) &#123; //... &#125; catch (const std::bad_alloc&amp; e) &#123; printf(&quot;%s &quot;, e.what()); &#125;private: int size; int *array;&#125;;","tags":["C++","构造函数"],"categories":["C++语言"]},{"title":"C++生成条形码","path":"/post/3756556672.html","content":"条形码(barcode)是将宽度不等的多个黑条和空白，按照一定的编码规则排列，用以表达一组信息的图形标识符。常见的条形码是由反射率相差很大的黑条（简称条）和白条（简称空）排成的平行线图案。 一、条形码介绍条码种类很多，常见的大概有二十多种码制，其中包括：Code39 码（标准 39 码）、Codabar 码（库德巴码）、Code25 码（标准 25 码）、ITF25 码（交叉 25 码）、Matrix25 码（矩阵 25 码）、UPC-A 码、UPC-E 码、EAN-13 码（EAN-13 国际商品条码）、EAN-8 码（EAN-8 国际商品条码）、中国邮政码（矩阵 25 码的一种变体）、Code-B 码、MSI 码、Code11 码、Code93 码、ISBN 码、ISSN 码、Code128 码（Code128 码，包括 EAN128 码）、Code39EMS（EMS 专用的 39 码）等一维条码和 PDF417 等二维条码。 目前，国际广泛使用的条码种类有： EAN 码 —— 国际物品编码协会制定的一种商品用条码，通用于全世界。EAN 码符号有标准版（EAN-13）和缩短版（EAN-8）两种，我国的通用商品条码与其等效，日常购买的商品包装上所印的条码一般就是 EAN 码。 UPC 码 —— UPC 码是美国统一代码委员会制定的一种商品用条码，主要用于美国和加拿大地区，我们在美国进口的商品上可以看到。 Code39 码 —— 因其可采用数字与字母共同组成的方式而在各行业内部管理上被广泛使用。 Code93 码 —— Code 93 码与 39 码具有相同的字符集，但它的密度要比 39 码高，所以在面积不足的情况下，可以用 93 码代替 39 码 Codebar 码 —— 可表示数字 0 - 9，字符$、+、 -、还有只能用作起始&#x2F;终止符的 a,b,c d 四个字符，可变长度，没有校验位，多用于血库,图书馆和照像馆的业务中。 Code128 码 —— 128 可表示 ASCII 0 到 ASCII 127 共计 128 个 ASCII 字符。 CodeI2of5 码 —— 只能表示数字 0 -9 可变长度，连续性条形码，所有条与空都表示代码，第一个数字由条开始，第二个数字由空组成，空白区比窄条宽 10 倍，应用于商品批发、仓库、机场、生产&#x2F;包装识别、工业中，条形码的识读率高，可适用于固定扫描器可靠扫描，在所有一维条形码中的密度最高。 二、C++方式实现barcode.h 中实现了 Code39、Code93、Code128、CodeI2of5 等 4 种格式的条形码的生成。具体使用方法：调用对应类的DrawBarcode函数将条形码绘制到 HDC 上，绘制到 HDC 上之后可以保存为图片或者显示到界面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242#ifndef BARCODE_H_#define BARCODE_H_#pragma onceclass Barcode39;class Barcode93;class BarcodeIof5;class Barcode128;static const int ga2_Code128[2][207] =&#123; &#123; 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, &#125;, &#123; -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, &#125;,&#125;;class BarcodeBase &#123;public: BarcodeBase() &#123; Clear(); i_Ratio = 3; &#125; void operator=(const BarcodeBase&amp;bc) &#123; i_LenBuf = bc.i_LenBuf; i_Ratio = bc.i_Ratio; memcpy(ia_Buf, bc.ia_Buf, sizeof(ia_Buf)); &#125; void Clear() &#123; memset(ia_Buf, 0, sizeof(ia_Buf)); i_LenBuf = 0; &#125; int GetEncodeLength() const &#123; BYTE*pb = (BYTE*)ia_Buf; int i, iLen = 0; for (i = 0; i &lt; i_LenBuf; i++) &#123; //wide is 3 if (*pb &amp; 2) iLen += (i_Ratio - 1); pb++; &#125; return iLen + i_LenBuf; &#125; int GetBufferLength() const &#123; return i_LenBuf; &#125; const BYTE&amp;GetAt(int i) const &#123; return ia_Buf[i]; &#125; int GetRatio() const &#123; return i_Ratio; &#125; int SetRatio(int iRatio) &#123; i_Ratio = iRatio; if (i_Ratio &lt;= 0) i_Ratio = 1; &#125; void DrawBarcode(HDC hDC, int iX, int iY0, int iY10, int iY11, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) &#123; HPEN hPenBar = ::CreatePen(PS_SOLID, iPenW, clrBar); HPEN hPenSpace = ::CreatePen(PS_SOLID, iPenW, clrSpace); HPEN hPenOld = (HPEN)::SelectObject(hDC, hPenBar); BYTE*pb = ia_Buf; int i0, iNum0 = i_LenBuf; BYTE bBar; int i1, iNum1; int iY; for (i0 = 0; i0 &lt; iNum0; i0++) &#123; bBar = *pb &amp; 0x01; iNum1 = (*pb &amp; 0x02) ? i_Ratio : 1; iY = (*pb &amp; 0x04) ? iY11 : iY10; for (i1 = 0; i1 &lt; iNum1; i1++) &#123; if (bBar) ::SelectObject(hDC, hPenBar); else ::SelectObject(hDC, hPenSpace); ::MoveToEx(hDC, iX, iY0, 0); ::LineTo(hDC, iX, iY); iX += iPenW; &#125; pb++; &#125; ::SelectObject(hDC, hPenOld); ::DeleteObject(hPenBar); ::DeleteObject(hPenSpace); &#125;protected: BYTE ia_Buf[4096]; int i_LenBuf; int i_Ratio; struct IntString &#123; int ch; char*psz; &#125;;&#125;;class Barcode39 : public BarcodeBase &#123; //[n/a][n/a][n/a][n/a][n/a][n/a][w-n][b-s]public: Barcode39() &#123; &#125; ~Barcode39() &#123; &#125; BOOL Encode39(const char*pszCodeIn) &#123; int iLen = strlen(pszCodeIn); char*pszCode = new char[iLen + 3]; sprintf(pszCode, &quot;*%s*&quot;, pszCodeIn); strupr(pszCode); BYTE*pFst = ia_Buf; BYTE*p0 = pFst, *p1; iLen += 2; int i; for (i = 0; i &lt; iLen; i++) &#123; p1 = P_GetNarrowWideBarSpace39(pszCode[i], p0); if (p1 == 0) return 0; p0 = p1; &#125; i_LenBuf = p1 - pFst; delete[]pszCode; return 1; &#125; void Draw39(HDC hDC, int iX, int iY0, int iY1, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) &#123; DrawBarcode(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW); &#125;private: BYTE*P_GetNarrowWideBarSpace39(char ch, BYTE*pb) &#123; IntString infs[] = &#123; &#123;&#x27;1&#x27;, &quot;wnnwnnnnwn&quot;&#125;, &#123;&#x27;2&#x27;, &quot;nnwwnnnnwn&quot;&#125;, &#123;&#x27;3&#x27;, &quot;wnwwnnnnnn&quot;&#125;, &#123;&#x27;4&#x27;, &quot;nnnwwnnnwn&quot;&#125;, &#123;&#x27;5&#x27;, &quot;wnnwwnnnnn&quot;&#125;, &#123;&#x27;6&#x27;, &quot;nnwwwnnnnn&quot;&#125;, &#123;&#x27;7&#x27;, &quot;nnnwnnwnwn&quot;&#125;, &#123;&#x27;8&#x27;, &quot;wnnwnnwnnn&quot;&#125;, &#123;&#x27;9&#x27;, &quot;nnwwnnwnnn&quot;&#125;, &#123;&#x27;0&#x27;, &quot;nnnwwnwnnn&quot;&#125;, &#123;&#x27;A&#x27;, &quot;wnnnnwnnwn&quot;&#125;, &#123;&#x27;B&#x27;, &quot;nnwnnwnnwn&quot;&#125;, &#123;&#x27;C&#x27;, &quot;wnwnnwnnnn&quot;&#125;, &#123;&#x27;D&#x27;, &quot;nnnnwwnnwn&quot;&#125;, &#123;&#x27;E&#x27;, &quot;wnnnwwnnnn&quot;&#125;, &#123;&#x27;F&#x27;, &quot;nnwnwwnnnn&quot;&#125;, &#123;&#x27;G&#x27;, &quot;nnnnnwwnwn&quot;&#125;, &#123;&#x27;H&#x27;, &quot;wnnnnwwnnn&quot;&#125;, &#123;&#x27;I&#x27;, &quot;nnwnnwwnnn&quot;&#125;, &#123;&#x27;J&#x27;, &quot;nnnnwwwnnn&quot;&#125;, &#123;&#x27;K&#x27;, &quot;wnnnnnnwwn&quot;&#125;, &#123;&#x27;L&#x27;, &quot;nnwnnnnwwn&quot;&#125;, &#123;&#x27;M&#x27;, &quot;wnwnnnnwnn&quot;&#125;, &#123;&#x27;N&#x27;, &quot;nnnnwnnwwn&quot;&#125;, &#123;&#x27;O&#x27;, &quot;wnnnwnnwnn&quot;&#125;, &#123;&#x27;P&#x27;, &quot;nnwnwnnwnn&quot;&#125;, &#123;&#x27;Q&#x27;, &quot;nnnnnnwwwn&quot;&#125;, &#123;&#x27;R&#x27;, &quot;wnnnnnwwnn&quot;&#125;, &#123;&#x27;S&#x27;, &quot;nnwnnnwwnn&quot;&#125;, &#123;&#x27;T&#x27;, &quot;nnnnwnwwnn&quot;&#125;, &#123;&#x27;U&#x27;, &quot;wwnnnnnnwn&quot;&#125;, &#123;&#x27;V&#x27;, &quot;nwwnnnnnwn&quot;&#125;, &#123;&#x27;W&#x27;, &quot;wwwnnnnnnn&quot;&#125;, &#123;&#x27;X&#x27;, &quot;nwnnwnnnwn&quot;&#125;, &#123;&#x27;Y&#x27;, &quot;wwnnwnnnnn&quot;&#125;, &#123;&#x27;Z&#x27;, &quot;nwwnwnnnnn&quot;&#125;, &#123;&#x27;-&#x27;, &quot;nwnnnnwnwn&quot;&#125;, &#123;&#x27;.&#x27;, &quot;wwnnnnwnnn&quot;&#125;, &#123;&#x27; &#x27;, &quot;nwwnnnwnnn&quot;&#125;, &#123;&#x27;*&#x27;, &quot;nwnnwnwnnn&quot;&#125;, &#123;&#x27;$&#x27;, &quot;nwnwnwnnnn&quot;&#125;, &#123;&#x27;/&#x27;, &quot;nwnwnnnwnn&quot;&#125;, &#123;&#x27;+&#x27;, &quot;nwnnnwnwnn&quot;&#125;, &#123;&#x27;%&#x27;, &quot;nnnwnwnwnn&quot;&#125;, &#125;; int i0, iNum0 = sizeof(infs) / sizeof(infs[0]); int i1; for (i0 = 0; i0 &lt; iNum0; i0++) &#123; IntString&amp;inf = infs[i0]; if (inf.ch == ch) &#123; for (i1 = 0; i1 &lt; 10; i1++) &#123; if (inf.psz[i1] == &#x27;w&#x27;) *pb += 2; if (i1 % 2 == 0) *pb += 1; pb++; &#125; return pb; &#125; &#125; return 0; &#125;&#125;;class BarcodeI2of5 :public BarcodeBase &#123; //[n/a][n/a][n/a][n/a][n/a][n/a][w-n][b-s]public: BarcodeI2of5() &#123; &#125; ~BarcodeI2of5() &#123; &#125; BOOL EncodeI2of5(const char*pszCode) &#123; Clear(); BYTE*pFst = ia_Buf; BYTE*pb = pFst; const int iNum = strlen(pszCode); int i; //&quot;nnnn&quot; for (i = 0; i &lt; 4; i++) &#123; if (i % 2 == 0) *pb += 1; pb++; &#125; int iV; for (i = 0; i &lt; iNum; i += 2) &#123; iV = pszCode[i] - &#x27;0&#x27;; iV = iV * 10; iV += pszCode[i + 1] - &#x27;0&#x27;; pb = P_GetNarrorWideBarSpaceI2of5(pb, iV); if (pb == 0) return 0; &#125; //&quot;wnn&quot; *pb += 3; pb++; *pb += 0; pb++; *pb += 1; pb++; i_LenBuf = pb - pFst; return 1; &#125; void DrawI2of5(HDC hDC, int iX, int iY0, int iY1, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) &#123; DrawBarcode(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW); &#125;private: BYTE*P_GetNarrorWideBarSpaceI2of5(BYTE*pb, int ch) &#123; if (ch &lt; 0) return 0; if (ch &gt; 99) return 0; IntString infs[] = &#123; &#123;0, &quot;nnnnwwwwnn&quot;&#125;, &#123;1, &quot;nwnnwnwnnw&quot;&#125;, &#123;2, &quot;nnnwwnwnnw&quot;&#125;, &#123;3, &quot;nwnwwnwnnn&quot;&#125;, &#123;4, &quot;nnnnwwwnnw&quot;&#125;, &#123;5, &quot;nwnnwwwnnn&quot;&#125;, &#123;6, &quot;nnnwwwwnnn&quot;&#125;, &#123;7, &quot;nnnnwnwwnw&quot;&#125;, &#123;8, &quot;nwnnwnwwnn&quot;&#125;, &#123;9, &quot;nnnwwnwwnn&quot;&#125;, &#123;10, &quot;wnnnnwnwwn&quot;&#125;, &#123;11, &quot;wwnnnnnnww&quot;&#125;, &#123;12, &quot;wnnwnnnnww&quot;&#125;, &#123;13, &quot;wwnwnnnnwn&quot;&#125;, &#123;14, &quot;wnnnnwnnww&quot;&#125;, &#123;15, &quot;wwnnnwnnwn&quot;&#125;, &#123;16, &quot;wnnwnwnnwn&quot;&#125;, &#123;17, &quot;wnnnnnnwww&quot;&#125;, &#123;18, &quot;wwnnnnnwwn&quot;&#125;, &#123;19, &quot;wnnwnnnwwn&quot;&#125;, &#123;20, &quot;nnwnnwnwwn&quot;&#125;, &#123;21, &quot;nwwnnnnnww&quot;&#125;, &#123;22, &quot;nnwwnnnnww&quot;&#125;, &#123;23, &quot;nwwwnnnnwn&quot;&#125;, &#123;24, &quot;nnwnnwnnww&quot;&#125;, &#123;25, &quot;nwwnnwnnwn&quot;&#125;, &#123;26, &quot;nnwwnwnnwn&quot;&#125;, &#123;27, &quot;nnwnnnnwww&quot;&#125;, &#123;28, &quot;nwwnnnnwwn&quot;&#125;, &#123;29, &quot;nnwwnnnwwn&quot;&#125;, &#123;30, &quot;wnwnnwnwnn&quot;&#125;, &#123;31, &quot;wwwnnnnnnw&quot;&#125;, &#123;32, &quot;wnwwnnnnnw&quot;&#125;, &#123;33, &quot;wwwwnnnnnn&quot;&#125;, &#123;34, &quot;wnwnnwnnnw&quot;&#125;, &#123;35, &quot;wwwnnwnnnn&quot;&#125;, &#123;36, &quot;wnwwnwnnnn&quot;&#125;, &#123;37, &quot;wnwnnnnwnw&quot;&#125;, &#123;38, &quot;wwwnnnnwnn&quot;&#125;, &#123;39, &quot;wnwwnnnwnn&quot;&#125;, &#123;40, &quot;nnnnwwnwwn&quot;&#125;, &#123;41, &quot;nwnnwnnnww&quot;&#125;, &#123;42, &quot;nnnwwnnnww&quot;&#125;, &#123;43, &quot;nwnwwnnnwn&quot;&#125;, &#123;44, &quot;nnnnwwnnww&quot;&#125;, &#123;45, &quot;nwnnwwnnwn&quot;&#125;, &#123;46, &quot;nnnwwwnnwn&quot;&#125;, &#123;47, &quot;nnnnwnnwww&quot;&#125;, &#123;48, &quot;nwnnwnnwwn&quot;&#125;, &#123;49, &quot;nnnwwnnwwn&quot;&#125;, &#123;50, &quot;wnnnwwnwnn&quot;&#125;, &#123;51, &quot;wwnnwnnnnw&quot;&#125;, &#123;52, &quot;wnnwwnnnnw&quot;&#125;, &#123;53, &quot;wwnwwnnnnn&quot;&#125;, &#123;54, &quot;wnnnwwnnnw&quot;&#125;, &#123;55, &quot;wwnnwwnnnn&quot;&#125;, &#123;56, &quot;wnnwwwnnnn&quot;&#125;, &#123;57, &quot;wnnnwnnwnw&quot;&#125;, &#123;58, &quot;wwnnwnnwnn&quot;&#125;, &#123;59, &quot;wnnwwnnwnn&quot;&#125;, &#123;60, &quot;nnwnwwnwnn&quot;&#125;, &#123;61, &quot;nwwnwnnnnw&quot;&#125;, &#123;62, &quot;nnwwwnnnnw&quot;&#125;, &#123;63, &quot;nwwwwnnnnn&quot;&#125;, &#123;64, &quot;nnwnwwnnnw&quot;&#125;, &#123;65, &quot;nwwnwwnnnn&quot;&#125;, &#123;66, &quot;nnwwwwnnnn&quot;&#125;, &#123;67, &quot;nnwnwnnwnw&quot;&#125;, &#123;68, &quot;nwwnwnnwnn&quot;&#125;, &#123;69, &quot;nnwwwnnwnn&quot;&#125;, &#123;70, &quot;nnnnnwwwwn&quot;&#125;, &#123;71, &quot;nwnnnnwnww&quot;&#125;, &#123;72, &quot;nnnwnnwnww&quot;&#125;, &#123;73, &quot;nwnwnnwnwn&quot;&#125;, &#123;74, &quot;nnnnnwwnww&quot;&#125;, &#123;75, &quot;nwnnnwwnwn&quot;&#125;, &#123;76, &quot;nnnwnwwnwn&quot;&#125;, &#123;77, &quot;nnnnnnwwww&quot;&#125;, &#123;78, &quot;nwnnnnwwwn&quot;&#125;, &#123;79, &quot;nnnwnnwwwn&quot;&#125;, &#123;80, &quot;wnnnnwwwnn&quot;&#125;, &#123;81, &quot;wwnnnnwnnw&quot;&#125;, &#123;82, &quot;wnnwnnwnnw&quot;&#125;, &#123;83, &quot;wwnwnnwnnn&quot;&#125;, &#123;84, &quot;wnnnnwwnnw&quot;&#125;, &#123;85, &quot;wwnnnwwnnn&quot;&#125;, &#123;86, &quot;wnnwnwwnnn&quot;&#125;, &#123;87, &quot;wnnnnnwwnw&quot;&#125;, &#123;88, &quot;wwnnnnwwnn&quot;&#125;, &#123;89, &quot;wnnwnnwwnn&quot;&#125;, &#123;90, &quot;nnwnnwwwnn&quot;&#125;, &#123;91, &quot;nwwnnnwnnw&quot;&#125;, &#123;92, &quot;nnwwnnwnnw&quot;&#125;, &#123;93, &quot;nwwwnnwnnn&quot;&#125;, &#123;94, &quot;nnwnnwwnnw&quot;&#125;, &#123;95, &quot;nwwnnwwnnn&quot;&#125;, &#123;96, &quot;nnwwnwwnnn&quot;&#125;, &#123;97, &quot;nnwnnnwwnw&quot;&#125;, &#123;98, &quot;nwwnnnwwnn&quot;&#125;, &#123;99, &quot;nnwwnnwwnn&quot;&#125;, &#125;; IntString&amp;inf = infs[ch]; int i; for (i = 0; i &lt; 10; i++) &#123; if (inf.psz[i] == &#x27;w&#x27;) *pb += 2; if (i % 2 == 0) *pb += 1; pb++; &#125; return pb; &#125;&#125;;class Barcode93 :public BarcodeBase &#123; //[n/a][n/a][n/a][n/a][n/a][n/a][n/a][b-s]public: Barcode93() &#123; &#125; ~Barcode93() &#123; &#125; BOOL Encode93(const char* pszCode) &#123; Clear(); const int iNum = strlen(pszCode); BYTE*pFst = ia_Buf; BYTE*pb = pFst; pb = P_GetBarSpace93(pb, 47); if (pb == 0) return 0; BOOL b; int i, iFirst, iSecond; for (i = 0; i &lt; iNum; i++) &#123; b = P_AscIItoCode93Sequence((int)pszCode[i], iFirst, iSecond); if (b == 0) return 0; pb = P_GetBarSpace93(pb, iFirst); if (pb == 0) return 0; if (iSecond != -1) &#123; pb = P_GetBarSpace93(pb, iSecond); if (pb == 0) return 0; &#125; &#125; pb = P_GetCheckDigits(pb, pszCode); if (pb == 0) return 0; pb = P_GetBarSpace93(pb, 48); if (pb == 0) return 0; i_LenBuf = pb - pFst; return 1; &#125; void Draw93(HDC hDC, int iX, int iY0, int iY1, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) &#123; DrawBarcode(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW); &#125;private: BYTE*P_GetBarSpace93(BYTE*pb, int ch) &#123; if (ch &lt; 0) return 0; if (ch &gt; 48) return 0; IntString infs[] = &#123; &#123;0, &quot;bsssbsbss&quot;&#125;, &#123;1, &quot;bsbssbsss&quot;&#125;, &#123;2, &quot;bsbsssbss&quot;&#125;, &#123;3, &quot;bsbssssbs&quot;&#125;, &#123;4, &quot;bssbsbsss&quot;&#125;, &#123;5, &quot;bssbssbss&quot;&#125;, &#123;6, &quot;bssbsssbs&quot;&#125;, &#123;7, &quot;bsbsbssss&quot;&#125;, &#123;8, &quot;bsssbssbs&quot;&#125;, &#123;9, &quot;bssssbsbs&quot;&#125;, &#123;10, &quot;bbsbsbsss&quot;&#125;, &#123;11, &quot;bbsbssbss&quot;&#125;, &#123;12, &quot;bbsbsssbs&quot;&#125;, &#123;13, &quot;bbssbsbss&quot;&#125;, &#123;14, &quot;bbssbssbs&quot;&#125;, &#123;15, &quot;bbsssbsbs&quot;&#125;, &#123;16, &quot;bsbbsbsss&quot;&#125;, &#123;17, &quot;bsbbssbss&quot;&#125;, &#123;18, &quot;bsbbsssbs&quot;&#125;, &#123;19, &quot;bssbbsbss&quot;&#125;, &#123;20, &quot;bsssbbsbs&quot;&#125;, &#123;21, &quot;bsbsbbsss&quot;&#125;, &#123;22, &quot;bsbssbbss&quot;&#125;, &#123;23, &quot;bsbsssbbs&quot;&#125;, &#123;24, &quot;bssbsbbss&quot;&#125;, &#123;25, &quot;bsssbsbbs&quot;&#125;, &#123;26, &quot;bbsbbsbss&quot;&#125;, &#123;27, &quot;bbsbbssbs&quot;&#125;, &#123;28, &quot;bbsbsbbss&quot;&#125;, &#123;29, &quot;bbsbssbbs&quot;&#125;, &#123;30, &quot;bbssbsbbs&quot;&#125;, &#123;31, &quot;bbssbbsbs&quot;&#125;, &#123;32, &quot;bsbbsbbss&quot;&#125;, &#123;33, &quot;bsbbssbbs&quot;&#125;, &#123;34, &quot;bssbbsbbs&quot;&#125;, &#123;35, &quot;bssbbbsbs&quot;&#125;, &#123;36, &quot;bssbsbbbs&quot;&#125;, &#123;37, &quot;bbbsbsbss&quot;&#125;, &#123;38, &quot;bbbsbssbs&quot;&#125;, &#123;39, &quot;bbbssbsbs&quot;&#125;, &#123;40, &quot;bsbbsbbbs&quot;&#125;, &#123;41, &quot;bsbbbsbbs&quot;&#125;, &#123;42, &quot;bbsbsbbbs&quot;&#125;, &#123;43, &quot;bssbssbbs&quot;&#125;, &#123;44, &quot;bbbsbbsbs&quot;&#125;, &#123;45, &quot;bbbsbsbbs&quot;&#125;, &#123;46, &quot;bssbbssbs&quot;&#125;, &#123;47, &quot;bsbsbbbbs&quot;&#125;, &#123;48, &quot;bsbsbbbbsb&quot;&#125;, &#125;; IntString&amp;inf = infs[ch]; int i; for (i = 0; i &lt; 9; i++) &#123; if (inf.psz[i] == &#x27;b&#x27;) *pb += 1; pb++; &#125; if (ch == 48) &#123; *pb += 1; pb++; &#125; return pb; &#125;private: BYTE*P_GetCheckDigits(BYTE*pb, const char*&amp;pszCode) &#123; int i, iSum, iWeight, iFirst, iSecond; // &quot;C&quot; check digit character iWeight = 1; iSum = 0; const int iNum = strlen(pszCode); for (i = iNum - 1; i &gt; -1; i--) &#123; P_AscIItoCode93Sequence((int)pszCode[i], iFirst, iSecond); iSum += (iWeight*iFirst); iWeight++; if (iWeight &gt; 20) iWeight = 1; if (iSecond != -1) &#123; iSum += (iWeight*iSecond); iWeight++; if (iWeight &gt; 20) iWeight = 1; &#125; &#125; pb = P_GetBarSpace93(pb, iSum % 47); if (pb == 0) return 0; iWeight = 2; iSum = iSum % 47; for (i = iNum - 1; i &gt; -1; i--) &#123; P_AscIItoCode93Sequence((int)pszCode[i], iFirst, iSecond); iSum += (iWeight * iFirst); iWeight++; if (iWeight &gt; 15) iWeight = 1; if (iSecond != -1) &#123; iSum += (iWeight * iSecond); iWeight++; if (iWeight &gt; 15) iWeight = 1; &#125; &#125; pb = P_GetBarSpace93(pb, iSum % 47); if (pb == 0) return 0; return pb; &#125; BOOL P_AscIItoCode93Sequence(int iValue, int&amp;iFirst, int&amp;iSecond) &#123; if (iValue &lt; 0) return 0; if (iValue &gt; 127) return 0; struct I3 &#123; int iV, iFirst, iSecond; &#125;; I3 i3s[] = &#123; &#123;0, 44,\t30&#125;, &#123;1, 43,\t10&#125;, &#123;2, 43,\t11&#125;, &#123;3, 43,\t12&#125;, &#123;4, 43,\t13&#125;, &#123;5, 43,\t14&#125;, &#123;6, 43,\t15&#125;, &#123;7, 43,\t16&#125;, &#123;8, 43,\t17&#125;, &#123;9, 43,\t18&#125;, &#123;10,43, 19&#125;, &#123;11,43, 20&#125;, &#123;12,43, 21&#125;, &#123;13,43, 22&#125;, &#123;14,43, 23&#125;, &#123;15,43, 24&#125;, &#123;16,43, 25&#125;, &#123;17,43, 26&#125;, &#123;18,43, 27&#125;, &#123;19,43, 28&#125;, &#123;20,43, 29&#125;, &#123;21,43, 30&#125;, &#123;22,43, 31&#125;, &#123;23,43, 32&#125;, &#123;24,43, 33&#125;, &#123;25,43, 34&#125;, &#123;26,43, 35&#125;, &#123;27,44, 10&#125;, &#123;28,44, 11&#125;, &#123;29,44, 12&#125;, &#123;30,44, 13&#125;, &#123;31,44, 14&#125;, &#123;32,38, -1&#125;, &#123;33,45, 10&#125;, &#123;34,45, 11&#125;, &#123;35,45, 12&#125;, &#123;36,39, -1&#125;, &#123;37,42, -1&#125;, &#123;38,45, 15&#125;, &#123;39,45, 16&#125;, &#123;40,45, 17&#125;, &#123;41,45, 18&#125;, &#123;42,45, 19&#125;, &#123;43,41, -1&#125;, &#123;44,45, 21&#125;, &#123;45,36, -1&#125;, &#123;46,37, -1&#125;, &#123;47,40, -1&#125;, &#123;48,0, -1&#125;, &#123;49,1, -1&#125;, &#123;50,2, -1&#125;, &#123;51,3, -1&#125;, &#123;52,4, -1&#125;, &#123;53,5, -1&#125;, &#123;54,6, -1&#125;, &#123;55,7, -1&#125;, &#123;56,8, -1&#125;, &#123;57,9, -1&#125;, &#123;58,45, 35&#125;, &#123;59,44, 15&#125;, &#123;60,44, 16&#125;, &#123;61,44, 17&#125;, &#123;62,44, 18&#125;, &#123;63,44, 19&#125;, &#123;64,44, 31&#125;, &#123;65,10, -1&#125;, &#123;66,11, -1&#125;, &#123;67,12, -1&#125;, &#123;68,13, -1&#125;, &#123;69,14, -1&#125;, &#123;70,15, -1&#125;, &#123;71,16, -1&#125;, &#123;72,17, -1&#125;, &#123;73,18, -1&#125;, &#123;74,19, -1&#125;, &#123;75,20, -1&#125;, &#123;76,21, -1&#125;, &#123;77,22, -1&#125;, &#123;78,23, -1&#125;, &#123;79,24, -1&#125;, &#123;80,25, -1&#125;, &#123;81,26, -1&#125;, &#123;82,27, -1&#125;, &#123;83,28, -1&#125;, &#123;84,29, -1&#125;, &#123;85,30, -1&#125;, &#123;86,31, -1&#125;, &#123;87,32, -1&#125;, &#123;88,33, -1&#125;, &#123;89,34, -1&#125;, &#123;90,35, -1&#125;, &#123;91,44, 20&#125;, &#123;92,44, 21&#125;, &#123;93,44, 22&#125;, &#123;94,44, 23&#125;, &#123;95,44, 24&#125;, &#123;96,44, 32&#125;, &#123;97,46, 10&#125;, &#123;98,46, 11&#125;, &#123;99,46, 12&#125;, &#123;100,46,13&#125;, &#123;101,46,14&#125;, &#123;102,46,15&#125;, &#123;103,46,16&#125;, &#123;104,46,17&#125;, &#123;105,46,18&#125;, &#123;106,46,19&#125;, &#123;107,46,20&#125;, &#123;108,46,21&#125;, &#123;109,46,22&#125;, &#123;110,46,23&#125;, &#123;111,46,24&#125;, &#123;112,46,25&#125;, &#123;113,46,26&#125;, &#123;114,46,27&#125;, &#123;115,46,28&#125;, &#123;116,46,29&#125;, &#123;117,46,30&#125;, &#123;118,46,31&#125;, &#123;119,46,32&#125;, &#123;120,46,33&#125;, &#123;121,46,34&#125;, &#123;122,46,35&#125;, &#123;123,44,25&#125;, &#123;124,44,26&#125;, &#123;125,44,27&#125;, &#123;126,44,28&#125;, &#123;127,44,29&#125;, &#125;; I3&amp;i3 = i3s[iValue]; iFirst = i3.iFirst; iSecond = i3.iSecond; return 1; &#125;&#125;;class Barcode128 :public BarcodeBase &#123;public: Barcode128() &#123; &#125; ~Barcode128() &#123; &#125; BOOL Encode128A(const char* pszCode) &#123; return P_Encode128((char*)pszCode, SUB::SETA); &#125; BOOL Encode128B(const char* pszCode) &#123; return P_Encode128((char*)pszCode, SUB::SETB); &#125; BOOL Encode128C(const char* pszCode) &#123; return P_Encode128((char*)pszCode, SUB::SETC); &#125; void Draw128(HDC hDC, int iX, int iY0, int iY1, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) &#123; DrawBarcode(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW); &#125;private: struct SUB &#123; enum &#123; SETA = 0, SETB = 1, SETC = 2, &#125;; &#125;; BOOL P_Encode128(char*pszCode, const int iSetIn) &#123; Clear(); BYTE*pFst = ia_Buf; BYTE*pb = pFst; if (iSetIn == SUB::SETA) pb = P_GetBarSpace128(pb, 103); else if (iSetIn == SUB::SETB) pb = P_GetBarSpace128(pb, 104); else pb = P_GetBarSpace128(pb, 105); if (pb == 0) return 0; const int iCheckDigit = GetCheckDigit(iSetIn, pszCode); const int iNum = strlen(pszCode); int iChar, iCharNext; int iPosition = 0; int iSet = iSetIn; while (iPosition &lt; iNum) &#123; if (iSet == SUB::SETC) &#123; if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 101) &#123; pb = P_GetBarSpace128(pb, 101); iPosition++; iSet = SUB::SETA; &#125; else if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 100) &#123; pb = P_GetBarSpace128(pb, 100); iPosition++; iSet = SUB::SETB; &#125; else if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 102) &#123; pb = P_GetBarSpace128(pb, 100); iPosition++; &#125; else &#123; char chT = pszCode[iPosition + 2]; pszCode[iPosition + 2] = 0; iChar = atoi(&amp;pszCode[iPosition]); pszCode[iPosition + 2] = chT; pb = P_GetBarSpace128(pb, iChar); if (pb == 0) return 0; iPosition += 2; &#125; &#125; else &#123; int iTemp2 = pszCode[iPosition]; if (iTemp2 &lt; -1) iTemp2 = iTemp2 &amp; 255; iChar = ga2_Code128[iSet][iTemp2]; pb = P_GetBarSpace128(pb, iChar); if (pb == 0) return 0; iPosition++; if (iSet == SUB::SETA) &#123; if (iChar == 100) iSet = SUB::SETB; else if (iChar == 99) iSet = SUB::SETC; &#125; else if (iSet == SUB::SETB) &#123; if (iChar == 101) iSet = SUB::SETA; else if (iChar == 99) iSet = SUB::SETC; &#125; else if (iChar == 98) &#123; if (iSet == SUB::SETA) iCharNext = ga2_Code128[SUB::SETB][pszCode[iPosition]]; else iCharNext = ga2_Code128[SUB::SETA][pszCode[iPosition]]; pb = P_GetBarSpace128(pb, iChar); if (pb == 0) return 0; iPosition++; &#125; &#125; &#125; pb = P_GetBarSpace128(pb, iCheckDigit); if (pb == 0) return 0; pb = P_GetBarSpace128(pb, 106); i_LenBuf = pb - pFst; return 1; &#125; BYTE*P_GetBarSpace128(BYTE*pb, int iV) &#123; if (iV &lt; 0) return 0; if (iV &gt; 106) return 0; IntString infs[] = &#123; &#123;0, &quot;bbsbbssbbss&quot;&#125;, &#123;1, &quot;bbssbbsbbss&quot;&#125;, &#123;2, &quot;bbssbbssbbs&quot;&#125;, &#123;3, &quot;bssbssbbsss&quot;&#125;, &#123;4, &quot;bssbsssbbss&quot;&#125;, &#123;5, &quot;bsssbssbbss&quot;&#125;, &#123;6, &quot;bssbbssbsss&quot;&#125;, &#123;7, &quot;bssbbsssbss&quot;&#125;, &#123;8, &quot;bsssbbssbss&quot;&#125;, &#123;9, &quot;bbssbssbsss&quot;&#125;, &#123;10, &quot;bbssbsssbss&quot;&#125;, &#123;11, &quot;bbsssbssbss&quot;&#125;, &#123;12, &quot;bsbbssbbbss&quot;&#125;, &#123;13, &quot;bssbbsbbbss&quot;&#125;, &#123;14, &quot;bssbbssbbbs&quot;&#125;, &#123;15, &quot;bsbbbssbbss&quot;&#125;, &#123;16, &quot;bssbbbsbbss&quot;&#125;, &#123;17, &quot;bssbbbssbbs&quot;&#125;, &#123;18, &quot;bbssbbbssbs&quot;&#125;, &#123;19, &quot;bbssbsbbbss&quot;&#125;, &#123;20, &quot;bbssbssbbbs&quot;&#125;, &#123;21, &quot;bbsbbbssbss&quot;&#125;, &#123;22, &quot;bbssbbbsbss&quot;&#125;, &#123;23, &quot;bbbsbbsbbbs&quot;&#125;, &#123;24, &quot;bbbsbssbbss&quot;&#125;, &#123;25, &quot;bbbssbsbbss&quot;&#125;, &#123;26, &quot;bbbssbssbbs&quot;&#125;, &#123;27, &quot;bbbsbbssbss&quot;&#125;, &#123;28, &quot;bbbssbbsbss&quot;&#125;, &#123;29, &quot;bbbssbbssbs&quot;&#125;, &#123;30, &quot;bbsbbsbbsss&quot;&#125;, &#123;31, &quot;bbsbbsssbbs&quot;&#125;, &#123;32, &quot;bbsssbbsbbs&quot;&#125;, &#123;33, &quot;bsbsssbbsss&quot;&#125;, &#123;34, &quot;bsssbsbbsss&quot;&#125;, &#123;35, &quot;bsssbsssbbs&quot;&#125;, &#123;36, &quot;bsbbsssbsss&quot;&#125;, &#123;37, &quot;bsssbbsbsss&quot;&#125;, &#123;38, &quot;bsssbbsssbs&quot;&#125;, &#123;39, &quot;bbsbsssbsss&quot;&#125;, &#123;40, &quot;bbsssbsbsss&quot;&#125;, &#123;41, &quot;bbsssbsssbs&quot;&#125;, &#123;42, &quot;bsbbsbbbsss&quot;&#125;, &#123;43, &quot;bsbbsssbbbs&quot;&#125;, &#123;44, &quot;bsssbbsbbbs&quot;&#125;, &#123;45, &quot;bsbbbsbbsss&quot;&#125;, &#123;46, &quot;bsbbbsssbbs&quot;&#125;, &#123;47, &quot;bsssbbbsbbs&quot;&#125;, &#123;48, &quot;bbbsbbbsbbs&quot;&#125;, &#123;49, &quot;bbsbsssbbbs&quot;&#125;, &#123;50, &quot;bbsssbsbbbs&quot;&#125;, &#123;51, &quot;bbsbbbsbsss&quot;&#125;, &#123;52, &quot;bbsbbbsssbs&quot;&#125;, &#123;53, &quot;bbsbbbsbbbs&quot;&#125;, &#123;54, &quot;bbbsbsbbsss&quot;&#125;, &#123;55, &quot;bbbsbsssbbs&quot;&#125;, &#123;56, &quot;bbbsssbsbbs&quot;&#125;, &#123;57, &quot;bbbsbbsbsss&quot;&#125;, &#123;58, &quot;bbbsbbsssbs&quot;&#125;, &#123;59, &quot;bbbsssbbsbs&quot;&#125;, &#123;60, &quot;bbbsbbbbsbs&quot;&#125;, &#123;61, &quot;bbssbssssbs&quot;&#125;, &#123;62, &quot;bbbbsssbsbs&quot;&#125;, &#123;63, &quot;bsbssbbssss&quot;&#125;, &#123;64, &quot;bsbssssbbss&quot;&#125;, &#123;65, &quot;bssbsbbssss&quot;&#125;, &#123;66, &quot;bssbssssbbs&quot;&#125;, &#123;67, &quot;bssssbsbbss&quot;&#125;, &#123;68, &quot;bssssbssbbs&quot;&#125;, &#123;69, &quot;bsbbssbssss&quot;&#125;, &#123;70, &quot;bsbbssssbss&quot;&#125;, &#123;71, &quot;bssbbsbssss&quot;&#125;, &#123;72, &quot;bssbbssssbs&quot;&#125;, &#123;73, &quot;bssssbbsbss&quot;&#125;, &#123;74, &quot;bssssbbssbs&quot;&#125;, &#123;75, &quot;bbssssbssbs&quot;&#125;, &#123;76, &quot;bbssbsbssss&quot;&#125;, &#123;77, &quot;bbbbsbbbsbs&quot;&#125;, &#123;78, &quot;bbssssbsbss&quot;&#125;, &#123;79, &quot;bsssbbbbsbs&quot;&#125;, &#123;80, &quot;bsbssbbbbss&quot;&#125;, &#123;81, &quot;bssbsbbbbss&quot;&#125;, &#123;82, &quot;bssbssbbbbs&quot;&#125;, &#123;83, &quot;bsbbbbssbss&quot;&#125;, &#123;84, &quot;bssbbbbsbss&quot;&#125;, &#123;85, &quot;bssbbbbssbs&quot;&#125;, &#123;86, &quot;bbbbsbssbss&quot;&#125;, &#123;87, &quot;bbbbssbsbss&quot;&#125;, &#123;88, &quot;bbbbssbssbs&quot;&#125;, &#123;89, &quot;bbsbbsbbbbs&quot;&#125;, &#123;90, &quot;bbsbbbbsbbs&quot;&#125;, &#123;91, &quot;bbbbsbbsbbs&quot;&#125;, &#123;92, &quot;bsbsbbbbsss&quot;&#125;, &#123;93, &quot;bsbsssbbbbs&quot;&#125;, &#123;94, &quot;bsssbsbbbbs&quot;&#125;, &#123;95, &quot;bsbbbbsbsss&quot;&#125;, &#123;96, &quot;bsbbbbsssbs&quot;&#125;, &#123;97, &quot;bbbbsbsbsss&quot;&#125;, &#123;98, &quot;bbbbsbsssbs&quot;&#125;, &#123;99, &quot;bsbbbsbbbbs&quot;&#125;, &#123;100, &quot;bsbbbbsbbbs&quot;&#125;, &#123;101, &quot;bbbsbsbbbbs&quot;&#125;, &#123;102, &quot;bbbbsbsbbbs&quot;&#125;, // &#123;103,\t&quot;bbsbsbbbbss&quot;&#125;, &#123;103, &quot;bbsbssssbss&quot;&#125;, &#123;104, &quot;bbsbssbssss&quot;&#125;, &#123;105, &quot;bbsbssbbbss&quot;&#125;, &#123;106, &quot;bbsssbbbsbsbb&quot;&#125;, &#125;; int i; IntString&amp;inf = infs[iV]; for (i = 0; i &lt; 11; i++) &#123; if (inf.psz[i] == &#x27;b&#x27;) *pb += 1; pb++; &#125; if (iV == 106) &#123; *pb += 1; pb++; *pb += 1; pb++; &#125; return pb; &#125;private: int GetCheckDigit(const int iSet, char*pszCode) &#123; int iSum = 0, iCurSet = 0, iChar128, iCharNext, iWeight, iPosition; iCurSet = iSet; if (iSet == SUB::SETA) &#123; iSum = 103; &#125; else if (iSet == SUB::SETB) &#123; iSum = 104; &#125; else if (iSet == SUB::SETC) &#123; iSum = 105; &#125; iPosition = 0; iWeight = 1; const int iNum = strlen(pszCode); while (iPosition &lt; iNum) &#123; if (iCurSet == SUB::SETC) &#123; if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 101) &#123; iChar128 = 101; iSum += (iWeight*iChar128); iPosition++; iWeight++; iCurSet = SUB::SETA; &#125; else if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 100) &#123; iChar128 = 100; iSum += (iWeight*iChar128); iPosition++; iWeight++; iCurSet = SUB::SETB; &#125; else if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 102) &#123; iChar128 = 102; iSum += (iWeight*iChar128); iPosition++; iWeight++; &#125; else &#123; char chT = pszCode[iPosition + 2]; pszCode[iPosition + 2] = 0; iChar128 = atol(&amp;pszCode[iPosition]); pszCode[iPosition + 2] = chT; iSum += (iWeight*iChar128); iPosition += 2; iWeight++; &#125; &#125; else &#123; int iTemp2 = pszCode[iPosition]; if (iTemp2 &lt; -1) iTemp2 = iTemp2 &amp; 255; iChar128 = ga2_Code128[iCurSet][iTemp2]; iSum += (iWeight*iChar128); iPosition++; iWeight++; if (iCurSet == SUB::SETA) &#123; if (iChar128 == 100) iCurSet = SUB::SETB; else if (iChar128 == 99) iCurSet = SUB::SETC; &#125; else if (iCurSet == SUB::SETB) &#123; if (iChar128 == 101) iCurSet = SUB::SETA; else if (iChar128 == 99) iCurSet = SUB::SETC; &#125; else if (iChar128 == 98) &#123; if (iCurSet == SUB::SETA) iCharNext = ga2_Code128[SUB::SETB][pszCode[iPosition]]; else iCharNext = ga2_Code128[SUB::SETA][pszCode[iPosition]]; iSum += (iWeight*iCharNext); iPosition++; iWeight++; &#125; &#125; &#125; return iSum % 103; &#125;&#125;;//=============================================class BarcodeEan13 :public BarcodeBase &#123;public: BarcodeEan13() &#123; &#125; ~BarcodeEan13() &#123; &#125; BOOL EncodeEan13(const char*pszCodeIn) &#123; Clear(); //only allow 12 characters as input char szCode[14]; const int iLen = strlen(pszCodeIn); if (iLen &gt; 12) &#123; strncpy(szCode, pszCodeIn, 12); &#125; else &#123; strcpy(szCode, pszCodeIn); while (strlen(szCode) &lt; 12) strcat(szCode, &quot;0&quot;); &#125; BYTE*pFst = ia_Buf; BYTE*pb = pFst; //&quot;bsb&quot;-long *pb += 5; pb++; *pb += 4; pb++; *pb += 5; pb++; BYTE iaCountryCode[6]; BOOL b = P_GetCountryCode(szCode[0], iaCountryCode); if (b == 0) return 0; pb = P_GetLeftOddParity(pb, szCode[1]); int i; for (i = 2; i &lt; 7; i++) &#123; if (iaCountryCode[i - 2] == &#x27;O&#x27;) &#123; pb = P_GetLeftOddParity(pb, szCode[i]); &#125; else if (iaCountryCode[i - 2] == &#x27;E&#x27;) &#123; pb = P_GetLeftEvenParity(pb, szCode[i]); &#125; &#125; //&quot;sbsbs&quot;-long *pb += 4; pb++; *pb += 5; pb++; *pb += 4; pb++; *pb += 5; pb++; *pb += 4; pb++; for (i = 7; i &lt; 12; i++) &#123; pb = P_GetRightPattern(pb, szCode[i]); &#125; i = P_GetCheckSumDigit(szCode); pb = P_GetRightPattern(pb, (char)i); //&quot;bsb&quot;-long *pb += 5; pb++; *pb += 4; pb++; *pb += 5; pb++; i_LenBuf = pb - pFst; return 1; &#125; void DrawEan13(HDC hDC, int iX, int iY0, int iY10, int iY11, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) &#123; DrawBarcode(hDC, iX, iY0, iY10, iY11, clrBar, clrSpace, iPenW); &#125;private: BOOL P_GetCountryCode(char ch, BYTE*pbCountryCode) &#123; const int iV = ch - &#x27;0&#x27;; if (iV &lt; 0) return 0; if (iV &gt; 9) return 0; IntString infs[] = &#123; &#123;0, &quot;OOOOO&quot;&#125;, &#123;1, &quot;OEOEE&quot;&#125;, &#123;2, &quot;OEEOE&quot;&#125;, &#123;3, &quot;OEEEO&quot;&#125;, &#123;4, &quot;EOOEE&quot;&#125;, &#123;5, &quot;EEOOE&quot;&#125;, &#123;6, &quot;EEEOO&quot;&#125;, &#123;7, &quot;EOEOE&quot;&#125;, &#123;8, &quot;EOEEO&quot;&#125;, &#123;9, &quot;EEOEO&quot;&#125;, &#125;; memcpy(pbCountryCode, infs[iV].psz, 5); return 1; &#125; BYTE*P_GetLeftOddParity(BYTE*pb, char ch) &#123; const int iV = ch - &#x27;0&#x27;; if (iV &lt; 0) return 0; if (iV &gt; 9) return 0; IntString infs[] = &#123; &#123;0, &quot;sssbbsb&quot;&#125;, &#123;1, &quot;ssbbssb&quot;&#125;, &#123;2, &quot;ssbssbb&quot;&#125;, &#123;3, &quot;sbbbbsb&quot;&#125;, &#123;4, &quot;sbsssbb&quot;&#125;, &#123;5, &quot;sbbsssb&quot;&#125;, &#123;6, &quot;sbsbbbb&quot;&#125;, &#123;7, &quot;sbbbsbb&quot;&#125;, &#123;8, &quot;sbbsbbb&quot;&#125;, &#123;9, &quot;sssbsbb&quot;&#125;, &#125;; IntString&amp;inf = infs[iV]; int i; for (i = 0; i &lt; 7; i++) &#123; if (inf.psz[i] == &#x27;b&#x27;) *pb += 1; pb++; &#125; return pb; &#125; BYTE*P_GetLeftEvenParity(BYTE*pb, char ch) &#123; const int iV = ch - &#x27;0&#x27;; if (iV &lt; 0) return 0; if (iV &gt; 9) return 0; IntString infs[] = &#123; &#123;0, &quot;sbssbbb&quot;&#125;, &#123;1, &quot;sbbssbb&quot;&#125;, &#123;2, &quot;ssbbsbb&quot;&#125;, &#123;3, &quot;sbssssb&quot;&#125;, &#123;4, &quot;ssbbbsb&quot;&#125;, &#123;5, &quot;sbbbssb&quot;&#125;, &#123;6, &quot;ssssbsb&quot;&#125;, &#123;7, &quot;ssbsssb&quot;&#125;, &#123;8, &quot;sssbssb&quot;&#125;, &#123;9, &quot;ssbsbbb&quot;&#125;, &#125;; char*psz = infs[iV].psz; int i; for (i = 0; i &lt; 7; i++) &#123; if (psz[i] == &#x27;b&#x27;) *pb += 1; pb++; &#125; return pb; &#125; BYTE*P_GetRightPattern(BYTE*pb, char ch) &#123; const int iV = ch - &#x27;0&#x27;; if (iV &lt; 0) return 0; if (iV &gt; 9) return 0; IntString infs[] = &#123; &#123;0, &quot;bbbssbs&quot;&#125;, &#123;1, &quot;bbssbbs&quot;&#125;, &#123;2, &quot;bbsbbss&quot;&#125;, &#123;3, &quot;bssssbs&quot;&#125;, &#123;4, &quot;bsbbbss&quot;&#125;, &#123;5, &quot;bssbbbs&quot;&#125;, &#123;6, &quot;bsbssss&quot;&#125;, &#123;7, &quot;bsssbss&quot;&#125;, &#123;8, &quot;bssbsss&quot;&#125;, &#123;9, &quot;bbbsbss&quot;&#125;, &#125;; char*psz = infs[iV].psz; int i; for (i = 0; i &lt; 7; i++) &#123; if (psz[i] == &#x27;b&#x27;) *pb += 1; pb++; &#125; return pb; &#125; char P_GetCheckSumDigit(const char*pszCode) &#123; const int iLen = strlen(pszCode); int i, iSum = 0, iItem; for (i = iLen; i &gt;= 1; i--) &#123; iItem = i % 2 ? (pszCode[i - 1] - &#x27;0&#x27;) * 1 : (pszCode[i - 1] - &#x27;0&#x27;) * 3; iSum += iItem; &#125; iSum %= 10; return &#x27;0&#x27; + (10 - iSum) % 10; &#125;&#125;;#endif","tags":["C++","条形码"],"categories":["C++语言"]},{"title":"批处理运行外部程序","path":"/post/2372684836.html","content":"本文介绍了批处理中启动外部程序和批处理的几种不同方法，以及如何获取命令返回值，最后还介绍了批处理中命令顺序执行的几种方法的区别。 1. start、call 和直接运行1.1 start使用 start 命令时，当前批处理不会等待外部程序运行结束，而是继续向下执行。 使用 start 命令运行其他批处理和 windows 命令行程序时，还会创建一个新的命令行窗口，并将在新的窗口中运行新的程序，如： 123456789@echo offecho 1start ping baidu.comecho 2start notepad.exeecho 3start other.batecho 4pause 1.2 call使用 call 命令时，当前批处理会等待外部程序或批处理运行结束，然后才继续向下执行。并且始终在当前命令行窗口中运行其他批处理和命令行程序。 1.3 直接运行直接运行与使用 call 命令一样。但直接运行外部批处理时会破坏当前批处理的运行流程，会导致执行流程无法返回到当前批处理继续执行。 123456789@echo offecho 1ping baidu.comecho 2notepad.exeecho 3other.batecho 4pause 上述示例，执行other.bat后，无法返回到当前批处理，从而无法执行echo 4及后面语句。 2. 获取命令的返回值在 Windows 批处理中，%errorlevel%变量保存着上一个命令的执行结果（即main函数的返回值）。一般来说，0 表示执行成功，非 0 则表示执行失败，具体的非 0 值的含义则取决于具体的命令。 在批处理脚本中，可以根据%errorlevel%的值来进行后续的处理逻辑，例如： 1234567891011@echo offREM 执行一个命令start un-exist.exeREM 判断命令执行结果if %errorlevel% equ 0 ( echo success) else ( echo failed with: %errorlevel%)pause 运行结果如下： 123系统找不到文件 un-exist.exe。failed with: 9059请按任意键继续. . . %errorlevel%是上一个命令的执行结果，因此上面例子中的 9059 是 start 命令的结果，而不是 un-exist.exe 返回的结果。 3. 顺序执行Windows 批处理提供了&amp;、&amp;&amp;、||、|、&gt;、&gt;&gt;等顺序执行方式，它们区别如下（下面说的执行成功指的是命令返回值为 0）： &amp; 顺序执行多条命令，而不管前面命令是否执行成功。 &amp;&amp; 顺序执行多条命令，当前面命令执行出错，后面的命令将不会执行。 || 顺序执行多条命令，直到遇到执行成功的命令。 | 管道命令，将前一个命令的执行结果输出到后一个命令 如：help|more。 &gt; 文件写入命令，清除原文件中的内容后再写入。 &gt;&gt; 文件追加写入命令","tags":["批处理"],"categories":["Windows批处理"]},{"title":"前后端常用概念扫盲","path":"/post/1162897275.html","content":"本文主要介绍前后端及客户端开发中遇到的一些常用的技术概念，本文不会涉及太深奥的技术细节。 1. 浏览器内核在 Web 大行其道的时代，网民需要上网浏览网页就需要依赖浏览器这个软件，掌握了浏览器就掌握了流量的入口，于是各大软件公司开始研发自己品牌的浏览器，不同品牌的浏览器其实现原理当然是有区别的，这个实现原理就是浏览器的核心，我们称其浏览器内核。 现在市面上有这么多的浏览器，如 Chrome，QQ 浏览器，搜狗浏览器，这些浏览器厂商是不是都是自己研发浏览器内核了？不是的！ 因为有些公司或者团体将浏览器内核进行了开源，方便其他人基于该内核进行二次开发，常见的开源浏览器内核有 Chromium、WebKit、Gecko。 正因为有了这些开源内核的存在，我们可以不用自己开发内核也可以开发属于自己品牌的浏览器，比如 QQ 浏览器，搜狗浏览器，360 浏览器都是基于 IE 内核和 Chromium 内核二次封装而成，美其名曰双引擎（双内核）。 目前市面上流行的拥有自主内核的浏览器： 浏览器 内核 Chrome Chromium Safari WebKit Firefox Gecko IE IE 内核 2. JavaScript, ECMAScript, ES6, TypeScriptJavaScript是一个编程语言的名称，类似 Java，C++，PHP，是由 Netscape 公司开发的一种解释性编程语言，其运行的宿主环境大多是浏览器，但也可以是其他环境，如 Node。 因为 Netscape 公司希望JavaScript成为一种浏览器脚本语言的标准规范，于是在 1996 年将 JavaScript 提交给标准化组织 ECMA。次年，ECMA 就发布了标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种标准称为 ECMAScript。 所以说，ECMAScript是一个的浏览器脚本语言的标准规范。 不同的浏览器内核及不同的版本对ECMAScript规范的支持情况不同， 截至 2012 年，所有浏览器都完整的支持ECMAScript 5.1； 从ECMAScript 6开始，标准制定者决定不再用诸如”3.1, 5.0”这样的版本号来命名，而是每年 6 月发布一个 ECMAScript 的正式版，并且以当年的年份来命名， 如 2015 年 6 月 17 日 ECMA 国际组织发布了 ECMAScript 的第六版，该版本正式名称为ECMAScript 2015。 ES6只是ECMAScript 6版本的简称，我们一般用ECMAScript 6来统称ECMAScript 2015及其以后的版本。 TypeScript是由微软开发的一种开源的编程语言。它是 JavaScript 的一个严格超集，并添加了静态类型及其他特性。TypeScript目前已经支持ECMAScript 2015。 3. CSS, CSS3CSS即Cascading Style Sheets层叠样式表的简称，在 Web 开发中用来定义元素样式的一种标记型语言。CSS3是 CSS（层叠样式表）的升级版本，2001 年 5 月 23 日 W3C 完成了 CSS3 的工作草案。 4. V8, Node, Node.js, npm, YarnV8，我们通常叫做 V8 引擎，然而其并不是汽车发动机的 V8 引擎，而是由 Google 开发并开源的一个项目，可以解释和执行 JavaScript，因为其性能非常高，目前得到了广泛的应用，如 Node.js 就是基于该引擎而开发。 Node.js 和 Node 是一个东西，Node 是 Node.js 的简称。 npm（node package management）是 Node.js 的一个包管理工具，目前已经内置到了 Node.js 中，不需要再单独安装。 yarn也是一个包管理工具，由 Facebook、Google、Exponent 和 Tilde 联合推出，其目的是为了弥补 npm 的一些缺陷。 5. React, Vue, Angular这 3 个说白了都是 Javascript 库。 我们最初开发 Web 的时候用的是HTML+CSS+JavaScript，后来有人觉得用纯 js 撸太繁琐了，就有了后来的 jQuery 这样的 JavaScript 库，但随着业务的扩增，数据交互越来越复杂，使用 jQuery 也太繁琐了，于时又有了 React, Vue, Angular 这样的库。 总之，前端生态真繁荣。。。。 6. Ant Design, Element UI前面说到了 React, Vue, Angular，虽然又了这些库，数据交互方面变得简单了，但页面效果还是需要 CSS 和 JS 一行行代码来实现的，比如要实现一个下拉列表，动态按钮等。于时现在又出现了一些基于 React, Vue 和 Angular 这些库的 UI 组件库，这些 UI 库将常用的组件封装好了，在开发中直接引入使用，改改属性，设置下参数即可。 7. Scaffold(脚手架)通俗的讲就是将一些重复性的事情整合成一个工具，这个工具就可以叫脚手架。 8. MySQL, Redis, MongoDB, Oracle, PostgreSQL, NoSQL数据库目前分为关系型数据库和非关系型数据（即 NoSQL），不同类型的数据各有其特点。同样，同一类型但不同品牌的数据库也各有其特点和应用领域 。 不能单纯的评判哪种数据库的好坏，一个项目中可能同时用到多个不同种类的数据库。 1、关系数据库MySQL、MariaDB、PostgreSQL、Microsoft Access、Microsoft SQL Server、Oracle、Sybase 等等。 2、非关系型数据库（NoSQL）BigTable（Google）、Cassandra、MongoDB、CouchDB、Redis 等等。 9. Nginx, Apache都是 Web 服务器，不同的团队研发，各有其优缺点。 10. 反向代理反向代理单纯从名字上理解就是正向代理的反方向。 那什么是正向代理？代理内部网络访问外部网络的代理就是正向代理，比如你需要从公司局域网中的电脑 A 经过代理服务器 B 访问网站 C： 1A --&gt; B --&gt; C 如果你认为 A 是内部网络，C 是外部网络，那 B 就是正向代理； 如果你认为 A 是外部网络，C 是内部网络（当然我们一般不这么认为），那么 B 就是反向代理。 11. RESTful一切具有 REST 特性的服务都可以成为 RESTful 服务，那么 REST 特性是什么了？ REST 是Representational state transfer的缩写，维基百科上的解释为： 1Representational State Transfer (REST) is a software architecture style consisting of guidelines and best practices for creating scalable web services. REST is a coordinated set of constraints applied to the design of components in a distributed hypermedia system that can lead to a more performant and maintainable architecture. REST 是一种架构风格, 只有满足这些约束，才能称之为符合 REST 架构风格。REST 的约束大致包括： 客户端-服务器结构 无状态 可缓存 按需代码（可选） 统一接口 持续更新中….","tags":["Web"],"categories":["Web编程"]},{"title":"Typescript基础语法","path":"/post/2248228478.html","content":"如果你还不了解 TypeScript 是什么，或者其与 JavaScript 之前的关系，可以参考：- 前后端常用概念扫盲 TypeScript 是 JavaScript 的一个超集，支持 ES6 的语法规范，并在此基础上进行了增强，二者最大的不同在于：TypeScript 是强类型语言，而 JavaScript 是弱类型的语言。 本文将着重介绍二者的不同之处。 一、变量声明TypeScript 支持使用var、let、const进行变量声明，但建议不要使用var。TypeScript 声明变量时，可以强制指定变量类型或者由编译器自动从“值”推导出变量类型，但无论哪种情况，一旦确定了类型，后面不能再次被赋值为其他类型： 123456789let a = 1;a = 10;a = &quot;x&quot;; ❌let b : number = 12;let c : number = &quot;x&quot;; ❌let fibonacci: number[] = [1, 1, 2, 3, 5];let fibonacci: number[] = [1, &#x27;1&#x27;, 2, 3, 5];❌ 二、函数参数TypeScript 要求：调用函数时传入的参数必须与函数声明的参数一致（个数及类型），如： 123456function sum(x: number, y: number): number &#123; return x + y;&#125;sum(1, 2, 3); ❌sum(1);❌sum(1, &quot;x&quot;); ❌ TypeScript 要求：可选参数必须在参数列表的最后，如： 1234567function buildName(firstName?: string, lastName: string) &#123;❌ if (firstName) &#123; return firstName + &#x27; &#x27; + lastName; &#125; else &#123; return lastName; &#125;&#125; 三、枚举枚举是 TypeScript 特有的：第一个元素没有赋值，则默认为 0，后面的元素的值依此递增： 123456789enum Days &#123; Sun, // 0 Mon, // 1 Tue, // 2 Wed, Thu, Fri, Sat&#125;; 也支持： 123456789enum Days &#123; Sun = 1, // 1 Mon, // 2 Tue, // 3 Wed = 10, // 10 Thu, // 11 Fri, // 12 Sat // 13&#125;; 枚举元素可以是常量值或是可以通过编译期计算得出的值： 123456789enum FileAccess &#123; // 常量值 None, // 0 Read = 1 &lt;&lt; 1, Write = 1 &lt;&lt; 2, ReadWrite = Read | Write, // 计算得出的值 G = &quot;123&quot;.length&#125; 四、类相比ES6，TypeScript新增了继承、成员访问控制修饰符。越来越有 Java、C++的味道了。 4.1 继承、成员访问控制修饰符TypeScript 继承需要使用extends关键字，只支持单继承，这点不同于 C++。类继承后，子类可以重写父类的方法。 123456789101112131415161718192021222324252627282930313233343536class Person &#123; private id: string; // 私有的，只能被自身访问 protected name: string; // 受保护，可以被其自身以及其子类和父类访问 protected age: number; // 公开的 public getId() : string &#123; return this.id; &#125; public getName() : string &#123; return this.name; &#125; public getAge() : number &#123; return this.age; &#125; public print() : void &#123; console.log(&quot;name:&quot; + this.name + &quot;, age:&quot; + this.age); &#125;&#125;class Student extends Person &#123; private grade : number; public getGrade() : number &#123; return this.grade; &#125; public print() : void &#123; // 重写了父类的方法 super.print(); // 使用super直接调用父类方法 console.log(&quot;grade:&quot; + this.grade); &#125;&#125; 4.2 instanceofinstanceof 运算符用于判断对象是否是指定的类型，如果是返回true，否则返回false。 123class Person &#123;&#125;let obj = new Person();let isPerson: boolean = obj instanceof Person; 4.3 interface 接口TypeScript 新增 interface 接口的概念，这个接口的概念和 Java 中的 interface 类似，即：只有定义没有实现。 同时，接口也支持继承。 1234567891011121314interface IPerson &#123; name: string;&#125;interface IStudent extends IPerson &#123; // 接口的继承 grade: number;&#125;class Student implements IStudent &#123; // 实现接口的类 name: string; grade: number;&#125; 五、命名空间TypeScript 中的命名空间的概念和 C++中的命名空间的概念一样，而且关键字也都是namespace。 稍有不同的是，C++不需要将命名空间中的内容暴露出来，C++默认就是全部暴露的，而 TypeScript 需要手动添加 export 关键字将命名空间的中的内容暴露出来： 12345678910namespace XYZ &#123; export let name : string; export class Person &#123; &#125; export interface IPerson &#123; &#125;&#125;XYZ.name = &quot;jeff&quot;;","tags":["Web","TypeScript"],"categories":["Web编程"]},{"title":"ECMAScript6基础语法","path":"/post/51642520.html","content":"ECMAScript 标准的发展经历了一个漫长的过程，从 1997 年发布的ECMAScript 1.0，到 2011 年的ECMAScript 5.1，再到 2015 年的ECMAScript 2015，以及后面每年都会发布的一个新的 ECMAScript 版本，版本众多，而且每个版本都有新特性的加入。 我们通常用ECMAScript 6来统称ECMAScript 2015及其之后的的版本。 但ECMAScript 2015可谓是 ECMAScript 标准的分水岭，其从制定到发布前后经历了 15 年。目前绝大多数浏览器都已支持ECMAScript 2015特性，并部分的支持了后面版本的新特性，所以对于需要快速入门的初学者，只需要直接学习ECMAScript 2015标准即可，编写完全遵守ECMAScript 2015标准的代码不仅更加严谨，而且可以节省不少学习时间。 即便对于那些不支持ECMAScript 6的浏览器（如 IE11），我们也可以使用Babel之类的工具将其转换为ECMAScript 5标准的代码。 查看浏览器对 ES 特性的支持情况，可以访问：https://kangax.github.io/compat-table/es6/ 下文讲述的都是支持 ECMAScript 6 标准的 JavaScript 语法 零 JavaScript 是大小写敏感的 在每行只写一条语句时，结尾可以不加分号;，但建议每条语句都以分号结尾 一、七种基本数据类型基本数据类型有以下 7 种： undefined null Boolean String Number Object Symbol JavaScript 虽然是弱类型的语言，但不代表其没有数据类型，其弱类型指的是在声明变量的时候不需要（也不能）指明变量类型，编译器会根据“值”的类型自动将变量转换成合适的类型。 所以无论是值还是变量终究还是有类型的，对于开发者而言，不需要关注什么类型的值应该赋值给什么类型的变量。 我们可以使用typeof查看每个变量或值的类型： 1234567console.log(typeof 123); // numberconsole.log(typeof &quot;abc&quot;); // stringconsole.log(typeof true); // booleanconsole.log(typeof undefined); // undefinedconsole.log(typeof null); // objectconsole.log(typeof [1, 2, 3, 4]); // objectconsole.log(typeof function () &#123;&#125;); // function 值得注意的是undefined的类型是undefined，但null的类型是object，下面的章节会介绍undefined和null的区别。 二、变量声明方式声明变量的方式有 3 种： let 用来声明变量 var 也是用来声明变量的 const 用来声明常量，必须在声明的时候赋初始值，且以后不能再修改 var是ES6之前的，建议不要在代码中使用 var，这样可以避免很多不必要的问题，比如变量提升、暂时性死区等，本文也只讲述let和const，忘记var吧，一起走向新世界。 2.1 变量具有作用域的概念用 let 和 const 声明的变量或常量的作用域可以精确到“块级别” 12345&#123; let a = 1; console.log(a); // 1&#125;console.log(a); // ReferenceError: a is not defined 1234for (let i = 0; i &lt; 10; i++) &#123; console.log(i); // 依次输出0~9&#125;console.log(i); // ReferenceError: i is not defined 1234567let a = 123;if (true) &#123; let a = 789;&#125;console.log(a); // 123 12345678910// 无论是let还是const都是一样的，在同一个作用域内不能重复声明&#123; let a = 123; let a = 456; // SyntaxError: Identifier &#x27;a&#x27; has already been declared&#125;&#123; let a = 123; const a = 456; // SyntaxError: Identifier &#x27;a&#x27; has already been declared&#125; 2.2 块级作用域内的 let只要“块级作用域内”存在 let 命令，它所声明的变量就“绑定”到这个区域，不再受外部的影响 12345678let a = 123;if (true) &#123; a = 456; // ReferenceError: Cannot access &#x27;a&#x27; before initialization let a = 789;&#125;console.log(a); // 123 这个和其他语言不太一样，如果是 C&#x2F;C++这样的语言是不会报错的，只会在let a = 789;给出“局部变量覆盖了全局变量”的警告。 但在 ES6 中却会报错，我们可以这样理解为“强龙压不过地头蛇”：我用let a = 789;在蓝色区域内声明了变量a，那么在这个蓝色区域的一亩三分地内的都是我说了算，a = 456;敢在我还没声明前都赋值，那我还不给你报个错。 2.3 for 循环的变量作用域for 循环设置循环变量的部分是一个父作用域，而循环体内部是一个单独的子作用域 1234for (let i = 0; i &lt; 10; i++) &#123; let i = &quot;abc&quot;; console.log(i); // abc&#125; 虽然编译器没有报错，但尽量不要写这样代码，不利于后期维护。 三、Object 与 ClassObject（对象）是 ES5 就已经有的概念，Class（类）是 ES6 引入的概念。 3.1 关于 JavaScript 中类和对象的叫法学过任何一个面向对象编程语言的同学都知道，对象是类的实例，比如在 Java 中： 1A a = new A(); a为对象，A为类，也就是“对象 a 为类型 A 的实例”。 而大家可能也发现了很多 JavaScript 教程称Object、Number、String为对象，如果根据这个称呼来，下面的代码岂不是“对象 a 为对象 Number 的实例”，很显然在这种叫法很别扭，也不科学： 1let a = new Number(123); 为什么会出现这种蹩脚的叫法了？因为在 ES6 之前，JavaScript 中没有完全引入Class类的概念，其最多只能算是一个伪的面向对象语言，估计也是为了降低学习理解的难度，所以统称为对象吧。 既然在 ES6 中明确引入了 Class 概念，我们在学习的时候就要明确区分“类”和“对象”的概念了。 3.2 万物皆对象在 JavaScript 中万物皆对象。学过其他面向对象编程语言的同学知道，对象是类的实例，每个类都可以有构造函数、析构函数、属性和方法。 在 JavaScript 中，每个对象都有构造函数、属性、方法，但没有析构函数，我们可以通过下面的代码来验证“万物皆对象”： 1234console.log(&quot;John&quot;.constructor); // [Function: String]console.log((3.14).constructor); // [Function: Number]console.log(false.constructor); // [Function: Boolean]console.log(&#123; name: &quot;John&quot;, age: 34 &#125;.constructor); // [Function: Object] 3.2.1 隐式声明对象JavaScript 访问属性和方法的方式和其他面向对象语言类似： 1234567891011let msg1 = &quot;Hello World!&quot;; // msg1为对象，String类的实例let x = msg1.length; // 访问length属性console.log(x); // 12let msg2 = &quot;Hello world!&quot;; // // msg2为对象，String类的实例let y = msg2.toUpperCase(); // 访问toUpperCase方法console.log(y); // HELLO WORLD!let car = &#123; name: &quot;BMW&quot;, price: 123000 &#125;; // car也为对象，&#123;name: &quot;BMW&quot;, price: 123000&#125;类的实例console.log(car.name); // BMWconsole.log(car.price); // 123000 大家可以看到上面的代码中都没有使用new来声明对象，但这些对象确确实实存在了，不然我们也无法访问其“属性”和“方法”，我们可以姑且认为这是 JavaScript 的语法糖吧，或者叫“隐式声明对象”吧。 3.2.2 显式声明对象前面介绍的 8 种基本数据类型中除了null和undefined之外，都可以使用 new 来显示的声明对象： 12345678910111213let a1 = new Number(123);console.log(a1); // [Number: 123]console.log(1 + a1); // 124let a2 = new Function();console.log(a2); // [Function: anonymous]let a3 = new String(&quot;xyz&quot;);console.log(a3); // [String: &#x27;xyz&#x27;]let a4 = new null(); // TypeError: null is not a constructorlet a5 = new undefined(); // TypeError: null is not a constructor 3.3 使用 Class 定义类在 ES6 中可以使用 Class 关键字定义类，且每个类都有默认的 name 属性。 1234567891011121314151617181920212223242526272829303132333435363738class Rectangle &#123; // 构造函数 // constructor方法名称不能修改 // 通过new命令生成对象实例时，自动调用该方法。 // 一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加 constructor(h, w) &#123; this.height = h; this.width = w; &#125; // Getter get area() &#123; return this.calcArea(); &#125; // Settter set setWidth(w) &#123; this.width = w; &#125; // 方法 calcArea() &#123; return this.height * this.width; &#125; // 静态方法 static printInfo(w, h) &#123; console.log(&quot;width:&quot; + w + &quot;, height:&quot; + h); &#125;&#125;// 注意：这个name属性是通过类本身来访问的，而不是类的实例来访问的，是不是有点乱了。。。console.log(Rectangle.name); // Rectanglelet rect = new Rectangle(5, 6);console.log(rect.area); // 30//rect.printInfo(); // TypeError: rect.printInfo is not a functionRectangle.printInfo(5, 6); // width:5, height:6 Class 的成员都是公共的，外部都可以访问，目前没有从语法层面规定如何定义一个私有的成员 类表达式一个类表达式是定义一个类的另一种方式。类表达式可以是具名的或匿名的。 一个具名类表达式的名称是类内的一个局部属性，它可以通过类的 name 属性来获取。 1234567891011121314151617// 匿名类let Rectangle1 = class &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125;&#125;;console.log(Rectangle1.name); // Rectangle1// 具名类let RectangleX = class Rectangle2 &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125;&#125;;console.log(RectangleX.name); // Rectangle2 四、函数4.1 函数参数是默认声明的变量123function foo1(x) &#123; let x = 0; // SyntaxError: Identifier &#x27;x&#x27; has already been declared&#125; 4.2 函数参数可以有默认值1234function foo2(x, y = 1) &#123; console.log(x + y);&#125;foo2(1); // 2 与 C++不同，JavaSript 没有要求拥有默认值的参数必须放在参数列表的尾部，所以可以这样写： 123function foo2(x = 1, y) &#123; console.log(x + y);&#125; 但仔细想一想，这样写并没有什么实际意义。 另外值得注意的是，函数参数的默认值是每次函数调用时都会动态计算的： 123456789let x = 99;function foo(p = x + 1) &#123; console.log(p);&#125;foo(); // 100x = 100;foo(); // 101 4.3 箭头函数123456789function foo(x, y) &#123; return x + y;&#125;// 等同于(x, y) =&gt; &#123; return x + y;&#125;; 如果函数只有一个参数： 123456789101112131415function foo(x) &#123; return x * x;&#125;// 等同于(x) =&gt; &#123; return x * x;&#125;;// 括号可以省略，等同于(x) =&gt; &#123; return x * x;&#125;; 如果函数没有返回值大括号可以省略： 1234567function foo() &#123; console.log(&quot;hi&quot;);&#125;// 大括号可以省略，等同于() =&gt; console.log(&quot;hi&quot;); 4.4 函数的 name，length 属性name可以返回函数名；length可以返回没有指定默认值的参数个数； 五、数据结构5.1 Object我们可以向 Object 对象添加任何属性，所以 Object 也是一个容器或集合： 12345678910let obj = new Object(&quot;hello&quot;);console.log(obj); // [String: &#x27;hello&#x27;]obj.name = &quot;jeff&quot;;console.log(obj.name); // jeffobj.print = function () &#123; console.log(&quot;I&#x27;m object&quot;);&#125;;obj.print(); // I&#x27;m object 5.2 数组JavaScript 中使用 Array 类创建数组对象： 12345678910111213141516171819202122232425// 使用Array类创建数组let cars1 = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);// 使用Array类创建数组let cars2 = new Array();cars2[0] = &quot;Saab&quot;; // 支持[]方式访问和赋值，下标从0开始cars2[1] = &quot;Volvo&quot;;cars2[2] = &quot;BMW&quot;;// 简写方式let cars3 = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];console.log(cars3.length); // 3// 数组中的元素可以为不同的类型let a = [1, &quot;x&quot;, true];console.log(a[1]); // xconsole.log(a[5]); // undefined，访问数组中不存在的元素会返回undefined，不会报错a.testProp = &quot;xyz&quot;; // 可以向Array对象添加任意属性console.log(a.testProp); // xyza.print = function () &#123; console.log(&quot;I&#x27;m a&quot;);&#125;;a.print(); // I&#x27;m a 5.2.1 Array 类完整的属性 属性 描述 length 设置或获取数组元素的个数 prototype 允许你向数组对象添加属性或方法 5.2.2 Array 类完整的方法 方法 描述 concat() 连接两个或更多的数组，并返回结果 copyWithin() 从数组的指定位置拷贝元素到数组的另一个指定位置中 entries() 返回数组的可迭代对象 every() 检测数值元素的每个元素是否都符合条件 fill() 使用一个固定值来填充数组 filter() 检测数值元素，并返回符合条件所有元素的数组 find() 返回符合传入测试（函数）条件的数组元素 findIndex() 返回符合传入测试（函数）条件的数组元素索引 forEach() 数组每个元素都执行一次回调函数 from() 通过给定的对象中创建一个数组 includes() 判断一个数组是否包含一个指定的值 indexOf() 搜索数组中的元素，并返回它所在的位置 isArray() 判断对象是否为数组 join() 把数组的所有元素放入一个字符串 keys() 返回数组的可迭代对象，包含原始数组的键(key) lastIndexOf() 搜索数组中的元素，并返回它最后出现的位置 map() 通过指定函数处理数组的每个元素，并返回处理后的数组 pop() 删除数组的最后一个元素并返回删除的元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度 reduce() 将数组元素计算为一个值（从左到右） reduceRight() 将数组元素计算为一个值（从右到左） reverse() 反转数组的元素顺序 shift() 删除并返回数组的第一个元素 slice() 选取数组的一部分，并返回一个新数组 some() 检测数组元素中是否有元素符合指定条件 sort() 对数组的元素进行排序 splice() 从数组中添加或删除元素 toString() 把数组转换为字符串，并返回结果 unshift() 向数组的开头添加一个或更多元素，并返回新的长度 valueOf() 返回数组对象的原始值 5.2.3 数组的复制123456let a1 = [1, 2, 3];let a2 = a1;a2[1] = 4;console.log(a1[1]); // 4 从上面的例子中，我们发现改变数组a2[1]的值时，数组a1[1]的值也随着改变了，这说明 a1 和 a2 指向的是同一块内存区域，这个在 C&#x2F;C++中就是指针的概念，let a2 = a1; 做的是浅拷贝操作。 如果需要做深拷贝，也就是将数组 a1 的所有元素克隆一份给 a2，可以通过下面的两种方式： 123456let a1 = [1, 2, 3];let a2 = a1.concat();a2[1] = 4;console.log(a1[1]); // 2 123456let a1 = [1, 2, 3];let a2 = [...a1]; // 也可以写成 let [...a2] = a1;a2[1] = 4;console.log(a1[1]); // 2 5.3 MapMap 对象用来存储键值对(key-value)，并且能够记住键的原始插入顺序。任何对象都可以作为键或值。在 Map 中 Key 是唯一的。 1234567891011121314151617181920212223242526272829303132let myMap = new Map();let keyObj = &#123;&#125;;let keyFunc = function () &#123;&#125;;let keyString = &quot;a string&quot;;// 添加键myMap.set(keyString, &quot;和键&#x27;a string&#x27;关联的值&quot;);myMap.set(keyObj, &quot;和键keyObj关联的值&quot;);myMap.set(keyFunc, &quot;和键keyFunc关联的值&quot;);console.log(myMap.size); // 3// 读取值console.log(myMap.get(keyString)); // 和键&#x27;a string&#x27;关联的值console.log(myMap.get(&quot;a string&quot;)); // 和键&#x27;a string&#x27;关联的值console.log(myMap.get(keyObj)); // 和键keyObj关联的值console.log(myMap.get(keyFunc)); // 和键keyFunc关联的值console.log(myMap.get(&#123;&#125;)); // undefined, 因为keyObj !== &#123;&#125;console.log(myMap.get(function () &#123;&#125;)); // undefined, 因为keyFunc !== function () &#123;&#125;console.log(myMap.size); // 3，返回有多少个键值对// 和Array一样，可以添加任意属性和方法myMap.test = &quot;a&quot;;console.log(myMap.test);myMap.print = function () &#123; console.log(&quot;I&#x27;m map&quot;);&#125;;myMap.print(); // I&#x27;m map 5.3.1 Map 与 Array 相互转换Array &#x3D;&gt; Map 123456let map = new Map([ [1, &quot;one&quot;], [2, &quot;two&quot;],]);console.log(map); // Map &#123; 1 =&gt; &#x27;one&#x27;, 2 =&gt; &#x27;two&#x27; &#125; Map &#x3D;&gt; Array 123456let map = new Map();map.set(1, &quot;one&quot;);map.set(2, &quot;tow&quot;);let arr2 = Array.from(map);console.log(arr2); // [ [ 1, &#x27;one&#x27; ], [ 2, &#x27;two&#x27; ] ] 5.3.2 Map 的复制Map 在直接赋值的时候会遇到和 Array 同样的“浅拷贝”的问题，如： 123456789let map1 = new Map();map1.set(1, &quot;one&quot;);map1.set(2, &quot;tow&quot;);let map2 = map1;map2.set(1, &quot;three&quot;);console.log(map1.get(1)); // three，修改map2会导致map1的值也被修改了 可以通过下面的方式完成 Map 的深拷贝： 12345678910let map1 = new Map();map1.set(1, &quot;one&quot;);map1.set(2, &quot;tow&quot;);let map2 = new Map(map1);map2.set(1, &quot;three&quot;);console.log(map1.get(1)); // oneconsole.log(map2.get(1)); // three 5.4 SetMap 是键值对的集合，而 Set 则只是键（key）的集合。 Set 中的每个元素都是唯一的。 任何对象都可以作为 Set 的元素。 1234567891011121314let keys = [1, 1, 2, 3, &quot;str&quot;];let s = new Set(keys);// 自动去重了console.log(s); // Set &#123; 1, 2, 3, &#x27;str&#x27; &#125;// 新增使用Adds.add(9);s.add(function () &#123;&#125;);console.log(s); // Set &#123; 1, 2, 3, &#x27;str&#x27;, 9, [Function] &#125;// 删除使用deletes.delete(1);console.log(s); // Set &#123; 2, 3, &#x27;str&#x27;, 9, [Function] &#125; 5.5 迭代器前面介绍 Object、Array、Map、Set 这些容器的时候，都避开了一个话题：遍历。本节主要介绍如何遍历 JavaScript 中的容器或集合。 迭代器（Iterator）就是一个接口，为各种不同的数据结构提供统一的遍历访问机制。任何数据结构只要实现 Iterator 接口，就可以完成遍历操作。 在学习如何自定义迭代器之前，我们先学习一下如何遍历 JavaScript 常用的数据集合： 5.5.1 遍历字符串12345678910111213let str = &quot;hello&quot;;for (let v of str) &#123; console.log(v);&#125;/*hello*/ 5.5.2 遍历数组123456789let arr = [1, &quot;str&quot;, 2];for (let v of arr) &#123; console.log(v);&#125;/*1str2*/ 5.5.3 遍历 Map123456789101112131415let map = new Map([ [1, &quot;one&quot;], [2, &quot;two&quot;], [3, function () &#123;&#125;],]);for (let [k, v] of map) &#123; console.log(k + &quot;:&quot; + v);&#125;/*1:one2:two3:function () &#123; &#125;*/ 六、解构赋值解构(Destructuring)赋值分为“数组的解构赋值”和“对象的解构赋值”。 6.1 数组的解构赋值123456789101112131415161718192021222324252627282930313233343536373839404142434445let [a, b, c] = [1, 2, 3]; // 根据位置依次取值// a = 1// b = 2// c = 3let [foo, [[bar], baz]] = [1, [[2], 3]];// foo = 1// bar = 2// baz = 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];// third = &quot;baz&quot;let [head, ...tail] = [1, 2, 3, 4];// head = 1// tail = [2,3,4]let [x, y, ...z] = [&quot;a&quot;];// x = &quot;a&quot;// y = undefined// z = []let [foo] = []; // foo = undefinedlet [bar, foo] = [1]; // foo = undefinedlet [bar, foo = true] = [1]; // 可以赋默认值// bar = 1// foo = truelet [x, y] = [1, 2, 3];// x = 1// y = 2let [a, [b], d] = [1, [2, 3], 4];// a = 1// b = 2// d = 4 6.2 对象的解构赋值1234567891011let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;; // 和顺序没关系，根据属性名来取值// foo = &quot;aaa&quot;// bar = &quot;bbb&quot;let &#123; foo &#125; = &#123; bar: &quot;baz&quot; &#125;;// foo = undefined// 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量// 如：console对象有log方法，我们可以这样使用：const &#123; log &#125; = console;log(&quot;hello&quot;); // hello 七、promise、async、awaitpromise、async、await 这三个关键字都和异步编程有关。 7.1 PromisePromise 翻译成中文就是“承诺”的意思，声明一个 Promise 就是立下了一个承诺，无论怎么样，都会给被承诺人一个结果，而且这个结果是板上钉钉的，不会再变。 Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。 声明 Promise 对象时需要传入一个函数对象作为参数，这个函数对象的 2 个参数也是函数对象（resolve, reject），resolve和reject不需要开发者定义，Javascript 引擎会自动生成这 2 个函数。 当 Promise 对象生成后会立即变成pending状态，调用resolve函数会将 Promise 对象标记为fulfilled状态，而调用reject函数则会将当前 Promise 对象标记rejected状态。 resolve和rejected函数，我们只能调用它们中的一个，不能即调用resolve又调用rejected。如果我们先调用了resolve，此时 Promise 状态会标记为fulfilled，然后又调用了rejected函数，此时 Promise 状态并不会再改变，仍然使fulfilled状态，因为承诺的结果是板上钉钉的，不会再变。建议将resolve和reject作为最后一行代码调用，简单起见，可以在这 2 个函数前面加上return, 即return resolve();或return reject(); 123456789101112// Promise的参数为一个函数对象，函数有2个参数resolve, rejectlet promise = new Promise((resolve, reject) =&gt; &#123; // 做一些耗时的操作，比如网络请求 // 这里我们使用一个延时器来模拟耗时的网络请求 setTimeout(() =&gt; &#123; // 延时1000ms之后成功 resolve(&quot;ok&quot;); &#125;, 1000); // 成功则调用 resolve(); // 失败则调用 reject();&#125;); 那么，我想在这个异步操作完成之后，再根据结果（是成功了，还是失败了）来继续做下一件事情，那我们该怎么做了？Promise 对象提供了then方法，该方法接受 2 个函数对象作为参数：第一个回调函数是 Promise 对象的状态变为resolved时调用;第二个回调函数是 Promise 对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。每个回调函数都可以接受一个参数，这个参数就是上一步调用 resolve 或 reject 时传入的。 12345678910111213// 上面的耗时操作完成之后，我们可能还需要根据结果来继续做一些事情// 此时就可以使用then，then函数有2个参数，分别为2个函数对象。// 上一步操作中，如果调用resolve(data)，则then函数第一个函数对象参数会被调用；// 如果调用reject(data)，则then函数第二个函数对象参数会被调用promise.then( (data) =&gt; &#123; console.log(&quot;resolve1: &quot; + data); return &quot;hello&quot;; &#125;, (data) =&gt; &#123; console.log(&quot;reject1: &quot; + data); &#125;); 在这个例子中，我在第一个参数中直接通过 return 返回了”hello”字符串，那这个返回值的意义在哪里了？还有其他人可以使用到这个返回值吗？是的，还可以继续使用。因为then的返回值是一个 Promise 对象，虽然我只是使用的return &quot;hello&quot;;，并没有new Promise，但 JavaScript 引擎会自动包装成一个 Promise 对象，等同于： 1234567891011promise.then( (data) =&gt; &#123; console.log(&quot;resolve1: &quot; + data); return new Promise((resolve, reject) =&gt; &#123; return resolve(&quot;hello&quot;); &#125;); &#125;, (data) =&gt; &#123; console.log(&quot;reject1: &quot; + data); &#125;); 到这儿了，我们知道了then的返回的是一个Promise对象。既然then返回的是Promise对象，那么Promise就可以继续then呀，然后一直then下去….这样我们就可以将一系列异步的操作串联起来了： 12345678910111213let p = new Promise((resolve, reject) =&gt; &#123; // ... // resolve(); 或 reject();&#125;) .then(() =&gt; &#123; // ... &#125;) .then(() =&gt; &#123; // ... &#125;) .then(() =&gt; &#123; // ... &#125;); 但多个异步操作串联执行，还有一点需要注意，我们看下面的例子： 1234567891011121314151617let promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // 延时1000ms resolve(&quot;ok1&quot;); &#125;, 1000);&#125;) .then((data) =&gt; &#123; console.log(&quot;resolve1: &quot; + data); setTimeout(() =&gt; &#123; // 延时1000ms return &quot;ok2&quot;; &#125;, 1000); &#125;) .then((data) =&gt; &#123; console.log(&quot;resolve2: &quot; + data); &#125;); 我们期望的输出是： 12resolve1: ok1;resolve2: ok2; 但实际的输出却是： 12resolve1: ok1;resolve2: undefined; 问题出在第二个 setTimeout 模拟的耗时操作，我们以为程序会等第二个 setTimeout 执行完了再执行第二个 then，但事实上 setTimeout 也是一个异步操作，虽然其延时了一秒执行其回调函数，但 setTimeout 这条语句却马上执行完成了，导致第一个 then 没有任何返回，针对这种情况，我们需要将代码改成下面的： 12345678910111213141516171819let promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // 延时1000ms resolve(&quot;ok1&quot;); &#125;, 1000);&#125;) .then((data) =&gt; &#123; console.log(&quot;resolve1: &quot; + data); return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // 延时1000ms resolve(&quot;ok2&quot;); &#125;, 1000); &#125;); &#125;) .then((data) =&gt; &#123; console.log(&quot;resolve2: &quot; + data); &#125;); 7.2 Promise 异常捕获Promise 对象还提供了catch方法，用来捕获异常。在介绍catch前，我们先看看下面的代码： 1234567891011121314let promise = new Promise((resolve, reject) =&gt; &#123; throw new Error(&quot;an error&quot;); resolve(&quot;ok&quot;);&#125;).then( (data) =&gt; &#123; console.log(&quot;resolve: &quot; + data); &#125;, (data) =&gt; &#123; console.log(&quot;reject: &quot; + data); &#125;);// 输出：// reject: Error: an error 我们在 Promise 中人为抛出了一个异常，但是程序却还是没有中止，而是运行到了 reject 过程中去了。 这是因为 Promise 默认会捕获其操作过程中的异常，如果有异常发生，其状态就会自动变成rejected，还记得前面说过 Promise 状态一旦确定就不会再改变了吧，所以即便后面的resolve(&quot;ok&quot;);执行了，也不会改变 promise 状态（事实上 throw 语句后的代码并没有机会执行）。 那么，假如我们没有写 reject 回调函数会怎么样了？看看下面的代码： 123456let promise = new Promise((resolve, reject) =&gt; &#123; throw new Error(&quot;an error&quot;); resolve(&quot;ok&quot;);&#125;).then((data) =&gt; &#123; console.log(&quot;resolve: &quot; + data);&#125;); 上面的代码中由于没有指定异常处理函数，所以程序抛出了异常信息，中止执行了。 另外，Promise 的异常是会一直向下传递的，直到最后有人处理，如果始终没人处理，程序就会抛出异常信息，然后中止： 123456789101112131415161718let promise = new Promise((resolve, reject) =&gt; &#123; throw new Error(&quot;an error&quot;); resolve(&quot;ok&quot;);&#125;) .then((data) =&gt; &#123; console.log(&quot;resolve1: &quot; + data); &#125;) .then( (data) =&gt; &#123; console.log(&quot;resolve2: &quot; + data); &#125;, (data) =&gt; &#123; console.log(&quot;reject2: &quot; + data); &#125; );// 输出：// reject: Error: an error 上面的代码中，第一个 then 没有处理异常，异常向下传递给第二个 then, 第二个 then 处理了该异常，程序继续运行。 现在理解Promise.catch()方法就容易多了。catch()方法其实就是.then(null, rejectiion)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 我们一般总是建议，Promise 对象后面要跟 catch()方法，这样可以处理 Promise 内部发生的错误。catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then()方法。 7.3 async, awaitasync 是ES7才有的与异步操作有关的关键字，需要和Promise配合使用，async函数返回一个 Promise对象，可以使用then方法添加回调函数： 12345678910111213async function helloAsync() &#123; return &quot;helloAsync&quot;;&#125;console.log(helloAsync());helloAsync().then((v) =&gt; &#123; console.log(v);&#125;);// 输出：// Promise &#123; &#x27;helloAsync&#x27; &#125;// helloAsync await关键字只能用在被async标记的函数体内，async函数执行时，如果遇到await就会先暂停执行，等到触发的异步操作完成后，恢复async函数的执行并返回解析值。 123456789101112131415161718function testAwait() &#123; return new Promise((resolve) =&gt; &#123; setTimeout(function () &#123; console.log(&quot;testAwait&quot;); resolve(); &#125;, 1000); &#125;);&#125;async function helloAsync() &#123; await testAwait(); console.log(&quot;helloAsync&quot;);&#125;helloAsync();// 输出：// testAwait// helloAsync","tags":["Web","JavaScript"],"categories":["Web编程"]},{"title":"QSS基本使用方法","path":"/post/749849405.html","content":"Qt QSS 选择器和 CSS2、CSS3 的选择器类似，建议先学习或者复习 CSS 选择器的语法。 QSS 虽然源自 CSS ，但也有稍许不同，而且支持的语法也没 CSS 那么多。 一、选择器类型1.1 类选择器12345678910111213/*匹配QPushButton的实例及其子类*/QPushButton &#123; color: blue;&#125;/*匹配QPushButton的实例，但不包含子类*/.QPushButton &#123; color: blue;&#125; 1.2 选择器分组123456/*同时匹配QPushButton、QLineEdit的实例*/QPushButton,QLineEdit &#123; color: blue;&#125; 1.3 ID 选择器1234567891011121314151617181920/*匹配所有objectName为btnOK的实例*/*#btnOK &#123; font-weight: bold;&#125;/*和*#btnOK一样，匹配所有objectName为btnOK的实例*/#btnOK &#123; font-weight: bold;&#125;/*匹配所有objectName为btnOK的QPushButton实例*/QPushButton#btnOK &#123; font-weight: bold;&#125; 1.4 属性选择器123456789101112131415161718192021222324252627/*匹配包含flat属性的所有实例*/*[flat] &#123; color: red;&#125;/*匹配包含flat属性的所有QPushButton的实例*/QPushButton[flat] &#123; color: red;&#125;/*匹配flat属性为true的所有QPushButton的实例*/QPushButton[flat=&quot;true&quot;] &#123; color: red;&#125;/*匹配falt属性为true且default属性为false的所有QPushButton的实例*/QPushButton[flat=&quot;true&quot;][default=&quot;false&quot;] &#123; color: red;&#125; 1.5 后代选择器123456/*匹配属于QDialog后代（孩子，孙子等）的QPushButton所有实例*/QDialog QPushButton &#123; color: red;&#125; 1.6 子元素选择器123456/*匹配属于QDialog直接子类的QPushButton所有实例*/QDialog &gt; QPushButton &#123; color: red;&#125; 1.7 伪状态1234567891011121314151617181920/*匹配hover状态的所有QPushButton的实例*/QPushButton:hover &#123; color: white;&#125;/*匹配同时为hover和enabled状态的所有QPushButton的实例*/QPushButton:hover:enabled &#123; color: white;&#125;/*匹配不为hover状态的所有QPushButton的实例*/qradiobutton: !hover &#123; color: red;&#125; 1.8 子控件选择器123QRadioButton::indicator::unchecked:disabled &#123; image: url(:/qss/radiobutton_unchecked_disable.png);&#125; 二、选择器优先级一句话归纳为：优先使用更具体的选择器。 具体实例如下： 123456789/*QPushButton#okButton选择器比QPushButton更具体，所以选择QPushButton#okButton*/QPushButton#okButton &#123; color: gray;&#125;QPushButton &#123; color: red;&#125; 12345678910/*如下2个规则应用于QPushButton实例时：因为QPushButton继承QAbstractButton，所以QPushButton比QAbstractButton更具体，选择QPushButton*/QPushButton &#123; color: red;&#125;QAbstractButton &#123; color: gray;&#125; 123456789/*指定伪状态比不指定伪状态的选择器更具体，所以当鼠标悬停时选择QPushButton:hover，否则选择QPushButton*/QPushButton:hover &#123; color: white;&#125;QPushButton &#123; color: red;&#125; 1234567891011/*如下2个规则应用于处于Enabled状态的QPushButton实例时：鼠标悬停时，QPushButton:hover更能具体描述当前状态，所以选择QPushButton:hover其他时候选择QPushButton:enabled*/QPushButton:enabled &#123; color: red;&#125;QPushButton:hover &#123; color: white;&#125; 1234567891011121314/*如下2个规则应用于处于Enabled状态的QPushButton实例时：鼠标悬停时，QPushButton:enabled:hover更能具体描述当前状态，所以选择QPushButton:enabled:hover其他时候选择QPushButton:enabled*/QPushButton:enabled &#123; color: red;&#125;QPushButton:hover &#123; color: white;&#125;QPushButton:enabled:hover &#123; color: white;&#125; 三、类型、属性、伪状态、子控件关于 QSS 支持哪些类型、每种类型支持哪些属性、伪状态和子控件，在 Qt 的官方的英文文档中有详细的介绍：《Qt Style Sheets Reference》 也可以在Qt Assistant中搜索”Qt Style Sheets Reference”打开帮助文档。 3.1 伪状态列表为了方便查阅，这里列举出QSS目前支持的所有伪状态。 伪状态都是以一个冒号:开头，如:active。 伪状态 描述 :active 此状态在Widget驻留在活动窗口时设置 :adjoins-item 此状态在QTreeView的::branch与一个item相邻时设置 :alternate 当QAbstractItemView::alternatingRowColors()设置为真时，在绘制QAbstractItemView的行时，为每个交替行设置此状态 :bottom 此item位于底部时设置。例如，QTabBar有位于底部的选项卡 :checked 此item被选中时设置。例如，QAbstractButton的checked状态 :closable 此item可以被关闭时设置。例如，QDockWidget的QDockWidget::DockWidgetClosable特性开启时 :closed 此item处于关闭状态时设置。例如，QTreeView中未展开的item :default 此item的默认状态时设置。例如，一个default的QPushButton或QMenu中的一个默认动作 :disabled 此item被禁用时设置 :editable 如QComboBox是可编辑时设置 :edit-focus 此item具有编辑焦点(参考QStyle::State_HasEditFocus)时设置。此状态仅对Qt扩展应用程序可用 :enabled 此item已启用时设置 :exclusive 此item是属于某个独占组时设置。例如，独占QActionGroup中的菜单项 :first 此item是列表中的第一项时设置。例如，QTabBar中的第一个选项卡 :flat 此item是扁平时设置。例如，一个扁平的QPushButton :floatable 此item可以浮动时设置。例如，QDockWidget的QDockWidget::DockWidgetFloatable的特性开启时 :focus 此item具有输入焦点时设置 :has-children 此item具有子对象时设置。例如，QTreeView中具有子项的项 :has-sibling 此item具有兄弟对象时设置。例如，QTreeView中与之相邻的项 :horizontal 此item处于水平方向时设置 :hover 鼠标悬浮在此item上时设置 :indeterminate 此item处于不确定状态时设置。例如，QCheckBox或QRadioButton被部分选中 :last 此item是列表中的最后一项时设置。例如，QTabBar中的最后一个选项卡 :left 此item位于左侧时设置。例如，QTabBar有位于左侧的选项卡 :maximized 此item处于最大化状态时设置。例如，一个最大化的QMdiSubWindow :middle 此item是列表中的中间一项时设置。例如，一个不在QTabBar中的开头或结尾的选项卡 :minimized 此item处于最小化状态时设置。例如，一个最小化的QMdiSubWindow :movable 此item可以被移动时设置。例如， QDockWidget的QDockWidget::DockWidgetMovable特性开启时 :no-frame 此item没有边框时设置。例如，没有边框的QSpinBox或QLineEdit :non-exclusive 此item是属于非独占组时设置。例如，非独占QActionGroup中的菜单项 :off 对可以切换的items，这适用于处于off状态的item :on 对可以切换的items，这适用于处于on状态的widget :only-one 此item是列表中的唯一项时设置。例如，一个在QTabBar中单独的选项卡 :open 此item处于打开状态时设置。例如，QTreeView中的展开项，或带有菜单的QComboBox或QPushButton :next-selected 此item是列表中的下一个被选中的项时设置。例如，在QTabBar中当前选项卡的下一个要选中的选项卡 :pressed 鼠标正在按压在此item上时设置 :previous-selected 此item是列表中的上一个被选中的项时设置。例如，在QTabBar中当前选项卡的上一个要选中的选项卡 :read-only 此item处于只读或不可编辑状态时设置。例如，一个只读QLineEdit或不可编辑的QComboBox :right 此item位于右侧时设置。例如，QTabBar有位于右侧的选项卡 :selected 此item处于选中状态时设置。例如，一个在QTabBar中被选中的选项卡或一个在菜单中被选中的菜单项 :top 此item位于顶部时设置。例如，QTabBar有位于顶部的选项卡 :unchecked 此item处于未被选中状态时设置 :vertical 此item处于垂直方向时设置 :window Widget是一个窗口(例如，一个顶层Widget)时设置 3.2 子控件列表 伪状态都是以两个冒号::开头，如::item。 子控件 描述 ::add-line 在QScrollBar中跳转下一行的按钮 ::add-page 在QScrollBar中滑动条和add-line之间的区域 ::branch 在QTreeView中的分支指示器 ::chunk 在QProgressBar中的进度块 ::close-button 在QDockWidget或QTabBar选项卡的关闭按钮 ::corner 在QAbstractScrollArea中两个滚动条之间的角落 ::down-arrow 在QComboBox、QHeaderView(排序指示器)、QScrollBar或QSpinBox的向下箭头 ::down-button 在QScrollBar或QSpinBox中的向下按钮 ::drop-down 在QComboBox中的下拉框 ::float-button 在QDockWidget中的浮动按钮 ::groove 在QSlider中的滑动槽 ::indicator 在QAbstractItemVIew、QCheckBox、QRadioButton、可选中的菜单项或可选中的QGroupBox中的指示器 ::handle 在QScrollBar、QSplitter和QSlider中的操作条(滑动条) ::icon 在QAbstractItemVIew或QMenu中的图标 ::item 在QAbstractItemVIew、QMenuBar、QMenu或QStatuBar中的一项 ::left-arrow 在QScrollBar中的向左箭头 ::left-corner 在QTabWidget中的左上角 ::menu-arrow 带有菜单的QToolButton中的箭头 ::menu-button 在QToolButton中的菜单按钮 ::menu-indicator 在QPushButton中的菜单指示器 ::right-arrow 在QMenu或QScrollBar中的向右箭头 ::pane 在QTabWidget中的边或框 ::right-corner 在QTabWidget中的右上角 ::scroller 在QMenu或QTabBar中的滚动条 ::section 在QHeaderView中的区块 ::separator 在QMenu或QMainWIndow中分隔条 ::sub-line 在QScrollBar中跳转上一行的按钮 ::sub-page 在QScrollBar中滑动条和sub-line之间的区域 ::tab 在QTabBar或QToolBox中选项卡 ::tab-bar 在QTabWidget中的选项卡栏 ::tear 在QTabBar中的tear指示器 ::tearoff 在QMenu中的tear-off指示器 ::text 在QAbstractItemView中的文本 ::title 在QGroupBox或QDockWidget中的标题栏 ::up-arrow 在QComboBox、QHeaderView(排序指示器)、QScrollBar或QSpinBox的向上箭头 ::up-button 在QScrollBar或QSpinBox中的向上按钮 使用示例： 123QPushButton#btnTest::menu-indicator &#123; image: url(indicator.png);&#125; 同时使用伪状态和子控件时，先指定子控件，后指定伪状态： 123QComboBox::down-arrow:disabled&#123; image:none;&#125; 四、盒子模型在使用 QSS 设置样式时，有一个关键的概念需要知晓，那就是“盒子模型”（即Box Model）。 每个 Widget 都被视为具有 4 个同心矩形的框： MARGIN矩形、BORDER矩形、PADDING矩形和 CONTENT矩形，上图标注了每个矩形的区域。 默认情况下MARGIN矩形、BORDER矩形、PADDING矩形的宽度都为 0，这样在默认情况下，4 个矩形就重合为 1 个CONTENT矩形了。 同样，默认情况下 background-image 指定的背景，只在 border 内的区域绘制，但我们也可以使用 background-clip 或 background-origin 属性来更改这种默认行为。 如何实现背景图像随 Widget 大小自动缩放？ background-image 指定的背景图像无法随 Widget 大小自动缩放，要提供可以随 Widget 大小缩放的背景图像可以使用border-image和image属性，二者区别如下： border-image 属性指定的图像从 border 及其内的区域开始绘制，会导致 border 属性被覆盖。 image 属性指定的图像从绘制到 content 区域内，image 指定的 url 为 SVG 图像，则支持自动缩放，非 SVG 图像仅支持自动缩小。 五、动态属性通过 setProperty 方法设置 QWidget 对象属性，在 QSS 中可以根据不同的属性值应用不同的样式。 例如，设置 pushButtonMax 按钮的 isMax 属性，表示当前窗口是否最大化： 1pushButtonMax-&gt;setProperty(&quot;isMax&quot;, this-&gt;isMaximized() ? true : false); 在 QSS 中根据不同的属性值应用不同的样式： 12345678910111213141516171819#pushButtonMax[isMax=&quot;false&quot;] &#123; width: 40px; height: 40px; background: gray;&#125;#pushButtonMax[isMax=&quot;false&quot;]:hover &#123; background: blue;&#125;#pushButtonMax[isMax=&quot;true&quot;] &#123; width: 40px; height: 40px; background: transparent;&#125;#pushButtonMax[isMax=&quot;true&quot;]:hover &#123; background: red;&#125; 六、Q_PROPERTY在 Qt 中可以使用Q_PROPERTY宏为 QObject 对象（含子对象）声明属性，任何被Q_PROPERTY声明的属性都能在 QSS 中使用qproperty-&lt;property name&gt;语法进行设置。 以 QToolButton 为例，QToolButton 继承至 QAbstractButton，QAbstractButton 拥有以下被 Q_PROPERTY 声明的属性： 12345678910111213141516171819class Q_WIDGETS_EXPORT QAbstractButton : public QWidget&#123; Q_OBJECT Q_PROPERTY(QString text READ text WRITE setText) Q_PROPERTY(QIcon icon READ icon WRITE setIcon) Q_PROPERTY(QSize iconSize READ iconSize WRITE setIconSize)#ifndef QT_NO_SHORTCUT Q_PROPERTY(QKeySequence shortcut READ shortcut WRITE setShortcut)#endif Q_PROPERTY(bool checkable READ isCheckable WRITE setCheckable) Q_PROPERTY(bool checked READ isChecked WRITE setChecked DESIGNABLE isCheckable NOTIFY toggled USER true) Q_PROPERTY(bool autoRepeat READ autoRepeat WRITE setAutoRepeat) Q_PROPERTY(bool autoExclusive READ autoExclusive WRITE setAutoExclusive) Q_PROPERTY(int autoRepeatDelay READ autoRepeatDelay WRITE setAutoRepeatDelay) Q_PROPERTY(int autoRepeatInterval READ autoRepeatInterval WRITE setAutoRepeatInterval) Q_PROPERTY(bool down READ isDown WRITE setDown DESIGNABLE false) ....&#125; 在 QSS 中可以直接对属性赋值，如： 12345QToolButton &#123; qproperty-text: &quot;文本&quot;; qproperty-icon: url(://img/icon.png); qproperty-iconsize: 100px 100px;&#125; 七、Padding和Margin的使用Margin 指控件和其他控件的间距，而 Padding 指控件内的内容与边框的间距。 二者的语法与CSS中的一样： 12margin: 25px 50px 75px 100px;padding: 25px 50px 75px 100px; 从左到右依次为：上、右、下、左。 支持简写形式： 12margin: 25px 50px;padding: 25px 50px; 表示：上下间距为25px，左右间距为50px。 八、几种图片设置方法大家在使用 QSS 进行图片设置时，也许被 image, border-image, background-image 这几个属性的差异困扰过，下面就来讲解一下这个几个属性的异同点。 8.1 background-imagebackground-image 按图片实际尺寸显示图片，超过控件显示区域的部分会被裁剪掉。 虽能显示 SVG，但无法对 SVG 进行无损缩放； 关于 background-image 的几个附属属性的作用，可以一句话概括为： 从 background-origin 区域的 background-position 位置开始绘制图像，并以 background-repeat 方式进行重复；最后将图像 background-clip 区域以外的范围裁剪掉（即不显示）。 8.2 imageimage 会将图片按图片原长宽比进行缩放，并保证填充满控件 content 区域。 image 支持 SVG 矢量图显示和无损缩放。 image 可以使用 image-position 来指定图片开始显示的位置（参考上面background-position）。 8.3 border-image按控件 border 区域的长宽比来缩放图片，保证填充满控件 border 区域，支持 SVG 矢量图显示和无损缩放; 8.4 绘制顺序如果在一个控件中同时指定background-image，border-image，image 这三个属性，会按照如下的顺序进行绘制： 123先绘制 background-image然后 border-image最后 image 8.5 示例1234567891011QPushButton#pushButton4 &#123; border: 20px solid rgba(0,0,255,0.5); padding: 20px; margin: 20px; background-image: url(:/QssUsage/Image/头像.png); /*下图中的圆形头像*/ background-origin: margin; background-position:top left; background-repeat:repeat-x; background-clip: margin;&#125; 九、QSS编辑器QSS 样式的编写是一个熟能生巧的过程，不仅不需要熟记常用的样式属性，还需要勤加练习，多多验证，灵活运用。 为了方便学习和验证 QSS 样式，我开发了一个 QSS 编辑器，通过该编辑器可以实时预览 QSS 的生效样式，而且编辑器还内置了两套完整的QSS主题，方便初学者学习 QSS 属性。 项目地址： https://github.com/winsoft666/qss-editor","tags":["Qt","QSS"],"categories":["Qt"]},{"title":"C++ 默认构造函数","path":"/post/818165951.html","content":"本文围绕 3 个问题来理解 C++的默认构造函数： 什么是默认构造函数？ 默认构造函数什么时候被调用？ 编译器在什么情况下会生成默认构造函数？ 一. 什么是默认构造函数我们一般会认为默认构造函数就是编译器自动生成的那个构造函数，其实这种理解不全面。 准确的说，默认构造函数就是在调用时不需要显示地传入实参的构造函数。 根据这个原则，下面两种构造函数都是默认构造函数： 1234567class Sample &#123;public: // 默认构造函数。 Sample() &#123; // do something &#125;&#125;; 1234567class Sample &#123;public: // 默认构造函数。虽然有形参，但有默认值，调用的时候可以不显示的传入实参。 Sample(int m = 10) &#123; // do something &#125;&#125;; 二. 默认构造函数何时被调用如果定义一个对象时没有使用初始化式，编译器就会使用默认构造函数。如： 1Sample s; 三. 什么情况下会生成默认构造函数有一句很经典的话可以用来回答这个问题：惟有默认构造函数被编译器需要的时候，编译器才会生成默认构造函数。 那我们只需知道什么时候“被编译器需要”，就可以知道什么情况下会生成默认构造函数了。 下面几种情况下，编译需要生成默认构造函数： 当该类的类对象数据成员有默认构造函数时。 当该类的基类有默认构造函数时。 当该类的基类为虚基类时。 当该类有虚函数时。 四. 注意事项4.1 避免无参和缺省同时存在无参数的默认构造函数和带缺省参数的默认构造函数同时存在时，编译器会产生二义性，从而生成编译错误。 12345678910111213141516171819202122class Sample &#123;public: // 默认构造函数 Sample() &#123; // do something printf(&quot;Sample()&quot;); &#125; // 默认构造函数 Sample(int m = 10) &#123; // do something printf(&quot;Sample(int m = 10)&quot;); &#125;&#125;;int main()&#123; Sample s; // error C2668: “Sample::Sample”: 对重载函数的调用不明确 return 0;&#125; 4.2 不应在对象名后面加上括号使用无参构造函数创建对象时，不应在对象名后面加上括号，否则会产生编译警告 1warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?) 因为编译器误认为Sample s()语句是要声明一个返回值为Sample对象的函数s，而它又没找到函数s的定义，所以产生了警告。 12345678910111213141516class Sample &#123;public: // 默认构造函数 Sample() &#123; // do something printf(&quot;Sample()&quot;); &#125;&#125;;int main()&#123; Sample s(); // warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?) return 0;&#125;","tags":["C++","构造函数"],"categories":["C++语言"]},{"title":"C++内存池实现","path":"/post/581068365.html","content":"本文从实际需求出发，介绍了内存池的实现原理，并且提供了具体的实现方案。 一、为什么需要使用内存池在 C&#x2F;C++ 中我们通常使用 malloc、free或new、delete 来动态分配内存。一方面，因为这些函数涉及到了系统调用，所以频繁的调用必然会导致程序性能的损耗； 另一方面，频繁的分配和释放小块内存会导致大量的内存碎片的产生，当碎片积累到一定的量之后，将无法分配到连续的内存空间，系统不得不进行碎片整理来满足分配到连续的空间，这样不仅会导致系统性能损耗，而且会导致程序对内存的利用率低下。 当然，如果我们的程序不需要频繁的分配和释放小块内存，那就没有使用内存池的必要，直接使用malloc,free或new,delete函数即可。 二、内存池的实现方案内存池的实现原理大致如下： 提前申请一块大内存交由内存池管理，并分成小片供给程序使用。程序使用完之后将内存归还到内存池中（并没有真正的从系统释放），当程序再次从内存池中请求内存时，内存池将池子中的可用内存片返回给程序使用。 我们在设计内存池的实现方案时，需要考虑以下问题： 内存池是否可以自动增长？ 如果内存池的最大空间是固定的（也就是非自动增长），那么当内存池中的内存被请求完之后，程序就无法再次从内存池请求到内存。所以需要根据程序对内存的实际使用情况来确定是否需要自动增长。 内存池的总内存占用是否只增不减？ 如果内存池是自动增长的，就涉及到了“内存池的总内存占用是否是只增不减”这个问题了。试想，程序从一个自动增长的内存池中请求了 1000 个大小为 100KB 的内存片，并在使用完之后全部归还给了内存池，而且假设程序之后的逻辑最多只需要 10 个 100KB 的内存片，该内存池中的 900 个 100KB 的内存片就一直处于闲置状态，程序内存占用就一直降下来。对内存占用大小有要求的程序需要考虑到这一点。 内存池中内存片的大小是否固定？ 如果每次从内存池中的请求的内存片的大小如果不固定，那么内存池中的每个可用内存片的大小就不一致，程序再次请求内存片的时候，内存池就需要在“匹配最佳大小的内存片”和“匹配操作时间”上作出衡量。“最佳大小的内存片”虽然可以减少内存的浪费，但可能会导致“匹配时间”变长。 内存池是否是线程安全的？ 是否允许在多个线程中同时从同一个内存池中请求和归还内存片？这个线程安全可以由内存池来实现，也可以由使用者来保证。 内存片分配出去之前和归还到内存池之后，其中的内容是否需要被清除？ 程序可能出现将内存片归还给内存池之后，仍然使用内存片的地址指针进行内存读写操作，这样就会导致不可预期的结果。将内容清零只能尽量的（也不一定能）将问题抛出来，但并不能解决任何问题，而且将内容清零会消耗一定的 CPU 时间。所以，最终最好还是需要由内存池的使用者来保证这种安全性。 是否兼容 std::allocator ？ STL 标准库中的大多类都支持用户提供一个自定义的内存分配器，默认使用的是 std::allocator，如 std::string ： 1typedef basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt; string; 如果我们的内存池兼容 std::allocator，那么我们就可以使用我们自己的内存池来替换默认的 std::allocator 分配器，如： 1typedef basic_string&lt;char, char_traits&lt;char&gt;, MemoryPoll&lt;char&gt; &gt; mystring; 关于如何兼容std::allocator，可以参考： http://www.cplusplus.com/reference/memory/allocator/ 三、内存池的具体实现现在实现一个内存池，类名为MemoryPool，它具有如下特性： 内存池的总大小自动增长。 内存池中内存片的大小固定。 支持线程安全。 在内存片被归还之后，清除其中的内容。 兼容 std::allocator 。 因为内存池的内存片的大小是固定的，不涉及到需要匹配最合适大小的内存片，由于会频繁的进行插入、移除的操作，但查找比较少，故选用链表数据结构来管理内存池中的内存片。 MemoryPool 中有 2 个链表，它们都是双向链表（设计成双向链表主要是为了在移除指定元素时，能够快速定位该元素的前后元素，从而在该元素被移除后，将其前后元素连接起来，保证链表的完整性）： data_element_ 记录以及分配出去的内存片。 free_element_ 记录未被分配出去的内存片。 3.1 MemoryPool实现代码下面是完整的内存池实现的代码，代码中使用了 std::mutex 等 C++11 才支持的特性，所以需要编译器最低支持 C++11。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302/* MemoryPool.hpp */#ifndef MEMORY_POOL_H_#define MEMORY_POOL_H_#include &lt;climits&gt;#include &lt;cstddef&gt;#include &lt;mutex&gt;template &lt;typename T, size_t BlockSize = 4096, bool ZeroOnDeallocate = true&gt;class MemoryPool &#123;public: /* Member types */ typedef T value_type; typedef T* pointer; typedef T&amp; reference; typedef const T* const_pointer; typedef const T&amp; const_reference; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef std::false_type propagate_on_container_copy_assignment; typedef std::true_type propagate_on_container_move_assignment; typedef std::true_type propagate_on_container_swap; template &lt;typename U&gt; struct rebind &#123; typedef MemoryPool&lt;U&gt; other; &#125;; /* Member functions */ MemoryPool() noexcept; MemoryPool(const MemoryPool&amp; memoryPool) noexcept; MemoryPool(MemoryPool&amp;&amp; memoryPool) noexcept; template &lt;class U&gt; MemoryPool(const MemoryPool&lt;U&gt;&amp; memoryPool) noexcept; ~MemoryPool() noexcept; MemoryPool&amp; operator=(const MemoryPool&amp; memoryPool) = delete; MemoryPool&amp; operator=(MemoryPool&amp;&amp; memoryPool) noexcept; pointer address(reference x) const noexcept; const_pointer address(const_reference x) const noexcept; // Can only allocate one object at a time. n and hint are ignored pointer allocate(size_type n = 1, const_pointer hint = 0); void deallocate(pointer p, size_type n = 1); size_type max_size() const noexcept; template &lt;class U, class... Args&gt; void construct(U* p, Args&amp;&amp;... args); template &lt;class U&gt; void destroy(U* p); template &lt;class... Args&gt; pointer newElement(Args&amp;&amp;... args); void deleteElement(pointer p);private: struct Element_ &#123; Element_* pre; Element_* next; &#125;; typedef char* data_pointer; typedef Element_ element_type; typedef Element_* element_pointer; element_pointer data_element_; element_pointer free_element_; std::recursive_mutex m_; size_type padPointer(data_pointer p, size_type align) const noexcept; void allocateBlock(); static_assert(BlockSize &gt;= 2 * sizeof(element_type), &quot;BlockSize too small.&quot;);&#125;;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::size_type MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::padPointer(data_pointer p, size_type align) const noexcept &#123; uintptr_t result = reinterpret_cast&lt;uintptr_t&gt;(p); return ((align - result) % align);&#125;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::MemoryPool() noexcept &#123; data_element_ = nullptr; free_element_ = nullptr;&#125;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::MemoryPool(const MemoryPool&amp; memoryPool) noexcept : MemoryPool() &#123;&#125;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::MemoryPool(MemoryPool&amp;&amp; memoryPool) noexcept &#123; std::lock_guard&lt;std::recursive_mutex&gt; lock(m_); data_element_ = memoryPool.data_element_; memoryPool.data_element_ = nullptr; free_element_ = memoryPool.free_element_; memoryPool.free_element_ = nullptr;&#125;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;template&lt;class U&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::MemoryPool(const MemoryPool&lt;U&gt;&amp; memoryPool) noexcept : MemoryPool() &#123;&#125;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;&amp; MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::operator=(MemoryPool&amp;&amp; memoryPool) noexcept &#123; std::lock_guard&lt;std::recursive_mutex&gt; lock(m_); if (this != &amp;memoryPool) &#123; std::swap(data_element_, memoryPool.data_element_); std::swap(free_element_, memoryPool.free_element_); &#125; return *this;&#125;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::~MemoryPool() noexcept &#123; std::lock_guard&lt;std::recursive_mutex&gt; lock(m_); element_pointer curr = data_element_; while (curr != nullptr) &#123; element_pointer prev = curr-&gt;next; operator delete(reinterpret_cast&lt;void*&gt;(curr)); curr = prev; &#125; curr = free_element_; while (curr != nullptr) &#123; element_pointer prev = curr-&gt;next; operator delete(reinterpret_cast&lt;void*&gt;(curr)); curr = prev; &#125;&#125;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::pointer MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::address(reference x) const noexcept &#123; return &amp;x;&#125;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::const_pointer MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::address(const_reference x) const noexcept &#123; return &amp;x;&#125;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;void MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::allocateBlock() &#123; // Allocate space for the new block and store a pointer to the previous one data_pointer new_block = reinterpret_cast&lt;data_pointer&gt; (operator new(BlockSize)); element_pointer new_ele_pointer = reinterpret_cast&lt;element_pointer&gt;(new_block); new_ele_pointer-&gt;pre = nullptr; new_ele_pointer-&gt;next = nullptr; if (data_element_) &#123; data_element_-&gt;pre = new_ele_pointer; &#125; new_ele_pointer-&gt;next = data_element_; data_element_ = new_ele_pointer;&#125;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::pointer MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::allocate(size_type n, const_pointer hint) &#123; std::lock_guard&lt;std::recursive_mutex&gt; lock(m_); if (free_element_ != nullptr) &#123; data_pointer body = reinterpret_cast&lt;data_pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(free_element_) + sizeof(element_type)); size_type bodyPadding = padPointer(body, alignof(element_type)); pointer result = reinterpret_cast&lt;pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(body + bodyPadding)); element_pointer tmp = free_element_; free_element_ = free_element_-&gt;next; if (free_element_) free_element_-&gt;pre = nullptr; tmp-&gt;next = data_element_; if (data_element_) data_element_-&gt;pre = tmp; tmp-&gt;pre = nullptr; data_element_ = tmp; return result; &#125; else &#123; allocateBlock(); data_pointer body = reinterpret_cast&lt;data_pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(data_element_) + sizeof(element_type)); size_type bodyPadding = padPointer(body, alignof(element_type)); pointer result = reinterpret_cast&lt;pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(body + bodyPadding)); return result; &#125;&#125;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline void MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::deallocate(pointer p, size_type n) &#123; std::lock_guard&lt;std::recursive_mutex&gt; lock(m_); if (p != nullptr) &#123; element_pointer ele_p = reinterpret_cast&lt;element_pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(p) - sizeof(element_type)); if (ZeroOnDeallocate) &#123; memset(reinterpret_cast&lt;data_pointer&gt;(p), 0, BlockSize - sizeof(element_type)); &#125; if (ele_p-&gt;pre) &#123; ele_p-&gt;pre-&gt;next = ele_p-&gt;next; &#125; if (ele_p-&gt;next) &#123; ele_p-&gt;next-&gt;pre = ele_p-&gt;pre; &#125; if (ele_p-&gt;pre == nullptr) &#123; data_element_ = ele_p-&gt;next; &#125; ele_p-&gt;pre = nullptr; if (free_element_) &#123; ele_p-&gt;next = free_element_; free_element_-&gt;pre = ele_p; &#125; else &#123; ele_p-&gt;next = nullptr; &#125; free_element_ = ele_p; &#125;&#125;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::size_type MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::max_size() const noexcept &#123; size_type maxBlocks = -1 / BlockSize; return (BlockSize - sizeof(data_pointer)) / sizeof(element_type) * maxBlocks;&#125;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;template &lt;class U, class... Args&gt;inline void MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::construct(U* p, Args&amp;&amp;... args) &#123; new (p) U(std::forward&lt;Args&gt;(args)...);&#125;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;template &lt;class U&gt;inline void MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::destroy(U* p) &#123; p-&gt;~U();&#125;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;template &lt;class... Args&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::pointer MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::newElement(Args&amp;&amp;... args) &#123; std::lock_guard&lt;std::recursive_mutex&gt; lock(m_); pointer result = allocate(); construct&lt;value_type&gt;(result, std::forward&lt;Args&gt;(args)...); return result;&#125;template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline void MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::deleteElement(pointer p) &#123; std::lock_guard&lt;std::recursive_mutex&gt; lock(m_); if (p != nullptr) &#123; p-&gt;~value_type(); deallocate(p); &#125;&#125;#endif 3.2 使用示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &quot;MemoryPool.hpp&quot;#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;assert.h&gt;using namespace std;class Apple &#123;public: Apple() &#123; id_ = 0; cout &lt;&lt; &quot;Apple()&quot; &lt;&lt; endl; &#125; Apple(int id) &#123; id_ = id; cout &lt;&lt; &quot;Apple(&quot; &lt;&lt; id_ &lt;&lt; &quot;)&quot; &lt;&lt; endl; &#125; ~Apple() &#123; cout &lt;&lt; &quot;~Apple()&quot; &lt;&lt; endl; &#125; void SetId(int id) &#123; id_ = id; &#125; int GetId() &#123; return id_; &#125;private: int id_;&#125;;void ThreadProc(MemoryPool&lt;char&gt; *mp) &#123; int i = 0; while (i++ &lt; 100000) &#123; char* p0 = (char*)mp-&gt;allocate(); char* p1 = (char*)mp-&gt;allocate(); mp-&gt;deallocate(p0); char* p2 = (char*)mp-&gt;allocate(); mp-&gt;deallocate(p1); mp-&gt;deallocate(p2); &#125;&#125;int main()&#123; MemoryPool&lt;char&gt; mp; int i = 0; while (i++ &lt; 100000) &#123; char* p0 = (char*)mp.allocate(); char* p1 = (char*)mp.allocate(); mp.deallocate(p0); char* p2 = (char*)mp.allocate(); mp.deallocate(p1); mp.deallocate(p2); &#125; std::thread th0(ThreadProc, &amp;mp); std::thread th1(ThreadProc, &amp;mp); std::thread th2(ThreadProc, &amp;mp); th0.join(); th1.join(); th2.join(); Apple* apple = nullptr; MemoryPool&lt;Apple&gt; mp2; apple = mp2.newElement(10); assert(apple); int a = apple-&gt;GetId(); // 10 assert(a == 10); apple-&gt;SetId(12); mp2.deleteElement(apple); return 0;&#125;","tags":["C++","内存池","多线程"],"categories":["C++语言"]},{"title":"移除Qt控件虚线框","path":"/post/2202762022.html","content":"方式一：使用 StyleSheet123QWidget:focus &#123; outline: none; /* 去掉得到焦点时的虚线框 */&#125; 方式二：继承 QProxyStyle继承 QProxyStyle，PrimitiveElement 为 QStyle::PE_FrameFocusRect 时不绘制虚线框，然后在 main() 函数里调用 QApplication::setStyle() 使用新的样式。 123456789101112131415161718192021// 文件名: NoFocusRectStyle.h#ifndef NOFOCUSRECTSTYLE_H#define NOFOCUSRECTSTYLE_H#include &lt;QProxyStyle&gt;class NoFocusRectStyle : public QProxyStyle&#123;public: NoFocusRectStyle(QStyle *baseStyle) : QProxyStyle(baseStyle) &#123;&#125; void drawPrimitive(PrimitiveElement element, const QStyleOption *option, QPainter *painter, const QWidget *widget = 0) const&#123; if (element == QStyle::PE_FrameFocusRect) &#123; return; &#125; QProxyStyle::drawPrimitive(element, option, painter, widget); &#125;&#125;;#endif // NOFOCUSRECTSTYLE_H 12345678910111213// 文件名: main.cpp#include &quot;Widget.h&quot;#include &quot;NoFocusRectStyle.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123; QApplication app(argc, argv); NoFocusRectStyle *style = new NoFocusRectStyle(app.style()); app.setStyle(style); // Ownership of the style object is transferred to QApplication Widget w; w.show(); return app.exec();&#125;","tags":["Qt"],"categories":["Qt"]},{"title":"Windbg调试入门","path":"/post/2711697202.html","content":"Windbg 是 Microsoft 公司推出的免费的、带 GUI 的调试器，支持 Source 和 Assembly 两种模式的调试。 Windbg 不仅可以调试应用程序，还可以进行系统内核调试，Windbg 支持的平台包括 X86、IA64、AMD64。 一、安装从下面的链接或其他链接下载安装：Download Debugging tools for Windows 二、配置常用的配置包含符号文件搜索路径、可执行文件搜索路径、源码文件搜索路径配置。 2.1 符号文件搜索路径配置在菜单项File -&gt; Symbol File Path中设置，如： 1D:\\symbol_path;SRV*D:\\symbolslocal*http://msdl.microsoft.com/download/symbols 意思是先从D:\\symbol_path中找符号文件；如果没找到，就去服务器中下载并保存到D:\\symbolslocal目录中。 可以使用.sympath+ 命令来添加其他目录到搜索路径中，如.sympath+ D:\\other_symbol_dir。 然后使用.reload来根据新的路径重新搜索并加载符号文件。 2.2 可执行文件路径在菜单项File -&gt; Image File Path中设置，此项是在加载 dump 时，设置可执行文件 exe、dll 的路径的。 2.3 源代码目录配置在菜单项File -&gt; Source File Path中设置源代码目录。如果当前指令指针在源代码范围内，就会自动跳出源文件窗口。源文件窗口中的操作和 vs 类似。如果没有跳出，可以单机菜单项 Open Source File 手动选择源文件 2.4 设置启动产生可以通过对 windbg 加入启动参数的方式来指定符号文件路径和源码路径等等。 1start &quot;&quot; &quot;%~dp0/Debuggers_x86/windbg.exe&quot; -Q -y &quot;D:\\symbolslocal*http://msdl.microsoft.com/download/symbols&quot; -srcpath &quot;srv*C:\\CodeCache&quot; 三、开始调试可以通过菜单项File -&gt; Open Executable来加载本地的一个 exe 来进行调试，也可以通过菜单项File -&gt; Attache to a Process来加载一个已经运行的 exe 来进行调试。 具体调试指令可以参考：Help -&gt; Contents -&gt; Debugging Tools for Windows -&gt; Debuggers -&gt; Debugger Reference 四、工作空间Windbg 会保存每个你调试的工程的信息，这些信息包括调试项目的属性、参数、会话状态、调试器设置、及图形界面信息，类似于 ide 的项目文件。 每个调试的工作空间信息默认保存在HKEY_CURRENT_USER\\Software\\Microsoft\\Windbg\\Workspaces中，在这个键下一般有 4 个子键 User、Kernel、Dump、Explicit, 他们分别保存用户态调试，内核态调试、转储文件调试、以及手动保存（Save Workspace As）的工作空间信息。 五、窗口界面介绍 名称 热键 用途 Command Atl+1 输入命令、显示命令结果和调试信息输出 Watch Atl+2 观察指令全局变量、局部变量和寄存器的信息 Locals Atl+3 自动显示当前函数的所有局部变量 Registers Atl+4 观察和修改寄存器的值 Memory Atl+5 观察和修改内存数据 Call Stack Atl+6 栈中记录的函数调用序列 Disassembly Atl+7 反汇编 Scratch Pad Atl+8 白板，可以用来做调试笔记等 Processes and Threads Atl+9 显示所有调试目标的列表，包括进程和线程等 Command Browser Ctrl+N 执行和浏览命令 六、常用命令windbg 命令分为标准命令，元命令和扩展命令。以.开头的元命令提供标准命令没有提供的功能，也内建在调试引擎中。以!开头的扩展命令用于扩展某一方面的调试功能，实现在动态加载的扩展模块中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061tab键 自动完成命令.hh 查看指定命令的帮助手册.reload 重新加载符号文件.restart 重新启动调试目标bp $exentry 在程序入口点设置断点，$exentry是一个伪寄存器bp 0x00401030 在地址0x00401030处设置断点bp MyTestModule!MyTestFunc 在MyTestModule模块中的MyTestFunc函数处设置断点，前提是该模块符号已经加载bp MyTestModule!MyTestClass::SetValue 在模块MyTestModule的MyTestClass类成员函数SetValue处设置断点bp @@C++(MyTestModule!MyTestClass::SetValue) 与上面一样，语法不同，C++语法，上面的为MASM语法bl 查看设置的断点be 激活断点bd 禁用断点bc 删除某个断点ba 设置访问断点ba r 1 0044108c 在内存0044108c的位置开始的下一个字节的读断点ba w4@@C++(&amp;i) 给变量i地址下4个字节的写断点p 单步执行，相当于F10g 运行程序，相当于F5gu 返回函数调用处，相当于shift+F11u 查看当前正要执行的代码k 查看当前调用堆栈~*kb 显示所有进程调用堆栈~ 查看调试进程中的线程信息!teb 线程环境块~. 当前线程信息~# 导致当前异常或调试事件的线程信息~[Number]s 线程切换a 修改当前指令，输入修改的指令按Enter结束s –a 00400000 L53000 “Wrong” 以ASCII码的形式从00400000处开始往后53000个字节搜索字符串“Wrong”db 400000 以二进制的方式显示内存地位为400000开始的内容dd 400000 以DWORD类型查看d 按上一次的d命令的方式来显示，如果不带参数，则从上一次显示结束的地方继续显示?i 查看局部变量i的值，会以10进制和16进制同时显示eb 0012ff78 &#x27;a&#x27; &#x27;b&#x27; 从内存地址0012ff78开始依次写入后面的值r 用于查看或者修改寄存器或伪寄存器r $peb $peb是一个伪寄存器，调试器将它定义为当前进程的进程环境块地址dt 用于查看结构体内容!address 400000 查看指定内存地址的信息dv 查看当前作用域下局部变量的类型和值.ecxr 当前异常的上下文信息!analyze -v 详细显示当前异常信息，常用于分析dmp文件| 所有进程列表|. 当前进程信息|# 导致当前异常或调试事件的进程信息|[Number]s 进程切换!peb 进程环境块!locks 查看进程中有些锁处于锁定状态!cs -l 查看处于锁定状态的关键区!handle 000000c0 f 查看句柄000000c0的信息lm 查看已加载的模块信息lm vm Test* 查看符合Test*名称的模块信息，v表示显示详细信息，m表示通配符模式 七、常用调试方法7.1、附加进程调试使用 File 菜单中的 Attach to a Process 选项来选择要附加调试的进程. 7.2、启动新进程并调试有三种方式可以启动新的进程，并自动附加调试。 方式一： 使用菜单File-&gt; Open Executable选项来选择要启动调试的进程。 方式二： 启动 windbg 时将待调试的程序的文件路径作为参数传递给 windbg。 方式三： 新建注册表项。在“HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options”下新建一个以程序名命名的子项，然后在这个子项中新建一个名为Debugger的REG_SZ类型的值，将值设置为 windbg 的全路径，比如：C:\\Program Files (x86)\\Windows Kits\\8.1\\Debuggers\\x86\\windbg.exe。 这样，再运行待调试的程序时，操作系统就会先启动 windbg，并把要调试程序的路径传递给他。 7.3、调试转储文件使用 File 菜单中的 Open Crash Dump 选项来加载 dump 文件。 7.4、远程调试服务器（被调试程序的机器）和客户端（发出远程请求的机器）都应该安装版本相同的 windbg，应该有网络连接或者串行口连接。 以 tcp 端口方式： 以命令行的方式启动服务器中的 windbg，如：windbg.exe -server tcp:port&#x3D;5005以命令行的方式启动客户端中的 windbg，如：windbg.exe -remote tcp:port&#x3D;5005,server&#x3D;192.168.1.180 以管道方式： 以命令行的方式启动服务器中的 windbg，如：windbg -server npipe:pipe&#x3D;advdbg （adbdbg 为命名管道名称）。在客户端中以命令行的方式启动 windbg，如：windbg -remote npipe:server&#x3D;REMOTEHOSTNAME,pipe&#x3D;advdbg （REMOTEHOSTNAME 为远程主机名，dbvdbg 为远程主机创建的命名管道名，也可以选择 File 菜单中的 Connect to Remote Session,在弹出来的编辑框中输入远程参数 npipe:server&#x3D;REMOTEHOSTNAME,pipe&#x3D;advdbg） 成功连接后，命令行信息区会显示类似如下信息： 1...(npipe advdbg) connected at Thu Jul 11 14:22:02 2017 之后可以在客户端或者服务器的 windbg 中执行各种调试命令，执行结果会同时显示在两个调试器中。 其它的远程调试方案，可以参考:https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/remode-debugging-using-windbg","tags":["Windbg"],"categories":["软件调试"]},{"title":"深入理解C++虚函数","path":"/post/3162890435.html","content":"本文主要介绍 C++虚函数的底层实现，虚析构函数的作用，虚函数表的数据结构及存储方式，以及__declspec(novtable)的作用。 一. 虚函数介绍C++中的虚函数主要是用来实现多态（面向对象的三大特性之一）的。下面是一个实现多态的错误例子： 123456789101112131415161718192021222324252627282930313233343536373839404142// 基类//class Base &#123;public: Base() &#123; printf(&quot;Call Base::Base() &quot;); &#125; ~Base() &#123; &#125; void Name() &#123; printf(&quot;Call Base::Name() &quot;); &#125;&#125;;// 派生类//class Derive : public Base &#123;public: Derive() &#123; printf(&quot;Call Derive::Derive() &quot;); &#125; ~Derive() &#123; &#125; void Name() &#123; printf(&quot;Call Derive::Name() &quot;); &#125;&#125;;int main()&#123; Base* pBase = new Derive(); pBase-&gt;Name(); delete pBase; return 0;&#125; 程序输出： 123Call Base::Base()Call Derive::Derive()Call Base::Name() 输出内容的第 3 行为：Call Base::Name()，并不是期望的Call Derive::Name()。因为void Name()函数不是虚函数，所以pBase-&gt;Name()调用的是基类的 Name()函数，并不是我们所期望的派生类 Derive 的 Name()函数。 如果将基类中void Name()改成虚函数virtual void Name()，程序输出就会和我们期望的一样： 12345678910111213141516// 基类//class Base &#123;public: Base() &#123; printf(&quot;Call Base::Base() &quot;); &#125; ~Base() &#123; printf(&quot;Call Base::~Base() &quot;); &#125; virtual void Name() &#123; printf(&quot;Call Base::Name() &quot;); &#125;&#125;; 二、 虚析构函数virtual不仅可以修饰成员函数，也可以用来修饰析构函数，也就是我们常说的虚析构函数。 下面的例子中的基类的析构函数没有使用 virtual 修饰，我们先执行程序，观察运行结果（类似上面的程序，只是在析构函数中多加入了输出打印语句）。 123456789101112131415161718192021222324252627282930313233343536373839404142// 基类//class Base &#123;public: Base() &#123; printf(&quot;Call Base::Base() &quot;); &#125; ~Base() &#123; printf(&quot;Call Base::~Base() &quot;); &#125; virtual void Name() &#123; printf(&quot;Call Base::Name() &quot;); &#125;&#125;;// 派生类//class Derive : public Base &#123;public: Derive() &#123; printf(&quot;Call Derive::Derive() &quot;); &#125; ~Derive() &#123; printf(&quot;Call Derive::~Derive() &quot;); &#125; void Name() &#123; printf(&quot;Call Derive::Name() &quot;); &#125;&#125;;int main()&#123; Base* pBase = new Derive(); pBase-&gt;Name(); delete pBase; return 0;&#125; 程序输出： 1234Call Base::Base()Call Derive::Derive()Call Derive::Name()Call Base::~Base() 从输出内容的第 4 行可以看到，执行delete pBase语句只有基类 Base 类的析构函数被调用了，而派生类 Derive 的析构函数却没有被调用。如果此时派生类 Derive 中有需要在析构函数执行的代码（如内存释放，句柄关闭等），这些代码将不会执行，有可能就会造成内存泄漏、句柄泄漏、逻辑错误等问题。 正确的做法是：使用 virtual 修饰基类的析构函数，即虚析构函数。 12345678910111213141516// 基类//class Base &#123;public: Base() &#123; printf(&quot;Call Base::Base() &quot;); &#125; virtual ~Base() &#123; printf(&quot;Call Base::~Base() &quot;); &#125; virtual void Name() &#123; printf(&quot;Call Base::Name() &quot;); &#125;&#125;; 此时程序输出为： 12345Call Base::Base()Call Derive::Derive()Call Derive::Name()Call Derive::~Derive()Call Base::~Base() 调用delete pBase之后，先执行了派生类 Derive 的析构函数，然后执行基类 Base 的析构函数。 在《C++API 设计》一书中有明确的说到：“如果希望一个类可以被继承，那么就应该将它的析构函数使用 virtual 修饰；反过来可以理解为，如果一个类的析构函数不是虚的，那么这个类是被设计为不可继承的。” 三、虚函数的实现原理3.1 实现原理C++的虚函数是使用虚函数表（即指针数组，也就是指针的指针）来实现的。 只要在类中声明了虚函数，编译器就会在类的对象中自动生成一个虚函数表，但一个对象最多只有一个虚函数表，不管这个类声明了多少个虚函数。虚函数表是针对于类的对象的。 3.2 虚函数表（指针）存储位置不同的编译器将自动生成的虚函数表指针存放的位置不同，有的存放在类对象所占内存的起始位置，有的存放在类对象所占内存的末尾。 可以通过如下代码来判断： 1234567891011121314151617// 返回值： ture - 虚函数指针存放在对象内存起始位置// false - 虚函数指针存放在对象内存末尾位置//bool VirtualTableAtFirst() &#123; class _C &#123; public: char _i; virtual void _f() &#123; &#125; &#125;; _C c; char * p1 = reinterpret_cast&lt;char*&gt;(&amp;c); char * p2 = reinterpret_cast&lt;char*&gt;(&amp;c._i); return p1 != p2;&#125; 通过 MSVC2015 编译运行，返回true, 说明 MSVC 编译器是将虚函数表指针放置在类对象内存的起始位置处。 3.3 虚函数表存储方式既然知道了 C++是使用虚函数表的形式来实现虚函数的，那个虚函数表中的数据是以何种形式来存储的了？ 现在我们根据类的继承方式的不同来分别说明。 3.3.1 单继承无重载类结构如图，Derive 继承于 Base，但 Derive 没有重载 Base 类中的任何函数。 需要说明的是，函数 f(), g(), h(), f1(), g1(), h1() 均为虚函数，这个在图上没有明确的写出来，后面的图也是一样。 这时Base b; 对象 b 的虚函数表为： Derive d; 对象 d 的虚函数表为： 3.3.2 单继承有重载Derive 重载 Base 类中的 f()函数： 这时Base b; 对象 b 的虚函数表不变，无论继承于它派生类如何重载，都不会影响基类的虚函数： Derive d; 对象 d 的虚函数表为： 派生类中重载基类的 f()函数指针替换了原来基类中虚函数 Base::f()的指针； 派生类中其他的虚函数存放在基类虚函数之后。 3.3.3 多继承无重载 此时，Derive d; 对象 d 的虚函数表为： 派生类自己的虚函数存放在第一个基类的虚函数表的最后面。 3.3.4 多继承有重载 此时，Derive d; 对象 d 的虚函数表为： 四、虚函数表的应用我们知道在 C++中要调用类的私有方法，我们可以使用友员（friend）的方式。但其实如果我们知道类的定义，完全可以根据该类对象的内存布局来直接调用它的私有函数。 下面介绍如何使用虚函数表的方式来调用该类的私有虚函数。 现有如下Test类，提供了一个私有虚函数virtual void Func()： 123456789101112131415class Test &#123;public: Test() &#123; &#125; virtual~ Test() &#123; &#125;private: virtual void Func() &#123; printf(&quot;Private Function &quot;); &#125;&#125;; 现在我们使用虚函数表来调用Func成员函数： 123456789101112131415typedef void(*PFN_Func)();int main()&#123; Test t; unsigned long **VirtualTable = (unsigned long **)(&amp;t); unsigned long FuncAddr = VirtualTable[0][1]; PFN_Func pfnFunc = (PFN_Func)FuncAddr; if (pfnFunc) &#123; pfnFunc(); &#125; return 0;&#125; 我们知道虚函数表其实就是一个二维数组。因为示例中的Test类没有继承于其他类，所以第一维只有一个元素；又因Test类有 2 个虚函数，故第二维有 2 个元素，且Func排在第二个，所以用VirtualTable[0][1]来取Func函数地址。 因为该示例运行在 MSVC 编译器环境，所以默认认为虚函数表位于类对象内存布局的起始位置，故直接使用了unsigned long **VirtualTable = (unsigned long **)(&amp;t);。严谨的做法应该是先判断虚函数表是否位于对象的内存布局起始位置。 五、__declspec(novtable)Mircrosoft C++中提供了__declspec(novtable)来修饰类，__declspec(novtable)会阻止编译器为该类生成虚函数表，这样可以减少编译生成代码的大小，同时也约束该类无法被实例化。 1234567891011121314151617181920// novtable.cpp#include &lt;stdio.h&gt;struct __declspec(novtable) X &#123; virtual void mf();&#125;;struct Y : public X &#123; void mf() &#123; printf_s(&quot;In Y &quot;); &#125;&#125;;int main() &#123; // X *pX = new X(); // pX-&gt;mf(); // 导致运行时访问冲突 Y *pY = new Y(); pY-&gt;mf();&#125; 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["C++","虚函数"],"categories":["C++语言"]},{"title":"以管理员权限运行批处理脚本","path":"/post/3405299964.html","content":"基本原理： 根据 系统自带的cacls.exe 是否能够访问”%SystemDrive%\\System Volume Information”文件，来判断当前批处理进程是否具有管理员权限。 创建 vbs 脚本到临时目录，然后使用该脚本提权执行当前 bat 文件。 下面是批处理模板，在最后追加需要执行的脚本即可。 123456789101112131415@echo offcd /d &quot;%~dp0&quot;cacls.exe &quot;%SystemDrive%\\System Volume Information&quot; &gt;nul 2&gt;nulif %errorlevel%==0 goto Adminif exist &quot;%temp%\\getadmin.vbs&quot; del /f /q &quot;%temp%\\getadmin.vbs&quot;echo Set RequestUAC = CreateObject^(&quot;Shell.Application&quot;^)&gt;&quot;%temp%\\getadmin.vbs&quot;echo RequestUAC.ShellExecute &quot;%~s0&quot;,&quot;&quot;,&quot;&quot;,&quot;runas&quot;,1 &gt;&gt;&quot;%temp%\\getadmin.vbs&quot;echo WScript.Quit &gt;&gt;&quot;%temp%\\getadmin.vbs&quot;&quot;%temp%\\getadmin.vbs&quot; /fif exist &quot;%temp%\\getadmin.vbs&quot; del /f /q &quot;%temp%\\getadmin.vbs&quot;exit:Adminrem ---------- Here is the script to be run ------------","tags":["批处理","权限"],"categories":["Windows批处理"]},{"title":"高速文件下载器的实现","path":"/post/3157704992.html","content":"我们下载文件时通常会使用浏览器或者迅雷这样的下载工具，这些工具大多具有高速下载（下载速度快）、断点续传（可以暂停之后继续下载）等特性。 现在我们自己开发的应用软件中也需要支持这些特性，我们该如何设计和实现了？本文主要围绕这一问题进行论述，并在文章最后分享了作者自己开发的高速文件下载库。 一个完善的文件下载库需要具有如下特性： 多线程分片下载 断点续传 磁盘缓存 最高下载速率限制及实时下载速率反馈（可选） 多协议支持，跨平台（可选） 1. 多线程分片下载Chrome 浏览器和迅雷能实现高速下载的核心就是多线程分片下载（这里忽略迅雷的离线加速等技术），以 HTTP 协议为例，HTTP 协议支持在请求头中指明需要请求数据的起始和结束位置。我们可以开启多个线程同时进行不同的 HTTP 请求，这些请求分别请求同一文件的不同位置，我们将每个 HTTP 请求的内容称为“片”，在文件的所有片下载完成之后，我们再进行片的合并。 libcurl 中可以通过如下方式指定请求文件的某一区域： 1curl_easy_setopt(curl_, CURLOPT_RANGE, &quot;1024-2048&quot;); 如何确定分片数量以及每片大小？文件分片有 2 种策略： 分片数量固定除最后一片外，每片的Size &#x3D; 文件总Size &#x2F; 分片Num 分片尺寸固定分片Num &#x3D; 文件总Size &#x2F; 每片的Size，如果不能整除，还需要新建一个分片，将余数放到该分片中 无论采用哪一种分片策略，在确定分片 Num 和每片 Size 之前，我们都需要先向文件服务器发起一个请求来获取原始文件总 Size。 2. 断点续传试想我们正在下载一个 4G 大小的文件，下载到一半的时候，忽然因为某些原因需要中止下载，等可以再次下载的时候，却不能继续上次的下载进度进行下载，那岂不是让人很抓狂。断点续传功能就是来解决这种问题的，虽然目前市场上的下载器都支持这些功能，但我们需要自己开发下载器的话，还是不得不自己来实现这个功能的。 断点续传原理主要是将已下载的数据信息（偏移、大小等）记录到某个文件中（我们称之为索引文件），下次下载前读取该文件中已下载信息，跳过已下载的内容，直接下载未下载的数据。 断点续传一般都会和多线程分片下载结合使用。 3. 磁盘缓存文件下载中涉及的磁盘缓存都是磁盘的写缓存，主要是为了避免频繁的对磁盘进行写操作，降低磁盘 IO 的效率。 原理：将网络下载数据存入预先分配好的内存缓冲区，待内存缓冲区满之后，再一次性写入磁盘。 关于内存缓冲区，建议采用双缓冲机制，因为磁盘写入操作是一个相对耗时的操作，在将缓冲区写入磁盘时，该缓冲区是禁止写入的，因而此时网络下载的数据写入缓冲区将被阻塞，从而影响下载速率。 4. 限速及实时速率最高下载速率限制有助于减少用户电脑带宽占用，而实时下载速率反馈可以让用户看到实时的下载速度。 因为采用的是多线程下载，假如最高下载速率限制为 N，则每个线程的最大下载速率为: N / 线程Num，但需要注意的是，如果当前活跃的线程数少于初始线程数时（如有的线程已经下载完了），需要重新计算每个线程的最大下载速率，否则总下载速率将会下载，无法达到最高下载速率。 zoe介绍zoe 是我开发的一个文件下载库，支持如上所有特性的开源库，采用 C++开发。该库已经在多个产品中使用，其稳定性得到了验证。 该库原名为teemo，teemo一词来源于英雄联盟游戏中的迅捷斥候，由于该库被灰产非法使用，导致代码被杀毒软件加入特征库，我闭源了原库，在修改代码后重新开源。 限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺 您可以通过在 blog-comment 项目中提交Issue来间接地发表评论🍀","categories":["Power By Me"]},{"title":"Windows平台生成Dump文件","path":"/post/2648186181.html","content":"转储文件也就是我们常说的 dump 文件，可以把转储文件看成软件的某个时刻的一个快照，我们一般在软件出现问题时手动生成或者程序自动生成转储文件。 一、工具篇下面我们介绍几种借助第三方工具生成转储文件的方法。 1.1 任务管理器任务管理器可以说是最易获取的系统工具，同时它具有生成转储文件的功能。但要注意的是在 64 位操作系统上面，默认启动的是 64 位的任务管理器。使用任务管理器生成转储文件需要遵循一个原则：用 32 位任务管理器给 32 位进程（无论该进程是运行在 32 位还是 64 位系统上面）生成转储文件，用 64 位任务管理器给 64 位进程生成转储文件。 在 64 位系统上，32 位的任务管理器位于C:\\Windows\\SysWOW64\\taskmgr.exe。 生成方法：右键进程 –&gt; 创建转储文件–&gt;弹出对话框提示生成成功，以及 dmp 文件位置。 类似的工具还有：Process Explorer，PCHunter 等。 1.2 注册表可以通过在注册表中进行配置，让操作系统在程序崩溃时自动生成 dmp 文件，并放到指定位置。在注册表项 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\\LocalDumps 下面根据进程名（含.exe）新建子项，并配置如下值：名称：DumpCount，类型：REG_DWORD，最大保留 Dump 个数，默认为 10.名称：DumpType，类型：REG_DWORD，Dump 类型(1-Mini dump, 2-Full dump)，默认为 1.名称：DumpFolder，类型：REG_EXPAND_SZ，Dump 文件保存的位置。 1.3 Windbg生成方法：File 菜单–&gt;Attach to Process–&gt;输入命令.dump /ma /u d:\\test.dmp提示成功之后，可以在 D 盘看到生成 dmp 文件到 test_0bf0_2017-08-13_23-46-37-244_11cc.dmp 文件。 0bf0_2017-08-13_23-46-37-244_11cc 是&#x2F;u 参数附加上去的，意思是 2017 年 08 月 13 日 23 时 46 分 37 秒 244 毫秒，进程 PID 位 11cc。 .dump 命令参数比较多，常用的组合就是/ma，&#x2F;m 表示生成 minidump，&#x2F;a 表示 dmp 包含所有信息，&#x2F;u 参数就是上面说的附加时间和 PID 信息到文件名。 1.4 Windbg -IWindbg -I 可以将 Windbg 设置为及时调试器（开启了 UAC 的系统上面，需要以管理员权限运行），也就是我们常说的 JIT 调试器。设置成功之后，如遇到程序崩溃，Windbg 会自动运行并附加到崩溃进程。 设置成功之后会弹出对话框提示设置成功。如果不想弹出对话框，可以加上 S（slient 首字母）Windbg -IS. 也可以通过修改注册表项 AeDebug 来实现和 windbg -I 同样的功能。根据 windbg 位数（32&#x2F;64）和系统的位数（32&#x2F;64）的不同，修改的注册表项的位置也不同： 32 位 windbg–32 位系统：HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug 32 位 windbg–64 位系统：HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug 64 位 windbg–64 位系统：HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug AeDebug 项下面有 2 个值：名称：Auto，类型：REG_SZ，0 表示出现崩溃弹出对话框，让用户选择关闭程序还是调试程序；1 表示自动弹出设置调试器。名称：Debugger，类型：REG_SZ，调试器值。默认为”C:\\WINDOWS\\system32\\vsjitdebugger.exe” -p %ld -e %ld，设置为 windbg 需更改为”C:\\Debuggers\\WinDbg\\x86\\windbg.exe” -p %ld -e %ld -g 看起来挺复杂，其实挺好理解的。 1.5 Adplusadplus 工具位于 windbg 安装目录，最早叫 adplus.vbs，以 VBScript 脚本提供，最新版改成了 adplus.exe。adplus.exe 不仅可以在程序崩溃时手动运行来生成 dmp 文件，也可以在崩溃之前就运行它，当程序崩溃时它会自动生成 dmp 文件；甚至可以在程序没有运行之前就先运行 adplus，当程序崩溃时它会自动生成 dmp 文件。如：adplus -pn powerpnt.exe -pn wincmd32.exe -hang -o c:\\test Adplus 用法： 1234ADPlus &lt;RunMode&gt; -o &lt;OutputDirectory&gt; [Options]RunMode：-hang或-crash -hang 附加到进程，生成dmp，然后解除附加(detach)。多用于程序卡死的情况下。 -crash 附加到进程，直到程序崩溃或者其他事件发生，生成dmp文件，然后解除附加。 常用参数： -o 目录指定生成文件存储目录。 -p 进程 ID指定进程 ID，可以同时使用多次-p 来指定多个进程。 -pn 进程名指定进程名，支持通配符，也可以同时使用多次-pn 来指定多个进程，但进程名必须存在，不存在则失败。 -po 进程名和-pn 类似，但-po 不要求进程名必须存在。可以在进程启动之前就先启动 Adplus. -pmn 进程名pmn 为 Process Monitor 缩写。顾名思义，可以监视进程列表，一旦指定进程运行，则附加上去。只适用于-crash 模式。 ​# 二、代码篇使用代码生成dump文件的原理大致是： 捕获异常，如SetUnhandledExceptionFilter、__try...__except。 使用MiniDumpWriteDump写入dump到文件。 为了便于使用，我封装了一个捕获异常并写入dump的辅助，具体如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// EasyDump.h#pragma once#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;strsafe.h&gt;namespace cpp4j &#123; typedef struct _EXCEPTION_POINTERS EXCEPTION_POINTERS, *PEXCEPTION_POINTERS; int __cdecl RecordExceptionInfo(PEXCEPTION_POINTERS pExceptPtrs, const TCHAR *szDumpNamePrefix); TCHAR *lstrrchr(LPCTSTR string, int ch); void DumpMiniDump(HANDLE hFile, PEXCEPTION_POINTERS excpInfo);&#125;#define WINMAIN_BEGIN(szDumpNamePrefix) \\ int __96A9695E_RUN_WINMAIN_FUNC(HINSTANCE hInstance, LPTSTR lpCmdLine);\\ LONG WINAPI __96A9695E_UnhandledExceptionHandler( _EXCEPTION_POINTERS *pExceptionInfo ) \\ &#123; \\ OutputDebugString(TEXT(&quot;Create a dump file sine an exception occurred in sub-thread. &quot;)); \\ int iRet = cpp4j::RecordExceptionInfo(pExceptionInfo, szDumpNamePrefix); \\ return iRet; \\ &#125; \\ int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow) \\ &#123; \\ UNREFERENCED_PARAMETER(hPrevInstance); \\ UNREFERENCED_PARAMETER(nCmdShow); \\ ::SetUnhandledExceptionFilter( __96A9695E_UnhandledExceptionHandler );\\ int ret = 0;\\ __try\\ &#123;\\ ret = __96A9695E_RUN_WINMAIN_FUNC(hInstance, lpCmdLine);\\ &#125;\\ __except(cpp4j::RecordExceptionInfo(GetExceptionInformation(), szDumpNamePrefix))\\ &#123;\\ OutputDebugString(TEXT(&quot;Create a dump file sine an exception occurred in main-thread. &quot;)); \\ &#125;\\ return ret;\\ &#125;\\ int __96A9695E_RUN_WINMAIN_FUNC(HINSTANCE hInstance, LPTSTR lpCmdLine) \\ &#123;#define WINMAIN_END &#125;#define MAIN_BEGIN(szDumpName) \\ int __96A9695E_RUN_MAIN_FUNC(int argc, _TCHAR* argv[]);\\ LONG WINAPI __96A9695E_UnhandledExceptionHandler( _EXCEPTION_POINTERS *pExceptionInfo ) \\ &#123; \\ OutputDebugString(TEXT(&quot;Create a dump file since an exception occurred in sub-thread. &quot;)); \\ int iRet = cpp4j::RecordExceptionInfo(pExceptionInfo, szDumpName); \\ return iRet; \\ &#125; \\ int _tmain(int argc, _TCHAR* argv[])\\ &#123; \\ ::SetUnhandledExceptionFilter( __96A9695E_UnhandledExceptionHandler );\\ int ret = 0;\\ __try\\ &#123;\\ ret = __96A9695E_RUN_MAIN_FUNC(argc, argv);\\ &#125;\\ __except(cpp4j::RecordExceptionInfo(GetExceptionInformation(), szDumpName))\\ &#123;\\ OutputDebugString(TEXT(&quot;Create a dump file since an exception occurred in main-thread. &quot;)); \\ &#125;\\ return ret;\\ &#125;\\ int __96A9695E_RUN_MAIN_FUNC(int argc, _TCHAR* argv[]) \\ &#123;#define MAIN_END &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// EasyDump.cpp#include &quot;EasyDump.h&quot;#include &lt;DbgHelp.h&gt;#pragma comment(lib, &quot;Dbghelp.lib&quot;)namespace cpp4j &#123; TCHAR *lstrrchr(LPCTSTR string, int ch) &#123; TCHAR *start = (TCHAR *)string; while (*string++) ; while (--string != start &amp;&amp; *string != (TCHAR)ch) ; if (*string == (TCHAR)ch) return (TCHAR *)string; return NULL; &#125; inline void DumpMiniDump(HANDLE hFile, PEXCEPTION_POINTERS excpInfo) &#123; if (!excpInfo) &#123; static int iTimes = 0; if (iTimes++ &gt; 1) return; __try &#123; RaiseException(EXCEPTION_BREAKPOINT, 0, 0, NULL); &#125; __except (DumpMiniDump(hFile, GetExceptionInformation()), EXCEPTION_CONTINUE_EXECUTION) &#123; &#125; &#125; else &#123; MINIDUMP_EXCEPTION_INFORMATION eInfo; eInfo.ThreadId = GetCurrentThreadId(); eInfo.ExceptionPointers = excpInfo; eInfo.ClientPointers = FALSE; MiniDumpWriteDump( GetCurrentProcess(), GetCurrentProcessId(), hFile, MiniDumpNormal, excpInfo ? &amp;eInfo : NULL, NULL, NULL); &#125; &#125; int __cdecl RecordExceptionInfo(PEXCEPTION_POINTERS pExceptPtrs, const TCHAR *szDumpNamePrefix) &#123; static bool bFirstTime = true; if (!bFirstTime) return EXCEPTION_CONTINUE_SEARCH; bFirstTime = false; // Dmp文件命名：前缀_年月日.时.分.秒.毫秒.dmp // TCHAR szLocalTime[50] = &#123; 0 &#125;; SYSTEMTIME st; GetLocalTime(&amp;st); StringCchPrintf(szLocalTime, 50, TEXT(&quot;%04d%02d%02d.%02d.%02d.%02d.%04d&quot;), st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds); TCHAR szExeDir[MAX_PATH + 1] = &#123; 0 &#125;; GetModuleFileName(NULL, szExeDir, MAX_PATH); if (TCHAR *p = lstrrchr(szExeDir, TEXT(&#x27;\\\\&#x27;))) &#123; *(p + 1) = 0; &#125; TCHAR szDumpFileName[MAX_PATH + 1] = &#123; 0 &#125;; _stprintf_s(szDumpFileName, MAX_PATH, TEXT(&quot;%s%s_%s.dmp&quot;), szExeDir, szDumpNamePrefix, szLocalTime); HANDLE hMiniDumpFile = CreateFile( szDumpFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL); if (hMiniDumpFile != INVALID_HANDLE_VALUE) &#123; DumpMiniDump(hMiniDumpFile, pExceptPtrs); CloseHandle(hMiniDumpFile); hMiniDumpFile = NULL; &#125; return EXCEPTION_EXECUTE_HANDLER; &#125;&#125; MAIN_BEGIN和WINMAIN_BEGIN中的参数为生成的 dump 文件的前缀，dump 文件命名方式: 前缀*年月日.时.分.秒.毫秒.dmp。 使用方法也很简单，使用MAIN_BEGIN替换main，WINMAIN_BEGIN替换WinMain即可： 123456789101112#include &quot;EasyDump.h&quot;MAIN_BEGIN(TEXT(&quot;Test&quot;))int i = 0;int *p = &amp;i;p = NULL;*p = 5;return 0;MAIN_END 上面的代码会在程序的当前目录生成一个名为 Test_20171101.14.49.57.0264.dmp 的 dump 文件。","tags":["Dump"],"categories":["Windows编程"]},{"title":"一键启动神器之1key.run","path":"/post/776574933.html","content":"1key.run既是产品官网域名（域名没钱续费，官网已嘎），亦是产品名称。 顾名思义，主打一键启动，可以一键启动本地应用、网页搜索，并内置了一些实用功能如日历、科学计算、截图、哈希计算等基础功能。 一、下载 Github（更新及时） https://github.com/winsoft666/1key.run-Setup/releases 奶牛快传（更新可能延后） https://cowtransfer.com/s/f0c4a81b0e604b 二、产品特色产品特色归纳为三个字：轻、快、爽。 2.1 轻“轻”为轻量化。减少系统资源的占用，不采用臃肿的 Electron 或 CEF 等 Web 技术架构，所有功能都采用纯 C++ Native 开发。软件安装包仅有 15MB（事实上还可以更小），运行时仅占用 12MB 内存。 2.2 快“快”为快速运行、快速上手。 1. 输入本地应用的简写（如拼音首字母）可以快速启动该应用。输入szqm: 默认会选中第一项，也可以使用Alt + 数字快捷键快速定位到其他项。 按Enter键运行当前项，还可以在右键菜单中可以选择“以管理员权限运行”。 2. 输入数学表达式，可以快速的计算该表达式的结果。 输入sin(90)+cos(45)+(2+3)*4： 科学计算器为 1key.run 的内置功能，在表达式计算结果项上按Enter键可以进入该功能详情页： 也可以输入kxjsq启动该功能，按Esc键可以退出当前功能。 3. 剪切板检测当 1key.run 被唤起时，会自动检查剪切板中的数据是否可以被 1key.run 的某个功能模块所使用。如复制sin(90)+cos(45)+(2+3)*4到剪切板，使用快捷键Alt+空格唤起 1key.run，会自动显示计算结果。 4. 快速上手想到则输入，所输即所得。不用记忆繁琐的快捷键，只需知道三个快捷键即可上手使用： Alt + 空格唤起 1key.run Enter为执行当前选择项 Esc为退出当前功能 2.3 爽完全免费，卸载无残留。 免费版本和 Pro 版本仅在更新通道上有区别，Pro 版本可以使用稳定的更新通道。在功能方面，免费版本和 Pro 版本没有任何区别。 三、功能介绍1key.run 将功能划分成了不同的功能模块，包含如下功能模块： 快速启动 网页搜索 科学计算器 颜色拾取 日历 截图 JSON 格式化 XML 格式化 文件哈希计算 可以在 1key.run 主搜索框输入功能模块支持的数据来唤起该功能，如1+2+3为科学计算器支持的数据，&#123;&quot;a&quot;:1&#125;为 JSON 格式化支持的数据。 也可以直接输入功能模块的触发关键字（可以在“设置”中自定义）来启动该功能，如输入qs触发颜色拾取功能等。 3.1 快速启动快速启动可以用来启动本地应用，支持中文拼音简写、分词，如： 123有道翻译 -&gt; ydfyVisual Studio Code -&gt; vscWinHex -&gt; wh 当搜索结果不足时，会自动添加网页搜索引擎到列表的末尾。 可以在“设置”中自定义需要检索和监控的文件夹，1key.run 会自动检索该文件夹及子文件夹下的可执行项(如.exe、.bat 文件)，并添加到快速启动中。 当文件夹中有文件新增或删除时，1key.run 会自动监控到这些改变，添加到启动项或从中移除。 如果某个目录下文件或子文件夹太多，检索和监控会消耗比较多的系统资源，可以在排除该目录。 最后，我们也可以添加单个启动项。 3.2 网页搜索1key.run 内置了百度、谷歌、必应、百度百科、Microsoft Docs、Github 等主流搜索引擎，输入对的引擎名或简写，可以快速定位到该搜索引擎。 如输入baidu并回车，定位并选择百度搜索引擎： 输入需要搜索的内容，回车即可搜索。 可以在“设置”中管理搜索引擎： 3.3 科学计算器提供传统科学计算器所拥有的全部功能，并且使用起来更加方便。 3.4 颜色拾取实时提取鼠标位置的颜色值，实时显示 RGB 和十六进制颜色值。 与其他取色软件不同的是，1key.run 提供的颜色拾取功能支持通过方向键进行像素级的移动。 3.5 日历传统日历系统通常只显示阴历的“日”，而不显示“月”，有时为了查看当前阴历的月份不得前后翻阅，非常不便。1key.run 提供的轻量级的日历解决了上述问题，使用起来会更加方便，无需联网即可使用。 3.6 截图1key.run 内置的截图功能，支持对窗口、矩形进行截图，实时显示截取区域坐标和尺寸。输入jt可以唤起该功能，也可以在“设置”中自定义全局快捷键。 3.7 JSON 格式化 3.8 XML 格式化 3.9 文件哈希计算计算文件的哈希值，支持MD5、CRC32、SHA-1、SHA-256、SHA-512等哈希类型。 更多更多功能还在开发和完善中，该文档可能更新不及时，已实际应用为准。 限于政策原因，在您看到该文章时，博客可能已经关闭了评论功能🥺 您可以通过在 blog-comment 项目中提交Issue来间接地发表评论🍀","tags":["1key.run"],"categories":["Power By Me"]},{"title":"从汇编的角度分析函数调用过程","path":"/post/4168021185.html","content":"本文从汇编的视角分析了函数的调用方式，掌握该知识对使用 OllyDbg 等动态调试工具会大有裨益。 一、 函数参数传递形式函数的参数传递有 2 种方式： 堆栈方式 寄存器方式 如果是堆栈方式传递的，就需要定义函数参数在堆栈中的传递顺序，并约定函数被调用之后，是由函数来平衡堆栈，还是由调用者来平衡堆栈； 如果是寄存器方式传递的，就需要确定参数存放在哪个寄存器中。 两种方式都有其优缺点，而且与使用的编程语言有关系。 我们在开发中经常遇到调用约定类型，如__cdecl、stdcall、PASCAL、fastcall，这些调用约定类型就用来指定函数参数的传递方式的。 上面几种约定类型，除了fastcall是使用寄存器方式传递参数外，其他的都是使用堆栈传递参数的。 Visual Studio 中的 C++工程，可以C++ –&gt; 高级 –&gt; 调用约定中进行调用约定的设置： 二、使用堆栈方式传递函数参数堆栈是一种“后进先出”的数据结构，ESP寄存器始终指向栈顶。 ESP：栈指针寄存器(Extended Stack Pointer)，永远指向栈顶。 栈中数据的地址从底部到顶部依次减小，也就是说，栈底对应高地址，栈顶对应低地址。 调用函数时，调用者依次把参数压栈，然后调用函数，函数被调用之后，在堆栈中取得参数数据。函数调用结束以后，堆栈需要恢复到函数调用之前的样子，而到底是由调用者来恢复还是函数自身来恢复，根据不同的调用约定类型采用的方式不同。 约定类型 __cdecl stdcall PASCAL fastcall 参数传递顺序 从右到左 从右到左 从左到右 使用寄存器 堆栈平衡者 调用者 函数自身 函数自身 函数自身 __cdcel是 C&#x2F;C++&#x2F;MFC 程序默认的调用约定。 stdcall是绝大多数 Win32 API 函数的约定方式，也有少部分使用__cdcel约定方式（如 wsprintf 等）。 在 Windows C&#x2F;C++开发中常用的就是__cdecl和stdcall这两种调用约定。 举例说明，按照不同的“调用约定”调用函数int add(int a, int b)。从调用者的视角来看，其汇编代码分别表示如下： __cdecl 1234push b ;参数按从右到左传递push acall addadd esp, 8 ;调用者在函数外部平衡堆栈 stdcall 123push b ;参数按从右到左传递push acall add ;函数自己内部平衡堆栈，调用者不需要平衡堆栈 在函数调用过程中，参数入栈的过程如图： 上图中，EBP和函数返回地址ret都是 32 位地址，堆栈中备份了老的EBP值，在函数调用完之后会将EBP恢复为备份在堆栈中的老EBP值，所以从调用者角度来看，在函数的调用开始前和结束后，EBP是不会变化的。 通常函数中的前2条指令都是： 12push ebp mov ebp,esp 通常使用新的EBP获取函数各个参数的值： 12参数a = EBP + 0x8参数b = EBP + 0xC 当然使用ESP获取参数值也是可以的，但使用EBP会更加方便，因为ESP一直指向栈顶，因此会随着局部变量的压栈而变化，而ESP是不会随着入栈&#x2F;出栈而变化的。 三、调用过程分析123456789101112131415#include &lt;stdio.h&gt;int add(int a, int b) &#123; int c = 0; c = a + b; return c;&#125;int main()&#123; int r = add(1, 2); return 0;&#125; 我们使用Visual Studio 2017编译上面代码，并在在工程配置中将函数调用约定设置为__cdecl。 在程序调试过程中，可以在Visual Studio的“反汇编窗口”中看到 C++代码对应的汇编代码，以及寄存器窗口中看到各个寄存器的值。 main函数的反汇编代码如下： 123456789101112131415161718192021222324int main()&#123;00DD1720 push ebp // 参见add函数中关于这一部分的解析00DD1721 mov ebp,esp00DD1723 sub esp,0CCh00DD1729 push ebx00DD172A push esi00DD172B push edi00DD172C lea edi,[ebp-0CCh]00DD1732 mov ecx,33h00DD1737 mov eax,0CCCCCCCCh00DD173C rep stos dword ptr es:[edi] int r = add(1, 2);00DD173E push 2 // 参数b入栈00DD1740 push 1 // 参数a入栈// 调用add函数。// CALL指令相当于执行一条PUSH指令加一条JMP指令，PUSH指令用于压入该指令的下一条指令地址到栈中，用于执行完子函数之后返回来。// JMP指令用于跳转到子函数所在位置开始执行子函数。00DD1742 call add (0DD1276h) 00DD1747 add esp,8 // 因为是__cdecl，所以由调用者来平衡堆栈.00DD174A mov dword ptr [r],eax return 0;00DD174D xor eax,eax&#125; 执行进入add函数后，add函数内的汇编代码如下： 1234567891011121314151617181920212223242526272829int add(int a, int b) &#123;00DD16D0 push ebp // ebp入栈，相当于备份ebp的值00DD16D1 mov ebp,esp // 将esp赋值给ebp，在该函数之后的执行过程中不会再改变ebp的值。00DD16D3 sub esp,0CCh // 在栈上分配0xCC大小的局部变量存储区域00DD16D9 push ebx // 暂存ebx00DD16DA push esi // 暂存esi00DD16DB push edi // 暂存edi00DD16DC lea edi,[ebp-0CCh] //下面4行代码（含该条）实现将0xCC大小的局部变量存储区域全部赋值为0xCC00DD16E2 mov ecx,33h // ecx存储循环次数，结合rep指令使用。为什么是0x33次了？因为是按照4个字节赋值的，0x33 * 0x4 = 0xCC00DD16E7 mov eax,0CCCCCCCCh00DD16EC rep stos dword ptr es:[edi] // 循环赋值 int c = 0;00DD16EE mov dword ptr [c],0 // 将局部变量c赋值为0 c = a + b;00DD16F5 mov eax,dword ptr [a]00DD16F8 add eax,dword ptr [b]00DD16FB mov dword ptr [c],eax return c;00DD16FE mov eax,dword ptr [c] // 将结果存储到eax中。在函数调用中返回结果都是存储在eax中的。&#125;01191701 pop edi // 将edi的值还原到函数调用前01191702 pop esi // 将esi的值还原到函数调用前01191703 pop ebx // 将ebx的值还原到函数调用前01191704 mov esp,ebp // 移动栈顶到ebp位置，从而跳过了局部变量存储区域01191706 pop ebp // 将ebp的值还原到函数调用前01191707 ret // ret指令等同于：弹出此时栈顶的值给eip， // 因为此时栈顶存储的刚好是函数返回地址，所以相当于将返回地址赋值给eip，从而实现了返回到函数调用的地方。 在上面代码的注释中已经包含了详细的解释，特别值得注意的几个地方是： rep stos dword ptr es:[edi]结合edi, ecx来初始化局部存储区域。 函数call指令之前的参数压栈顺序。 CALL指令相当于执行一条PUSH指令加一条JMP指令，PUSH指令用于压入该指令的下一条指令地址到栈中，用于执行完子函数之后返回来。JMP指令用于跳转到子函数所在位置开始执行子函数。 因为是__cdecl调用约定，因此在函数调用完之后，调用方需要使用add esp,8指令来平衡堆栈。 ret指令等同于：弹出此时栈顶的值给 eip，巧妙之处在于此时栈顶存储的刚好是函数返回地址，因此可以继续执行函数下面的语句。","tags":["C++","汇编"],"categories":["C++语言"]},{"title":"Windows程序如何删除自身","path":"/post/3102005562.html","content":"本文介绍几种实现在程序退出后，从磁盘删除自身 exe 文件的方式。该技术通常应用于安装包卸载程序中。 一、借用 choice 命令实现Windows 提供了 choice 命令，允许用户从选择列表选择一个项目并返回所选项目的索引。 1234567891011121314151617181920212223242526272829303132C:\\Users\\akx&gt;choice /?CHOICE [/C choices] [/N] [/CS] [/T timeout /D choice] [/M text]描述: 该工具允许用户从选择列表选择一个项目并返回所选项目的索引。参数列表: /C choices 指定要创建的选项列表。默认列表是 &quot;YN&quot;。 /N 在提示符中隐藏选项列表。提示前面的消息得到显示， 选项依旧处于启用状态。 /CS 允许选择分大小写的选项。在默认情况下，这个工具 是不分大小写的。 /T timeout 做出默认选择之前，暂停的秒数。可接受的值是从 0 到 9999。如果指定了 0，就不会有暂停，默认选项 会得到选择。 /D choice 在 nnnn 秒之后指定默认选项。字符必须在用 /C 选 项指定的一组选择中; 同时，必须用 /T 指定 nnnn。 /M text 指定提示之前要显示的消息。如果没有指定，工具只 显示提示。示例: CHOICE /? CHOICE /C YNC /M &quot;确认请按 Y，否请按 N，或者取消请按 C。&quot; CHOICE /T 10 /C ync /CS /D y CHOICE /C ab /M &quot;选项 1 请选择 a，选项 2 请选择 b。&quot; CHOICE /C ab /N /M &quot;选项 1 请选择 a，选项 2 请选择 b。&quot; 实现方式如下： 123456789101112131415161718192021222324252627bool DeleteSelf &#123; wchar_t szSystemDir[MAX_PATH] = &#123;0&#125;; if (GetSystemDirectoryW(szSystemDir, MAX_PATH) &gt; 0) &#123; PathAddBackslashW(szSystemDir); &#125; wchar_t szFullCmd[MAX_PATH] = &#123;0&#125;; StringCchPrintfW(szFullCmd, MAX_PATH, L&quot;%scmd.exe /C choice /C Y /N /D Y /T 4 &amp; rmdir \\&quot;%s\\&quot; /Q&quot;, szSystemDir, szPath); STARTUPINFOW si = &#123;sizeof(STARTUPINFOW)&#125;; PROCESS_INFORMATION pi; if (CreateProcessW(NULL, szFullCmd, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, szSystemDir, &amp;si, &amp;pi)) &#123; if (pi.hThread) CloseHandle(pi.hThread); if (pi.hProcess) CloseHandle(pi.hProcess); return true; &#125; return false;&#125;int main() &#123; bool ret = DeleteSelf(); return 0;&#125; 二、使用计划任务实现在程序退出前添加 Windows 计划任务，计划任务在程序退出几秒后执行删除文件的操作。 这种实现方式需要程序具有管理员权限。 此处省略具体的实现方式。","tags":["计划任务","进程","choice"],"categories":["Windows编程"]},{"title":"C++标准库线程的启动与退出","path":"/post/2289160283.html","content":"本文简要介绍C++标准库提供的几种线程操作方法，主要介绍如何判断线程是否已经结束运行。 一、std::threadstd::thread 未直接提供判断线程是否结束的方法。 如果线程未进行 detach 且此时该线程处于 joinable 状态，析构该线程对象会触发异常。 线程处于 joinable 状态不代表线程正在执行，joinable 状态仅代表线程是可执行的，下面几种情况下线程会处于非 joinable 状态： 使用缺省构造函数构造的 std::thread 对象。 该线程对象的所有权已被 move 给其他对象。 该线程对象已经调用过 join 或 detach 函数。 由此可见，即便线程已经执行完成，只要未调用过 join 方法，线程仍然是 joinable 状态。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;thread&gt;std::thread Thread1() &#123; std::thread t = std::thread([]() &#123; std::this_thread::sleep_for(std::chrono::milliseconds(1000)); &#125;); return t;&#125;int main()&#123; std::thread t1 = Thread1(); t1.join(); //等待线程结束 std::thread t2 = std::thread([]() &#123; std::this_thread::sleep_for(std::chrono::milliseconds(1000)); &#125;); std::cout &lt;&lt; &quot;thread id:&quot; &lt;&lt; t2.get_id() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;joinable:&quot; &lt;&lt; t2.joinable() &lt;&lt; std::endl; // 1 t2.detach(); std::cout &lt;&lt; &quot;joinable:&quot; &lt;&lt; t2.joinable() &lt;&lt; std::endl; // 0 std::this_thread::sleep_for(std::chrono::milliseconds(2000)); return 0;&#125; 还可以通过native_handle方法获取线程的本地句柄，然后使用系统API函数来判断线程是否在运行，如： 123456if(WaitForSingleObject((HANDLE)t.native_handle(), 0) == WAIT_OBJECT_0) &#123; // Thread stopped&#125;else &#123; // Thread running&#125; 二、std::async通过std::async可以判断线程是否结束运行。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;future&gt;int main()&#123; std::future&lt;void&gt; f = std::async(std::launch::async, []() &#123; std::this_thread::sleep_for(std::chrono::milliseconds(1000)); &#125;); bool isRunning = f.valid() &amp;&amp; f.wait_for(std::chrono::milliseconds(0)) == std::future_status::timeout; std::cout &lt;&lt; isRunning &lt;&lt; std::endl; f.wait(); isRunning = f.valid() &amp;&amp; f.wait_for(std::chrono::milliseconds(0)) == std::future_status::timeout; std::cout &lt;&lt; isRunning &lt;&lt; std::endl; return 0;&#125; 2.1 判断 std::future 是否结束12bool isRunning = f.valid() &amp;&amp; f.wait_for(std::chrono::milliseconds(0)) == std::future_status::timeout; 2.2 std::shared_futurestd::future不支持赋值构造，需要使用std::shared_future。 12345std::shared_future&lt;void&gt; f1 = std::async(std::launch::async, []() &#123; std::this_thread::sleep_for(std::chrono::milliseconds(1000)); &#125;);std::shared_future&lt;void&gt; f2 = f1;","tags":["C++","多线程"],"categories":["C++语言"]},{"title":"在C++中使用Lamada表达式","path":"/post/4208014138.html","content":"Lamada 表达式是 C++11 最重要也是最常用的特性之一。Lamada 来源于函数式编程的概念，也是现代编程语言的一个特点。 一、Lamada 表达式定义下图展示出了 C++ Lamada 表示的组成部分： 其中：① 指明捕获列表。② 指明参数列表。③ mutable可选项。和常规的 mutable 用法类似，即当 lamada 表达式参数是 const 时，使用mutable可以取消这种 const。④ throw可选项。可以使用noexcept指明&#x2F;约束表达式内不会抛出异常。⑤ 指定返回类型。⑥ Lamada 函数体。 根据上图定义一个完整的 lamada 表达式： 1auto f = [](int a) noexcept -&gt; int &#123; return a + 1; &#125;; 二、返回类型很多时候 lamada 表达式的返回值类型是非常明显的，编译器可以根据return语句自动推导出返回类型，这个时候我们可以省略表达式的返回值定义： 1auto x1 = [](int a) &#123;return a + 1&#125;; // OK: return type is int 但是，初始化列表不能用于返回值的自动推导： 1auto x2 = [](int a) &#123;return &#123;a+1, a+2&#125;; &#125;; // error: 无法推导出返回值类型 三、捕获列表lamada 表达式可以通过捕获列表捕获一定范围内的变量： [] 不捕获任何变量。 [&amp;] 按引用捕获：捕获外部作用域中的所有变量，并作为引用在函数体中使用。 [=] 按值捕获：捕获外部作用域中的所有变量，并作为副本在函数体中使用。 [=, &amp;foo] 按值捕获外部作用域中的所有变量，并按引用捕获 foo 变量。 [bar] 按值捕获 bar 变量，同时不捕获其他变量。 [this] 捕获 lamada 所在的当前类中的this指针，让 lamada 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了&amp;或=，就默认添加此选项。捕获 this 的目的是可以在 lamada 中使用当前类的成员函数和成员变量。 四、异常约束可以使用noexcept来指定和约束 Lamada 表达内不会抛出异常，如果抛出异常，编译器会产生编译警告。 123456// throw_lambda_expression.cpp// compile with: /W4 /EHscint main() // 产生编译警告C4297&#123; []() noexcept &#123; throw 5; &#125;();&#125; 五、mutable正常情况下，按值捕获的变量，其值在 Lamada 表达式内是不能被修改的（遵循const-by-value），如下面的代码编译会报错： 123456 int n = 1;auto fuc = [n]() &#123; n = 2;&#125;;// error C3491: “n”: 无法在非可变 lambda 中修改通过复制捕获 可以使用mutable关键字改变这种行为： 123456int n = 1;auto fuc = [n]() mutable &#123; n = 2;&#125;;printf(&quot;%d&quot;, n); // 1 虽然在 Lamada 表达式内可以修改n的值，但n仍是按值传递，因此外部n的值没有被改变。 参考：https://msdn.microsoft.com/en-us/library/dd293608.aspx","tags":["C++","Lamada"],"categories":["C++语言"]},{"title":"NSIS教程(12)-开源UI插件","path":"/post/2584392152.html","content":"一、项目介绍介绍一个我开发的开源NSIS UI插件 NSIS-UI-Plugin，基于 NSIS-UI-Plugin 插件我们可以快速使用NSIS制作类似QQ等软件那样的安装包。 该插件默认使用Qt作为界面库（不需要编译Qt静态库，可以使用Qt动态库），但也可以很方便的切换使用其他界面库，如DuiLib等。 项目地址： https://github.com/winsoft666/NSIS-UI-Plugin 二、依赖项使用NSIS-UI-Plugin插件需要提前安装如下工具。 2.1 NSIS从https://nsis.sourceforge.io/Download 下载NSIS并安装，新增系统环境变量NSIS_DIR为NSIS安装目录。 2.2 Python之所以需要安装Python，主要是为了执行NsisScriptGenerate.py脚本。 将Python.exe所在目录添加到Path环境变量。 2.3 Qt因为插件默认使用Qt作为界面库，所以需要安装Qt。 Qt安装包会默认将安装目录添加QTDIR环境变量，如果没有自动添加，则需要手动添加。 三、开始使用3.1 编译NSIS-UI-Plugin安装完上面依赖项之后，编译NSIS-UI-Plugin\\NSIS-UI-Plugin.vcxproj工程，Visual Studio的生成后事件会自动将目标文件（Debug版：nsQtPluginD.dll， Release版：nsPlugin.dll）拷贝到NSIS插件目录（NSIS_DIR\\Plugins\\x86-unicode）。 3.2 生成安装包VimeoSetup是一个关于如何在NSIS中使用该插件的示例工程： 12345App -- 放置需要打包到安装包中的文件VCRuntimeDLL -- 放置VC++运行时库文件（Debug版和Release版），Qt界面库默认采用MD模式编译，运行时需要依赖VC++运行时库vimeo-template.nsi -- NSIS模板文件，文件名的`-template`后缀固定的，NsisScriptGenerate.py会根据该模板生成vimeo.nsibuild-setup [debug].bat -- 生成Debug版的安装包，即使用Debug版的Qt和NSIS-UI-Pluginbuild-setup [debug].bat -- 生成Release版的安装包 将需要打包的文件放置到App目录，然后运行build-setup.bat生成安装包。 NsisScriptGenerate.py脚本功能：因为NSIS没有提供获取文件释放进度的功能，所以NsisScriptGenerate.py遍历App目录，采用File命令挨个添加文件，并调用插件接口SetInstallStepDescription通知安装详情。 四、截图仅用作示例，你可以使用任意界面库来创建任意的安装&#x2F;卸载界面。","tags":["NSIS"],"categories":["NSIS"]},{"title":"Windows用户界面特权隔离(UIPI)","path":"/post/2701401097.html","content":"在早期的 Windows 操作系统中，在同一用户下运行的所有进程有着相同的安全等级，拥有相同的权限。此时进程可以自由地发送Windows 消息到其他进程的窗口。 从 Windows Vista 开始，对于某些 Windows 消息，这一方式再也行不通了，进程（或者其他的对象）开始拥有一个新的属性–特权等级(Privilege Level)。此时一个特权等级较低的进程不再可以向特权等级较高的进程发送消息，即便他们在相同的用户权限下运行也不行，这就是所谓的用户界面特权隔离(User Interface Privilege Isolation, 简称 UIPI)。 引入 UIPI 的目的是为了防止恶意程序发送消息给那些拥有较高权限的窗口，从而利用该进程的高权限达到某种目的等等。 一、UIPI 的运行机制在 Windows 7 中，当 UAC(User Account Control)启用的时候，UIPI 的运行可以得到最明显的体现。在 UAC 中，当一个管理员用户登录系统后，操作系统会创建两个令牌对象(Token Object)：一个是管理员令牌，拥有大多数特权(类似于 Windows Vista 之前的 System 中的用户)，而另一个是经过过滤后的简化版本，只拥有普通用户的权限。 默认情况下，以普通用户权限启动的进程拥有普通特权等级【UIPI 的等级划分为低等级(low)，普通(normal)，高等级(high)，系统(system)】。同样的，以管理员权限运行的进程（例如用户右键单击选择“以管理员身份运行”或者是通过添加“runas”参数调用 ShellExecute 运行的进程）拥有高(high)特权等级。 系统中会运行多种不同类型、不同特权等级的进程(当然，从技术上讲这两个进程都是在同一用户下)。我们可以使用Windows Sysinternals工具集中的Process Explorer查看各个进程的特权等级。 所以，当发现进程之间 Windows 消息通信发生问题时，不妨使用Process Explorer查看一下两个进程之间是否有合适的特权等级。 二、UIPI 所带来的限制正如我们前文所说，等级的划分，是为了防止以下犯上。所以，有了用户界面特权隔离，一个运行在较低特权等级的应用程序的行为就受到了诸多限制，它不可以进行如下操作： 验证由较高特权等级进程创建的窗口句柄 通过调用 SendMessage 和 PostMessage 向由较高特权等级进程创建的窗口发送 Windows 消息 使用线程钩子处理较高特权等级进程 使用普通钩子(SetWindowsHookEx)监视较高特权等级进程 向一个较高特权等级进程执行 DLL 注入 但是，一些特殊 Windows 消息是被容许的，因为这些消息对进程的安全性没有太大影响。这些 Windows 消息包括： 123456789101112 0x000 - WM_NULL 0x003 - WM_MOVE 0x005 - WM_SIZE 0x00D - WM_GETTEXT 0x00E - WM_GETTEXTLENGTH 0x033 - WM_GETHOTKEY 0x07F - WM_GETICON 0x305 - WM_RENDERFORMAT 0x308 - WM_DRAWCLIPBOARD 0x30D - WM_CHANGECBCHAIN 0x31A - WM_THEMECHANGED 0x313, 0x31B (WM_???) 三、修复 UIPI 问题基于 Windows Vista 之前的操作系统行为所设计的应用程序，可能希望 Windows 消息能够在进程之间自由的传递以完成一些特殊的工作。当这些应用程序在 Windows 7&#x2F;10&#x2F;11 上运行时，因为 UIPI 机制的存在，这种消息传递被阻断了，应用程序就会遇到兼容性问题。 为了解决这个问题，Windows Vista 引入了新的 API 函数ChangeWindowMessageFilter和ChangeWindowMessageFilterEx。在特权等级较高的进程中利用这 2 个函数可以添加或者删除能够通过特权等级隔离的 Windows 消息。这就像拥有较高特权等级的进程设置了一个过滤器，被允许通过的 Windows 消息都将被添加到这个过滤器的白名单，只有在这个白名单上的消息才允许传递进来。 下面对添加&#x2F;移除白名单功能进行了简单封装（UIPIMsgFilter函数），该函数可以针对特定的窗体添加、移除消息白名单： 123456789101112131415161718192021222324252627282930313233343536373839404142BOOL UIPIMsgFilter(HWND hWnd, UINT uMessageID, BOOL bAllow) &#123; OSVERSIONINFO VersionTmp; VersionTmp.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); GetVersionEx(&amp;VersionTmp); BOOL res = FALSE; if (VersionTmp.dwMajorVersion &gt;= 6) &#123; // vista above. BOOL(WINAPI * pfnChangeMessageFilterEx)(HWND, UINT, DWORD, PCHANGEFILTERSTRUCT); BOOL(WINAPI * pfnChangeMessageFilter)(UINT, DWORD); CHANGEFILTERSTRUCT filterStatus; filterStatus.cbSize = sizeof(CHANGEFILTERSTRUCT); HINSTANCE hlib = LoadLibrary(_T(&quot;user32.dll&quot;)); if (hlib != NULL) &#123; (FARPROC &amp;)pfnChangeMessageFilterEx = GetProcAddress(hlib, &quot;ChangeWindowMessageFilterEx&quot;); if (pfnChangeMessageFilterEx != NULL &amp;&amp; hWnd != NULL) &#123; res = pfnChangeMessageFilterEx(hWnd, uMessageID, (bAllow ? MSGFLT_ADD : MSGFLT_REMOVE), &amp;filterStatus); &#125; // If failed, try again. if (!res) &#123; (FARPROC &amp;)pfnChangeMessageFilter = GetProcAddress(hlib, &quot;ChangeWindowMessageFilter&quot;); if (pfnChangeMessageFilter != NULL) &#123; res = pfnChangeMessageFilter(uMessageID, (bAllow ? MSGFLT_ADD : MSGFLT_REMOVE)); &#125; &#125; &#125; if (hlib != NULL) &#123; FreeLibrary(hlib); &#125; &#125; else &#123; res = TRUE; &#125; return res;&#125; 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["UIPI"],"categories":["Windows编程"]},{"title":"Windows注册URL协议","path":"/post/1343547595.html","content":"当电脑安装完 Steam 后，我们在浏览器中访问steam://run/123，浏览器会自动提示打开 Steam 程序。类似的功能在迅雷、QQ 等产品上也都有使用，本文讲述如何实现该功能。 实现上述功能只需要在注册表HKEY_CLASSES_ROOT项下添加对应的子项即可，以注册test协议为例： 123456789101112131415Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\test]@=&quot;URL:test protocol&quot;&quot;URL Protocol&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\\test\\DefaultIcon]@=&quot;mytest.exe&quot;[HKEY_CLASSES_ROOT\\test\\Shell][HKEY_CLASSES_ROOT\\test\\Shell\\Open][HKEY_CLASSES_ROOT\\test\\Shell\\Open\\Command]@=&quot;\\&quot;D:\\\\sourcecode\\\\mytest.exe\\&quot; -- \\&quot;%1\\&quot;&quot; 修改完之后，在浏览器中输入test://start/123就可以打开D:\\\\sourcecode\\\\mytest.exe，并且传递给mytest.exe的命令行参数为test://start/123。","tags":["URL协议"],"categories":["Windows编程"]},{"title":"编译器基础概念","path":"/post/3064318708.html","content":"一、C++代码编译流程以下面 C++代码为例： 1234567#include &lt;stdio.h&gt;​int main()&#123; printf(&quot;Hello World&quot;); return 0;&#125; 编译成二进制文件需要经过如下 4 个过程： 预编译：将 hello.c 和 stdio.h 预编译为 hello.i 编译：将 hello.i 编译为 hello.s 汇编：将 hello.s 翻译为机器指令 hello.o（.o 目标文件） 链接：链接各种需要的库和其他目标文件（该 hello 程序不需要）得到可执行文件 hello.out（相当于 windows 的.exe）。 二、编译器架构编译器通常分为三个部分： 前端（FrontEnd） 优化器（Optimizer） 后端（BackEnd） 在编译过程中，前端主要负责词法和语法分析，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。 2.1 GCCGCC(GNU Compiler Collection，GNU 编译器集合)是一个完整的编译器，包含 FrontEnd、Optimizer 和 BackEnd。 2.2 LLVM 架构Clang是 LLVM 编译器架构的前端，可以用来编译 C，C++，ObjectiveC 等语言； LLVM是该架构的优化器和后端； 二者统称为 LLVM 架构。 三、编译版本选择3.1 x86、x86-64、AMD64x86 是指 Intel 的开发的一种 32 位指令集，从 386 时代开始，一直沿用至今，所有 Intel 早期的 cpu，以及 amd 早期的 cpu 都支持这种指令集。 由于AMD 领先 Intel 制造出兼容 x86 的商用 CPU，AMD 称之为 AMD64，且得到用户的认同。Intel 后面才决定设计一种不兼容 x86 的全新 64 位指令集，称之为 IA-64，由于是全新设计的 CPU，没有编译器、不支持 Windows，后来还不得不在时机落后的情况下开始支持 AMD64 指令集，因此 Intel 将 IA-64 换了个名字，叫 x86_64，表示 x86 指令集的 64 位扩展。 x86_64、x64、AMD64 实际上是一个东西，我们现在用的 intel&#x2F;amd 的桌面级 CPU 基本上都是 x86_64。 3.2 i386i386 即 Intel 80386。 其实 i386 通常被用来作为对 Intel（英特尔）32 位微处理器的统称。 但是目前更多的时候，我们公认 i386 为 32 位系统，其实就是 x86。 3.3 i686i686 仍然属于 i386 体系，不过相对于 386 CPU 的特性作了指令优化。 3.4 MSVC 编译器版本描述 x86：编译器为 x86 版本，输出文件为 x86。 amd64_x86：编译器为 amd64 版本，输出文件为 x86。 amd64：编译器为 amd64 版本，输出文件为 amd64。 x86_amd64：编译器为 x86 版本，输出文件为 amd64。","tags":["C++","LLVM","编译器","GCC"],"categories":["C++语言"]},{"title":"QWidget子类无法应用QSS样式的问题","path":"/post/10890071.html","content":"这是一个老生常谈的问题，在使用Qt进行界面开发时，我们经常会继承自QWidget来实现自定义控件（当然这里说的是非顶级窗口），此时我们发现在该自定义控件上应用QSS样式会无效。 导致这个问题的主要原因是QWidget的paintEvent函数实现为空，未做任何绘制，也没有对样式表进行初始化和绘制，其代码如下： 123void QWidget::paintEvent(QPaintEvent *)&#123;&#125; 解决这个问题也比较简单，在QWidget子类的paintEvent函数中初始化并绘制样式表： 123456void CustomWidget::paintEvent(QPaintEvent* e) &#123; QStyleOption opt; opt.init(this); QPainter p(this); style()-&gt;drawPrimitive(QStyle::PE_Widget, &amp;opt, &amp;p, this);&#125; 当然我们也可以采用变通的方法，改为继承自QFrame，因为QFrame默认初始化和绘制了样式表，其代码如下： 1234567891011121314151617void QFrame::paintEvent(QPaintEvent *)&#123; QPainter paint(this); drawFrame(&amp;paint);&#125;/*! \\internal Used by QLabel and QLCDNumber */void QFrame::drawFrame(QPainter *p)&#123; QStyleOptionFrame opt; initStyleOption(&amp;opt); style()-&gt;drawControl(QStyle::CE_ShapedFrame, &amp;opt, p, this);&#125;","tags":["Qt","QSS"],"categories":["Qt"]},{"title":"C++的API设计规范","path":"/post/128186902.html","content":"《C++ API 设计》是一本非常不错的书，该书内容远远超过了它标题所指的 C++ API 设计，它不仅仅讲述了与编程语言无关的 API 设计需要遵循的一些规范，同时也介绍了很多 C++开发中需要遵守一些准则，如果在开发中能遵循这些准则，将有利于我们写出高质量的代码。 读罢该书，受益匪浅，本文将该书中我认为比较受用的部分摘录下来。 只有两种编程语言：一种是天天挨骂的，另一种是没人用的。 良好的 API 设计的首要目标是：在为客户提供所需功能的前提下，使用新发布的 API 对客户的代码造成的影响应该最小，理想的情况下应该是零影响。 C++ 没有包私有的概念，而是使用更加宽泛的友元的概念，以允许指定的类和方法访问某个类的受保护的和私有的成员。虽然友元可以用来加强封装，但是如果使用不当，它会向用户暴露过多的内部细节。 类的数据成员应该始终声明为私有的，而不是公有的或受保护的。 类只应该定义做什么，而不是怎么做。不要将某一个功能的具体实现步骤暴露出来，即便定义为私有的，也尽量不要这样做。可以使用Pimpl技巧来将所有的私有数据成员和函数隔离到一个.cpp 文件中独立实现的类或结构体内。 不要过度承诺。当不确定是否需要某个接口时，就不要提供此接口。谨记奥卡姆（Occam）剃刀原理：若无必要，勿增实体。 谨慎添加虚函数，使用虚函数要意识到其潜在的隐患： 对基类看似无害的修改可能会给客户带来不利的影响。 客户可能会以你根本无法预料的方式来使用 API。 客户可能采用不正确的或易于出错的方式来扩展 API。 重写虚函数可能破坏类的内部原有逻辑的完整性。 使用虚函数要注意的方面： 虚函数的调用必须在运行时查虚函数表才能决定，无法在编译时决定。 使用虚函数需要维护虚函数表指针，进而增加对象的大小。 添加、重排或者移除虚函数会破坏二进制兼容性。因为虚函数调用通常用类的虚函数表的整型偏移量来表示，所以改变虚函数的顺序，或者执行可能会引起其他虚函数的顺序发送变化的操作，都需要重新编译现有代码。 如果类包含了任一虚函数，那么必须将析构函数声明为虚函数。这样子类就可以释放其可能申请的额外资源。 绝不在构造函数或析构函数中调用虚函数，这些调用不会指向之类。 Sutter 建议接口应该是非虚的，同时在适当的情况下使用模板方法设计模式。 给出清晰的、描述性强的且恰当的名字是 API 设计中最困难的任务之一。 避免编写拥有多个相同类型参数的函数。 使用一致的（统一规范）函数命令和参数顺序。 API 接口应该是平台独立的。不要将平台相关的#if或#ifdef语句放在公共的 API 中，因为这些语句暴露了实现的细节，并使 API 因平台而异。 优秀的 API 表现为松耦合和高内聚。 除非确实需要#include类的完整定义，否则应该为类使用前置声明。 通常，优秀的软件工程实践的目标是去除冗余，即确保每个重要的知识点或行为有且仅有一次实现。而代码复用意味着耦合，因此略微的增加重复以断绝过分的耦合关系有时是值得的。 《C++ API 设计》[美] Martin Reddy 著；刘晓娜，臧秀涛，林健 译","categories":["项目管理"]},{"title":"Windows内核对象","path":"/post/14744864.html","content":"一、什么是内核对象我们在 windows 开发中经常会遇到内核对象，如事件(Event)，管道(Pipe)，互斥量(Mutex)，完成端口(IOCP)，进程(Process)，线程(Thread)等，他们都是内核对象。这些内核对象虽然通过不同的系统 API 来创建，但这些 API 都有一个共同特点，就是都需要传入SECURITY_ATTRIBUTES安全描述符结构体指针，并且返回句柄(HANDLE)。依据这个特点，我们有一个简单方法来判断对象是否是内核对象，就是看创建它的函数是否允许传入SECURITY_ATTRIBUTES安全描述符。 二、内核对象的创建大多数创建内核对象的系统 API 函数，如 CreateEvent, CreateMutex, CreateThread, CreateProcess, CreatePipe, CreateNamedPipe 等都会返回一个 HANDLE（无论是以返回值的形式，还是以指针参数的形式返回），创建内核对象成功时 HANDLE 为非NULL，我们可以通过将 HANDLE 的值与 NULL 进行比较，来判断函数是否执行成功。但是有些函数比较例外，如CreateFile，这些函数执行失败时，返回的HANDLE的值为INVALID_HANDLE_VALUIE。 相关文章：由HANDLE返回值不确定性引发的思考 三、内核对象的访问虽然内核对象属于系统内核，但创建函数返回的HANDLE句柄却只和当前进程有关，离开了当前进程这个句柄也就失去了意义。内核对象属于系统内核级别，为了系统安全性，Windows 不允许我们直接访问内核对象的内存区域，只允许我们通过 Windows 提供的一系列 API 来访问内核对象，如SetEvent, ResetEvent等等，使用这些函数时我们都会用到HANDLE，windows 头文件中HANDLE的定义如下： 1typedef void *HANDLE; 虽然定义为void*类型，但很显然这个HANDLE不是指向内核对象的指针。 如何证明 HANDLE 不是指向内核对象的指针？一方面直接执行内核对象毫无安全性可言；另一方面内核对象保存在内核地址空间（32 位系统是0x80000000 到 0xFFFFFFFF，64 位系统是0x00000040 00000000到0xFFFFFFFF FFFFFFFF），我们可以调用类似CreateEvent的函数创建一个内核对象，观察其返回的 HANDLE，明显不在内核地址空间的范围内，且值一般比较小。 那么这个HANDLE句柄是如何与内核对象关联起来的了？答案是：进程的句柄表。每个进程在初始化的时候，系统都会为它分配一个句柄表(Windows 没有提供官方的文档来介绍句柄表)，参考《Windows 核心编程》得知句柄表的结构，如图： 索引 指向内核对象内存块的指针 访问掩码 标志 1 0x???????? 0x???????? 0x???????? 2 0x???????? 0x???????? 0x???????? … … … … 如我们调用类似CreateEvent的函数返回的句柄HANDLE就是句柄表中的索引。因为是索引，所以它的值一般比较小。我们向 windows API 函数传入这个索引，API 再通过索引找到对应的内核对象指针。 四、内核对象的销毁4.1 引用计数内核对象的所有者是操作系统内核，而不是创建它的进程。 多个进程可以引用（使用）同一个内核对象，操作系统使用了计数器的方式来管理内核对象（这个和 C++中的std::shared_ptr智能指针类似），一个内核对象其实有两个计数器：一个是给用户态(Ring3)用的句柄计数；另一个是指针计数，也叫引用计数，因为核心态程序(Ring0)也经常用到内核对象，为了使用方便，在核心态的代码用指针直接访问对象，所以内核对象的管理器也维护了这个指针引用计数。只有在内核对象的句柄计数和引用计数都为 0 时，该内核对象才被释放。一般而言，指针引用计数值比句柄计数值大。 4.2 正确的销毁方式当程序不再使用内核对象时，需要调用CloseHandle将内核对象的计数减 1，这样系统内核在该对象计数为 0 时（也就是没有被任何东西引用时）将销毁该对象。 并且在调用CloseHandle之后，程序还应该将HANDLE置为NULL。 如果CloseHandle之后不将HANDLE置为NULL，反而再次使用该HANDLE，就会出现 2 种情况： 进程句柄表中该HANDLE所在的索引项的记录已经被清除，且没有别的线程再次在该索引创建记录项，若此时使用这个过期的HANDLE调用 Win32 API 函数，Windows 会返回无效参数错误。这种情况还比较好调试。 进程句柄表中该HANDLE所在的索引项的记录同样也已经被清除，但已经有别的线程（该进程中的其他线程）在该索引位置创建了记录项，若此时使用这个过期的HANDLE调用 Win32 API 函数，该HANDLE就会引用到其他线程新建的那个内核对象，从而出现一些难以预料的错误。这种错误很难调试。 4.3 获取内核对象的引用计数虽然 windows 没有提供 API 让用户在用户态（Ring3）查询一个内核对象的句柄计数和引用计数，但我们可以从Ntdll.dll导出NtQueryObject函数来实现查询内核对象的当前状态(该函数没有被文档化)。 NtQueryObject函数声明如下： 123456789// 返回值：如果成功则返回0//DWORD WINAPI NtQueryObject(HANDLE handle, // 待查询的句柄DWORD nQueryIndex, // 0为查询对象的当前状态，包括句柄计数，引用计数等等。VOID* pOutBuffer, // 存放查询结果DWORD cbInBufferSize, // pOutBuffer的大小，如果nQueryIndex为0，这里为sizeof(SYSTEM_HANDLE_STATE)VOID* cbOutBufferSize // 实际大小); 将NtQueryObject函数调用的细节封装到GetKernelObjectRefCount函数中，方便使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool GetKernelObjectRefCount(HANDLE handle, DWORD &amp;handle_count, DWORD &amp;point_count) &#123; typedef struct _SYSTEM_HANDLE_STATE &#123; DWORD r1; DWORD GrantedAccess; DWORD HandleCount; // 减1为句柄计数 DWORD ReferenceCount; // 减1为指针引用计数 DWORD r5; DWORD r6; DWORD r7; DWORD r8; DWORD r9; DWORD r10; DWORD r11; DWORD r12; DWORD r13; DWORD r14; &#125;SYSTEM_HANDLE_STATE, *PSYSTEM_HANDLE_STATE; typedef DWORD(WINAPI *PFN_NtQueryObject)(HANDLE handle, DWORD nQueryIndex, VOID* pOutBuffer, DWORD cbInBufferSize, VOID* cbOutBufferSize); static PFN_NtQueryObject pfnNtQueryObject = NULL; bool ret = false; do &#123; if (pfnNtQueryObject == NULL) &#123; HMODULE ntdll = GetModuleHandle(TEXT(&quot;Ntdll.dll&quot;)); if (ntdll == NULL) break; pfnNtQueryObject = (PFN_NtQueryObject)GetProcAddress(ntdll, &quot;NtQueryObject&quot;); if (pfnNtQueryObject == NULL) break; &#125; SYSTEM_HANDLE_STATE sys_handle_state; memset(&amp;sys_handle_state, 0, sizeof(SYSTEM_HANDLE_STATE)); DWORD out_buf_size = 0; ret = (pfnNtQueryObject(handle, 0, &amp;sys_handle_state, sizeof(SYSTEM_HANDLE_STATE), &amp;out_buf_size) == 0); if (ret) &#123; handle_count = sys_handle_state.HandleCount - 1; point_count = sys_handle_state.ReferenceCount - 1; &#125; &#125; while (false); return ret;&#125; 五、内核对象跨进程访问虽然内核对象位于独立于进程之外的内核区域，我们在开发中却只能通过调用 Win32 API 传入 HANDLE 参数来操作内核对象（如SetEvent等）。然而HANDLE句柄只对当前进程有效，离开了当前进程该句柄就无效了。所以说，跨进程访问内核对象的关键在于我们怎么跨进程访问句柄HANDLE？ 下面介绍几种方法来实现跨进程共享内核对象。 5.1 使用句柄继承的方式只有进程之间有父子关系时，才可以使用句柄继承的方式。在这种情况下，父进程可以生成一个子进程，并允许子进程访问父进程的内核对象。为了使这种继承生效，父进程必须执行几个步骤：（1）. 父进程在创建一个内核对象时，父进程必须向系统指定它希望这个内核对象的句柄是可以继承的。为了创建一个可继承的内核对象，必须分配并初始化一个SECURITY_ATTRIBUTES结构，如： 123456SECURITY_ATTRIBUTES sa;sa.nLength = sizeof(SECURITY_ATTRIBUTES);sa.bInheritHandle = TRUE; // 可继承的sa.lpSecurityDescriptor = NULL;HANDLE h = CreateEvent(&amp;sa, TRUE, FALSE, NULL); （2）. 父进程通过 CreateProcess 生成子进程，且指定bInheritHandles为 TRUE，从而允许子进程来继承父进程的那些“可继承的句柄”。 1234567891011121314151617181920212223// 启动子进程TestB.exe，将句柄h作为启动参数传给进程TestB//TCHAR cmd_buf[MAX_PATH];StringCchPrintf(cmd_buf, MAX_PATH, TEXT(&quot;TestB.exe %ld&quot;), (long)h);STARTUPINFO si = &#123; sizeof(si) &#125;;PROCESS_INFORMATION pi;BOOL ret = CreateProcess( NULL, cmd_buf, NULL, NULL, TRUE, // 指定子进程可以继承父进程的“可继承句柄” 0, NULL, NULL, &amp;si, &amp;pi);CloseHandle(pi.hProcess);CloseHandle(pi.hThread); 由于我们传给bInheritHandles参数的值是TRUE，所以系统在创建子进程时会多做一件事情：它会遍历父进程的句柄表，对它的每一项进行检查，凡是包含一个有效的“可继承的句柄”的项，都会将该项完整的复制到子进程的句柄表。在子进程的句柄表中，复制项的位置与它在父进程句柄表中的位置完全一样（包含索引），这个就意味着：在父进程和子进程中，对一个内核对象进行标识的句柄值也是完全一样的。所以我们只需要通过某种方式（如上面示例中的启动参数的方式，或者环境变量的方式等任何进程间通讯的方式）将这个值告诉子进程，子进程就可以将该值转成HANDLE，然后使用这个HANDLE来调用系统 API。 5.2 使用 DuplicateHandle 方式DuplicateHandle 函数可以将指定“源进程的句柄表”中的某一项复制到“目的进程句柄表”中（除了索引），并且返回该项在目的进程句柄表中的索引（即 HADNLE）。可以在任何时候调用 DuplicateHandle 函数，DuplicateHandle 对源句柄是否是可继承的没有要求。 函数声明如下： 123456789BOOL DuplicateHandle( HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions); DuplicateHandle 详细介绍可以参考 MSDN：https://msdn.microsoft.com/en-us/library/windows/desktop/ms724251(v=vs.85).aspx DuplicateHandle 函数不能复制所有类型的句柄，只能复制如下类型的句柄（从 MSDN 复制而来）： Object Description Access token The handle is returned by the CreateRestrictedToken, DuplicateToken, DuplicateTokenEx, OpenProcessToken, or OpenThreadToken function. Change notification The handle is returned by the FindFirstChangeNotification function. Communications device The handle is returned by the CreateFile function. Console input The handle is returned by the CreateFile function when CONIN$ is specified, or by the GetStdHandle function when STD_INPUT_HANDLE is specified. Console handles can be duplicated for use only in the same process. Console screen buffer The handle is returned by the CreateFile function when CONOUT$ is specified, or by the GetStdHandle function when STD_OUTPUT_HANDLE is specified. Console handles can be duplicated for use only in the same process. Desktop The handle is returned by the GetThreadDesktop function. Event The handle is returned by the CreateEvent or OpenEvent function. File The handle is returned by the CreateFile function. File mapping The handle is returned by the CreateFileMapping function. Job The handle is returned by the CreateJobObject function. Mailslot The handle is returned by the CreateMailslot function. Mutex The handle is returned by the CreateMutex or OpenMutex function. Pipe A named pipe handle is returned by the CreateNamedPipe or CreateFile function. An anonymous pipe handle is returned by the CreatePipe function. Process The handle is returned by the CreateProcess, GetCurrentProcess, or OpenProcess function. Registry key The handle is returned by the RegCreateKey, RegCreateKeyEx, RegOpenKey, or RegOpenKeyEx function. Note that registry key handles returned by the RegConnectRegistry function cannot be used in a call to DuplicateHandle. Semaphore The handle is returned by the CreateSemaphore or OpenSemaphore function. Thread The handle is returned by the CreateProcess, CreateThread, CreateRemoteThread, or GetCurrentThread function Timer The handle is returned by the CreateWaitableTimer or OpenWaitableTimer function. Transaction The handle is returned by the CreateTransaction function. Window station The handle is returned by the GetProcessWindowStation function. 不同的事件类型对应的dwDesiredAccess参数不同，具体参考MSDN。 示例进程 TestA 源码 123456789101112131415161718192021222324252627int main(int argc, char** argv) &#123; HANDLE h = CreateEvent(NULL, TRUE, FALSE, NULL); // 启动子进程TestB.exe // TCHAR cmd_buf[MAX_PATH]; StringCchPrintf(cmd_buf, MAX_PATH, TEXT(&quot;D:\\\\TestB.exe&quot;), (long)h); STARTUPINFO si = &#123; sizeof(si) &#125;; PROCESS_INFORMATION pi; BOOL ret = CreateProcess(NULL, cmd_buf, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;pi); assert(ret); assert(pi.hProcess); HANDLE duplicated_h = NULL; ret = DuplicateHandle(GetCurrentProcess(), h, pi.hProcess, &amp;duplicated_h, 0, FALSE, DUPLICATE_SAME_ACCESS); WaitForSingleObject(pi.hProcess, INFINITE); CloseHandle(pi.hProcess); CloseHandle(pi.hThread); bool has_signal = WaitForSingleObject(h, 0) == WAIT_OBJECT_0; assert(has_signal == true); return 0;&#125; 子进程 TestB 源码 12345678910111213141516int main(int argc, char** argv)&#123; long l = 0; printf(&quot;Input Handle:&quot;); scanf(&quot;%ld&quot;, &amp;l); HANDLE h = (HANDLE)l; bool has_signal = WaitForSingleObject(h, 0) == WAIT_OBJECT_0; assert(has_signal == false); SetEvent(h); return 0;&#125; 在父进程 TestA 中创建一个不可继承的事件 -&gt; 然后启动子进程 TestB -&gt; 调用 DuplicateHandle 复制句柄项到 TestB 进程句柄表 -&gt; 并向 TestB 输入句柄值 -&gt; TestB 访问该事件句柄，将事件置为有信号状态。 5.3 使用命名的内核对象的方式5.3.1 实现原理这种方式严格的说已经不是文章开头说到的跨进程访问句柄了，有点类似跨进程直接访问内核对象了。该方式实现起来比较简单，就是在调用创建内核对象的Create***函数时，通过pszName参数为内核对象取一个名字。如创建事件 Event 的函数CreateEvent： 1234567HANDLE WINAPI CreateEvent( LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCTSTR lpName // 指定名称); 1HANDLE h = CreateEvent(NULL, TRUE, FALSE, TEXT(&quot;TestA_Obj&quot;)); 若在其他进程中要访问这个内核对象，只需要使用打开函数Open***打开该内核对象，系统就会在进程的句柄表中插入一条记录，并返回这条记录的索引，也就是句柄。需要注意的是，在打开内核对象时需要留意返回值和GetLastError函数的返回值。由于内核对象是有访问权限的，有时候虽然这个名字的内核对象存在，但该进程却不见得有权限可以打开它，这个时候GetLastError函数会返回失败的原因。 以打开事件的函数OpenEvent为例： 123456HANDLE h = OpenEvent(READ_CONTROL, FALSE, TEXT(&quot;TestA_Obj&quot;));if (h == NULL) &#123; if (GetLastError() == ERROR_ACCESS_DENIED) &#123; // 没有READ_CONTROL权限 &#125;&#125; 5.3.2 全局命令空间不同的会话（Session）有不同的内核对象命名空间（如 windows 服务程序位于Session 0，而普通的用户进程位于Session 1），要通过名称访问其他会话中的内核对象，需要在名称前面加上Session\\&lt;当前会话ID&gt;。Windows 提供了一个全局的内核对象命名空间，处于任何会话中的进程都可以访问该命名空间，将内核对象放入全局命令空间的方式很简单：只需要在内核对象名称前加入Global\\即可。 如： 1HANDLE h = CreateEvent(NULL, TRUE, FALSE, TEXT(&quot;Global\\\\TestA_Obj&quot;));","tags":["Windows","内核"],"categories":["Windows编程"]},{"title":"C++实现编译时断言","path":"/post/4155207961.html","content":"C++自 C++11 起支持 static_assert 编译时断言，如： 12static_assert ( bool_constexpr , message ) (C++11 起)static_assert ( bool_constexpr ) (C++17 起) 若编译器不支持 C++11（经测试 VS2010 已经支持static_assert），可以使用下面方式来实现编译断言： 1#define COMPILE_ASSERT(expression) switch (0) &#123;case 0: case expression:;&#125; 使用方法： 1COMPILE_ASSERT(1 != 1);","tags":["C++","断言"],"categories":["C++语言"]},{"title":"Windows注入与拦截(3)-窗口挂载","path":"/post/2804470458.html","content":"本文主要介绍如何通过 DLL 注入的方式来实现在指定窗口的控件上挂载一个自定义窗口。 何谓挂载？和舰载机挂载导弹类似，将我们自己的窗口挂到原有程序的窗口之上，可以实现对原有窗口功能的覆盖和扩展。 一、实现过程挂载的实现过程如下： 通过远程线程的方式（其他方式也可以）将 DLL 注入到指定的进程（当然是被挂载窗口所属的进程）。 在DllMain的DLL_PROCESS_ATTACH条件分支中创建一个新线程 NewThread，后面的处理逻辑将放到 NewThread 中，防止DllMain阻塞。 在 NewThread 线程中查找被挂载的窗口（注意是窗口不是窗口上的控件）的句柄（查找方式：EnumWindows结合FindWindowEx实现，详见FindProcessWindow函数）。 使用SetWindowLong修改窗体的默认的消息处理过程（假设将窗口处理过程修改为我们 DLL 中的WndProc_Trampoline函数），然后向窗体发送一个自定义消息，这时WndProc_Trampoline函数就可以获取到该消息通知，我们在收到该消息通知后就可以开始我们的挂载逻辑了。之所以要通过发送一个自定义消息的方式来做，而不是直接在新线程 NewThread 中开始我们的挂载逻辑，是因为这样做可以保证我们的挂载逻辑（如创建窗口）是在主线程中进行的。 挂载逻辑主要包含：查找需要挂载控件的句柄、创建挂载窗口。创建挂载窗口的时候要设置WS_CHILD子窗口属性，并设置父窗体的WS_CLIPCHILDREN属性来裁剪子窗口，防止我们挂载的子窗口闪烁。 在WndProc_Trampoline函数的最后不要忘记调用之前老的消息处理过程，否则原窗口的消息将无法得到正确的响应。 二、实例代码2.1 DllInjecter 工程DllInjecter.exe 实现将 DLL 注入到指定的进程之中，该 exe 是一个通用的 DLL 注入器。包含了对前面文章介绍的“使用远程线程的方式注入”和“使用钩子方式注入”这两种注入方式的实现。 2.2 Test 工程Test.exe是一个模拟的被挂载程序，程序非常简单，只包含一个窗体和大按钮，不包含任何逻辑。本实例主要是将我们的窗口挂载到这个大按钮之上。挂载前如图： 挂载后效果如图： 2.3 Troy 工程Troy.dll 就是被注入到 Test.exe 中的 DLL 文件，挂载的主要逻辑大都在该工程之中。 在WndProc_Trampoline函数的WUM_CREATE_USER_WINDOW消息处理分支中调用CreateUserWindowByDuilib函数来创建挂载窗口，CreateUserWindowByDuilib 使用duilib界面库来创建挂载窗口。 123456789LRESULT CALLBACK WndProc_Trampoline(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) &#123; switch (message) &#123; case WUM_CREATE_USER_WINDOW: CreateUserWindowByDuilib(); break; &#125; return CallWindowProc(g_oldProc, hwnd, message, wParam, lParam);&#125; 12345678910111213// 线程处理函数unsigned int __stdcall PluginProc(LPVOID pArg) &#123; MessageBox(NULL, TEXT(&quot;我已经被注入啦&quot;), TEXT(&quot;信息&quot;), MB_OK | MB_ICONASTERISK); HWND hMainWindow = InjectHelper::FindProcessWindow(GetCurrentProcessId(), TEXT(&quot;#32770&quot;), TEXT(&quot;Test&quot;), TRUE); g_oldProc = (WNDPROC)SetWindowLong(hMainWindow, DWL_DLGPROC, (LONG)WndProc_Trampoline); ::PostMessage(hMainWindow, WUM_CREATE_USER_WINDOW, 0, 0); return 0;&#125; 12345678910111213141516171819202122232425262728293031BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved) &#123; HANDLE hThread = NULL; switch(fdwReason) &#123; case DLL_PROCESS_ATTACH: &#123; g_hDllModule = hModule; // 使用注册表方式和CreateRemoteThread方式注入时，一般在此处创建线程 // hThread = (HANDLE)_beginthreadex(NULL, 0, PluginProc, NULL, 0, NULL); if (hThread) &#123; CloseHandle(hThread); // 关闭句柄，防止句柄泄漏 &#125; break; &#125; case DLL_THREAD_ATTACH: &#123; break; &#125; case DLL_THREAD_DETACH: &#123; break; &#125; case DLL_PROCESS_DETACH: &#123; break; &#125; &#125; return TRUE;&#125; 完整的示例代码见： https://github.com/winsoft666/InjectSample","categories":["HOOK"]},{"title":"理解 Visual C/C++ 运行时库","path":"/post/782629701.html","content":"运行时库（Runtime library）通俗的说就是我们的程序运行的时候所依赖的库文件。在 Windows 平台，这些库由微软提供，称之为 Visual C++ 运行时库，虽然叫 C++ 运行时库，但也包含了 C 运行时库。 这些库以两种形式被提供：静态库(lib)、动态库(lib + dll)，每个库还分别提供了 Debug 和 Release 两个版本。 一、什么是运行时库C&#x2F;C++运行时库从形式上来讲和我们自己开发的静态库、动态库没什么两样，只是它们由微软开发和维护，并提供了一些常用的功能支持（如malloc, free, printf等等），如果我们的程序需要使用这些功能（事实上，只要是 C&#x2F;C++程序就一定会用到运行时库提供的功能），就要链接 C&#x2F;C++运行时库。我们可以自主选择是链接“静态库”还是“动态库”，是链接“debug 版本”的还是“release 版本”的。 二、如何链接运行时库大家可能注意到我们在平时开发中从来没有显式的来链接这些库，这是为什么了？ 因为我们的编译器为我们提供了便利，我们只需要向编译器指定特定的编译选项（如MT、MD、MTd、MDd），编译器就会自动链接对应的库。 同时，编译器会根据MT和MD来定义相应的预处理宏：MT 对应 _MT宏，MD对应_MD宏。 例如，我们通过Visual Studio开发 C&#x2F;C++程序时，在工程属性中配置“运行库”为MT、MD、MTd、MDd中的一个： 就相当于间接的向编译器指定编译选项和定义相应的宏。 三、不同版本和形态的运行时库3.1 运行时库对应的文件下表列出各种编译选项的含义以及对应的库文件： 类型 全称 含义 对应的库文件 备注 ML Single-Threaded Release 版的单线程静态库 libc.lib 从 VS2005 起被废弃 MLd Single-Threaded Debug Debug 版的单线程静态库 libcd.lib 从 VS2005 起被废弃 MT Multi-threaded Release 版的多线程静态库 libcmt.lib MTd Multi-threaded Debug Debug 版的多线程静态库 libcmtd.lib MD Multi-threaded DLL Release 版的多线程动态库 msvcrt.lib + msvcrxxx.dll msvcprt.lib+msvcpxxx.dll MDd Multi-threaded DLL Debug Debug 版的多线程动态库 msvcrtd.lib + msvcrxxxd.dll msvcprtd.lib + msvcpxxxd.dll 如果计算机上安装了多个版本的 VC++运行环境（或者多个版本的 Visual Studio），则相同名称的 lib 或 dll 就会存在多份。如msvcrt.lib文件： 3.2 运行时库文件命名规则MSVCRT微软的C语言运行时库，以msvcr100d.dll为例： 123456ms = Microsoftv = Visualc = C Programr = Run-time100 = Versiond = Debug (不带d即为release版本) UCRT微软开发的通用C语言运行时库，从Visual Studio 2015开始使用 Universal CRT 来取代上面介绍的MSVCRT，简称 UCRT，Windows 8 及以上系统会自带该运行时库。 系统自带的运行时文件位于C:\\Windows\\System32和C:\\Windows\\SysWOW64目录。 如果安装了Windows SDK，运行时文件还会存在于如下目录： 1C:\\Program Files (x86)\\Windows Kits\\10\\Redist\\XXX.XXX.XXX.XXX\\ucrt\\DLLs MSVCP微软C++运行时库，以msvcp100d.dll为例： 12345ms = Microsoftv = Visualcp = C Plus Plus 即C++100 = Versiond = Debug (不带d即为release版本) 从 Visual Studio 2015 开始，版本号固定为140，有如下三个文件： msvcp140.dll msvcp140_1.dll (the memory_resource satellite) msvcp140_2.dll (the special math satellite) 由于微软的 STL 是开源的，因此每个文件提供的具体功能，可以参考 STL 的 CMakeLists.txt。 四、运行时库使用注意事项 不要混合使用运行时库的静态库版和动态库版。 不要混合使用运行时库的debug版和release版。 不要混合使用 Visual Studio 2013 及更早版本的运行时库，但在 Visual Studio 2015 及更高版本中提供的运行时库可以保证二进制兼容。 参考我的另外一篇文章：MSVC版本的二进制兼容性 五、Visual Studio及MSVC版本微软从1998年发布Visual C++ 6.0以来，基本上是以每2年一个IDE的速度发布新的开发平台。 Microsoft Visual C++ 编译器版本由四个字段组成： M - 主版本（两位数）N - 次要版本（两位数）B - 内部版本（五位数）R - 修订版本 Microsoft 特定的编译器宏按以下方式对这些字段进行编码： _MSC_VER &#x3D; MMNN_MSC_FULL_VER &#x3D; MMNNBBBBB_MSC_BUILD &#x3D; R IDE 发布时间 工具集版本 _MSC_VER宏 MSVC++ 系统支持 Visual C++ 6.0 1998 V60 1200 MSVC++ 6.0 XP+ Visual Studio 2002 2002 V70 1300 MSVC++ 7.0 XP+ Visual Studio 2003 2003 V71 1310 MSVC++ 7.1 XP+ Visual Studio 2005 2005 V80 1400 MSVC++ 8.0 XP+ Visual Studio 2008 2008 V90 1500 MSVC++ 9.0 XP+ Visual Studio 2010 2010 V100 1600 MSVC++ 10.0 XP+ Visual Studio 2012 2012 V110 1700 MSVC++ 11.0 XP+ Visual Studio 2013 2013 V120 1800 MSVC++ 12.0 Win7+ Visual Studio 2015 2015 V140 1900 MSVC++ 14.0 Win7+ Visual Studio 2017 2017 V141 1910 ~ 1916 MSVC++ 14.1 Win7+ Visual Studio 2019 2019 V142 1920 ~ 1929 MSVC++ 14.2 Win7+ Visual Studio 2022 2022 V143 1930 ~ 1942 (随着升级可能还会增加) MSVC++ 14.3 Win7+ 参考：Microsoft Visual C++ compiler versioning 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["运行时库","MSVC"],"categories":["C++语言"]},{"title":"Windows注入与拦截(2)-注入方式","path":"/post/721636578.html","content":"一、注册表方式1.1 注入方法如题，通过注册表的方式来实现 DLL 注入，我们只需要针对特定的注册表项进行修改即可，有一点需要注意的是：如果被注入的进程是 64 位进程，则注入的 DLL 也需要是 64 位的。同理，注入到 32 位的进程也需要是 32 位的 DLL。 另外，根据被注入目标进程的位数（32 或 64）不同，注册表的位置也不同。 1.1.1 注入 64 位系统上的 32 位进程在64位Windows系统上，将DLL注入到32位进程，步骤如下： 将被注入的 DLL 名称填入到AppInit_DLLs注册表项： 1HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\AppInit_DLLs AppInit_DLLs中的文件名通过逗号或空格来分割，在文件名中要避免使用空格。 另外AppInit_DLLs中的第一个文件可以包含路径，而后面的文件的路径则将被忽略。出于这个原因，我们最好将 DLL 文件放到 Windows 的系统目录中。 并将LoadAppInit_DLLs注册表项的值修改为1： 1HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\LoadAppInit_DLLs 1.1.2 注入 64 位进程在64位Windows系统上，将DLL注入到64位进程，步骤与“注入 64 位系统上的 32 位进程”类似，区别在于： 注册表位置不一样，注入 64 位进程的注册表分别位于： 123HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\AppInit_DLLsHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\LoadAppInit_DLLs 被注入 DLL 需要是 64 位版本。 1.2 原理为什么可以通过上述方式实现DLL注入呢？ 当系统的User32.dll被加载到新进程时，会在DLL_PROCESS_ATTACH通知处理过程中读取AppInit_DLLs注册表值，并依次加载该项中的每个 DLL。 1.3 弊端这么做有什么弊端？ 依据上面一节的介绍，我们可以知道被注入的 DLL 是通过 User32.dll 加载到目标进程中去的，这也就要求被注入的目标进程必须使用了 User32.dll，虽然基于 GUI 的程序都会使用这个 DLL 文件，但命令行程序一般不会加载 User32.dll，所以可能无法通过这种方式被注入。 而且这种方式会导致系统上所有使用了 User32.dll 的程序都会被注入DLL，很多时候这也并不是我们所期望的。 二、消息钩子方式2.1 钩子技术Windows 提供了三个 API 让我们可以很方便使用钩子技术将 DLL 文件注入到进程之中： 1234567891011121314151617// 安装指定消息类型的钩子到钩子链中HHOOK SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId);// 从钩子链中删除钩子BOOL UnhookWindowsHookEx(HHOOK hhk);// 将消息转发到钩子链上的下一个钩子LRESULT CallNextHookEx(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam); Hook中文名“钩子”，我们可以把它想象成一个“鱼钩”，用来钩住指定类型的消息。我们可以指定“钩子”需要钩住哪个线程的消息，可以是当前线程，也可以是所有线程。 当“指定线程”的“指定消息”被钩住时，系统就会将我们的 DLL（如果钩子的处理过程位于 DLL 中）加载到该线程所属进程的地址空间中，并且在该地址空间中调用我们的 DLL 中的钩子处理过程函数，从而实现注入功能。 我们通过SetWindowsHookEx函数来安装一个钩子，操作系统同时也允许开发人员为“同一个线程”的“同一个消息类型”指定多个钩子，这样就形成了一个“钩子链”（Hook Chain）。 2.1.1 SetWindowsHookEx123456HHOOK SetWindowsHookExA( [in] int idHook, [in] HOOKPROC lpfn, [in] HINSTANCE hmod, [in] DWORD dwThreadId); idHook参数：指定我们需要勾住的消息类型； lpfn参数：函数指针。当 idHook 指定的消息触发时，系统将会调用 lpfn 函数指针。 hMod参数：lpfn 函数指针所在 DLL 的句柄。有 2 种情况下这个参数需要传 NULL： lpfn 函数的代码位于本进程内时。 只需要勾住本进程的消息时，即 dwThreadId 参数指定的线程位于当前进程。 dwThreadId参数：线程 ID，用于指定勾住哪个线程的消息。如果传 0，则表示勾住所有线程的指定消息。 SetWindowsHookEx 详细的参数解释可以参考 MSDN。 2.1.2 CallNextHookEx当我们的钩子处理函数（由lpfn参数指定）将消息处理完之后，我们可以选择将消息丢弃，不让钩子链后面的钩子进行处理；也可以在钩子处理函数的最后调用CallNextHookEx函数，让消息继续传递下去，从而让其他钩子有处理的机会。 2.1.3 UnhookWindowsHookExUnhookWindowsHookEx函数用于将指定钩子从钩子链中移除。 即使不调用UnhookWindowsHookEx，在调用SetWindowsHookEx的进程退出后，钩子也将被自动移除。 2.2 钩子实例SetWindowsHookEx函数返回一个HHOOK类型的钩子句柄，CallNextHookEx和UnhookWindowsHookEx函数都需要使用这个句柄作为参数。 如果我们将“注入逻辑”放在独立的 exe 中，将“钩子处理过程”放到独立的 dll 中，那么为了在“钩子处理过程”中调用CallNextHookEx时能够拿到钩子的句柄，我们需要通过其他途径将该句柄从 exe 传递到 dll 中。 所以为了避免传递“钩子句柄”的麻烦，我们将“注入逻辑”和“钩子处理过程”都写入到一个 DLL 之中。我们只需要调用这个 DLL 的导出函数就可以将这个 DLL 注入到指定线程所属的进程中。 示例 DLL 名称为InjectDLL，用于勾住指定窗口的WH_GETMESSAGE消息，我们也可以指定其他的消息类型，如键盘消息等。完整的消息类型可以参考 MSDN 上关于SetWindowsHookEx函数的解释。 InjectDLL示例完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;tchar.h&gt;HHOOK g_hook = NULL;BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved) &#123; switch(fdwReason) &#123; case DLL_PROCESS_ATTACH: &#123; break; &#125; case DLL_THREAD_ATTACH: &#123; break; &#125; case DLL_THREAD_DETACH: &#123; break; &#125; case DLL_PROCESS_DETACH: &#123; break; &#125; &#125; return TRUE;&#125;// 提权函数// 参考：https://blog.csdn.net/china_jeffery/article/details/79173417//BOOL EnablePrivilege(LPCTSTR szPrivilege, BOOL fEnable) &#123; BOOL fOk = FALSE; HANDLE hToken = NULL; if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) &#123; TOKEN_PRIVILEGES tp; tp.PrivilegeCount = 1; LookupPrivilegeValue(NULL, szPrivilege, &amp;tp.Privileges[0].Luid); tp.Privileges-&gt;Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0; AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL); fOk = (GetLastError() == ERROR_SUCCESS); CloseHandle(hToken); &#125; return fOk;&#125;// 钩子处理过程LRESULT CALLBACK HookProc_GetMsg(int code, WPARAM wParam, LPARAM lParam) &#123; char szMsg[512] = &#123; 0 &#125;; sprintf_s(szMsg, 512, &quot;code: %d, wParam: %d, lParam: %d&quot;, code, wParam, lParam); OutputDebugStringA(szMsg); return CallNextHookEx(g_hook, code, wParam, lParam);;&#125;// 导出函数，安装钩子HHOOK InjectDllByHook(HWND hwnd) &#123; DWORD dwThreadId = 0; HHOOK hHook = NULL; __try &#123; if (!EnablePrivilege(SE_DEBUG_NAME, TRUE)) &#123; __leave; &#125; // 通过窗口句柄获取到窗口所属线程 dwThreadId = GetWindowThreadProcessId(hwnd, NULL); if (dwThreadId == 0) &#123; __leave; &#125; // 获取DLL自身的句柄 HMODULE hModule = NULL; GetModuleHandleExW( GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, (LPCWSTR)InjectDllByHook, &amp;hModule); hHook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)HookProc_GetMsg, hModule, dwThreadId); &#125; __finally &#123; &#125; return (hHook);&#125;// 导出函数，卸载钩子BOOL EjectDllByHook(HHOOK hook) &#123; return UnhookWindowsHookEx(hook);&#125; 直接调用该 DLL 的导出函数InjectDllByHook，实现安装钩子并Hook指定窗口的指定消息。当指定窗口消息被勾住时，我们的 DLL 也就会被加载到了窗口所属的进程地址空间中，从而实现注入。 三、远程线程方式3.1 远程线程原理“注册表注入方式”由于不能精确指定需要注入的目标进程，而且只能注入到 GUI 程序中，灵活性较差； “钩子注入方式”虽然能够精确指定被注入的目标线程，但只能针对特定类型的窗口消息进行 Hook，对于类似 Windows 服务这样的非GUI程序就束手无策了。 本节介绍的“远程线程的注入方式”是在实际中使用较为广泛的一种注入方式，它既可以精确指定需要注入的进程，又可以注入到非 GUI 程序中。 远程线程注入方式使用的关键系统 API 为CreateRemoteThread，原型如下： 123456789HANDLE WINAPI CreateRemoteThread( _In_ HANDLE hProcess, _In_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_ LPDWORD lpThreadId); CreateRemoteThread的参数和我们平时创建本地线程使用的CreateThread的参数类似，新增了hProcess句柄参数用于指定在哪个进程创建远程线程，通过OpenProcess可以获取到进程句柄，但需要注意权限问题，可能由于权限不足，获取进程句柄失败。 通过远程线程方式实现 DLL 注入主要是在lpStartAddress和lpParameter这 2 个参数上面做文章。 lpStartAddress参数是函数指针类型，为远程线程的处理过程函数，函数原型分别如下： 1DWORD WINAPI ThreadProc(LPVOID lpParameter); 我们知道加载 DLL 使用的 API 是LoadLibraryA或LoadLibraryW，原型如下： 1HMODULE WINAPI LoadLibrary(LPCTSTR lpFileName); 对比LoadLibrary和线程处理函数(LPTHREAD_START_ROUTINE)的原型，不难发现两者的函数的原型基本相同。虽然不是完全相同，但都是接收一个指针参数，而且都是返回一个值，并且调用约定也都是WINAPI。 因此，我们完全可以利用它们之间的相似性，把线程处理函数的地址设为LoadLibraryA或LoadLibraryW，如： 12345678HANDLE hThread = CreateRemoteThread(hProcessRemote, NULL, 0, LoadLibraryA, &quot;C:\\\\InjectDll.dll&quot;, 0, NULL); 当CreateRemoteThread所创建的线程在远程进程地址空间中被创建的时候，就会立即调用LoadLibraryA函数，并传入 DLL 路径的地址作为其参数，从而实现DLL加载。但这还没完，请继续看下面章节。 3.2 注意事项按照上面的介绍的方法很容易就能实现远程线程注入，实际上也的确是很容易实现，只是还有几个地方需要注意： LoadLibrary 函数地址 DLL 路径字符串地址 取消注入 LoadLibrary 函数地址我们不能向上面的代码那样直接把LoadLibraryA或LoadLibraryW作为第 4 个参数传给CreateRemoteThread函数。这涉及模块的导入段等问题，如果在调用CreateRemoteThread时直接引用LoadLibraryA函数地址，该引用会被解析为我们被注入 DLL 的导入段中的LoadLibraryA函数地址，如果把这个函数地址作为远程线程的起始地址传入，其结果很可能是访问违规。 我们必须通过 GetProcAddress 来得到LoadLibraryA的确切地址，如： 12HMODULE hKernel32 = GetModuleHandle(TEXT(&quot;kernel32.dll&quot;));LPVOID pLoadLibraryAAddr = (LPVOID)GetProcAddress(hKernel32, &quot;LoadLibraryA&quot;); DLL 路径字符串地址DLL 路径字符串&quot;C:\\\\InjectDll.dll&quot;的内存地址位于调用进程的地址空间中，并不位于被注入的进程的地址空间中。所以，当LoadLibraryA用该地址访问被注入进程地址空间时，会导致访问违规。 如果对进程的地址空间不了解，可以参考：系列文章。 为了解决这个问题，我们需要把 DLL 的路径字符串存储到被注入进程的地址空间中。Windows 提供的VirtualAllocEx函数可以实现在其他进程的地址空间中分配内存块，实现过程大致如下： 123456789101112131415161718192021222324// dwProcessID为被注入目标进程的进程IDhTargeProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID);if (!hTargeProcess) &#123; return;&#125;SIZE_T dllPathSize = strlen(pszDllPath); // pszDllPath存储了DLL的路径pVM4DllPath = VirtualAllocEx(hTargeProcess, NULL, dllPathSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);if (!pVM4DllPath) &#123; return;&#125;if (!WriteProcessMemory(hTargeProcess, pVM4DllPath, pszDllPath, dllPathSize, NULL)) &#123; return;&#125; 取消注入取消注入就是将 DLL 从目标进程卸载，卸载 DLL 所用的 API 是FreeLibrary，但我们不能直接调用这个函数，因为直接调用的话是在我们的进程中卸载 DLL，而不是目标进程中卸载，很显然这样达不到卸载的目的。我们需要和加载 DLL 时一样，将FreeLibrary的地址作为第 4 个参数传给CreateRemoteThread函数，但同样需要通过GetProcAddress来得到FreeLibrary的确切地址： 1234PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32&quot;)), &quot;FreeLibrary&quot;);if(pfnThreadRtn) &#123; hThread = CreateRemoteThread(hProcess, NULL, 0, pfnThreadRtn, me.modBaseAddr, 0, NULL);&#125; 3.3 实例本实例中的InjectDllByRemoteThread和EjectDllByRemoteThread两个函数使用远程线程的方式分别实现了注入和取消注入的功能。 3.3.1 InjectDllByRemoteThread 函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859BOOL InjectDllByRemoteThread(DWORD dwProcessID, const char* pszDllPath) &#123; BOOL bRet = FALSE; const DWORD dwThreadSize = 50 * 1024; HANDLE hTargeProcess = NULL; HANDLE hRemoteThread = NULL; PVOID pVM4LoadLibrary = NULL; PVOID pVM4DllPath = NULL; __try &#123; if (!EnablePrivilege(SE_DEBUG_NAME, TRUE)) &#123; __leave; &#125; hTargeProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID); if (!hTargeProcess) &#123; __leave; &#125; SIZE_T dllPathSize = strlen(pszDllPath); pVM4DllPath = VirtualAllocEx(hTargeProcess, NULL, dllPathSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (!pVM4DllPath) &#123; __leave; &#125; if (!WriteProcessMemory(hTargeProcess, pVM4DllPath, pszDllPath, dllPathSize, NULL)) &#123; __leave; &#125; HMODULE hKernel32 = GetModuleHandle(TEXT(&quot;kernel32.dll&quot;)); LPVOID pLoadLibraryAAddr = (LPVOID)GetProcAddress(hKernel32, &quot;LoadLibraryA&quot;); hRemoteThread = CreateRemoteThread(hTargeProcess, NULL, 0, (DWORD(WINAPI *)(LPVOID))pLoadLibraryAAddr, pVM4DllPath, 0, NULL); if (!hRemoteThread) &#123; __leave; &#125; WaitForSingleObject(hRemoteThread, INFINITE); DWORD dwExitCode = 0; BOOL B = GetExitCodeThread(hRemoteThread, &amp;dwExitCode); bRet = TRUE; &#125; __finally &#123; if (hTargeProcess &amp;&amp; pVM4DllPath) &#123; VirtualFreeEx(hTargeProcess, pVM4DllPath, dwThreadSize, MEM_RELEASE); &#125; if (hRemoteThread) &#123; CloseHandle(hRemoteThread); &#125; if (hTargeProcess) &#123; CloseHandle(hTargeProcess); &#125; &#125; return bRet;&#125; 3.3.2 EjectDllByRemoteThread 函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162BOOL EjectDllByRemoteThread(DWORD dwProcessID, LPCWSTR pszDllPath) &#123; BOOL bOk = FALSE; HANDLE hTHSnapshot = NULL; HANDLE hProcess = NULL, hThread = NULL; __try &#123; hTHSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwProcessID); if(hTHSnapshot == INVALID_HANDLE_VALUE) &#123; __leave; &#125; MODULEENTRY32W me = &#123;sizeof(me)&#125;; BOOL bFound = FALSE; BOOL bMoreMods = Module32FirstW(hTHSnapshot, &amp;me); for(; bMoreMods; bMoreMods = Module32NextW(hTHSnapshot, &amp;me)) &#123; bFound = (_wcsicmp(me.szModule, pszDllPath) == 0) || (_wcsicmp(me.szExePath, pszDllPath) == 0); if(bFound) break; &#125; if(!bFound) &#123; __leave; &#125; hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION, // For CreateRemoteThread FALSE, dwProcessID); if(hProcess == NULL) &#123; __leave; &#125; PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32&quot;)), &quot;FreeLibrary&quot;); if(pfnThreadRtn == NULL) &#123; __leave; &#125; hThread = CreateRemoteThread(hProcess, NULL, 0, pfnThreadRtn, me.modBaseAddr, 0, NULL); if(hThread == NULL) &#123; __leave; &#125; WaitForSingleObject(hThread, INFINITE); bOk = TRUE; &#125; __finally &#123; if(hTHSnapshot != NULL) &#123; CloseHandle(hTHSnapshot); &#125; if(hThread != NULL) &#123; CloseHandle(hThread); &#125; if(hProcess != NULL) &#123; CloseHandle(hProcess); &#125; &#125; return(bOk);&#125; 3.3.3 DllMain 函数使用远程线程的方式进行 DLL 注入时，我们一般在 DllMain 的DLL_PROCESS_ATTACH条件分支开始业务逻辑（通常会另外创建一个子线程，将业务逻辑放到子线程中处理），在DLL_PROCESS_DETACH条件分支处结束业务逻辑。 123456789101112131415161718192021222324252627282930313233BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved) &#123; HANDLE hThread = NULL; switch(fdwReason) &#123; case DLL_PROCESS_ATTACH: &#123; g_hDllModule = hModule; // 使用注册表方式和CreateRemoteThread方式注入时，一般在此处创建线程 // hThread = (HANDLE)_beginthreadex(NULL, 0, PluginProc, NULL, 0, NULL); if (hThread) &#123; CloseHandle(hThread); // 关闭句柄，防止句柄泄漏 &#125; break; &#125; case DLL_THREAD_ATTACH: &#123; break; &#125; case DLL_THREAD_DETACH: &#123; break; &#125; case DLL_PROCESS_DETACH: &#123; // 结束业务逻辑 // ...... break; &#125; &#125; return TRUE;&#125; 四、APC方式TODO","tags":["DLL","消息钩子","远程线程","APC"],"categories":["HOOK"]},{"title":"Windows注入与拦截(1)-注入基础","path":"/post/1504192511.html","content":"一、注入技术的用途从Windows内存体系(1)--虚拟地址空间文章中我们可以知道： 在 Windows 系统中，每个进程都有自己私有的地址空间。当我们用指针来引用内存时，指针的值表示的是进程自己的地址空间的一个虚拟的内存地址。进程不能通过指针来引用其他进程地址空间的内存。 这种设计提升了操作系统的健壮性和安全性，比如一个进程存在缺陷，可能会引用和覆盖随机地址处的内存数据，那么我们就不用担心这个缺陷会影响到操作系统及其他进程。 独立的地址空间有利于系统的稳定性。但也带来了诸多不便，下面列举了需要跨越进程的边界来访问另一个进程地址空间的情况： 我们要从另一个进程创建的窗口来派生子类窗口，比如附着在 Windows 资源管理器上的一些小插件等。 我们需要假借其他进程之名做某些事情。 我们需要获取其他进程的更多详细信息，如加载了哪些 dll 等。 我们需要对其他进程的某些函数进行HOOK。 以及干一些羞羞的事情… 为了满足上述需求，我们可以使用 DLL 注入的技术，将我们自己开发的 DLL 注入到另一个进程的地址空间中，这样 DLL 中的代码就可以在该进程地址空间中执行。 二、什么样的 DLL 可以被注入理论上任何 DLL 都可以被注入到其他进程之中，但是大多数情况下，我们注入到其他进程之中是为了实现某些功能、做某些事情的，所以我们需要在 DLL 被注入之后，DLL 中的功能代码能够被自动执行。 DLL 被首次载入到进程中时，会收到DLL_PROCESS_ATTACH通知，即调用DllMain函数，并且参数fdwReason的值被设为DLL_PROCESS_ATTACH。 我们可以在收到DLL_PROCESS_ATTACH通知时开始我们的业务逻辑。 下面是一个最简单的 dll 的源码，在被注入成功后（即收到DLL_PROCESS_ATTACH通知时）弹出消息提示框： 12345678910111213141516171819202122BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved ) &#123; switch(fdwReason) &#123; case DLL_PROCESS_ATTACH: &#123; MessageBox(NULL, TEXT(&quot;我已经被注入啦&quot;), TEXT(&quot;信息&quot;), MB_ICONINFORMATION); break; &#125; case DLL_THREAD_ATTACH: &#123; break; &#125; case DLL_THREAD_DETACH: &#123; break; &#125; case DLL_PROCESS_DETACH: &#123; break; &#125; &#125; return TRUE;&#125; 另外，当 DLL 被从目标进程卸载时，DLL 会收到DLL_PROCESS_DETACH通知，我们可以在该通知的处理过程中做最后的善后工作，防止出现资源泄漏、程序崩溃等问题。","categories":["HOOK"]},{"title":"了解DPI缩放","path":"/post/50218900.html","content":"dpi 是“Dots Per Inch”的缩写，表示每英寸的像素点个数，也就是像素点的密集度。 dpi不是用来表示屏幕分辨率的，也不是用来表示屏幕物理尺寸的。 dpi = 总像素点 / 物理面积 比如一个 32 寸的显示，但分辨率只有1920*1440，而一个 24 寸的显示器，分辨率却达到3840*2160，很明显后面这个显示器的每英寸的像素点的个数多，显示的画面更加细腻。所以：高分辨率不等于高 dpi。 苹果的视网膜屏幕的核心就是高 dpi：屏幕物理面积小，而分辨率高达 5k，每英寸的像素点（dpi）固然多，画面自然细腻。 软件显示异常为什么高 DPI 显示器会导致某些软件显示异常了？ 随着 2K、4K 显示器的普及，在使用这些高 DPI 显示器时，我们为了使软件界面看起来不至于太小，导致视觉疲劳，一般会在系统中设置缩放比例。 Windows 操作系统对高 dpi 显示器缩放支持最好的是 windows 10+，建议在使用高 DPI 显示器时搭配 Windows 10+操作系统。 假设现有一个软件，其界面宽 950 像素，高 700 像素，该软件在 24 寸、分辨率为1900*1400的显示器上显示正常，但放到高 dpi 显示器（同样是 24 寸，但分辨率为3800*2800）上显示效果会如何？ 从上图可以看到，同样尺寸的软件界面，在高 dpi 显示器上会显得非常小，会对使用者会造成严重的视觉疲劳。 所以我们的软件需要针对高 dpi 进行适配和缩放，从而发挥出高dpi显示器的优势，让界面显示更加清晰和细腻。 目前大多数客户端框架（如Qt、Electron、WPF、WinForm）都已经能很好的支持dpi缩放了，不需要开发人员花费经历去处理这些事情。 Windows 10+系统的DPI缩放规则Windows 10+操作系统针对 dpi 缩放制定了 3 种规则，每个进程都必须匹配下面的一种规则，默认为PROCESS_DPI_UNAWARE： PROCESS_DPI_UNAWARE在软件启动时， 操作系统会自动将软件进行缩放拉伸；在系统 dpi 缩放改变时，系统也会将软件自动进行缩放拉伸，但软件不会收到 WM_DPICHANGED 消息。 PROCESS_SYSTEM_DPI_AWARE在软件启动时，系统不会将软件进行缩放拉伸；但在系统 dpi 缩放改变时，系统会将软件进行缩放拉伸，但软件仍然不会收到 WM_DPICHANGED 消息。 PROCESS_PER_MONITOR_DPI_AWARE在软件启动时，系统不会将软件进行缩放拉伸；同样，在系统 dpi 缩放改变时，系统也不会将软件进行缩放拉伸，但软件会收到 WM_DPICHANGED 消息。 详见：dpi_awareness","tags":["DPI"],"categories":["Windows编程"]},{"title":"图形编程扫盲","path":"/post/1919525700.html","content":"一、常见图形编程接口我们常见的图形编程接口主要分为如下派系： OpenGL DirectX Vulkan Metal 下图展示了各个派系的分支及特点： 二、ANGLEANGLE （全称 Almost Native Graphics Layer Engine）是Google发起的开源项目，主要用在 Chromium 项目里面，Google创建这个项目是为了让WebGL能够间接调用硬件平台支持的图形API，如Windows平台上调用DirectX图形接口。 目前ANGLE支持Windows, Mac, Linux, iOS和Android平台。 WebGL基于OpenGL ES开发，而在Windows系统上默认只安装了OpenGL 1.1驱动程序，如果用户没有升级更新的OpenGL驱动，则网页中的WebGL将只能使用软件渲染（即CPU绘制图形），显然这种方式无法利用显卡GPU的优势，图形渲染性能和效果都不好。为了改版这个现状，Google公司开发了ANGLE项目。 例如在Windows平台，ANGLE项目通过将DirectX接口进行二次封装，封装后的接口与OpenGL ES接口非常类似，这样当程序代码调用ANGLE提供的类OpenGL ES接口时，ANGLE就可以在内部判断是调用OpenGL接口还是调用DirectX接口，从而实现了当用户系统上没用安装OpenGL驱动时，自动使用合适的DirectX绘制接口。 项目地址：https://github.com/google/angle 三、EGLEGL 是 OpenGL ES 和本地窗口系统（Native Window System）之间的通信接口，OpenGL ES 的平台无关性正是借助 EGL 实现的，EGL 屏蔽了不同平台的差异（Apple 提供了自己的 EGL API 的 iOS 实现，自称 EAGL）。 我们通常在安装目录看到的libEGL.dll和libGLESv2.dll文件就是EGL在Windows平台的实现。WebGL基于OpenGL ES实现，所以使用了WebGL和OpenGL ES的程序都会带上这2个文件。","tags":["OpenGL","DirectX","ANGLE"],"categories":["编程基础"]},{"title":"基于Joplin和WebDAV搭建私有云笔记","path":"/post/2173106656.html","content":"一、私有Docker搭建WebDAV服务从我的Github上下载WebDAV的Docker配置文件： 1git clone https://github.com/winsoft666/docker-webdev 根据docker-compose.yml.sample文件来新建docker-compose.yml文件： 1cp docker-compose.yml.sample docker-compose.yml 修改docker-compose.yml文件中的相应字段： 123456789101112131415version: &#x27;3&#x27;services: webdav: build: . restart: always ports: - &quot;9443:443&quot; - &quot;9080:80&quot; environment: SERVER_NAME: www.xxx.com,xxx.com AUTH_TYPE: Basic SSL_CERT: selfsigned volumes: - /webdav-server:/var/lib/dav - /root/webdav/user.passwd:/user.passwd 字段含义如下： ports为容器和宿主机器的端口映射，冒号前面的端口可以自定义； SERVER_NAME为服务器绑定的域名，如果没有绑定域名，可以直接写服务器的外网IP。 Joplin只支持Basic验证模式； /root/webdav/user.passwd为WebDAV的用户名和密码存储文件，存在在宿主机器上，通过映射的方式映射到容器中，生成步骤如下： 123456# 在CentOS7系统上安装httpdyum -y install httpdcd /root/webdav/touch user.passwdhtpasswd -B user.passwd zhanghua 在docker-compose.yml文件所在目录，执行： 1docker-compose up -d 上面命令会部署并启动WebDAV服务。 二、测试WebDAV服务在浏览器中打开http://xxx.com:9080，会弹出用户名和密码输入框，输入使用htpasswd 命令创建的用户和密码，点击登录，如果可以登录进去，说明服务搭建成功。 三、新建Joplin数据目录在宿主机器的/webdav-server/data目录下，新建子目录joplin。因为/webdav-server/目录已经映射到容器中，所以容器可以直接访问。 重启Docker： 123docker ps -a # 查看容器IDdocker stop XXXdocker start XXX 从Joplin官网（https://joplinapp.org/）下载Joplin客户端，在“同步”选项中设置WebDAV，如图所示： 设置完成之后，点击“检查同步配置”，提示“成功”则说明配置正确。","tags":["Joplin","WebDAV"],"categories":["爱折腾"]},{"title":"NSIS教程(11)-中文手册","path":"/post/2948643539.html","content":"这这里分享几个我一直使用的NSIS中文手册： 《NSIS用户手册 中文版》 NSIS官方英文的手册上的机器翻译版本，有些地方翻译可能不太纯正。 《NSIS图文教程集锦 - 轻狂志》 里面有很多基于NSIS的安装包示例，大多数与NSIS有关的功能，都可以在这个文档找到线索。 上述文档下载地址：https://github.com/winsoft666/NSIS-Chinese-Doc","tags":["NSIS"],"categories":["NSIS"]},{"title":"NSIS教程(10)-MUI跳过指定安装步骤","path":"/post/1597634702.html","content":"在正常情况下安装包会有“欢迎界面”、“安装目录选择界面”等等，有时我们需要安装包自动跳过这 2 个界面，如安装包通过命令行参数传入“安装目录”（如setup.exe /installdir F:\\test），本文讲述如何使安装包跳过指定的界面。 HOW TO DO?在页面插入宏之前通过MUI_PAGE_CUSTOMFUNCTION_PRE来指定 pre 处理函数，在该函数中来判断是否需要跳过： 12345678# 安装程序欢迎页面!define MUI_PAGE_CUSTOMFUNCTION_PRE SkipPage!insertmacro MUI_PAGE_WELCOME# 安装程序显示安装目录选择页面!define MUI_PAGE_CUSTOMFUNCTION_PRE SkipPage!insertmacro MUI_PAGE_DIRECTORY SkipPage函数定义如下： 123456Function SkipPage StrLen $R1 $paramInstllDir $&#123;If&#125; $R1 &gt; 0 Abort $&#123;EndIf&#125;FunctionEnd 获取命令行参数存入$paramInstllDir变量，并解析命令行参数： 12345678910!macro ParseParameters $&#123;GetParameters&#125; $R0 $&#123;GetOptions&#125; $R0 &#x27;/installdir&#x27; $R1 StrCpy $paramInstllDir $R1 StrLen $R1 $paramInstllDir $&#123;If&#125; $R1 &gt; 0 StrCpy $INSTDIR $paramInstllDir $&#123;EndIf&#125;!macroend","tags":["NSIS"],"categories":["NSIS"]},{"title":"NSIS教程(9)-使用界面库制作安装界面","path":"/post/100006247.html","content":"前面的几篇文章介绍了 NSIS 的传统界面的安装包和现代界面的安装包的制作方法，也提到了 NSIS 支持自定义页面（即使用page custom）的特性，自定义页面需要用户自己创建对话框、控件、添加控件响应等等，虽然 NSIS 提供了nsDialogs.nsh来支持这些功能，但使用起来还是不太方便（需要专门了解这个插件诸多用法），而且不够灵活，所以本文介绍一种终极的自定义界面的安装包解决方案，即完全使用第三方界面库来绘制安装包界面。 该方案是对界面库没有限制的，可以使用其他任何界面库，如 MFC, Qt，WTL 等。通过这种方案可以很轻松的实现类似金山毒霸、QQ、360 安全卫士等软件的安装包界面。 一、原理NSIS 自定义页面的语法： 1page custom [创建函数] [离开函数] [标题] 使用第三方界面库完全定制安装包界面的基本原理就是：新建一个 dll 插件，在page custom的[创建函数]中调用该插件中的函数来显示界面，这时界面上的按钮的响应就不再由 NSIS 控制了，完全由我们的代码控制。 二、难点问题使用我们的插件 dll 完全替代 NSIS 界面之后，有几个问题需要解决： 如何获取安装和卸载的进度 如何从 C++回调 NSIS 函数 2.1 安装和卸载进度NSIS 中的安装和卸载进度由!insertmacro MUI_PAGE_INSTFILES或Page instfiles提供。 在完全使用自己的界面之后，这 2 个 NSIS 界面都不能使用了，这时我们需要自己获取安装（释放）和卸载（删除）的进度。 以安装进度为例，NSIS 中文件的安装时文件释放功能都是由File命令提供，但该命令没有提供释放进度，所以我们无法获取到实时的释放进度。在这里我们可以使用一个曲折的方法，我们将一个 7z 压缩包放入安装包中： 12SetOutPath $INSTDIRFile &quot;app\\app.7z&quot; 等安装包释放完这个压缩包之后（这段时间的进度无法显示），再使用 NSIS 官方提供的nsis7z插件来解压缩这个 7z 压缩包，由于 nsis7z 插件可以提供解压缩进度，所以我们可以将这个进度显示在安装进度页面上，解压完之后再删除 7z 压缩包。这个方案的一个弊端就是，7z 压缩包从安装包中释放到本地磁盘的过程需要时间，且这个时间无法准确的显示在进度页面。 1234567Function ExtractFunc SetOutPath $INSTDIR File &quot;app\\app.7z&quot; GetFunctionAddress $R9 ExtractCallback Nsis7z::ExtractWithCallback &quot;$INSTDIR\\app.7z&quot; $R9 Delete &quot;$INSTDIR\\app.7z&quot;FunctionEnd 123456789101112131415Function ExtractCallback Pop $1 Pop $2 System::Int64Op $1 * 100 Pop $3 System::Int64Op $3 / $2 Pop $0 nsDui::SetSliderValue &quot;slrProgress&quot; $0 $&#123;If&#125; $1 == $2 nsDui::SetSliderValue &quot;slrProgress&quot; 100 nsDui::NextPage &quot;wizardTab&quot; $&#123;EndIf&#125;FunctionEnd 写这篇文字的时候，发现现在的nsis7z已经太老了，新版的压缩软件生成的 7z 压缩包，该插件已经无法解压。可以使用 7za.exe 命令行工具来生成 7z 压缩文件，7za.exe 从此处下载：http://download.csdn.net/download/china_jeffery&#x2F;10214464。7za 生成 7z 压缩包语法为：7za.exe a app.7z app\\* 2.2 从 C++回调 NSIS 函数比如用户点击了我们自定义界面上的“取消”按钮，这时我们需要调用 NSIS 的Abort函数来取消安装。此时就需要解决如何从 C++环境回调到 NSIS 环境。 我们可以使用NSIS教程(8)-插件开发中介绍的PluginCommon.h来实现该功能。 大致原理是，在 NSIS 脚本中初始化自定义界面的控件与 NSIS 函数指针（整型）的绑定关系（如控件名–函数名），当用户点击控件之后，查找到该控件绑定的 NSIS 函数，然后调用extra_parameters::ExecuteCodeSegment函数（函数第一个参数就是 NSIS 函数指针）。 以 duilib 界面库为例，对 NSIS 暴露 OnControlBindNSISScript 接口，提供绑定控件与 NSIS 函数指针（整型）的功能： 123456789NSISAPI OnControlBindNSISScript(HWND hwndParent, int string_size, char *variables, stack_t **stacktop, extra_parameters *extra)&#123; char controlName[MAX_PATH]; ZeroMemory(controlName, MAX_PATH); popstring(controlName); int callbackID = popint(); g_pMainDlg-&gt;SaveToControlCallbackMap( controlName, callbackID );&#125; 在 NSIS 中调用OnControlBindNSISScript绑定控件与 NSIS 函数： 12GetFunctionAddress $0 OnExitDUISetupnsDui::OnControlBindNSISScript &quot;btnFinishedClose&quot; $0 在 duilib 的Notify按钮事件响应函数中调用ExecuteCodeSegment执行 NSIS 函数： 1234567891011121314void CDlgMain::Notify( TNotifyUI&amp; msg )&#123; std::map&lt;CDuiString, int &gt;::iterator iter = m_controlCallbackMap.find( msg.pSender-&gt;GetName() ); if( _tcsicmp( msg.sType, _T(&quot;click&quot;) ) == 0 )&#123; if( iter != m_controlCallbackMap.end() ) g_pluginParms-&gt;ExecuteCodeSegment( iter-&gt;second - 1, 0 ); &#125; else if( _tcsicmp( msg.sType, _T(&quot;textchanged&quot;) ) == 0 )&#123; if( iter != m_controlCallbackMap.end() ) g_pluginParms-&gt;ExecuteCodeSegment( iter-&gt;second - 1, 0 ); &#125; else &#123; WindowImplBase::Notify(msg); &#125;&#125; 可以参考我的NSIS-UI-Plugin 项目，基于该项目可以使用任意第三方界面库来定制安装界面。","tags":["NSIS","duilib"],"categories":["NSIS"]},{"title":"NSIS教程(8)-插件开发","path":"/post/1273492093.html","content":"虽然 NSIS 官方提供了很多插件，也有一些第三方的插件可以下载使用，但在实际开发中难免会遇到已有插件没有提供的功能或者插件不好用的情况，这时我们可以选择自己开发 NSIS 插件。 一、插件开发规范NSIS 插件对开发语言没有限制（本文介绍基于 C++开发），只要按照 NSIS 标准所要求的生成一个 dll 文件，该 dll 文件提供纯C规范的、固定格式的导出函数即可。 总结起来，开发 NSIS 插件的步骤为： 使用 Visual Studio 新建 dll 工程（运行库选择MT或MTD），建议使用的 MT 运行库，不需要额外携带运行时文件。 定义插件功能函数，假设函数名为 add，则函数声明格式如下： 123456extern &quot;C&quot; __declspec(dllexport) void __cdecl add ( HWND hwndParent, int string_size, char *variables, stack_t **stacktop, extra_parameters *extra); 编译生成 dll 文件。 二、参数和返回值开发 NSIS 插件的难点在于：获取调用者传入的参数，以及将执行结果返回给调用者。前面的 NSIS教程(7)-插件使用 说到了，插件函数的调用者传递参数方式有 2 种： 一种是通过$0~$9 $R0~$R9的形式，这种形式的参数通过char *variables参数来获取。 一种是通过堆栈的形式，这种形式的参数通过stack_t **stacktop参数来获取。 三、PluginCommon为了方便插件开发中获取用户传入参数、以及执行结果的返回，我对插件开发的常用操作进行了封装。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147// PluginCommon.h#ifndef _PLUGIN_COMMON_H_#define _PLUGIN_COMMON_H_#include &lt;stdio.h&gt;#define PLUGIN_BUF_LEN 1024#define NSISAPI extern &quot;C&quot; __declspec(dllexport) void __cdecl#define EXDLL_INIT() &#123; \\ g_stringsize=string_size; \\ g_stacktop=stacktop; \\ g_variables=variables; &#125;typedef struct _stack_t &#123; struct _stack_t *next; char text[1];&#125; stack_t;static unsigned int g_stringsize;static stack_t **g_stacktop;static char *g_variables;enum&#123; INST_0, // $0 INST_1, // $1 INST_2, // $2 INST_3, // $3 INST_4, // $4 INST_5, // $5 INST_6, // $6 INST_7, // $7 INST_8, // $8 INST_9, // $9 INST_R0, // $R0 INST_R1, // $R1 INST_R2, // $R2 INST_R3, // $R3 INST_R4, // $R4 INST_R5, // $R5 INST_R6, // $R6 INST_R7, // $R7 INST_R8, // $R8 INST_R9, // $R9 INST_CMDLINE, // $CMDLINE INST_INSTDIR, // $INSTDIR INST_OUTDIR, // $OUTDIR INST_EXEDIR, // $EXEDIR INST_LANG, // $LANGUAGE __INST_LAST&#125;;static int __stdcall popstring(char *str)&#123; stack_t *th; if (!g_stacktop || !*g_stacktop) return 1; th=(*g_stacktop); lstrcpyA(str,th-&gt;text); *g_stacktop = th-&gt;next; GlobalFree((HGLOBAL)th); return 0;&#125;static void __stdcall pushstring(char *str)&#123; stack_t *th; if (!g_stacktop) return; th=(stack_t*)GlobalAlloc(GPTR,sizeof(stack_t)+g_stringsize); lstrcpynA(th-&gt;text,str,g_stringsize); th-&gt;next=*g_stacktop; *g_stacktop=th;&#125;static int __stdcall popint()&#123; char buf[512] = &#123;0&#125;; popstring(buf); return atoi(buf);&#125;static void __stdcall pushint(long value)&#123; char buf[512] = &#123;0&#125;; sprintf_s(buf, &quot;%ld&quot;, value); pushstring(buf);&#125;static char * __stdcall getuservariable(int varnum)&#123; if (varnum &lt; 0 || varnum &gt;= __INST_LAST) return NULL; return g_variables+varnum*g_stringsize;&#125;static void __stdcall setuservariable(int varnum, char *var)&#123; if (var != NULL &amp;&amp; varnum &gt;= 0 &amp;&amp; varnum &lt; __INST_LAST) lstrcpyA(g_variables + varnum*g_stringsize, var);&#125;enum NSPIM&#123; NSPIM_UNLOAD, // This is the last message a plugin gets, do final cleanup NSPIM_GUIUNLOAD, // Called after .onGUIEnd&#125;;typedef UINT_PTR (*NSISPLUGINCALLBACK)(enum NSPIM);// extra_parameters data structures containing other interesting stuff// but the stack, variables and HWND passed on to plug-ins.typedef struct&#123; int autoclose; int all_user_var; int exec_error; int abort; int exec_reboot; // NSIS_SUPPORT_REBOOT int reboot_called; // NSIS_SUPPORT_REBOOT int XXX_cur_insttype; // depreacted int plugin_api_version; // see NSISPIAPIVER_CURR // used to be XXX_insttype_changed int silent; // NSIS_CONFIG_SILENT_SUPPORT int instdir_error; int rtl; int errlvl; int alter_reg_view; int status_update;&#125; exec_flags_t;#ifndef NSISCALL#define NSISCALL __stdcall#endiftypedef struct &#123; exec_flags_t *exec_flags; int (NSISCALL *ExecuteCodeSegment)(int, HWND); void (NSISCALL *validate_filename)(char *); // returns 0 on success, 1 if already registered and &lt; 0 on errors int (NSISCALL *RegisterPluginCallback)(HMODULE, NSISPLUGINCALLBACK);&#125; extra_parameters;#endif //_PLUGIN_COMMON_H_ 在开发插件中经常用到的有：4 个堆栈操作函数：pushint,pushstring,popint,popstring。2 个寄存器变量($R0~$R9,$0~$9)操作函数：getuservariable，setuservariable。 四、示例基于上面的 PluginCommon.h，我们可以将开发插件的步骤流程大大简化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;windows.h&gt;#include &lt;commctrl.h&gt;#include &lt;stdarg.h&gt;#include &lt;tchar.h&gt;#include &quot;PluginCommon.h&quot;HINSTANCE g_hInstance;HWND g_hwndParent;extra_parameters *g_pluginParms = NULL;#define NSMETHOD_INIT(parent) &#123;\\ g_pluginParms = extra; \\ g_hwndParent = parent; \\ EXDLL_INIT(); &#125;BOOL WINAPI DllMain(HANDLE hInst, ULONG ul_reason_for_call, LPVOID lpReserved)&#123; g_hInstance = (HINSTANCE)hInst; if (ul_reason_for_call == DLL_PROCESS_ATTACH) &#123; //do what you want at init time. &#125; if (ul_reason_for_call == DLL_THREAD_DETACH || ul_reason_for_call == DLL_PROCESS_DETACH) &#123; //clean up code. &#125; return TRUE;&#125;//// 以上内容通用，每个插件都可以将上面的内容直接复制过去。//// NSIS插件导出函数,以add函数为例，若要添加其他函数，则只是函数名需要修改，函数逻辑写在NSMETHOD_INIT(hwndParent);之后的花括号内。//extern &quot;C&quot; __declspec(dllexport) void __cdecladd ( HWND hwndParent, int string_size, char *variables, stack_t **stacktop, extra_parameters *extra)&#123; NSMETHOD_INIT(hwndParent); &#123; // == 添加自己代码 // 假设调用者通过堆栈的形式传递的参数 int i = popint(); // 注意：栈是先进后出 int j = popint(); int k = i + j; pushint(k); // 通过plugin-common.h中提供的pushint返回整数，也可以使用pushstring返回字符串 // == &#125;&#125; 五、Unicode 支持大家可能注意到了上面的示例和PluginCommon.h中使用的都是char，而不是wchar_t。那如果要改成wchar_t需要哪些工作了？ 将插件代码中的char改成wchar_t。 在 nsi 脚本中加入Unicode True。 需要将生成的插件 dll 放到 nsis 目录下的Plugins\\x86-unicode子目录中。","tags":["NSIS"],"categories":["NSIS"]},{"title":"NSIS教程(7)-插件使用","path":"/post/3031217406.html","content":"NSIS 内置了很多指令，这些指令可以满足我们基本需求，但难免会遇到 NSIS 没有内置的功能，如进程操作，后台运行（即多线程），7z 压缩等等，这个时候我们就需要借助第三方插件来满足我们所需要的功能了。 一、插件获取NSIS 官方收录插件的网址是： http://nsis.sourceforge.net/Category:Plugins 我们可以在这个网站上查找和下载我们需要的插件，该网站上针对每个插件都提供了比较完善的示例。 二、插件使用NSIS 插件以 dll 的形式存在，我们以KillProc插件为例（从名字上可以看出该插件提供杀进程的功能），我们下载下来的一般是压缩包，解压之后找到对应插件 dll 文件，如KillProc.dll文件。 使用步骤如下： 将 dll 文件拷贝到 NSIS 安装目录下的Plugins\\x86-ansi目录（Unicode 插件需要拷贝到Plugins\\x86-unicode目录）。 在官方文档上找到该插件所提供的函数，以及函数的参数传递形式、返回值形式。NSIS 中插件函数的参数传递形式有 2 种形式： 使用$0 ~ $9，$R0 ~ $R9来传递。 使用堆栈来传递。 在 NSIS 脚本中按照函数声明的形式来调用，需要在函数名前加上 dll 名称（不需要.dll 后缀），如KillProc::KillProcesses。 1234567891011Section StrCpy $0 &quot;foo.exe&quot; # 变量赋值 KillProc::KillProcesses StrCmp $1 &quot;-1&quot; wooops wooops: Abort completed:SectionEnd","tags":["NSIS"],"categories":["NSIS"]},{"title":"NSIS教程(6)-静默安装","path":"/post/4172083706.html","content":"静默安装&#x2F;卸载是一种安装&#x2F;卸载形式，用户打开安装包后不显示任何安装界面，直接开始安装，支持使用命令行参数指定安装路径等。 1. 静默方式常用的静默安装有 2 种： 在脚本中加入 SilentInstall 和 SilentUninstall 命令 在程序启动参数里加 &#x2F;S 参数(区分大小写) 2. 当前是否静默运行在脚本中判断安装、卸载程序是否为静默运行，可以使用 IfSilent： 12345# 安装操作开始前.Function .onInit IfSilent +2 +1 MessageBox MB_ICONQUESTION|MB_OK &quot;欢迎使用&quot;FunctionEnd 3. 默认应答对于有些命令需要为静默安装指定默认的回答，如MessageBox需要加入&#x2F;SD 开关来指定默认回答。 12345# 卸载操作开始前.Function un.onInit MessageBox MB_ICONQUESTION|MB_YESNO &quot;确定要卸载吗?&quot; /SD IDYES IDYES +2 IDNO +1 AbortFunctionEnd 4. 启动参数解析如果需要为静默安装指定其他的参数，如用户名等，可以使用程序启动参数指定，并在.onInit 函数里进行解析： 1234#使用插件FileFunc中的2个宏!include &quot;FileFunc.nsh&quot;!insertmacro GetParameters!insertmacro GetOptions 12# 定义全局变量Var paramInstllDir # 启动参数-安装目录 12345678# 自定义宏ParseParameters，在.onInit函数中调用即可!macro ParseParameters $&#123;GetParameters&#125; $R0 $&#123;GetOptions&#125; $R0 &#x27;/installdir&#x27; $R1 StrCpy $paramInstllDir $R1 IfSilent +1 +2 StrCpy $INSTDIR $paramInstllDir!macroend","tags":["NSIS","静默安装"],"categories":["NSIS"]},{"title":"NSIS教程(5)-现代界面示例","path":"/post/3798382521.html","content":"NSIS 的现代用户界面(Modern UI)只是相对于传统（丑陋）的界面而言的“现代”而已。它定义在MUI2.nsh中，nsh 文件类似 C++中的头文件，可以被其他模块包含引用。 📌 推荐：NSIS-UI-Plugin 开源 NSIS UI 插件框架，支持任意第三方界面库。默认使用 Qt 作为界面库的安装包示例。 使用 MUI2 界面需要包含MUI2.nsh： 1!include &quot;MUI2.nsh&quot; MUI2 界面和传统界面不同之处在于，传统界面使用的Page(或PageEx)语法来标识显示哪些页面，如： 123PageEx license LicenseData &quot;license.rtf&quot; #可以是txt或rtf文件格式PageExEnd 而 MUI2 使用的是MUI2.nsh中定义的一系列宏来标识显示哪些页面，如： 1!insertmacro MUI_PAGE_LICENSE &quot;license.rtf&quot; 和NSIS教程(4)-传统界面示例类似，这里提供制作网易云音乐的现代用户界面的安装包示例，脚本代码中包含了详细的注释。 高仿网易云音乐安装脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188# ====================== 自定义宏 ==============================!define PRODUCT_NAME &quot;网易云音乐&quot;!define EXE_NAME &quot;cloudmusic.exe&quot;!define PRODUCT_VERSION &quot;1.0.0.1&quot;!define PRODUCT_PUBLISHER &quot;NetEase&quot;!define PRODUCT_LEGAL &quot;NetEase 1999-2014&quot;!define TEMP_DIR &quot;&quot;# ===================== 外部插件以及宏 =============================!include &quot;MUI2.nsh&quot;# ===================== 安装包版本 =============================VIProductVersion &quot;$&#123;PRODUCT_VERSION&#125;&quot;VIAddVersionKey &quot;ProductVersion&quot; &quot;$&#123;PRODUCT_VERSION&#125;&quot;VIAddVersionKey &quot;ProductName&quot; &quot;$&#123;PRODUCT_NAME&#125;&quot;VIAddVersionKey &quot;CompanyName&quot; &quot;$&#123;PRODUCT_PUBLISHER&#125;&quot;VIAddVersionKey &quot;FileVersion&quot; &quot;$&#123;PRODUCT_VERSION&#125;&quot;VIAddVersionKey &quot;InternalName&quot; &quot;$&#123;EXE_NAME&#125;&quot;VIAddVersionKey &quot;FileDescription&quot; &quot;$&#123;PRODUCT_NAME&#125;&quot;VIAddVersionKey &quot;LegalCopyright&quot; &quot;$&#123;PRODUCT_LEGAL&#125;&quot;# ==================== NSIS属性 ================================# ZLIB(默认) BZIP2 LZMASetCompressor lzma; 安装包名字.Name &quot;$&#123;PRODUCT_NAME&#125;&quot;# 安装程序文件名.OutFile &quot;网易云音乐安装0.exe&quot;# 默认安装位置.InstallDir &quot;$PROGRAMFILES\\Netease\\CloudMusic&quot;# 设置是否显示安装详细信息。ShowInstDetails hide# 设置是否显示卸载详细信息ShowUnInstDetails hide# 针对Vista和win7 的UAC进行权限请求.# RequestExecutionLevel none|user|highest|adminRequestExecutionLevel admin# ==================== MUI属性 ==================================# 安装和卸载程序图标!define MUI_ICON &quot;image\\logo.ico&quot;!define MUI_UNICON &quot;image\\un_logo.ico&quot;# 如果未使用MUI，则可直接使用.onGUIInit!define MUI_CUSTOMFUNCTION_GUIINIT onGUIInit# 安装程序欢迎页面!insertmacro MUI_PAGE_WELCOME# 安装程序软件授权申明页面!insertmacro MUI_PAGE_LICENSE &quot;license.rtf&quot;# 安装程序显示安装目录选择页面!insertmacro MUI_PAGE_DIRECTORY# 安装程序显示安装组件选择页面!insertmacro MUI_PAGE_COMPONENTS# 安装程序显示进度页面!insertmacro MUI_PAGE_INSTFILES# 安装程序显示安装结束页面!insertmacro MUI_PAGE_FINISH# 卸载程序显示进度!insertmacro MUI_UNPAGE_INSTFILES# 卸载程序显示安装结束!insertmacro MUI_UNPAGE_FINISH# 指定语言，必须在最后指定!insertmacro MUI_LANGUAGE &quot;SimpChinese&quot;# ========================= 安装步骤 ===============================# 区段1# 区段名以一个 ! 开头，那么该区段的显示名称将以粗体字显示.Section &quot;!Files&quot; &quot;des_files&quot; ; 设置文件的输出路径 SetOutPath $INSTDIR ; 放置文件 File /r &quot;app\\*.*&quot;SectionEnd# 区段2Section &quot;Shortcut&quot; &quot;des_shortcut&quot; SetShellVarContext all CreateDirectory &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;&quot; CreateShortCut &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;\\$&#123;PRODUCT_NAME&#125;.lnk&quot; &quot;$INSTDIR\\$&#123;EXE_NAME&#125;&quot; CreateShortCut &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;\\卸载$&#123;PRODUCT_NAME&#125;.lnk&quot; &quot;$INSTDIR\\uninst.exe&quot; SetShellVarContext currentSectionEnd# 区段3# 区段名为空、遗漏或者以一个 &quot;-&quot; 开头，那么它将是一个隐藏的区段，用户也不能选择禁止它.Section &quot;-Necessary&quot; # 生成卸载程序 WriteUninstaller &quot;$INSTDIR\\uninst.exe&quot; # 添加卸载信息到控制面板 WriteRegStr HKLM &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$&#123;PRODUCT_NAME&#125;&quot; &quot;DisplayName&quot; &quot;$&#123;PRODUCT_NAME&#125;&quot; WriteRegStr HKLM &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$&#123;PRODUCT_NAME&#125;&quot; &quot;UninstallString&quot; &quot;$INSTDIR\\uninst.exe&quot; WriteRegStr HKLM &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$&#123;PRODUCT_NAME&#125;&quot; &quot;DisplayIcon&quot; &quot;$INSTDIR\\$&#123;EXE_NAME&#125;&quot; WriteRegStr HKLM &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$&#123;PRODUCT_NAME&#125;&quot; &quot;Publisher&quot; &quot;$INSTDIR\\$&#123;PRODUCT_PUBLISHER&#125;&quot;SectionEnd# 卸载区段Section &quot;Uninstall&quot; ; 删除快捷方式 SetShellVarContext all Delete &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;\\$&#123;PRODUCT_NAME&#125;.lnk&quot; Delete &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;\\卸载$&#123;PRODUCT_NAME&#125;.lnk&quot; RMDir &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;\\&quot; Delete &quot;$DESKTOP\\$&#123;PRODUCT_NAME&#125;.lnk&quot; SetShellVarContext current SetOutPath &quot;$INSTDIR&quot; ; 删除安装的文件 Delete &quot;$INSTDIR\\*.*&quot; SetOutPath &quot;$DESKTOP&quot; RMDir /r &quot;$INSTDIR&quot; RMDir &quot;$INSTDIR&quot; SetAutoClose trueSectionEnd# 区段描述!insertmacro MUI_FUNCTION_DESCRIPTION_BEGIN !insertmacro MUI_DESCRIPTION_TEXT $&#123;des_files&#125; &quot;主程序文件&quot; !insertmacro MUI_DESCRIPTION_TEXT $&#123;des_shortcut&#125; &quot;创建开始菜单和桌面快捷方式&quot;!insertmacro MUI_FUNCTION_DESCRIPTION_END# ============================== 回调函数 ====================================# 函数名以“.”开头的一般作为回调函数保留.# 函数名以“un.”开头的函数将会被创建在卸载程序里，因此，普通安装区段和函数不能调用卸载函数，而卸载区段和卸载函数也不能调用普通函数。Function .onInitFunctionEndFunction onGUIInitFunctionEnd# 安装成功以后.Function .onInstSuccessFunctionEnd# 卸载操作开始前.Function un.onInit MessageBox MB_ICONQUESTION|MB_YESNO &quot;你确实要完全删除网易云音乐，及其所有组件吗?&quot; /SD IDYES IDYES +2 IDNO +1 AbortFunctionEnd# 卸载成功以后.Function un.onUninstSuccess MessageBox MB_ICONINFORMATION|MB_OK &quot;$&#123;PRODUCT_NAME&#125; 已成功地从你的计算机移除&quot; /SD IDOKFunctionEnd 运行效果","tags":["NSIS"],"categories":["NSIS"]},{"title":"NSIS教程(4)-传统界面示例","path":"/post/275632694.html","content":"本文以一个完整的、传统界面的网易云音乐安装包的脚本为示例，来介绍 NSIS 传统用户界面的开发流程。 网易云音乐安装脚本完整的示例脚本如下，脚本中包含了详细的注释加以解释说明。请将下面脚本保存为.nsi 文件（需使用 ANSI 编码保存），编译即可生成安装包。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199# 单行注释用井号&quot;#&quot;或分号&quot;;&quot;，跨行注释用可以用C/C++中注释语法。# 使用!define定义一些常量（如安装包的版本号等）# 对常量或变量的引用可以使用如$&#123;PRODUCT_NAME&#125;格式，也可以使用如$PRODUCT_NAME格式!define PRODUCT_NAME &quot;网易云音乐&quot;!define EXE_NAME &quot;cloudmusic.exe&quot;!define PRODUCT_VERSION &quot;1.0.0.1&quot;!define PRODUCT_PUBLISHER &quot;NetEase&quot;!define PRODUCT_LEGAL &quot;NetEase 1999-2014&quot;!define TEMP_DIR &quot;&quot;/*NSIS内置了一些常用的变量，如$INSTDIR 表示用户定义的解压路径；$DESKTOP 表示Windows桌面目录；等等。也可以用 Var 命令来声明自己的变量($VARNAME)。 NSIS的变量都是全局的并且可以在任何区段或函数中使用。另外堆栈可以用来作为临时存储。 使用 Push 和 Pop 命令来访问堆栈。Push把一个值添加到堆栈，Pop移除一个值并且设置该变量。且NSIS内置了20个已注册的变量 (如 $0~$9 和 $R0~$R9)。 这些变量不需要声明就可以使用。*/# 定义安装包可执行文件的版本信息VIProductVersion &quot;$&#123;PRODUCT_VERSION&#125;&quot;VIAddVersionKey &quot;ProductVersion&quot; &quot;$&#123;PRODUCT_VERSION&#125;&quot;VIAddVersionKey &quot;ProductName&quot; &quot;$&#123;PRODUCT_NAME&#125;&quot;VIAddVersionKey &quot;CompanyName&quot; &quot;$&#123;PRODUCT_PUBLISHER&#125;&quot;VIAddVersionKey &quot;FileVersion&quot; &quot;$&#123;PRODUCT_VERSION&#125;&quot;VIAddVersionKey &quot;InternalName&quot; &quot;$&#123;EXE_NAME&#125;&quot;VIAddVersionKey &quot;FileDescription&quot; &quot;$&#123;PRODUCT_NAME&#125;&quot;VIAddVersionKey &quot;LegalCopyright&quot; &quot;$&#123;PRODUCT_LEGAL&#125;&quot;# ==================== NSIS属性 ================================# 设置安装包的压缩方案，有ZLIB（默认）、BZIP2、LZMASetCompressor lzma; 设置安装包名字，显示在安装包标题栏等位置Name &quot;$PRODUCT_NAME&quot;# 安装包可执行程序文件名OutFile &quot;网易云音乐安装-Basic UI.exe&quot;# 安装包默认安装位置，也就是安装路径的默认值InstallDir &quot;$PROGRAMFILES\\Netease\\CloudMusic&quot;# 设置是否显示安装详细信息ShowInstDetails hide# 设置是否显示卸载详细信息ShowUnInstDetails hide# 针对Vista和win7+ 的UAC进行权限请求.# RequestExecutionLevel none|user|highest|adminRequestExecutionLevel admin# 安装和卸载程序的图标Icon &quot;image\\logo.ico&quot;UninstallIcon &quot;image\\un_logo.ico&quot;/*向导页面是NSIS安装程序中最重要的界面元素，在nsis脚本中可以使用NSIS内置页面或者定制界面，通过脚本可以指定页面的顺序、显示样子和行为。 PageEx指令用来定义安装程序中的页面，也可以使用Page指令，但PageEx提供更多选项；UninstPage用来定义卸载页面。页面显示的顺序和它在nsis脚本中定义的次序一致。安装页面有：license|components|directory|instfiles|卸载页面有：uninstConfirm每个页面有不同元素和属性。也可以使用Page custom来自定义页面，这个后面的文章有讲到。*/PageEx license LicenseData &quot;license.rtf&quot; #可以是txt或rtf文件格式PageExEnd/*在一个普通的安装包里用户需要安装许多东西。例如在NSIS安装包里你可以选择安装源码、附加插件、脚本样例或其他。里面的每个组件都有它自己的代码块，当用户选择了安装该组件，那么安装程序就会执行对应的代码。在脚本里，这些代码称为区段，见下面的Section。每个可见的区段都可以作为一个组件给用户选择是否安装。你可以只使用一个区段来构建安装包，但是如果你想要使用组件页来让用户选择可选的组件，那你就需要使用多个区段。*/PageEx components Caption &quot;组件选择&quot; ComponentText &quot;选择安装组件：&quot; &quot;主程序&quot; &quot;快捷方式&quot;PageExEndPageEx directory Caption &quot;安装目录&quot; DirText &quot;请选择安装目录：&quot;PageExEndPageEx instfilesPageExEnd# 区段1# 区段名以一个!开头，那么该区段的显示名称将以粗体字显示.Section &quot;!Files&quot; &quot;des_files&quot; ; 设置下面指定的文件在安装时默认的解压路径 SetOutPath $INSTDIR ; 指明哪些文件需要被压缩进入安装包，&quot;app\\*.*&quot;是相对于nsis脚本文件的相对路径 File /r &quot;app\\*.*&quot;SectionEnd# 区段2# 该区段专门用来创建一些快捷方式#Section &quot;Shortcut&quot; &quot;des_shortcut&quot; SetShellVarContext all CreateDirectory &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;&quot; CreateShortCut &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;\\$&#123;PRODUCT_NAME&#125;.lnk&quot; &quot;$INSTDIR\\$&#123;EXE_NAME&#125;&quot; CreateShortCut &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;\\卸载$&#123;PRODUCT_NAME&#125;.lnk&quot; &quot;$INSTDIR\\uninst.exe&quot; SetShellVarContext currentSectionEnd# 区段3# 区段名为空、遗漏或者以一个 &quot;-&quot; 开头，那么它将是一个隐藏的区段，用户也不能选择禁止它.#Section &quot;-Necessary&quot; # 生成卸载程序 WriteUninstaller &quot;$INSTDIR\\uninst.exe&quot; # 添加卸载信息到控制面板 WriteRegStr HKLM &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$&#123;PRODUCT_NAME&#125;&quot; &quot;DisplayName&quot; &quot;$&#123;PRODUCT_NAME&#125;&quot; WriteRegStr HKLM &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$&#123;PRODUCT_NAME&#125;&quot; &quot;UninstallString&quot; &quot;$INSTDIR\\uninst.exe&quot; /* 在NSIS脚本里每一行都作为一个命令处理，如果这一行太长的话你可以使用“\\”来分隔，编译器会自动地把下一行接到上一行来作为完整的一行，而不是看作新的行。 */ WriteRegStr HKLM &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$&#123;PRODUCT_NAME&#125;&quot; &quot;DisplayIcon&quot; &quot;$INSTDIR\\$&#123;EXE_NAME&#125;&quot; WriteRegStr HKLM &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$&#123;PRODUCT_NAME&#125;&quot; &quot;Publisher&quot; &quot;$INSTDIR\\$&#123;PRODUCT_PUBLISHER&#125;&quot;SectionEnd# 卸载区段，如果一个区段名为“Uninstall”或以“un.”为前缀，那么它就是一个卸载程序区段。#Section &quot;Uninstall&quot; ; 删除快捷方式，SetShellVarContext 设置操作是针对当前用户还是所有用户 SetShellVarContext all Delete &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;\\$&#123;PRODUCT_NAME&#125;.lnk&quot; Delete &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;\\卸载$&#123;PRODUCT_NAME&#125;.lnk&quot; RMDir &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;\\&quot; Delete &quot;$DESKTOP\\$&#123;PRODUCT_NAME&#125;.lnk&quot; SetShellVarContext current SetOutPath &quot;$INSTDIR&quot; ; 删除安装的文件 Delete &quot;$INSTDIR\\*.*&quot; SetOutPath &quot;$DESKTOP&quot; RMDir /r &quot;$INSTDIR&quot; RMDir &quot;$INSTDIR&quot; SetAutoClose trueSectionEnd# ============================== 回调函数 ====================================# 函数名以“.”开头的一般作为回调函数保留.# 函数名以“un.”开头的函数将会被创建在卸载程序里，因此，普通安装区段和函数不能调用卸载函数，而卸载区段和卸载函数也不能调用普通函数。Function .onInitFunctionEndFunction .onGUIInitFunctionEnd# 安装成功以后.Function .onInstSuccessFunctionEnd# 卸载操作开始前.Function un.onInit MessageBox MB_ICONQUESTION|MB_YESNO &quot;你确实要完全删除网易云音乐，及其所有组件吗?&quot; /SD IDYES IDYES +2 IDNO +1 AbortFunctionEnd# 卸载成功以后.Function un.onUninstSuccess MessageBox MB_ICONINFORMATION|MB_OK &quot;$&#123;PRODUCT_NAME&#125; 已成功地从你的计算机移除&quot; /SD IDOKFunctionEnd 上述脚本会将与脚本相同级别的 app 目录下的全部文件（含子目录）打包进安装包。image\\logo.ico和image\\un_logo.ico分别是安装包和卸载程序的图标。 运行截图","tags":["NSIS"],"categories":["NSIS"]},{"title":"NSIS教程(3)-完整指令","path":"/post/2673115526.html","content":"本文列出了 NSIS 支持的完整指令，以供查阅。 基本指令NSIS 用于脚本的这些指令稍微的近似于 PHP 和汇编。他们没有真正的高级语言结构，但是他们的指令(对于绝大部分)却是高级的，并且你可以很容易的掌握(比如你不用担心字串的连接等等)。NSIS 为你提供了 25 个寄存器(20 个常规用途，5 个特殊用途)，和一个堆栈。 Delete1[/REBOOTOK] 文件 从目标系统删除文件(可以是文件或通配符，但必须指定一个完整的路径)。如果指定了“&#x2F;REBOOTOK”并且该文件当前不可删除，则会在系统重启时删除该文件 – 如果该文件要在系统重启时删除，你还要设置一个重启的位标计。如果找到的文件不能被删除则会置一个错误位标计。但该错误位标计不是从尝试删除一个不存在的文件设置的。 Exec命令执行一个指定的程序并且立即继续安装。注意指定的文件必须存在于目标系统而不是编译的系统。$OUTDIR 用于指定工作路径。如果该命令不能被运行则会置一个错误位标计。注意，如果该命令包含有空格，你要用引号来把他们包括起来。例如：Exec ‘“$INSTDIR\\command.exe” 参数’。如果你不用引号括起来则在 Windwos 9X 下不正常或丢失参数。 ExecShell1动作 命令 [参数] [SW_SHOWNORMAL | SW_SHOWMAXIMIZED | SW_SHOWMINIMIZED] 使用 Windows 的外壳关联来执行一个指定的程序。注意“动作”通常为“open”、“print”等等，也可以是一个空字串来使用默认动作。参数和显示类型是可选项。$OUTDIR 用于指定工作路径。如果该处理不能被运行则会置一个错误位标计。 ExecWait1命令 [用户变量(退出代码)] 执行一个指定的程序并且等待运行处理结束。更多信息请查看 Exec。如果没有用户输出变量 ExecWait 会置一个错误位标计当程序执行返回一个非零错误代码，或者当产生错误时。如果指定了输出变量，ExecWait 会把变量置为退出代码(并且仅当产生一个错误时置一个错误位标计；如果产生一个错误则该用户变量的内容为未指定)。注意，如果该命令包含有空格，你要用引号来把他们包括起来。例如：Exec ‘“$INSTDIR\\command.exe” 参数’。如果你不用引号括起来则在 Windwos 9X 下不正常或丢失参数。 File1[/nonfatal] [/a] ([/r] (文件|通配符) [...] | /oname=输出路径\\文件名 输入路径\\文件名) 释放文件到当前输出路径($OUTDIR). 注意输出文件名是 $OUTDIR\\文件名。 如果使用了 &#x2F;oname&#x3D;X 开关，则输出名变为 $OUTDIR\\X。当使用了 &#x2F;oname&#x3D; 开关时只能指定一个文件，且文件名可以使用变量(或完整路径如 $SYSDIR\\whatever.dll)。支持通配符。 如果使用了 &#x2F;r 开关，文件和目录将会被递归添加。如果没有尾随通配符(如 File &#x2F;r C:\\whatever\\mydir)，则整个 mydir 目录树将会被添加到 $OUTDIR。如果要使它放到 $OUTDIR 请使用 File &#x2F;r C:\\whatever\\mydir*.*。 如果使用了 &#x2F;a 开关，被添加的文件的属性将会被保护。 如果覆盖模式被设定为 “try” 并且文件未被覆盖，那么 File 命令将会置一个错误位标计，或者如果覆盖模式被设定为 “on” 并且文件未被覆盖并且用户选择了忽略，那么也会被置一个错误位标计。 如果使用了 &#x2F;nonfatal 开关，当文件未找到时使用警告来代替错误。 Rename1[/REBOOTOK] 源文件 目标文件 把源文件重命名为目标文件。你可以用它来把用户系统里的任何地方的一个文件移动到用户系统里的任何地方，你也可以在一些驱动器上把一个目录移动到某些地方。目标文件必须为不存在否则移动失败(除非你使用了 &#x2F;REBOOTOK)。如果指定了 &#x2F;REBOOTOK，并且文件当时不能移动(比如，目标文件已存在)，则该文件在系统重启后才被移动到目标。如果文件在重启后才被移动，会置一个重启的位标计。当文件不能被重命名时(并且没有使用 &#x2F;REBOOTOK)或者原文件不存在时，会置一个错误位标计。 如果没有指定绝对路径则使用当前路径代替。当前路径可以使用 SetOutPath 指令来设置。如果你没有使用 SetOutPath 那么当前路径为 $EXEDIR。 ReserveFile1[/nonfatal] [/r] 文件 [文件...] 保存一个文件在最后使用的数据区块。之所以要把在脚本中使用到的文件，这样添加是因为要在 .onInit 函数里使用，例如使得安装程序载入变慢。这时候这个命令就非常有用了，它可以把文件包含在数据区块的顶端而不是让 NSIS 从已压缩的数据区块从头搜到脚来找这个文件，这样可以加快安装程序载入速度。 相关参数说明请查看 File。 RMDir1[/r|/REBOOTOK] 目录名 删除指定的目录(完整的路径)。没有 &#x2F;r 参数时只有在目录为空时才会被删除。如果指定了 &#x2F;r，则目录会被递归删除，所以在指定目录下的所有文件和目录均被删除。如果指定了 &#x2F;REBOOTOK，并且目录不能被覆盖，则当系统重启的时候会被删除 —— 如果目录需要在重启时被删除，会设一个重启的位标计。当目录不能被删除时会置一个错误的位标计。 SetOutPath输出路径设置输出路径($OUTDIR)且当路径不存在时创建(需要时递归)。必须为全路径名，通常使用 $INSTDIR。 注册表、INI 文件指令在下面所有的注册表指令里使用一个空字串(“”)来作为某个子健默认项，该默认项在注册表编辑器里显示为“(默认)”。 DeleteINISec1INI_文件名 区段名 从“INI_文件名”里删除整个区段 [区段名]。如果该区段不能被删除，会置一个错误的位标计。但是如果该区段找不到时则不会置错误位标计。 DeleteINIStr1INI_文件名 区段名 字串名 从“INI_文件名”里的 [区段名] 区段删除“字串名”字串。如果该字串不能被删除，会置一个错误的位标计。但是如果该字串找不到时则不会置错误位标计。 DeleteRegKey1[/ifempty] 根键 子键 删除一个注册表键。如果指定了 &#x2F;ifempty，则该注册表键仅当它无子键时才会被删除(否则，整个注册表键将被删除)。有效的根键值在后面的 WriteRegStr 列出。如果该键不能被删除(或如果它不存在)则会置一个错误的位标计。 DeleteRegValue1根键 子键 键名 删除一个注册表键值。有效的根键值在后面的 WriteRegStr 列出。如果该键值不能被删除(或如果它不存在)则会置一个错误的位标计。 EnumRegKey1用户变量(输出) 根键 子键 索引 把用户变量 $x 设为“根键\\子键”第“索引”号注册表键名。有效的根键值在后面的 WriteRegStr 列出。当指定的“根键\\子键”没有任何键时会返回一个空字串，当产生一个错误时会返回空字串并置一个错误位标计。 EnumRegValue1用户变量(输出) 根键 子键 索引 把用户变量 $x 设为“根键\\子键”第“索引”号注册表键值。有效的根键值在后面的 WriteRegStr 列出。当指定的“根键\\子键”没有任何键值时会返回一个空字串，当产生一个错误时会返回空字串并置一个错误位标计。 ExpandEnvStrings1用户变量(输出) 字串 把“字串”里的环境变量扩展到用户变量 $x。如果错误，该变量会被设为空值并置一个错误位标计。 FlushINI1INI_文件名 刷新 INI 文件缓冲。Windows 9x 会保持 INI 文件在内存里。该命令强制更改立即写入磁盘。当你自己编辑一个 INI 文件的时候可以使用它，删除、移动、复制，直到你使用 WriteINIStr、DeleteINISec 或 DeleteINStr 来更改它。 ReadEnvStr1用户变量(输出) 名称 从环境字串“名称”读取值并把值赋给用户变量 $x。如果读取字串时有错误发生，该用户变量被设为空，并置一个错误位标计。 ReadINIStr1用户变量(输出) INI_文件名 区段名 项名 从“INI_文件名”的 [区段名] 区段读取“项名”的值并把该值赋给用户变量 $x。如果该项未找到时会置一个错误位标计且该用户变量被赋为空值。 ReadRegDWORD1用户变量(输出) 根键 子键 项 从注册表读取一个 32 位 DWORD 到用户变量 $x。有效的根键值在后面的 WriteRegStr 列出。如果 DWORD 不存在时会置一个错误位标计并把 $x 设为空字串。如果该值存在但不是 DWORD，则会作为字串类型读取并置一个错误位标计。 ReadRegStr1用户变量(输出) 根键 子键 项 从注册表读取一个字串值到用户变量 $x。有效的根键值在后面的 WriteRegStr 列出。如果字串不存在时会置一个错误位标计并把 $x 设为空字串。如果该值存在但是 DWORD，则会转换为字串类型并置一个错误位标计。 WriteINIStr1INI_文件名 区段名 项名 值 把“项名”&#x3D;“值”写入“INI_文件名”的 [区段名] 区段。如果 INI 文件不能写入则置一个错误的位标计。 WriteRegBin1根键 子键 项 值数据 该命令将会写一个区块的二进制数据到注册表。有效的根键值在后面的 WriteRegStr 列出。值数据为十六进制格式(如 DEADBEEF01223211151)。如果该二进制数据不能写入注册表则置一个错误的位标计。如果注册表键不存在则会自动创建。“值数据”不能使用变量。 WriteRegDWORD1根键 子键 项 值 该命令写一个 DWORD(32 位整数)到注册表(可以使用变量)。有效的根键值在后面的 WriteRegStr 列出。如果该 DWORD 不能写入注册表则置一个错误的位标计。如果注册表键不存在则会自动创建。 4.9.2.16 WriteRegStr 1根键 子键 项 值 把字串写入注册表。详细信息请查看 WriteRegExpandStr。 4.9.2.17 WriteRegExpandStr 1根键 子键 项 值 把字串写入注册表。根键必须为下面列表之一: HKCR 或 HKEY_CLASSES_ROOT HKLM 或 HKEY_LOCAL_MACHINE HKCU 或 HKEY_CURRENT_USER HKU 或 HKEY_USERS HKCC 或 HKEY_CURRENT_CONFIG HKDD 或 HKEY_DYN_DATA HKPD 或 HKEY_PERFORMANCE_DATA 如果字串不能写入注册表则置一个错误的位标计。字串的类型为 REG_SZ 对应 WriteRegStr，或 REG_EXPAND_STR 对应 WriteRegExpandStr。如果注册表键不存在则会自动创建。 常规用途指令CallInstDLL1DLL_文件 [/NOUNLOAD] 函数名 从一个 NSIS 扩展动态链接库里调用一个函数名。看 Contrib\\ExDLL 的样本可以知道如何来创建。扩展动态链接库可以访问堆栈和变量。使用 &#x2F;NOUNLOAD 来强制安装程序保持动态链接库载入。注意: 要自动释放并调用 DLL 插件请使用插件命令来替换 CallInstDLL。 CopyFiles1[/SILENT] [/FILESONLY] 目标系统文件规范 目标路径 [文件大小_单位为_kb] 在正在安装的系统中把“目标系统文件规范”复制到“目标路径”。 如果你想从安装媒体里复制，或从系统的一个地方复制到另一个地方，你可以使用 $EXEDIR 变量来代替安装程序目录。如果复制操作需要很长时间的话你可以看到 Windows 的复制文件窗口(要禁止出现复制文件窗口使用&#x2F;SILENT)。最后的参数用来指定要复制的文件的大小(单位为 kb)，使安装程序可以估计所需磁盘空间。在出错，或用户退出(仅当忽略了 &#x2F;SILENT 时)时，会置一个错误位标计。如果指定了 &#x2F;FILESONLY 则仅复制文件。 如果没有指定绝对路径则使用当前路径代替。当前路径为最后一个 SetOutPath 指定的路径。如果没有使用任何 SetOutPath 指令则当前路径为 $EXEDIR。 CreateDirectory要创建的路径创建(必要时递归)指定的目录。当目录不能创建时是一个错误位标计。 你也可以指定一个绝对路径。 CreateShortCut1快捷文件.lnk 目标文件 [参数 [图标文件 [图标索引号 [启动选项 [键盘快捷键 [描述]]]]]] 创建一个指向“目标文件”的快捷方式“快捷文件.lnk”，可以带“参数”参数。 用于快捷方式的图标为“图标文件,图标索引号”；要使用默认图标的话把“图标文件”和“图标索引号”设为空字串。 “启动选项”可以是它们之一: SW_SHOWNORMAL, SW_SHOWMAXIMIZED, SW_SHOWMINIMIZED, 或一个空字串。 “键盘快捷键”应该为“flag|c”格式且 flag 可以联合使用(使用 |): ALT, CONTROL, EXT, 或 SHIFT。c 为要使用的字符(a-z, A-Z, 0-9, F1-F24 等等)。注意在这些字串里不能含有空格。一个典型的例子为 “ALT|CONTROL|F8”。$OUTDIR 被用来作为工作目录。你可以在创建快捷方式之前使用 SetOutPath 来指定或更改。“描述”为快捷方式的描述，或在 XP 下作为注释调用。 当快捷方式不能创建的时候会置一个错误位标计(例如路径不存在或一些其它错误)。 GetDLLVersion1文件名 用户变量(高位_DWORD_输出) 用户变量(低位_DWORD_输出) 从“文件名” DLL(或其他包含版本信息的可执行文件)取得版本信息。成功时把版本信息高位 DWORD 和低位 DWORD 设为用户输出变量；失败时输出为空且置错误位标计。下面的例子演示了读取一个 DLL 版本并可读的版本到 $0: 123456GetDllVersion &quot;$INSTDIR\\MyDLL.dll&quot; $R0 $R1IntOp $R2 $R0 / 0x00010000IntOp $R3 $R0 &amp; 0x0000FFFFIntOp $R4 $R1 / 0x00010000IntOp $R5 $R1 &amp; 0x0000FFFFStrCpy $0 &quot;$R2.$R3.$R4.$R5&quot; GetDLLVersionLocal1内部文件 用户变量(高位_DWORD_输出) 用户变量(低位_DWORD_输出) 类似于 GetDLLVersion，但它仅用于获取安装程序内部文件的信息(它实际上编译为两个 StrCpy 命令)。成功时把内部文件的版本信息高位 DWORD 和低位 DWORD 设为用户输出变量。 GetFileTime1文件名 用户变量(高位_DWORD_输出) 用户变量(低位_DWORD_输出) 获取“文件名”的最后写入时间。成功时把时间戳信息高位 DWORD 和低位 DWORD 输出到用户输出变量;失败时输出为空且置一个错误位标计。 GetFileTimeLocal1内部文件 用户变量(高位_DWORD_输出) 用户变量(低位_DWORD_输出) 类似于 GetFileTime，但它仅用于获取安装程序内部文件的信息(它实际上编译为两个 StrCpy 命令)。 GetFullPathName1[/SHORT] 用户变量(输出) 路经或文件 把指定的文件完整路径信息输出到用户变量 $x。如果参数的部分路径未找到，则置一个错误位标记并清空 $x。如果指定了 &#x2F;SHORT，路经将会被转换为短文件名格式。 GetTempFileName1用户变量(输出) [基本路径] 把一个临时文件的名称输出到用户变量 $x。该文件会自动创建，所以你可以随时的覆盖它。该临时文件的名称唯一。如果你希望这个临时文件创建在另一个目录而不是 Windows 临时目录的话指定一个“基本路径”给它。你需要在完成之后手动删除它。 SearchPath1用户变量(输出) 文件名 由第二个参数指定的文件名的全路径输出到用户变量 $x。如果该文件不存在则会置一个错误位标记并清空 $x。使用 SearchPath() 来在系统目录里搜索文件。 SetFileAttributes1文件名 属性 1|属性 2|... 设置“文件名”的属性。多从属性可用 | 隔开，有效的属性为: NORMAL 或 FILE_ATTRIBUTE_NORMAL (你可以把该项缩写为 0) ARCHIVE 或 FILE_ATTRIBUTE_ARCHIVE HIDDEN 或 FILE_ATTRIBUTE_HIDDEN OFFLINE 或 FILE_ATTRIBUTE_OFFLINE READONLY 或 FILE_ATTRIBUTE_READONLY SYSTEM 或 FILE_ATTRIBUTE_SYSTEM TEMPORARY 或 FILE_ATTRIBUTE_TEMPORARY 如果文件的属性不能被设置则置一个错误的位标计(例如文件不存在，或者你没有足够的权限)。你只能进行属性设置，而不能移除属性，如果你想移除的话请使用 NORMAL。这样所有的属性都会被擦除，该命令不支持通配符。 RegDLL1DLL_文件 [入口点名称] 载入指定的 DLL 并且调用 DllRegisterServer (或入口点名称，当指定之后)。当产生一个错误的时候会置一个错误位标计(例如不能载入 DLL，不能初始化 OLE，不能找到入口点，或者函数返回任何其它错误 ERROR_SUCCESS (&#x3D;0))。 当某些要注册的 DLL 要依靠其它的位于同目录或 Windows 目录下的 DLL 时请用 SetOutPath 来设定当前目录。例如，如果 foo.dll 依靠位于 $INSTDIR 的 bar.dll 时: 12SetOutPath $INSTDIRRegDLL $INSTDIR\\foo.dll UnRegDLL1DLL_文件 载入指定的 DLL 并且调用 DllUnregisterServer。当产生一个错误的时候会置一个错误位标计(例如不能载入 DLL，不能初始化 OLE，不能找到入口点，或者函数返回任何其它错误 ERROR_SUCCESS (&#x3D;0))。 流程控制指令Abort1[用户信息] 取消安装，停止执行脚本，并且在状态显示里显示用户信息。注意: 你可以用于回调函数来实现一些特殊功能。页面回调也可以用 Abort 来实现特殊目的。 Call1函数名 | :标记名 调用“函数名”函数。如果在 Uninstall 区段，Call 仅能调用以“un.”开头的函数名。如果参数以一个“:”开始则它竟会被认为是一个标记(所以你可以在你的函数里调用一个标记 - 这样大概不会使用太多的时间)。 ClearErrors清除错误位标记。 GetCurrentAddress1用户变量(输出) 获取当前指令的地址(GetCurrentAddress)并且把它保存到用户输出变量。该用户变量可以传递到 Call 或 Goto。 GetFunctionAddress1用户变量(输出) 函数名 获取函数地址并且把它保存到用户输出变量。该用户变量可以传递到 Call 或 Goto。注意如果你 Goto 一个由 GetFunctionAddress 输出的地址，你的函数将不能返回(当你 Goto 的函数要返回时，你应该立即返回)。 GetLabelAddress1用户变量(输出) 标记 获取标记地址并且把它保存到用户输出变量。该用户变量可以传递到 Call 或 Goto。需要注意的是你可能仅能从你的函数里随标记调用该指令，但是你可以从任何地方调用它(可能存在不稳定因素)。需要注意的是如果你调用(Call)了 GetLabelAddress 的输出，那么直到它返回时才会被执行(明确或隐含在一个函数的结尾)，然后你将回到 Call 指令的状态。. Goto1要跳转的标记 | +偏移| -偏移| 用户变量(目标) 如果指定了标记，则跳转到“要跳转的标记:”。 如果指定了 +偏移 或 -偏移 ，跳转会根据偏移指令相对的跳转。Goto +1 跳转到下一条指令，Goto -1 跳转到上一条指令，等等。 如果指定了用户变量，则跳转到绝对地址(通常你可以从一个函数比如 GetLabelAddress 来取得该值)。编译器位标计命令和 SectionIn 不是指令所以跳转对它们无效。 IfAbort1退出时要跳转的标记 [不是退出时要跳转的标记] 如果调用退出时它将“返回” true。这种情况可能发生在当一个文件不能创建(或覆盖)失败而用户选择退出时或者当用户手动退出时。该函数仅能在 instfiles 页面的离开函数里调用。 IfErrors1错误时跳转 [没有错误时跳转] 检测并清除错误位标计，如果设了错误位标计，则跳转到“错误时跳转”，否则跳转到“没有错误时跳转”。错误位标计由其它指令在产生一个错误是设置的(比如试图去删除一个正在使用的文件)。 IfFileExists1要检测的文件 文件存在时跳转 [文件不存在时跳转] 检测“要检测的文件”是否存在(可以用通配符，或目录)，并当文件存在时跳转到“文件存在时跳转”，否则跳转到“文件不存在时跳转”。如果你要检测目标是文件还是目录请使用 IfFileExists 目录*.* IfRebootFlag1[已设时跳转] [未设时跳转] 至少需要一个参数。检测重启位标计，如果设置了重启位标计则跳转到“已设时跳转”，否则跳转到“未设时跳转”。重启位标计可以在 Delete 河 Rename，或手动设定的 SetRebootFlag 指令里设置。 IfSilent1[静默安装时跳转] [非静默安装时跳转] 至少需要一个参数。检测静默安装位标计，如果安装程序是静默安装时跳转到“静默安装时跳转”，否则跳转到“非静默安装时跳转”。静默安装位标计可以由 SilentInstall、SilentUninstall、SetSilent 和用户使用 &#x2F;S 命令行启动来设置。 IntCmp值 1 值 2 相等时跳转 [值 1 小时跳转] [值 1 大时跳转]比较两个整数 值 1 和 值 2。如果 值 1 和 值 2 相等，则跳转到“相等时跳转”，否则如果 值 1 &lt; 值 2，跳转到“值 1 小时跳转”，否则如果 值 1 &gt; 值 2 ，跳转到“值 1 大时跳转”。 IntCmpU1值1 值2 相等时跳转 [值1小时跳转] [值1大时跳转] 比较两个无符号整数 值 1 和 值 2。如果 值 1 和 值 2 相等，则跳转到“相等时跳转”，否则如果 值 1 &lt; 值 2，跳转到“值 1 小时跳转”，否则如果 值 1 &gt; 值 2 ，跳转到“值 1 大时跳转”。比较时作为无符号整数来比较。 MessageBox1消息框选项列表 消息框文本 [/SD 返回] [检测返回值 跳转到] [检测返回值 2 跳转到 2] 显示一个包含“消息框文本”的消息框。“消息框选项列表”必须为下面的一个或多个，多个使用 | 来隔开(例如 MB_YESNO|MB_ICONSTOP)。 MB_OK - 显示 OK 按钮 MB_OKCANCEL - 显示 OK 和取消按钮 MB_ABORTRETRYIGNORE - 显示退出、重试、忽略按钮 MB_RETRYCANCEL - 显示重试和取消按钮 MB_YESNO - 显示是和否按钮 MB_YESNOCANCEL - 显示是、否、取消按钮 MB_ICONEXCLAMATION - 显示惊叹号图标 MB_ICONINFORMATION - 显示信息图标 MB_ICONQUESTION - 显示问号图标 MB_ICONSTOP - 显示终止图标 MB_TOPMOST - 使消息框在最前端显示 MB_SETFOREGROUND - 设置前景 MB_RIGHT - 右对齐文本 MB_DEFBUTTON1 - 默认为按钮 1 MB_DEFBUTTON2 - 默认为按钮 2 MB_DEFBUTTON3 - 默认为按钮 3 MB_DEFBUTTON4 - 默认为按钮 4 “检测返回值”可以为 0(或空，或保留关闭)，或下列之一: IDABORT - 退出按钮 IDCANCEL - 取消按钮 IDIGNORE - 忽略按钮 IDNO - 否按钮 IDOK - OK 按钮 IDRETRY - 重试按钮 IDYES - 是按钮 如果消息框的返回值为“检测返回值”，则安装程序执行跳转。 用 &#x2F;SD 来指定一个上面列出的返回值当在安装程序静默安装时作为返回值。 Return从一个函数或区段返回。 Quit使得安装程序立即退出。在调用 Quit 后，安装程序将退出(将没有回调函数可以运行)。 SetErrors设置错误位标计。 StrCmp1字串1 字串2相同时跳转 [不相同时跳转] 比较(不区分大小写)“字串 1”和“字串 2”。如果两者相等，跳转到“相同时跳转”，否则跳转到“不相同时跳转”。 文件指令FileClose句柄关闭一个由 FileOpen 打开的文件句柄。 FileOpen1用户变量(句柄输出) 文件名 打开模式 打开一个“文件名”的文件，并且把句柄设置为句柄输出变量。“打开模式”为“r”(只读)“w”(写入，文件的所有内容将被清空)或“a”(附加，保持文件内容并写入)其中之一。在所有的打开模式里，文件指针都置于文件起始位置。如果文件不能被打开，则句柄输出变量为空，并置一个错误位标计。 如果没有指定绝对路径则使用当前路径。当前路径由 SetOutPath 设置。如果之前没有使用 SetOutPath 则当前路径为 $EXEDIR。 FileRead1句柄 用户变量(输出) [最大长度] 读取一个由 FileOpen 打开的文件的字串。该字串一直读取到新的一行为止(或回车新行)。或直到读取到空的字节为止，或者直到读取的字串满足了“最大长度”(如果指定了的话)。字串的最大长度被限定在 1024 字节之内。如果读取到了文件的结尾却没有有效的数据则输出字串被清空，并置一个错误位标计。 FileReadByte1句柄 用户变量(输出) 读取一个由 FileOpen 打开的文件的字节。读取的字节作为一个整数(0-255)保存在输出变量里。如果读取到了文件的结尾却没有有效的数据则输出字串被清空，并置一个错误位标计。 FileSeek1句柄 偏移 [模式] [用户变量(新位置)] 定位一个由 FileOpen 打开的文件。 如果“模式”忽略或指定为“SET”，则文件指针定位到“偏移”。 如果“模式”指定为“CUR”，则文件指针向后移动“偏移”。 如果文件指定为“END”，则指针定位到相对于文件结尾 EOF(End of file)处。 如果指定了最后一个参数“用户变量(新位置)”，则新文件位置将保存在该变量中。 FileWrite1句柄 字串 写入一个字串到 FileOpen 打开的文件。如果写入时产生了错误，则置一个错误位标计。 FileWriteByte1句柄 字串 写入“字串”解释为整数的值到 FileOpen 打开的文件。当然你也可以直接输入整数值。下面的代码写入一个“回车&#x2F;换行” - 输入到文件。 12FileWriteByte 文件句柄 &quot;13&quot;FileWriteByte 文件句柄 &quot;10&quot; 如果写入时产生了错误，则置一个错误位标计。需要注意的是整数仅低字节被使用，例如: 写入 256 和写入 0 一样，等等。 FindClose1句柄 关闭一个由 FindFirst 打开的搜索。 FindFirst1用户变量(句柄输出) 用户变量(文件输出) 文件匹配格式 按“文件匹配格式”执行一个搜索，把第一个查找到的文件放置到“用户变量(文件输出)”。也可以把搜索的句柄放到“用户变量(句柄输出)”。如果未找到任何文件，则输出都被设为空，并且置一个错误位标计。比较好的用法是使用 FindNext 和 FindClose。需要注意的是“用户变量(文件输出)”不带有路径。 FindNext1句柄 用户变量(文件输出) 继续一个由 FindFirst 开始的搜索。句柄应该为 FindFirst 返回的值。如果搜索已完成(没有更多文件)，“用户变量(文件输出)”将被设为空，并且置一个错误位标计。需要注意的是“用户变量(文件输出)”不带有路径。 卸载程序指令WriteUninstaller1[路径\\]可执行文件名.exe 由指定的文件名(路径为可选项)写入卸载程序。仅在一个安装区段或函数里有效，并且你的脚本里必须有一个卸载区段。也可以参考卸载配置。你可以调用一次或多次来写入一个或多个卸载程序(副本)。 混合指令GetInstDirError1用户变量(错误输出) 用于目录选择页面的离开函数。读取位标计设置看“DirVerify leave”是否已使用。可能的值: 0: 无错误 1: 无效的安装目录 2: 目标驱动器没有足够的空间 InitPluginsDir初始化插件目录($PLUGINSDIR)，当之前没有初始化时。 SetShellVarContextcurrent|all 设置 $SMPROGRAMS 的内容或其他命令解释程序目录。如果设为“current”(默认值)，则使用当前用户的命令解释程序目录。如果设为“all”，则使用所有用户的命令解释程序目录。所有用户目录可能不能被所有的操作系统支持。如果所有用户的目录找不到则使用当前用户代替。请考虑一个普通用户或游客是否有正确的权限在所有用户目录里操作。仅仅管理员才有完全的权限访问所有用户目录。你可以用 UserInfo 来查看用户身份。详细信息请查看 Contrib\\UserInfo\\UserInfo.nsi 样例。 Sleep休眠时间单位为毫秒在安装程序里暂停执行“休眠时间单位为毫秒”时间。“休眠时间单位为毫秒”可以是一个变量，例如 “$0”或一个数字，比如 “666”。 字串操作指令StrCpy1用户变量(目标) 字串 [最大长度] [起始偏移] 把用户变量 $x 设为“字串”。注意“字串”可以包含另一个变量，或该用户变量会被设置(可以用来连接字串等等)。如果指定了“最大长度”则目标字串的长度为“最大长度”(如果“最大长度”是负数，则会从字串尾部截去“最大长度”的绝对值个字符)。如果指定了起始偏移，则字串偏移到该处作为起始(如果“起始偏移”是负数，则会从尾部开始偏移)。 StrLen1用户变量(长度输出) 字串 把用户变量 $x 设为“字串”的长度值。 堆栈支持Exch1[用户变量 | 堆栈索引] 当不指定参数时，交换堆栈顶部的两个单元。当指定了一个参数并且是一个用户变量时，交换堆栈顶部的单元和该参数。当指定了一个参数并且是正整数时，Exch 将会交换堆栈顶部那项和根据参数从堆栈顶部偏移到指定的那项。如果堆栈里没有足够的项来完成交换时，会产生一个致命的错误(来帮助你调试你的代码)。 Pop1用户变量(输出) 从堆栈里弹出一个字串到用户变量 $x。如果堆栈是空的，则会置一个错误位标计。 Push1字串 把一个字串压入堆栈。该字串可随后从堆栈里弹出。 整数支持IntFmt1用户变量(输出) 格式 数字字串 用“格式”格式格式化“数字字串”中的数字，并把输出设为用户变量 $x。例如格式化字串包含 “%08X” “%u” IntOp1用户变量(输出) 值1 操作 [值2] 联合值 1 和(取决于操作)值 2 到用户变量 $x。操作定义为下列之一: + 值 1 加 值 2 - 值 1 减 值 2 *值 1 乘 值 2 / 值 1 除 值 2 % 由 值 2 取 值 1 的模 | 值 1 和 值 2 二进制“或” &amp; 值 1 和 值 2 二进制“与” ^ 值 1 和 值 2 二进制“异或” ~ 按位取反 值 1(例如 7 变为 4294917288) ! 逻辑取反 值 1(例如 7 变为 0) || 值 1 和 值 2 逻辑“或” &amp;&amp; 值 1 和 值 2 逻辑“与” 重启指令Reboot重启电脑。请小心使用该指令。如果重启时产生了错误，该函数会置一个错误位标计并继续。如果重启成功，该指令不返回任何值。 SetRebootFlagtrue|false设置重启位标计为“true”或“false”。 安装记录指令LogSeton|off设置安装记录到 $INSTDIR\\install.log 将会发生。 在你调用该函数之前， $INSTDIR 必须有一个值，否则该指令将无效。需要注意的是在编译的时候编译配置文件(config.h)必须设置 NSIS_CONFIG_LOG (默认未设置)来支持该指令。关于重新编译 NSIS 的详细信息请查看 编译 NSIS 源代码。 LogText文本如果启用了安装程序记录，插入“文本”文本到记录文件。 区段管理SectionSetFlags1区段索引 区段位标计 设置区段位标计。位标计为 32 位整数。第一位(低位)代表该区段当前是否选中，第二位代表该区段是否是一个子区段(请不要修改这里除非你真的很了解)，第三位代表该区段是否是一个子区段的结尾(同样，请不要修改)，第四位代表该区段文字是否描黑显示，第五位代表该区段是否是只读，第六位代表子区段是否自动展开。如果指定了超出范围的区段则会置一个错误的位标计。 SectionGetFlags1区段索引 用户变量(输出) 找回该区段的位标计。位标计的描述请看上面。如果指定了超出范围的区段则会置一个错误的位标计。 SectionSetText1区段索引 区段文本 设置“区段索引”区段的描述。要设置一个子区段的文本，你必须在文本前加 -。如果文本设为 “”则该区段将会隐藏。如果指定了超出范围的区段则会置一个错误的位标计。 SectionGetText1区段索引 区段文本 把“区段索引”区段的描述保存在输出变量。如果区段为隐藏，则保存的变量为空。如果指定了超出范围的区段则会置一个错误的位标计。 SectionSetInstTypes1区段索引 安装类型 设置“区段索引”区段在安装类型中的默认启用状态。需要注意的是区段索引从零开始。“安装类型”的每一位都是一个告诉该区段是否属于这个安装类型的位标计。例如，如果你有 3 个安装类型并且你希望第一个区段包含在类型 1 和 3，则命令如下: 1SectionSetInstTypes 0 5 因为 5 的二进制值为 “00000101”。 如果指定了超出范围的区段则会置一个错误的位标计。 SectionGetInstTypes1区段索引 用户变量(输出) 找回一个区段的安装类型位标计。如果处理输出的描述请看上面的关于 SectionSetInstTypes 的解释。如果指定了超出范围的区段则会置一个错误的位标计。 SectionSetSize区段索引 新容量设置“区段索引”区段的容量。需要注意的是索引从零开始。容量的单位为 KB 且仅支持整数。 SectionGetSize区段索引 用户变量获得“区段索引”区段的容量并把值保存在指定的用户变量里。需要注意的是索引从零开始。 SetCurInstType安装类型索引设置当前安装类型。如果使用了一个超出范围的安装类型则不会置一个错误位标计。 SetCurInstType 仅在当前存在组件选择页面时才有效。 GetCurInstType用户变量获取当前的安装类型并保存在指定的用户变量里。${NSIS_MAX_INST_TYPES} (默认为 32)的值意味着选择了自定义安装类型。 InstTypeSetText1安装类型索引 文本 设置指定的安装类型的文本。如果设置的文本为空则移除该安装类型。通过使用一个以前未使用的“安装类型索引”序号你可以创建一个新的安装类型。要在新的安装类型里添加、删除区段请看 SectionSetInstTypes。与 SectionIn 不同的是该索引从零开始，这意味着第一个安装类型索引为 0。 InstTypeGetText1安装类型索引 用户变量 获取指定的安装类型的文本。 用户界面指令BringToFront使安装程序窗口可见并把它带到其他窗口的最前端。如果一个应用程序已经执行且显示在安装程序的前面，BringToFront 将把安装程序带回到焦点。 CreateFont1用户变量(句柄输出) 字体名 [高] [宽] [/ITALIC] [/UNDERLINE] [/STRIKE] 创建一个字体并把句柄保存在用户变量里。关于不同参数的更多信息请看 MSDN 页面关于 Win32 API 函数 CreateFont()。 DetailPrint用户信息添加“用户信息”字串到安装程序的安装信息查看窗口。 EnableWindow1窗口句柄(HWND) (1|0) 对指定的窗口或控件允许或禁止鼠标和键盘输入。可用的状态为 0(禁止) 或 1(允许)。 FindWindow1用户变量(窗口句柄输出) 窗口类 [窗口标题] [windowparent] [childafter] 查找一个窗口。类似于 Win32 FindWindowEx()。由窗口类来查找(和&#x2F;或窗口标题，如果指定的话)。如果指定了 windowparent 或 childafter，则查找会受到限制。如果窗口类或窗口标题指定为 “”，则它们将不能用于查找。如果窗口未找到，用户变量将返回 0 值。要实现旧式 FindWindow 行为，请和 SendMessage 一起使用。 GetDlgItem1用户变量(输出) 窗口句柄 控件ID 在指定的对话框上根据控件 ID 获得控件句柄。如果你想获得安装程序内部的控件句柄，请先使用 FindWindow 用户变量(窗口句柄输出) &quot;#32770&quot; &quot;&quot; $HWNDPARENT 来获取窗口句柄。 HideWindow隐藏安装程序。 IsWindow1窗口句柄 是窗口时跳转 [不是窗口时跳转] 如果“窗口句柄”是一个窗口，则跳转到“是窗口时跳转”，否则跳转到“不是窗口时跳转”(如果指定了的话)。 SendMessage1窗口句柄 消息 第一个消息参数 第二个消息参数 [用户变量(返回值)] [/TIMEOUT=毫秒] 发送消息到“窗口句柄”。如果指定了一个用户变量 $x 作为最后一个参数(或在 &#x2F;TIMEOUT 之前的最后一个参数)，SendMessage 的返回值将保存在该变量里。需要注意的是当指定“消息”时你只能用消息的整数值。如果你需要发送字串请使用“STR:字串”作为“第一个消息参数”或“第二个消息参数”。 WM_CLOSE 16 WM_COMMAND 273 WM_USER 1024 Include WinMessages.nsh 来获得所有 Windows 消息定义。 要发送一个字串参数的话，在参数前面加入 STR: ，例如: “STR:一些字串” 。 使用 &#x2F;TIMEOUT&#x3D;毫秒 来指定持续时间，单位为毫秒。 SetAutoClose1true|false 取代默认的窗口自动关闭位标计(由 AutoCloseWindow 指定，且对于写在程序为 false)。指定“true”将使得安装程序在安装完成时立即关闭窗口，或者“false”来使它需要手动关闭。 SetBrandingImage1[/IMGID=对话里的 ID 项] [/RESIZETOFIT] 位图.bmp 把当前位图作为标志图像显示。如果没有指定 IMGID 则使用第一个找到的图像控件，或由 AddBrandingImage 建立的图像控件。需要注意的是位图必须预先存在于当前用户的机器上。可以先使用 File 指令把它释放。如果指定了 &#x2F;RESIZETOFIT 则图像会自动改变尺寸到图像控件的大小。如果你使用了 AddBrandingImage 你可以得到它的大小，通过编译你的脚本并察看 AddBrandingImage 的输出，它会告诉你控件的大小。SetBrandingImage 在 .onInit 或 .onInit 调用的函数里无效。 SetDetailsView1show|hide 显示或隐藏详细信息，取决于你使用什么样的参数。它可以覆盖默认的由 ShowInstDetails 设定的详细信息察看属性。 SetDetailsPrint1none|listonly|textonly|both|lastused 为命令输出的状态信息设置一个显示模式。None 为不输出，listonly 仅在列表框显示，textonly 仅在状态条显示，both 则两者都显示(默认)。对于释放很多小的文件，推荐使用 textonly(特别在 Win9X 下启用了平滑卷动)。 SetCtlColors1句柄 [/BRANDING] [文本颜色] [transparent|背景颜色] 对一个静态控件、编辑控件、按钮或一个对话框设置一个背景颜色和文本颜色。使用 GetDlgItem 来获取控件的句柄。如果要使得控件透明你可以指定“transparent”作为背景颜色值。你也可以指定 &#x2F;BRANDING 并带或不带文本颜色和背景颜色来使得控件完全灰白(或其他你选择的颜色)。在 MUI 里用来显示标志牌。 SetSilent1silent | normal 设置安装程序为静默模式或普通模式。关于静默安装的详细信息请看 SilentInstall。仅能在 .onInit 里使用。 ShowWindow1窗口句柄 显示状态 设置一个窗口的显示程度。可能的“显示状态”和 Windows ShowWindow 函数相同。SW_* 常量定义于 Include\\WinMessages.nsh。 多语言指令LoadLanguageFile1语言文件.nlf 给一个语言表的结构载入一个语言文件。所有的语言文件在 Contrib\\Language Files 在你插入一个语言文件后 ${LANG_langfile} 将会被定义为语言 ID(例如: ${LANG_ENGLISH} 将会被定义为 1033)。你可以把它用于 LangString、LicenseLangString、LangDLL 和 VIAddVersionKey。 LangString1名称 语言ID 字串 定义一个使用多种语言的字串。这意味着它的值将对于每个语言都不同。这允许你方便的使安装程序多语言化，不需要再脚本里使用大量的开关语句。 每一个语言字串都有一个特定的名字和一个用于安装程序的分配给每一个语言的值。他们可以在脚本里用于任何运行时字串。要使用一个语言字串你所需要做的就是把 $(LangString_名称) 插入到你想插入字串的地方。 注意: 不像定义使用花括号 - {} 一样，语言字串使用圆括号 - ()。 如果你想在 .onInit 函数里更改语言，需要注意的是在 .onInit 里的语言字串将仍旧使用基于用户的默认 Windows 语言检测到的语言，因为语言的初始化在 .onInit 之后。 总是在你的脚本里为所有语言设置语言字串。 如果你把语言 ID 设为 0，则使用 LangString 或 LoadLanguageFile 最后使用的语言。 使用例子: 12345LangString message $&#123;LANG_ENGLISH&#125; &quot;英语信息&quot;LangString message $&#123;LANG_FRENCH&#125; &quot;法语信息&quot;LangString message $&#123;LANG_KOREAN&#125; &quot;韩文信息&quot;MessageBox MB_OK &quot;A translated message: $(message)&quot; LicenseLangString1名称 语言ID 许可文件路径 用法和 LangString 一样，但它仅从一个文本、RTF 文件载入字串并且定义一个特别的仅能用于 LicenseData 的 LangString。","tags":["NSIS"],"categories":["NSIS"]},{"title":"NSIS教程(2)-完整属性","path":"/post/1923360270.html","content":"本文列举了 NSIS 支持的所有属性，以供查阅。 描黑加粗部分的为默认值。 一、常规属性AddBrandingImage1(left|right|top|bottom) (width|height) [填充] 在安装程序顶部、底部、左边、右边添加一个标志图像。它的大小将由指定的宽&#x2F;高、安装程序的宽&#x2F;高和安装程序字体确定。最终的大小不一定就是你需要的，请看输出命令来得到实际大小。因为这取决于安装程序字体，所以你应该在 AddBrandingImage 前使用 SetFont。默认的填充值为 2。 AllowRootDirInstalltrue|false控制是否允许安装在驱动器根目录，或者共享网络。把它设为“true”可以改变这个安全行为，此安全行为可以防止用户选择 C:\\ 或 \\\\Server\\Share 来作为安装(或卸载)目录。对于另外的可定制的目录选择页面。 AutoCloseWindowtrue|false设置当安装完成的时候窗口是否自动关闭。该属性可以不理会一个使用了 SetAutoClose 的区段。 BGGradient[off|(顶部颜色 底部颜色 [文本颜色|notext])] 指定是否使用一个渐变的背景窗口。如果为“off”，安装程序将不显示背景窗口，如果无指定参数，则使用默认的黑蓝渐变，或者指定顶部颜色或底部颜色来得到一个渐变的背景。顶部颜色和底部颜色使用 RRGGBB 格式(十六进制，就像 HTML 那样，但略去了 #，因为 # 用于注释)。你也可以指定“文本颜色”，该颜色会显示“Name”指定的名称在左上角，或者你不需要文本时使用“notext”来关闭文本显示。 BrandingText&#x2F;TRIM(LEFT|RIGHT|CENTER) 文本设置显示在安装窗口底部的文本(默认为“Nullsoft Install System vX.XX”)。如果设为空字串(“”)则使用默认值；设为” “(一个空格)则显示空白。如果你不知道哪个适合你，那就保留默认值吧，这样可以使每个人知道你使用的 NSIS 版本。使用 &#x2F;TRIMLEFT、&#x2F;TRIMRIGHT 或 &#x2F;TRIMCENTER 来裁剪控制大小到字串大小。 Caption标题当使用一个外部的 PageEx 区块:设置安装程序标题条文本。默认为“Name 安装”，当使用了 Name 指令指定了名称时。你可以把它替换为“我的安装程序”或其他。如果你指定为空字串(“”)，则使用默认值(你也可以指定为” “来使用一个空白字串)。 当使用一个内部的 PageEx 区块:设置当前页面的子标题。 ChangeUI1对话框 ui_file.exe 使用 ui_file.exe 里相同资源 ID 的一个对话框替换对话框(IDD_LICENSE、IDD_DIR、IDD_SELCOM、IDD_INST、IDD_INSTFILES、IDD_UNINST 或 IDD_VERIFY)。你也可以指定“all”作为一个对话框，当你想从同一个 UI 文件里一次载入替换全部 7 个对话框时。一些 UI 的例子请看位于 NSIS 目录下的 Contrib\\UIs。 IDD_LICENSE 必须包含 IDC_EDIT1 (RICHEDIT 控件)。 IDD_DIR 必须包含 IDC_DIR (编辑框)，IDC_BROWSE (按钮) 和 IDC_CHECK1 (选择框)。 IDD_SELCOM 必须包含 IDC_TREE1 (SysTreeView32 control)，和 IDC_COMBO1 (组合框)。 IDD_INST 必须包含 IDC_BACK (按钮)，IDC_CHILDRECT (静态控制其他所有对话大小)，IDC_VERSTR (静态文本框)，IDOK (按钮)，和 IDCANCEL (按钮)。如果该对话框有一个图象控件(静态 SS_BITMAP 样式)，那么它将被用于 SetBrandingImage 作为默认值。 IDD_INSTFILES 必须包含 IDC_LIST1 (SysListView32 控件), IDC_PROGRESS (msctls_progress32 控件)，和 IDC_SHOWDETAILS (按钮)。 IDD_UNINST 必须包含 IDC_EDIT1 (编辑框)。 IDD_VERIFY 必须包含 IDC_STR (静态文本框)。 CheckBitmap1bitmap.bmp 指定一个位图为用于组件选择页面树形列表选择框的图像。 该位图应该为 96x16 像素大小，不能多于 8 位位深(256 色)且包括六个用于不同状态(次序为: 鼠标点击反白边缘、未选时、已选时、子区段未选时、未选且只读、已选且只读)的 16x16 图像。使用粉红色为覆盖颜色(该区域实际时为透明)。 CompletedText文本当指定了参数时替换在安装结束时的默认文本(“完成”)。否则，使用默认值。 ComponentText1[文本 [子文本] [子文本 2]] 用来更改组件选择页面的默认文本。 文本: 控件上的文本，到安装图标的右边。 子文本: 安装类型选择控件的文本。 子文本 2: 安装类型选择控件下面、组件列表左边的文本。 如果字串为空(“”)则使用默认文本。 CRCCheckon|off|force指定安装前安装程序是否对自身执行一个 CRC。注意，如果用户使用了 &#x2F;NCRC 命令行参数，且你没有指定“force”参数时，不会执行 CRC，这样有可能导致用户安装一个损坏的安装程序。 DetailsButtonText1show details text 指定参数时替换默认详细信息按钮文本“显示细节”，未指定参数时使用默认值。 DirText1[文本] [子文本] [浏览按钮文本] [浏览对话框文本] 用来更改目录选择页面的默认文本。 文本: 控件上面的文本，右延至安装图标。 子文本: 在目录选择框架上的文本。 浏览按钮文本: 浏览按钮上的文本。 浏览对话框文本: 在点击“浏览”按钮后“浏览目录”对话框上的文本。 如果字串为空(“”)则使用默认文本。 DirVar1用户变量(目录输入输出) 指定用哪个变量来保存所选的目录。该变量也会保存默认值。这样可以很方便的建立两个不同的目录选择页面而不需要频繁的读取、写入 $INSTDIR。默认的变量为 $INSTDIR。它只能用于 PageEx 来确定目录变量和 uninstConfirm 页面。 DirVerifyauto|leave如果使用了“DirVerify leave”，则当安装目录无效或磁盘空间不够用时下一步按钮将会被禁止并且你可以在离开函数里使用 GetInstDirError 来读取被设置的位标计。 FileErrorText文件错误文本替换当文件不能写入时显示的默认文本。该文本可以包含一个代表文件名的 $0($0 会被临时更改为该值)。例如: “文件 $0$\\r$ 不能写入$\\r$ 祝你下次好运。”。 Icon1[路径\\]图标文件.ico 设置安装程序的图标。在图标文件里的每一个图标将会被包含在图标文件里。注意如果你在安装程序和卸载程序里使用了不同的图标，那么它们的文件大小和结构必须匹配否则安装程序的构建将会失败。 InstallButtonText安装按钮文本如果指定了参数，则会把默认的“安装”按钮文本替换为你指定的文本。 InstallColors1/windows | (前景色 背景色) 设置安装信息屏幕颜色(默认为 00FF00 000000)。使用 RRGGBB 格式(十六进制，就像 HTML 那样，但略去了 #，因为 # 用于注释)。注意指定了 “&#x2F;windows” 作为唯一的参数，将使用默认的 Windows 颜色。 InstallDir默认安装目录设定默认的安装目录。查看变量一段得到可用于该字串的变量(尤其是 $PROGRAMFILES)。注意该字串中最后一个 \\ 后面的部分会被保留，当用户在安装时选择“浏览”并取得新的目录字串时，该部分会自动附加在后面(要禁止该行为你需要在目录字串后面添加一个额外的 \\ ，但是你要使用引号把目录字串括起来以避免被认为是断行处理)。如果没有起作用的话，还是使用浏览按钮吧。 InstallDirRegKey根键 子键 键名该属性让安装程序去检测一注册表里的一个字串，如果该字串可用那么把它用来作为安装目录。如果预置了该属性，当指定的注册表键可用时它会越过 InstallDir 指定的字串，否则使用默认的 InstallDir 指定值。查询注册表时，该命令将自动截去引号(如“”C:\\program files\\poop” “%1””，可得“C:\\program files\\poop”)。如果该字串以“.exe”结尾，它还会自动移去字串里的文件名部分(如“C:\\program files\\poop\\poop.exe”，将得到“C:\\program files\\poop”)。对于更多高级的安装目录配置，可在 .onInit 函数里设定 $INSTDIR。[译者注: 事实上它还可以自动截取如“”C:\\program files\\poop\\poop.exe” “%1””而得到“C:\\program files\\poop”，这样你只要知道了某个程序关联的文件类型，就可以直接用它获得该程序的安装目录。比如 InstallDirRegKey HKCR “FlashGet.Document\\shell\\open\\command” “” 即可获得网际快车的安装目录] InstProgressFlags1[位标计 [...]] 有效的位标计值为“smooth”(平滑进度条)或“colored”(把进度条着色为 InstallColors 设定的颜色)。例如: “InstProgressFlags” (默认老式 Windows 外观)，”InstProgressFlags smooth” (新式平滑外观)，”InstProgressFlags smooth colored” (新式平滑外观并着色)。注意: 当安装程序运行在 Windows XP 且使用了新式主题时“smooth”或“colored”都不能与 XPStyle on 共用。 InstType1安装类型名称 | /NOCUSTOM | /CUSTOMSTRING=字串 | /COMPONENTSONLYONCUSTOM 把一个安装类型添加到安装类型列表里，或禁止自定义安装类型。最多可以增加到 32 类，每一个类型都需要指定安装类型名称。如果以“un.”作前缀那么它就是一个卸载程序安装类型。你可以使用在运行时可以处理的用户变量而不是难以改变的代码来作为安装类型名称，这样你可以动态的改变安装类型的名称。另一个在运行时更改 InstType 名称的方法是 InstTypeSetText 命令。所不同的是使用 InstTypeSetText 你可以保留你自己宝贵的用户变量。第一个类型为默认类型(通常为“常规”)。每一个类型都是以编号的，从 1 开始。查看 SectionIn 可以知道这些编号怎么使用。如果指定了 &#x2F;NOCUSTOM 开关，那么“自定义”类型就会被禁止，那么用户就必须选择一个已经定义的安装类型。作为选择，如果指定了 &#x2F;CUSTOMSTRING 开关，那么该开关的参数将会替代“自定义”安装类型文本。作为选择，如果指定了 &#x2F;COMPONENTSONLYONCUSTOM 位标计，那么组件列表仅在选择了“自定义”安装类型的时候才显示。 LicenseBkColor颜色 | &#x2F;gray | &#x2F;windows设置许可协议数据的背景颜色。颜色使用 RRGGBB 格式(十六进制，就像 HTML 那样，但略去了 #，因为 # 用于注释)。默认为“&#x2F;gray”。你也可以使用“&#x2F;windows”来使用 Windows 操作系统定义的颜色。 LicenseData1许可文件.(txt|rtf) 指定一个用户读取许可协议的文本文件或 RTF 文件。如果没有许可协议需要显示那么可以忽略它。注意该文件必须是 DOS 文本格式(\\r )。要定义多语言许可协议请使用 LicenseLangString。 如果你使用 RTF 文件来显示许可协议推荐使用写字板来编辑 RTF 文件而不是使用微软的 Word。使用写字板可以得到更小的文件。 LicenseForceSelection(checkbox [接受文本] | radiobuttons [接受文本] [拒绝文本] | off) 指定显示的许可协议是否必须被接受。可以使用单选框或互斥按钮的形式。默认情况下“下一步”按钮是禁止的并且只能在钩选了单选框选择了正确的互斥按钮后才可以进入下一步。如果指定了 off 则默认情况下“下一步：按钮是可用的。 LicenseText1[文本 [按钮文本]] 用来更改许可协议页面的默认文本。 文本: 控件上方的文本，右延至安装图标。 按钮文本: “我同意”按钮上的文本。 如果字串为空(“”)则使用默认文本。 MiscButtonText1[上一步文本 [下一步文本] [退出按钮文本] [关闭按钮文本]] 替换这四个(上一步、下一步、退出、关闭)按钮的默认文本。如果留空参数，将使用默认值代替。 Name1名称 [双与名称] 设置安装程序的名称。名称通常用来显示产品的名称比如“我的程序”或“蓝色网际的程序”。如果在名称里有一个或多个与符号(&amp;)，把第二个参数设为与第一个相同，有 &amp; 的地方使用两个 &amp; 来表示。例如你的产品名称为“foo &amp; bar2000”，那么使用: Name “foo &amp; bar2000” “foo &amp;&amp; bar2000”如果你的安装程序名称里有 &amp; 符号并且对名称使用了一个 LangString，那么你还需要创建另一个含有双 &amp; 字符的名称作为第二个参数。 OutFile1[路径\\]安装程序.exe 指定 MakeNSIS 要写入安装程序的输出文件。仅仅是 MakeNSIS 要写入的文件，它不会对安装程序的内容有任何影响。 SetFont字体名 字体大小设置安装程序字体大小。请记住你选择的字体在用户的机器上也要有，不要使用只有你自己有的字体。 ShowInstDetailshide|show|nevershow 设置是否显示安装详细信息。你可以设为“hide”来默认隐藏详细信息但用户可以查看，或“show”来默认显示详细信息，或“nevershow”来阻止用户查看任何信息。注意区段里可以使用 SetDetailsView 来越过它的设置。 ShowUninstDetailshide|show|nevershow设置是否显示卸载详细信息。你可以设为“hide”来默认隐藏详细信息但用户可以查看，或“show”来默认显示详细信息，或“nevershow”来阻止用户查看任何信息。注意区段里可以使用 SetDetailsView 来越过它的设置。 SilentInstallnormal|silent|silentlog 指定安装程序是否静默安装。如果它为“silent”或“silentlog”，所有位标计为 SF_SELECTED 的区段都会被安装而不做提示(你可以使用 SectionSetFlags 来设定区段的位标计)，安装程序本身没有任何屏幕输出(而脚本仍可以显示某些特定的输出，使用 MessageBox 的 &#x2F;SD 参数来指定静默安装时默认的返回值)。注意如果设置为“normal”且用户运行时使用了 &#x2F;S (区分大小写)命令行参数时就相当于 SilentInstall 设置为“silent”一样。注意: 也可以看 LogSet。 SilentUnInstallnormal|silent指定卸载程序是否静默安装。如果它为“silent”，卸载区段会被运行而不做提示，卸载程序本身没有任何屏幕输出(而脚本仍可以显示某些特定的输出，使用 MessageBox 的 &#x2F;SD 参数来指定静默安装时默认的返回值)。注意如果设置为“normal”且用户运行时使用了 &#x2F;S (区分大小写)命令行参数时就相当于 SilentUnInstall 设置为“silent”一样。注意: 也可以看 LogSet。 SpaceTexts1[需要空间文本 [可用空间文本]] 如果指定了参数，将会取代所需空间和可用空间文本(默认为“所需空间: ”和“可用空间: ”)。如果指定了“none”则不会显示空间提示文本。 SubCaption1[页面代号 子标题] 取代每一个安装程序页面(0&#x3D;”: 许可协议”,1&#x3D;”: 安装选项”,2&#x3D;”: 安装目录”, 3&#x3D;”: 正在安装”, 4&#x3D;”: 安装完成”)的子标题。如果指定了空字串(“”)，将使用默认值(你也可以指定 “ “ 来使用一个空白字串)。 你也可以在一个 PageEx 区块内部使用 Caption 来设置一个子标题(或取代默认值)。 UninstallButtonText文本替换卸载程序上默认为“卸载”的按钮文本。如果无指定参数，将使用默认的文本。也可以看 WriteUninstaller (替换 UninstallEXEName)。 UninstallCaption标题设置卸载程序标题条上显示的文本。默认情况下，它为由 Name 命令指定的“卸载名称”。你可以取代它为“我的应用程序卸载”或其他。如果指定了空字串(“”)，将使用默认值(你也可以指定 “ “ 来使用一个空白字串)。 UninstallIcon1[路径\\]图标.ico 设置卸载程序的图标。这个图标文件必须和安装程序的图标结构一致。 UninstallSubCaption页面代号 子标题取代每一个卸载程序页面(0&#x3D;”: 卸载确认”,1&#x3D;”: 正在卸载”,2&#x3D;”: 卸载完成”)的子标题。如果指定了空字串(“”)，将使用默认值(你也可以指定 “ “ 来使用一个空白字串)。 你也可以在一个 PageEx 区块内部使用 Caption 来设置一个子标题(或取代默认值)。 UninstallText1文本 [子文本] 指定卸载程序确认页面上的文本。 文本: 控件上方的文本 子文本: 下面卸载定位的文本 WindowIconon|off设置是否显示安装程序的图标。 XPStyleon|off设置是否把 XP 外观添加到安装程序里。当运行在 Windows XP 时一个 XP 外观使得安装程序控件使用新的 XP 样式。这个设定也会影响卸载程序。 二、编译器位标计下面的命令可以改变编译器如何去创建代码和压缩数据。这些命令在脚本的任何地方都有效，并且影响着该命令下的每一行(直道被另一个命令取代)。 AllowSkipFileson|off该命令指定用户是否可以略过文件。如果 SetOverwrite 设为 on(默认)且当安装程序打开一个文件往里边写入东西失败时一个用户可以选择略过文件。如果使用了 off 则不会显示允许用户略过文件的忽略按钮，这样用户只能选择退出安装程序(退出按钮)或重试打开该文件写入(重试按钮)。如果使用了 on 则用户可以选择跳过文件(同时置一个错误位标计 - 看 SetOverwrite)。 FileBufSize缓冲大小以 MB 为单位该命令设置编译器内部文件缓冲大小。该命令允许你通过限制一个所给的文件一次性读入内存的多少来控制编译器的内存的使用。因为编译器需要输入和输出，所以文件缓冲时需要使用两倍指定的内存大小。该命令不会限制需要另一组内存大小的压缩器缓冲，也不会限制编译器另外的内部缓冲，因为这两个缓冲正常情况下无论如何也不能达到 1MB。指定一个很小的数字可能会降低执行效率。指定过大的数字可能会耗尽系统的资源并迫使编译器退出编译处理。该默认值为 32MB。 SetCompressauto|force|off 该命令设置由安装程序使用来决定数据是否应该被压缩的压缩位标计。典型的 SetCompress 位标计将影响它后面的命令，并且脚本文件中的最后一个 SetCompress 命令也决定了是否压缩安装信息区段和卸载数据。如果压缩位标计为“auto”，那么仅当压缩后大小小于未压缩时文件才会被压缩。如果压缩位标计为“force”，则始终使用压缩。如果压缩位标计为“off”，则不使用压缩(这样可以加快编译速度)。 注意该选项当使用了固实压缩方式后无效，固实压缩方式在使用 BZIP2 和 LZMA 时默认启用。 SetCompressorzlib|bzip2|lzma该命令设置了安装程序压缩文件、数据使用的压缩算法。 支持三种压缩方式: ZLIB，BZIP2 和 LZMA。 ZLIB (默认值) 使用收缩算法，是一个快速简单的方法。默认的压缩级别它消耗大约 300 KB 内存。 BZIP2 通常比 ZLIB 的压缩率好，但是稍微慢了一点并且内存的使用也多一点。默认的压缩级别它消耗大约 4 MB 内存。 LZMA 是一个压缩率比较理想的新式压缩方式。它的解压速度非常快(在 2 GHz 的 CPU 上能达到 10-20 MB&#x2F;s 的速度)，但是压缩速度很慢。解压时内存的使用量是字典的大小加上一些 KB，默认值为 8 MB。 SetCompressorDictSize字典大小以 MB 为单位设置使用 LZMA 压缩器时的字典大小(默认为 8 MB)。 SetDatablockOptimizeon|off该命令决定编译器是否优化数据区块。数据区块的优化首先由编译器检查要添加到数据区块的数据是否已经存在了，如果已存在，只需要简单的作为引用来添加(会保留一小部分大小)。非常强烈的推荐保留该选项为 on。 SetDateSaveon|off该命令设置了由 File 命令使用的保存文件日期、时间位标计来决定是否保留最后上次写入文件的日期和时间，它可以在安装时储存下来。有效的位标计为“on”和“off”。“on”为默认。 SetOverwriteon|off|try|ifnewer|ifdiff|lastused 该命令设置了由 File 命令使用的覆盖位标计来决定目标文件已存在时是否覆盖。如果覆盖位标计为“on”，则目标文件被覆盖(这个是默认值)。如果覆盖位标计为“off”,则已存在的文件不会被覆盖。如果覆盖位标计为“try”，文件仅当可以被覆盖时(就是说假如文件不能写入，它会自动略过而不需要用户决定)才会覆盖目标文件。如果覆盖位标计为“ifnewer”，则仅当已存在的文件比新文件旧时才会覆盖目标文件。如果覆盖位标计为“ifdiff”，则仅当已存在的文件比新文件旧或新时才会覆盖目标文件。注意在“ifnewer”或“ifdiff”模式下，目标文件的日期都会被设为新文件的日期，而不管 SetDateSave 是怎么设置的。 SetPluginUnloadmanual|alwaysoff 该命令设置了 CallInstDLL 和插件调用(插件名::函数)的不卸载插件位标计。 该命令设为“alwaysoff”相当于每个 CallInstDLL 和插件调用都使用了 &#x2F;NOUNLOAD 参数。该命令设为“manual”则仅当你指定了 &#x2F;NOUNLOAD 参数时才不卸载。 版本信息VIAddVersionKey1[/LANG=语言 ID] 键名 值 在文件属性的版本表格里添加一个字段。既可以是由系统提供的的一个字段也可以是一个用户定义的字段。随后的这些字段由系统提供: ProductName Comments CompanyName LegalCopyright FileDescription FileVersion ProductVersion InternalName LegalTrademarks OriginalFilename PrivateBuild SpecialBuild 这些字段名称由目标系统翻译，而用户自定义的字段则无翻译。 VIProductVersion1[版本字串_X.X.X.X] 在文件属性版本表格的顶部添加产品版本号。","tags":["NSIS"],"categories":["NSIS"]},{"title":"NSIS教程(1)-基础语法","path":"/post/409779091.html","content":"NSIS（Nullsoft Scriptable Install System）是一个开源的 Windows 平台安装包制作程序。NSIS 通过它定义的脚本语言来描述安装包的行为和逻辑的。 一. 环境搭建从http://nsis.sourceforge.net/Download下载 NSIS 安装进行安装。 使用 NSIS 生成安装包的大致流程如下： 使用任意文本编辑器（如 Notepad++、Visual Studio Code）开发 NSIS 脚本 使用安装目录内的 makensisw.exe 程序编译 NSIS 脚本生成安装包。 makensisw.exe 只提供编译脚本的功能，不能对脚本进行调试，调试脚本全靠错误提示和经验。 二. NSIS 脚本结构一个 NSIS 脚本可以包括：安装程序属性、页面、区段等。 对于一个最简单的 NSIS 脚本，只有 OutFile属性和区段（一个或多个）是必须的，OutFile 属性用于指定 NSIS 编译生成安装包的路径。 1234OutFile &quot;Simple.exe&quot;Section &quot;Installer Section&quot;SectionEnd 保存上面脚本到任意 .nsi 文件，并使用 makensisw.exe 打开改脚本进行编译，出现下图表示编译成功，成功之后会在脚本当前目录看到输出的 Simple.exe 文件。 如果编译失败，makensisw.exe 会在输出窗口提示失败原因。 需要注意：如果 NSIS 脚本内包含中文等非 ASCII 字符，需要将脚本保存为 ANSI 编码格式，而不能保存为 UTF8 格式。 2.1 安装程序属性安装程序的属性用于控制安装程序的外观，比如指定哪些页面出现在安装程序里，在每个页面的每个部分显示什么文本，安装程序的名称（如上面脚本中的 OutFile），使用什么样的图标，默认安装目录等等。 安装程序属性可以在除了区段和函数以外的任何地方设置。 可以理解为安装程序属性是设置给 NSIS 编译器看的，这些属性的值在编译时都已经确定了，所以除了 InstallDir 以外，其他安装程序属性都不允许使用变量（除了$\\r和$ ）。 2.2 完整的安装程序属性见 NSIS教程(2)-完整属性 2.2 页面页面分为NSIS内置的向导页面和用户自定义页面。 一个非静默安装程序需要页面来指导用户运行安装程序，可以通过Page命令或PageEx（PageEx 提供了更多高级的设置）命令来设定哪个页面显示。 页面实际的显示顺序和它在 NSIS 脚本中定义的顺序是一致的。 2.2.1 内置向导页面：NSIS 内置的向导页面有： license：许可证页面。 components： 组件选择页面，每个可见的区段都可以作为一个组件给用户选择是否安装。你可以只使用一个区段来构建安装包，但是如果你想要使用组件页来让用户选择可选的组件，那你就需要使用多个区段。 directory： 安装目录选择页面。 instfiles： 安装过程页面。 uninstConfirm： 卸载确认页面。 不同的页面，有不同的属性。 内置页面语法如下： 1Page (license|components|directory|instfiles|uninstConfirm) [预置函数] [显示函数] [离开函数] 每个内建的页面都有三个回调函数（预置函数、显示创建函数和离开函数），预置函数在页面被创建之前被直接的调用，显示函数在页面被创建后且在显示之前被直接调用，离开函数在用户按下下一页按钮之后并且在页面离开之前被直接调用。 如： 123PageEx license LicenseData &quot;license.rtf&quot; #可以是txt或rtf文件格式PageExEnd 2.2.2 自定义页面创建自定义页面语法： 1page custom [创建函数] [离开函数] [标题] 自定义页面只有两个回调函数（创建函数和离开函数），创建函数在需要创建页面时被调用，离开函数在用户按下”下一页”按钮之后并且在页面离开之前被直接调用。 2.2.3 页面回调函数每个内建的页面都有三个回调函数：一个预置函数、一个显示创建函数和一个离开函数。 预置函数在页面被创建之前被直接的调用，显示函数在页面被创建后且在显示之前被直接调用，离开函数在用户按下下一页按钮之后并且在页面离开之前被直接调用。 预置函数允许使用 Abort 来略过该页面。 显示函数允许使用 CreateFont、SetCtlColors、SendMessage 和其他来调整页面的用户界面。 离开函数允许使用 Abort 来强制用户停留在当前页面。 一个自定义的页面仅有两个回调函数，一个是必须的创建页面，另一个离开函数的作用就和内建页面的离开函数一样。 例如： 123456789101112131415161718192021222324252627Page license skipLicense &quot;&quot; stayInLicensePage custom customPage &quot;&quot; &quot;: 自定义页面&quot;Page instfilesFunction skipLicense MessageBox MB_YESNO &quot;你想略过许可页面吗？&quot; IDNO no Abort no:FunctionEndFunction stayInLicense MessageBox MB_YESNO &quot;你想停留在许可页面吗？&quot; IDNO no Abort no:FunctionEndFunction customPage GetTempFileName $R0 File /oname=$R0 customPage.ini InstallOptions::dialog $R0 Pop $R1 StrCmp $R1 &quot;cancel&quot; done StrCmp $R1 &quot;back&quot; done StrCmp $R1 &quot;success&quot; done error: MessageBox MB_OK|MB_ICONSTOP &quot;InstallOptions error:$\\r$ $R1&quot; done:FunctionEnd 2.3 区段（Section）在安装程序中用户需要安装许多东西，如安装源码、附加插件、脚本样例或其他。里面的每个安装组件都有它自己的代码块，当用户选择了安装该组件，那么安装程序就会执行对应的代码。 在 NSIS 脚本里，这些代码称为区段。每个可见的区段都可以作为一个组件给用户选择是否安装（区段也可以设置属性对用户隐藏，默认安装，让用户无法选择是否安装）。 NSIS 脚本对区段的数量没有限制，你可以只使用一个区段来构建安装包，但是如果你想要使用组件页来让用户选择可选的组件，那你就需要使用多个区段了。 卸载程序也可以有多个区段，但卸载程序区段名前要加上前缀un.，因为卸载程序是要被编译成是一个单独的 exe 的，所以要对编译器指明哪些内容（如区段）需要被编译进卸载程序，因此需要特殊前缀。 区段名为空、遗漏或者以一个 “-“ 开头，那么它将是一个隐藏的区段，用户也不能在组件选择页面选择是否禁止。 三. NSIS 语法3.1 语法概述 单行注释用井号#或分号;，跨行注释用可以用 C&#x2F;C++中注释语法； 数字常量可以用十进制、十六进制(0x 为前缀)、八进制(0 为前缀)表示，颜色用类似 html 的中 RGB 表示法，但去井号”#”。 字符串常量可以用引号引用，特殊的字符可以使用美元符号”$”作前缀来转义。美元符号、换行、回车、制表符都是特殊字符，需要转义，他们在NSIS中可以写成： $$, $ , $r, $\\t NSIS 脚本用行尾的反斜杠”&quot;表示下一行和当前行逻辑上是同一行。 3.2 常量和变量NSIS 的变量和常量都是全局的，且大小写敏感的，NSIS 中变量和常量都是弱类型的。 常用和变量的引用方式都是$&#123;VAR_NAME&#125;或$VAR_NAME。 使用!define方式定义常量，如：!define PRODUCT_NAME &quot;网易云音乐&quot; 使用Var方式定义变量，如：Var a NSIS 内置了 20 个已注册的变量：$0 ~ $9 和 $R0 ~ $R9，这些变量不需要声明就可以使用，一般用于参数传递等。 另外，NSIS 内置一个堆栈，使用push和pop命令来入栈和出栈，可以使用堆栈来暂存数据。 关于变量的赋值，NSIS 中不能直接使用=来赋值，需要借助StrCpy来实现，如： 12StrCpy $0 &quot;hello&quot;StrCpy $0 123 3.3 函数3.3.1 函数定义123Function 函数名FunctionEnd 函数名以“.”开头的(例如 “.Whatever”)一般作为回调函数保留。函数名以“un.”开头的函数将会被创建在卸载程序里。因此，普通安装区段和函数不能调用卸载函数，而卸载区段和卸载函数也不能调用普通函数。NSIS 函数声明中不支持参数定义，如果需要传递参数，可以使用内置的 20 个变量或者堆栈的方式。 3.3.2 函数调用1Call 函数名 3.4 宏除了函数之外，NSIS 还支持定义宏，NSIS 中的宏支持定义参数。 3.4.1 宏定义123!macro 宏名 [参数1] [参数n]!macroend 3.4.2 宏调用1!insertmacro 宏名 [参数1] [参数n] 3.5 指令NSIS 内置了很多指令，这些指令提供了安装包常用了功能，如果这些指令无法满足需求，用户也可以自己开发插件。 NSIS 支持的指令列表见：NSIS教程(3)-完整指令 NSIS 指令使用中比较特别的在于跳转，比如执行失败跳转到哪里，成功跳转到哪里。以MessageBox指令为例（[]为可选项）： 1MessageBox 消息框选项列表 消息框文本 [/SD 返回] [检测返回值 跳转到] [检测返回值2 跳转到2] 下面的用法表示如果 MessageBox 返回 IDYES，则+2，即跳转到该指令的下 2 条执行（+1 该指令的下 1 条，+2 就为该指令的下 2 条），/SD IDYES表示安装包采用静默安装方式时默认用户选择了IDYES: 1MessageBox MB_ICONQUESTION|MB_YESNO &quot;你确实要完全删除网易云音乐，及其所有组件吗?&quot; /SD IDYES IDYES +2 IDNO +1 四. NSIS 界面NSIS 提供的界面分为传统界面（Classic UI）、现代界面（Modern UI）。 4.1 传统界面 4.2 现代界面 4.3 自定义界面我们可以使用第三方界面库（如 duilib, Qt）自己绘制安装包的界面，这样灵活度更大，可以开发出类似 QQ 那样的安装界面。在此之前需要掌握 NSIS 的插件开发技巧。","tags":["NSIS"],"categories":["NSIS"]},{"title":"WebRTC线程模型","path":"/post/795351407.html","content":"在介绍WebRTC的线程模型之前，先介绍Webrtc线程模型中用到的几个简单、常用的模块或函数。 一、 设置线程名12345678910111213141516171819202122//platform_thread.ccvoid SetCurrentThreadName(const char* name) &#123;#if defined(WEBRTC_WIN) struct &#123; DWORD dwType; LPCSTR szName; DWORD dwThreadID; DWORD dwFlags; &#125; threadname_info = &#123;0x1000, name, static_cast&lt;DWORD&gt;(-1), 0&#125;; __try &#123; ::RaiseException(0x406D1388, 0, sizeof(threadname_info) / sizeof(DWORD), reinterpret_cast&lt;ULONG_PTR*&gt;(&amp;threadname_info)); &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123; &#125;#elif defined(WEBRTC_LINUX) || defined(WEBRTC_ANDROID) prctl(PR_SET_NAME, reinterpret_cast&lt;unsigned long&gt;(name));#elif defined(WEBRTC_MAC) || defined(WEBRTC_IOS) pthread_setname_np(name);#endif&#125; 二、 原子操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//atomicops.hclass AtomicOps &#123; public:#if defined(WEBRTC_WIN) // Assumes sizeof(int) == sizeof(LONG), which it is on Win32 and Win64. static int Increment(volatile int* i) &#123; return ::InterlockedIncrement(reinterpret_cast&lt;volatile LONG*&gt;(i)); &#125; static int Decrement(volatile int* i) &#123; return ::InterlockedDecrement(reinterpret_cast&lt;volatile LONG*&gt;(i)); &#125; static int AcquireLoad(volatile const int* i) &#123; return *i; &#125; static void ReleaseStore(volatile int* i, int value) &#123; *i = value; &#125; static int CompareAndSwap(volatile int* i, int old_value, int new_value) &#123; return ::InterlockedCompareExchange(reinterpret_cast&lt;volatile LONG*&gt;(i), new_value, old_value); &#125; // Pointer variants. template &lt;typename T&gt; static T* AcquireLoadPtr(T* volatile* ptr) &#123; return *ptr; &#125; template &lt;typename T&gt; static T* CompareAndSwapPtr(T* volatile* ptr, T* old_value, T* new_value) &#123; return static_cast&lt;T*&gt;(::InterlockedCompareExchangePointer( reinterpret_cast&lt;PVOID volatile*&gt;(ptr), new_value, old_value)); &#125;#else static int Increment(volatile int* i) &#123; return __sync_add_and_fetch(i, 1); &#125; static int Decrement(volatile int* i) &#123; return __sync_sub_and_fetch(i, 1); &#125; static int AcquireLoad(volatile const int* i) &#123; return __atomic_load_n(i, __ATOMIC_ACQUIRE); &#125; static void ReleaseStore(volatile int* i, int value) &#123; __atomic_store_n(i, value, __ATOMIC_RELEASE); &#125; static int CompareAndSwap(volatile int* i, int old_value, int new_value) &#123; return __sync_val_compare_and_swap(i, old_value, new_value); &#125; // Pointer variants. template &lt;typename T&gt; static T* AcquireLoadPtr(T* volatile* ptr) &#123; return __atomic_load_n(ptr, __ATOMIC_ACQUIRE); &#125; template &lt;typename T&gt; static T* CompareAndSwapPtr(T* volatile* ptr, T* old_value, T* new_value) &#123; return __sync_val_compare_and_swap(ptr, old_value, new_value); &#125;#endif&#125;; 使用示例 123bool MessageQueue::IsQuitting() &#123; return AtomicOps::AcquireLoad(&amp;stop_) != 0;&#125; 三、线程模型原理WebRTC的线程功能由Thread类提供。Thread继承于消息队列MessageQueue，这样WebRTC中的每个线程都有了自己的消息循环，外部可以向该线程的消息循环Post消息Message，然后该线程轮询从消息循环Get到消息后处理消息。 UML如下： 四、Message和MessageQueueMessage用于定义单个消息： posted_from标记改条消息发送自哪个函数，一般都是直接用RTC_FROM_HERE宏来赋值； message_id32位整数，消息ID； pdata消息携带的数据指针，虽然定义MessageData*类型，但也可以等同于void*。 ts_sensitive消息的敏感时间点。在使用MessageQueue::Post等方法发送消息时，若time_sensitive == true则设置ts_sensitive = TimeMillis() + kMaxMsgLatency 即当前时间 + 最大消息延迟时间。当消息被从队列中取出的时间大于该时间，则会打印警告日志。 phandler消息处理器，MessageHandler接口的指针。用户需要继承该类，并重写其OnMessage虚函数。 MessageQueue实现了WebRTC中消息队列的功能，如Post方法用于添加消息；Get方法用于从队列取出消息，若队列没有消息则一直等待，具体的等待和唤醒的方式通过SocketServer的Wait和WakeUp来实现。 SocketServer是一个纯抽象类，NullSocketServer和PhysicalSocketServer都派生自该类。NullSocketServer比较简单，没有创建SOCKET，只处理本地事件（CreateEvent系列函数）；PhysicalSocketServer会创建SOCKET，并可以处理网络事件（WSACreateEvent系列函数）。在单纯的线程模型中，SocketServer只用于处理等待和唤醒操作。 五、 ThreadThread类提供了2个静态函数（Create, CreateWithSocketServer）来构造Thread实例。 不建议使用new Thread()调用默认构造函数的方式，代码注释中已经给出了解释： 123456// DEPRECATED.// The default constructor should not be used because it hides whether or// not a socket server will be associated with the thread. Most instances// of Thread do actually not need one, so please use either of the Create*// methods to construct an instance of Thread.Thread(); 下面是Thread类构造的大致过程： 12345678910111213+-----------------------------+| || new Thread(SocketServer*) || |+---+-------------------------+ | | | +-----------------------------------+ | | | +---------&gt; new MessageQueue(SocketServer*) | | | +-----------------------------------+ 构造完Thread实例之后，调用Start来启动线程，框架会根据Start函数的Runnable参数是否为NULL来判断是需要运行用户自定义的Runnable-&gt;Run(), 还是运行默认ProcessMessage去循环从消息队列中获取消息来处理。 若运行用户自定义的Runnable-&gt;Run()，则用户需要继承rtc::Runnable去重载Run()； 若运行默认的ProcessMessage，则用户则需要定义Message，向线程中Post该Message，让线程来执行。 流程如下： 1234567891011121314151617181920212223242526272829303132333435363738+---------------------------+| || Thread-&gt;Start(Runnable*) || |+-+-------------------------+ | | +-------------------------+ | | | +-------&gt; CreateThrad(PreRun) | | | +-------------------------+ |Runnable* is NULL? | | +------------------+ | | | +-----------&gt; Runnable-&gt;Run() | | | | | +------------------+ | | | +------------------+ | | | +-----------&gt; Thread-&gt;Run() | | | +-+----------------+ | | | +--------------------------+ | | | +----&gt; Thread-&gt;ProcessMessage() | | | +--+-----------------------+ | | +--------------------------------+ | | | +-----&gt; Loop call MessageQueue-&gt;Get() | | | +--------------------------------+ 六、 示例6.1 实现Runnbale1234567891011121314151617181920212223#include &quot;rtc_base/thread.h&quot;class MyTask : public rtc::Runnable &#123;public: MyTask(const std::string &amp;name) : name_(name) &#123; &#125;protected: void Run(Thread* thread) &#123; std::cout &lt;&lt; &quot;task name: &quot; &lt;&lt; name_ &lt;&lt; std::endl; std::cout &lt;&lt; &quot;my thread id: &quot; &lt;&lt; thread-&gt;GetId() &lt;&lt; std::endl; &#125;private: std::string name_;&#125;;int main()&#123; std::unique_ptr&lt;rtc::Thread&gt; thread = rtc::Thread::Create(); thread-&gt;Start(new MyTask(&quot;task1&quot;)); getchar(); return 0;&#125; 6.2 发送Message123456789101112131415161718192021222324class MyTaskHandler : public rtc::MessageHandler &#123;public: MyTaskHandler(const std::string &amp;name) : name_(name) &#123; &#125;protected: void OnMessage(Message* msg) &#123; std::cout &lt;&lt; &quot;task name: &quot; &lt;&lt; name_ &lt;&lt; std::endl; std::cout &lt;&lt; &quot;my thread id: &quot; &lt;&lt; Thread::Current()-&gt;GetId() &lt;&lt; std::endl; &#125;private: std::string name_;&#125;;int main()&#123; std::unique_ptr&lt;rtc::Thread&gt; thread = rtc::Thread::Create(); thread-&gt;Start(nullptr); thread-&gt;Post(RTC_FROM_HERE, new MyTaskHandler(&quot;task2&quot;), 0, nullptr, false); getchar(); return 0;&#125;","tags":["WebRTC","线程"],"categories":["音视频编程"]},{"title":"Janus的编译部署及配置","path":"/post/3773107387.html","content":"Janus是一个开源的 WebRTC SFU 服务器，可以作为 WebRTC 的一个端将其收到的数据进行转发，同时提供了一些的控制能力。Janus 是基于插件架构的，其功能都是通过一个个插件来提供，我们可以为 Janus 开发插件，来扩展其功能。 一、编译部署Janus 可以方便的在 Linux 和 MacOS 上面编译部署，暂时不支持 Windows 系统，但可以在 Win10 的Windows Subsystem for Linux上编译部署。 1.1 安装依赖项在编译 Janus 之前，需要安装如下依赖项： Jansson libconfig libnice (at least v0.1.15 suggested, master recommended) OpenSSL (at least v1.0.1e) libsrtp (at least v1.5 suggested) usrsctp (only needed if you are interested in Data Channels) libmicrohttpd (only needed if you are interested in REST support for the Janus API) libwebsockets (only needed if you are interested in WebSockets support for the Janus API) cmake (only needed if you are interested in WebSockets and&#x2F;or BoringSSL support, as they make use of it) rabbitmq-c (only needed if you are interested in RabbitMQ support for the Janus API or events) paho.mqtt.c (only needed if you are interested in MQTT support for the Janus API or events) nanomsg (only needed if you are interested in Nanomsg support for the Janus API) libcurl (only needed if you are interested in the TURN REST API support) Janus 的某些插件可能还依赖下面的库： Sofia-SIP (only needed for the SIP plugin) libopus (only needed for the bridge plugin) libogg (needed for the voicemail plugin and&#x2F;or post-processor) libcurl (only needed if you are interested in RTSP support in the Streaming plugin or in the sample Event Handler plugin) Lua (only needed for the Lua plugin) 另外，还需要安装如下工具： GLib pkg-config gengetopt 上面的所有库通常在多数 Linux 发行版中都有提供，可以直接安装。以在Fedora中安装为例： 1234yum install libmicrohttpd-devel jansson-devel \\ openssl-devel libsrtp-devel sofia-sip-devel glib2-devel \\ opus-devel libogg-devel libcurl-devel pkgconfig gengetopt \\ libconfig-devel libtool autoconf automake 需要注意的是，如果你尝试在CentOS上面安装这些依赖项，需要先执行yum install epel-release . 在Ubuntu和Debian系统上，执行如下命令： 1234aptitude install libmicrohttpd-dev libjansson-dev \\ libssl-dev libsrtp-dev libsofia-sip-ua-dev libglib2.0-dev \\ libopus-dev libogg-dev libcurl4-openssl-dev liblua5.3-dev \\ libconfig-dev pkg-config gengetopt libtool automake 在低版本的系统上(如低于Ubuntu 14.04 LTS版本)，可能没有提供的libopus的预编译包，如果遇到这种情况，需要手动编译opus. 1.1.1 libnicelibnice虽然在大多数系统上都提供了预编译包，但可能会导致一些问题，所以建议先卸载老版本，然后下载 libnice 的master的版本，手动编译： 12345git clone https://gitlab.freedesktop.org/libnice/libnicecd libnice./autogen.sh./configure --prefix=/usrmake &amp;&amp; sudo make install 确保已经移除老版本，否则会产生冲突。如果需要保留多个版本的 libnice，可以执行pkg-config --cflags --libs nice确保 Janus 可以找到正确的版本，如果无法找到，可以在编译 Janus 之前设置PKG_CONFIG_PATH环境变量，如export PKG_CONFIG_PATH=/path/to/libnice/lib/pkgconfig 1.1.2 libcurl如果后期需要编译安装 Janus 的Event Handler插件，还需要安装 libcurl 库的开发版本，在 Fedora&#x2F;CentOS 上通常为libcurl-devel，在 Ubuntu&#x2F;Debian 上通常为libcurl4-openssl-dev。 1.1.3 libsrtp假如已经安装了libsrtp 1.5 之前的版本，需要先卸载，然后手动安装1.5x 或 1.6x版本。因为 1.4x 版本会导致 WebRTC 出现一些问题。以安装2.2.0版本为例： 12345wget https://github.com/cisco/libsrtp/archive/v2.2.0.tar.gztar xfv v2.2.0.tar.gzcd libsrtp-2.2.0./configure --prefix=/usr --enable-opensslmake shared_library &amp;&amp; sudo make install Janus 的 configure 脚本可以自动检测到使用的 libsrtp 的版本，如果同时安装了 1.5x 和 2.x 版本，会优先使用 2.x 版本，如果想强制使用 1.5 或者 1.6 版本，可以在 configure 命令传入--disable-libsrtp2 参数。 假如安装的是 x86&#x2F;x64 版本的 libsrtp，需要在 configure 命令传入--libdir=/usr/lib64参数。 1.1.4 BoringSSL如果需要使用BoringSSL代替OpenSSL （因为使用BoringSSL可以使用--enable-dtls-settimeout功能），可以通过如下命令手动安装，并且在 configure 命令传入--enable-boringssl参数： 12345678910111213141516git clone https://boringssl.googlesource.com/boringsslcd boringssl# Don&#x27;t barf on errorssed -i s/&quot; -Werror&quot;//g CMakeLists.txt# Buildmkdir -p buildcd buildcmake -DCMAKE_CXX_FLAGS=&quot;-lrt&quot; ..makecd ..# Installsudo mkdir -p /opt/boringsslsudo cp -R include /opt/boringssl/sudo mkdir -p /opt/boringssl/libsudo cp build/ssl/libssl.a /opt/boringssl/lib/sudo cp build/crypto/libcrypto.a /opt/boringssl/lib/ Janus 默认 BoringSSL 安装在/opt/boringssl，如果不是，可以通过--enable-boringssl=/path/to/boringssl指定。 1.1.5 usrcstp1234git clone https://github.com/sctplab/ccd usrsctp./bootstrap./configure --prefix=/usr &amp;&amp; make &amp;&amp; sudo make install Note: 假如安装的是 x8&#x2F;x64 版本的 usrcstp，需要在 configure 命令传入 --libdir=/usr/lib64 参数。 1.1.6如果需要提供 websockets 信令支持，还需要安装 libwebsockets 库： 123456789git clone https://libwebsockets.org/repo/libwebsocketscd libwebsockets# If you want the stable version of libwebsockets, uncomment the next line# git checkout v2.4-stablemkdir buildcd build# See https://github.com/meetecho/janus-gateway/issues/732 re: LWS_MAX_SMPcmake -DLWS_MAX_SMP=1 -DCMAKE_INSTALL_PREFIX:PATH=/usr -DCMAKE_C_FLAGS=&quot;-fpic&quot; ..make &amp;&amp; sudo make install 假如 libwebsockets.org 无法访问, 可以将第一行替换为:git clone https://github.com/warmcat/libwebsockets.git 1.1.7 文档如果需要编译 Janus 文档，需要安装如下工具： Doxygen Graphviz Fedora: 1yum install doxygen graphviz Ubuntu&#x2F;Debian: 1aptitude install doxygen graphviz 二、编译在安装完依赖项之后，使用下面命令获取 Janus 代码： 1234- [ ] git clone https://github.com/meetecho/janus-gateway.git cd janus-gateway 然后使用sh autogen.sh命令生成 configure 文件。最后，执行 configure 和编译命令开始编译： 123./configure --prefix=/opt/janus --enable-boringsslmakemake install 编译完成之后，使用make configs命令生成默认配置文件，配置文件位于/opt/janus/etc/janus/janus.jcfg。需要注意的是，每次执行make configs命令都会将/opt/janus/etc/janus/janus.jcfg文件还原为默认配置。 三、运行、测试我们可以先不修改任何配置，将 Janus 运行起来，然后使用测试 html，测试一下效果。执行如下命令，运行 Janus： 1/opt/janus/bin/janus Janus 启动完成之后，我们另寻一台客户机，将 Janus 源码下载下来，修改janus-gateway\\html\\echotest.js文件中server变量为：&quot;ws://47.93.47.150:8188&quot;，如： 1234567var server = null;if(window.location.protocol === &#x27;http:&#x27;) server = &quot;http://&quot; + window.location.hostname + &quot;:8088/janus&quot;;else server = &quot;https://&quot; + window.location.hostname + &quot;:8089/janus&quot;;server = &quot;ws://47.93.47.150:8188&quot;; 在浏览器中打开echotest.html，点击“Start”即可看到效果。 如果无法连接成功，可能是因为iceServers默认使用的是 google 的 turn 服务器，国内无法访问导致，可以参考 如何搭建WebRTC的TURN服务器 搭建自己的 TURN 服务器。","tags":["WebRTC","Janus"],"categories":["音视频编程"]},{"title":"WebRTC添加选择音频输入输出设备功能","path":"/post/2143630083.html","content":"我们先来看看 WebRTC 中提供音频设备输入输出功能的类结构： 从上图中我们看到： AudioDeviceModule接口类是音频设备模型的基类，该接口类及其子类并不提供任何针对音频的实际操作，实际操作都是由AudioDeviceGeneric接口类的子类来提供。 AudioDeviceGeneric接口类是音频设备实际操作（如录音、播放、声音控制等）的基类，然后根据平台不同由不同的类来实现具体操作，如 windows 平台由AudioDeviceWindowsCore来负责实现。 通过代码追踪，我们可以发现 WebRTC 默认使用的是计算机上的系统默认音频输入输出设备，以及默认的视频采集设备，这些我们通过adm_helpers.cc::Init函数来验证（笔者这里使用的是m77分支）： 123456789if (adm-&gt;SetPlayoutDevice(AUDIO_DEVICE_ID) != 0) &#123; RTC_LOG(LS_ERROR) &lt;&lt; &quot;Unable to set playout device.&quot;; return;&#125;if (adm-&gt;SetRecordingDevice(AUDIO_DEVICE_ID) != 0) &#123; RTC_LOG(LS_ERROR) &lt;&lt; &quot;Unable to set recording device.&quot;; return;&#125; 所以即便我们调用了SetPlayoutDevice和SetRecordingDevice也无济于事，因为在此处仍然会被覆盖为使用默认设备。因此我们只需要针对此处进行修改即可，如： 12345678910111213141516171819202122uint16_t playout_index = 0;// 先获取设备index，如果能够获取到，表示外部已经设备设备index，放弃使用默认设备// AudioDeviceModule没有提供Get接口，需要自己添加//if (adm-&gt;GetPlayoutDevice(&amp;playout_index) == 0) &#123; RTC_LOG(LS_INFO) &lt;&lt; &quot;Playout device index: &quot; &lt;&lt; playout_index;&#125; else &#123; if (adm-&gt;SetPlayoutDevice(AUDIO_DEVICE_ID) != 0) &#123; RTC_LOG(LS_ERROR) &lt;&lt; &quot;Unable to set playout device.&quot;; return; &#125;&#125;uint16_t recording_index = 0;if (adm-&gt;GetRecordingDevice(&amp;recording_index) == 0) &#123; RTC_LOG(LS_INFO) &lt;&lt; &quot;Recording device index: &quot; &lt;&lt; recording_index;&#125; else &#123; if (adm-&gt;SetRecordingDevice(AUDIO_DEVICE_ID) != 0) &#123; RTC_LOG(LS_ERROR) &lt;&lt; &quot;Unable to set recording device.&quot;; return; &#125;&#125; 细心的读者可能发现，AudioDeviceModule接口类只定义了 Playout&#x2F;Recoding 设备的Set接口，但没有提供Get接口，因为 WebRTC 默认使用的是系统设备，所以外界不需要知道具体设备 index，故没有提供（笔者使用的是 webrtc m77分支，也许 webrtc 的后续版本会加入该接口）。我们自己也可以很容易的在 AudioDeviceModule 中加入Get接口。 上面的一切修改完毕之后，我们只需要定义一个 adm，作为参数传入到webrtc::CreatePeerConnectionFactory函数即可： 12345678910111213141516171819m_adm = webrtc::AudioDeviceModule::Create( webrtc::AudioDeviceModule::kPlatformDefaultAudio, webrtc::CreateDefaultTaskQueueFactory().get());int32_t ret = m_adm-&gt;Init();Q_ASSERT(ret == 0);if (m_connParameter.audioInputDeviceIndex == -1) &#123; m_adm-&gt;SetEnableRecording(false);&#125; else &#123; ret = m_adm-&gt;SetRecordingDevice(m_connParameter.audioInputDeviceIndex); Q_ASSERT(ret == 0);&#125;if (m_connParameter.audioOutputDeviceIndex == -1) &#123; m_adm-&gt;SetEnablePlayout(false);&#125; else &#123; ret = m_adm-&gt;SetPlayoutDevice(m_connParameter.audioOutputDeviceIndex); Q_ASSERT(ret == 0);&#125;","tags":["WebRTC"],"categories":["音视频编程"]},{"title":"WebRTC在直播领域应用的可行性分析","path":"/post/2016855525.html","content":"一、目前流行的直播技术架构目前主流的直播方案一般采用RTMP架构，首先客户端采集音视频流（如obs studio客户端），然后通过 RTMP 协议将流推到流媒体服务器，最后流媒体服务器将流处理后分发给各个直播客户端。 优点：良好的 CDN 支持，目前主流的 CDN 厂商都有比较成熟的解决方案，另外也有可用的商用 SDK 方便集成，例如声网等，只要集成对应平台的 SDK 即可。由于有 CDN 的支持，相较于端对端的 webrtc 方式，其并发度高，适合多人直播场景。 缺点： 由于 RTMP 协议基于是 TCP 的，相对于基于 UDP 协议的 WebRTC 方式延时较大，所以对于某些低延时场景体验较差，这也是为什么现在直播应用中只能通过弹幕的方式与主播互动，不能实时连麦互动了，因为延迟太大，体验太差。 浏览器没有集成对 RTMP 协议的支持，所以不支持浏览器推流等，需要主播端安装特定的客户端软件。 二、基于端对端的 WebRTC 直播方案严格的讲，基于端对端的 WebRTC 直播方式不属于 WebRTC 常规应用场景，WebRTC 设计之初是用来进行多人实时通信的，所以 WebRTC 代码中集成了很多语音方面的算法，如人声检测等。若将 WebRTC 应用在直播方案中，则主要工作流程如下图所示： 优点： 单纯使用 Javascript 在 Web 端即可实现推流，这对于开发者来说，简化了音视频通信的开发工作，降低了门槛低，不必熟悉流媒体等技术细节；对于主播来说，在浏览器中打开网页即可进行直播，方便快捷。 如果点对点连接成功就可以不通过服务器中转，可以节省服务器带宽费用。 相对于基于 TCP 的 RTMP 推拉流方式，基于 UDP 的 webrtc 方式延时更低。 缺点： PC 端浏览器的性能有局限，如果是 1v1 方式的直播连麦，浏览器尚能支撑；如果同时进行多人直播连麦，则浏览器需要同时给多人推流，这对于浏览器来说恐难支撑。 虽然目前浏览器提供的 WebRTC Javascript API 越来越多，但一旦现有 API 无法满足需求，则单纯的依靠 JavaScript 恐难为力（可以修改 WebRTC C++源码，另外开发浏览器客户端提供 Javascript 接口，但这就失去了主流浏览器支持 WebRTC 的天然优势）。 音视频的传输质量难以保障，尤其在跨地区、跨运营商的情况下，即便可以端对端连接成功，但质量也难保障。 由于端对端连接没有经过服务器，所以无法在服务器端对直播流进行审录制回放等。 三、基于服务器转发的 WebRTC 直播方案基于端对端的 WebRTC 直播方式受限于浏览器性能、连接人数等限制，很难适用于直播场景。为了解决这些问题，从而引入媒体服务器，主播客户端仅传输一路音视频流到媒体服务器，其余客户端通过与媒体服务器建立连接获取音视频流。 目前适用于 WebRTC 的媒体服务器有 SFU 和 MUC 两种类型，两种的差别可以参考： WebRTC的三种架构 虽然两种类型的 WebRTC 服务器架构都有开源的解决方案，也存在一些商用的解决方案，但终究没有基于RTMP+CDN方式的直播方案成熟，这也就意味着一旦采用此方案需要投入更大的研发力度。 基于服务器转发的 WebRTC 直播方案虽然看起来和当前流行的RTMP+CDN方式类似，都经过了服务器的转发，但 WebRTC 基于 UDP 方式延迟可以做到更低，且 WebRTC 内置了很多音视频方面的算法，如 AEC, VAD, VP9 等，并且在网络传输方面做了很多优化工作。","tags":["WebRTC"],"categories":["音视频编程"]},{"title":"如何搭建WebRTC的TURN服务器","path":"/post/2256138363.html","content":"本文讲解如何在 Ubuntu 系统上采用coturn搭建 p2p 打洞服务器，coturn 是一个开源的 stun 和 turn 服务器实现。 1. 安装依赖项123sudo apt-get install opensslsudo apt-get install libsslsudo apt-get install libevent-dev 2. 下载 coturn 源码编译安装12git clone https://github.com/coturn/coturn.git./configure &amp;&amp; make &amp;&amp; make install 3. 编辑配置安装完之后，编辑\\usr\\local\\etc\\turnserver.conf配置文件： 12345listening-device=eth0listening-port=3478external-ip=47.93.42.10 #公网IPuser=jeff:123456 #用户名密码realm=rtctest 4. 启动 coturn1turnserver -a -f -v -r rtctest 5. 客户端连接 coturn 服务器webrtc::PeerConnectionFactoryInterface::CreatePeerConnection函数传入的RTCConfiguration 参数如下： 123456789webrtc::PeerConnectionInterface::RTCConfiguration config;config.sdp_semantics = webrtc::SdpSemantics::kUnifiedPlan;config.enable_dtls_srtp = true;webrtc::PeerConnectionInterface::IceServer server;server.urls.push_back(&quot;stun://47.93.42.10:3478&quot;);server.urls.push_back(&quot;turn://47.93.42.10:3478&quot;);server.username = &quot;jeff&quot;;server.password = &quot;123456&quot;;config.servers.push_back(server);","tags":["WebRTC","TURN","Coturn"],"categories":["音视频编程"]},{"title":"WebRTC的三种架构","path":"/post/2114040426.html","content":"WebRTC 是基于 P2P 的实时通信技术，（如果 P2P 打洞失败，则会使用 TURN 服务器进行数据转发），在有 2 台客户端参与的情况下，网络拓扑结构如图： 一、Mesh 架构在只有 2 个客户端参与情况下，我们可以使用上图的这种拓扑结构。但假如同时有 3 个客户端参与（如多人视频会议），如果还是按照上面的方式，拓扑结构就会变成： 从上图中我们可以看到，在 3 人参与的实时通信中，每个客户端要维持 4 个连接（2 个上行，2 个下行）；同理，如果有 N 个客户端参与，每个客户端就要维持N-1上行，N-1个下行，这样会极大的占用客户端的上行带宽和下行带宽； 这种每个端之前完全使用 P2P 方式架构称之为 Mesh 架构。 二、SFU (Selective Forwarding Unit)架构SFU 架构最核心的特点是把自己 “伪装” 成了一个 WebRTC 的客户端，WebRTC 的其他客户端其实并不知道自己通过 P2P 连接过去的是一台真实的客户端还是一台服务器，我们通常把这种连接称之为 P2S，即：Peer to Server。除了 “伪装” 成一个 WebRTC 的客户端外，SFU 服务器还有一个最重要的能力就是具备one-to-many的能力，即可以将一个客户端的数据转发到其他多个客户端。 这种网络拓扑结构中，无论多少人同时进行视频通话，每个 WebRTC 的客户端只需要连接一个 SFU 服务器，上行一路数据即可，可以极大的减少多人视频通话场景下 Mesh 模型给客户端带来的上行带宽压力。 SFU 服务器跟 TURN 服务器最大的不同是，TURN 服务器仅仅是为 WebRTC 客户端提供的一种辅助的数据转发通道，在 P2P 不通的时候进行透明的数据转发。而 SFU 是 “懂业务” 的， 它跟 WebRTC 客户端是平等的关系，甚至 “接管了” WebRTC 客户端的数据转发的申请和控制。 三、MCU (MultiPoint Control Unit)架构从上述 SFU 的定义可以看到，SFU 这种网络拓扑模型，通过由 SFU Server 来实现 one-to-many ，减轻了多人视频通话场景下每个客户端的上行带宽压力，但是下行依然是多路流，随着通话人数的增大，下行带宽的压力依然会成比例的增大，那能否让下行也只剩一路流呢？—— 可以，通过在服务器端合流后再下发即可解决，如下图所示： 目前，随着 5G 技术的推广，可以预见带宽越来越不是问题，所以 SFU 在未来，可能会更有优势。常见的开源 SFU 服务器有：Licode，Janus，Jitsi，mediasoup，Medooze 等等。 文章参考：WebRTC 开发实践：为什么你需要 SFU 服务器 &gt; webrtc 笔记(3): 多人视频通讯常用架构 Mesh&#x2F;MCU&#x2F;SFU","tags":["WebRTC","Mesh","SFU","MCU"],"categories":["音视频编程"]},{"title":"客户端软件日志输出规范","path":"/post/449620601.html","content":"众所周知，软件日志对问题的排查可以起到至关重要的作用，但在多人协同开发的情况下，可能会导致不同的人使用不同的日志打印风格，导致日志可阅读性不高。纵观各大知名软件的输出日志，无不有着规范的格式，非常利于阅读。 本日志输出规范仅适用于客户端软件，不适用于服务器端软件。 日志中使用英文，不使用中文。 日志文件采用UTF-8编码。 每条日志的第一个单词的首字母大写，而且每条日志以回车换行符(\\r )结束，不需要写句号.，如： 12// RTC_LOG会自动在日志结尾添加\\r RTC_LOG(LS_INFO) &lt;&lt; &quot;Forced software decoder fallback enabled&quot;; 不同语义间使用逗号,分隔，key-value间使用冒号:分隔，如： 123RTC_LOG(LS_INFO) &lt;&lt; &quot;DataChannel received DATA message, sid: &quot; &lt;&lt; sid;RTC_LOG(LS_INFO) &lt;&lt; &quot;Session: &quot; &lt;&lt; session_id() &lt;&lt; &quot; is destroyed&quot;;RTC_LOG(LS_ERROR) &lt;&lt; &quot;Invalid configuration: &quot; &lt;&lt; config_error.message(); 每条日志需要包含日志打印的时间（日期+时间+时区，精确到毫秒）、日志级别。","tags":["日志"],"categories":["项目管理"]},{"title":"流媒体基础概念","path":"/post/737279469.html","content":"一、流媒体协议1.1 RTP (Real-time Transport Protocol)1.1.1 RTP 特征实时传输协议（Real-time Transport Protocol）是一个网络传输层协议，它是由 IETF 的多媒体传输工作小组 1996 年在 RFC 1889 中公布的，它作为因特网标准在 RFC 3550（该文档的旧版本是 RFC 1889）有详细说明，RTP 标准定义了两个子协议：RTP 和 RTCP。 RTP 协议是建立在 UDP 协议上的。 RTP 协议详细说明了在互联网上传递音频和视频的标准数据包格式。RTP 协议常用于流媒体系统（配合 RTCP 协议）、视频会议和视频电话系统（配合 H.263 或 SIP）。 RTP 标准由两个紧密链接部分组成： RTP —- 传送具有实时属性的数据； RTP 控制协议（RTCP）—-监控服务质量并传送正在进行的会话参与者的相关信息。 RTP 本身并没有提供按时发送机制或其他服务质量（QoS）保证，它依赖于底层服务去实现这一过程。RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。RTP 实行有序传送，RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。 1.1.2 RTP 报头RTP 报头格式如下： V：RTP 协议的版本号，占 2 位，当前协议版本号为 2。 P：填充标志，占 1 位，如果 P&#x3D;1，则在该报文的尾部填充一个或多个额外的八位组，它们不是有效载荷的一部分。 X：扩展标志，占 1 位，如果 X&#x3D;1，则在 RTP 报头后跟有一个扩展报头。 CC：CSRC 计数器，占 4 位，指示 CSRC 标识符的个数。 M: 标记，占 1 位，不同的有效载荷有不同的含义，对于视频，标记一帧的结束；对于音频，标记会话的开始。 PT: 有效载荷类型，占 7 位，用于说明 RTP 报文中有效载荷的类型，如 GSM 音频、JPEM 图像等。 序列号：占 16 位，用于标识发送者所发送的 RTP 报文的序列号，每发送一个报文，序列号增 1。接收者通过序列号来检测报文丢失情况，重新排序报文，恢复数据。 时戳(Timestamp)：占 32 位，时戳反映了该 RTP 报文的第一个八位组的采样时刻。接收者使用时戳来计算延迟和延迟抖动，并进行同步控制。 同步信源(SSRC)标识符：占 32 位，用于标识同步信源。该标识符是随机选择的，参加同一视频会议的两个同步信源不能有相同的 SSRC。 特约信源(CSRC)标识符：每个 CSRC 标识符占 32 位，可以有 0 ～ 15 个。每个 CSRC 标识了包含在该 RTP 报文有效载荷中的所有特约信源。 这里的同步信源是指产生媒体流的信源，它通过 RTP 报头中的一个 32 位数字 SSRC 标识符来标识，而不依赖于网络地址，接收者将根据 SSRC 标识符来区分不同的信源，进行 RTP 报文的分组。特约信源是指当混合器接收到一个或多个同步信源的 RTP 报文后，经过混合处理产生一个新的组合 RTP 报文，并把混合器作为组合 RTP 报文的 SSRC，而将原来所有的 SSRC 都作为 CSRC 传送给接收者，使接收者知道组成组合报文的各个 SSRC。 1.2 RTCP (Real-time Transport Control Protocol)实时传输控制协议（Real-time Transport Control Protocol,RTCP）是实时传输协议（RTP）的一个姐妹协议。 RTCP 为 RTP 媒体流提供信道外控制。RTCP 定期在多媒体流会话参加者之间传输控制数据。RTCP 的主要功能是为 RTP 所提供的服务质量提供反馈。 RTCP 收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，时延抖动，单向和双向网络延迟等等。网络应用程序可以利用 RTCP 所提供的信息试图提高服务质量，比如限制信息流量或改用压缩比较小的编解码器。RTCP 本身不提供数据加密或身份认证，其伴生协议SRTCP（安全实时传输控制协议）则可用于此类用途。 WebRTC 内部采用的是 RTC+RTCP 1.3 SRTP &amp; SRTCPSRTP &#x3D; Secure Real-time Transport ProtocolSRTCP &#x3D; Secure Real-time Transport Control ProtocolSRTP 是在实时传输协议 RTP 基础上所定义的一个协议，旨在为单播和多播应用程序中的实时传输协议的数据提供加密、消息认证、完整性保证和重放保护。它是由 David Oran（思科）和 Rolf Blom（爱立信）开发的，并最早由 IETF 于 2004 年 3 月作为 RFC 3711 发布。 1.4 RTSP (Real-time Transport Streaming Protocol)RTSP（Real Time Streaming Protocol），RFC2326，实时流传输协议。RTSP 在体系结构上位于 RTP 和 RTCP 之上，它使用 TCP 或 UDP 完成数据传输。 RTSP 是一种基于文本的应用层协议，在语法及一些消息参数等方面与 HTTP 协议类似。 RTSP 被用于建立的控制媒体流的传输，它为多媒体服务扮演“网络远程控制”的角色。尽管有时可以把 RTSP 控制信息和媒体数据流交织在一起传送，但一般情况 RTSP 本身并不用于传送媒体流数据，媒体数据的传送可通过 RTP&#x2F;RTCP 等协议来完成。 1.5 SDP (Session Description Protocol)会话描述协议（Session Description Protocol 或简写 SDP）描述的是流媒体的初始化参数。此协议由 IETF 发表为 RFC 2327。 SDP 完全是一种会话描述格式，它不属于传输协议。 SDP 用于描述多媒体通信会话，包括会话建立、会话请求和参数协商。SDP 不用于传输媒体数据，只能用于两个通信终端的参数协商，包括媒体类型、格式以及所有其他和会话相关的属性。SDP 以字符串的形式描述上述初始化参数。 可以参考 SDP格式解析 1.6 SIP (Session Initiation Protocol)SIP(Session Initiation Protocol)是一个应用层的信令控制协议。 SIP 用于初始化一个 Session，并负责传输 SDP 包；而 SDP 包中描述了一个 Session 中包含哪些媒体数据，邀请的人等等；当需要被邀请的人都通过各自的终端设备被通知到后，就可以使用 RTSP 来控制特定 Media 的通信，比如 RTSP 控制信息要求开始 Video 的播放，那么就开始使用 RTP（或者 TCP）实时传输数据，在传输过程中，RTCP 要负责 QoS 等。 1.7 RTMP (Real Time Messaging Protocol)RTMP(Real-Time Messaging Protocol 实时消息传送协议)的缩写，它是 Adobe Systems 公司为 Flash 播放器和服务器之间音频、视频和数据传输开发的一个基于TCP的应用层传输协议。这是一个标准的、未加密的实时消息传递协议，默认端口是 1935。 RTMP 是一种有状态协议。 RTMP 协议有效的保证了媒体传输质量，使用户可以观看到高质量的多媒体。RTMP 采用 TCP 协议作为其在传输层的协议，避免了多媒体数据在广域网传输过程中的丢包对质量造成的损失。此外 RTMP 协议传输的 FLV 封装格式支持的 H．264 视频编码方式可以在很低的码率下显示质量还不错的画面，非常适合网络带宽不足的情况下收看流媒体。 当然 RTMP 协议也有一些局限，RTMP 基于 TCP 协议，而 TCP 协议实时性不如 UDP，也非常占用带宽。目前基于 UDP 的 RTMFP 协议能很好的解决这些问题。 RTMPT 封装在 HTTP 请求之中，可穿越防火墙;RTMPS 类似 RTMPT，但使用的是 HTTPS 连接; 1.8 RTMFP (Real Time Media Flow Protocol)RTMFP 是 Adobe 公司开发的一套新的通信协议。 RTMFP 是基于 UDP 的，RTMP 是基于 TCP 的。UDP 在传送直播数据方面比 TCP 还是有较多优势的，比如减少延时，对丢包的容忍，虽然在可靠性上有所损失。与 RTMP 不同, RTMFP 支持 Flash Player 直接发送数据给另一个，而不经过 Server。 1.9 RSVP (Resource ReSerVation Protocol)使用 RSVP 预留一部分网络资源（即带宽），能在一定程度上为流媒体的传输提供 QoS。通常 RSVP 请求将会引起每个节点数据路径上的资源预留。 RSVP 只在单方向上进行资源请求，因此，尽管相同的应用程序，同时可能既担当发送者也担当接受者，但 RSVP 对发送者与接受者在逻辑上是有区别的。 RSVP 属于网络层协议。 RSVP 不传输应用数据，但支持因特网控制协议，如 ICMP、IGMP 或者路由选择协议。 1.10 MMS (Microsoft Media Server Protocol)MMS(Microsoft Media Server Protocol)，微软媒体服务器协议，用来访问接收 Windows Media 服务器中 .asf 文件的一种协议。MMS 协议用于访问 Windows Media 发布点上的单播内容。 MMS 的默认端口是 1755. 1.11 HLS (HTTP Live Streaming)HTTP Live Streaming（缩写是 HLS）是一个由苹果公司提出的基于HTTP的流媒体网络传输协议。它的工作原理是把整个流分成一个个小的基于 HTTP 的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的 extended M3U (m3u8)playlist 文件，用于寻找可用的媒体流。 HLS 只请求基本的 HTTP 报文，与实时传输协议（RTP)不同，HLS 可以穿过任何允许 HTTP 数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。 HLS 协议规定： 视频的封装格式是 TS。 视频的编码格式为 H264,音频编码格式为 MP3、AAC 或者 AC-3。 除了 TS 视频文件本身，还定义了用来控制播放的 m3u8 文件（文本文件）。 二、封装格式 名称 推出机构 流媒体支持 支持的视频编码 支持的音频编码 AVI Microsoft Inc. 否 几乎所有格式 几乎所有格式 MP4 MPEG 是 MPEG-2, MPEG-4, H.264, H.263 等 AAC, MPEG-1 Layers I, II, III, AC-3 等 TS MPEG 是 MPEG-1, MPEG-2, MPEG-4, H.264 MPEG-1 Layers I, II, III, AAC FLV Adobe Inc. 是 Sorenson, VP6, H.264 MP3, ADPCM, Linear PCM, AAC 等 MKV CoreCodec Inc. 是 几乎所有格式 几乎所有格式 RMVB Real Network Inc. 是 RealVideo 8, 9, 10 AAC, Cook Codec, RealAudio Lossless 三、视频编码格式 名称 推出机构 推出时间 HEVC(h.265) MPEG&#x2F;ITU-T 2013 H.264 MPEG&#x2F;ITU-T 2003 MPEG4 MPEG 2001 MPEG2 MPEG 1994 VP9 Google 2013 VP8 Google 2008 VC-1 Microsoft Inc. 2006 四、音频编码格式 名称 推出机构 推出时间 AAC MPEG 1997 AC-3 Dolby Inc. 1992 MP3 MPEG 1993 WMA Microsoft Inc. 1999 目前，直播服务普通采用RTMP作为流媒体协议，FLV作为封装格式，H.264作为视频编码格式，AAC作为音频编码格式化。点播服务普通采用HTTP作为流媒体协议，H.264作为视频编码格式，AAC作为音频编码格式，而封装格式有多种，如MP4，FLV，F4V等。","tags":["流媒体","RTP"],"categories":["音视频编程"]},{"title":"Windows资源管理器图标覆盖优先级设定","path":"/post/2567544627.html","content":"我们在安装了TortoiseSVN或TortoiseGit后，会自动在资源管理器的文件夹和文件图标上显示覆盖图标（Icon Overlay），这样可以比较方便的查看文件状态。 但有时候我们安装的其他软件，如Dropbox等，也会在资源管理器中显示覆盖图标。多个软件都显示覆盖图标时，会由于优先级问题导致覆盖图标不显示的问题。 本文讲述如何通过调整软件覆盖图标的优先级来解决诸如此类的问题。 打开注册表： 1HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellIconOverlayIdentifiers 通过修改ShellIconOverlayIdentifiers的各个子项的名称来改变覆盖图标显示的优先级。 如：1Tortoise1Normal就排在2Tortoise2Modified的前面。 参考：managing-overlay-icons","tags":["Windows"],"categories":["编程基础"]},{"title":"Windows平台编译WebRTC源码","path":"/post/2910781705.html","content":"写作本文时使用的 webrtc 版本为：branch heads/67 一、 准备工作1.0 请确保可以访问国外网站1.1 系统语言切换到英文系统 Windows 7&#x2F;10 都可以，在“控制面板”–&gt;”区域和语言”–&gt;”管理”–&gt;”更改系统区域设置”中切换到“英语（美国）”，然后重启系统。 1.2 卸载部分软件无 1.3 安装 VS2017Visual Studio 2017 现在只提供在线安装包，为了加快在线安装的速度，可以只选择如下几个安装项： Desktop development with C++ MFC and ATL support 1.4 安装 Windows 10 SDK虽然官方指南上面写的是支持 10.0.15063 及以后的版本，但编译选项中默认指定的是 10.0.15063 版本，所以建议安装 10.0.15063 版本。如果要使用其他版本的 SDK，可以在三、 生成vs解决方案 这一步中指定--winsdk=&lt;sdk_version&gt;参数。 10.0.15063 下载地址： 1https://download.microsoft.com/download/0/1/1/01111605-8CDF-4A88-BB06-C20E97E8B3D5/iso_windowssdk/15063.468.170612-1856.rs2_release_svc_sec_WindowsSDK.iso 1.5 安装 DirectX SDk下载地址： 1http://download.microsoft.com/download/A/E/7/AE743F1F-632B-4809-87A9-AA1BB3458E31/DXSDK_Jun10.exe 安装 DirectX SDK June 2010，安装完成后可能会提示“s1023”这样的错误，这是因为与系统已有的 visual c++ redistributable packages 版本冲突，可以忽略不管。 二、 源码获取2.1 配置 depot_toolsdepot_tools 是 webrtc 或 chromium 使用的源码管理工具，从此处下载： 1https://storage.googleapis.com/chrome-infra/depot_tools.zip 解压到 D:\\webrtc\\depot_tools 中，添加该目录到到系统环境变量 PATH。 因为 webrtc 或 chromium 使用的编译系统会自动下载与之匹配的 Python 和 Git，为了防止编译系统错误使用原有的版本，需要将D:\\webrtc\\depot_tools路径放到 PATH 的最前面，至少也要放到 Python 和 Git 的前面。 2.2 环境初始化先设置如下环境变量： 12DEPOT_TOOLS_WIN_TOOLCHAIN = 0GYP_GENERATORS = ninja,msvs-ninja 然后以管理员权限运行系统 cmd 命令行（不要使用其他命令行工具，如 cmder），依次执行下面的命令： 123d:cd D:\\webrtc # 用来进入webrtc目录，目录名不一样，命令也不一样gclient # 需要使用网络代理，耗时较长 2.3 下载源码和依赖项新建 webrtc-checkout 目录，下载源码到该目录，命令如下： 12345mkdir webrtc-checkout # 也可以手动新建cd webrtc-checkoutfetch --nohooks webrtc # 获取源码gclient sync # 更新源码gclient runhooks # 获取DEPS文件中指定的依赖项 三、 生成 vs 解决方案进入 webrtc-checkout\\src 目录（2.3 步骤中下载的源码会自动存储到该目录）,执行： 1gn gen --ide=vs out/Debug 或者加入详细的配置参数： 1gn gen out/x64/Debug --ide=vs --args=&quot;is_debug=true target_cpu=\\&quot;x64\\&quot;&quot; 执行成功之后，在 out&#x2F;Debug 目录中会生成 all.sln 解决方案文件。 另外，可以使用gn gen --help查看帮助，节选如下： 12345678910111213141516171819202122232425262728293031323334353637383940IDE options GN optionally generates files for IDE. Possibilities for &lt;ide options&gt; --ide=&lt;ide_name&gt; Generate files for an IDE. Currently supported values: &quot;eclipse&quot; - Eclipse CDT settings file. &quot;vs&quot; - Visual Studio project/solution files. (default Visual Studio version: 2017) &quot;vs2013&quot; - Visual Studio 2013 project/solution files. &quot;vs2015&quot; - Visual Studio 2015 project/solution files. &quot;vs2017&quot; - Visual Studio 2017 project/solution files. &quot;xcode&quot; - Xcode workspace/solution files. &quot;qtcreator&quot; - QtCreator project files. &quot;json&quot; - JSON file containing target information --filters=&lt;path_prefixes&gt; Semicolon-separated list of label patterns used to limit the set of generated projects (see &quot;gn help label_pattern&quot;). Only matching targets and their dependencies will be included in the solution. Only used for Visual Studio, Xcode and JSON.Visual Studio Flags --sln=&lt;file_name&gt; Override default sln file name (&quot;all&quot;). Solution file is written to the root build directory. --no-deps Don&#x27;t include targets dependencies to the solution. Changes the way how --filters option works. Only directly matching targets are included. --winsdk=&lt;sdk_version&gt; Use the specified Windows 10 SDK version to generate project files. As an example, &quot;10.0.15063.0&quot; can be specified to use Creators Update SDK instead of the default one. --ninja-extra-args=&lt;string&gt; This string is passed without any quoting to the ninja invocation command-line. Can be used to configure ninja flags, like &quot;-j&quot;. 在编译解决方案中的某些工程（如freetype_source, harfbuzz_source）时，可能会遇到诸如下面的错误提示： 1error C2220: 警告被视为错误 - 没有生成“object”文件 这时我们需要调低警告等级，编译对应的 ninja 文件，将其中的/WX改成/W3即可。 参考：https://chromium.googlesource.com/chromium/src/+/master/docs/windows_build_instructions.md","tags":["WebRTC"],"categories":["音视频编程"]},{"title":"拨开字符编码的迷雾(5)--Qt字符编码","path":"/post/1204594779.html","content":"我们以“测试字符串-보고싶다-Test String.”这个字符串来进行讲解，它包含了英文、中文和韩文。因为我使用 Qt 的方式是Visual Studio + Qt库的形式，所以本文以 MSVC 编译器为例来进行说明，但这种方式的原理也适用于其他编译器。 QString 中使用 QChar 来存储每一个字符，QChar 是 short 类型，占 2 个字节，默认按 Unicode 编码存储。 首先，为了保证写到代码文件中的测试字符串能被 MSVC 编译器理解，我们需要将源文件保存为Utf8-带签名的格式。具体参考：拨开字符编码的迷雾(2)--编译器处理文件编码 解决 Qt 程序乱码问题的关键在于理解QString中存储字符的编码格式。 QString 中存储的字符串的编码格式就是“编译器执行字符集编码格式”。 这一句话很关键。 在 MSVC 中我们可以使用#pragma execution_character_set(&quot;utf-8&quot;)来指定该源文件的执行字符集编码格式为 UTF8 格式，这样 QString 中存储的字符串格式就是 utf8 编码了。 下面是完整的测试用例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void Demo01::qStringUseCase() &#123; /* 该源文件使用Utf8-BOM格式保存. 源字符集为UTF8-BOM. 可执行字符集为UTF8：#pragma execution_character_set(&quot;utf-8&quot;) 定义在stdafx.h. */#define TEST_STR_A &quot;测试字符串-보고싶다-Test String.&quot;#define TEST_STR_W L&quot;测试字符串-보고싶다-Test String.&quot; &#123; // 因为可执行字符集是utf8，所以使用OutputDebugStringA需要转换成ANSI OutputDebugStringA(Utf8ToAnsi(TEST_STR_A).c_str()); &#125; &#123; ui.lblLanguage-&gt;setText(TEST_STR_A); &#125; // char* --&gt; QString &#123; QString qstr = TEST_STR_A; qInfo() &lt;&lt; qstr; &#125; // QString --&gt; char*或std::string &#123; QString qstr = TEST_STR_A; std::string str = qstr.toStdString(); // 不能直接使用qstr.toStdString().c_str()来获取，必须先将qstr.toStdString()存入std::string中 const char* pStr = str.c_str(); QString qstr2 = QString::fromUtf8(pStr); Q_ASSERT(qstr == qstr2); &#125; // QString --&gt; wchar_t*或std::wstring &#123; QString qstr = TEST_STR_A; std::wstring str = qstr.toStdWString(); const wchar_t * pStr = str.c_str(); QString qstr2 = QString::fromWCharArray(pStr); Q_ASSERT(qstr == qstr2); &#125; // std::string --&gt; QString &#123; std::string str = TEST_STR_A; // std::string中存储的是UTF-8编码的字符串，因为可执行字符集为UTF8 QString qstr = QString::fromStdString(str); &#125; // std::wstring --&gt; QString &#123; std::wstring str = TEST_STR_W; // std::wstring中存储的是UTF-8编码的字符串，因为可执行字符集为UTF8 QString qstr = QString::fromStdWString(str); &#125;&#125; QString::toLocal8BitQString 有一个名为toLocal8Bit的方法，网上很多介绍如何解决乱码的文章都会提到这个函数。关于这个函数官方的介绍如下： 12345Returns the local 8-bit representation of the string as a QByteArray. The returned byte array is undefined if the string contains characters not supported by the local 8-bit encoding.QTextCodec::codecForLocale() is used to perform the conversion from Unicode. If the locale encoding could not be determined, this function does the same as toLatin1().If this string contains any characters that cannot be encoded in the locale, the returned byte array is undefined. Those characters may be suppressed or replaced by another. 简单来说，我们可以理解为这个函数将字符串转换为的 ANSI 编码，通过拨开字符编码的迷雾(1)--字符编码概述介绍，我们应该知道 ANSI 是和具体的代码页相关联的（在 Windows 中文环境下默认代码页为 936）。Qt 不是根据系统代码页来做判断的，而是通过QTextCodec来做判断的，所以文档中会提到这个函数需要结合QTextCodec::codecForLocale()来使用，toLocal8Bit根据对应的QTextCodec来做相应的转换。 总结所以要想在使用 Qt 时，避免遇到中文乱码问题，只需要在预编译头文件中加入（对于不使用预编译头的项目可以在.cpp文件中添加）： 1#pragma execution_character_set(&quot;utf-8&quot;) 同时由于部分韩文、日文等字符不在 Visual Studio 默认的中文 GB2312 编码中，所以如果遇到 Visual Studio 提示“此文件的某些 Unicode 字符未能保存到当前代码页中”时，这时应该选择”Utf8-带签名“格式来保存。 综上所述，源文件保存为Utf8-带签名，且设置编译器执行字符集编码为UTF8（如#pragma execution_character_set(&quot;utf-8&quot;)）就可以解决所有乱码问题。 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["Qt","字符编码"],"categories":["Qt"]},{"title":"Windows内存体系(7)--使用std::string跨MT模块传参","path":"/post/3937624737.html","content":"前面的Windows内存体系(6)--跨模块内存分配释放文章解释了跨 MT 模块分配的内存相互释放为什么会崩溃的问题，本文介绍如何解决该问题。 一、问题描述这篇文章主要介绍我们在实际开发中经常遇到的一个问题： 我们开发了一个DLL，该DLL的运行时库采用MT模式，在为该模块定义接口函数时，接口参数使用的是std::string类型。EXE程序调用DLL中的接口时遇到&quot;Debug Assertioni Failed&quot;错误的问题。 上面的错误提示表明触发了debug_heap.cpp文件中的一个调试断言（release模式下调用的是heap.cpp中的分配函数），该断言用于判断指针是否指向堆分配的内存块的第一块。在 release 模式下不会弹出这样的断言错误，程序可能会直接崩溃（崩溃相对来说还比较好排查），就怕出现其他不可预料的、难以排查的错误。 二、实例现有DLLUser.exe调用DLL.dll中的TestFun函数，代码量非常小： DLL.dll中TestFun函数定义：1234DLL_API void TestFun( std::string str)&#123; return;&#125; DLLUser.exe中调用TestFun函数：123456789int _tmain(int argc, _TCHAR* argv[])&#123; std::string str = &quot;test&quot;; TestFun(str); return 0;&#125; 上面的代码运行之后程序就会弹出错误断言。原因是std::string在进行值传参的过程中会执行一次深拷贝，即：在堆上分配内存块，拷贝“test”到内存块中，然后将临时形参std::string对象传递到 dll 中，dll 中的TestFun函数在作用域结束后对临时形参进行释放时就出现了错误，因为尝试在dll的crt堆中释放由在exe的crt堆中分配的内存块。 三、自定义std::allocator通过上面问题的分析，加上前面几篇文章对 Windows 内存体系的介绍，我们不难想出解决方案，其中一种方案就是：让std::string统一在进程的默认堆上分配内存块，而不是在各个模块的crt堆上分配。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;windows.h&gt;#include &lt;string&gt;#include &lt;vector&gt;template &lt;typename T&gt;class vm_allocator : public std::allocator&lt;T&gt; &#123;public: typedef size_t size_type; typedef T* pointer; typedef const T* const_pointer; template&lt;typename _Tp1&gt; struct rebind &#123; typedef vm_allocator&lt;_Tp1&gt; other; &#125;; pointer allocate(size_type n, const void *hint = 0) &#123; UNREFERENCED_PARAMETER(hint); void* pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, n * sizeof(T)); return (pointer)pBuffer; &#125; void deallocate(pointer p, size_type n) &#123; UNREFERENCED_PARAMETER(n); if (p) &#123; HeapFree(GetProcessHeap(), 0, p); &#125; &#125; vm_allocator() throw() : std::allocator&lt;T&gt;() &#123; &#125; vm_allocator(const vm_allocator &amp;a) throw() : std::allocator&lt;T&gt;(a) &#123; &#125; template &lt;class U&gt; vm_allocator(const vm_allocator&lt;U&gt; &amp;a) throw() : std::allocator&lt;T&gt;(a) &#123; &#125; ~vm_allocator() throw() &#123; &#125;&#125;;typedef std::basic_string&lt;char, std::char_traits&lt;char&gt;, vm_allocator&lt;char&gt; &gt; mystring; 上面的代码使用自定义的内存分配器vm_allocator&lt;char&gt;定义了mystring类，我们只需要将TestFun函数接口中的std::string修改为mystring即可解决崩溃问题。 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["运行时库","Windows内存体系","堆"],"categories":["Windows编程"]},{"title":"Wav音频编码","path":"/post/3666885372.html","content":"一. WAVE 简介WAV格式是微软公司（Microsoft）开发的一种声音文件格式，它符合 RIFF(Resource Interchange File Format)文件规范，用于保存 Windows 平台的音频信息资源，被 Windows 平台及其应用程序所广泛支持。 WAVE 是录音时用的标准的 WINDOWS 文件格式，文件的扩展名为“WAV”，数据本身的格式为 PCM 或其他压缩数据，属于无损音乐格式的一种。 所有的 WAV 都有一个文件头，这个文件头记录了音频流的编码参数。WAV文件 = WAV头 + PCM数据。 二. 音频编码参数在介绍 WAVE 文件头之前，需要了解下音频编码的各个参数的含义： 声道数量(NumChannels)声道数是指支持能不同发声的音响的个数，它是衡量音响设备的重要指标之一。我们戴的耳机因为只有左右 2 个喇叭，所以最多只能支持 2 个声道数量。单声道（mono）的声道数为 1；立体声道（stereo）的声道数默认为 2，即左右声道；四声道即前左、前右，后左、后右供 4 个发音点；目前还有 5.1 声道、7.1 声道。 对于音频编码存储来说，每多一个声道，就要多存储一份数据。 采样率(SampleRate)表示每秒采样的次数，常见的有 8000, 16000, 32000, 44100, 48000。 采样精度(BitPerSample)表示每次从每个声道采样的数据的大小，以比特位单位。一般为 16,32。16 即 16 比特，也就是 2 个字节。 比特率(ByteRate)表示每秒的音频数据大小，以字节为单位，可以根据上面几个参数求得。ByteRate = SampleRate * NumChannels * BitPerSample / 8 三. WAVE 文件头 偏移 字段字节数 字段名 解释 0 4 ChunkID “RIFF”串 十进制大端表示为 0x52494646 4 4 ChunkSize 整个文件的大小减去 8 字节(ChunkID+ChunkSize)。36 + SubChunk2Size或者 4 + (8 + SubChunk1Size) + (8 + SubChunk2Size) 8 4 Format “WAVE”串，十六进制大端表示为 0x57415645 12 4 Subchunk1ID “fmt “串，十六进制大端表示为 0x666d7420 16 4 Subchunk1Size 整个 Subchunk1 的大小减去该字段本身所占的 4 字节，对于 PCM 来说固定为 16 20 2 AudioFormat PCM 格式为 1，大于 1 表示其他压缩格式 22 2 NumChannels 声道数量，如 Mono &#x3D; 1, Stereo &#x3D; 2 24 4 SampleRate 采样率，如 8000, 44100 等 28 4 ByteRate 比特率， 等于SampleRate * NumChannels * BitsPerSample/8 32 2 BlockAlign 每个 Sample 的大小，等于NumChannels * BitsPerSample/8 34 2 BitsPerSample 采样精度，如 8,16,32 36 4 Subchunk2ID “data”串，十六进制大端表示为 0x64617461 40 4 Subchunk2Size 实际音频数据的大小，不包含 Subchunk2ID 和 Subchunk2Size 这 2 个字段的大小 44 * Data 实际的音频数据 下图是以十六进制显示的一个 WAV 文件的前 72 字节： 四. 从其他编码转 WAVE我们可以使用 ffmpeg.exe 将音频从其他编码转为 wave 编码，命令如下: 1ffmpeg.exe -i input.mp3 output.wav 我们还可以指定输出文件的编码格式，如采用率，采样精度，声道数，如： 1ffmpeg.exe -f u16le -ar 44100 -ac 1 -i input.mp3 output.wav ffmpeg 参数解释见：http://trac.ffmpeg.org/wiki/audio%20types ffmpeg 生成的 wav 文件的文件头可能和我们上面介绍的不太一样，它可能会包含LIST和INFO数据块，这个时候我就需要通过 2 个步骤来生成不包含LIST和INFO数据块的 WAV 文件了：首先通过 ffmpeg.exe 将音频文件转成 pcm 裸数据文件，然后使用其他工具（如audacity）为该 pcm 裸数据加上 wav 头。 ffmpeg 将音频转成 pcm 裸数据命令如下： 1ffmpeg.exe -f s16le -c:a pcm_u16le -i input.mp3 output.raw 五、WebRTC 对 Wav 格式支持WebRTC 源码src\\common_audio目录中的wav_header.h和wav_file.h提供了对 wav 的读写功能。","tags":["Wav"],"categories":["音视频编程"]},{"title":"Windows内存体系(6)--跨模块内存分配释放","path":"/post/213040252.html","content":"在《Windows核心编程 第五版》第19章 DLL基础（511页）中给出了一个建议： “当一个 MT 版本的模块如果提供一个内存分配函数的时候，它必须同时提供另一个用来释放内存的函数。”。 说得更加直白一点就是，“对于 MT 的模块，不要跨模块进行内存释放。”。但是核心编程这本书上面没有具体分析原因，本文就来分析具体的原因。 一、不同堆分配的内存块不能相互释放Windows 的堆管理器对每个进程都维护了多个“堆”，我们从每个“堆”中分配处理的内存块的地址都不一样。所以我们不能将从“堆 A”中分配出来的内存块拿到“堆 B”中，让“堆 B”来释放，这样就会导致程序异常。 如上图，通过malloc函数从“堆 A”中分配 100 字节内存块，内存块地址为0x123456；从“堆 B”中分配 100 字节内存块，内存块地址为0x345678.如果将0x123456这个地址拿到“堆 B”中去释放，势必会导致异常，因为“堆 B”中没有这地址。 那么我们是不是可以使用HeapFree函数来释放hHeap参数指定的“堆”中的任何内存块了。答案是：不能。回忆前面介绍的HeapFree函数， 12345BOOL HeapFree( HANDLE hHeap, DWORD dwFlags, LPVOID lpMem); 这个函数只要求传入了内存块的起始地址指针，但没有要求传入需要释放的内存块的大小，那么该函数是如何知道起始地址指针指向的内存块的大小了？ 我们可以简单的理解为，HeapAlloc函数每次分配内存块的时候都会额外分配一点空间用于存储一个结构体，该结构体中存储了本次分配的内存块的大小等信息。大致如下图： 所以，HeapFree函数首先会通过lpMem指针计算出“结构体”的地址，然后从结构体中获取到分配的内存块的具体大小，最后执行释放操作。 基于上面的原因，我们不能在HeapFree函数的lpMem参数中传入随意的地址，因为该地址处可能没有存储用于存放内存块信息的结构体，所以释放操作就会失败。free函数也一样，因为free函数内部也是调用的HeapFree函数。 二、MD 模块内存可以相互释放为什么 MD模块内存可以相互释放，而MT模块的却不可以了？ 2.1 MT 模块内存相互释放会崩溃我们先分析为什么 MT 模块的内存间相互释放会崩溃？ 现在有 2 个模块（A.dll和B.dll）都是使用MT运行时库，即加载的静态库libcmt.lib（可以参考理解 Visual C&#x2F;C++ 运行时库），在A.dll中使用malloc分配 100 字节的内存，malloc返回的内存地址为0x123456。然后将该地址传给B.dll，在B.dll中调用free函数来释放这个内存。如图： 从Windows内存体系(5)--堆我们知道，DLL 在启动代码_DllMainCRTStartup中会建立一个“堆”（堆句柄存放在_crtheap 变量中），所以 A.dll 和 B.dll 中都会有一个 crt 堆。 为了区分，我们将A.dll中的crt堆称作_crtheap_A，B.dll中的crt堆称作_crtheap_B。 从上面图可以看到，A.dll中malloc的内存拿到B.dll去中去free，就相当于从堆_crtheap_A中分配的内存拿到另一个堆_crtheap_B中的释放。第一节已经解释了为什么不能这样做了。 2.2 MD 模块内存相互释放不会崩溃现在我们分析为什么 MD 模块的内存间相互释放不会崩溃。 还是 2 个模块（A.dll和B.dll），但是现在他们都是使用MD运行时库，即加载的动态库msvcr100.dll，程序的代码的过程和上面一样，还是在A.dll中使用malloc分配 100 字节的内存，malloc返回的内存地址为0x123456。然后将该地址传给B.dll，在B.dll中调用free函数来释放这个内存。但是这个时候程序却不会崩溃，通过下面的图我们基本可以明白原因了，如图： 因为 A、B 两个 dll 都是链接的·msvcr100.dll·，同一个 dll 在一个进程只会被加载一次，所以进程中只会有一个 crt 堆（_crtheap），malloc和free都是运行时库提供的函数，所以都会调到运行时库里面去，然后从运行时库里面的_crtheap分配和释放内存块。因为分配和释放都是在同一个堆上，所以不会崩溃。 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["Windows内存体系","堆"],"categories":["Windows编程"]},{"title":"WebRTC官方示例apprtc搭建","path":"/post/201024982.html","content":"系统环境 Ubuntu 16.04，在搭建之前建议关闭系统防火墙。 一. 房间服务器搭建1.1 安装依赖程序1apt-get install git unzip lrzsz nodejs npm automake autoconf libtool nodejs-legacy python-webtest golang –y 1.2 安装jdk81.2.1 下载jdk8从此处下载对应的版本到/usr/lib/jvm目录，然后解压到当前目录： 1tar zxf jdk-8u151-linux-x64.tar.gz 1.2.2 设置环境变量编辑/etc/source文件，在文件尾添加如下内容（因为jdk版本不同，文件夹名称可能会有差别）： 123export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_151export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 执行source /etc/profile命令让设置生效。 1.3 apprtc获取和安装1.3.1 获取apprtc源码12cd ~git clone https://github.com/webrtc/apprtc.git 1.3.2 安装apprtc1234cd apprtcnpm -g install grunt-clinpm installgrunt build --force 1.3.3 修改源码使用ifconfig命令查看本机IP信息： 我使用的阿里云的云服器，服务器在NAT之后，所以172.18.163.203是本地IP，即内网IP；从云服务器的管理页面可以看到该服务器的外网IP，如120.79.164.111。如果使用的是阿里云等服务器还需要在安全策略中设置将所有进&#x2F;出端口都映射到172.18.163.203。 下面以外网IP 120.79.164.111为例，根据实际外网IP进行对应修改。 修改constants.pyconstants.py路径：apprtc&#x2F;out&#x2F;app_engine&#x2F;constants.py 设置ICE服务器的IP端口、信令服务器(collider)的IP端口，修改之后的constants.py文件完整内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# Copyright 2015 Google Inc. All Rights Reserved.&quot;&quot;&quot;AppRTC Constants.This module contains the constants used in AppRTC Python modules.&quot;&quot;&quot;import os# Deprecated domains which we should to redirect to REDIRECT_URL.REDIRECT_DOMAINS = [ &#x27;apprtc.appspot.com&#x27;, &#x27;apprtc.webrtc.org&#x27;, &#x27;www.appr.tc&#x27;]# URL which we should redirect to if matching in REDIRECT_DOMAINS.REDIRECT_URL = &#x27;https://appr.tc&#x27;ROOM_MEMCACHE_EXPIRATION_SEC = 60 * 60 * 24MEMCACHE_RETRY_LIMIT = 100LOOPBACK_CLIENT_ID = &#x27;LOOPBACK_CLIENT_ID&#x27;# Turn/Stun server override. This allows AppRTC to connect to turn servers# directly rather than retrieving them from an ICE server provider.ICE_SERVER_OVERRIDE = None# Enable by uncomment below and comment out above, then specify turn and stun# ICE_SERVER_OVERRIDE = [# &#123;# &quot;urls&quot;: [# &quot;turn:hostname/IpToTurnServer:19305?transport=udp&quot;,# &quot;turn:hostname/IpToTurnServer:19305?transport=tcp&quot;# ],# &quot;username&quot;: &quot;TurnServerUsername&quot;,# &quot;credential&quot;: &quot;TurnServerCredentials&quot;# &#125;,# &#123;# &quot;urls&quot;: [# &quot;stun:hostname/IpToStunServer:19302&quot;# ]# &#125;# ]ICE_SERVER_BASE_URL = &#x27;http://120.79.164.111:3033&#x27;ICE_SERVER_URL_TEMPLATE = &#x27;%s/v1alpha/iceconfig?key=%s&#x27;ICE_SERVER_API_KEY = os.environ.get(&#x27;ICE_SERVER_API_KEY&#x27;)# Dictionary keys in the collider instance info constant.WSS_INSTANCE_HOST_KEY = &#x27;host_port_pair&#x27;WSS_INSTANCE_NAME_KEY = &#x27;vm_name&#x27;WSS_INSTANCE_ZONE_KEY = &#x27;zone&#x27;WSS_INSTANCES = [&#123; WSS_INSTANCE_HOST_KEY: &#x27;120.79.164.111:8089&#x27;, WSS_INSTANCE_NAME_KEY: &#x27;wsserver-std&#x27;, WSS_INSTANCE_ZONE_KEY: &#x27;us-central1-a&#x27;&#125;, &#123; WSS_INSTANCE_HOST_KEY: &#x27;120.79.164.111:8089&#x27;, WSS_INSTANCE_NAME_KEY: &#x27;wsserver-std-2&#x27;, WSS_INSTANCE_ZONE_KEY: &#x27;us-central1-f&#x27;&#125;]WSS_HOST_PORT_PAIRS = [ins[WSS_INSTANCE_HOST_KEY] for ins in WSS_INSTANCES]# memcache key for the active collider host.WSS_HOST_ACTIVE_HOST_KEY = &#x27;wss_host_active_host&#x27;# Dictionary keys in the collider probing result.WSS_HOST_IS_UP_KEY = &#x27;is_up&#x27;WSS_HOST_STATUS_CODE_KEY = &#x27;status_code&#x27;WSS_HOST_ERROR_MESSAGE_KEY = &#x27;error_message&#x27;RESPONSE_ERROR = &#x27;ERROR&#x27;RESPONSE_ROOM_FULL = &#x27;FULL&#x27;RESPONSE_UNKNOWN_ROOM = &#x27;UNKNOWN_ROOM&#x27;RESPONSE_UNKNOWN_CLIENT = &#x27;UNKNOWN_CLIENT&#x27;RESPONSE_DUPLICATE_CLIENT = &#x27;DUPLICATE_CLIENT&#x27;RESPONSE_SUCCESS = &#x27;SUCCESS&#x27;RESPONSE_INVALID_REQUEST = &#x27;INVALID_REQUEST&#x27;IS_DEV_SERVER = os.environ.get(&#x27;APPLICATION_ID&#x27;, &#x27;&#x27;).startswith(&#x27;dev&#x27;)BIGQUERY_URL = &#x27;https://www.googleapis.com/auth/bigquery&#x27;# Dataset used in production.BIGQUERY_DATASET_PROD = &#x27;prod&#x27;# Dataset used when running locally.BIGQUERY_DATASET_LOCAL = &#x27;dev&#x27;# BigQuery table within the dataset.BIGQUERY_TABLE = &#x27;analytics&#x27; 修改apprtc.pyapprtc.py路径：apprtc&#x2F;out&#x2F;app_engine&#x2F;apprtc.py 将修改为（大约位于146行左右） 修改index_template.htmlindex_template.html路径：apprtc&#x2F;out&#x2F;app_engine&#x2F;index_template.html 设置TURN服务器信息，在javascript脚本中添加servers变量： 12345678var servers=[&#123; credential:&quot;helloword&quot;, username:&quot;helloword&quot;, urls:[ &quot;turn:120.79.164.111:3478?transport=udp&quot;, &quot;turn:120.79.164.111:3478?transport=tcp&quot; ] &#125;]; 并将peerConnectionConfig: &#123;&#123; pc_config | safe &#125;&#125;修改为使用上面声明的servers变量； 12peerConnectionConfig: &#123; &quot;rtcpMuxPolicy&quot;:&quot;require&quot;,&quot;iceServers&quot;:servers,&quot;bundlePolicy&quot;:&quot;max-bundle&quot;&#125;,iceServerRequestUrl: &#x27;&#123;&#123; ice_server_url &#125;&#125;&#x27;,// peerConnectionConfig: &#123;&#123; pc_config | safe &#125;&#125;, ##1.4 获取google_appengine从https://download.csdn.net/download/china_jeffery&#x2F;10375696下载google_appengine.tar，并使用tar命令解压： 12cd ~unzip google_appengine.tar 1.5 启动房间服务器12cd ~./google_appengine/dev_appserver.py --host 172.18.163.203 ./apprtc/out/app_engine --skip_sdk_update_check 172.18.163.203为内网IP。 二. 信令服务器搭建2.1 collider源码Webrtc信令服务可以使用的apprtc自带的collider，这个服务是使用go语言开发。collider已经位于apprtc/src目录中，我们将其拷贝到~/collider/src目录中： 123cd ~mkdir collider/src -pcp apprtc/src/collider/ collider/src/ -r 编辑~/collider/src/collidermain/main.go文件，将room-server修改为服务器的外网IP和端口8080: 1var roomSrv = flag.String(&quot;room-server&quot;, &quot;http://120.79.164.111:8080&quot;, &quot;The origin of the room server&quot;) 2.2 安装go在安装go之前最好先卸载掉系统上已经安装的go版本： 123apt-get remove golangapt-get remove golang*apt-get autoremove 然后使用wget命令下载go： 1wget https://storage.googleapis.com/golang/go1.5.1.linux-amd64.tar.gz 或者从https://download.csdn.net/download/china_jeffery&#x2F;10375936下载。然后解压tar zxf go1.5.1.linux-amd64.tar.gz。 添加如下环境变量到/etc/source文件尾，并使用source /etc/source是环境变量生效： 123export GOROOT=/root/goexport PATH=$PATH:$GOROOT/binexport GOPATH=/root/collider/ 2.3 collider安装使用go命令进行collider安装： 123cd ~/collidergo get collidermaingo install collidermain 2.4 启动信令服务器12cd ~./collider/bin/collidermain -port=8089 -tls=false 三. TURN服务器搭建webrtc的turn服务是为提供NAT穿透或者中转使用的，因为webrtc客户端可能会在不同的路由器后面或者多层路由器后面，那么他们如何通讯呢？都需要穿透，穿透的服务就是turn服务，webrtc推荐使用的coturn（以前也叫turnserver）,它支STUN和Relay。 3.1 安装依赖12sudo apt-get install libssl-devsudo apt-get install libevent-dev 3.2 下载并编译源码1234cd ~git clone https://github.com/coturn/coturn.gitcd coturnconfigure &amp;&amp; make &amp;&amp; make install 3.3 启动TURN服务1./coturn/bin/turnserver --syslog -a -X 120.79.164.111 -E 172.18.163.203 -f --min-port=32355 --max-port=65535 --user=helloword:helloword -r helloword --cert=turn_server_cert.pem --pkey=turn_server_pkey.pem --log-file=stdout -v 120.79.164.111为外网IP，172.18.163.203为本地IP。turnserver的参数见： https://github.com/coturn/coturn/wiki/turnserver 本文最初发布在我的CSDN博客：《WebRTC – 官方apprtc示例搭建》","tags":["WebRTC","apprtc"],"categories":["音视频编程"]},{"title":"Windows内存体系(5)--堆","path":"/post/3599385732.html","content":"一、为什么要使用堆 (Heap)？应用程序虽然可以使用页面粒度的函数（如VirualAlloc）来分配一个最小为4KB或8K的内存块，但是很多时候我们并不需要分配这么大的内存块，我们可能只想分配 1K，2K 的内存块，那么这个时候无论从内存的使用率，还是从性能的角度来看，再分配这么大的一个内存区域显然不是最优的了。 为了满足这种需求，Windows 提供了一个被称为“堆管理器”的组件，它负责管理大内存区域中的内存分配，这些大内存区域就是通过一些页面粒度的内存分配函数（如VirualAlloc）来预定（reserve）的。 堆管理器中的分配粒度相对比较小：在32位系统上是8字节，在64位系统上是16字节。 堆管理器已经被 Windows 系统精心设计，在这些小内存分配的情况下会进行内存使用率和性能两个方面的优化。 二、进程的默认堆每个进程至少有一个堆，那就是进程的默认堆。进程的默认堆是在进程启动的时候创建的，而且在进程的生命周期中永远不会被删除。 “默认堆”的默认大小为1MB，但是可以通过/HEAP链接器编译器选项来指定一个更大的起始大小。这个大小值只是初始的保留内存大小，后期根据需要它可以自动扩充。 应用程序可以调用GetProcessHeap来获取进程的默认堆，也可以通过调用HeapCreate函数来创建额外的私有堆，当一个进程不在需要一个私有堆的时候，它可以调用HeapDestory来释放虚拟地址空间。 三、crt 堆C 语言的malloc,free函数以及 C++的new,delete都是从堆上分配和释放内存的。但是他们所使用的堆不是进程的默认堆，他们使用的是私有堆。可是我们在使用malloc函数之前并有进行任何私有堆的创建操作呀？ 因为malloc函数使用的这个私有堆不需要程序员来创建，而是在 C 或 C++运行时库 DLL 的启动代码_DllMainCRTStartup中自动创建的。下面通过解析malloc函数的调用过程来说明这一点。 malloc函数的定义在malloc.c文件中，调用流程如下：（以Microsoft Visual Studio 10.0为例，malloc.c文件路径为C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\crt\\src） 123(1). void* __cdecl malloc(size_t const size)(2). void * __cdecl _malloc_base (size_t size)(3). void * __cdecl _heap_alloc (size_t size) _heap_alloc 的定义如下： 12345678910__forceinline void * __cdecl _heap_alloc (size_t size)&#123; if (_crtheap == 0) &#123; _FF_MSGBANNER(); /* write run-time error banner */ _NMSG_WRITE(_RT_CRT_NOTINIT); /* write message */ __crtExitProcess(255); /* normally _exit(255) */ &#125; return HeapAlloc(_crtheap, 0, size ? size : 1);&#125; 从上面的代码中，我们可以看到分配内存块的时候使用的是_crtheap句柄标记的堆。那么_crtheap堆是何时创建的了？ 我们从heapinit.c文件中的_heap_init函数可以看到_crtheap堆的创建过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445HANDLE _crtheap=NULL;/****_heap_init() - Initialize the heap**Purpose:* Setup the initial C library heap.** NOTES:* (1) This routine should only be called once!* (2) This routine must be called before any other heap requests.**Entry:* &lt;void&gt;*Exit:* Returns 1 if successful, 0 otherwise.**Exceptions:* If heap cannot be initialized, the program will be terminated* with a fatal runtime error.********************************************************************************/int __cdecl _heap_init (void)&#123; ULONG HeapType = 2; // Initialize the &quot;big-block&quot; heap first. if ( (_crtheap = HeapCreate(0, BYTES_PER_PAGE, 0)) == NULL ) return 0;#ifdef _WIN64 // Enable the Low Fragmentation Heap by default on Windows XP and // Windows Server 2003. It&#x27;s the 8 byte overhead heap, and has // generally better performance charateristics than standard heap, // particularly for apps that perform lots of small allocations. if (LOBYTE(GetVersion()) &lt; 6) &#123; HeapSetInformation(_crtheap, HeapCompatibilityInformation, &amp;HeapType, sizeof(HeapType)); &#125;#endif /* _WIN64 */ return 1;&#125; 从上面的代码，我们可以看到，创建的私有堆句柄存放在一个全局的_crtheap变量中，后面每次调用malloc函数都是从该堆分配内存块。 四、Win32 堆函数我们最常用的 Windows 堆函数如下： HeapCreate或HeapDestory — 创建或删除一个私有堆 HeapAlloc — 分配一个堆内存块 HeapFree — 释放一个原先由HeapAlloc分配的内存块 HeapReAlloc — 增长或缩减一个已分配的内存块的大小 HeapLock或HeapUnLock — 控制堆操作的内存访问 HeapWalk — 列举一个堆内部的内存项和区域。 五、Windows 内存管理 API 分层结构 从上图可以看到，虚拟内存机制（Virtual Memory）是 windows 内存体系的基础，无论你是使用堆，还是使用内存映射文件，它们的底层都是基于虚拟内存来实现的。 从上往下，每一层的 API 在内部会依次调用下一层的 API。下图中列举了每层 API 中经常使用的函数： CRT Memory Functions：malloc, free, new, delete Local, Global Memory API: ** LocalAlloc, GlobalAlloc （这 2 个函数现在不建议使用，注意是为了兼容以前的老代码才保留下来的**） Heap Memory API：HeapCreate, HeapAlloc, HeapDestory Virtual Memory API：VirtualAlloc, VirtualFree Memory Mapped File API：CreateFileMapping, MapViewOfFile, MapViewOfFileEx, UnMapViewOfFile 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["Windows内存体系","堆"],"categories":["Windows编程"]},{"title":"Windows内存体系(4)--内存对齐","path":"/post/4245522728.html","content":"一、为什么要内存对齐平台原因不是所有的CPU都能访问任意地址上的任意数据的，有些CPU只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 性能原因尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的，它一般会以双字节、四字节、8字节、16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度。 如果数据存储时是按照内存存取粒度对齐的，那么处理器就可以在一个内存访问周期内完成数据的读取；反之，如果数据没有对齐，可能需要多个内存访问周期才能读取完整的数据。 二、内存对齐规则对齐系数在 C&#x2F;C++ 中，编译器会在结构体（联合体、类）成员之间插入填充字节，以确保每个成员都按照特定的对齐要求进行存储，以提高内存访问效率。 每个编译器都有自己的默认“对齐系数”（也叫对齐模数）。GCC默认对齐系数为4，MSVC 32位默认对齐系数为8，MSVC 64位默认对齐系数位16。 我们可以在代码中通过预编译命令#pragma pack(n)来指定对齐系数，n 可以为 (1, 2, 4, 8, 16)中的任意一个。 下面是 #pragma pack 命令的基本用法： 123#pragma pack(n) // 使用自定义n字节对齐 n可以为1，2，4，8，16#pragma pack() // 使用缺省字节对齐#pragma pack(show) // 在编译输出窗口以警告的形式显示出当前的内存以几个字节对齐 对齐规则假设在一个结构体（联合体、类）中，最大数据类型长度为 m，编译器对齐系数是 n，则将 min(m, n) 称做对齐单位，也叫有效对齐值，这里记为 s。 对齐分为成员对齐和结构体（联合体、类）整体对齐。 成员对齐规则：第一个成员相对于结构体首地址的偏移量始终为 0，以后每个成员（数据类型长度记为 k）相对于结构体首地址的偏移量都为 min(k, s) 的整数倍。 整体对齐：结构体的总大小必须是有效对齐值 s 的整数倍。 从内存对齐的规则可以看出：&#96; 除第一个成员外，每个成员的偏移量：min(k, min(m, n)) 如果设置的对齐系数 n 大于类中最大数据类型长度 m 时，则该设置实际是不起作用的。 当对齐系数 n &#x3D;&#x3D; 1 时，整个结构体的大小为所有成员长度之和。 三、结构体内存对齐示例在 64 位系统上编译下面的测试程序，已知在 64 位系统上各类型占用字节数如下： 1234567char 1字节short 2字节int 4字节long 4字节double 8字节long long 8字节char* 8字节 示例代码如下： 123456789101112131415#pragma pack(8) // 强制设置对齐系数为8struct A &#123; char s[5]; short c; int a;&#125;;int main()&#123; int i = sizeof(A); printf(&quot;%d&quot;, i); return 0;&#125; 按照第二节所讲的内存对齐规则，分析如下：因为结构体中最大的数据成员长度为 int（即 4 字节），而且#pragma pack(8)指定的对齐系数为 8 ，所以有效对齐值 s 为 min(4, 8) = 4。 下图是结构体 A 按照 4 字节对齐的内存布局（需要注意的是“内存不是填充在 s5 后面，而是填充在 c 后面”）： 从图我们很容易知道sizeof(A) = 12. 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["Windows内存体系","内存对齐"],"categories":["Windows编程"]},{"title":"Windows内存体系(3)--内存映射文件","path":"/post/3938269003.html","content":"一、为什么需要内存映射“内存映射文件”可以将硬盘上的文件映射到虚拟地址空间，这样就不需要将所有东西都放入到页交换文件中，比如系统有许多程序同时运行时，如果将这些程序文件都加载到页交换文件中，页交换文件将会变得非常大。事实上，Windows 也并没有将硬盘上的程序文件复制到页交换文件中，因为这样不仅会让页交换文件将会变得非常大，也会浪费很多时间，特别是可执行程序非常大的时候。 当用户要求执行一个应用程序时，系统会打开该应用程序的.exe文件，并计算出应用程序的代码和数据的大小，然后系统会在进程的虚拟地址空间预定一块地址空间，并注明与该区域相关联的物理存储器就是.exe文件本身。 当把一个位于硬盘上的文件（可以是.exe，.dll也可以是普通文件）映像用作地址空间区域对应的物理存储器时，我们称这个文件映像为“内存映射文件”。 现在我们可以对Windows内存体系(2)--虚拟内存第 2 节的图进行完善了，加入“内存映射文件”部分： 二、内存映射文件技术介绍常用的有 Win32 API 的CreateFile()、WriteFile()、ReadFile()和 MFC 提供的CFile类都可以实现文件的读写操作。一般来说，以上这些函数可以满足大多数场合的要求，但是对于某些特殊应用领域所需要的动辄几十 GB、几百 GB、乃至几 TB 的海量存储，此时在以平常的文件处理方法进行处理显然是行不通的（效率低下，而且内存没那么大）。目前，对于这种大文件的操作一般是以内存映射文件的方式来加以处理的。 内存映射文件也是 Windows 的一种内存管理方法，提供了一个统一的内存管理特征，使应用程序可以通过内存指针对磁盘上的文件进行访问。通过文件映射将磁盘文件内容（全部或者部分）与进程虚拟地址空间的某个区域建立映射关联，可以直接对被映射的文件进行访问，而不必执行文件 I&#x2F;O 操作也无需对文件内容进行缓冲处理。内存文件映射的这种特性是非常适合于用来管理大尺寸文件的。 三、大文件读写实例通过 C++调用系统 API 实现文件映射的步骤大致如下： 本示例首先在D:\\生成一个大小为 1GB 的BigFile.data文件，然后使用内存映射技术将该文件内全部填充字符 A，随后读取其中的第20000~20100字节，并将这些字节修改为字符 B，然后再次读取已验证是否修改成功。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;windows.h&gt;void Test() &#123; HANDLE file_ = CreateFile(TEXT(&quot;D:\\\\BigFile.data&quot;), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (file_ == INVALID_HANDLE_VALUE) &#123; printf(&quot;CreateFile failed, GLE:%d &quot;, GetLastError()); return; &#125; LARGE_INTEGER filesize; filesize.QuadPart = 1024 * 1024 * 1024; // 1GB HANDLE mapping_ = CreateFileMapping(file_, NULL, PAGE_READWRITE, filesize.HighPart, filesize.LowPart, NULL); if (mapping_ == NULL) &#123; printf(&quot;CreateFileMapping failed, GLE:%d &quot;, GetLastError()); return; &#125; LARGE_INTEGER offset; offset.QuadPart = 0; LPVOID mapping_addr = MapViewOfFile(mapping_, FILE_MAP_WRITE | FILE_MAP_READ, offset.HighPart, offset.LowPart, 0); if (mapping_addr == NULL) &#123; printf(&quot;MapViewOfFile failed, GLE:%d &quot;, GetLastError()); return; &#125; // 向文件中填充1GB的字符&#x27;A&#x27; // char buf[1024]; for (int i = 0; i &lt; 1024; i++) &#123; buf[i] = &#x27;A&#x27;; &#125; // 每次填充1024字节，填充1024*1024次 for (long l = 0; l &lt; 1024 * 1024; l++) &#123; memcpy((LPVOID)((long)mapping_addr + l * 1024), buf, 1024); &#125; // 填充完毕 // 读取第20000~20100字节，共100字节 // char read_content[101] = &#123; 0 &#125;; memcpy(read_content, (LPVOID)((long)mapping_addr + 20000), 100); printf(&quot;%s &quot;, read_content); // 将第20000~20100字节，共100字节全部修改为字符&#x27;B&#x27; // char write_content[100]; for (int i = 0; i &lt; 100; i++) &#123; write_content[i] = &#x27;B&#x27;; &#125; memcpy((LPVOID)((long)mapping_addr + 20000), write_content, 100); // 再次读取第20000~20100字节，共100字节，验证修改是成功 // memcpy(read_content, (LPVOID)((long)mapping_addr + 20000), 100); printf(&quot;%s &quot;, read_content); UnmapViewOfFile(mapping_addr); CloseHandle(mapping_); CloseHandle(file_); return;&#125;int main()&#123; Test(); return 0;&#125; 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["Windows内存体系","内存映射"],"categories":["Windows编程"]},{"title":"Windows内存体系(2)--虚拟内存","path":"/post/595856315.html","content":"一、页交换文件虚拟地址空间只是操作系统为进程“虚拟”出来的一块地址区域，并不代表任何实际的空间。而“页交换文件”却对应了实际的空间，这个空间一般是磁盘上名为“pagefile.sys”的文件。 “页交换文件”的大小和位置可以在系统设置（系统属性 -&gt; 高级 -&gt; 性能 -&gt; 设置 -&gt; 高级 ）中进行设置： 从微软的官方文档来看，“虚拟内存”等于“物理内存”+“分页文件”总和。可以把“虚拟内存”理解为 Windows 的一种内存管理机制。 二、虚拟地址空间、页交换文件、物理内存虚拟地址空间、页交换文件、物理内存三者的关系如下图： 《Windows 核心编程》第 13 章关于“物理存储器和页交换文件”章节中讲到了“页交换文件、物理存储器之间的数据交换过程”，流程如下： 应用程序从进程的虚拟地址空间预定并调拨了一块地址区域时，起初这块区域只是从“页交换文件”中调拨的，这样作有个好处就是：因为还不确定何时才会使用这块区域，如果立即从物理内存调拨，会将占用很多的物理内存。当程序读写该地址区域时，此时就会出现上面图上的页交换文件和物理内存之间的数据交换过程。 三、将页面锁定在物理内存从上面的几节我们知道，当物理内存中没有闲置页面时，系统会将内存中的某些页面的数据写入到交换文件中，从而将该物理内存区域释放出来供后面的程序使用。 我们可以通过调用VirtualLock方法，将页面锁定在物理内存中，从而防止虚拟内存管理机制将页面交换至页面文件，而引起不必要的硬盘和物理内存之间的低效页面交换。 也可以通过调用VirtualUnlock方法解锁页面，允许系统对页面进行交换操作。 需要注意的是，锁定页面时系统会根据当前可用实际物理内存情况，以及进程工作集配额判定当前最大可锁定的页面的实际数量，超过此数量会引起一个错误。我们可以调用SetProcessWorkingSetSize可以改变一个进程工作集大小的配额，从而可以锁定更多的物理页面。 四、虚拟内存使用实例虚拟内存方面的 API 属于页面粒度 API，通过这些 API 分配的内存的最小粒度是64KB。这些 API 分配（调拨）的内存区域最初都是位于“页交换文件”上面，当程序对该区域的某些“页面”（对虚拟内存的管理以页面为单位进行的）进行读写时，才会将这些页面交换到物理内存上面。 从Windows内存体系(1)--虚拟地址空间中我们知道虚拟地址空间要经过预定和调拨2 个步骤之后才能使用，这 2 个步骤都可以通过VirtualAlloc函数实现： 123456LPVOID VirtualAlloc( LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect); 当预定或者调拨的空间我们不在需要时，我们需要调用VirtualFree来释放该地址空间： 12345BOOL VirtualFree( LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType); 下面是的示例演示了在预定、调拨、使用等操作前后，进程的各项内存的占用情况： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;windows.h&gt;int main()&#123; SIZE_T size = 1 &lt;&lt; 30; // 1GB // 预定1GB的空间 char *pVirtualAddress = (char *)VirtualAlloc(NULL, size, MEM_RESERVE, PAGE_READWRITE); if (pVirtualAddress == NULL) &#123; printf(&quot;Reserve 1GB failed. &quot;); return 1; &#125; // 验证分配粒度是不是64KB int n = (long)pVirtualAddress % (64*1024); if (n == 0) &#123; printf(&quot;分配粒度为64K &quot;); &#125; printf(&quot;已经预定1GB &quot;); getchar(); // 暂停 if (VirtualAlloc(pVirtualAddress, size, MEM_COMMIT, PAGE_READWRITE) == NULL) &#123; printf(&quot;Commit 1GB failed. &quot;); return 1; &#125; printf(&quot;已经调拨1GB &quot;); getchar(); // 暂停 // 页面大小为4K，访问2560个页面，即2560*4K = 10MB // for (int i = 0; i &lt; 2560; i++) &#123; char * p = pVirtualAddress + i * (4 * 1024); *p = &#x27;A&#x27;; // 只访问每个页面的第一个字节 &#125; printf(&quot;已经使用前10MB &quot;); getchar(); // 暂停 return 0;&#125; 在程序运行各个阶段进程的内存情况如下图：（“内存专用工作集”表示占用的物理内存的大小，“提交大小”表示调拨的页交换文件的大小） 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["Windows内存体系","虚拟内存"],"categories":["Windows编程"]},{"title":"Windows内存体系(1)--虚拟地址空间","path":"/post/2494475058.html","content":"一、实模式下内存分配机制在 8086 或者 80186 以前，程序运行时，操作系统会把程序全都装入内存，程序都是直接运行在物理内存上的。也就是说程序中访问的内存地址都是实际的物理内存地址。当计算机同时运行多个程序时，必须保证这些程序用到的内存总量要小于计算机实际物理内存的大小。 例如某台计算机总的内存大小是128M ，现在同时运行两个程序 A 和 B ，A 需占用内存10M ， B 需占用内存110M 。计算机在给程序分配内存时会采取这样的方法：先将内存中的前10M分配给程序 A ，接着再从内存中剩余的118M中划分出 110M分配给程序 B 。这种分配方法虽然可以保证程序 A 和程序 B 都能运行，但是这种简单的内存分配策略会导致很多问题： 问题 1 ：进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意但有 bug 的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。这种情况对用户来说是无法容忍的，因为用户希望使用计算机的时候，其中一个任务失败了，不能影响其它的任务。 问题 2 ：内存使用效率低。在 A 和 B 都运行的情况下，如果用户又运行了程序 C ，而程序 C 需要 20M 大小的内存才能运行，而此时系统只剩下 8M 的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序 C 使用，然后再将程序 C 的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。 问题 3 ：程序运行的地址不确定。当内存中的剩余空间可以满足程序 C 的要求后，操作系统会在剩余空间中随机分配一段连续的 20M 大小的空间给程序 C 使用，因为是随机分配的，所以程序运行的地址是不确定的。 二、虚拟地址空间介绍操作系统让每个进程都有自己的虚拟地址空间（Virtual Address Space，简称VAS）。以 32 位进程为例，每个进程都有0x00000000 ~ 0xFFFFFFFF(4GB)的虚拟地址空间，所以每个进程都可能分配到0x123456地址的内存，但这个地址不能在进程间相互访问。 因为这些都是“虚拟”的地址空间，这些“地址”都不能直接使用，CPU 在寻址的时候虽然是按照虚拟地址来寻址的，但是还要通过MMU(内存管理单元)来将虚拟地址转换为物理存储器（如内存等）上的物理地址： 从图上可以看出，进程 A 和 B 虽然都有地址0x123456，但它们分别对应的物理地址不一样。 ##三、虚拟地址空间分区进程的虚拟地址空间虽然很大，但是它被划分成了很多分区，供 Ring3 层应用程序使用的用户模式分区并不大（一半不到），如图： 3.1 空指针赋值分区这一分区的进程地址空间的范围为：[0x00000000, 0x0000FFFF]，总大小为64K，保留该分区的目的是为了帮助应用程序员捕获对空指针的赋值。如malloc分配内存失败，就会返回NULL。 如果进程中的线程试图访问该分区内的内存地址，就会引发访问违规。 3.2 用户模式分区在 Windows 中，所有的 exe 和动态链接库都载入到这一区域。系统同时会把该进程可以访问的所有内存映射文件（后面会介绍）映射到这一分区。 进程无法通过指针来读取、写入、访问其他进程的这一分区，因此一个应用程序破坏另一个应用程序的可能性就非常小了，从而使整个系统更加坚固。 3.3 内核模式分区内核模式分区是操作系统代码的驻地。与线程调度、内存管理、文件系统支持、网络支持以及设备驱动程序相关的代码都会载入到这一分区。该分区内的代码和数据被完全的保护起来了，如果一个应用程序试图读取或写入位于这一分区的内存地址，会引发访问违规。 驻留在这一分区内的代码为所有进程共有。 四、虚拟地址空间的使用虚拟地址空间的使用涉及到 3 个概念：页面大小、分配粒度、预定和调拨。 4.1 页面大小虚拟地址空间被分成以“页面”为单位，因为硬件内存管理单元是以页面为粒度将虚拟地址转译成物理地址的。页面的大小根据不同的 CPU 不而有所不同。x86 和 x64 系统使用的页面大小都是4KB，而 IA-64 系统使用的页面大小是8KB。 IA-64 操作系统只能在 INTEL 安腾系列处理器及 AMD 部分服务器处理器运行，所以主流市场并不常见 当应用程序在虚拟地址空间分配空间时，系统需要确保分配区域的大小正好是系统页面大小的整数倍。 4.2 分配粒度当应用程序在从虚拟地址空间分配空间时，系统会确保所有分配区域的起始地址都是分配粒度的整数倍。分配粒度的会根据不同的 CPU 平台而有所不同，但目前所有的 CPU 平台的分配粒度都是使用64KB。也就是说，分配的起始地址 = 64 * N。 通过 Windows 的GetSystemInfo函数也可以获得此分配粒度值。 上面所说的分配粒度和页面大小的限制，只是针对于“应用程序”，系统内核自己不存在这样的限制。 4.3 预定和调拨虚拟地址空间的使用分为 2 个步骤： 预定（reserve）：告诉系统我们要从虚拟地址空间预定哪一块区域，系统为我们保留这一块区域。预定的局域的起始地址和大小遵循上面介绍的分配粒度和页面大小的要求。因为预定的只是虚拟地址空间，不占用任何其他物理存储器，所以没有形成实质的开销。 调拨（commit）：预定的区域还不能使用，我们还需要为预定的区域从页交换文件中调拨存储器，调拨之后我们才能使用该区域。至于为什么要从页交换文件中调拨存储器？ 页交换文件如何与物理内存之间交互？在下一篇文章Windows内存体系(2)--虚拟内存中会详细介绍。 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["虚拟地址","Windows内存体系"],"categories":["Windows编程"]},{"title":"初识WebRTC","path":"/post/3298681169.html","content":"WebRTC （Web Real-Time Communications） 是一项实时通讯技术，它允许网络应用或者站点在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。 它并不是单一的协议，包含了媒体、加密、传输层等在内的多个协议标准以及一套基于 JavaScript 的 API。通过简单易用的 JavaScript API ，在不安装任何插件的情况下，让浏览器拥有了 P2P音视频和数据分享的能力。同时WebRTC 并不是一个孤立的协议，它拥有灵活的信令，可以便捷的对接现有的SIP 和电话网络的系统。 不同技术领域的人都可以从WebRTC中获取到需要的东西。 一. 支持的浏览器和平台目前基本上所有的浏览器都已经支持WebRTC 二. WebRTC 内部结构 架构图颜色标识说明： 紫色部分是Web开发者API层 蓝色实线部分是面向浏览器厂商的API层 蓝色虚线部分浏览器厂商可以自定义实现 WebRTC有三个模块： Voice Engine（音频引擎） Voice Engine包含iSAC&#x2F;iLBC Codec（音频编解码器，前者是针对宽带和超宽带，后者是针对窄带） NetEQ for voice（处理网络抖动和语音包丢失） Echo Canceler（回声消除器）&#x2F; Noise Reduction（噪声抑制） Video Engine（视频引擎） VP8 Codec（视频图像编解码器） Video jitter buffer（视频抖动缓冲器，处理视频抖动和视频信息包丢失） Image enhancements（图像质量增强） Transport SRTP（安全的实时传输协议，用以音视频流传输） Multiplexing（多路复用） P2P，STUN+TURN+ICE（用于NAT网络和防火墙穿越的） 除此之外，安全传输可能还会用到DTLS（数据报安全传输），用于加密传输和密钥协商 整个WebRTC通信是基于UDP的 三. WebRTC 的核心组件 音视频引擎：OPUS、VP8 &#x2F; VP9、H264 传输层协议：底层传输协议为 UDP 媒体协议：SRTP &#x2F; SRTCP 数据协议：DTLS &#x2F; SCTP P2P 内网穿透：STUN &#x2F; TURN &#x2F; ICE &#x2F; Trickle ICE 信令与 SDP 协商：HTTP &#x2F; WebSocket &#x2F; SIP、 Offer &#x2F; Answer 模型 四. WebRTC 音频和视频引擎 最底层是硬件设备，上面是音频捕获模块和视频捕获模块 中间部分为音视频引擎。音频引擎负责音频采集和传输，具有降噪、回声消除等功能。视频引擎负责网络抖动优化，互联网传输编解码优化 在音视频引擎之上是 一套 C++ API，在 C++ 的 API 之上是提供给浏览器的Javascript API. 五. WebRTC 协议栈 WebRTC 核心的协议都是在右侧基于 UDP 基础上搭建起来的。 其中，ICE、STUN、TURN 用于内网穿透。 DTLS 用于对传输内容进行加密，可以看做是 UDP 版的 TLS。由于 WebRTC 对安全比较重视，所以这一层是必须的。所有WebRTC组件都必须加密，并且其JavaScript API只能用于安全源（HTTPS或本地主机）。信令机制并不是由WebRTC标准定义的，所以您必须确保使用安全协议。 SRTP 与 SRTCP 是对媒体数据的封装与传输控制协议 SCTP 是流控制传输协议，提供类似 TCP 的特性，SCTP 可以基于 UDP 上构建，在 WebRTC 里是在 DTLS 协议之上。 RTCPeerConnection 用来建立和维护端到端连接，并提供高效的音视频流传输。 RTCDataChannel 用来支持端到端的任意二进制数据传输。 WebRTC 协议栈解释 ICE，STUN，TURN：用于NAT穿透，参考 WebRTC的三种架构 SDP：会话描述协议（RFC 4566） DTLS：数据报传输层安全性（RFC 6347） SCTP：流控制传输协议（RFC 4960） SRTP：安全实时传输协议（RFC 3711）","tags":["WebRTC"],"categories":["音视频编程"]},{"title":"SDP格式解析","path":"/post/2172509399.html","content":"会话描述协议（Session Description Protocol 或简写 SDP）描述的是流媒体的初始化参数。此协议由 IETF 发表为 RFC 2327。 SDP 完全是一种会话描述格式，它不属于传输协议。 SDP 用于描述多媒体通信会话，包括会话建立、会话请求和参数协商。SDP 不用于传输媒体数据，只能用于两个通信终端的参数协商，包括媒体类型、格式以及所有其他和会话相关的属性。SDP 以字符串的形式描述上述初始化参数。 一、SDP 组成SDP 是由多行文本组成的一个纯文本协议，如果将SDP从语义上分解成不同组件来描述一个多媒体会话信息，那么SDP由以下部分组成： 会话信息 网络信息 媒体信息 安全信息 服务质量和分组信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 +---------------------+ | v= | +---------------------+ +---------------------+ +---------------------+ ==== | Session Metadata | ===== | o= | | +---------------------+ +---------------------- | +---------------------+ | | t= | | +---------------------+ | | | +---------------------+ | | c= | | +---------------------+ | +---------------------+ ==== | Network Description | ===== | +---------------------+ | +---------------------+ | | a=candidate | | +---------------------+ | | | +---------------------+ | | m= | | +---------------------+ | +---------------------+ +---------------------+ ==== | Stream Description | ===== | a=rtpmap | | +---------------------+ +---------------------- | +---------------------+ | | a=fmtp | | +---------------------+ | +---------------------+ | | a=sendrecv.. | | +---------------------++---------------+| SEMANTIC || COMPONENTS OF || SDP |+---------------+ | +---------------------+ | | a=crypto | | +---------------------+ | +---------------------+ +---------------------+ ==== |Security Descriptions| =====| a=ice-frag | | +---------------------+ +---------------------- | +---------------------+ | | a=ice-pwd | | +---------------------+ | +---------------------+ | | a=fingerprint | | +---------------------+ | | | | +---------------------+ | | a=rtcp-fb | | +---------------------+ | +---------------------+ +---------------------+ ==== | Qos,Grouping | | | | Descriptions | =====| a=group | +---------------------+ +---------------------- +---------------------+ | a=rtcpmux | +---------------------+ 二、SDP 格式SDP 由多行组成，每行的的格式如下： 1&lt;type&gt;=&lt;value&gt; &lt;type&gt;: 区分大小写，代表特定的属性，例如v代表 SDP 版本。 &lt;value&gt;：UTF8 编码的文本，具体格式与类型有关。 =两边不允许存在空格。 =*表示该项是可选的。 下面是 WebRTC（branch_76）的一个真实 SDP 样本: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144// -------------------------------- 【Session Metadata部分】 --------------------------------// sdp版本号v=0// o=&lt;username&gt; &lt;sess-id&gt; &lt;sess-version&gt; &lt;nettype&gt; &lt;addrtype&gt; &lt;unicast-address&gt;// username如何没有使用-代替，3967017503571418851是整个会话的编号，2代表会话版本，如果在会话过程中有改变编码之类的操作，重新生成sdp时,sess-id不变，sess-version加1o=- 3967017503571418851 2 IN IP4 127.0.0.1//会话名s=-// 会话的起始时间和结束时间，0代表没有限制t=0 0// 表示需要共用一个传输通道传输的媒体，通过ssrc进行区分不同的流。如果没有这一行，音视频数据就会分别用单独udp端口来发送.a=group:BUNDLE audio video// WMS是WebRTC Media Stream简称;// 这一行定义了本客户端支持同时传输多个流，一个流可以包括多个track.// 一般定义了这个，后面a=ssrc这一行就会有msid,mslabel等属性.a=msid-semantic: WMS stream_id// -------------------------------- 【Stream Description部分】 --------------------------------// ------------ audio部分 -------------// m意味着它是一个媒体行.// m=audio说明本会话包含音频，9代表音频使用端口9来传输，但是在webrtc中现在一般不使用，如果设置为0，代表不传输音频,// UDP/TLS/RTP/SAVPF是表示用户支持来传输音频的协议，udp,tls,rtp代表使用udp来传输rtp包，并使用tls加密// SAVPF代表使用srtcp的反馈机制来控制通信过程// 后面的111 103 104 9 102 0 8 106 105 13 110 112 113 126表示本会话音频支持的编码，后面几行会有详细补充说明.m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 102 0 8 106 105 13 110 112 113 126// 表示你要用来接收或者发送音频使用的IP地址.// webrtc使用ice传输，不使用这个地址c=IN IP4 0.0.0.0// 用来传输rtcp的地址和端口，webrtc中不使用a=rtcp:9 IN IP4 0.0.0.0// 下面2行是ice协商过程中的安全验证信息a=ice-ufrag:kSq0a=ice-pwd:pWLGrCTwFNq6rm249ZEasHPY// 通知对端支持trickle，即sdp里面描述媒体信息和ice候选项的信息可以分开传输a=ice-options:trickle// dtls协商过程中需要的认证信息a=fingerprint:sha-256 A0:D6:B2:63:1B:69:0E:91:01:C3:88:A9:92:6F:E7:EF:5B:36:52:66:08:DF:94:A0:FE:0C:C9:06:BF:2C:38:A2// 代表本客户端在dtls协商过程中，可以做客户端也可以做服务端, 参考rfc4145 rfc4572a=setup:actpass// 前面BUNDLE行中用到的媒体标识a=mid:audio// 指出要在rtp头部中加入音量信息，参考 rfc6464a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level// 指出是双向通信，另外几种类型是recvonly,sendonly,inactivea=sendrecv// 指出rtp,rtcp包使用同一个端口来传输a=rtcp-mux// 下面十几行都是对m=audio这一行的媒体编码补充说明，指出了编码采用的编号，采样率，声道等a=rtpmap:111 opus/48000/2a=rtcp-fb:111 transport-cc// 下面一行对opus编码可选的补充说明,minptime代表最小打包时长是10ms，useinbandfec=1代表使用opus编码内置fec特性a=fmtp:111 minptime=10;useinbandfec=1a=rtpmap:103 ISAC/16000a=rtpmap:104 ISAC/32000a=rtpmap:9 G722/8000a=rtpmap:102 ILBC/8000a=rtpmap:0 PCMU/8000a=rtpmap:8 PCMA/8000a=rtpmap:106 CN/32000a=rtpmap:105 CN/16000a=rtpmap:13 CN/8000a=rtpmap:110 telephone-event/48000a=rtpmap:112 telephone-event/32000a=rtpmap:113 telephone-event/16000a=rtpmap:126 telephone-event/8000// cname用来标识一个数据源，ssrc当发生冲突时可能会发生变化，但是cname不会发生变化，也会出现在rtcp包中SDEC中，用于音视频同步a=ssrc:2603526440 cname:AyMDWB+q6ApWdpfUa=ssrc:2603526440 msid:stream_id audio_labela=ssrc:2603526440 mslabel:stream_ida=ssrc:2603526440 label:audio_label// ------------ video部分 -------------m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 127c=IN IP4 0.0.0.0a=rtcp:9 IN IP4 0.0.0.0a=ice-ufrag:kSq0a=ice-pwd:pWLGrCTwFNq6rm249ZEasHPYa=ice-options:tricklea=fingerprint:sha-256 A0:D6:B2:63:1B:69:0E:91:01:C3:88:A9:92:6F:E7:EF:5B:36:52:66:08:DF:94:A0:FE:0C:C9:06:BF:2C:38:A2a=setup:actpassa=mid:videoa=extmap:2 urn:ietf:params:rtp-hdrext:toffseta=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-timea=extmap:4 urn:3gpp:video-orientationa=extmap:5 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01a=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/playout-delaya=extmap:7 http://www.webrtc.org/experiments/rtp-hdrext/video-content-typea=extmap:8 http://www.webrtc.org/experiments/rtp-hdrext/video-timinga=sendrecva=rtcp-muxa=rtcp-rsizea=rtpmap:96 VP8/90000a=rtcp-fb:96 goog-remba=rtcp-fb:96 transport-cca=rtcp-fb:96 ccm fira=rtcp-fb:96 nacka=rtcp-fb:96 nack plia=rtpmap:97 rtx/90000a=fmtp:97 apt=96a=rtpmap:98 VP9/90000a=rtcp-fb:98 goog-remba=rtcp-fb:98 transport-cca=rtcp-fb:98 ccm fira=rtcp-fb:98 nacka=rtcp-fb:98 nack plia=rtpmap:99 rtx/90000a=fmtp:99 apt=98a=rtpmap:100 red/90000a=rtpmap:101 rtx/90000a=fmtp:101 apt=100a=rtpmap:127 ulpfec/90000a=ssrc-group:FID 1563406656 4103641903a=ssrc:1563406656 cname:AyMDWB+q6ApWdpfUa=ssrc:1563406656 msid:stream_id video_labela=ssrc:1563406656 mslabel:stream_ida=ssrc:1563406656 label:video_labela=ssrc:4103641903 cname:AyMDWB+q6ApWdpfUa=ssrc:4103641903 msid:stream_id video_labela=ssrc:4103641903 mslabel:stream_ida=ssrc:4103641903 label:video_label 2.1 协议版本第一行v=0定义了 sdp 协议的版本号。 2.2 会话发起者第二行 1o=- 3967017503571418851 2 IN IP4 127.0.0.1 定义了会话发起者的信息，格式如下： 1o=&lt;username&gt; &lt;sess-id&gt; &lt;sess-version&gt; &lt;nettype&gt; &lt;addrtype&gt; &lt;unicast-address&gt; username：发起者的用户名，不允许存在空格，如果应用不支持用户名，则为-。 sess-id：会话 id，由应用自行定义，SDP 规范建议使用 NTP(Network Time Protocol)时间戳。 sess-version：会话版本，用途由应用自行定义，只要会话数据发生变化时（比如编码）sess-version 随着递增即可。SDP 规范建议使用 NTP 时间戳。 nettype：网络类型，比如 IN 表示 Internet。 addrtype：地址类型，比如 IP4、IV6 unicast-address：域名，或者 IP 地址。 2.3 会话名1s=&lt;session name&gt; 必选，有且仅有一个s=字段，且不能为空。可以赋一个空格（即s= ），或者-。 2.4 连接信息1c=&lt;nettype&gt; &lt;addrtype&gt; &lt;connection-address&gt; 每个 SDP 至少需要包含一个会话级别的c=字段，或者在每个媒体描述后面各包含一个c=字段，（媒体描述后的c=会覆盖会话级别的c=）。例如，在上面的示例 SDP 样本中，就不存在会话级别的连接信息。 nettype：网络类型，比如 IN，表示 Internet。 addrtype：地址类型，比如 IP4、IP6。 connection-address：如果是广播，则为广播地址组；如果是单播，则为单播地址； 2.4.1 何为会话级别和媒体级别会话级部分以v =行开始，到第一个媒体级部分结束。每个媒体级部分以m =行开始，持续到下一个媒体级（即下一个m=）。 2.5 媒体描述信息SDP 可以同时包含多个媒体描述信息（如音频、视频等），格式如下： 1m=&lt;media&gt; &lt;port&gt; &lt;proto&gt; &lt;fmt&gt; ... 示例： 12m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 102 0 8 106 105 13 110 112 113 126c=IN IP4 0.0.0.0 media：媒体类型，包括 video、audio、text、application、message 等。 port：传输媒体流使用的端口，具体含义取决于使用的网络类型（在c=中声明）和使用的传输协议(proto)。 proto：传输协议，具体含义取决于c=中定义的地址类型，比如c=IP4，那么这里的传输协议运行在 IP4 之上。 fmt：媒体格式的描述，可能有多个。根据proto的不同，fmt的含义也不同。比如proto为 RTP&#x2F;SAVP 时，fmt 表示 RTP payload 的类型。如果有多个，表示在这次会话中，多种 payload 类型可能会用到，且第一个为默认的 payload 类型。数字0~95是静态负载类型；96~127是动态负载类型，需要在后面使用附近属性a = rtpmap:指定具体的格式参数。具体的每个数字代表的负载类型和含义可以参考：Real-Time Transport Protocol (RTP) Parameters如上例中的 audio 类型的111表示使用 opus 编码。 2.6 附加属性附加属性用于扩展 SDP，有 2 种作用范围：会话级别、媒体级别： 媒体级别：媒体描述（m&#x3D;）后面可以跟任意数量的 a&#x3D; 字段，对媒体描述进行扩展。 会话级别：在第一个媒体字段(media field)前，添加的 a&#x3D; 字段是会话级别的。 有下面 2 种格式： 12a=&lt;attribute&gt;a=&lt;attribute&gt;:&lt;value&gt; 2.7 时间用于声明会话的开始、结束时间，格式如下： 1t=&lt;start-time&gt; &lt;stop-time&gt; 如果&lt;stop-time&gt;是 0，表示会话没有结束的边界，但是需要在&lt;start-time&gt;之后会话才是活跃(active)的；如果&lt;start-time&gt;是 0，表示会话是永久的。 SDP for the WebRTC &gt; WebRTC：会话描述协议 SDP &gt; WebRTC 中的 SDP 协议","tags":["WebRTC","SDP"],"categories":["音视频编程"]},{"title":"网络协议(7)--HTTP与HTTPS协议","path":"/post/3654006375.html","content":"HTTP 是Hyper Text Transfer Protocol（超文本传输协议）的缩写。HTTP 协议位于 TCP&#x2F;IP 协议栈的应用层。 一、HTTP 协议介绍1.1 什么是 HTTPHTTP 是一个客户端和服务器端请求和应答的标准，主要用于从万维网（即WWW，全称 World Wide Web）服务器传输超文本到本地浏览器之间的请求数据和响应数据的协议。客户端通过使用网页浏览器或者其它的工具发起一个 HTTP 请求到服务器上指定端口（默认端口为80），服务器在收到请求之后，返回响应内容（文本、图片等）。 HTTP 协议是基于 TCP 协议来进行数据传输的。 1.2 HTTP 的版本HTTP 协议已经演化出了很多版本，它们中的大部分都是向下兼容的。客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。现在大多使用的都是1.1版本。 1.0 版本： HTTP 协议非常老的标准，为了提高系统的效率，HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。正式因为这种特性造成了一些性能上的缺陷。 1.1 版本： 克服了 HTTP 1.0 的缺陷，HTTP 1.1 支持持久连接（HTTP&#x2F;1.1 的默认模式使用带流水线的持久连接），在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。同时还增加更多的请求头和响应头来改进和扩充 HTTP 1.0 的功能（如 POST 请求头字段等）。 2.0 版本： 2015 年 5 月作为互联网标准正式发布。主要新增如下特性：多路复用，二进制分帧，首部压缩，服务端推送。 二、HTTP 消息请求2.1 URI、URL、URN通过 HTTP 或者 HTTPS 协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。我们常用的是 URL，那么 URI, URL, URN 之前有什么区别和联系了？ 123URI = Uniform Resource Identifier 统一资源标识符URL = Uniform Resource Locator 统一资源定位符URN = Universal Resource Name 统一资源名称 三者关系如下图： URI用来唯一标识符来标识一个资源，是一个通用的概念，URI由URL和URN两个子集组成。 URL通过描述资源的位置来标识资源。 URN通过资源的名字来标识资源，与其所处的位置无关，这样即使资源的位置发生变动，其URN也不会变化。 HTTP 规范将更通用的概念 URI 作为其资源标识符，但是实际上，HTTP 应用程序处理的只是 URI 的 URL 子集. 2.2 消息请求格式 2.3 HTTP 常见的请求方法HTTP 消息请求的第一个字段就是“请求方法”，HTTP 1.1 中定义的几种常见的请求方法如下（只列出了常用的）： GET向服务器获取数据。使用 GET 请求方法时，消息 Body 中没有“请求数据”（见上面消息格式的图）部分，所以将需要提交到服务器的数据放在 URL 中，因此能够提交到服务器的数据会受到 URL 长度的限制。 12345678910 各个浏览器对URL长度的限制如下（这些限制值可能随着浏览器的版本的更新而发生改变，仅供参考）：1. IE浏览器（Microsoft Internet Explorer） 对URL长度限制是2083（2K+53），超过这个限制，则自动截断（若是form提交则提交按钮不起作用）。2. FirefoxFirefox（火狐浏览器）对URL长度限制是65536字符，但实际上有效的URL最大长度不少于100,000个字符。3. Chromechrome对URL长度限制是8182个字符。4. SafariSafari对URL长度限制是80000字符。5. OperaOpera浏览器对URL长度限制是190000 字符。 POST向服务器提交数据（例如提交表单或者上传文件）。提交的数据包含在 Body 中。 三、HTTP 消息响应3.1 消息响应格式 3.2 HTTP 状态码状态代码由三位数字组成，第一个数字定义了响应的类别，共分五种类别: 123451xx消息—— 请求已被服务器接收，继续处理2xx成功 —— 请求已成功被服务器接收、理解、并接受3xx重定向 —— 需要后续操作才能完成这一请求4xx请求错误 —— 请求含有词法错误或者无法被执行5xx服务器错误 —— 服务器在处理某个正确请求时发生错误 常见的状态码有： 1234567200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，比如：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //由于超载或系统维护，服务器暂时的无法处理客户端的请求 关于 HTTP 状态码的完整定义见：https://tools.ietf.org/html/rfc2616#page-39 四、HTTPS 之密码学基础4.1 对称加密算法对称加密算法（英文：Symmetric-key algorithm）是指密码学中的一类加密算法，又称为：私钥加密、共享密钥加密。这类算法在加密和解密时使用相同的密钥（或者这 2 个密钥可以通过简单的规则相互推算）。“对称加密算法”比“非对称加密算法”速度更快，但对称加密算法的主要缺点在于要求加密和解密的双方获取相同的密钥，这样只要密钥被泄漏，则密文将不再安全。 常见的对称加密算法有： DES: Data Encryption Standard, 数据加密标准，速度较快，适用于加密大量数据的场合。 3DES: Triple DES, 是基于 DES，对一块数据用三个不同的密钥进行三次加密，强度更高。 AES: Advanced Encryption Standard, 高级加密标准，是下一代的加密算法标准，速度快，安全级别高。 Blowfish: 一个 64 位分组及可变密钥长度的对称密钥分组密码算法，可用来加密 64 比特长度的字符串。 IDEA: 在 DES 算法的基础上发展出来的，密钥为 128 位。 RC5 RC6 4.2 非对称加密算法“非对称加密算法”又称为“公开密钥加密”（英语：public-key cryptography）。也一种密码学算法类型，在这类加密算法中，需要一个“密钥对”，即“私钥”和“公钥”。这两个密钥是数学相关，用某个密钥对的“私钥”加密的信息，只能用该密钥对的“公钥”才能解密。同样，用“公钥”加密的信息，也只能用该密钥对的“私钥”才能解密。 “私钥”一般都是自己保留，不透露给他人；而“公钥”可以公开给他人。 “非对称加密算法”比“对称加密算法”安全性更高，不用担心加密密钥的泄漏，因为“公钥”是公开的，不存在泄漏。但“私钥”还是要保存妥当，不能泄露给他人，因为我们不需要在网络上传输“私钥”，所以“私钥”泄露的可能性会小很多。 但是“非对称加密算法”比“对称加密算法”的运算速度慢很多，一般在数据量比较少的时候采用“非对称加密算法”。 如上图，因为李四的“公钥”是公开的，所以张三要给李四发送信息，可以使用李四的“公钥”来加密信息。李四收到密文信息之后就可以使用自己的“私钥”来解密信息。因为其他人没有李四的“私钥”，所以就算密文信息被他人截获也无法解密。 常见的非对称加密算法有： RSA: 由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的。 DSA: Digital Signature Algorithm, 数字签名算法，是一种标准的 DSS（数字签名标准）。 ECC: Elliptic Curves Cryptography, 椭圆曲线密码编码学。 非对称算法虽然安全，但运算速度很慢，而对称算法的速度虽快，但在管理和传输密钥方面会存在安全隐患。在实际的操作过程中，我们通常采用的方式是：采用“非对称加密算法”管理“对称加密算法”的密钥，然后用“对称加密算法”加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。 使用 OpenSSL 生成 RSA 公私钥对 12345// 生成1024位的私钥openssl genrsa -out d:\\rsa_private.pem 1024// 生成私钥对应的公钥openssl rsa -in d:\\rsa_private.pem -pubout -out d:\\ca_public.pem git 客户端安装文件中的提供的ssh-keygen.exe工具也可以用来生产非对称加密的公私钥对。 4.3 散列函数散列函数（英文：Hash Function）是将任意长度的的输入转化为定长输出的算法。编程中对散列函数使用非常普遍，如MD5,但并不是所有的散列函数都适用于密码学。密码学的散列函数必须同时具有如下几个额外的特性： 单向性：给定一个散列值，无法反向找到或者构造出生成它的消息。 抗碰撞性：给定一个消息和它的散列值，无法找到具有相同散列值的不同的消息。 散列函数最常用的场合是以紧凑的方式来唯一表示大量数据，如“数字签名”中用到散列函数生成摘要信息等。 常见的散列函数： MD5：1991 年对 MD4 的改进版本，该算法不可逆。2004 年王小云等人证明了完全碰撞，在理论上说明 MD5 可以被完全攻破，2005 年，Lenstra 等人证明了现实中的碰撞，展示了两张完全不同的证书却拥有同样的 MD5 散列值。所以，目前MD5已经不安全了。 SHA-1：SHA-1 在许多安全协议中广为使用，包括 TLS 和 SSL、PGP、SSH、S&#x2F;MIME 和 IPsec，曾被视为是 MD5 的后继者，但因为在理论在已经证明 SHA1 可以被破解，但限制于计算机的计算能力所以 SHA-1 被破解还是很困难，所以 SHA-1 的安全性如今被密码学家严重质疑。 SHA-256：SHA-224、SHA-256、SHA-384、SHA-512 一起并称为 SHA-2，至今尚找出对 SHA-2 有效的破解方法。 五、数字签名与数字证书5.1 数字签名数字签名（英文：Digital Signature）类似于我们写在纸上的手写签名，它的诞生主要是为了解决如下问题： 证明该文件（或信息）是由你发送的。 证明该文件（或信息）没有被他人篡改过。 其实，我们生活中手写签名的纸质合同也是通过各种形式达到上面 2 个效果（如：合同一式多份，每份合同都有双方签名等）。 数字签名利用了“非对称加密算法”，签名和验证签名的过程如下图（图中的“认证”部分不是数字签名必须的，在“数字证书”部分会介绍）： 假设“李四”要发送一份数据给“张三”：发送者“李四”对数据生成摘要信息（摘要明文A），然后使用“李四”的“私钥”加密摘要信息；接收者“张三”收到加密的摘要信息之后： 使用“李四”的“公钥”对加密的摘要信息进行解密。若能解密则证明签名是由“李四”所签，这是因为只有“李四”的“私钥”加密的数据才能由“李四”的“公钥”解密，而又只有“李四”才有“李四”的“私钥”。 并将数据使用相同的摘要算法自己也生成一份摘要信息（摘要明文B），然后比较 A 和 B。若两者相等，则证明了该数据内容没有被他人篡改过。 通过上面的过程我们可以知道： 数字签名具有合法性的前提条件是用于加密散列值的“私钥”没有被泄露。 数字签名不负责数据的加密，若要防止数据被他人窥视，则还要结合其他手段，如使用接收者的“公钥”对数据进行加密等。 如何获取签名者的公钥？如何保证获得的公钥就是签名者的，而不是他人的？基于这些问题，数字签名需要结合后面介绍的数字证书来使用（也就是上图中的“认证”文件）。 5.2 数字证书有了上面的公开密钥算法（也就是“非对称加密算法”）之后，我们就可以通过他人的公开密钥（公钥）与其安全通信了，但是还有一些悬而未决的问题： 如何获取那些从未谋面的人的公钥？ 如何存储和吊销这些公钥？ 如何确保获取的公钥就是那个人的？ 公钥基础设施（public key infrastructure, 简称KPI）就是为了解决这个问题而建立的。PKI的目标就是为了实现不同成员在不见面的情况下进行安全通信的，我们当前采用的 PKI 模型是基于可信的第三方机构，也就是“证书颁发机构”（certification authority，简称CA）签发的证书。证书中存储了使用“证书颁发机构”的私钥加密之后的申请者的公钥信息。 5.2.1 数字证书的申请数字证书需要向“证书颁发机构”提交申请，并通过审核之后才能颁发。因为数字证书中存储的是申请者的公钥，所以如果申请者的私钥丢失或泄漏，就需要向“证书颁发机构”申请注销该证书。 Web服务器向CA申请证书的流程大致如图： “证书”中主要包含了经过“证书颁发机构”的私钥加密过后的申请者的“公钥”、“证书有效期”、“申请者信息（如域名等）”。更详细的信息，可以参考《HTTPS 权威指南》第 3.3.1 章节。 5.2.2 数字证书的验证以“Chrome 浏览器”为例：浏览器会内置各大著名的“证书颁发机构”的“公钥”，当收到 Web 服务器返回的“服务器证书”后，Chrome 会尝试使用内置的该“证书颁发机构”的“公钥”来解密该证书，如果能解密则说明该证书是“证书颁发机构”颁发的，且没有被篡改过的。然后通过解密所得的“域名”、“证书有效期”来校验该证书是否为该网站所有，是否过期等。 本文介绍的只是“数字证书”申请和验证的基本的流程，实际流程比这个复杂很多，关于“数字证书”的信息介绍可以参考《HTTPS 权威指南》 六、HTTPS在 HTTP 请求过程中，客户端与服务端之前没有进行身份确认，而且传输的数据都没有加密处理，所以很容易被劫持和篡改。 基于 HTTP 协议的这些弊端，后面就出现了HTTPS（严格的说，HTTPS 并不是一个协议，所以前面文章都没有使用“HTTPS 协议”），HTTPS 是基于SSL/TSL协议的，说白了就是HTTP+SSL/TSL，可以把 HTTPS 大致理解为“HTTP Over SSL”或者“HTTP Over TSL”。 HTTP, SSL&#x2F;TSL, HTTPS 的关系如下图： 6.1 SSL&#x2F;TSL 协议6.1.1 SSLSSL（英文：Secure Sockets Layer的缩写）中文叫“安全套接层”。最开始由 NetScape 公司研发，用以保障互联网上数据传输的安全，利用数据加密技术确保数据在网络上之传输过程中不会被截取及窃听。SSL 协议在 TCP&#x2F;IP 协议栈中位于传输层和应用层之间。以HTTPS为例，SSL 协议就位于 TCP 和 HTTP 之间： 6.1.2 TLSTLS（英文：Transport Layer Security的缩写）中文叫“传输层安全协议”，TLS 1.0是 IETF（Internet Engineering Task Force，Internet 工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为 SSL 3.1，它定义在RFC5246中。 因为 TLS 是基于 SSL 3.0 的，所以也可以认为 TLS 是 SSL 的加强版。 我们一般将二者并称为SSL/TSL协议，因为这二者可以视为同一个产品的不同阶段。 6.2 SSL&#x2F;TSL 协议的握手过程 在了解 SSL&#x2F;TSL 协议的握手过程之前，需要先阅读关于 HTTPS 的前几篇文章，对相关预备知识有所了解。 参考上面的流程图，握手过程可以分为 4 个步骤： 1). 客户端发送 Client Hello 请求到服务端，包含如下内容： SSL 或 TSL 协议的版本 客户端生成的随机串Client random； 客户端支持的加密算法列表，用于客户端和服务端加密算法的协商； 客户端支持的 HASH 算法； 2). 服务端发送 Sever Hello 响应到客户端，包含如下内容： 服务端生成的随机串Server random（第 3 步会用到）； 由“CA 证书机构”颁发的证书的Public key部分（Public key和Private Key为一对，用于非对称加密和解密）； 会话 ID 协商的加密算法（对称加密和非对称加密）和 HASH 算法。 3). 客户端发送 Client Key 到服务端，包含如下内容或步骤： 检查服务端返回的“证书”的有效性，如果无效则在浏览器上显示警告。 客户端使用前 2 步生成的Client random和Server random作为随机因子，生成另外一个随机串Premaster。 使用Public key（第 2 步服务端返回）非对称加密的随机串Premaster。 4). 服务端通知客户端握手结束，包含如下内容： 通过解密出来的Premaster生成的本次会话的Session key。 前面所有握手内容的 HASH 值，供客户端校验。 参考：http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html &gt; http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["数字证书","HTTP","HTTPS","TSL"],"categories":["编程基础"]},{"title":"网络协议(6)--TCP协议","path":"/post/1504706832.html","content":"一、TCP 特性尽管 TCP 和 UDP 都是用 IP 协议作为网络层，但 TCP 却提供和 UDP 完全不同的网络服务。TCP 是面向连接的、稳定可靠的字节流服务。TCP 首部的很多字段都是为了实现这 2 大特性而设计的。 在一个 TCP 连接中，仅有两方能进行彼此通信。所以说广播和多播不适用于 TCP 协议。 为了通过 IP 数据报实现可靠性传输，需要考虑很多事情，如数据的破坏、丢包、重复以及分片顺序混乱等问题。TCP 通过检验和、序列号、确认序列号、重发控制、连接管理以及窗口控制等机制来实现可靠性传输。 二、TCP 协议首部摘自《TCP&#x2F;IP 详解卷 1》中的关于 TCP 首部定义的图： TCP 协议的实现较 UDP 协议复杂太多，它的首部的各个字段的用法也比 UDP 首部字段复杂多，这里先对 TCP 首部字段的功能做个大概的介绍。 16 位源端口号：表示发送端端口号。传输层使用端口号来标识发送端和接收端的应用程序，而网络层是通过 IP 地址来标识主机，这样使用“IP 地址+端口”就可以精确定位到某一台主机上的某一应用程序。 16 位目的端口号：表示接收端端口号。 32 位序列号：序列号用来标识从 TCP 发送端已经发送的字节数。达到最大值$2^{32}-1$之后，再从 0 开始。 32 位确认序列号：确认序列号用来标识 TCP 接收端期望接收的下一个序列号（反过来想也就是，TCP 接收端已经接受到的字节数为确认序列号减去1）。只有ACK标志位为 1 时，该字段才有效。只要 TCP 连接建立，这个字段会一直起作用，也就是说只要 TCP 连接建立，ACK标志位会一直为 1。 4 位首部长度：和 IP 首部一样，是以4个字节(32 bit)为单位的，所以 TCP 首部最大长度也是15*4=60字节。若没有“选项”字段，长度固定为 20 字节。 6 位标志位：他们中的多个可以同时被设置为 1。 123456URG 标记后面的&quot;16位紧急指针&quot;是否有效。ACK 标记前面的&quot;32位确认序号&quot;是否有效。PSH 接收方应该尽快的将这个报文交给上层的网络层。RST 重建连接。SYN 标记这个TCP段是用来同步初始序号（ISN）的。FIN 标记发送端已经完成了发送任务。 16 位窗口大小：窗口大小为字节数，用于 TCP 的流量控制，这个值是接收端期望接受的字节数。 16 位校验和：和 UDP 类似，校验和覆盖首部和数据部分。 16 位紧急指针：只有前面提到的URG标记位为 1 时，这个字段才有效。 选项：添加一些附加数据。和 UDP 不同，TCP 的“选项”字段使用的比较多。 三、三次握手与四次挥手3.1 完整的 TCP 会话流程图本文通过真实的网络示例来讲解 TCP 的三次握手和四次挥手。读者可以先下载作者写本文时使用的网络包示例，然后使用 wireshark 打开（当然也可以使用 wireshark 随便抓取一个网络包），选中编号为No.9的包，右键选择“追踪流” –&gt; “TCP 流”： 上图是使用 wireshark 抓取的一个 Http 接口请求的过程（不含 DNS 解析等步骤），包含了 TCP 连接建立、Http 请求、Http 响应、TCP 连接断开。现在以这个示例为基础，来画出该 Http 接口请求中涉及的整个 TCP 会话的流程（也是本文最重要的图）： 箭头上方标出了该 TCP 包SYN、ACK、FIN、PSH等标志位的设置情况（大家可能注意到，除了第一个箭头上没有ACK之外，其他的箭头上都有ACK，这是因为ACK标记位只是用于标记 TCP 首部的32位确认序列号是否有效。在此之后的32位确认序列号一直有效，所以也就一直有ACK标记位。）；箭头下发标出了该 TCP 包的序号和确认序号。 seq_num：表示 32 位的序号，紧跟其后括号[]中的是相对序号。 ack_num：表示 32 位的确认序号，紧跟其后括号[]中的是相对确认序号。 payload_len：表示本次 TCP 携带的数据大小（字节）。 在三次握手和四次挥手的部分，旁边的红色粗体字表示当前端的 TCP 状态。在这个示例中是服务端执行主动关闭。 3.2 Wireshark 的相对序号相对序号是 Wireshark 引出的概念，TCP 协议中没有这个概念。Wireshark 使用相对数值来显示序号和确认序号，这个相对值是相对于初始序号（ISN）而言的。因为人类更加习惯跟踪更小数值，所以 Wireshark 默认用相对数值来展示。如果需要查看真实的序号，可以在 wireshark 中选中该网络包，在最下方的数据窗口查看，如： 3.3 Wireshark 的 TCP 流量图我们也可以使用 Wireshark 自带的统计功能来查看整个 TCP 会话的过程。通过菜单“统计” –&gt; “流量图”打开流量图窗口，在“显示”选项选择“显示的分组”，“流类型”选项选择“TCP 流”，如图： 四、TIME_WAIT 及 MSL4.1 TIME_WAIT 状态为何存在？这里我们不使用“客户端”、“服务端”来表示 TCP 连接的 2 端，转而使用“主动断开连接端”、“被动断开连接端”来表示 TCP 通讯的 2 端。因为执行主动断开连接的端可能是服务端也可能是客户端（虽然我们大多数情况下遇到的是客户端执行主动断开）。 在“主动断开连接端”收到了“被动断开连接端”发来的LAST_ACK之后，会给“被动断开连接端”回复一个ACK确认消息。但这个时候为了确保“被动断开连接端”有足够的时间能够收到该消息，“主动断开连接端”不能马上关闭 socket，需要等待一定的时间来确保“被动断开连接端”可以收到ACK确认消息。“主动断开连接端”在等待的这个时间段内的状态我们称之为TIME_WAIT状态。 归纳为一句话就是：TIME_WAIT 状态就是“主动断开的一方”在发送完最后一次 ACK 后进入的等待状态。 4.2 等待时间那么TIME_WAIT状态需要持续多久了，也就是“主动断开连接端”在发送完最后一个 ACK 之后需要等待多久了？《TCP&#x2F;IP 详解 卷 1：协议》中提到：默认 TIME_WAIT 的超时时间是 2 倍的 MSL。MSL 是Maximum Segment Lifetime的缩写，表示报文的最大生存时间，这个时间和系统的 TCP 实现有关，每个系统是不一样的。 4.2.1 windows 系统 MSL注册表HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters下的TcpTimedWaitDelay键（如果没有可以新建一个）就对应了2*MSL（2 倍的 MSL）的值。 4.2.2 Linux 系统 MSL以 CentOS 为例（摘自网络，仅供参考）： 查看默认的 MSL 值（60s）： 1cat /proc/sys/net/ipv4/tcp_fin_timeout 修改默认为 120： 1echo 120 &gt; /proc/sys/net/ipv4/tcp_fin_timeout 修改完成后，重新加载配置文件： 1sysctl -p /etc/sysctl.conf 查看是否已经生效： 1sysctl -a | grep fin 4.3 SO_REUSEADDR 如果进程中的某个 TCP 连接处于TIME_WAIT等待状态，因为这个等待时间比较长，在这期间该连接使用的端口将一直被占用。 如果一个服务端进程（绑定了某个端口）退出（正常退出或异常退出）后，立即启动一个新的该进程，可能由于 Windows 系统对端口的释放不及时，导致这个端口还没有被释放，不能被再次绑定，从而导致新进程绑定端口失败。 那么遇到上面的问题如何解决了？我们在网络编程中经常设置的SO_REUSEADDR选项就可以解决这个问题， 12int flag = 1;setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast&lt;const char*&gt;(&amp;flag), sizeof(flag)); SO_REUSEADDR提供如下四个功能： SO_REUSEADDR 允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在。这通常是重启监听服务器时出现，若不设置此选项，则bind时将出错。 SO_REUSEADDR 允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地 IP 地址即可。由于设置该Socket选项不需要任何特殊权限，恶意程序可以轻易使用SO_REUSEADDR强制绑定已用于标准网络协议服务的套接字，从而使这些服务拒绝访问。不用担心，我们可以使用SO_EXCLUSIVEADDRUSE选项解决这个问题。 SO_REUSEADDR 允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地 IP 地址即可。这一般不用于 TCP 服务器。 SO_REUSEADDR 允许完全重复的捆绑：当一个 IP 地址和端口绑定到某个套接口上时，还允许此 IP 地址和端口捆绑到另一个套接口上。一般来说，这个特性仅在支持多播的系统上才有，而且只对 UDP 套接口而言（TCP 不支持多播）。 其中第一个功能就可以用来解决该问题。 关于SO_REUSEADDR更详细的介绍可以访问微软的官方文档：using-so-reuseaddr-and-so-exclusiveaddruse 五、为什么要进行 3 次握手？前面的文章介绍了 TCP 的三次握手，那么 TCP 的握手为什么是 3 次了？ 本文从 3 个角度来解释为什么要进行 3 次握手？ 1TCP 的握手的目的是让通信双方都确定双方能够正常发送和接收信息。 第一步，服务端收到客户端发送的 SYN，服务端能够确定如下信息：“客户端的发送功能正常，服务端自己的接受功能正常”。但客户端还什么都不能确定。第二步，客户端收到服务端回复的 SYN+ACK，截至目前，客户端能够确定如下信息：“客户端自己的发送&#x2F;接收功能都正常，服务端的接收和发送功能都正常”；服务端还是只能确定自己的接受功能正常，还不知道自己的发送功能是否正常，客户端的接受功能是否正常。 大家可以看到，到第二步完成，客户端和服务端能够确认的信息分别如下： 1234567891011客户端能够确定： 客户端-发送 正常 客户端-接收 正常 服务端-发送 正常 服务端-接收 正常服务端能够确定： 客户端-发送 正常 客户端-接收 ？ 服务端-发送 ？ 服务端-接收 正常 从上面表可以看到，第二步完成之后，服务端还能不能确定“服务端的发送功能”和“客户端的接收功能”是否正常。所以需要第三步。 第三步，服务端收到客户端回复的 ACK，服务端能够确定如下信息：客户端的发送功能正常，服务端的接收功能正常。 2我们可以假设“客户端”和“服务端”是 2 个人，模拟这 2 个人打招呼的形式来理解为什么需要 3 次握手。 123客户端：hi，服务端，你能听到我说话吗？服务端：hi，客户端，我能听到你说的话，你能听到我说的话吗？客户端：嗯，服务端，我也能听到你说的话。 3对照文章开始处 TCP 握手图的前 2 步，现在我们假设 TCP 只有 2 次握手： 服务端在收到客户端的SYN并且回复SYN+AKC之后，就认为连接已经建立完成了，并为之分配相应的资源。但客户机却因为网络延迟等问题一直没收到服务端回复的SYN+ACK，这样客户端就认为连接没有建立成功，糟糕的是，客户端会因为连接没有成功而不停的重试，这样每次服务端都会认为连接建立成功并分配资源。 如果按照上面描述的那样，客户端一直没有收到服务端回复的SYN+ACK，且一直这样尝试建立连接，就会造成服务端资源极大的浪费，加重服务端的负担。 六、为什么要进行 4 次挥手？ 对比上面的图，我们不难发现：4 次挥手相比 3 次握手多了一次，主要是因为握手的ACK和SYN是合并在一条发送的，而挥手的ACK和FIN是分开发送的，所以挥手比握手多了一次。 现在我们分析为什么 TCP 挥手的ACK和FIN（分别对应图中的第 2,3 条线）要分开发送？ “被动断开方”之所以叫称之为“被动”是因为 TCP 连接的断开并不是它想的，也不是它主动触发的，是对面的“主动断开方”想要断开的，也许这个时候“被动断开方”还正想发送点数据给“主动断开方”了。 为了让“被动断开方”有机会将想要发送的数据发送完，主动断开方在发送完FIN并收到了ACK确认信息进入FIN_WAIT_2状态后，只关闭了发送功能了，但仍然保留接收功能。这样“被动断开方”就有机会将没有发送完的数据发送完成，发送完成之后，“被动断开方”也发送一个FIN，相当于告诉“主动断开方”：“我的数据已经发完了呀，以后不会再发数据了，你可以安心的把接收功能关闭了，另外我自己也要关闭了呀”。 《TCP&#x2F;IP 详解 卷 1：协议》在线阅读地址：http://www.52im.net/topic-tcpipvol1.html 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["TCP"],"categories":["编程基础"]},{"title":"Windows的消息机制","path":"/post/4206756384.html","content":"一、消息队列首先我们要明确一个观点：窗口是和线程相关联的，消息队列也是和线程相关联的，这个线程无论是主线程还是子线程。 当一个线程被创建时，系统假定该线程不会被用于任何与用户界面相关的任务，所以不会为它分配相应的资源（如消息队列等），因为这样可以减少线程对系统资源的占用。 但是，一旦这个线程调用一个与图形用户界面有关的函数（例如检查它的消息队列或建立一个窗口），系统就会为该线程分配一些额外的资源，以便它能够执行与用户界面有关的任务。特别是，系统会分配一个THREADINFO结构，并将这个数据结构与线程关联起来。 THREADINFO结构是微软内部的、没有被公开的数据结构，我们无法找到这个结构体的准确的定义。但从其他文档中可以得知，THREADINFO结构包含： 一组成员变量，利用这组成员，线程可以认为它是在自己独占的环境中运行。 登记消息队列（posted-message queue） 发送消息队列（ send-message queue） 应答消息队列（ reply -message queue） 虚拟输入队列（virtualized-input queue） 唤醒标志（wake flag） 用来描述线程局部输入状态的若干变量。 上图描述了THREADINFO结构中的各个成员。线程拥有了THREADINFO结构也就有了各种消息队列。 二、窗口消息处理函数下面是一个完整的、简单的创建Windows窗体的C++代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;windows.h&gt;LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) &#123; switch (message) &#123; case WM_DESTROY: PostQuitMessage(0); return 0; &#125; return DefWindowProc(hwnd, message, wParam, lParam);&#125;int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)&#123; WNDCLASS wndclass; wndclass.style = CS_HREDRAW | CS_VREDRAW; wndclass.cbClsExtra = 0; wndclass.cbWndExtra = 0; wndclass.hInstance = hInstance; wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION); wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH); wndclass.lpszMenuName = NULL; wndclass.lpfnWndProc = WndProc; //设置窗体消息处理函数 wndclass.lpszClassName = TEXT(&quot;SimpleWindow&quot;); if (!RegisterClass(&amp;wndclass)) &#123; //注册窗体类 return 0; &#125;; HWND hwnd = CreateWindow(TEXT(&quot;SimpleWindow&quot;), // window class name TEXT(&quot;SimpleWindow&quot;), // window caption WS_OVERLAPPEDWINDOW, // window style CW_USEDEFAULT,// initial x position CW_USEDEFAULT,// initial y position CW_USEDEFAULT,// initial x size CW_USEDEFAULT,// initial y size NULL, // parent window handle NULL, // window menu handle hInstance, // program instance handle NULL); ShowWindow(hwnd, SW_SHOW); MSG msg; while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; return msg.wParam;&#125; 上面代码中的WndProc函数就是窗口消息处理函数。消息循环中的DispatchMessage函数派发消息时，系统就会调用这个函数对消息进行处理。 三、消息循环消息循环是程序员自己编写的从线程消息队列中循环获取（Get或Peek）消息的循环体，代码大致如下： 12345while(GetMessage(&amp;Msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;Msg); DispatchMessage(&amp;Msg);&#125; 3.1 循环何时结束？GetMessage函数的返回值如下： 123收到WM_QUIT消息，返回0收到非WM_QUIT消息，返回非0错误，返回-1 利用GetMessage函数返回值的特性，在收到WM_QUIT消息之后，消息循环就会结束。 3.2 TranslateMessageTranslateMessage函数的作用就是将虚拟键值信息转换为字符信息。这一步并不是必须的。 3.3 DispatchMessage将消息派发到窗口的消息处理函数（如第2节中的WndProc函数）。 四、PostMessage4.1 PostMessage原理12345BOOL PostMessage( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam); 当一个线程调用这个函数时，系统要确定是哪一个线程建立了用hwnd参数标识的窗口。然后系统分配一块内存，将这个消息参数存储在这块内存中，并将这块内存增加到相应线程的登记消息队列中。并且，这个函数还设置QS_POSTMESSAGE唤醒位。PostMessage函数在登记了消息之后立即返回，调用该函数的线程不知道登记的消息是否被指定窗口的窗口过程所处理。实际上，有可能这个指定的窗口永远不会收到登记的消息。 4.2 PostThreadMessage还可以通过调用PostThreadMessage将消息放置在线程的登记消息队列中。 12345BOOL PostThreadMessage( DWORD dwThreadId, UINT uMsg, WPARAM wParam, LPARAM lParam); 4.3 PostQuitMessage为了终止线程的消息循环，可以调用PostQuitMessage函数。PostQuitMessage函数类似于：PostThreadMessage(GetCurrentThreadId(), WM_QUIT, nExitCode, 0);但是，PostQuitMessage并不实际登记一个消息到任何一个THREADINFO结构的消息队列。只是在内部，PostQuitMessage会设定QS_QUIT唤醒标志，并对THREADINFO结构的nExitCode成员进行设置。因为这些操作永远不会失败，所以PostQuitMessage的原型被定义成VOID返回类型。 五、SendMessageSendMessage的实现分为2种情况：向本线程的窗口发送消息、向其他线程的窗口发送消息。 5.1 向本线程的窗口发送消息如果调用SendMessage的线程向本线程所建立的一个窗口发送一个消息，SendMessage的做法很简单：直接调用指定窗口的“窗口消息处理函数”，将其作为一个子例程。当“窗口消息处理函数”完成对消息的处理后，该函数会返回一个值给SendMessage，SendMessage再将这个值返回给调用线程。 5.2 向其他线程的窗口发送消息但是，当调用SendMessage的线程向其他线程所建立的窗口发送消息时，SendMessage的内部工作就复杂得多（即使两个线程在同一进程中也是如此）。 Windows要求建立窗口的线程来处理该窗口的消息。所以当一个线程调用SendMessage向一个由其他进程所建立的窗口发送一个消息，也就是向其他的线程发送消息，发送线程不可能处理窗口消息，因为发送线程不是运行在接收进程的地址空间中，因此不能访问相应窗口过程的代码和数据。实际上，发送线程要挂起，而由另外的线程处理消息。所以为了向其他线程建立的窗口发送一个窗口消息，系统必须执行下面的动作： 首先，发送的消息要追加到接收线程的发送消息队列，同时还为这个线程设定QS_SENDMESSAGE标志（后面将讨论）。其次，如果接收线程已经在执行代码并且没有等待消息（等待消息是指：如调用GetMessage、PeekMessage或WaitMessage等），发送的消息不会被处理，系统不能中断线程来立即处理消息。当接收进程在等待消息时，系统首先检查线程的QS_SENDMESSAGE唤醒标志是否被设定，如果是，系统扫描发送消息队列中消息的列表，并找到第一个发送的消息。有可能在这个队列中有几个发送的消息。例如，几个线程可以同时向一个窗口分别发送消息。当发生这样的事时，系统只是将这些消息追加到接收线程的发送消息队列中。 当接收线程等待消息时，系统从发送消息队列中取出第一个消息并调用适当的窗口过程来处理消息。如果在发送消息队列中再没有消息了，则QS_SENDMESSAGE唤醒标志被关闭。当接收线程处理消息的时候，调用SendMessage的线程被设置成空闲状态（idle），等待一个消息出现在它的应答消息队列中。在发送的消息处理之后，窗口过程的返回值被登记到发送线程的应答消息队列中。发送线程现在被唤醒，取出包含在应答消息队列中的返回值。这个返回值就是SendMessage的返回值。这时，发送线程继续正常执行。 当一个线程等待SendMessage返回时，它基本上是处于空闲状态。但它可以执行一个任务：如果系统中另外一个线程向一个窗口发送消息，这个窗口是由这个等待SendMessage返回的线程所建立的，则系统要立即处理发送的消息。在这种情况下，系统不必等待线程去调用GetMessage、PeekMessage或WaitMessage。 由于Windows使用上述方法处理线程之间发送的消息，所以有可能造成线程挂起。例如，当处理发送消息的线程含有错误时，会导致进入死循环。那么对于调用SendMessage的线程会发生什么事呢？它会恢复执行吗？这是否意味着一个程序中的bug会导致另一个程序挂起？答案是确实有这种可能。 利用4个函数—— SendMessageTimeOut、SendMessageCallback、SendNotifyMessage和ReplayMessage，可以编写保护性代码防止出现这种情况。","tags":["Windows消息"],"categories":["Windows编程"]},{"title":"网络协议(5)--UDP协议","path":"/post/4190400644.html","content":"一、什么是 UDP 协议？UDP 是 User Datagram Protocol 的简称，中文名是用户数据报协议，是 OSI 参考模型中的传输层协议，它是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。 UDP 的正式规范是IETF RFC768。UDP 在 IP 报文的协议号是 17。 ISO 七层模型： 二、UDP 报头UDP 报头的结构如图： UDP 报头由 4 个部分组成，其中两个是可选的（粉红背景标出部分）： 各 16bit 的来源端口和目的端口用来标记发送和接受的应用进程。因为 UDP 不需要应答，所以来源端口是可选的，如果来源端口不用，那么置为零。 在目的端口后面是长度固定的以字节为单位的报文长度域，用来指定 UDP 数据报包括数据部分的长度，长度最小值为 8byte。 首部剩下地 16bit 是用来对首部和数据部分一起做校验和（Checksum）的，这部分是可选的，但在实际应用中一般都使用这一功能。 UDP 和 TCP 的校验和都覆盖到了他们的首部和数据，而之前介绍的 IP 首部的校验和只覆盖了 IP 首部。 三、TCP 和 UDP 区别 特征点 TCP UDP 是否连接 面向连接 面向非连接 传输可靠性 可靠 会丢包，不可靠 应用场景 传输数据量大 传输量小 速度 慢 快 TCP(传输控制协议)提供的是面向连接、可靠的字节流服务。当客户端和服务器彼此交换数据前，必须先在双方之间建立一个 TCP 连接，之后才能传输数据。TCP 提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。UDP(用户数据报协议)是一个简单的面向数据报的运输层协议。UDP 不提供可靠性，它只是把应用程序传给 IP 层的数据报发送出去，但是并不能保证它们能到达目的地。由于 UDP 在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。 由于 UDP 缺乏拥塞控制（congestion control），需要基于网络的机制来减少因失控和高速 UDP 流量负荷而导致的拥塞崩溃效应。换句话说，因为 UDP 发送者不能够检测拥塞，所以像使用包队列和丢弃技术的路由器这样的网络基本设备往往就成为降低 UDP 过大通信量的有效工具。数据报拥塞控制协议（DCCP）设计成通过在诸如流媒体类型的高速率 UDP 流中，增加主机拥塞控制，来减小这个潜在的问题。 四、应用场景由于缺乏可靠性且属于非连接导向协议，UDP 的应用一般必须允许一定量的丢包、出错和复制粘贴。但有些应用，比如 TFTP，需要可靠性保证，则必须在应用层增加根本的可靠机制。但是绝大多数 UDP 应用都不需要可靠机制，甚至可能因为引入可靠机制而降低性能。流媒体、即时多媒体游戏和 IP 电话（VoIP）就是典型的 UDP 应用。如果某个应用需要很高的可靠性，那么可以用传输控制协议（即 TCP 协议）来代替 UDP。 使用 UDP 协议的应用有：域名系统（DNS）、简单网络管理协议（SNMP）、动态主机配置协议（DHCP）、路由信息协议（RIP）等等。 因为 UDP 不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用 UDP 较多，因为它们即使偶尔丢失几个数据包，也不会对接收结果产生太大影响。 五、单播、多播、广播、组播假设 A(all 简写)代表所有的机器，M(multiple 简写)代表 A 中的多个机器，G(group 简写)代表一组机器，1 代表一台机器，那么： 12345671 -&gt; 1 就是单播；1 -&gt; M 就是多播；1 -&gt; A 就是广播；1 -&gt; G 就是组播；当M=A时，多播就是广播；当M=G时，多播就是组播； 多播包括组播和广播，组播、广播都是多播的一种表现形式。 5.1 单播单播是主机之间“一对一”的通讯模式。发送方需要指定一个接收方的 IP 和端口，只有这个接收方会收到数据报。不会对子网内的其他机器产生影响。在单播模式下，服务器针对每个客户机都要发送数据流，服务器流量=客户机数量×客户机流量，在客户机数量大、每个客户机流量大的应用（如流媒体）中，服务器将不堪重负。 5.1.1 单播发送端因为 UDP 不是面向连接的，且不可靠的，所以发送端在调用sendto之后，就算sendto返回成功，也不代表接收端一定收到了数据，可能接收端压根都没启动，也是有可能的。不能根据sendto的返回值来确保接收端一定收到了数据。如果需要数据传输的可靠性得到保证，可以使用 TCP 或者通过业务逻辑来保证。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;WinSock2.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)void SendLogic() &#123; WSADATA wsaData; WORD wVersionRequested = MAKEWORD(1, 0); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0); if (socket == INVALID_SOCKET) &#123; printf(&quot;WSASocket failed, error=%d &quot;, WSAGetLastError()); return; &#125; sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(6000); // 接收端端口 addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); // 接收端IP char buf[100] = &#123; &quot;hello&quot; &#125;; int err = sendto(socket, buf, strlen(buf), 0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)); if (err == SOCKET_ERROR) &#123; printf(&quot;sendto failed, error=%d &quot;, WSAGetLastError()); return; &#125; printf(&quot;[SEND] %s OK &quot;, buf); WSACleanup();&#125;int main()&#123; SendLogic(); getchar(); return 0;&#125; 5.1.2 单播接收端因为 UDP 不是面向连接的，所以接收端不用 listen，也不用 accept，只需要绑定到指定的端口和地址即可。recvfrom是同步的，会阻塞住等待数据的到来。如果要使用异步方式，可以使用WSARecvFrom结合 ICOP 的方式来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;WinSock2.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)void RecvLogic() &#123; WSADATA wsaData; WORD wVersionRequested = MAKEWORD(1, 0); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0); if (socket == INVALID_SOCKET) &#123; printf(&quot;WSASocket failed, error=%d &quot;, WSAGetLastError()); return; &#125; sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(6000); // 端口 addr.sin_addr.s_addr = INADDR_ANY; // 任意IP地址 int err = bind(socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)); if (err == SOCKET_ERROR) &#123; printf(&quot;bind failed, error=%d &quot;, WSAGetLastError()); return; &#125; while (true) &#123; // TODO：未考虑退出的情况 char buf[100] = &#123; 0 &#125;; int fromlen = sizeof(addr); err = recvfrom(socket, buf, 100, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;addr), &amp;fromlen); if (err == SOCKET_ERROR) &#123; printf(&quot;recvfrom failed, error=%d &quot;, WSAGetLastError()); return; &#125; printf(&quot;[RECV] %s &quot;, buf); &#125; WSACleanup();&#125;int main()&#123; RecvLogic(); getchar(); return 0;&#125; 5.2 广播广播是主机之间“一对所有”的通讯模式。子网的一台主机作为发送发广播一条信息，该子网中的所有主机都可以接收到该信息（不管你是否需要该信息）。在广播模式下，由于服务器不用向每个客户机单独发送数据，所以服务器流量负载极低。无法在广域网上进行广播，而且广播消息不会被路由转发，所以只能在一个子网中进行广播。因为如果路由器转发了广播信息，那么势必会引起网络瘫痪。这也是为什么 IP 协议的设计者故意没有定义互联网范围的广播机制。 主机发送广播消息时，需要指定目的 IP 地址为255.255.255.255和接受者的端口号。 UDP 的广播和单播的不同在于发送端（接收端的实现和单播方式没有区别）的实现上： 发送端将套接字配置为发送广播消息，使用setsockopt函数。 发送地址更改为受限的广播地址255.255.255.255。 需要说明的是广播地址不仅仅只有255.255.255.255一个。广播地址分为受限的广播、指向网络的广播、指向子网的广播、指向所有子网的网广播。255.255.255.255只是受限的广播地址。 5.2.1 广播发送端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;WinSock2.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)void SendLogic() &#123; WSADATA wsaData; WORD wVersionRequested = MAKEWORD(1, 0); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0); if (socket == INVALID_SOCKET) &#123; printf(&quot;WSASocket failed, error=%d &quot;, WSAGetLastError()); return; &#125; // 将套接字配置为发送广播消息 int broadcast = 1; int err = setsockopt(socket, SOL_SOCKET, SO_BROADCAST, reinterpret_cast&lt;const char*&gt;(&amp;broadcast), sizeof(int)); if (err == SOCKET_ERROR) &#123; printf(&quot;setsockopt failed, error=%d &quot;, WSAGetLastError()); return; &#125; sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(6000); addr.sin_addr.s_addr = INADDR_BROADCAST; // 也可以换成inet_addr(&quot;255.255.255.255&quot;) char buf[100] = &#123; &quot;hello&quot; &#125;; err = sendto(socket, buf, strlen(buf), 0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)); if (err == SOCKET_ERROR) &#123; printf(&quot;sendto failed, error=%d &quot;, WSAGetLastError()); return; &#125; printf(&quot;[BROADCAST] %s OK &quot;, buf); WSACleanup();&#125;int main()&#123; SendLogic(); getchar(); return 0;&#125; 5.2.2 广播接收端(和单播一样)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;WinSock2.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)void RecvLogic() &#123; WSADATA wsaData; WORD wVersionRequested = MAKEWORD(1, 0); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0); if (socket == INVALID_SOCKET) &#123; printf(&quot;WSASocket failed, error=%d &quot;, WSAGetLastError()); return; &#125; sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(6000); addr.sin_addr.s_addr = INADDR_ANY; int err = bind(socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)); if (err == SOCKET_ERROR) &#123; printf(&quot;bind failed, error=%d &quot;, WSAGetLastError()); return; &#125; while (true) &#123; char buf[100] = &#123; 0 &#125;; int fromlen = sizeof(addr); err = recvfrom(socket, buf, 100, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;addr), &amp;fromlen); if (err == SOCKET_ERROR) &#123; printf(&quot;recvfrom failed, error=%d &quot;, WSAGetLastError()); return; &#125; printf(&quot;[RECV] %s &quot;, buf); &#125; WSACleanup();&#125;int main()&#123; RecvLogic(); getchar(); return 0;&#125; 5.3 组播组播是主机之间“一对多”的通讯模式。一台主机加入一个组播 IP 后，之后向该组播 IP 发送的数据报都会发送到该主机。专门为组播划出了一个地址范围，在 IPv4 中为 D 类地址，范围是224.0.0.0 ~ 239.255.255.255，并将 D 类地址划分为局部链接组播地址、预留组播地址、管理权限组播地址如下：局部链接地址：224.0.0.0～224.0.0.255，用于局域网，路由器不转发属于此范围的 IP 包。 预留组播地址：224.0.1.0～238.255.255.255，用于全球范围或网络协议。 管理权限地址：239.0.0.0～239.255.255.255，组织内部使用，用于限制组播范围。 组播就是将数据发送到一组主机。接收端如果要接收消息，则需要加入到该分组，分组是用 IP 来标识的。从网络协议(3)--IP协议可以知道，适用于分组的 IP 有224.0.0.0 ~ 239.255.255.255。同样，发送端就需要将数据发送到该分组 IP。 5.3.1 组播发送端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;WinSock2.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)void SendLogic() &#123; WSADATA wsaData; WORD wVersionRequested = MAKEWORD(1, 0); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0); if (socket == INVALID_SOCKET) &#123; printf(&quot;WSASocket failed, error=%d &quot;, WSAGetLastError()); return; &#125; // 将套接字配置为发送广播消息 int broadcast = 1; int err = setsockopt(socket, SOL_SOCKET, SO_BROADCAST, reinterpret_cast&lt;const char*&gt;(&amp;broadcast), sizeof(int)); if (err == SOCKET_ERROR) &#123; printf(&quot;setsockopt failed, error=%d &quot;, WSAGetLastError()); return; &#125; sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(6000); addr.sin_addr.s_addr = inet_addr(&quot;225.0.0.37&quot;); // 向指定广播组发送消息 char buf[100] = &#123; &quot;hello&quot; &#125;; err = sendto(socket, buf, strlen(buf), 0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)); if (err == SOCKET_ERROR) &#123; printf(&quot;sendto failed, error=%d &quot;, WSAGetLastError()); return; &#125; printf(&quot;[BROADCAST] %s OK &quot;, buf); WSACleanup();&#125;int main()&#123; SendLogic(); getchar(); return 0;&#125; 5.3.2 组播接收端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;WinSock2.h&gt;#include &lt;Ws2ipdef.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)void RecvLogic() &#123; WSADATA wsaData; WORD wVersionRequested = MAKEWORD(1, 0); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0); if (socket == INVALID_SOCKET) &#123; printf(&quot;WSASocket failed, error=%d &quot;, WSAGetLastError()); return; &#125; sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(6000); addr.sin_addr.s_addr = htonl(INADDR_ANY); int err = bind(socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)); if (err == SOCKET_ERROR) &#123; printf(&quot;bind failed, error=%d &quot;, WSAGetLastError()); return; &#125; // 将SOCKET加入广播组 // struct ip_mreq mreq; // 引入头文件&lt;Ws2ipdef.h&gt; mreq.imr_multiaddr.s_addr = inet_addr(&quot;225.0.0.37&quot;); // 广播组地址 mreq.imr_interface.s_addr = htonl(INADDR_ANY); // 注：使用IP_DROP_MEMBERSHIP可以离开广播组 err = setsockopt(socket, IPPROTO_IP, IP_ADD_MEMBERSHIP, reinterpret_cast&lt;const char*&gt;(&amp;mreq), sizeof(ip_mreq)); if (err == SOCKET_ERROR) &#123; printf(&quot;setsockopt failed, error=%d &quot;, WSAGetLastError()); return; &#125; while (true) &#123; char buf[100] = &#123; 0 &#125;; int fromlen = sizeof(addr); err = recvfrom(socket, buf, 100, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;addr), &amp;fromlen); if (err == SOCKET_ERROR) &#123; printf(&quot;recvfrom failed, error=%d &quot;, WSAGetLastError()); return; &#125; printf(&quot;[RECV] %s &quot;, buf); &#125; WSACleanup();&#125;int main()&#123; RecvLogic(); getchar(); return 0;&#125; 《TCP&#x2F;IP 详解 卷 1：协议》在线阅读地址：http://www.52im.net/topic-tcpipvol1.html 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["UDP"],"categories":["编程基础"]},{"title":"网络协议(4)--ICMP协议","path":"/post/349088656.html","content":"互联网控制消息协议（英文：Internet Control Message Protocol，ICMP）是互联网协议族的核心协议之一。定义在 RFC 792 文档中。ICMP 的消息大致可以分为两类：一类是差错报文，即通知出错原因的错误消息（如 traceroute），另一类是查询报文，即用于诊断的查询消息（如 ping）。使用 ICMP 协议的典型应用有 ping 和 traceroute（windows 上叫 tracert）。 ICMP 是在 IP 数据报的内部被传输的，紧跟着 IP 报文的首部（如果 IP 首部有可选部分，则紧跟着可选部分）： 图上的 IP 首部 20 字节是在 IP 报文首部不含可选部分的情况下，若 IP 首部含可选部分，则大于 20 字节。 一、 ICMP 报文格式 所有 ICMP 报文的前 4 个字节都是一样的，但剩下的其他字节则根据报文类型的不同而不同。 8位类型字段和8位代码字段共同决定一种 ICMP 报文的类型。 校验和的计算方法和 IP 首部校验和的计算方式相同，但 ICMP 校验和覆盖整个 ICMP 报文。 IP 首部校验和的计算方式和原理参考：网络协议(3)--IP协议UDP 和 TCP 的校验和同样也都覆盖到了他们的首部和数据。 《TCP&#x2F;IP 详解 卷 1：协议》在线阅读地址：http://www.52im.net/topic-tcpipvol1.html 二、实际应用2.1 Ping2.1.1 Ping 程序原理大多数系统都已经在内核中内置了 ping 服务器的功能，所以不需要单独的其他进程来接收主机的 ping 请求。 windows 系统下，输入ping /?命令查看 ping 的用法如下： 123456789101112131415161718192021222324用法: ping [-t] [-a] [-n count] [-l size] [-f] [-i TTL] [-v TOS] [-r count] [-s count] [[-j host-list] | [-k host-list]] [-w timeout] [-R] [-S srcaddr] [-4] [-6] target_name选项: -t Ping 指定的主机，直到停止。 若要查看统计信息并继续操作 - 请键入 Control-Break； 若要停止 - 请键入 Control-C。 -a 将地址解析成主机名。 -n count 要发送的回显请求数。 -l size 发送缓冲区大小。 -f 在数据包中设置“不分段”标志(仅适用于 IPv4)。 -i TTL 生存时间。 -v TOS 服务类型(仅适用于 IPv4。该设置已不赞成使用，且 对 IP 标头中的服务字段类型没有任何影响)。 -r count 记录计数跃点的路由(仅适用于 IPv4)。 -s count 计数跃点的时间戳(仅适用于 IPv4)。 -j host-list 与主机列表一起的松散源路由(仅适用于 IPv4)。 -k host-list 与主机列表一起的严格源路由(仅适用于 IPv4)。 -w timeout 等待每次回复的超时时间(毫秒)。 -R 同样使用路由标头测试反向路由(仅适用于 IPv6)。 -S srcaddr 要使用的源地址。 -4 强制使用 IPv4。 -6 强制使用 IPv6。 其中-r参数用于记录跃点路由，类似 tracert 的功能，但他们的实现方式不一样，ping 是通过在 IP 头部“选项”字段记录经过的每个路由的 IP 来实现记录路由功能的，这种实现有个限制，就是 IP 首部“选项”字段的最大字节数为 40 字节，所以最多只能记录 10 个 IP。 ping 功能通过 ICMP 的回显请求和回显应答来实现，也就是说 ping 是基于 ICMP 协议实现的。 ICMP 回显请求和回显应答的报文格式如下： 标识符：在实现中，一般将该字段设置为当前进程 ID。这样即使在同一台主机上同时运行了多个 ping 程序实例， ping 程序也可以识别出返回的信息属于哪个进程。 序号：序号一般从 0 开始（没有强制性，从任何数字开始都可以），每发送一次新的回显请求就加 1。因为 ICMP 是在 IP 数据报内部被传输的，而 IP 协议又是不可靠、无连接的，所以 ping 程序打印出返回的每个分组的序列号，方便我们查看是否有分组丢失、失序或重复。 选项：在“选项”字段中，我们一般放入发送时间戳，这样在收到回应的时候可以用来计算本次 ping 的耗时。我们经常会指定 ping 包的大小，所以也会在“选项”字段中填充一些废数据来让包达到一定大小，在下面的FillPingPacket函数就有这样的实现。 2.1.2 C++代码实现定义 ICMP、ping 首部networkprotocolheader.h头文件中定义了 IP 协议、ICMP 协议等协议的首部结构体。 12345678910111213141516171819#pragma pack(1)#define __u8 unsigned char#define __u16 unsigned short#define __u32 unsigned longstruct icmp_common_hdr &#123; __u8 type; __u8 code; __u16 check; /*Other content start here. */&#125;;struct ping_header &#123; icmp_common_hdr common_hdr; __u16 id; __u16 seq; __u32 timestamp;&#125;;#pragma pack() 程序执行参数12345678910111213DECLARE_bool(h); // 帮助DECLARE_bool(t); // ping指定的主机直到停止DECLARE_int(w); // 等待每次回复的超时时间(毫秒)DECLARE_int(s); // 发送ping包超时时间(毫秒)DECLARE_int(l); // 发送缓冲区大小DECLARE_int(i); // TTLDEFINE_bool(h, false, &quot;帮助&quot;);DEFINE_bool(t, false, &quot;ping指定的主机直到停止&quot;);DEFINE_int(w, 3000, &quot;等待每次回复的超时时间(毫秒)&quot;);DEFINE_int(s, 3000, &quot;发送ping包超时时间(毫秒)&quot;);DEFINE_int(l, 32, &quot;发送缓冲区大小&quot;);DEFINE_int(i, 128, &quot;TTL&quot;); ping 程序的执行参数的定义和解析由 webrtc 的&quot;rtc_base/flags.h&quot;支持。 完整代码代码中的某些功能，如参数解析、断言、时间戳等基于 webrtc 的rtc_base实现，这些功能也可以很方便的自己实现。 另外，使用原始套接字需要管理员权限，如果需要绕开管理员权限，可以使用 windows 提供的IcmpSendEcho系列函数。 在发送 ping 请求的时候，我们只封装了一个 ICMP 报文，并没有自己手动添加 IP 头，封装 IP 报文。因为内核会自动添加 IP 头，如果想自己添加 IP 头，可以调用setsockopt设置IP_HDRINCL选项，告诉内核由我们自己来封装 IP 头。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271#include &lt;WinSock2.h&gt;#include &lt;ws2spi.h&gt;#include &lt;ws2tcpip.h&gt;#include &quot;rtc_base/networkprotocolheader.h&quot;#include &quot;rtc_base/checks.h&quot;#include &quot;rtc_base/flags.h&quot;#include &quot;rtc_base/timeutils.h&quot;DECLARE_bool(h); // 帮助DECLARE_bool(t); // ping指定的主机直到停止DECLARE_int(w); // 等待每次回复的超时时间(毫秒)DECLARE_int(s); // 发送ping包超时时间(毫秒)DECLARE_int(l); // 发送缓冲区大小DECLARE_int(i); // TTLDEFINE_bool(h, false, &quot;帮助&quot;);DEFINE_bool(t, false, &quot;ping指定的主机直到停止&quot;);DEFINE_int(w, 3000, &quot;等待每次回复的超时时间(毫秒)&quot;);DEFINE_int(s, 3000, &quot;发送ping包超时时间(毫秒)&quot;);DEFINE_int(l, 32, &quot;发送数据大小&quot;);DEFINE_int(i, 128, &quot;TTL&quot;);void FillPingPacket(__u8* icmp_packet, __u16 seq, __u16 icmp_packet_size) &#123; RTC_DCHECK(icmp_packet); ping_hdr* pping_hdr = reinterpret_cast&lt;ping_hdr*&gt;(icmp_packet); pping_hdr-&gt;common_hdr.type = 8; pping_hdr-&gt;common_hdr.code = 0; pping_hdr-&gt;id = (__u16)GetCurrentProcessId(); pping_hdr-&gt;seq = seq; __u32 now = rtc::Time32(); memcpy((icmp_packet + sizeof(ping_hdr)), &amp;now, sizeof(__u32)); // fill some junk in the buffer. int junk_data_size = FLAG_l - sizeof(__u32); // timestamp int junk_offset = icmp_packet_size - junk_data_size; if(junk_data_size &gt; 0) memset((icmp_packet + junk_offset), &#x27;E&#x27;, junk_data_size); pping_hdr-&gt;common_hdr.check = 0; pping_hdr-&gt;common_hdr.check = rtc::GetCheckSum(reinterpret_cast&lt;__u16*&gt;(icmp_packet), icmp_packet_size);&#125;void DecodeIPPacket(__u8* ip_packet, __u16 packet_size) &#123; iphdr* ip_hdr = reinterpret_cast&lt;iphdr*&gt;(ip_packet); __u32 now = rtc::Time32(); __u16 ip_hdr_len = ip_hdr-&gt;ihl * 4; // bytes ping_hdr *pping_hdr = reinterpret_cast&lt;ping_hdr*&gt;(ip_packet + ip_hdr_len); if (pping_hdr-&gt;common_hdr.type != 0 || pping_hdr-&gt;common_hdr.code != 0) &#123; printf(&quot;non-echo response, type=%d, code=%d &quot;, pping_hdr-&gt;common_hdr.type, pping_hdr-&gt;common_hdr.code); return; &#125; if (pping_hdr-&gt;id != (__u16)GetCurrentProcessId()) &#123; printf(&quot;other process ping response packet, pid=%d &quot;, GetCurrentProcessId()); return; &#125; __u32 timestamp = 0; memcpy(&amp;timestamp, reinterpret_cast&lt;__u32*&gt;((__u8*)pping_hdr + sizeof(ping_hdr)), sizeof(__u32)); in_addr from; from.s_addr = ip_hdr-&gt;saddr; printf(&quot;%d bytes from %s, time &lt; %d ms, icmp_seq = %d, TTL = %d &quot;, packet_size - ip_hdr_len - sizeof(ping_hdr), inet_ntoa(from), now - timestamp, pping_hdr-&gt;seq, ip_hdr-&gt;ttl );&#125;int main(int argc, char**argv)&#123; rtc::FlagList::SetFlagsFromCommandLine(&amp;argc, argv, true); if (FLAG_h) &#123; rtc::FlagList::Print(NULL, false); return 1; &#125; char *hostname = argv[argc - 1]; if (!hostname || strlen(hostname) == 0) &#123; printf(&quot;Invalid host name &quot;); return 1; &#125; if (FLAG_l &lt;= 4) &#123; return 1; &#125; WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); sockaddr_in from; int from_len = sizeof(sockaddr_in); sockaddr_in dest; memset(&amp;dest, 0, sizeof(sockaddr_in)); dest.sin_family = AF_INET; dest.sin_addr.s_addr = inet_addr(hostname); // resolve host name if (dest.sin_addr.s_addr == INADDR_NONE) &#123; unsigned long begin_time = rtc::Time32(); struct addrinfo* result = nullptr; struct addrinfo hints = &#123; 0 &#125;; hints.ai_family = AF_UNSPEC; hints.ai_flags = AI_ADDRCONFIG; int ret = getaddrinfo(hostname, nullptr, &amp;hints, &amp;result); if (ret != 0) &#123; printf(&quot;Resolve host name failed, error code = %d &quot;, ret); return 1; &#125; unsigned long end_time = rtc::Time32(); struct addrinfo* cursor = result; printf(&quot;------------------------------ &quot;); printf(&quot;Resolve [time &lt; %d ms]: &quot;, end_time - begin_time); bool flag = false; for (; cursor; cursor = cursor-&gt;ai_next) &#123; sockaddr_in *paddr_in = reinterpret_cast&lt;sockaddr_in *&gt;(cursor-&gt;ai_addr); printf(&quot;%s &quot;, inet_ntoa(paddr_in-&gt;sin_addr)); if (!flag) &#123; dest.sin_addr = paddr_in-&gt;sin_addr; flag = true; &#125; &#125; freeaddrinfo(result); printf(&quot;------------------------------- &quot;); &#125; printf(&quot;Ping %s [TTL %d]: &quot;, inet_ntoa(dest.sin_addr), FLAG_i); // socket函数需要管理员权限 // 需要绕开管理员权限，可以使用IcmpSendEcho系列函数 // SOCKET s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP); if (s == INVALID_SOCKET) &#123; printf(&quot;create socket failed, error code = %d &quot;, WSAGetLastError()); WSACleanup(); return 1; &#125; int err = setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_s), sizeof(FLAG_s)); RTC_DCHECK(err != SOCKET_ERROR); if (err == SOCKET_ERROR) &#123; printf(&quot;setsockopt for SO_SNDTIMEO failed, error code = %d &quot;, WSAGetLastError()); closesocket(s); WSACleanup(); return 1; &#125; err = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_w), sizeof(FLAG_w)); RTC_DCHECK(err != SOCKET_ERROR); if (err == SOCKET_ERROR) &#123; printf(&quot;setsockopt for SO_RCVTIMEO failed, error code = %d &quot;, WSAGetLastError()); closesocket(s); WSACleanup(); return 1; &#125; err = setsockopt(s, IPPROTO_IP, IP_TTL, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_i), sizeof(FLAG_i)); RTC_DCHECK(err != SOCKET_ERROR); if (err == SOCKET_ERROR) &#123; printf(&quot;setsockopt for IP_TTL failed, error code = %d &quot;, WSAGetLastError()); closesocket(s); WSACleanup(); return 1; &#125; // ping request int icmp_packet_size = sizeof(ping_hdr) + FLAG_l; // data __u8 *icmp_packet = new __u8[icmp_packet_size]; RTC_DCHECK(icmp_packet); // ping response __u16 ip_packet_size = icmp_packet_size + 20; // 20 bytes ip header, no option. __u8 *ip_packet = new __u8[ip_packet_size]; RTC_DCHECK(ip_packet); if (!icmp_packet || !ip_packet) &#123; closesocket(s); WSACleanup(); return 1; &#125; __u16 i = 0; while (true) &#123; if (i == 0xFFFF) i = 0; i++; if (!FLAG_t) &#123; if(i &gt; 4) break; &#125; FillPingPacket(icmp_packet, i, icmp_packet_size); int sent = sendto(s, reinterpret_cast&lt;const char*&gt;(icmp_packet), icmp_packet_size, 0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;dest), sizeof(sockaddr)); if (sent == SOCKET_ERROR) &#123; int gle = WSAGetLastError(); if (gle == WSAETIMEDOUT) &#123; printf(&quot;request timeout &quot;); continue; &#125; else &#123; printf(&quot;ping %s failed, error code = %d &quot;, inet_ntoa(dest.sin_addr), gle); break; &#125; &#125; if (sent &lt; FLAG_l) &#123; printf(&quot;warning, sent %d bytes &quot;, sent); &#125; int bread = recvfrom(s, reinterpret_cast&lt;char*&gt;(ip_packet), ip_packet_size, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;from), &amp;from_len); if (bread == SOCKET_ERROR) &#123; int gle = WSAGetLastError(); if (gle == WSAETIMEDOUT) &#123; printf(&quot;receive timeout &quot;); continue; &#125; else &#123; printf(&quot;ping %s failed, error code = %d &quot;, inet_ntoa(dest.sin_addr), gle); break; &#125; &#125; if (bread &lt; ip_packet_size) &#123; printf(&quot;too few bytes from %s &quot;, inet_ntoa(from.sin_addr)); continue; &#125; DecodeIPPacket(reinterpret_cast&lt;__u8*&gt;(ip_packet), ip_packet_size); Sleep(1000); &#125; delete [] icmp_packet; delete [] ip_packet; if (s != INVALID_SOCKET) &#123; closesocket(s); &#125; WSACleanup(); return 0;&#125; 运行效果 2.2 TracertTracert 是 windows 系统提供的一个工具，使用该程序可以让我们看到 IP 数据报从一台主机到另一台主机所经过的路由器。Linux 系统也提供了类似的工具，叫 traceroute，功能和 Tracert 一样。 2.2.1 Tracert 原理在介绍 Tracert 的原理之前，需要先弄清楚 IP 首部 TTL 字段的含义，IP 报文每经过一个路由器，路由器都会将该 IP 报文首部的 TTL 字段减 1，当路由器收到一份 IP 数据报的 TTL 是 0 或 1 时，路由器此时不会转发该数据报，而会丢弃该数据报，并且给 IP 数据报首部中的源地址发送一份 ICMP 超时报文。 IP 首部的定义见：网络协议(3)--IP协议 Tracert 利用了路由器会丢弃 TTL 为 1 或 0 的数据报且返回 ICMP 超时报文的特性，来实现侦测路由的功能。Tracert 程序先发送 TTL 值为 1 的 IP 数据报，处理这份数据报的第一个路由器将 TTL 减 1，丢弃该数据报并返回 ICMP 超时报文，这样程序就得到了第一个路由器的地址，以此方式，递增 IP 数据报 TTL 的值，直到数据报最终到达目标主机。 那么怎么判断数据报到达了最终的目标主机呢？我们不能单纯的通过未收到路由器返回的 ICMP 差错报文的方式来判断数据报到达目的地了，因为有可能我们由于接收 ICMP 差错报文超时等原因导致我们收不到 ICMP 差错报文（这也是为什么我们后面会介绍每一个 TTL 跃点会发送 3 次或多次请求的原因）。windows 平台的 tracert 与 linux 平台的 traceroute 的实现原理稍有不同，判断数据报到达目标主机的方式也有不同。tracert 是通过发送 ping 包，因为 windows 系统内核都实现了 ping 功能，所以如果目的主机收到了 ping 请求就会回复相应的 ping 包，tracert 就是通过这种方式来判断数据报是否到达了目标主机。而 traceroute 是通过发送 UDP 包（UDP 端口选择一个不可能使用的 UDP 端口，比如大于 30000 的端口），因为目的主机没有监听该端口，所以不会响应接收到的该 UDP 请求，因此当 UDP 包到达时，目标主机会返回“端口不可达”的错误，traceroute 就是通过该错误来判断 UDP 包到达了目的主机。 从实现方式来看，traceroute 通过 UDP 的方式来实现更加稳定可靠，因为大多数主机的防火墙会组织 ICMP 报文，而不会阻止 UDP 报文。 下图使用 wireshark 抓取的tracert 192.168.3.76命令的数据包，从图中可以看到 tracert 是通过发送 ping 包来实现的，以及每个 ping 包的 TTL 递增过程： 2.2.2 ICMP 差错报文格式路由器在丢弃 TTL 为 0 或 1 的数据报时，会发送一个一份 ICMP 差错报文，该 ICMP 的差错报文的 type 为 11, code 为 0. type 为 11 的报文格式如下（code 有 0 和 1 两种，格式一样）： 2.2.3 实现该示例和之前的 Ping 程序的示例有所不同，该示例设置了IP_HDRINCL选项来自己构造 IP 头部。 程序的启动参数使用 webrtc 的&quot;rtc_base/flags.h&quot;实现。 代码中的其他某些功能，如断言、时间戳等基于 webrtc 的rtc_base实现，这些功能也可以很方便的自己实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348#include &lt;WinSock2.h&gt;#include &lt;ws2spi.h&gt;#include &lt;ws2tcpip.h&gt;#include &lt;strsafe.h&gt;#include &lt;algorithm&gt;#include &quot;rtc_base/networkprotocolheader.h&quot;#include &quot;rtc_base/checks.h&quot;#include &quot;rtc_base/flags.h&quot;#include &quot;rtc_base/timeutils.h&quot;DECLARE_bool(h); // 帮助DECLARE_int(m); // 最大跃点数DECLARE_int(w); // 等待每次回复的超时时间(毫秒)DECLARE_int(s); // 发送ICMP包超时时间(毫秒)DECLARE_int(n); // 每个跃点发送的请求数DEFINE_bool(h, false, &quot;帮助&quot;);DEFINE_int(m, 30, &quot;最大跃点数&quot;);DEFINE_int(w, 3000, &quot;等待每次回复的超时时间(毫秒)&quot;);DEFINE_int(s, 3000, &quot;发送ICMP包超时时间(毫秒)&quot;);DEFINE_int(n, 3, &quot;每个跃点发送的请求数&quot;);const int kPingDataSize = 36;__u32 kLocalIP = 0;__u32 GetLocalIPv4Address() &#123; return inet_addr(&quot;192.168.42.26&quot;); char hostname[MAX_PATH] = &#123; 0 &#125;; gethostname(hostname, MAX_PATH); struct hostent FAR* lpHostEnt = gethostbyname(hostname); if (lpHostEnt == NULL) &#123; return htonl(0x7f000001); //127.0.0.1 &#125; LPSTR lpAddr = lpHostEnt-&gt;h_addr_list[0]; struct in_addr addr; memcpy(&amp;addr, lpAddr, 4); return addr.s_addr;&#125;std::string IPv4ToString(__u32 ip) &#123; in_addr addr; addr.s_addr = ip; char *p= inet_ntoa(addr); if (p) return p; return &quot;&quot;;&#125;std::string GetPrintString(const char* fmt, ...) &#123; char buf[100]; va_list arglist; va_start(arglist, fmt); StringCchVPrintfA(buf, 100, fmt, arglist); va_end(arglist); return buf;&#125;bool print_ip(__u32* ips, int count, __u32 dest_ip) &#123; bool has_ip = false; bool trace_end = false; for (int i = 0; i &lt; count; i++) &#123; if (ips[i] != 0) &#123; printf(&quot; %s&quot;, IPv4ToString(ips[i]).c_str()); has_ip = true; trace_end = (ips[i] == dest_ip); &#125; &#125; if (!has_ip) printf(&quot; timeout&quot;); printf(&quot; &quot;); if (trace_end) printf(&quot;Trace Complete &quot;); return trace_end;&#125;void FillRequestIPPacket(__u8* ip_packet, __u16 ip_packet_size, __u16 seq, __u8 ttl, __u32 dest_addr) &#123; RTC_DCHECK(ip_packet); iphdr* p_iphdr = reinterpret_cast&lt;iphdr*&gt;(ip_packet); memset(p_iphdr, 0, sizeof(iphdr)); p_iphdr-&gt;version = 4; p_iphdr-&gt;ihl = sizeof(iphdr)/4; // no option p_iphdr-&gt;tos = 0; p_iphdr-&gt;frag_off = 0; p_iphdr-&gt;id = (__u16)rtc::Time32(); p_iphdr-&gt;ttl = ttl; p_iphdr-&gt;protocol = IPPROTO_ICMP; p_iphdr-&gt;tot_len = ip_packet_size; p_iphdr-&gt;daddr = dest_addr; p_iphdr-&gt;saddr = kLocalIP; p_iphdr-&gt;check = rtc::GetCheckSum(reinterpret_cast&lt;__u16*&gt;(p_iphdr), p_iphdr-&gt;ihl*4); ping_hdr* p_ping_hdr = reinterpret_cast&lt;ping_hdr*&gt;(ip_packet + p_iphdr-&gt;ihl*4); p_ping_hdr-&gt;common_hdr.type = 8; p_ping_hdr-&gt;common_hdr.code = 0; p_ping_hdr-&gt;id = (__u16)GetCurrentProcessId(); p_ping_hdr-&gt;seq = seq; // fill some junk in the buffer. if (kPingDataSize &gt; 0) memset((void*)((__u8*)p_ping_hdr+sizeof(ping_hdr)), &#x27;E&#x27;, kPingDataSize); p_ping_hdr-&gt;common_hdr.check = 0; p_ping_hdr-&gt;common_hdr.check = rtc::GetCheckSum(reinterpret_cast&lt;__u16*&gt;(p_ping_hdr), ip_packet_size - p_iphdr-&gt;ihl*4);&#125;// return source ip addressbool DecodeIPPacket(const __u8* ip_packet, __u16 ip_packet_size, __u32 send_time, __u32* src_addr) &#123; const iphdr* ip_hdr = reinterpret_cast&lt;const iphdr*&gt;(ip_packet); __u32 use_time = rtc::Time32() - send_time; __u16 ip_hdr_len = ip_hdr-&gt;ihl * 4; // bytes const icmp_common_hdr *icmp_hdr = reinterpret_cast&lt;const icmp_common_hdr*&gt;(ip_packet + ip_hdr_len); if (icmp_hdr-&gt;type == 0 &amp;&amp; icmp_hdr-&gt;code == 0) &#123; // 回显应答 const ping_hdr *p_ping_hdr = reinterpret_cast&lt;const ping_hdr*&gt;(icmp_hdr); if (p_ping_hdr-&gt;id != (__u16)GetCurrentProcessId()) &#123; printf(&quot;other process ping response packet, pid=%d &quot;, GetCurrentProcessId()); return false; &#125; printf(&quot;%-10s&quot;, GetPrintString(&quot;&lt;%d ms&quot;, use_time == 0 ? 1 : use_time).c_str()); *src_addr = ip_hdr-&gt;saddr; return true; &#125; else if (icmp_hdr-&gt;type == 11 &amp;&amp; icmp_hdr-&gt;code == 0) &#123; // cause by ttl == 0 printf(&quot;%-10s&quot;, GetPrintString(&quot;&lt;%d ms&quot;, use_time == 0 ? 1 : use_time).c_str()); *src_addr = ip_hdr-&gt;saddr; return true; &#125; else &#123; printf(&quot;unexpected response, type=%d, code=%d &quot;, icmp_hdr-&gt;type, icmp_hdr-&gt;code); return false; &#125;&#125;#define SAFE_RELEASE \\if (req_ip_packet) &#123; \\delete[] req_ip_packet; \\ req_ip_packet = NULL;\\&#125;\\if (rsp_ip_packet) &#123; \\delete[] rsp_ip_packet; \\ rsp_ip_packet = NULL;\\&#125;\\if (s != INVALID_SOCKET) &#123;\\ closesocket(s);\\ s = INVALID_SOCKET;\\&#125;\\WSACleanup();int main(int argc, char**argv) &#123; rtc::FlagList::SetFlagsFromCommandLine(&amp;argc, argv, true); if (FLAG_h) &#123; rtc::FlagList::Print(NULL, false); return 1; &#125; char *hostname = argv[argc - 1]; if (!hostname || strlen(hostname) == 0) &#123; printf(&quot;Invalid host name &quot;); return 1; &#125; printf(&quot;Trace %s &quot;, hostname); WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); sockaddr_in from; int from_len = sizeof(sockaddr_in); kLocalIP = GetLocalIPv4Address(); sockaddr_in dest; memset(&amp;dest, 0, sizeof(sockaddr_in)); dest.sin_family = AF_INET; dest.sin_addr.s_addr = inet_addr(hostname); // resolve host name if (dest.sin_addr.s_addr == INADDR_NONE) &#123; unsigned long begin_time = rtc::Time32(); struct addrinfo* result = nullptr; struct addrinfo hints = &#123; 0 &#125;; hints.ai_family = AF_UNSPEC; hints.ai_flags = AI_ADDRCONFIG; int ret = getaddrinfo(hostname, nullptr, &amp;hints, &amp;result); if (ret != 0) &#123; printf(&quot;Resolve host name failed, error code = %d &quot;, ret); return 1; &#125; unsigned long end_time = rtc::Time32(); struct addrinfo* cursor = result; printf(&quot;------------------------------ &quot;); printf(&quot;Resolve [time &lt; %d ms]: &quot;, end_time - begin_time); bool flag = false; for (; cursor; cursor = cursor-&gt;ai_next) &#123; sockaddr_in *paddr_in = reinterpret_cast&lt;sockaddr_in *&gt;(cursor-&gt;ai_addr); printf(&quot;%s &quot;, inet_ntoa(paddr_in-&gt;sin_addr)); if (!flag) &#123; dest.sin_addr = paddr_in-&gt;sin_addr; flag = true; &#125; &#125; freeaddrinfo(result); printf(&quot;------------------------------- &quot;); &#125; printf(&quot;Tracing %s [%d max hops]: &quot;, inet_ntoa(dest.sin_addr), FLAG_m); SOCKET s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP); if (s == INVALID_SOCKET) &#123; printf(&quot;create socket failed, error code = %d &quot;, WSAGetLastError()); WSACleanup(); return 1; &#125; int err = setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_s), sizeof(FLAG_s)); RTC_DCHECK(err != SOCKET_ERROR); if (err == SOCKET_ERROR) &#123; printf(&quot;setsockopt for SO_SNDTIMEO failed, error code = %d &quot;, WSAGetLastError()); closesocket(s); WSACleanup(); return 1; &#125; err = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_w), sizeof(FLAG_w)); RTC_DCHECK(err != SOCKET_ERROR); if (err == SOCKET_ERROR) &#123; printf(&quot;setsockopt for SO_RCVTIMEO failed, error code = %d &quot;, WSAGetLastError()); closesocket(s); WSACleanup(); return 1; &#125; int opt = 1; err = setsockopt(s, IPPROTO_IP, IP_HDRINCL, reinterpret_cast&lt;const char*&gt;(&amp;opt), sizeof(opt)); RTC_DCHECK(err != SOCKET_ERROR); if (err == SOCKET_ERROR) &#123; printf(&quot;setsockopt for IP_HDRINCL failed, error code = %d &quot;, WSAGetLastError()); closesocket(s); WSACleanup(); return 1; &#125; // ip packet for ping request. __u16 req_ip_packet_size = sizeof(iphdr) + sizeof(ping_hdr) + kPingDataSize; __u8 *req_ip_packet = new __u8[req_ip_packet_size]; memset(req_ip_packet, 0, req_ip_packet_size); // ip packet for icmp response or ping echo. __u16 rsp_ip_packet_size = // ICMP差错报文的大小 sizeof(iphdr) + sizeof(icmp_common_hdr) // ICMP(type=11,code=0或1)差错报文 + 4 // unused + sizeof(iphdr) + 8; //取ping包大小和ICMP差错报文大小的最大值，保证无论返回哪种报文缓冲区都够用， //也可以直接分配一个足够大的缓冲区，如1024 // rsp_ip_packet_size = std::max(rsp_ip_packet_size, req_ip_packet_size); __u8 *rsp_ip_packet = new __u8[rsp_ip_packet_size]; memset(rsp_ip_packet, 0, rsp_ip_packet_size); RTC_DCHECK(rsp_ip_packet); int ttl = 1; int seq = 0; __u32 *ips = new __u32[FLAG_n]; for(int hop = 1; hop &lt;= FLAG_m; hop++) &#123; printf(&quot; %-4d&quot;, hop); for (int i = 0; i &lt; FLAG_n; i++) &#123; ips[i] = 0; seq++; FillRequestIPPacket(req_ip_packet, req_ip_packet_size, seq, ttl, dest.sin_addr.s_addr); __u32 send_time = rtc::Time32(); int sent = sendto(s, reinterpret_cast&lt;const char*&gt;(req_ip_packet), req_ip_packet_size, 0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;dest), sizeof(sockaddr)); if (sent == SOCKET_ERROR) &#123; printf(&quot;%-10s&quot;, &quot;*&quot;); if (i == FLAG_n - 1) if (print_ip(ips, FLAG_n, dest.sin_addr.s_addr)) &#123; SAFE_RELEASE; return 0; &#125; continue; &#125; int bread = recvfrom(s, reinterpret_cast&lt;char*&gt;(rsp_ip_packet), rsp_ip_packet_size, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;from), &amp;from_len); if (bread == SOCKET_ERROR) &#123; int gle = WSAGetLastError(); printf(&quot;%-10s&quot;, &quot;*&quot;); if (i == FLAG_n - 1) if (print_ip(ips, FLAG_n, dest.sin_addr.s_addr)) &#123; SAFE_RELEASE; return 0; &#125; continue; &#125; __u32 dest_ip = 0; DecodeIPPacket(reinterpret_cast&lt;const __u8*&gt;(rsp_ip_packet), rsp_ip_packet_size, send_time, &amp;dest_ip); ips[i] = dest_ip; if (i == FLAG_n - 1) if (print_ip(ips, FLAG_n, dest.sin_addr.s_addr)) &#123; SAFE_RELEASE; return 0; &#125; &#125; ttl++; &#125; SAFE_RELEASE; return 0;&#125; 2.2.4 运行效果： 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["ICMP","Ping"],"categories":["编程基础"]},{"title":"网络协议(3)--IP协议","path":"/post/2274025898.html","content":"IP 协议是 TCP/IP 协议族中最核心的协议。所有的 TCP、UDP、ICMP、IGMP 数据都以 IP 数据报的格式传输。 IP 协议是不可靠、无连接的： 不可靠表示 IP 协议不能保证 IP 数据报能成功的到达目的地。IP 仅提供传输服务，任何可靠性的要求都必须由上层来提供（如 TCP）。如果传输过程发生错误，IP 协议简单的丢弃该数据报，然后发送 ICMP 消息给发送端。 无连接表示 IP 协议不维护任何关于后续数据报的状态信息，每个数据报都是相互独立的。这也说明，IP 数据报可能不是按照发送顺序被接收到的，很有可能后发送的数据被先收到。 一、IP 首部IP 数据报的格式如图： 4 位版本：标识目前采用的 IP 协议的版本号。IPv4 为 0100, IPv6 为 0110 4 位首部长度：用于标识首部的长度，单位为4 字节，所以首部的最大长度为15*4字节=60字节。 8 位服务类型：包括 3bit 的优先权字段（已被忽略），4bit 的 TOS 字段，1bit 的始终为 0 的未使用位。 16 位总长度(字节数)：整个 IP 数据报的长度。数据报中数据内容的长度=总长度 - 首部长度 16 位标识：唯一地标识主机发送的每一份数据报。IP 数据报的最大长度可达 65535 字节，但大多数链路层都会对它进行分片。由于 TCP 本身会把用户数据分成若干片，因此这个字段一般来说不会影响到 TCP。 3 位标志：用于 IP 数据报分片。该字段第 1bit 不使用，第 2bit 是 DF(Don't Fragment)位，DF 位设为 1 时表明 IP 不对该数据包分片。第 3bit 是 MF(More Fragments)位，当对数据包分片时，除了最后一片外，其他每个组成数据报的片都要把此位设为 1。 13 位偏移：用于 IP 数据报分片。单位为 8 字节。表示该片相对于原始数据报开始处的位置，能表示的最大偏移为*8=65536 字节。 另外，数据报被分片之后，每个片的总长度要更改为该片的长度值。IP 层分片是透明的，但是即使只丢失一片数据也要重传整个数据报，因为 IP 层本身没有超时重传的机制。 8 位生存时间(TTL)：设置数据报可以经过的最多路由器数量，每经过一个路由器，该值就减去 1。当该值为 0 时，数据报就被丢弃。通常初始值为 32 或 64. 8 位协议：表示上层传输层所用的协议类型。1 表示 ICMP 协议，2 表示 IGMP 协议，6 表示 TCP 协议，17 表示 UDP 协议。 16 位首部校验和：用于对 IP 首部的正确性进行校验，但不包括数据部分，这点不同于 TCP 和 UDP 的首部校验和。 32 位源 IP 地址：发送端的 32bit 的 IP 地址。 32 位目的 IP 地址：接收端的 32bit 的 IP 地址。 选项：可变长度的可选信息。如果首部不含“选项字段”，则 IP 首部长度为 20 字节。 二、IP 首部校验和 发送端对 IP 数据报的校验和的计算步骤： 把 IP 数据报的校验和字段置为 0； 把首部看成以 16 位为单位的数字组成，依次进行二进制反码求和； 把求和得到的结果取反。 将第 2、3 步得到的 2 个字节数据存入首部校验和。 接收端对 IP 数据报的校验和的校验步骤： 把首部看成以 16 位为单位的数字组成，依次进行二进制反码求和； 把求和得到的结果取反码。 如果结果为 0，则表示检验和校验通过，IP 报文没有被修改过。 三、使用代码计算校验和通过 wireshark 抓取一帧数据报，如图： 以该数据报的 IP 首部为基础，使用 C++代码来验证 IP 首部校验和的计算步骤和校验步骤： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;assert.h&gt;// GetChecksum函数用于实现上面所说的计算步骤中的第2步、第3步：// 把首部看成以16位（2字节）为单位的数字组成，依次进行二进制反码求和，// 但实际的算法实现上需要考虑取和溢出时的改进计算方法（见函数内部注释）//unsigned short GetChecksum(unsigned short* ip_header, int size) { assert(sizeof(unsigned short) == 2); // 为什么使用unsigned long（4字节）？ // 因为虽然首部校验和只占16位（2个字节），但执行“以16位（2字节）为单位的二进制反码数据”求和操作得到的checksum可能会超过16位（2字节）， // 所以这里用4个字节的unsigned long来接收相加得到的结果，后面再进行处理。 // unsigned long checksum = 0; while (size &gt; 1) { checksum += *ip_header; // 因为都是正数，所以反码与原码相同；故直接相加求和 ip_header++; // ip_header为unsigned short类型的指针每次按2个字节相加 size -= 2; } // 执行到这：checksum = 0x2850c // IP首部如果不包含“选项”字段，则为20字节，偶数；如果包含了“选项”，则字节数就可能为奇数了， // 这里针对字节数为奇数的情况进行处理。 // 注：示例main函数中构造的ip_header不含有“选项” // if (size == 1) { checksum += *(unsigned char*)ip_header; } // 因为上面相加之后的结果大于2个字节，所以执行额外的处理步骤： // checksum &gt;&gt; 16 右移16位 // 即除以2的16次方（0xffff），就是去除右边的2个字节，如：0x2850c &gt;&gt; 16 = 0x2 // // checksum &amp; 0xffff 位运算，得到后2个字节 // 如：0x2850c &amp; 0xffff = 0x850c // // checksum = 0x2 + 0x850c = 0x850e // checksum = (checksum &gt;&gt; 16) + (checksum &amp; 0xffff); // 假如还大于2个字节，再次将多余的字节和checksum相加。 checksum += (checksum &gt;&gt; 16); // 求和得到的结果的取反 return (unsigned short)(~checksum);}int main(){ // 将上面wirkshark抓的数据包的IP头部，使用char数组，按字节构造出来 // unsigned char ip_header[20] = { 0x45, // 4位版本+4位首部长度 0x00, // 8位服务类型（TOS） 0x00, 0x1c, // 16位总长度（字节数） 0x50, 0xaa, // 16位标识 0x00, 0x00, // 3位标志+13位片偏移 0xff, // 8位生存时间（TTL） 0x01, // 8位协议 0xf1, 0x7a, // 16位首部校验和 0xc0, 0xa8, 0x2e, 0x55, // 32位源IP地址 0xee, 0x73, 0x9c, 0x4a // 32位目的IP地址 }; // 第1步：把IP数据包的校验和字段置为0； // ip_header[10] = 0x00; ip_header[11] = 0x00; // 第2、3步计算校验和 // unsigned short checksum = GetChecksum((unsigned short*)ip_header, sizeof(ip_header)); printf(\"%02hhx %02hhx \", *(char*)(&amp;checksum), *((char*)(&amp;checksum) + 1)); // 第4步：将第2、3步得到的2个字节数据存入首部校验和 // ip_header[10] = *(char*)(&amp;checksum); ip_header[11] = *((char*)(&amp;checksum) + 1); // 模拟接收到IP包之后，对IP首部的校验和进行校验 // unsigned short checksum_check = GetChecksum((unsigned short*)ip_header, sizeof(ip_header)); if (checksum_check == 0) { printf(\"checksum check successful! \"); } else { printf(\"checksum check failed! \"); } return 0;} 四、IP 校验和的设计原理我们将 IP 首部进行简化来讲解 IP 校验和的设计原理，假设 IP 首部只有 6 个字节，第 5,6 字节存放校验和： 计算校验和时第 5,6 字节置为 0，校验和等于：A+B+0，然后取反，即： 接收端收到之后校验步骤为：求校验和（不同的是：校验和位不置 0），若此时求得校验和为 0，则校验通过。即： 五、IP 地址相关操作本节介绍在网络编程中涉及到的与 IP 地址相关的操作 struct in_addr1234567891011121314151617// sizeof(in_addr) == sizeof(ULONG) == 4//typedef struct in_addr { union { struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b; struct { USHORT s_w1,s_w2; } S_un_w; ULONG S_addr; // 4个字节，按网络字节序列存储 // 可以使用inet_addr函数将IP格式字符串转为网络字节序列的整数。 } S_un;// 定义的一些宏，方便访问结构体成员#define s_addr S_un.S_addr /* can be used for most tcp &amp; ip code */#define s_host S_un.S_un_b.s_b2 // host on imp#define s_net S_un.S_un_b.s_b1 // network#define s_imp S_un.S_un_w.s_w2 // imp#define s_impno S_un.S_un_b.s_b4 // imp ##define s_lh S_un.S_un_b.s_b3 // logical host} IN_ADDR, *PIN_ADDR, FAR *LPIN_ADDR; struct sockaddr_in1234567// sizeof(sockaddr_in) == 16struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8];}; struct sockaddr123456// sizeof(sockaddr) == 16//struct sockaddr { u_short sa_family; /* address family */ char sa_data[14]; /* up to 14 bytes of direct address */}; 5.1 转换函数 webrtc 中的IPAddress类和SocketAddress类，对网络地址的操作进行了很好的封装，值得参考。 5.1.1 IP 字符串 -&gt; 整数123unsigned long inet_addr( _In_ const char *cp); 将类似127.0.0.1这样的 IP 字符串转换为网络字节序列的整数 5.1.2 整数 -&gt; IP 字符串123char* FAR inet_ntoa( _In_ struct in_addr in); 将 in_addr（也可以理解为网络字节序列整数）转换为 IP 字符串。 5.2 字节序列转换123456htonshtonlntohsntohlhtonllntohll 对整数（short、long、longlong）进行网络字节序列和主机字节序列间的转换操作。以 htons 为例：h是 host 的首字母，表示主机字节序列；n是 network 的首字母，表示网络字节序列；s代表 short；所以 htons 的功能是，将 short 从主机字节序列转为网络字节序列。 字节序列可以参考：http://blog.csdn.net/china_jeffery/article/details/78401731 5.3 获取本机 IP 地址5.3.1 使用 gethostbyname这种方式有一个弊端：只能获取一个网卡的 IP 地址。 123456789101112131415unsigned long GetLocalIPv4Address() { char hostname[MAX_PATH] = { 0 }; gethostname(hostname, MAX_PATH); struct hostent FAR* lpHostEnt = gethostbyname(hostname); if (lpHostEnt == NULL) { return htonl(0x7f000001); //127.0.0.1 } LPSTR lpAddr = lpHostEnt-&gt;h_addr_list[0]; struct in_addr addr; memcpy(&amp;addr, lpAddr, 4); return addr.s_addr;} 5.3.2 使用 GetAdaptersInfo该方式可以获取本机多块网卡的信息（不限于 IP 地址）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;windows.h&gt;#include &lt;Iphlpapi.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#pragma comment(lib,\"Iphlpapi.lib\")bool GetLocalAddress(std::vector&lt;std::string&gt; &amp;ip_list) { PIP_ADAPTER_INFO pIpAdapterInfo = new IP_ADAPTER_INFO(); unsigned long stSize = sizeof(IP_ADAPTER_INFO); int nRet = GetAdaptersInfo(pIpAdapterInfo, &amp;stSize); if (ERROR_BUFFER_OVERFLOW == nRet) { delete pIpAdapterInfo; pIpAdapterInfo = (PIP_ADAPTER_INFO)new BYTE[stSize]; nRet = GetAdaptersInfo(pIpAdapterInfo, &amp;stSize); } if (ERROR_SUCCESS != nRet) { if (pIpAdapterInfo) { delete pIpAdapterInfo; } return false; } while (pIpAdapterInfo) { IP_ADDR_STRING *pIpAddrString = &amp;(pIpAdapterInfo-&gt;IpAddressList); switch (pIpAdapterInfo-&gt;Type) { case MIB_IF_TYPE_OTHER: case MIB_IF_TYPE_ETHERNET: case MIB_IF_TYPE_TOKENRING: case MIB_IF_TYPE_FDDI: case MIB_IF_TYPE_PPP: case MIB_IF_TYPE_LOOPBACK: case MIB_IF_TYPE_SLIP: { std::string address = pIpAddrString-&gt;IpAddress.String; if (\"0.0.0.0\" == address) break; ip_list.push_back(address); break; } default: break; } pIpAdapterInfo = pIpAdapterInfo-&gt;Next; } if (pIpAdapterInfo) { delete pIpAdapterInfo; } return true;} 《TCP/IP 详解 卷 1：协议》在线阅读地址：http://www.52im.net/topic-tcpipvol1.html 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["IP"],"categories":["编程基础"]},{"title":"网络协议(2)--ARP和RARP协议","path":"/post/3034381124.html","content":"ARP (Address Resolution Protocol) 地址解析协议，位于 TCP&#x2F;IP 协议栈中的链路层。 当局域网内主机间（或者是主机与网关间）需要通信时，通过使用 ARP 协议获取目标 IP 地址所对应的硬件 MAC 地址，然后在主机间通过 MAC 地址来完成数据包的发送和接收。 一、ARP 协议1.1 ARP 协议介绍通过使用ARP协议获取目标IP地址所对应硬件MAC地址的具体过程如下： 本地主机在局域网中广播ARP 请求，ARP 请求数据帧中包含目的主机的 IP 地址。意思是“如果你是这个 IP 地址的拥有者，请回答你的硬件 MAC 地址”。 目的主机的 ARP 层解析这份广播报文，识别出是询问其硬件地址。于是发送（单播）ARP 应答包，里面包含 IP 地址及其对应的硬件地址。 本地主机收到 ARP 应答后，知道了目的地址的硬件地址，之后的数据报就可以传送了。 1.2 ARP 缓存如果像上面说的那样，每次发包之前都要发送 ARP 请求硬件地址，这样会不会效率太低，实际上 ARP 的运行是非常高效的。这是因为每一个主机上都有一个 ARP 高速缓存，我们可以通过命令 arp -a 获取本机 ARP 高速缓存的所有内容： 12345678910111213141516arp -a接口: 192.168.42.26 --- 0xb Internet 地址 物理地址 类型 192.168.1.1 00-00-00-00-00-ff 静态 192.168.40.1 f8-75-88-c2-df-c1 动态 192.168.40.74 c8-5b-76-86-c6-06 动态 192.168.40.245 38-d5-47-e1-8a-2f 动态 192.168.42.131 60-a4-4c-65-9f-68 动态 224.14.51.28 01-00-5e-0e-33-1c 静态 224.19.133.150 01-00-5e-13-85-96 静态 224.49.6.212 01-00-5e-31-06-d4 静态 224.50.134.225 01-00-5e-32-86-e1 静态 224.68.111.100 01-00-5e-44-6f-64 静态 224.80.154.130 01-00-5e-50-9a-82 静态 224.88.174.75 01-00-5e-58-ae-4b 静态 通过命令 arp -d 可以清除 arp 缓存。 1.3 ARP 缓存生存周期在默认情况下，Windows Server 2003 家族和 Windows XP 中，ARP 缓存中的表项仅存储 2 分钟。如果一个 ARP 缓存表项在 2 分钟内被用到，则其期限再延长 2 分钟，直到最大生命期限 10 分钟为止。超过 10 分钟的最大期限后，ARP 缓存表项将被移出，并且通过另外一个 ARP 请求来获得新的对应关系。 ARP 缓存表项的存放时间可以通过改变 ArpCacheLife 和 ArpCacheMinReferencedLife 的注册表值来重新设置。 1234567891011HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Tcpip/Parameters键值：ArpCacheLife，设置未被使用的ARP缓存表项可以被保持的时间，类型为 DWORD，单位为秒，默认值为120。ArpCacheMinReferencedLife，设置被重复使用的表项可以在ARP缓存中存放的时间，类型为 DWORD，单位为秒，默认值为600。ArpCacheMinReferencedLife和ArpCacheLife的值的使用方法如下：如果 ArpCacheLife &gt;= ArpCacheMinReferencedLife，则被使用和未被使用的ARP缓存表项可存储的时间都是 ArpCacheLife。如果 ArpCacheLife &lt; ArpCacheMinReferencedLife，则未被使用的ARP缓存表项在 ArpCacheLife 秒的时间后就过期了，被使用的表项的生存期为ArpCacheMinReferencedLife秒。注意：这些键值默认是不存在的，如果你想修改，必须自行创建；修改后还需重启计算机才生效。 1.3 ARP 帧格式 1234567891011121314151617181920212223以太网目的地址：目的主机的硬件地址。目的地址全部为 1 的特殊地址是广播地址。以太网源地址：源主机的硬件地址。帧类型：对于ARP协议，该字段为0x0806。对于RARP协议，该字段为0x8035。硬件类型：表示硬件地址的类型。值为1时表示以太网地址。ARP协议不仅仅应用于以太网协议，还可以支持别的链路层协议。协议类型：表示要映射的协议地址类型。值为0x0800时表示IP协议。硬件地址长度：与硬件类型对应的硬件地址的长度，以字节为单位。如果是以太网，则是6字节（MAC长度）。协议地址长度：与协议类型对应的协议地址长度，以字节为单位。如果是IP协议，则是4字节（IP地址长度）。操作类型（op）：四种操作类型。ARP请求（1），ARP应答（2），RARP请求（3），RARP应答（4）。发送端硬件地址：如果是以太网，则是源主机以太网地址，此处和以太网头中的源地址对应。发送端协议地址：如果是IP协议，则表示源主机的IP地址。目的端硬件地址：如果是以太网，则是目的以太网地址，和以太网头中的目的地址对应。目的端协议地址：如果是IP协议，则表示源主机要请求硬件地址的IP地址。 对应ARP请求包来说，目的端的硬件地址字段无须填充，其他字段都需要填充；对于ARP响应包来说，所有字段都需要填充。 1.4 ARP 欺骗ARP 欺骗一般目的是通过某种方式把自己伪装成网关，从而欺骗目标机器，使本应发送到真实网关的数据包发送到欺骗者的机器。 现有如下网络： 1.4.1 如何伪装成网关？我们以主机 A 请求 www.csdn.net 网站为例，涉及到 ARP 的主要流程如下： 主机 A 通过浏览器打开 www.csdn.net（假设通过 DNS 得到的 IP 是 47.95.163.175），然后组装需要发送 http 请求包。 主机 A 准备根据默认路由（网关）将数据包发送给 192.168.0.1, 但是最开始的时候主机 A 不知道 192.168.0.1 的 MAC 地址, 所以主机 A 广播一条 ARP 请求, 询问 192.168.0.1 的 MAC 地址。 路由器（网关）收到该 ARP 请求, 发现自己就是 192.168.0.1，于是向主机 A 回复一条 ARP 应答包, 告诉主机 A 192.168.0.1 的 MAC 地址是 xxxGW。 主机 A 收到该 ARP 响应包, 并向该响应包中的 MAC 地址发送一个 Http 请求包。 路由器（网关）收到该 Http 请求包, 发现目标 IP 是公网 IP, 便将该包放送到公网, 公网返回 Http 应答包给路由器（网关）。 路由器（网关）准备将 Http 响应包发送给 192.168.0.100, 但是同第 2 步, 路由器最开始的时候也不知道 192.168.0.100 的 MAC 地址是多少, 所以路由器会广播一条 ARP 请求, 询问 192.168.0.100 的 MAC 地址是多少。 主机 A 收到 ARP 请求, 发现自己就是 192.168.0.100, 于是向路由器回复了一个 ARP 应答包, 告诉路由器 192.168.0.100 的 MAC 地址是 xxxA. 路由器（网关）收到 ARP 应答包, 并使用该 APR 应答包中的 MAC 地址将第 5 步收到 Http 响应包发送出去。 试想，如果现在主机 B 做了如下 2 件事情会有什么后果： 主机 B 不停的向主机 A 发送 ARP 应答包, 告诉路由器（网关）192.168.0.1 的 MAC 地址是 xxxB, 会发生什么? 主机 B 不停的向路由器（网关）发送 ARP 应答包, 告诉主机 A 192.168.0.100 的 MAC 是 xxxB, 会发生什么? 如果主机 B 做了上面说的两件事的, 那么主机 A 访问网络的所有数据都会先经过主机 B, 并且从网关发送到主机 A 的数据也都会经过 B, 至此, 整个 ARP 欺骗完成。 但是，如果欺骗者机器不对这些数据包作处理，当被欺骗数据包到达后就会被本机丢弃（因为自己到底不是网关，还不知道如何处理这类数据包），这当然是不允许的。这时开启 IP 转发功能可以解决该问题，IP 转发负责把该类数据包再转发给真正的网关处理，开启 IP 转发的方法： 1sysctl net.ipv4.ip_forward=1 1.4.2 arpspoof 使用在 Ubuntu 或 Kali 等系统上有 arpspoof 工具可以轻松实现 ARP 欺骗的整个流程。 123456789101112arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host参数：-i 指定用攻击机的哪个网络接口，可以使用ifconfig命令查看攻击机接口列表。-c own|host|both-t 指定arp攻击的目标。如果不指定，则目标为该局域网内的所有机器。可以指定多个目标，如：arpspoof -i etho -t 192.168.32.100 -t 192.168.32.101-r host希望拦截攻击机和哪个host之间的通信，一般都是网关。 二、RARP 协议RARP 协议（Reverse Address Resolution Protocol），反向地址转换协议，也叫逆地址解析协议，主要被那些没有磁盘驱动器的系统使用，如无盘工作站等。 具有本地磁盘的系统引导时，一般是从磁盘中的配置文件读取 IP 地址。但是无盘机，如无盘工作站，则需要采用其他方法获取 ip 地址。网络上的每个系统都具有唯一的硬件地址，它是由网络接口生产厂家配置的。无盘系统的 RARP 实现过程是从网卡上读取唯一的硬件地址，然后发送 RARP 请求到 RARP 服务器，请求该主机在无盘系统的 IP 地址。 文章参考：https://segmentfault.com/a/1190000009562333 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["ARP"],"categories":["编程基础"]},{"title":"网络协议(1)--基础概念","path":"/post/3886809266.html","content":"一、协议栈1.1 七层OSI协议栈完整的OSI协议总共有7层，如下图所示： 1.2 五层TCP/IP协议栈在实际应用中，业界又产生了简化的五层 TPC/IP 协议栈，将 OSI 协议栈中的会话层、表示层、应用层统称为应用层。 1.3 四层TCP/IP协议栈在五层TCP/IP协议栈的基础上，进一步将物理层、数据链路层统称为链路层。 二、IP 地址、子网掩码、网关2.1 IP 地址及分类IP 地址相当于互联网上的门牌号，计算机在启动的时候可以从磁盘（无盘系统例外）上读取该主机的 IP 配置。 IP 地址由 4 个字节（也就是 32 位）的二进制码组成，包含了网络号( net-id )和主机号( host-id )。但现实中，我们经常还需要再继续划分“子网”，这时就需要借用主机号的一部分充任子网号，这样 IP 地址也就可以看成由标准网络号、子网号、主机号3 部分组成的，即IP地址=标准网络号+子网号+主机号。 网络号、子网号、主机号三者间的关系，形象的描述如下：假设你的住址 IP 是武汉市文治街16号，那么，IP 地址 = 武汉市文治街 16 号网络号 = 武汉市子网号 = 文治街主机号 = 16 号 IP 地址种类 二进制组成(前缀位+网络位+主机位) IP 范围 网络数 主机数/网络 A 类地址 0+7 位网络号+24 位主机号 1.0.0.0 - 127.255.255.255 B 类地址 10+14 位网络号+16 位主机号 128.0.0.0 - 191.255.255.255 C 类地址 110+21 位网络号+8 位主机号 192.0.0.0 - 223.255.255.255 D 类地址 1110+多播地址(用于多播) 224.0.0.0 - 239.255.255.255 - - E 类地址 1111+保留位(不开放, 保留使用) 240.0.0.0-249.255.255.255 - - 从表中可以看出，A 类 IP 的第 1 位（二进制位）必须是 0，所以 A 类 IP 的第一个整数的范围是0000 0000 ~ 01111 11111，转换为十进制就是0 ~ 127，以此类推。 关于网络数的解释网络数就是一种网络的子网数, 比如 A 类地址, 可以分为多少个子网。看表格可以推出网络数的计算公式为: 网络号位数。规定网络地址全为0的 IP 地址是保留地址，意思是“本网络”。 在 A 类地址中，实际上 0.0.0.0 是不指派的，而可以指派的最小网络是 1.0.0.0；网络地址为 127 的 A 类 IP 地址保留作为本地软件环回测试本主机的进程之间的通信(比如常用的 127.0.0.1，但实际上网络地址为127的都可以用作本地环回地址)。所以 A 类地址网络数为 。 在 B 类地址中，实际上 128.0.0.0 是不指派的，而可以指派的最小网络是 `128.1.0.0，所以 B 类地址网络数是 。 在 C 类地址中，实际上 192.0.0.0 是不指派的，而可以指派的最小网络是 192.0.1.0，所以 C 类地址网络数是 。 关于主机数的解释主机数就是一个子网里面可以容纳多少台主机。看表格可以推出主机数的计算公式为: 2^主机号位数-2。主机号全为 0 表示该网络，而主机号全为 1 表示广播地址，所以要排除掉这两个。比如 A 类地址 1.0.0.0 表示主机所在的网段的网络地址, 1.255.255.255 为该网段的广播地址。 2.2 私有 IP 地址经常可以看到192.168.1.101这类的 IP 地址, 这些是私有 IP 地址, 专用地址, 也就是局域网内使用的的 IP 地址。公网 IP 地址是需要向有关部门申请备案的，私有 IP 地址不用申请, 但是仅限内网使用, 也节约公网 IP。 IP 地址种类 私有 IP 范围 A 类地址 10.0.0.0 - 10.255.255.255 B 类地址 172.16.0.0 - 172.31.255.255 C 类地址 192.168.0.0 - 192.168.255.255 路由器看到专用地址就不转发，所以说专用地址作为目的地址是不可能在因特网上传送的。专用 IP 地址也可叫做可重用地址。那好，问题来了，如果配置了这些专用地址的主机想和因特网上的主机通信，怎么办呢？NAT(network address translation: 网络地址转换)在这种情况下就应运而生了。NAT 就是将这种地址转换成有效的外部全球 IP 地址，使得整个专用网只需要一个全球 IP 地址就可以与因特网联通。 2.3 子网掩码IP地址=标准网络号+子网号+主机号。从 IP 分类可以很容易确定“标准网络号”，32bit的 IP 地址除去前面的“标准网络号”之后，剩下的就是“子网号”和“主机号”，那么怎么确定“子网号”和“主机号”了？ 这就需要借助“子网掩码”了。子网掩码也是一个 32bit(xxx.xxx.xxx.xxx)的值，其中值为 1 的 bit 留给“标准网络号”和“子网号”，为 0 的 bit 留给“主机号”。我们可以将子网掩码和 IP 地址进行二进制“与运算”，通过得到的结果来确定“子网号”。 以 C 类 IP 地址为例，对于规范的 C 类 IP 地址来说，规范子网掩码为255.255.255.0，即用 32 比特 IP 地址的前 24 比特标识网络号，后 8 比特标识主机号。因而，每个 C 类网络下共可容纳 254 台主机()。 如今，我们先思索借用 2 比特的主机号来充任子网络号的情形。 C 类网络地址210.31.233.0，我们借用 2bit 的主机号来充当子网号，子网的数目为(子网号无法全为 0 或 1，所以减 2). 为了借用原来 8 位主机号中的前 2 位充任子网络号，采用了新的非规范子网掩 255.255.255.192。采用了新的子网掩码后，借用的 2 位子网号可以用来标识两个子网：01 子网和 10 子网(子网号无法全为 0 或 1，因而 00、11 子网无法用)。 对于上图的 01 子网来说，其网络号的点分十进制的方式为：210.31.233.64，该子网的最小 IP 地址为：210.31.233.65，最大 IP 地址为：210.31.233.126（主机号全为 1 位广播地址），共可容纳 62 台主机。对该子网的直接广播地址为：210.31.233.127（主机号全为 1）。 经常见到像192.168.1.0/24这样的写法，它的意思是网络号为192.168.1.0；子网掩码为 24 位，即111111111 111111111 111111111 00000000，转为点分十进制就为255.255.255.0，没有借用主机号来充当子网号，可以拥有的主机数为-2. 2.3 网关的作用你的住址 IP 是武汉市洪山区文治街16号，你的父母只允许你和文治街的小朋友（同一个子网）一起玩耍，如果你想要去和别的街道（别的子网）的小朋友玩耍，你就需要经过你的父母的同意，由你的父母带你过去，这时候你的父母就充当了网关的角色，没有你的父母，你就不能和其他街道（其他子网）的小朋友玩耍。 三、包的封装与解封装 封装英文：Encapsulation解封装英文：Demultiplexing 当应用程序使用网络传送数据时，数据按照协议栈从上到下的顺序，逐次通过每一层。其中每一层对收到的数据都要增加一些首部信息（有时还增加尾部信息）。最终生成一串比特流通过以太网来传输，我们称这串比特流叫帧。如图： 当数据报到达链路层时，链路层也要对 IP 数据包封装进行包装。链路层也要对 IP 数据包封装的方式主要有以太网IP数据包封装（RFC894）、IEEE 802 IP数据报封装（RFC1042）两种，最常使用的封装格式是以太网 IP 数据包封装（RFC894）。下图显示了这两种不同形式的封装格式：从图中可以看到以太网封装限制了数据帧的最大长度为 1500 字节，这个限制叫做 MTU，最大传输单元（详见第四节）。 接收端收到帧之后，按照和上面相反的顺序（协议栈从下到上）来解包，依次解析每一层加入的头部（或尾部），最终将原始数据传给最上层应用程序。如图： 因为传输层的 TCP、UDP、ICMP 等都有可能向网络层 IP 协议传送数据，这样在 IP 协议层解包的时候，需要知道这个包对应的上层协议是哪一个，因此 IP 协议必须在生成的 IP 首部加入某种标识，以表明数据的上一层的具体协议。为此，IP 在首部中存入了一个长度为 8bit 的数值，称作协议域。常见的 IP 协议号有：1 表示 ICMP 协议，2 表示 IGMP 协议，6 表示 TCP 协议，17 表示 UDP 协议。 完整的 IP 协议号见：IP 协议号列表 四、MTU前面第三节提到了以太网封装限制了数据帧的长度为 1500 字节，这个限制是在链路层封装 IP 数据报时作的。如果 IP 层的数据报比链路层的这个 MTU 值大，那么 IP 层就需要分片（英文：fragmentation），把数据报分成若干片，保证每一片的大小都小于 MTU 值。 windows 系统修改 MTU 值 查询当前 MTU 值 1netsh interface ipv4 show subinterfaces 修改 MTU 值 1netsh interface ipv4 set subinterface \"本地连接\" mtu=1480 store=persistent 文章参考：https://m.vipcn.com/a/360973/ &gt; https://ahaochan.github.io/posts/IP_address,_subnet_mask,_gateway_Introduction.html &gt; https://www.zhihu.com/question/20717354 《TCP/IP 详解 卷 1：协议》在线阅读地址：http://www.52im.net/topic-tcpipvol1.html 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["IP"],"categories":["编程基础"]},{"title":"使用WinDbg查看调用堆栈","path":"/post/2414867920.html","content":"一. 显示堆栈信息k*命令 1234[~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] [FrameCount][~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] = BasePtr [FrameCount][~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] = BasePtr StackPtr InstructionPtr[~Thread] kd [WordCount] 参数：Thread： &nbsp;指定显示哪个线程的调用堆栈。如果省略该参数，则显示当前线程的调用堆栈。显示所有线程的调用堆栈。b： &nbsp;显示每个函数的前3个参数。p： &nbsp;显示每个函数的所有参数。参数列表包括每个参数的类型、名称、值。P： &nbsp;类似于p*。不同之处在于，每个参数显示在单独的行上面。n： &nbsp;显示调用堆栈中每帧的序号（一般称栈帧，如栈帧3）。FrameCount： &nbsp;指定显示调用堆栈的帧数，即调用堆栈的深度。默认为16进制格式。默认帧数为0x14&#x3D;20 二. 切换到指定帧信息调用堆栈显示出来之后，如果想知道调用某帧时的相关信息，可以使用.frame来切换到指定的帧，然后就可以使用如dv命令显示局部变量等。 1.frame [/c] [/r] [FrameNumber] &#x2F;r： &nbsp;显示执行该帧时寄存器的值。 FrameNumber： &nbsp;指定要切换到的帧号。","tags":["Windbg"],"categories":["软件调试"]},{"title":"MySQL的DECLARE...HANDLER使用","path":"/post/3457369310.html","content":"一、 功能DECLARE...HANDLER语法如下： 123DECLARE handler_action HANDLER FOR condition_value [, condition_value] ... statement 功能概括起来就是：在一个或者多个condition_value条件满足时，先执行statement语句，然后执行handler_action动作。 二、 参数解释2.1 statementstatement语句可以是一行简单的SQL语句，如SET var_name = value，也可以是多行复杂的的SQL语句，但多行SQL语句需要使用BEGIN和END包围。 简单statement： 1DECLARE CONTINUE HANDLER FOR 1051 SET result = 0; 复杂的statement： 1234DECLARE CONTINUE HANDLER FOR 1051BEGIN -- body of handlerEND; 2.2 handler_actionhandler_action的取值如下： CONTINUE：表示继续执行当前SQL脚本。 EXIT：表示终止执行当前SQL脚本。即使condition_value（见2.3）由statement语句的BEGIN...AND语句块引发，也是一样会终止执行。 2.3 condition_valuecondition_value的取值可以为如下几种： ● mysql_error_code：MySQL的错误码，整数类型。 1234DECLARE CONTINUE HANDLER FOR 1051BEGIN -- body of handlerEND; MySQL错误码取值见:https://dev.mysql.com/doc/refman/5.7/en/error-messages-server.html ● SQLSTATE ：用5个字符表示的SQLSTATE值。 1234DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;42S02&#x27;BEGIN -- body of handlerEND; 以&#39;00&#39;开始的值表示成功。SQLSTATE的完整取值列表见:https://dev.mysql.com/doc/refman/5.7/en/error-messages-server.html ● condition_name：使用DECLARE ... CONDITION定义的条件的名称。 如何使用DECLARE ... CONDITION定义条件，见：https://dev.mysql.com/doc/refman/5.7/en/declare-condition.html ● SQLWARNING：相当于值从&#39;01&#39;开始的SQLSTATE 。● NOT FOUND：相当于值从&#39;02&#39;开始的SQLSTATE 。● SQLEXCEPTION：相当于值不为&#39;00&#39;,&#39;01&#39;,&#39;02&#39;的所有 SQLSTATE。 参考文档: https://dev.mysql.com/doc/refman/5.7/en/declare-handler.html","tags":["MySQL"],"categories":["数据库","MySQL"]},{"title":"最不像干货的33条干货（转载）","path":"/post/3534906950.html","content":"成功的唯一秘诀就是钻空子。钻职场人际关系的空子、钻市场监管的空子、钻信息不对称的空子，钻你发现的一切空子的空子。当然，坚持、努力、选择这些因素，对于成功也很重要，但算不上秘诀。只有钻空子才是唯一的秘诀。 不要做永远正确的穷人。少跟人争辩，你觉得对就去做，做成了自然别人就闭嘴了。说服别人并没有实际的意义，浪费口舌和时间。当然，利益相关的事情，有人冤枉你的情况除外。 脸皮变厚一倍，成功的可能性要翻倍。不要怕丢脸，你觉得丢脸的事情，大家其实压根不在乎，丢脸多半是你个人的臆想。 项目不做调研，就像嫖娼不戴套，非常危险。任何项目启动前一定要做适当的调研，哪怕很粗糙，也远胜于无。 创业做生意就是要抄，抄产品、抄模式、抄架构，这是规避风险，减少试错成本的最好方法。但是也不能全抄。大原则是：拿得准的环节创新，拿不准的地方抄。 每个月花半天时间，扫描和梳理自己所在领域和区域的行业新机会。 有枣没枣，打一竿子。多去做一些尝试。不一定每一件事都要努力去做，但那些舒适区外的事情，可以试着去做。 大家都去找金矿的时候，给淘金的人卖铲子就是最好的生意，多考虑快速增长行业的周边生意。 卖手机不如修手机，修手机不如做二手回收。一个行业越是信息不对称，越是不标准化，它的利润就越高，赚钱的可能性就越大。 要投资一个领域，下面两个条件至少要一个条件成立：1. 你自己懂行；2. 你能找到懂行又靠谱的人来帮你把关。 不要用个人的好恶代替商业逻辑。如果你觉得罗辑思维、咪蒙、比特币都是骗子，那你永远看不到背后的需求、机会和行业红利。 做营销就和做小姐一样，越low的方式反倒越有效。与其扭扭捏捏、故作逼格，不如大大方方简单粗暴、赤裸相待。 遇到自己不懂或者没听过的新名词，用手机记下来。有空可以研究一下，说不定里面有新的机会和思路。 对于赚钱的事，多琢磨，多尝试。当你第一次尝到甜头，你就走在一条快车道上了。 让你觉得听了不舒服的话，往往是真话。别人对你的有价值的批评，往往是你成长和进步的机会。 减少无效思考。80%的人都是无能的，即使是有能力的人当中，80%的思考也是无效的。尽可能减少无效的思考时间，多把精力和时间投入到行动中。 别被那些一夜暴富的事情忽悠了，相信时间，相信积累，顺着大趋势慢慢做，总会起来。 选择比努力更重要。思考方式的转变比能力提升更重要，这方面的学习和研究很有价值。 如果你无法释怀过去的痛苦，不要责怪你自己，尽可能安排一下未来生活的兴奋点。 忧虑的时候尽可能保持忙碌，把身体的能量用完了，就没时间、精力忧虑了。 每周至少约一个对自己事业、生活有帮助的朋友吃饭。 人与人之间很难真正理解，你也不需要这么多人理解你，也不要为了让别人理解你做太多尝试。专注于提升自己的实力，多做一些让别人敬佩你的事情。 相比于认清世界，更难的是认清自己。对自己有一个清晰的认识后，需要做取舍做选择，才会有判断依据。 靠谱不仅是一种人格，也是一种营销策略。因为这个世界大部分人都不靠谱，你要是相对靠谱，好的资源、机会都会首先想到你、找到你。能在混沌一片的世界里快速把自己的品牌营销出去。 思想深度和快乐是成反比的，除了赚钱相关的事情，其他事情没必要深究，徒增烦恼。不要觉得减少就变成一个快乐的笨蛋了，你思考太多、忧虑太多，你只是变成一个忧心忡忡的笨蛋罢了。 学习最重要的，不是把10分的精力都花在吸收新知识上，而是3分学习，7分练习和实践。 简单的事情反复做，就能成长；复杂的事情简单做，就能成功。同一个技能反复练习100次，那个技能就是你的；同一个领域的事情做对100次，那个领域的钱就是你的。 迷茫的时候，就把能做好的事情踏实做好就行。多关注自己力所能及的小事，小成功积累多了，就有大成功的机会。。 人生常常就像堵车，心里别添堵。很多时候堵在里面，你也不要心急。能走几步走几步，走不动的时候歇着，等车流慢慢恢复了，又继续走。 有责任感有担当的人，往往都活得比较累，因为要操心的事儿太多。你如果是这样的人，接受这样的事实，尽可能坦然面对事业、生活、家庭中的苦与乐。 做人不要太容易多愁善感，不然容易成为loser。 生活的常态就是平淡，但是我们在规划未来的时候，尽可能还是为生活安排一些兴奋点。 每个人的生活都需要有一个支点，不管是让你充满成就感的事业、还是你疼爱的爱人，还是你的温暖家庭，还是你的知心挚友、老师、贵人，或者是一个爱好。至少要有一个这样的支点，能够支撑起你的生命。即使在你迷茫、无助、悲伤的时候，这个支点能支撑你走过最艰难的时刻。能让你的精神随时有地方可以倚靠。 转载自： http://mp.weixin.qq.com/s/PjlLbikJHSM4PKwpmTkL9g","categories":["剪切板"]},{"title":"程序员如何提升自身价值（转载）","path":"/post/618632730.html","content":"程序员薪水有高有低，有的人一个月可能拿30K、50K，有的人可能只有2K、3K。同样有五年工作经验的程序员，可能一个人每月拿20K，一个拿5K。是什么因素导致了这种差异？我特意总结了容易导致薪水低的九大行为表现，避开这些大坑，你就离高薪不远了。 1. 习惯即刻回报他不懂得只有春天播种，秋天才会有收获。刚刚付出一点点，甚至还没有付出，就想要得到回报。技术刚刚掌握，能一边百度一边干活了就觉得该拿到多少多少钱了。找工作先想着多少多少钱，入职了没干几个月就想着要加多少多少钱，干了没几个月，薪水要是没涨，就放弃了，准备通过跳槽加薪，不跳槽的话，往往也会因为没加薪而牢骚满腹，工作敷衍了事。 一个程序员的价值，是通过他带给公司的价值体现的。先给公司带来了价值，然后才会反过来在薪水上体现出自己的价值。公司都很现实，很少会为你的潜力买单，在你还没有体现出价值时就给你很高的薪水。 在生活和工作中，一定要懂得付出，不要那么急功近利，马上想得到回报。天下没有白吃的午餐，你想获得什么，就得先付出什么。唯有种下种子，然后浇水、施肥、除草、杀虫，然后才能等来收获。 2. 缺乏学习热情很少有哪个岗位的人像程序员这样需要持续不断的学习，软件开发的技术日新月异，而每一项技术又往往博大精深，不持续、深入钻研是很难掌握的，更别谈精通了。如果你对一项技术不能深刻理解熟练应用，表现出来的水准仅仅是能干活、还行，那很难说会有公司愿意为“还行”付出大的代价，只有脱颖而出，才可能备受重视。 假如你对学习、掌握、精通技术没有兴趣，面对不断涌现的新语言新技术新框架没有学习欲望，那但就软件开发这个工作而言，你不但眼下不太可能拿到高薪，将来也不会。在这样一个快速变化的时代，只有不断地学习才不会被抛弃。 3. 不够努力虽然我们都知道努力学习可以改变我们的技能水平，持续努力不懈坚持可以让自己有所建树，可还是有很多人浅尝辄止，三天打鱼两天晒网，搞两下能Run就放下了。 人和人在聪明才智上的差距并没有想象中大，甚至很多时候，从大多数人的努力程度之低来看，根本还轮不到拼天赋。如果两个人的实力半斤八两的话，热情工作努力坚持的人，一定比较容易成功。 4. 畏难做事拈轻怕重，不愿挑战。殊不知能力就是在不断挑战不断突破自己的过程中历练出来的。在一个公司里面，经常承担高难度任务的程序员，一定是成长比较快的，薪水增长也一定是比较快的。越是困难的事情，越能体现出个人价值，也越能带给个人成长。 万事起头难，不要害怕困难。事情做不好往往不是因为没有能力，大都是由于缺乏恒心。只要不怕困难，坚持前行，一定会有不一样的收获。 事业就像女人，谁去追求，谁就能得手。金钱也一样。 5. 缺乏责任心工作上不管什么事儿，反正不是自己的事儿，缺乏责任心，干好干不好都无所谓，对交付承诺、对产品质量都不在意，没什么事儿能让他上心。 一个人的责任心如何，决定着他在工作中的态度，决定着其事业的好坏和成败。如果一个人没有责任心，即使他有再大的能耐，也不一定能做出好的成绩来。 6. 消极，抱怨工作稍有不顺，就怨气沸腾，这个怎么怎么样，那个怎么怎么样，而我怎么就这样，任务不公平，资源不公平，那谁谁不支持我，那谁谁不配合…… 抱怨不能使事情变好，反之，它会让负面情绪蔓延，蚕食你的精力和时间，让你产出更低。成功者永不抱怨，抱怨者永不成功。立刻停止抱怨，早一分钟停止，你就离目标近一分钟。 7. 没有时间管理观念每个人的一天都只有24小时，人和人的差别就在于如何利用时间上。 有的人每周都有目标，每天都有计划，早上起来会想今天要做的几件重要的事，晚上会回顾今天完成的事，总结干成了什么干坏了什么，还会有计划的学习新知识新技能，这样日积月累不断坚持，每一天都是高效的，每一天都朝着更丰富更完美的自己前进。 而有的人则漫无目的，走哪算哪，到了公司，上午基本做不成事儿，到下午了还不知道要做什么，晚上也发愁如何消磨时间…… 8. 为薪水工作虽然工作的一大目的是获取薪水，养活自己以及供给家庭所需；但是，这只是工作最直接的报偿，同时也是最低级的目标。 如果我们为薪水而工作，将注定我们是短视的，也将注定受到最深的伤害。假如你看不到工资以外的东西，斤斤计较于薪水、福利、职位等，那外界的些微风吹草动就可能让你像浮萍一样飘来荡去，你很快就会失去平衡，失去信心，失去热情，失去平和，进而在工作时总是采取一种应付了事的态度，能少做就少做，能躲避就躲避，觉得只要对得起自己的那份薪水就成了。长此以往，你追求的高薪水反倒得不到。 我们进入一个公司工作，是为了自己，不是薪水也不是别人，比薪水更重要的，是成长和成就自己的机会。我们一定要明白，公司、企业、组织，都是我们锻炼自己、修炼自我的平台，我们不是为薪水工作、不是为老板工作、不是为家人工作，是为实现自我而工作，是为更完美的自己而工作。 唯有志存高远，方能风行天下。 9. 其实不喜欢软件开发有一部分人从事软件开发工作，并不是因为喜欢，也没有干着干着从不喜欢变成喜欢。他们可能是喜欢软件开发附带的高薪水——平均薪水比其他行业高。人做一件自己不喜欢的事情时，心理上没有亲近感，不会想着怎样把事情做得更好，往往是差不多就成了，不太可能有精益求精积极向上的追求。因为在做不喜欢的事情时，情感上是拒绝的，情绪上是想逃离的，总想着早点儿完事儿拉倒，每一天去单位时不是充满期待，而是各种担忧、烦躁、畏惧，到了单位，稍有困难或不顺心，就会消极、抱怨、抵触、拒绝…… 做喜欢的事，能最大可能发挥一个人的潜能和热情，会最快速地通向成功成就自己。而做不喜欢的事，一开始就注定了事倍功半，最后也往往会是痛苦不堪或半途而废。 转载自: 月薪3万的程序员都避开了哪些坑","categories":["剪切板"]},{"title":"使用WinDbg调试关键区死锁","path":"/post/3177767322.html","content":"本文通过一个实例来讲解如何使用WinDbg来调试Windows CriticalSection死锁的问题。 一. 演示示例这里有一个关键区锁死问题的程序，运行之后依次点击“CS锁死”按钮、右上角退出按钮，程序就会卡死。 对于眼下的这个问题，界面完全失去响应，这说明负责消息处理的UI线程阻塞了。 对于几乎所有的windows GUI程序，编号为0的初始线程就是UI线程，windows发现该界面一段时间没有消息响应之后就会在标题后面加上“（未响应）”。 二. WinDbg调试启动Windbg，附加到执行进程（F6）。 ~*knv3查看各个线程的调用堆栈，数字3表示显示的堆栈深度，省略即显示完整堆栈。 #0号线的栈帧0表示线程程阻塞在NtWaitForSingleObject函数，MSDN得知该函数原型为： 12345NTSTATUS WINAPI NtWaitForSingleObject( _In_ HANDLE Handle, _In_ BOOLEAN Alertable, _In_ PLARGE_INTEGER Timeout); 第一个参数Handle为其等待的句柄，第三个参数TimeOut为超时时间。同样从栈帧0得知NtWaitForSingleObject正在等待句柄000000c4，超时时间为0（即没信号就一直等待）。 !handle 000000c4 f 命令查看000000c4句柄的信息： 现在我们知道c4句柄就是线程ID:20d0的句柄，主线程在退出的时候等待该线程退出，而该线程一直没有退出，所以主线程卡死了。 根据图3得知20d0线程就是#1线程，~1kvn查看该线程完整堆栈： 栈帧00 NtWaitForSingleObject表示线程在等待000000c0句柄。 !handle!handle 000000c0 f查看句柄信息，得知c0句柄为事件句柄： 123456789101112130:002&gt; !handle c0 fHandle c0 Type Event Attributes 0 GrantedAccess 0x100003: Synch QueryState,ModifyState HandleCount 2 PointerCount 4 Name &lt;none&gt; Object Specific Information Event Type Auto Reset Event is Waiting !locks!locks查看进程中哪些锁处于锁定状态： 从第一行结果可以得知是gcsName临界区（需要有pdb才会显示具体变量名）处于锁定状态。 其实，我们从栈帧02 RtlEnterCriticalSection也可以很快的知道该线程一直在等待进入关键区。 经过分析，知道程序无法退出的原因了：线程#1中的关键区gcsName处于锁定状态（也就是一直等待进入关键区），导致线程#1阻塞无法执行。又因主线程在退出的时候执行了WaitForSingleObject等待#1线程，从而导致主线程卡死。 RTL_CRITICAL_SECTION结构关键区机制主要是通过下面这样的RTL_CRITICAL_SECTION结构来实现的，可以通过dt命令查看该结构定义： 123456780:002&gt; dt RTL_CRITICAL_SECTIONTest1!RTL_CRITICAL_SECTION +0x000 DebugInfo : Ptr32 _RTL_CRITICAL_SECTION_DEBUG +0x004 LockCount : Int4B +0x008 RecursionCount : Int4B +0x00c OwningThread : Ptr32 Void +0x010 LockSemaphore : Ptr32 Void +0x014 SpinCount : Uint4B 其中，LockCount字段用来标识关键区的锁状态，RecursionCount字段用来记录递归次数，用来支持同一个线程多次进入关键区，OwningThread字段用来记录进入（拥有）关键区的线程ID，LockSemaphore用来记录这个关键区对应的事件对象，当有线程需要等待这个关键区时，便是通过等待这个事件来做到的，这个事件对象是按需创建的，如果LockSemaphore为NULL表示这个关键区从来没有线程在此等待过。 通过图6中的OwningThread&#x3D;738得知，关键区被线程ID为738的线程所拥有，即Enter之后一直没有Leave。 知道了是哪个线程获取了关键区但没有释放，就可以很容易的在代码中定位问题了。 !cs -l!locks没有显示LockSemaphore字段，我们可以通过!cs -l命令获取更为全面的关键区信息： 从上图可以看到LockSemaphore&#x3D;0xC0，正好是#1线程NtWaitForSingleObject的事件对象。 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["Windbg","死锁"],"categories":["软件调试"]},{"title":"使用WinDbg调试互斥体死锁","path":"/post/1092140776.html","content":"本文通过一个实例来讲解如何使用WinDbg来调试Windows Mutex死锁的问题。 一. 演示用例下面是一个会导致Mutex死锁的程序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;process.h&gt;HANDLE hMutexA = NULL;HANDLE hMutexB = NULL;unsigned __stdcall ThreadProc1(void * pArg) &#123; WaitForSingleObject(hMutexA, INFINITE); Sleep(500); WaitForSingleObject(hMutexB, INFINITE); printf(&quot;+++ &quot;); ReleaseMutex(hMutexB); ReleaseMutex(hMutexA); return 0;&#125;unsigned __stdcall ThreadProc2(void * pArg) &#123; WaitForSingleObject(hMutexB, INFINITE); Sleep(500); WaitForSingleObject(hMutexA, INFINITE); printf(&quot;... &quot;); ReleaseMutex(hMutexA); ReleaseMutex(hMutexB); return 0;&#125;int main()&#123; hMutexA = CreateMutex(NULL, FALSE, TEXT(&quot;MutexA&quot;)); hMutexB = CreateMutex(NULL, FALSE, TEXT(&quot;MutexB&quot;)); // 启动线程 HANDLE hThread1 = (HANDLE)_beginthreadex(NULL, 0, ThreadProc1, NULL, 0, NULL); HANDLE hThread2 = (HANDLE)_beginthreadex(NULL, 0, ThreadProc2, NULL, 0, NULL); getchar(); // 等待线程退出并关闭句柄 if (hThread1) &#123; WaitForSingleObject(hThread1, INFINITE); CloseHandle(hThread1); &#125; if (hThread2) &#123; WaitForSingleObject(hThread2, INFINITE); CloseHandle(hThread2); &#125; // 关闭句柄 if(hMutexA) CloseHandle(hMutexA); if(hMutexB) CloseHandle(hMutexB); return 0;&#125; 二. 死锁原因程序生成了2个线程（线程1、线程2）和2个互斥体MutexA和MutexB。观察线程执行代码可知，这是一个典型的死锁用例，2个线程相互等待。 线程1： 拥有MutexA –&gt; 过一段时间(sleep) —&gt; 想拥有MutexB 线程2： 拥有MutexB –&gt; 过一段时间(sleep) —&gt; 想拥有MutexA 线程1想拥有属于线程2的MutexB，而线程2却想拥有属于线程1的MutexA，互不松手，就只能都等着了。 三. Windbg调试~*kvn查看所有线程调用堆栈： 从线程#1栈帧03可以看到其正在等待句柄00000038。从线程#2栈帧03可以看到其正在等待句柄00000034。即：线程#1（ID：22f4）—&gt;等待句柄38线程#2（ID：33bc）—&gt; 等待句柄34 使用!handle命令查看句柄00000034和00000038是什么类型： 从图中可以看到：句柄00000034为名为MutexA的互斥体，被线程ID：2264 拥有。句柄00000038为名为MutexB的互斥体，被线程ID：33bc 拥有。 即：线程#1（ID：22f4）等待00000038（互斥体MutexA ），拥有00000034（互斥体MutexB)线程#2（ID：33bc）等待句柄00000034（互斥体MutexB ），拥有00000038（互斥体MutexA) 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["Windbg","死锁"],"categories":["软件调试"]},{"title":"C++ 匿名对象","path":"/post/3350490999.html","content":"在WebRTC的源码中有如下函数： 1234template &lt;typename T&gt;std::unique_ptr&lt;T&gt; WrapUnique(T* ptr) &#123; return std::unique_ptr&lt;T&gt;(ptr);&#125; 该函数本身不复杂，重点在于它直接返回了一个std::unique_ptr，据我所知std::unique_ptr是不能够直接拷贝构造的，如： 12std::unique_ptr&lt;std::string&gt; s1(new std::string(&quot;123&quot;));std::unique_ptr&lt;std::string&gt; s2 = s1; // ERROR 而且WrapUnique经过单步调试，整个函数的执行过程只有执行了一次std::unique_ptr构造。按照我的理解，至少要执行1次构造，2次拷贝构造的。那么WrapUnique为什么可以做到了？ 结论是：C++编译器对匿名变量做了优化，编译器发现有变量来接收匿名变量，则直接将匿名变量的初始化过程放到接收该匿名变量的对象身上去，免去了后面的拷贝构造的过程。 如下测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Apple &#123;public: Apple() &#123; id_ = 0; cout &lt;&lt; &quot;Apple()&quot; &lt;&lt; endl; &#125; Apple(int id) &#123; id_ = id; cout &lt;&lt; &quot;Apple(&quot; &lt;&lt; id_ &lt;&lt; &quot;)&quot; &lt;&lt; endl; &#125; Apple(const Apple &amp;a) &#123; id_ = a.id_; cout &lt;&lt; &quot;Apple(const Apple &amp;a)&quot; &lt;&lt; endl; &#125; Apple&amp; operator=(const Apple &amp;that) &#123; id_ = that.id_; cout &lt;&lt; &quot;Apple&amp; operator=(const Apple &amp;that)&quot; &lt;&lt; endl; &#125; ~Apple() &#123; cout &lt;&lt; &quot;~Apple()&quot; &lt;&lt; endl; &#125;private: int id_;&#125;;Apple WrapApple(int id) &#123; return Apple(id);&#125;int main() &#123; Apple apple = WrapApple(666); return 0;&#125; 不考虑匿名变量的优化，我们猜测执行过程的输出是： 123Apple(666)Apple(const Apple &amp;a)Apple(const Apple &amp;a) 但实际执行结果是： 1Apple(666) 编译器直接对apple对象进行初始化，省去了2次拷贝构造的过程。 WebRTC中的WrapUnique函数就是利用这个原理。","tags":["C++","匿名对象","WebRTC"],"categories":["C++语言"]},{"title":"一个MySQL存储过程模板","path":"/post/254517042.html","content":"在进行数据库开发时，我们可能需要写很多存储过程，本文提供一个存储过程的模板，通过该模板可以简化存储过程的开发。 MySQL存储过程的范例模板，带返回值和异常处理的功能。 12345678910111213141516171819202122DROP PROCEDURE IF EXISTS sp_sample;CREATE PROCEDURE sp_sample(OUT errno INT)root:BEGIN /* 功能： IN参数： OUT参数： errno 存储过程异常标志(0-成功, 1-异常) */ DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN ROLLBACK; SET errno = 1; END; SET errno = 0; START TRANSACTION; -- do what you want to do. -- ... COMMIT;END; 其中，存储过程的异常捕获和回滚使用DECLARE...HANDLER实现： 12345DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN ROLLBACK; SET errno = 1; END; 关于DECLARE...HANDLER的用法见： MySQL的DECLARE...HANDLER使用","tags":["MySQL"],"categories":["数据库","MySQL"]},{"title":"Windows套接字I/O模型(5)-完成端口模型","path":"/post/326824759.html","content":"一、写在前面前面的文章已经介绍了套接字 I&#x2F;O 的同步模型、WSAAsyncSelect模型、WSAEventSelect模型，到目前为止套接字I&#x2F;O还剩下2个模型没有介绍：重叠模型，完成端口模型。 如果程序对性能和并发要求不高，可以使用前面介绍的WSAEventSelect模型；如果对性能和并发有要求，可以使用本文介绍的完成端口模型。 因为完成端口模型是基于重叠模型的，且在易用性、可伸缩性等方面都高于重叠模型，在一般选择重叠模型的场合，都可以用完成端口模型来替代，强烈建议使用完成端口模型。 “完成端口模型”是 Windows 系统上面套接字 I&#x2F;O 的终极模型，可以用它代替前面的所有模型。如果对完成端口模型有一个好的封装，基本上可以“一招鲜，吃遍天”，免去重复造轮子的麻烦。所以这里对完成端口的模型的介绍和比前面的几篇篇幅更长，示例代码也更加复杂和全面。 Reactor和Proactor在网络编程中，我们常听到的两种I&#x2F;O多路复用的模式：reactor 和 proactor。对于这两种模式的区别通俗来说就是： 12Reactor： 能收了你跟我说一声。Proactor: 你帮我最多收十个字节，收好了跟我说一声。 Windows提供的完成端口模型就是Proactor模式；而对于Linux系统，由于没有操作系统层面的支持，只能使用Reactor模式，如epoll等。 二、完成端口模型介绍完成端口模型说白了就是，您要做什么事情（如接收连接AcceptEx、发送数据WSASend、接收数据WSARecv、连接服务端ConnectEx），您告诉我，我做完了通知您。这里的“我”指的是操作系统，“您”指的是应用程序。如应用程序需要接收其他端发来的数据，可以调用WSARecv，并指定接收数据的缓冲区及大小，等其他端发来数据时，操作系统自动将数据放入到应用程序指定的缓冲区中，然后通知应用程序数据来啦。 这个和WSAEventSelect模型最大的不同就是，WSAEventSelect模型只是通知程序数据来了，并没有将数据接收，还需要程序调用recv来接收数据。 2.1 完成端口创建和绑定123456HANDLE WINAPI CreateIoCompletionPort( _In_ HANDLE FileHandle, _In_opt_ HANDLE ExistingCompletionPort, _In_ ULONG_PTR CompletionKey, _In_ DWORD NumberOfConcurrentThreads); CreateIoCompletionPort这个函数比较特殊，根据传入的参数不同，它可以实现2个功能：创建一个完成端口；将完成端口和设备（套接字）相绑定。一般对该函数进行如下封装来实现这2个功能： 12345678HANDLE CreateNewCompletionPort() &#123; return CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);&#125;BOOL AssociateDeviceWithCompletionPort(HANDLE completion_port, HANDLE device, DWORD completion_key) &#123; HANDLE h = CreateIoCompletionPort(device, completion_port, completion_key, 0); return (h == completion_port);&#125; 2.2 线程池前面说到了，完成端口模型就是应用程序等着操作系统把事情做完了通知它。那既然是等，等的操作肯定是阻塞住了的，所以不能在主线程中等，我们需要启动子线程去等。可是启动多个子线程去等了，一个连接一个线程吗？我们知道，线程越多，占用的系统资源也就越多，而且线程的切换也是消耗CPU时间的。所以线程不是越多越好，这里有一个经验法则就是：线程数量 = CPU数量 * 2。 线程数量和CPU数量相同是最理想的环境，这样免去了CPU在各个线程之间切换，但现实情况下，难免某些线程执行某些任务耗时较长，导致CPU将时间片从该线程分拨出去。所以这里用CPU数量乘以2，最大限度的利用CPU资源。这也是完成端口的目标，即最大限度的利用CPU资源。 获取CPU数量的方式： 12345int GetNumberOfProcesser() &#123; SYSTEM_INFO si; GetSystemInfo(&amp;si); return si.dwNumberOfProcessors;&#125; 2.3 AcceptEx等12345678910BOOL AcceptEx( _In_ SOCKET sListenSocket, _In_ SOCKET sAcceptSocket, _In_ PVOID lpOutputBuffer, _In_ DWORD dwReceiveDataLength, _In_ DWORD dwLocalAddressLength, _In_ DWORD dwRemoteAddressLength, _Out_ LPDWORD lpdwBytesReceived, _In_ LPOVERLAPPED lpOverlapped); AcceptEx和WSARecv、WSASend、ConnectEx等函数类似，最后一个参数都是LPOVERLAPPED，需要调用者提供一个重叠结构。但这个AcceptEx、ConnectEx等函数比较特别，他们是微软专门在Windows操作系统里面提供的扩展函数，不是在Winsock2标准里面提供的，是微软为了方便使用重叠I&#x2F;O机制，额外提供的一些函数。 以AcceptEx为例，微软的实现是通过mswsock.dll中提供的，所以我们可以通过静态链接mswsock.lib来直接调用AcceptEx。但不推荐使用这种方式，因为每次直接调用AcceptEx时，Service Provider都得要通过WSAIoctl()获取一次该函数指针，这样效率比较低。所以我们一般都是在直接代码中先获取到这个函数指针，并保存下来，后面直接使用这个函数指针就好了。 获取AcceptEx等函数的指针的方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162LPFN_ACCEPTEX GetAcceptExFnPointer(SOCKET s)&#123; LPFN_ACCEPTEX fn = NULL; GUID GuidAcceptEx = WSAID_ACCEPTEX; DWORD bytes = 0; if (SOCKET_ERROR == WSAIoctl( s, SIO_GET_EXTENSION_FUNCTION_POINTER, &amp;GuidAcceptEx, sizeof(GuidAcceptEx), &amp;fn, sizeof(fn), &amp;bytes, NULL, NULL)) &#123; return NULL; &#125; return fn;&#125;LPFN_CONNECTEX GetConnectExFnPointer(SOCKET s)&#123; LPFN_CONNECTEX fn = NULL; GUID GuidConnectEx = WSAID_CONNECTEX; DWORD bytes = 0; if (SOCKET_ERROR == WSAIoctl( s, SIO_GET_EXTENSION_FUNCTION_POINTER, &amp;GuidConnectEx, sizeof(GuidConnectEx), &amp;fn, sizeof(fn), &amp;bytes, NULL, NULL)) &#123; return NULL; &#125; return fn;&#125;LPFN_GETACCEPTEXSOCKADDRS GetAcceptExSockAddrsFnPointer(SOCKET s)&#123; LPFN_GETACCEPTEXSOCKADDRS fn = NULL; GUID GuidGetAcceptExSockAddrs = WSAID_GETACCEPTEXSOCKADDRS; DWORD bytes = 0; if (SOCKET_ERROR == WSAIoctl( s, SIO_GET_EXTENSION_FUNCTION_POINTER, &amp;GuidGetAcceptExSockAddrs, sizeof(GuidGetAcceptExSockAddrs), &amp;fn, sizeof(fn), &amp;bytes, NULL, NULL)) &#123; return NULL; &#125; return fn;&#125; 2.4 GetQueuedCompletionStatus函数原型如下： 1234567BOOL WINAPI GetQueuedCompletionStatus( _In_ HANDLE CompletionPort, _Out_ LPDWORD lpNumberOfBytes, _Out_ PULONG_PTR lpCompletionKey, _Out_ LPOVERLAPPED *lpOverlapped, _In_ DWORD dwMilliseconds); 前面说到了，完成端口模型需要在子线程中等待操作系统做完事情之后的通知。而GetQueuedCompletionStatus函数就是用来等待这个通知的。通过该函数可以获取的本次传输的字节数lpNumberOfBytes、一个用户绑定在套接字上的自定义整数lpCompletionKey、用户调用WSASend等函数时指定的OVERLAPPED结构的指针lpOverlapped。 我们比较关注的是lpCompletionKey、lpOverlapped这2个参数：lpCompletionKey是调用CreateIoCompletionPort函数绑定完成端口和套接字时指定的，每个套接字(SOCKET)对应一个lpCompletionKey。lpCompletionKey可以是包括指针在内的任何整数。 lpOverlapped是每次调用WSASend等函数时指定的，每一次操作（也就是每一次调用，如WSASend, WSARecv, AcceptEx, ConnectEx）对应的lpOverlapped都不一样，所以一次操作对应一个lpOverlapped。一个SOCKET可以有多次操作，多以对应多个lpOverlapped。 对应关系如下： 123456789101112131415161718192021+-----------+ +--------------------+| | 1 --&gt; 1 | || SOCKET +-----------&gt; lpCompletionKey || | | |+-----+-----+ +--------------------+ | |1 --&gt; n |+-----v------------------+| || Send,Recv,Accept... || |+-----+------------------+ | |1 --&gt; 1 |+-----v------------------+| || lpOverlapped || |+------------------------+ 注：示例代码中的PER_SOCKET_CONTEXT结构对应图中的SOCKET，PER_IO_CONTEXT结构对应图中的lpOverlapped。知道这个对理解示例代码会有很大的帮助。 Windows还提供了一个辅助宏CONTAINING_RECORD，该宏可以根据结构体中的某成员的地址来推算出该结构体整体的地址。知道了这个功能，我们就可以在lpOverlapped参数上做文章了（扩展），具体见示例。 上面对完成端口模型只做了一个简单的介绍，关于完成端口的详细介绍可以参考《windows核心编程 第5版》 10.3节。 2.5 CONTAINING_RECORD宏的实现原理该宏的作用就是：根据结构体中的某成员的地址来推算出该结构体整体的地址，相当于一个万能公式。 下面代码的注释中，讲解了该宏的实现原理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; struct T &#123; int a; int b; int c; &#125;; //CONTAINING_RECORD宏的作用就是根据结构体中的某成员的地址来推算出该结构体整体的地址。 T t = &#123; 1, 2, 3 &#125;; //假设我们知道T结构体中b的地址和名称，求t的指针 T *pT = CONTAINING_RECORD(&amp;t.b, T, b); printf(&quot;a:%d b:%d c:%d &quot;, pT-&gt;a, pT-&gt;b, pT-&gt;c); //CONTAINING_RECORD的定义: //((type *)( (PCHAR)(address) - (ULONG_PTR)(&amp;((type *)0)-&gt;field))) //最后一部分(&amp;((type *)0)-&gt;field) 将0(空指针)转成type，再取地址。 //在本例中就是将空指针转成T*, 然后指向b这个变量, 然后再取地址。 //这个操作的作用就是：假设T开始在0x000000内存位置上分配内存，在此基础上求b的内存地址, //这样等同于求得b的内存结构体对齐偏移量, 求得b的地址我们转成ULONG_PTR类型, //然后用实际b的内存地址减去b的结构体偏移量求得结构体首地址。 // //分解开来就是： //这种情况是允许的。 //这个大前提很重要！！！ T *pTemp = (T*)0; //求b的内存地址,在结构体首地址为0的情况下b的内存地址其实就是自身的对齐大小偏移量！！！ //CONTAINING_RECORD宏的核心！！！ int *pB = &amp;pTemp-&gt;b; ULONG_PTR Offset = (ULONG_PTR)pB; //转成数字, 就是b的偏移量。 printf(&quot;b的偏移量:%d &quot;, Offset); //因为各个成员的地址是递增的，最后用实际b的地址减b的偏移量的到结构体首地址 T *pFinal = (T*)(((char*)&amp;t.b) - Offset); printf(&quot;T中a:%d b:%d c:%d &quot;, pFinal-&gt;a, pFinal-&gt;b, pFinal-&gt;c); return 0;&#125; 三、示例示例代码实现如下功能： 服务端和客户端都使用完成端口模型来实现。 服务端和客户端之间通过发送消息来模拟TCP的三次握手机制。 3.1 辅助函数iocp.h和iocp.cpp中实现了IOCP相关的结构体定义和一些通用的辅助函数：iocp.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// iocp.h#ifndef IOCP_H_#define IOCP_H_#include &lt;winsock2.h&gt;#include &lt;MSWSock.h&gt;#include &lt;vector&gt;#define MAX_BUFFER_LEN 8192 #define EXIT_CODE 0namespace IOCP &#123; typedef enum _OPERATION_TYPE &#123; ACCEPT_POSTED, CONNECT_POSTED, SEND_POSTED, RECV_POSTED, NULL_POSTED &#125;OPERATION_TYPE; typedef struct _PER_IO_CONTEXT &#123; OVERLAPPED overlapped; SOCKET socket; WSABUF wsa_buffer; char buffer[MAX_BUFFER_LEN]; OPERATION_TYPE operation_type; _PER_IO_CONTEXT() &#123; ZeroMemory(&amp;overlapped, sizeof(overlapped)); ZeroMemory(buffer, MAX_BUFFER_LEN); socket = INVALID_SOCKET; wsa_buffer.buf = buffer; wsa_buffer.len = MAX_BUFFER_LEN; operation_type = NULL_POSTED; &#125; ~_PER_IO_CONTEXT() &#123; if (socket != INVALID_SOCKET) &#123; closesocket(socket); socket = INVALID_SOCKET; &#125; &#125; void ResetBuffer() &#123; ZeroMemory(buffer, MAX_BUFFER_LEN); &#125; &#125; PER_IO_CONTEXT; typedef struct _PER_SOCKET_CONTEXT &#123; SOCKET socket; SOCKADDR_IN client_addr; std::vector&lt;_PER_IO_CONTEXT*&gt; io_ctx_array; _PER_SOCKET_CONTEXT() &#123; socket = INVALID_SOCKET; memset(&amp;client_addr, 0, sizeof(client_addr)); &#125; ~_PER_SOCKET_CONTEXT() &#123; if (socket != INVALID_SOCKET) &#123; closesocket(socket); socket = INVALID_SOCKET; &#125; for (size_t i = 0; i &lt; io_ctx_array.size(); i++) &#123; delete io_ctx_array[i]; &#125; io_ctx_array.clear(); &#125; _PER_IO_CONTEXT* GetNewIoContext() &#123; _PER_IO_CONTEXT* p = new _PER_IO_CONTEXT; io_ctx_array.push_back(p); return p; &#125; void RemoveContext(_PER_IO_CONTEXT* pContext) &#123; for (std::vector&lt;_PER_IO_CONTEXT*&gt;::iterator it = io_ctx_array.begin(); it != io_ctx_array.end(); it++) &#123; if (pContext == *it) &#123; delete pContext; pContext = NULL; io_ctx_array.erase(it); break; &#125; &#125; &#125; &#125; PER_SOCKET_CONTEXT; int GetNumberOfProcesser(); HANDLE CreateNewCompletionPort(); BOOL AssociateDeviceWithCompletionPort(HANDLE completion_port, HANDLE device, DWORD completion_key); LPFN_ACCEPTEX GetAcceptExFnPointer(SOCKET s); LPFN_CONNECTEX GetConnectExFnPointer(SOCKET s); LPFN_GETACCEPTEXSOCKADDRS GetAcceptExSockAddrsFnPointer(SOCKET s);&#125;;#endif // IOCP_H_ iocp.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// iocp.cpp#include &quot;iocp.h&quot;namespace IOCP &#123; int GetNumberOfProcesser() &#123; SYSTEM_INFO si; GetSystemInfo(&amp;si); return si.dwNumberOfProcessors; &#125; HANDLE CreateNewCompletionPort() &#123; return CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0); &#125; BOOL AssociateDeviceWithCompletionPort(HANDLE completion_port, HANDLE device, DWORD completion_key) &#123; HANDLE h = CreateIoCompletionPort(device, completion_port, completion_key, 0); return (h == completion_port); &#125; LPFN_ACCEPTEX GetAcceptExFnPointer(SOCKET s) &#123; LPFN_ACCEPTEX fn = NULL; GUID GuidAcceptEx = WSAID_ACCEPTEX; DWORD bytes = 0; if (SOCKET_ERROR == WSAIoctl( s, SIO_GET_EXTENSION_FUNCTION_POINTER, &amp;GuidAcceptEx, sizeof(GuidAcceptEx), &amp;fn, sizeof(fn), &amp;bytes, NULL, NULL)) &#123; return NULL; &#125; return fn; &#125; LPFN_CONNECTEX GetConnectExFnPointer(SOCKET s) &#123; LPFN_CONNECTEX fn = NULL; GUID GuidConnectEx = WSAID_CONNECTEX; DWORD bytes = 0; if (SOCKET_ERROR == WSAIoctl( s, SIO_GET_EXTENSION_FUNCTION_POINTER, &amp;GuidConnectEx, sizeof(GuidConnectEx), &amp;fn, sizeof(fn), &amp;bytes, NULL, NULL)) &#123; return NULL; &#125; return fn; &#125; LPFN_GETACCEPTEXSOCKADDRS GetAcceptExSockAddrsFnPointer(SOCKET s) &#123; LPFN_GETACCEPTEXSOCKADDRS fn = NULL; GUID GuidGetAcceptExSockAddrs = WSAID_GETACCEPTEXSOCKADDRS; DWORD bytes = 0; if (SOCKET_ERROR == WSAIoctl( s, SIO_GET_EXTENSION_FUNCTION_POINTER, &amp;GuidGetAcceptExSockAddrs, sizeof(GuidGetAcceptExSockAddrs), &amp;fn, sizeof(fn), &amp;bytes, NULL, NULL)) &#123; return NULL; &#125; return fn; &#125;&#125; 3.1 服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348#include &lt;winsock2.h&gt;#include &lt;iostream&gt;#include &lt;assert.h&gt;#include &lt;vector&gt;#include &lt;process.h&gt;#include &quot;iocp.h&quot;using namespace std;const u_short kPort = 10001;const std::string kSYN = &quot;(SYN) hello server, I&#x27;m client. Can you hear me?&quot;;const std::string kSYN_ACK = &quot;(SYN+ACK) hello client, I&#x27;m server. I can hear you, can you hear me?&quot;;const std::string kACK = &quot;(ACK) hello server, I&#x27;m client. I can hear you!&quot;;#pragma comment(lib, &quot;Ws2_32.lib&quot;)HANDLE g_IOCP = INVALID_HANDLE_VALUE;HANDLE g_exit = NULL;int g_work_thread_num = 0;HANDLE *g_work_threads = NULL;IOCP::PER_SOCKET_CONTEXT *g_listen_ctx = NULL;CRITICAL_SECTION g_cs_socket_ctx_array;std::vector&lt;IOCP::PER_SOCKET_CONTEXT*&gt; g_socket_ctx_array;LPFN_ACCEPTEX g_AcceptExFn = NULL;LPFN_GETACCEPTEXSOCKADDRS g_AcceptExSockAddrsFn = NULL;// 管理g_socket_ctx_array//void AddSocketContext(IOCP::PER_SOCKET_CONTEXT *socket_ctx) &#123; EnterCriticalSection(&amp;g_cs_socket_ctx_array); g_socket_ctx_array.push_back(socket_ctx); LeaveCriticalSection(&amp;g_cs_socket_ctx_array);&#125;void RemoveSocketContext(IOCP::PER_SOCKET_CONTEXT *socket_ctx) &#123; EnterCriticalSection(&amp;g_cs_socket_ctx_array); for (std::vector&lt;IOCP::PER_SOCKET_CONTEXT*&gt;::iterator it = g_socket_ctx_array.begin(); it != g_socket_ctx_array.end(); it++) &#123; if (*it == socket_ctx) &#123; delete *it; g_socket_ctx_array.erase(it); break; &#125; &#125; LeaveCriticalSection(&amp;g_cs_socket_ctx_array);&#125;void ClearSocketContextArray() &#123; EnterCriticalSection(&amp;g_cs_socket_ctx_array); for (std::vector&lt;IOCP::PER_SOCKET_CONTEXT*&gt;::iterator it = g_socket_ctx_array.begin(); it != g_socket_ctx_array.end(); it++) &#123; closesocket((*it)-&gt;socket); delete *it; &#125; g_socket_ctx_array.clear(); LeaveCriticalSection(&amp;g_cs_socket_ctx_array);&#125;// 发送Accept、Recv、Send请求//bool PostAccept(IOCP::PER_IO_CONTEXT* io_ctx) &#123; if (io_ctx == NULL) return false; io_ctx-&gt;operation_type = IOCP::ACCEPT_POSTED; io_ctx-&gt;ResetBuffer(); io_ctx-&gt;socket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED); if (io_ctx-&gt;socket == INVALID_SOCKET) &#123; printf(&quot;WSASocket failed with code: %d &quot;, WSAGetLastError()); return false; &#125; DWORD bytes = 0; if (g_AcceptExFn(g_listen_ctx-&gt;socket, io_ctx-&gt;socket, io_ctx-&gt;wsa_buffer.buf, 0, sizeof(SOCKADDR_IN) + 16, sizeof(SOCKADDR_IN) + 16, &amp;bytes, &amp;io_ctx-&gt;overlapped) == FALSE) &#123; int gle = WSAGetLastError(); if (gle != WSA_IO_PENDING) &#123; printf(&quot;AcceptEx failed with code: %d &quot;, gle); return false; &#125; &#125; return true;&#125;bool PostRecv(IOCP::PER_IO_CONTEXT* io_ctx) &#123; if (io_ctx == NULL) return false; io_ctx-&gt;operation_type = IOCP::RECV_POSTED; io_ctx-&gt;ResetBuffer(); DWORD recv_bytes = 0; DWORD flags = 0; int ret = WSARecv(io_ctx-&gt;socket, &amp;io_ctx-&gt;wsa_buffer, 1, &amp;recv_bytes, &amp;flags, &amp;io_ctx-&gt;overlapped, NULL); if (ret == SOCKET_ERROR &amp;&amp; WSAGetLastError() != WSA_IO_PENDING) &#123; return false; &#125; return true;&#125;bool PostSend(IOCP::PER_IO_CONTEXT* io_ctx, const char* msg, int msg_len) &#123; if (io_ctx == NULL) return false; io_ctx-&gt;operation_type = IOCP::SEND_POSTED; memcpy(io_ctx-&gt;wsa_buffer.buf, msg, msg_len); io_ctx-&gt;wsa_buffer.len = msg_len; DWORD sent_bytes = 0; int ret = WSASend(io_ctx-&gt;socket, &amp;io_ctx-&gt;wsa_buffer, 1, &amp;sent_bytes, 0, &amp;io_ctx-&gt;overlapped, NULL); if (ret == SOCKET_ERROR &amp;&amp; WSAGetLastError() != WSA_IO_PENDING) &#123; return false; &#125; return true;&#125;// 处理Accept、Recv、Send完成之后的通知//bool DoAccept(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx) &#123; SOCKADDR_IN* ClientAddr = NULL; SOCKADDR_IN* LocalAddr = NULL; int remoteLen = sizeof(SOCKADDR_IN); int localLen = sizeof(SOCKADDR_IN); g_AcceptExSockAddrsFn(io_ctx-&gt;wsa_buffer.buf, io_ctx-&gt;wsa_buffer.len - ((sizeof(SOCKADDR_IN) + 16) * 2), sizeof(SOCKADDR_IN) + 16, sizeof(SOCKADDR_IN) + 16, (LPSOCKADDR*)&amp;LocalAddr, &amp;localLen, (LPSOCKADDR*)&amp;ClientAddr, &amp;remoteLen); printf(&quot;* new connection(%s:%d): %s &quot;, inet_ntoa(ClientAddr-&gt;sin_addr), ntohs(ClientAddr-&gt;sin_port), io_ctx-&gt;wsa_buffer.buf); // 此次创建一个新的PER_SOCKET_CONTEXT，之前老的PER_SOCKET_CONTEXT继续用作接收客户端连接 // IOCP::PER_SOCKET_CONTEXT *new_socket_ctx = new IOCP::PER_SOCKET_CONTEXT(); new_socket_ctx-&gt;socket = io_ctx-&gt;socket; if (!IOCP::AssociateDeviceWithCompletionPort(g_IOCP, (HANDLE)new_socket_ctx-&gt;socket, (DWORD)new_socket_ctx)) &#123; printf(&quot;AssociateDeviceWithCompletionPort failed &quot;); delete new_socket_ctx; new_socket_ctx = NULL; return false; &#125; AddSocketContext(new_socket_ctx); // post recv IOCP::PER_IO_CONTEXT *new_io_ctx = new_socket_ctx-&gt;GetNewIoContext(); new_io_ctx-&gt;socket = new_socket_ctx-&gt;socket; if (!PostRecv(new_io_ctx)) &#123; printf(&quot;PostRecv failed &quot;); return false; &#125; // post new accept if (!PostAccept(io_ctx)) &#123; printf(&quot;PostAccept failed &quot;); return false; &#125; return true;&#125;bool DoRecv(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx) &#123; printf(&quot;recv: %s &quot;, io_ctx-&gt;wsa_buffer.buf); if (strcmp(io_ctx-&gt;wsa_buffer.buf, kSYN.c_str()) == 0) &#123; // SYN+ACK IOCP::PER_IO_CONTEXT * new_io_ctx = socket_ctx-&gt;GetNewIoContext(); new_io_ctx-&gt;socket = socket_ctx-&gt;socket; if (!PostSend(new_io_ctx, kSYN_ACK.c_str(), kSYN_ACK.length())) &#123; printf(&quot;PostSend failed &quot;); return false; &#125; &#125; // post new recv if (!PostRecv(io_ctx)) &#123; printf(&quot;PostRecv failed &quot;); return false; &#125; return true;&#125;bool DoSend(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx) &#123; printf(&quot;send: %s &quot;, io_ctx-&gt;wsa_buffer.buf); return true;&#125;// 工作线程unsigned int __stdcall WorkThreadProc(void *arg) &#123; DWORD transferred_bytes = 0; IOCP::PER_SOCKET_CONTEXT *socket_ctx = NULL; OVERLAPPED *overlapped = NULL; DWORD gle; while (WaitForSingleObject(g_exit, 0) != WAIT_OBJECT_0) &#123; BOOL ret = GetQueuedCompletionStatus(g_IOCP, &amp;transferred_bytes, (PULONG_PTR)&amp;socket_ctx, &amp;overlapped, INFINITE); gle = GetLastError(); if (socket_ctx == EXIT_CODE) &#123; break; &#125; if (ret == FALSE) &#123; if (gle == WAIT_TIMEOUT) &#123; continue; &#125; else if (gle == ERROR_NETNAME_DELETED) &#123; printf(&quot;client exit &quot;); RemoveSocketContext(socket_ctx); continue; &#125; else &#123; RemoveSocketContext(socket_ctx); break; &#125; &#125; else &#123; // http://blog.csdn.net/china_jeffery/article/details/78801331 IOCP::PER_IO_CONTEXT *io_ctx = CONTAINING_RECORD(overlapped, IOCP::PER_IO_CONTEXT, overlapped); if ((transferred_bytes == 0) &amp;&amp; (io_ctx-&gt;operation_type == IOCP::RECV_POSTED || io_ctx-&gt;operation_type == IOCP::SEND_POSTED)) &#123; printf(&quot;client disconnect &quot;); RemoveSocketContext(socket_ctx); continue; &#125; switch (io_ctx-&gt;operation_type) &#123; case IOCP::ACCEPT_POSTED: DoAccept(socket_ctx, io_ctx); break; case IOCP::RECV_POSTED: DoRecv(socket_ctx, io_ctx); break; case IOCP::SEND_POSTED: DoSend(socket_ctx, io_ctx); break; default: assert(false); &#125; &#125; &#125; return 0;&#125;int main()&#123; WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); do &#123; InitializeCriticalSection(&amp;g_cs_socket_ctx_array); g_IOCP = IOCP::CreateNewCompletionPort(); g_exit = CreateEvent(NULL, FALSE, FALSE, NULL); g_work_thread_num = IOCP::GetNumberOfProcesser() * 2; g_work_threads = new HANDLE[g_work_thread_num]; for (int i = 0; i &lt; g_work_thread_num; i++) &#123; g_work_threads[i] = (HANDLE)_beginthreadex(NULL, 0, WorkThreadProc, NULL, 0, NULL); &#125; g_listen_ctx = new IOCP::PER_SOCKET_CONTEXT; g_listen_ctx-&gt;socket = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED); if (!IOCP::AssociateDeviceWithCompletionPort(g_IOCP, (HANDLE)g_listen_ctx-&gt;socket, (DWORD)g_listen_ctx)) &#123; printf(&quot;AssociateDeviceWithCompletionPort failed with code: %d &quot;, GetLastError()); break; &#125; struct sockaddr_in addr = &#123; 0 &#125;; addr.sin_family = AF_INET; addr.sin_addr.s_addr = htonl(INADDR_ANY); addr.sin_port = htons(kPort); if (bind(g_listen_ctx-&gt;socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) &#123; printf(&quot;bind failed with code: %d &quot;, WSAGetLastError()); break; &#125; if (listen(g_listen_ctx-&gt;socket, SOMAXCONN) == SOCKET_ERROR) &#123; printf(&quot;listen failed with code: %d &quot;, WSAGetLastError()); break; &#125; g_AcceptExFn = IOCP::GetAcceptExFnPointer(g_listen_ctx-&gt;socket); if (g_AcceptExFn == NULL) &#123; printf(&quot;GetAcceptExFnPointer failed &quot;); break; &#125; g_AcceptExSockAddrsFn = IOCP::GetAcceptExSockAddrsFnPointer(g_listen_ctx-&gt;socket); if (g_AcceptExSockAddrsFn == NULL) &#123; printf(&quot;GetAcceptExSockAddrsFnPointer failed &quot;); break; &#125; int i = 0; for (; i &lt; 10; i++) &#123; IOCP::PER_IO_CONTEXT *io_ctx = g_listen_ctx-&gt;GetNewIoContext(); if (PostAccept(io_ctx) == FALSE) &#123; break; &#125; &#125; if(i != 10) break; &#125; while (FALSE); printf(&quot; press any ket to stop server... &quot;); getchar(); SetEvent(g_exit); for (int i = 0; i &lt; g_work_thread_num; i++) &#123; PostQueuedCompletionStatus(g_IOCP, 0, (DWORD)EXIT_CODE, NULL); &#125; WaitForMultipleObjects(g_work_thread_num, g_work_threads, TRUE, INFINITE); ClearSocketContextArray(); printf(&quot; press any ket to exit... &quot;); getchar(); DeleteCriticalSection(&amp;g_cs_socket_ctx_array); WSACleanup(); return 0;&#125; 3.2 客户端客户端代码和服务端类似，唯一需要注意的是ConnectEx函数调用之前，需要将SOCKET进行bind操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;winsock2.h&gt;#include &lt;iostream&gt;#include &lt;assert.h&gt;#include &lt;vector&gt;#include &lt;process.h&gt;#include &quot;iocp.h&quot;using namespace std;const std::string kIP = &quot;127.0.0.1&quot;;const u_short kPort = 10001;const std::string kSYN = &quot;(SYN) hello server, I&#x27;m client. Can you hear me?&quot;;const std::string kSYN_ACK = &quot;(SYN+ACK) hello client, I&#x27;m server. I can hear you, can you hear me?&quot;;const std::string kACK = &quot;(ACK) hello server, I&#x27;m client. I can hear you!&quot;;#pragma comment(lib, &quot;Ws2_32.lib&quot;)HANDLE g_IOCP = INVALID_HANDLE_VALUE;HANDLE g_exit = NULL;int g_work_thread_num = 0;HANDLE *g_work_threads = NULL;IOCP::PER_SOCKET_CONTEXT *g_client_ctx = NULL;LPFN_CONNECTEX g_ConnectExFn = NULL;bool PostConnect(IOCP::PER_IO_CONTEXT* io_ctx, const std::string &amp;ip, int port) &#123; if (io_ctx == NULL) return false; io_ctx-&gt;operation_type = IOCP::CONNECT_POSTED; io_ctx-&gt;ResetBuffer(); // ConnectEx requires the socket to be initially bound. struct sockaddr_in addr0 = &#123; 0 &#125;; addr0.sin_family = AF_INET; addr0.sin_addr.s_addr = INADDR_ANY; addr0.sin_port = 0; int ret = bind(io_ctx-&gt;socket, (SOCKADDR*)&amp;addr0, sizeof(addr0)); if (ret != 0) &#123; printf(&quot;bind failed: %d &quot;, WSAGetLastError()); return false; &#125; struct sockaddr_in addr1 = &#123; 0 &#125;; addr1.sin_family = AF_INET; addr1.sin_addr.s_addr = inet_addr(ip.c_str()); addr1.sin_port = htons(port); ret = g_ConnectExFn(io_ctx-&gt;socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr1), sizeof(addr1), NULL, 0, NULL, &amp;io_ctx-&gt;overlapped); int gle = WSAGetLastError(); if (ret == SOCKET_ERROR &amp;&amp; gle != WSA_IO_PENDING) &#123; return false; &#125; return true;&#125;bool PostRecv(IOCP::PER_IO_CONTEXT* io_ctx) &#123; if (io_ctx == NULL) return false; io_ctx-&gt;operation_type = IOCP::RECV_POSTED; io_ctx-&gt;ResetBuffer(); DWORD recv_bytes = 0; DWORD flags = 0; int ret = WSARecv(io_ctx-&gt;socket, &amp;io_ctx-&gt;wsa_buffer, 1, &amp;recv_bytes, &amp;flags, &amp;io_ctx-&gt;overlapped, NULL); if (ret == SOCKET_ERROR &amp;&amp; WSAGetLastError() != WSA_IO_PENDING) &#123; return false; &#125; return true;&#125;bool PostSend(IOCP::PER_IO_CONTEXT* io_ctx, const char* msg, int msg_len) &#123; if (io_ctx == NULL) return false; io_ctx-&gt;operation_type = IOCP::SEND_POSTED; memcpy(io_ctx-&gt;wsa_buffer.buf, msg, msg_len); io_ctx-&gt;wsa_buffer.len = msg_len; DWORD sent_bytes = 0; int ret = WSASend(io_ctx-&gt;socket, &amp;io_ctx-&gt;wsa_buffer, 1, &amp;sent_bytes, 0, &amp;io_ctx-&gt;overlapped, NULL); int gle = WSAGetLastError(); if (ret == SOCKET_ERROR &amp;&amp; gle != WSA_IO_PENDING) &#123; printf(&quot;WSASend failed with code: %d &quot;, gle); return false; &#125; return true;&#125;bool DoConnect(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx) &#123; printf(&quot;connect to server &quot;); if (!PostRecv(io_ctx)) &#123; printf(&quot;PostRecv failed &quot;); return false; &#125; IOCP::PER_IO_CONTEXT* new_io_ctx = socket_ctx-&gt;GetNewIoContext(); new_io_ctx-&gt;socket = socket_ctx-&gt;socket; if (!PostSend(new_io_ctx, kSYN.c_str(), kSYN.length())) &#123; printf(&quot;PostSend failed &quot;); return false; &#125; return true;&#125;bool DoRecv(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx) &#123; printf(&quot;recv: %s &quot;, io_ctx-&gt;wsa_buffer.buf); if (strcmp(io_ctx-&gt;wsa_buffer.buf, kSYN_ACK.c_str()) == 0) &#123; // ACK IOCP::PER_IO_CONTEXT * new_io_ctx = socket_ctx-&gt;GetNewIoContext(); new_io_ctx-&gt;socket = socket_ctx-&gt;socket; if (!PostSend(new_io_ctx, kACK.c_str(), kACK.length())) &#123; printf(&quot;PostSend failed &quot;); return false; &#125; &#125; // post new recv if (!PostRecv(io_ctx)) &#123; printf(&quot;PostRecv failed &quot;); return false; &#125; return true;&#125;bool DoSend(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx) &#123; printf(&quot;send: %s &quot;, io_ctx-&gt;wsa_buffer.buf); return true;&#125;unsigned int __stdcall WorkThreadProc(void *arg) &#123; DWORD transferred_bytes = 0; IOCP::PER_SOCKET_CONTEXT *socket_ctx = NULL; OVERLAPPED *overlapped = NULL; DWORD gle; while (WaitForSingleObject(g_exit, 0) != WAIT_OBJECT_0) &#123; BOOL ret = GetQueuedCompletionStatus(g_IOCP, &amp;transferred_bytes, (PULONG_PTR)&amp;socket_ctx, &amp;overlapped, INFINITE); gle = GetLastError(); if (socket_ctx == EXIT_CODE) &#123; break; &#125; if (ret == FALSE) &#123; if (gle == WAIT_TIMEOUT) &#123; continue; &#125; else if (gle == ERROR_NETNAME_DELETED) &#123; printf(&quot;server exit &quot;); closesocket(socket_ctx-&gt;socket); socket_ctx-&gt;socket = INVALID_SOCKET; break; &#125; else &#123; closesocket(socket_ctx-&gt;socket); socket_ctx-&gt;socket = INVALID_SOCKET; break; &#125; &#125; else &#123; IOCP::PER_IO_CONTEXT *io_ctx = CONTAINING_RECORD(overlapped, IOCP::PER_IO_CONTEXT, overlapped); switch (io_ctx-&gt;operation_type) &#123; case IOCP::CONNECT_POSTED: DoConnect(socket_ctx, io_ctx); break; case IOCP::RECV_POSTED: DoRecv(socket_ctx, io_ctx); break; case IOCP::SEND_POSTED: DoSend(socket_ctx, io_ctx); break; default: assert(false); &#125; &#125; &#125; return 0;&#125;int main()&#123; WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); do &#123; g_IOCP = IOCP::CreateNewCompletionPort(); g_exit = CreateEvent(NULL, FALSE, FALSE, NULL); g_work_thread_num = IOCP::GetNumberOfProcesser() * 2; g_work_threads = new HANDLE[g_work_thread_num]; for (int i = 0; i &lt; g_work_thread_num; i++) &#123; g_work_threads[i] = (HANDLE)_beginthreadex(NULL, 0, WorkThreadProc, NULL, 0, NULL); &#125; g_client_ctx = new IOCP::PER_SOCKET_CONTEXT; g_client_ctx-&gt;socket = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED); if (!IOCP::AssociateDeviceWithCompletionPort(g_IOCP, (HANDLE)g_client_ctx-&gt;socket, (DWORD)g_client_ctx)) &#123; printf(&quot;AssociateDeviceWithCompletionPort failed with code: %d &quot;, GetLastError()); break; &#125; g_ConnectExFn = IOCP::GetConnectExFnPointer(g_client_ctx-&gt;socket); if (g_ConnectExFn == NULL) &#123; printf(&quot;GetConnectExFnPointer failed &quot;); break; &#125; IOCP::PER_IO_CONTEXT* io_ctx = g_client_ctx-&gt;GetNewIoContext(); io_ctx-&gt;socket = g_client_ctx-&gt;socket; if (!PostConnect(io_ctx, kIP, kPort)) &#123; printf(&quot;PostConnect failed &quot;); &#125; &#125; while (FALSE); printf(&quot;press any key to exit client... &quot;); getchar(); SetEvent(g_exit); closesocket(g_client_ctx-&gt;socket); getchar(); WSACleanup(); return 0;&#125; 完整工程下载地址：https://github.com/winsoft666/CodeSnippet/tree/main/CompletionPort-Sample","tags":["套接字I/O模型","完成端口"],"categories":["网络编程"]},{"title":"由字符串格式化函数引起的崩溃","path":"/post/432875265.html","content":"本文记录一个由错误使用StringCchVPrintf等格式化函数所导致的崩溃问题。 一. 问题描述我们常用的格式化字符串函数有： 123456HRESULT StringCchVPrintf( _Out_ LPTSTR pszDest, _In_ size_t cchDest, _In_ LPCTSTR pszFormat, _In_ va_list argList); 1int printf ( const char * format, ... ); 对于如下的调用： 12char buf[100] = &#123;0&#125;;StringCchVPrintf(buf, 100, &quot;select * from member where name like &#x27;%sjj%&#x27;;&quot;); 此时buf中存储的并不是期望的select * from member where name like &#39;%sjj%&#39;;字符串。不出意外，%sjj%处的%s会变成乱码。 因为函数将%sjj%中的%s当做了字符串格式化串了，而我们又没有给最后一个参数（即可变参数）传值，根据可变参数的原理，默认会根据format参数的地址来取一个地址让%s进行输出。 具体计算方式参考va_start宏定义: 12#define va_start _crt_va_start#define _crt_va_start(ap,v) ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) ) 这个地址的内容是未知的，所以就可能出现乱码或崩溃。 二. 解决方案要解决这个问题，我们只需要做到一点，在调用StringCchVPrintf、vsprintf、vswprintf、_vstprintf、printf等函数时，一定不要将固定字符串传入到pszFormat参数，如： 1StringCchVPrintf(szBuf, 512, &quot;我想输出单纯的%s，我是错误的格式示范&quot;); // 错误的 这个时候，单纯的%s中的%s已经不在单纯。 正确的做法是： 1StringCchVPrintf(szBuf, 512, &quot;%s&quot;, &quot;我想输出单纯的%s，我是正确的格式示范&quot;); 同理，下面的调用方式也是错误的、危险的： 12std::string strInfo = GetInfo();printf(strInfo.c_str()); 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["字符串","崩溃"],"categories":["软件调试"]},{"title":"Windows套接字I/O模型(4)-WSAEventSelect模型","path":"/post/547434843.html","content":"一、WSAEventSelect模型介绍WSAEventSelect模型和WSAAsyncSelect模型类似，但WSAEventSelect模型允许应用程序在一个或多个套接字上面接收以事件为基础的网络事件通知。该模型和WSAAsyncSelect模型的最主要的区别在于网络事件是由事件对象句柄完成的，而不是通过窗口消息完成的。 该模型要求应用程序为打算使用的每一个套接字都创建一个事件对象。使用WSACreateEvent函数即可创建事件对象，函数原型如下： 1WSAEVENT WSACreateEvent(void); WSACreateEvent 函数返回一个人工控制(manual)、无初始信号的事件句柄。在得到事件句柄之后，可以通过调用WSAEventSelect函数，将它和套接字相关联，同时注册感兴趣的网络事件。 12345int WSAEventSelect( _In_ SOCKET s, _In_ WSAEVENT hEventObject, _In_ long lNetworkEvents); 具体的参数解释可以参考MSDN：https://msdn.microsoft.com/en-us/library/windows/desktop/ms741576(v=vs.85).aspx 和CreateEvent创建的事件类型，windows提供了类似的API来重置事件信号、关闭事件等，如WSAResetEvent, WSACloseEvent等。 同样提供了和 WaitForMultipleObjects 类似的函数WSAWaitForMultipleEvents，用于等待多个事件信号，其参数也和 WaitForMultipleObjects 类似。 需要注意的是，WSAWaitForMultipleEvents 最多只支持同时等待64个事件，如果需要等待超过64个事件，需要使用多个线程调用多次 WSAWaitForMultipleEvents 函数来实现，这也是WSAEventSelect 模型的一大弊端。 WSAEnumNetworkEvents 函数用于查询指定的SOCKET上有哪些有信号事件（是FD_READ，还是FD_WRITE，或者说还是FD_ACCEPT等），hEventObject 参数为事件句柄，函数会自动将事件置为无信号状态，不需要再次调用 WSAResetEvent 来重置信号。 12345int WSAEnumNetworkEvents( _In_ SOCKET s, _In_ WSAEVENT hEventObject, _Out_ LPWSANETWORKEVENTS lpNetworkEvents); 具体的用法可以参考下面“示例程序”。 二、示例服务端和客户端着重在列出 WSAEventSelect 模型的基本用法，并未实现复杂的逻辑。 服务端在有新的客户端连接上时，给主动客户端发送“hello, I’m server.”消息，并且在服务端退出时会关闭所有客户端连接。 客户端在连接上服务端之后，会不间断接收服务端的消息。 示例程序只使用了一个线程来等待最多64个事件（也就是最多只支持 64 - 1 = 63 个客户端连接），如果需要支持更多的客户端连接，可以开启多个线程来等待。 2.1 服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include &lt;winsock2.h&gt;#include &lt;iostream&gt;#include &lt;assert.h&gt;#include &lt;vector&gt;using namespace std;#pragma comment(lib, &quot;Ws2_32.lib&quot;)const u_short kPort = 10001;const std::string kHelloServer = &quot;hello, I&#x27;m server.&quot;;HANDLE g_event_array[WSA_MAXIMUM_WAIT_EVENTS]; // 存储所有的事件句柄SOCKET g_socket_array[WSA_MAXIMUM_WAIT_EVENTS]; // 存储所有的socketint g_index = 0; // 记录数组的下标template&lt;typename T&gt;void RemoveArrayIndex(T arr[], int total, int index) &#123; if (index &gt; total) return; for (int i = index; i &lt; (total - 1); i++) &#123; arr[i] = arr[i + 1]; &#125;&#125;int main()&#123; WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); do &#123; // (1) g_socket_array[g_index] = ::socket(AF_INET, SOCK_STREAM, 0); if (g_socket_array[0] == INVALID_SOCKET) &#123; std::cout &lt;&lt; &quot;create socket failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; // (2) struct sockaddr_in addr = &#123; 0 &#125;; addr.sin_family = AF_INET; addr.sin_addr.s_addr = htonl(INADDR_ANY); addr.sin_port = htons(kPort); if (bind(g_socket_array[g_index], reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;bind failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; // (3) g_event_array[g_index] = WSACreateEvent(); WSAEventSelect(g_socket_array[g_index], g_event_array[g_index], FD_ACCEPT | FD_READ | FD_WRITE | FD_CLOSE); // (4) if (listen(g_socket_array[g_index], 5) == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;listen failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; std::cout &lt;&lt; &quot;listen on port: &quot; &lt;&lt; kPort &lt;&lt; std::endl; // (5) // 该循环可以放到子线程中 while (true) &#123; DWORD ret = WSAWaitForMultipleEvents(g_index + 1, g_event_array, FALSE, WSA_INFINITE, FALSE); if(ret == WSA_WAIT_FAILED || ret == WSA_WAIT_TIMEOUT) continue; // 忽略上面WSAWaitForMultipleEvents返回值所表示的index。遍历每个socket，查看是否有信号。 for (int i = 0; i &lt;= g_index; i++) &#123; ret = WSAWaitForMultipleEvents(1, &amp;g_event_array[i], FALSE, 0, FALSE); if (ret == WSA_WAIT_FAILED || ret == WSA_WAIT_TIMEOUT) &#123; continue; &#125; WSANETWORKEVENTS network_events; // WSAEnumNetworkEvent函数会将事件重置为无信号状态 WSAEnumNetworkEvents(g_socket_array[i], g_event_array[i], &amp;network_events); if (network_events.lNetworkEvents &amp; FD_ACCEPT) &#123; if (network_events.iErrorCode[FD_ACCEPT_BIT] != 0) &#123; std::cout &lt;&lt; &quot;FD_ACCEPT failed with code: &quot; &lt;&lt; network_events.iErrorCode[FD_ACCEPT_BIT] &lt;&lt; &quot; &quot;; break; &#125; SOCKET s = accept(g_socket_array[i], NULL, NULL); if (s == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;accept failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; if (g_index &gt;= WSA_MAXIMUM_WAIT_EVENTS - 1) &#123; std::cout &lt;&lt; &quot;too many connection &quot;; closesocket(s); break; &#125; g_index++; g_event_array[g_index] = WSACreateEvent(); g_socket_array[g_index] = s; std::cout &lt;&lt; &quot;new connection &quot;; int err = send(s, (const char*)kHelloServer.c_str(), kHelloServer.length(), 0); if (err == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;send failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; &#125; if (network_events.lNetworkEvents &amp; FD_READ) &#123; if (network_events.iErrorCode[FD_READ_BIT] != 0) &#123; std::cout &lt;&lt; &quot;FD_READ failed with code: &quot; &lt;&lt; network_events.iErrorCode[FD_READ_BIT] &lt;&lt; &quot; &quot;; break; &#125; char buf[100] = &#123; 0 &#125;; int err = recv(g_socket_array[i], buf, 100, 0); if (err &gt; 0) &#123; std::cout &lt;&lt; &quot;recv: &quot; &lt;&lt; buf &lt;&lt; std::endl; &#125; else if (err == 0) &#123; std::cout &lt;&lt; &quot;connection closed.&quot; &lt;&lt; std::endl; closesocket(g_socket_array[i]); WSACloseEvent(g_event_array[i]); RemoveArrayIndex(g_socket_array, g_index, i); RemoveArrayIndex(g_event_array, g_index, i); g_index--; &#125; else &#123; std::cout &lt;&lt; &quot;recv failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; closesocket(g_socket_array[i]); WSACloseEvent(g_event_array[i]); RemoveArrayIndex(g_socket_array, g_index, i); RemoveArrayIndex(g_event_array, g_index, i); g_index--; &#125; &#125; if (network_events.lNetworkEvents &amp; FD_WRITE) &#123; if (network_events.iErrorCode[FD_WRITE_BIT] != 0) &#123; std::cout &lt;&lt; &quot;FD_WRITE failed with code: &quot; &lt;&lt; network_events.iErrorCode[FD_WRITE_BIT] &lt;&lt; &quot; &quot;; break; &#125; &#125; if (network_events.lNetworkEvents &amp; FD_CLOSE) &#123; if (network_events.iErrorCode[FD_CLOSE_BIT] != 0) &#123; std::cout &lt;&lt; &quot;FD_CLOSE failed with code: &quot; &lt;&lt; network_events.iErrorCode[FD_CLOSE_BIT] &lt;&lt; &quot; &quot;; break; &#125; closesocket(g_socket_array[i]); WSACloseEvent(g_event_array[i]); RemoveArrayIndex(g_socket_array, g_index, i); RemoveArrayIndex(g_event_array, g_index, i); g_index--; &#125; &#125; &#125; // while &#125; while (false); // (6) for (int i = 0; i &lt;= g_index; i++) &#123; closesocket(g_socket_array[i]); WSACloseEvent(g_event_array[i]); &#125; WSACleanup(); return 0;&#125; 2.2 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;winsock2.h&gt;#include &lt;iostream&gt;#include &lt;assert.h&gt;#include &lt;vector&gt;using namespace std;#pragma comment(lib, &quot;Ws2_32.lib&quot;)const std::string kIP = &quot;127.0.0.1&quot;;const u_short kPort = 10001;HANDLE g_event;SOCKET g_socket;int main()&#123; WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); do &#123; // (1) g_socket = ::socket(AF_INET, SOCK_STREAM, 0); if (g_socket == INVALID_SOCKET) &#123; std::cout &lt;&lt; &quot;create socket failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; // (2) g_event = WSACreateEvent(); WSAEventSelect(g_socket, g_event, FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE); // (3) struct sockaddr_in addr = &#123; 0 &#125;; addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(kIP.c_str()); addr.sin_port = htons(kPort); if (connect(g_socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) &#123; int gle_err = WSAGetLastError(); if (gle_err != WSAEWOULDBLOCK) &#123; std::cout &lt;&lt; &quot;connect failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; &quot; &quot;; break; &#125; &#125; // (4) while (true) &#123; DWORD ret = WSAWaitForMultipleEvents(1, &amp;g_event, FALSE, WSA_INFINITE, FALSE); if (ret == WSA_WAIT_FAILED || ret == WSA_WAIT_TIMEOUT) &#123; continue; &#125; WSANETWORKEVENTS network_events; // WSAEnumNetworkEvent函数会将事件重置为无信号状态 WSAEnumNetworkEvents(g_socket, g_event, &amp;network_events); if (network_events.lNetworkEvents &amp; FD_CONNECT) &#123; if (network_events.iErrorCode[FD_CONNECT_BIT] != 0) &#123; std::cout &lt;&lt; &quot;FD_CONNECT failed with code: &quot; &lt;&lt; network_events.iErrorCode[FD_CONNECT_BIT] &lt;&lt; &quot; &quot;; break; &#125; std::cout &lt;&lt; &quot;connect to server &quot;; &#125; if (network_events.lNetworkEvents &amp; FD_READ) &#123; if (network_events.iErrorCode[FD_READ_BIT] != 0) &#123; std::cout &lt;&lt; &quot;FD_READ failed with code: &quot; &lt;&lt; network_events.iErrorCode[FD_READ_BIT] &lt;&lt; &quot; &quot;; break; &#125; char buf[100] = &#123; 0 &#125;; int err = recv(g_socket, buf, 100, 0); if (err &gt; 0) &#123; std::cout &lt;&lt; &quot;recv: &quot; &lt;&lt; buf &lt;&lt; std::endl; &#125; else if (err == 0) &#123; std::cout &lt;&lt; &quot;connection closed.&quot; &lt;&lt; std::endl; closesocket(g_socket); WSACloseEvent(g_event); &#125; else &#123; std::cout &lt;&lt; &quot;recv failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; closesocket(g_socket); WSACloseEvent(g_event); &#125; &#125; if (network_events.lNetworkEvents &amp; FD_WRITE) &#123; if (network_events.iErrorCode[FD_WRITE_BIT] != 0) &#123; std::cout &lt;&lt; &quot;FD_WRITE failed with code: &quot; &lt;&lt; network_events.iErrorCode[FD_WRITE_BIT] &lt;&lt; &quot; &quot;; break; &#125; &#125; if (network_events.lNetworkEvents &amp; FD_CLOSE) &#123; if (network_events.iErrorCode[FD_CLOSE_BIT] != 0) &#123; std::cout &lt;&lt; &quot;FD_CLOSE failed with code: &quot; &lt;&lt; network_events.iErrorCode[FD_CLOSE_BIT] &lt;&lt; &quot; &quot;; break; &#125; closesocket(g_socket); WSACloseEvent(g_event); &#125; &#125; // while &#125; while (false); // (5) closesocket(g_socket); WSACloseEvent(g_event); WSACleanup(); return 0;&#125;","tags":["套接字I/O模型"],"categories":["网络编程"]},{"title":"Windows套接字I/O模型(3)-WSAAsyncSelect模型","path":"/post/2544551173.html","content":"一、WSAAsyncSelect模型介绍利用 WSAAsyncSelect 模型结合 Windows 窗口消息循环，应用程序可以在一个套接字上接收以 Windows 消息为基础的网络事件通知。 在使用 WSAAsyncSelect 模型之前，首先需要创建一个 Windows 窗口，并为该窗口提供一个窗口过程支持函数（WndProc）。 函数原型如下： 123456int WSAAsyncSelect( _In_ SOCKET s, _In_ HWND hWnd, _In_ unsigned int wMsg, _In_ long lEvent); 参数解释： s指定套接字。 hWnd指定一个窗口句柄，它表示网络事件发生之后，用来接收消息通知的那个窗口。 wMsg表示在网络事件发生时，窗口收到的消息。 lEvent代表一个掩码，指定应用程序感兴趣的网络事件，只有这些网络事件发生时才会发送 wMsg 到 hWnd 窗口。 事件类型包括：FD_READ，FD_WRITE，FD_CLOSE，FD_CONNECT，FD_ACCEPT。 对于FD_CONNECT，FD_ACCEPT，服务端一般使用 FD_ACCEPT，客户端一般使用FD_CONNECT。 若将lEvent设置为0，则表示停止接收该套接字上的所有网络事件通知。 一旦调用WSAAsyncSelect函数在套接字上启用了事件通知，除非明确调用closesocket，或者再次调用WSAAsyncSelect重新设置网络事件类型，否则，事件通知将总是有效的。 由于WSAAsyncSelect模型需要结合Windows窗口来使用，因此不适那些没有界面的服务程序，可以使用WSAEventSelect模型来代替。 二、示例因为重点不在界面编程上面，所以示例中使用TraceMsgA函数打印信息到Visual Studio输出窗口或 Debugview。 TraceMsgA 只是对 OutputDebugStringA 的简单封装。 示例中的 InitWindow 函数用于创建一个简单的、空白的窗口，将句柄存储在全局变量g_hwnd中，WndProc为该窗口的处理过程函数。 服务端在有新的客户端连接上时，给客户端发送“hello, I’m server.”消息，而且服务端在退出时，会主动关闭所有的客户端连接。 客户端连接上服务端之后，将接收来自服务端的消息。 2.1 服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &lt;winsock2.h&gt;#include &lt;vector&gt;#include &lt;strsafe.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)const u_short kPort = 10001;const std::string kHelloServer = &quot;hello, I&#x27;m server.&quot;;#define WUM_SOCKET (WM_USER+1)HWND g_hwnd;SOCKET socket_srv = INVALID_SOCKET;std::vector&lt;SOCKET&gt; clients;void TraceMsgA(const char *lpFormat, ...) &#123; if (!lpFormat) return; char *pMsgBuffer = NULL; unsigned int iMsgBufCount = 0; va_list arglist; va_start(arglist, lpFormat); HRESULT hr = STRSAFE_E_INSUFFICIENT_BUFFER; while (hr == STRSAFE_E_INSUFFICIENT_BUFFER) &#123; iMsgBufCount += 1024; if (pMsgBuffer) &#123; free(pMsgBuffer); pMsgBuffer = NULL; &#125; pMsgBuffer = (char*)malloc(iMsgBufCount * sizeof(char)); if (!pMsgBuffer) &#123; break; &#125; hr = StringCchVPrintfA(pMsgBuffer, iMsgBufCount, lpFormat, arglist); &#125; va_end(arglist); if (hr == S_OK) &#123; OutputDebugStringA(pMsgBuffer); &#125; if (pMsgBuffer) &#123; free(pMsgBuffer); pMsgBuffer = NULL; &#125;&#125;LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; int err; SOCKET s; char buf[100] = &#123; 0 &#125;; switch (message) &#123; // (5) case WUM_SOCKET: if (WSAGETSELECTERROR(lParam)) &#123; closesocket((SOCKET)wParam); break; &#125; switch (WSAGETSELECTEVENT(lParam)) &#123; case FD_ACCEPT: s = accept((SOCKET)wParam, NULL, NULL); clients.push_back(s); WSAAsyncSelect(s, g_hwnd, WUM_SOCKET, FD_READ | FD_WRITE | FD_CLOSE); TraceMsgA(&quot;new connection &quot;); err = send(s, (const char*)kHelloServer.c_str(), kHelloServer.length(), 0); if (err == SOCKET_ERROR) &#123; TraceMsgA(&quot;send failed, GLE: %d &quot;, WSAGetLastError()); break; &#125; break; case FD_READ: err = recv((SOCKET)wParam, buf, 100, 0); if (err &gt; 0) &#123; TraceMsgA(&quot;recv: %s &quot;, buf); &#125; else if (err == 0) &#123; TraceMsgA(&quot;connection closed &quot;); closesocket((SOCKET)wParam); &#125; else &#123; TraceMsgA(&quot;recv failed, GLE: %d &quot;, WSAGetLastError()); closesocket((SOCKET)wParam); &#125; break; case FD_WRITE: break; case FD_CLOSE: closesocket((SOCKET)wParam); for (std::vector&lt;SOCKET&gt;::iterator it = clients.begin(); it != clients.end(); it++) &#123; if (*it == (SOCKET)wParam) &#123; clients.erase(it); break; &#125; &#125; break; &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;void InitWindow(HINSTANCE hInstance) &#123; WCHAR szWindowClass[100] = L&quot;Test&quot;; WNDCLASSEX wcex = &#123; sizeof(WNDCLASSEX) &#125;; wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.lpszClassName = szWindowClass; RegisterClassExW(&amp;wcex); g_hwnd = CreateWindowW(szWindowClass, L&quot;server&quot;, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (g_hwnd) &#123; ShowWindow(g_hwnd, SW_SHOW); UpdateWindow(g_hwnd); &#125;&#125;int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); InitWindow(hInstance); WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); do &#123; // (1) socket_srv = ::socket(AF_INET, SOCK_STREAM, 0); if (socket_srv == INVALID_SOCKET) &#123; TraceMsgA(&quot;create socket failed, GLE: %d &quot;, WSAGetLastError()); break; &#125; // (2) struct sockaddr_in addr = &#123; 0 &#125;; addr.sin_family = AF_INET; addr.sin_addr.s_addr = htonl(INADDR_ANY); addr.sin_port = htons(kPort); if (bind(socket_srv, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) &#123; TraceMsgA(&quot;bind failed, GLE: %d &quot;, WSAGetLastError()); break; &#125; // (3) WSAAsyncSelect(socket_srv, g_hwnd, WUM_SOCKET, FD_ACCEPT | FD_READ | FD_WRITE | FD_CLOSE); // (4) if (listen(socket_srv, 5) == SOCKET_ERROR) &#123; TraceMsgA(&quot;listen failed, GLE: %d &quot;, WSAGetLastError()); break; &#125; TraceMsgA(&quot;listen on port: %d &quot;, kPort); &#125; while (false); MSG msg; while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; for (std::vector&lt;SOCKET&gt;::iterator it = clients.begin(); it != clients.end(); it++) &#123; closesocket(*it); &#125; // (6) closesocket(socket_srv); WSACleanup(); return 0;&#125; 2.2 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include &lt;winsock2.h&gt;#include &lt;vector&gt;#include &lt;strsafe.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)const std::string kIP = &quot;127.0.0.1&quot;;const u_short kPort = 10001;#define WUM_SOCKET (WM_USER+1)HWND g_hwnd;void TraceMsgA(const char *lpFormat, ...) &#123; if (!lpFormat) return; char *pMsgBuffer = NULL; unsigned int iMsgBufCount = 0; va_list arglist; va_start(arglist, lpFormat); HRESULT hr = STRSAFE_E_INSUFFICIENT_BUFFER; while (hr == STRSAFE_E_INSUFFICIENT_BUFFER) &#123; iMsgBufCount += 1024; if (pMsgBuffer) &#123; free(pMsgBuffer); pMsgBuffer = NULL; &#125; pMsgBuffer = (char*)malloc(iMsgBufCount * sizeof(char)); if (!pMsgBuffer) &#123; break; &#125; hr = StringCchVPrintfA(pMsgBuffer, iMsgBufCount, lpFormat, arglist); &#125; va_end(arglist); if (hr == S_OK) &#123; OutputDebugStringA(pMsgBuffer); &#125; if (pMsgBuffer) &#123; free(pMsgBuffer); pMsgBuffer = NULL; &#125;&#125;LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; int err; SOCKET s; char buf[100] = &#123; 0 &#125;; switch (message) &#123; // (4) case WUM_SOCKET: if (WSAGETSELECTERROR(lParam)) &#123; closesocket((SOCKET)wParam); TraceMsgA(&quot;connect failed, %d &quot;, WSAGETSELECTERROR(lParam)); break; &#125; switch (WSAGETSELECTEVENT(lParam)) &#123; case FD_CONNECT: TraceMsgA(&quot;connection to server &quot;); break; case FD_READ: err = recv((SOCKET)wParam, buf, 100, 0); if (err &gt; 0) &#123; TraceMsgA(&quot;recv: %s &quot;, buf); &#125; else if (err == 0) &#123; closesocket((SOCKET)wParam); TraceMsgA(&quot;connection closed &quot;); &#125; else &#123; closesocket((SOCKET)wParam); TraceMsgA(&quot;recv failed, GLE: %d &quot;, WSAGetLastError()); &#125; break; case FD_WRITE: break; case FD_CLOSE: closesocket((SOCKET)wParam); TraceMsgA(&quot;connection closed &quot;); break; &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;void InitWindow(HINSTANCE hInstance) &#123; WCHAR szWindowClass[100] = L&quot;Test&quot;; WNDCLASSEX wcex = &#123; sizeof(WNDCLASSEX) &#125;; wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.lpszClassName = szWindowClass; RegisterClassExW(&amp;wcex); g_hwnd = CreateWindowW(szWindowClass, L&quot;client&quot;, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (g_hwnd) &#123; ShowWindow(g_hwnd, SW_SHOW); UpdateWindow(g_hwnd); &#125;&#125;int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); InitWindow(hInstance); WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket_ = INVALID_SOCKET; do &#123; // (1) socket_ = ::socket(AF_INET, SOCK_STREAM, 0); if (socket_ == INVALID_SOCKET) &#123; TraceMsgA(&quot;create socket failed, GLE: %d &quot;, WSAGetLastError()); break; &#125; // (2) WSAAsyncSelect(socket_, g_hwnd, WUM_SOCKET, FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE); // (3) struct sockaddr_in addr = &#123; 0 &#125;; addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(kIP.c_str()); addr.sin_port = htons(kPort); if (connect(socket_, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) &#123; int gle_err = WSAGetLastError(); if (gle_err != WSAEWOULDBLOCK) &#123; TraceMsgA(&quot;connect failed, GLE: %d &quot;, WSAGetLastError()); break; &#125; &#125; &#125; while (false); MSG msg; while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; // (5) closesocket(socket_); WSACleanup(); return 0;&#125; 代码下载地址: https://github.com/winsoft666/CodeSnippet/tree/main/WSAAsyncSelect-Sample","tags":["套接字I/O模型"],"categories":["网络编程"]},{"title":"Windows套接字I/O模型(2)-Select模型","path":"/post/640627104.html","content":"一、Select模型介绍套接字Select模型的中心思想是利用 select 函数实现对I&#x2F;O的管理。 可以利用select函数判断一个或多个套接字上是否存在待接收数据，或者能否向一个或多个套接字发送数据。 select函数是同步的，也会阻塞，但和阻塞模型不同的是，Select模型可以同时管理多个套接字。 select函数原型如下： 1234567int select ( int nfds, fd_set FAR * readfds, fd_set FAR * writefds, fd_set FAR * exceptfds, const struct timeval FAR * timeout ); 第一个参数nfds会被忽略。之所以仍然要提供这个参数，只是为了保持与早期的Berkeley套接字应用程序的兼容。 三个fd_set参数：一个用于检查可读性（readfds），一个用于检查可写性（writefds），另一个用于例外数据（ excepfds）。 从本质上说，fd_set数据类型代表着一系列特定套接字的集合。 其中，readfds集合包括符合下述任何一个条件的套接字： 有数据可以读入。 连接已经关闭、重置或中止。(可以用来判断客户端或服务端程序是否退出了) 假如已经调用了listen，而且一个连接正在等待中，那么accept函数调用成功。 writefds集合包括符合下述任何一个条件的套接字： 有数据可以发出。 如果正在处理一个非阻塞的connect操作，则连接成功。 最后，exceptfds集合包括符合下述任何一个条件的套接字： 假如已完成了对一个非阻塞连接调用的处理，连接尝试就会失败。 有带外（out-of-band，OOB）数据可供读取。 例如，假定我们想测试一个套接字是否“可读”，必须将自己的套接字增添到readfds集合，再等待select函数完成。select完成之后，必须判断自己的套接字是否仍为readfds集合的一部分。若答案是肯定的，便表明该套接字“可读”，可立即着手从它上面读取数据。在三个参数中（readfds、writedfss和exceptfds），至少有一个不能为空值！在任何不为空的集合中，必须包含至少一个套接字句柄；否则，select函数便没有任何东西可以等待。 最后一个参数timeout对应的是一个指针，它指向一个timeval结构，用于设置select最多等待的时间。如timeout是一个空指针，那么select调用会无限期地“锁定”下去，直到至少有一个描述符符合指定的条件后结束。 对timeval结构的定义如下： 1234struct timeval &#123; long tv_sec; long tv_usec;&#125; ; 若将超时值设置为(0,0)，表明select会立即返回，允许应用程序对select操作进行“轮询”。出于对性能方面的考虑，应避免这样的设置。 select成功完成后，会在fd_set结构中，返回刚好有未完成的I&#x2F;O操作的所有套接字句柄的总量。若超过timeval设定的时间，便会返回0。不管由于什么原因，假如select调用失败，都会返回SOCKET_ERROR。用select对套接字进行监视之前，在自己的应用程序中，必须将套接字句柄分配给一个集合，设置好一个或全部读、写以及例外fd_set结构。将一个套接字分配给任何一个集合后，再来调用select，便可知道一个套接字上是否正在发生上述的I&#x2F;O活动。 Winsock提供下列宏对fd_set进行处理与检查： 1234FD_CLR(s, *set); 从set中删除套接字s。FD_ISSET(s, *set); 检查s是否set集合的一名成员；返回TRUE或FALSE。FD_SET(s, *set); 将套接字s加入集合set。FD_ZERO(*set); 将set初始化成空集合。 二、示例2.1 服务端服务端代码比之前介绍的“阻塞模型”中的示例稍微复杂一点。 提供如下功能： 管理多个客户端的连接。 对每个新连接的客户端发送“Hello，I’m server”信息。 在客户端程序退出时自动关闭连接等功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;winsock2.h&gt;#include &lt;iostream&gt;#include &lt;assert.h&gt;#include &lt;vector&gt;using namespace std;#pragma comment(lib, &quot;Ws2_32.lib&quot;)const u_short kPort = 10001;const std::string kHelloServer = &quot;hello, I&#x27;m server.&quot;;int main()&#123; WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket_ = INVALID_SOCKET; std::vector&lt;SOCKET&gt; clients; do &#123; // (1) socket_ = ::socket(AF_INET, SOCK_STREAM, 0); if (socket_ == INVALID_SOCKET) &#123; std::cout &lt;&lt; &quot;create socket failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; // (2) struct sockaddr_in addr = &#123; 0 &#125;; addr.sin_family = AF_INET; addr.sin_addr.s_addr = htonl(INADDR_ANY); addr.sin_port = htons(kPort); if (bind(socket_, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;bind failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; // (3) if (listen(socket_, 5) == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;listen failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; std::cout &lt;&lt; &quot;listen on port: &quot; &lt;&lt; kPort &lt;&lt; std::endl; fd_set fd_read; while (true) // TODO 未处理何时退出的问题 &#123; // (4) FD_ZERO(&amp;fd_read); FD_SET(socket_, &amp;fd_read); for (std::vector&lt;SOCKET&gt;::iterator it = clients.begin(); it != clients.end(); ++it) FD_SET(*it, &amp;fd_read); // (5) timeval timeout = &#123; 3, 0 &#125;; int ret = select(0, &amp;fd_read, NULL, NULL, &amp;timeout); if (ret == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;select failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; // (6.1) // 检查服务端的监听socket，是否有新的连接等待建立 if (FD_ISSET(socket_, &amp;fd_read)) &#123; // (7.1) struct sockaddr_in addr_c = &#123; 0 &#125;; int addr_len = sizeof(addr_c); SOCKET s = accept(socket_, reinterpret_cast&lt;sockaddr*&gt;(&amp;addr_c), &amp;addr_len); if (s == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;accept failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; &#125; else &#123; clients.push_back(s); std::cout &lt;&lt; &quot;new connection&quot; &lt;&lt; std::endl; int left = kHelloServer.length(); int idx = 0; while (left &gt; 0) &#123; int err = send(s, (const char*)(kHelloServer.c_str() + idx), left, 0); if (err == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;send failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; left -= err; idx += err; std::cout &lt;&lt; &quot;bytes sent: &quot; &lt;&lt; err &lt;&lt; std::endl; &#125; &#125; &#125; // (6.2) // 检查与客户端连接的socket，是否有数据可以读入 for (std::vector&lt;SOCKET&gt;::iterator it = clients.begin(); it != clients.end(); ) &#123; if (FD_ISSET(*it, &amp;fd_read)) &#123; // (7.2) char buf[100] = &#123; 0 &#125;; int err = recv(*it, buf, 100, 0); if (err &gt; 0) &#123; std::cout &lt;&lt; &quot;recv: &quot; &lt;&lt; buf &lt;&lt; std::endl; ++it; &#125; else if (err == 0) &#123; std::cout &lt;&lt; &quot;connection closed.&quot; &lt;&lt; std::endl; closesocket(*it); it = clients.erase(it); &#125; else &#123; std::cout &lt;&lt; &quot;recv failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; closesocket(*it); it = clients.erase(it); &#125; &#125; else &#123; ++it; &#125; &#125; &#125; // while &#125; while (false); // (8) for (std::vector&lt;SOCKET&gt;::iterator it = clients.begin(); it != clients.end(); ++it) &#123; closesocket(*it); &#125; // (9) closesocket(socket_); WSACleanup(); return 0;&#125; 2.2 客户端客户端在连接上服务端之后，便可以不间断地接收来自服务端的消息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;winsock2.h&gt;#include &lt;iostream&gt;#include &lt;assert.h&gt;#include &lt;vector&gt;using namespace std;#pragma comment(lib, &quot;Ws2_32.lib&quot;)const std::string kIP = &quot;127.0.0.1&quot;;const u_short kPort = 10001;const std::string kHelloClient = &quot;hello, I&#x27;m client.&quot;;int main()&#123; WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket_ = INVALID_SOCKET; do &#123; // (1) socket_ = ::socket(AF_INET, SOCK_STREAM, 0); if (socket_ == INVALID_SOCKET) &#123; std::cout &lt;&lt; &quot;create socket failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; // (2) struct sockaddr_in addr = &#123; 0 &#125;; addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(kIP.c_str()); addr.sin_port = htons(kPort); if (connect(socket_, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;connect failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; fd_set fd_read; while (true) // TODO 未处理何时退出的问题 &#123; // (3) FD_ZERO(&amp;fd_read); FD_SET(socket_, &amp;fd_read); // (4) timeval timeout = &#123; 3, 0 &#125;; int ret = select(0, &amp;fd_read, NULL, NULL, &amp;timeout); if (ret == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;select failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; // (5) if (FD_ISSET(socket_, &amp;fd_read)) &#123; char buf[100] = &#123; 0 &#125;; int err = recv(socket_, buf, 100, 0); if (err &gt; 0) &#123; std::cout &lt;&lt; &quot;recv: &quot; &lt;&lt; buf &lt;&lt; std::endl; &#125; else if (err == 0) &#123; std::cout &lt;&lt; &quot;connection closed.&quot; &lt;&lt; std::endl; break; &#125; else &#123; std::cout &lt;&lt; &quot;recv failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; &#125; &#125; // while &#125; while (false); // (6) closesocket(socket_); WSACleanup(); return 0;&#125;","tags":["套接字I/O模型"],"categories":["网络编程"]},{"title":"Windows套接字I/O模型(1)-阻塞模型","path":"/post/2937580891.html","content":"套接字I&#x2F;O的阻塞模型是最常见的网络模型，也是在网络编程中最早接触的一个模型。因为它是阻塞的，所以我们一般都会结合线程一起使用，如将accept，recv等操作放到单独的线程，避免程序主线程被阻塞。 下面的示例为了演示阻塞模型使用的基本流程没有将其放入到独立的线程中。 一、服务端服务端大致流程: 创建Socket Bind端口 开始Listen accept客户端连接（一般在子线程中不间断accept） send数据到客户端（也可以recv） close socket 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;winsock2.h&gt;#include &lt;iostream&gt;#include &lt;assert.h&gt;using namespace std;#pragma comment(lib, &quot;Ws2_32.lib&quot;)const u_short kPort = 10001;const std::string kHelloServer = &quot;hello, I&#x27;m server.&quot;;int main()&#123; WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket_ = INVALID_SOCKET; SOCKET s_ = INVALID_SOCKET; do &#123; // (1) socket_ = ::socket(AF_INET, SOCK_STREAM, 0); if (socket_ == INVALID_SOCKET) &#123; std::cout &lt;&lt; &quot;create socket failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; // (2) struct sockaddr_in addr = &#123; 0 &#125;; addr.sin_family = AF_INET; addr.sin_addr.s_addr = htonl(INADDR_ANY); addr.sin_port = htons(kPort); if (bind(socket_, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;bind failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; // (3) if (listen(socket_, 5) == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;listen failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; std::cout &lt;&lt; &quot;listen on port: &quot; &lt;&lt; kPort &lt;&lt; std::endl; // (4) while (true) &#123; struct sockaddr_in addr_c = &#123; 0 &#125;; int addr_len = sizeof(addr_c); SOCKET s = accept(socket_, reinterpret_cast&lt;sockaddr*&gt;(&amp;addr_c), &amp;addr_len); if (s == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;accept failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; std::cout &lt;&lt; &quot;new connection&quot; &lt;&lt; endl; // (5) // 此处使用while循环send，详见 三、流协议 int left = kHelloServer.length(); int idx = 0; while (left &gt; 0) &#123; int err = send(s, (const char*)(kHelloServer.c_str() + idx), left, 0); if (err == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;send failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; left -= err; idx += err; std::cout &lt;&lt; &quot;bytes sent: &quot; &lt;&lt; err &lt;&lt; std::endl; &#125; &#125; &#125; while (false); // (6) closesocket(socket_); closesocket(s_); WSACleanup(); return 0;&#125; 二、客户端客户端大致流程： 创建Socket connect服务端 recv接收数据从服务端(也可以send) close socket 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;winsock2.h&gt;#include &lt;assert.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)const std::string kIP = &quot;127.0.0.1&quot;;const u_short kPort = 10001;const std::string kHelloClient = &quot;hello, I&#x27;m client.&quot;;int main()&#123; WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 2); WSAStartup(wVersionRequested, &amp;wsaData); SOCKET socket_ = INVALID_SOCKET; do &#123; // (1) socket_ = ::socket(AF_INET, SOCK_STREAM, 0); if (socket_ == INVALID_SOCKET) &#123; std::cout &lt;&lt; &quot;create socket failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; // (2) struct sockaddr_in addr = &#123; 0 &#125;; addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(kIP.c_str()); addr.sin_port = htons(kPort); if (connect(socket_, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr)) == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;connect failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; // (3) char buf[100] = &#123; 0 &#125;; int err = recv(socket_, buf, 100, 0); if (err &gt; 0) &#123; std::cout &lt;&lt; &quot;recv: &quot; &lt;&lt; buf &lt;&lt; std::endl; &#125; else if (err == 0) &#123; std::cout &lt;&lt; &quot;connection closed.&quot; &lt;&lt; std::endl; break; &#125; else &#123; std::cout &lt;&lt; &quot;recv failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; &#125; while (false); // (4) closesocket(socket_); WSACleanup(); return 0;&#125; 三、流协议由于大多数面向连接的协议（如TCP）也是流协议。在流协议中，发送者和接收者可以将数据分解成小块数据，也可以将数据合并成大块数据。对于流套接字上收发数据所有用的函数（如send, recv），都不能保证一定按照指定的数据量进行读取或写入。 比如用send发送一个有1024字节的字符缓冲区时，send函数可能返回的已发出的字节数少于1024。 针对这种情况，要保证缓冲区所有数据都被发送出去，可以采用下面的代码： 1234567891011121314int left = kHelloServer.length();int idx = 0;while (left &gt; 0) &#123; int err = send(s, (const char*)(kHelloServer.c_str() + idx), left, 0); if (err == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;send failed, GLE: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; std::endl; break; &#125; left -= err; idx += err; std::cout &lt;&lt; &quot;bytes sent: &quot; &lt;&lt; err &lt;&lt; std::endl;&#125; 对于接收数据来说，我们一般也都是循环的、不间断的接收数据，很少有上面第二节例子中的，只接收一次的情况。如何确保接收到一个完整的、符合特定格式的数据包，这是需要考虑的问题。","tags":["套接字I/O模型"],"categories":["网络编程"]},{"title":"Linux GDB调试命令","path":"/post/2824175441.html","content":"一、启动GDBgdb -tui：分屏显示源代码gdb -q：不显示开始的提示信息 可以在.bashrc中加入别名： 1alias gdb=&quot;gdb -q -tui&quot; 二、开始调试执行run（需要提前设置断点），也可以在调试过程中重新运行调试的程序，run后可以跟随发给该程序的任何参数。 三、常用命令 命令 功能 list（简写l） 显示当前行前面和后面的10行代码 list n1 n2 显示n1到行和n2行之间的代码 list main 显示main函数代码 info functions regex 列出符合正则表达式的函数名称 info breakpoints（简写info b） 查看当前所有的断点信息（断点号，断点类型，断点位置） break func 在当前文件的func函数处设置断点 break fileName:N 在某文件的第N行处设置断点，当前文件第N行设置断点可以忽略fileName break func(或fileName:N) if exp 条件断点，exp成立则断点 delete N 删除第N号断点 delete 删除所有断点 clear N 清除第N行上的断点 watch exp exp成立程序停住 next（简写n） 单步执行，遇到函数会跳过 next N 执行N次单步执行 step（简写s) 单步执行，遇到函数会进入 finish 执行完当前函数，返回到调用它的位置 continue 运行到下一个断点处 until（简写u） 鼠标放到代码行，运行到该代码行停止 jump N 跳转到第N行开始执行，不会主动在N行停住 run 重新运行调试的程序，可以带参数 [Enter] 直接回车执行上次执行的命令 print var（简写p） 查看变量var的值 print &#x2F;x var 按16进制格式显示变量值 ptype var 查看变量var的结构或类型 backtrach 查看调用堆栈 四、多进程调试在调试多进程程序时GDB默认只会调试主进程，但是GDB（&gt;V7.0）支持对多进程分别或同时调试。换句话说，GDB可以同时调试多个程序。只需要设置follow-fork-mode(默认值：parent)和detach-on-fork（默认值：on）即可。 follow-fork-mode detach-on-fork 说明 parent on 只调试主进程（GDB默认） child on 只调试子进程 parent off 同时调试两个进程，gdb跟主进程，子进程block在fork位置 child off 同时调试两个进程，gdb跟子进程，主进程block在fork位置 设置方法：set follow-fork-mode [parent|child] set detach-on-fork [on|off] 查询正在调试的进程：info inferiors 切换调试的进程： inferior 添加新的调试进程： add-inferior [-copies n] [-exec executable] ,可以用file executable来分配给inferior可执行文件。 其他：remove-inferiors infno， detach inferior","tags":["GDB"],"categories":["软件调试"]},{"title":"拨开字符编码的迷雾(4)--MySQL字符编码","path":"/post/1559270845.html","content":"一、MySQL 字符集和校对规则MySQL 的字符集是用来定义 MySQL 存储字符串的方式，校对规则（有的软件叫排序规则）则是用来定义了比较字符串的方式。 字符集和校对规则是一对多的关系。每种字符集都有一个默认校对规则。 查看数据库支持的字符集: 123456# 方法1：SHOW CHARACTER SET;# 方法2：USE information_schema;SELECT * FROM CHARACTER_SETS; 查看数据库支持的校对规则： 123456# 方法1：SHOW COLLATION;# 方法2：USE information_schema;SELECT * FROM collations; 二、MySQL 各个级别字符集MySQL 可以对如下字符集进行设置： 服务器级字符集（CHARACTER_SET_SERVER） 数据库级字符集（CHARACTER_SET_DATABASE） 表级字符集 字段级字符集 连接字符集（CHARACTER_SET_CONNECTION），客户端连接数据库所用的字符集。 结果字符集（CHARACTER_SET_RESULTS），存储查询结果（含错误信息）所用的字符集。 客户端字符集（CHARACTER_SET_CLIENT），客户端发送给 MySQL 服务器的查询语句字符集。 系统字符集（CHARACTER_SET_SYSTEM），用于存储我们新建的或自带的数据库的表、列的名称，默认是 UTF-8。 服务器级、数据库级、表级、字段级 这 4 个字符集设置影响到数据库中存储数据的编码。 这 4 个级别的字符集继承关系为：服务器级 --&gt; 数据库级 --&gt; 表级 --&gt; 字段级, 从左到右，一级继承一级，和 C++、Java 中的类的继承类似，如果某一级未显式的指定字符集，那么将继承上一级的字符集设置。 2.1 服务器级别字符集设置服务器级别的字符集可以从下面几个地方指定，从上到下优先级依次增加： 编译 MySQL 时指定的字符集 my.cnf 配置文件设置 character-set-server mysqld 服务启动命令行中指定字符集 影响数据存储的字符集之间的关系： 查看当前数据库的字符集设置： 123456# 方法1：SHOW VARIABLES LIKE &#x27;%character%&#x27;;# 方法2：USE information_schema;SELECT * FROM GLOBAL_VARIABLES WHERE VARIABLE_NAME LIKE &#x27;%character%&#x27;; 三、utf8 与 utf8mb4 区别UTF-8 是多字节编码方案，采用 1~4 个字节来存储一个字符，但在 MySQL 设计之初，一个字符最多采用 3 个字节的就可以存储，所以 Mysql 的设计者将 MySQL 中的 UTF-8 字符集（UTF-8 其实不是字符集，是字符编码方案，但在 MySQL 中一直这么叫）设计成了最大长度只能为 3. 如图： 但随着 Unicode 字符集的扩张，出现了需要 4 个字节才能存储的字符，如果这时仍然使用 utf-8（指 mysql 中的 3 字节 utf-8）来存储这些字符就会出现错误，如执行INSERT INTO member(memberName)VALUES(&#39;𤭢&#39;)报错如下： 12Warning Code : 1366Incorrect string value: &#x27;\\xF0\\xA4\\xAD\\xA2&#x27; for column &#x27;memberName&#x27; at row 1 于是 MySQL 后来新增了 utf8mb4 字符集，最大长度为 4，兼容之前的 utf8，但为了之前的数据库不报错，仍然保留了之前的 utf8 字符集。 所以 MySQL 中的 UTF-8 字符集是伪 UTF-8，现在需要使用 utf8mb4。 四、完全避免字符乱码要完全避免字符乱码，最简单也是最好的方法就是将各个字符集保持一致，可以都设置为 utf8mb4。 Mysql 数据存储所涉及到的 4 个字符集的设置可以使用第二节的方法进行设置，客户端字符集、连接字符集，结果字符集关系到数据显示的正确性，可以使用如下语句统一设置为 utf8mb4，但这个设置只针对当前连接有效： 1set names utf8mb4; 编程开发中，一般使用 MySQL API 进行数据连接、查询等操作，可以使用mysql_set_character_set对每个连接进行设置，这个 API 会将客户端字符集、连接字符集，结果字符集都设置为指定字符集，代码大致如下： 123MYSQL* pMysql = NULL;mysql_real_connect(pMysql, szHost, szUser, szPwd, szDatabase, iPort, NULL, CLIENT_MULTI_STATEMENTS);mysql_set_character_set(pMysql, &quot;utf8mb4&quot;); 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["MySQL","字符编码"],"categories":["MySQL"]},{"title":"拨开字符编码的迷雾(2)--编译器处理文件编码","path":"/post/1337290471.html","content":"本文主要介绍微软 MSVC 编译器如何加载和处理 C++代码文件。 一. Visual Studio 字符集虽然使用 Visual Studio 创建的 C++工程可以在工程属性配置属性--&gt;常规中配置字符集：使用Unicode字符集（默认）、使用多字节字符集。 如图： 但这个设置项并不会对编译器处理字符编码产生直接的影响（注意这里的“直接”二字，第 3 节会说到），只会在工程属性配置属性--&gt;C/C++--&gt;预处理器加入相应的宏： 12使用Unicode字符集 --&gt; _UNICODE和UNICODE宏使用多字节字符集 --&gt; _MBCS宏 这几个宏一般用来判断是使用 char 还是 wchar_t，在系统 API 中使用比较多，如 MessegeBox 通过判断是否定义了 UNICODE 宏来决定是使用 LPCSTR 还是 LPCWSTR（LPCSTR 即 const char*, LPCWSTR 即 const wchar_t*）： 12345#ifdef UNICODE#define MessageBox MessageBoxW#else#define MessageBox MessageBoxA#endif // !UNICODE 二. char 和 wchar_t上面提到了，定义 API 时通过 UNICODE 宏来决定是使用 char 还是 wchar_t 类型，那么 char 和 wchar_t 有什么不同了？ char 和 wchar_t 是标准 C&#x2F;C++字符类型，并不是 Windows 特有的。 char 固定占 1 个字节，wchar_t 固定占 2 个字节，从内存的角度来看，char、wchar_t 和其他数据类型一样，只是代表一段内存块，用来存储固定长度的二进制 0 或 1。 在编程时，我们一般习惯于将字符串储到 char 或 wchar_t 定义的内存空间中，将整形存储在 int 定义的内存空间中。 所以，用 char 还是 wchar_t 来存储字符，只是内存分配和数据存储上面的事情，它们本身也是与字符编码无直接关系的（ 同样注意这里的“直接”二字，第 3 节会说到）。 三. 编译器如何处理硬编码字符MSVC 编译器编译源代码的步骤中，涉及编码处理的步骤主要有 2 个： 第 1 步：预处理 1.1) 读取源文件，判断源文件采用的字符编码类型。(这一步不会改变文件内容) 1234编译器判断源文件编码类型的步骤为：1. 若文件开始处有BOM (EF BB BF)，则判定为 UTF-8 编码；2. 若没有BOM，则试图从文件的前 8 个字节来判断文件是否像 UTF-16 编码，如果像，则就判断为 UTF-16 编码。3. 如果既没BOM，也不是UTF-16编码，则使用系统当前的代码页（简体中文操作系统为CP936）。 1.2) 将源文件内容转成源字符集(Source Character Set)，默认为 UTF-8 编码。 第 2 步：链接 2.1) 将 1.2 中得到的 UTF-8 转为执行字符集(Execution Character Set)： 对于宽字符串（wchar_t类型），执行字符集为 UTF-16 编码。 对于窄字符串（char类型），执行字符集为系统当前的代码页。 到现在我们彻底明白了 Visual Studio 字符集设置、char、wchar*t 是如何***间接_**影响到编译器对字符编码的处理了： 1234567Visual Studio字符集设置 |决定声明哪一个宏（UNICODE还是_MBCS宏） |宏又决定了API参数使用char还是wchar_t |编译器在进行【执行字符集】编码时对char和wchar_采用不同的处理方式，从而对字符编码产生了影响。 在 Visual Studio 2010（含）之后，可以在代码中使用#pragma execution_character_set来设置执行字符集： 12// 执行字符集设置为utf8#pragma execution_character_set(&quot;utf-8&quot;) 也可以在Visual Studio项目属性中（“配置属性”&gt;“C&#x2F;C++”&gt;“命令行”）中，通过/source-charset:utf-8 和 /execution-charset:utf-8 来分别设置源字符集和可执行字符集为utf-8。 四. 实例分析已知汉字“中”的各种编码如下： 123GBK D6 D0Unicode 2D 4EUTF-8 E4 B8 AD 函数DumpCharacterCode用于按字节打印内存中的数据： 1234567void DumpCharacterCode(const char* pChar, int iSize) &#123; for(int i = 0; i &lt; iSize; i++) &#123; char a = *pChar++; printf(&quot;%02X &quot;, a &amp; 0xff); &#125; printf(&quot; &quot;);&#125; 设置系统代码页的方法： “控制面板” –&gt; “区域和语言” –&gt; “管理” –&gt; “非 Unicode 程序的语言” –&gt; “更改系统区域设置”。 Visual Studio 保存文件到指定编码方法：“文件” –&gt; “高级保存选项”。 4.1 测试编译器处理窄字符编码测试代码如下： 12345678int _tmain(int argc, _TCHAR* argv[])&#123; char buf[100] = &#123;&quot;中&quot;&#125;; // char DumpCharacterCode(buf, 2); // 也可以打印4个字节 return 0;&#125; 针对不同的系统代码页和源文件编码，打印出的汉字“中”的编码分别为： 测试用例 系统代码页 保存源文件编码 编译器判断文件采用的编码 源字符集(Source Character Set) 执行字符集(Execution Character Set) 打印输出 用例 1 简体中文 CP936 简体中文 CP936 简体中文 CP936 UTF-8 简体中文 CP936 D6 D0 用例 2 简体中文 CP936 UTF-8 BOM UTF-8 BOM UTF-8 简体中文 CP936 D6 D0 用例 3 简体中文 CP936 UTF-8 简体中文 CP936 UTF-8 简体中文 CP936 编译错误(C2146) 用例 4 西欧 CP1252 简体中文 CP936 西欧 CP1252 UTF-8 西欧 CP1252 D6 D0 用例 5 西欧 CP1252 UTF-8 BOM UTF-8 BOM UTF-8 西欧 CP1252 3F 00 表格中列 4~6 依次对应编译处理源文件的几个步骤。3F对应的 ASCII 字符为?，编译器遇到不能识别的字符时，就会用?来替代。 出现?的情况会伴随着编译警告C4566。上面出现了 1 次3F（用例 5），导致乱码的原因是UTF-8 --&gt; 西欧 CP1252. 西欧 CP1252也就是 ASCII 的扩展，不支持汉字，所以用3F替代。 用例 3 为什么会编译错误？微软的编译器只能识别带 BOM 的 UTF-8，用例 3 的 UTF-8 没带 BOM，编译器会判定源文件编码为系统当前代码页 CP936。“中”的 UTF-8 编码为E4 B8 AD，列 5 执行从 CP936 到 UTF-8 转换之后变成了E6 B6 93 3F，列 6 再要将E6 B6 93 3F转换为 CP936 肯定是转换不回去的，相当于 UTF-8（1） –&gt; UTF-8 （2），再将 UTF-8（2）转换回 CP936，这时肯定得到的字符不是原来的字符了。 用例 4 为什么输出的D6 D0，而不是3F？对着用例 4 的各个顺序来看，源文件通过 CP936 保存着，但编译器通过 CP1252 来读取的，CP1252 就是 ASCII 扩展，单字节的，虽然此时显示为乱码，但各字节仍然是 D6 D0；然后将读取到的文件内容从 CP1252 转成 UTF-8 编码，转码后为 C3 96 C3 90；然后再将 UTF-8 编码转回为 CP1251，转码就又变成了 D6 D0。 但这个D6 D0在 CP1252 中是无法显示的，如果我们在用例 4 加入MessageBoxA(NULL, &quot;中&quot;, &quot;test&quot;, MB_OK); 会发现弹出的对话框中显示仍然是乱码。可以使用下面的代码进行测试： 1234567891011121314int _tmain(int argc, _TCHAR* argv[])&#123; char buf[3] = &#123; 0 &#125;; // 模拟CP936编码的“中” buf[0] = 0xD6; buf[1] = 0xD0; std::string strUTF8 = ANSIToUTF8(buf, 1252); char *p = (char*)strUTF8.c_str(); // 通过visual studio查看指针p处内存为： C3 96 C3 90 std::string str = UTF8ToANSI(strUTF8, 1252); p = (char*)str.c_str(); // 通过visual studio查看指针p处内存为： D6 D0 return 0;&#125; 4.2 测试编译器处理宽字符编码测试代码如下： 12345678int _tmain(int argc, _TCHAR* argv[])&#123; wchar_t buf[100] = &#123;L&quot;中&quot;&#125;; // wchar_t DumpCharacterCode((char*)buf, 4); // 打印4个字节 return 0;&#125; 同样，针对不同的系统代码页和源文件编码，打印出的汉字“中”的编码分别为： 测试用例 系统代码页 保存源文件编码 编译器判断文件采用的编码 源字符集(Source Character Set) 执行字符集(Execution Character Set) 打印输出 用例 1 简体中文 CP936 简体中文 CP936 简体中文 CP936 UTF-8 UTF-16 2D 4E 00 00 用例 2 简体中文 CP936 UTF-8 BOM UTF-8 BOM UTF-8 UTF-16 2D 4E 00 00 用例 3 简体中文 CP936 UTF-8 简体中文 CP936 UTF-8 UTF-16 编译错误(C2146) 用例 4 西欧 CP1252 简体中文 CP936 西欧 CP1252 UTF-8 UTF-16 D6 00 D0 00 大小端 用例 5 西欧 CP1252 UTF-8 BOM UTF-8 BOM UTF-8 UTF-16 2D 4E 00 00 五. 彻底避免硬编码字符乱码通过第 3 节的说明，很容易知道，要开发支持多语言，在任意语言（系统代码页）的 windows 环境下都正常编译，且运行起来没有乱码的程序，需要遵循如下原则： 代码文件采用 UTF-8 with BOM 编码。 Visual Studio 字符集设置为 Unicode 字符集。 使用 wchar_t。 做到上面 3 步，你的代码被别人从 github 上 clone 下来编译，不会因为你代码中含有中文等字符，产生类似error C2015这样的编译错误，更不会产生乱码。 本文介绍的方法只用来解决硬编码字符乱码的问题，至于数据传输中的乱码，需要统一字符编码来解决。 参考: https://blogs.msdn.microsoft.com/vcblog/2016/02/22/new-options-for-managing-character-sets-in-the-microsoft-cc-compiler 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["MSVC","字符编码"],"categories":["字符编码"]},{"title":"拨开字符编码的迷雾(3)--字符编码转换","path":"/post/4126466705.html","content":"本文主要介绍如何使用系统 API 进行字符编码的转换。 1. Windows API 介绍本文介绍使用 Windows API 进行字符编码的转换，注意涉及WideCharToMultiByte和MultiByteToWideChar这两个基础函数的使用。 在函数名中的MultiByte对应着多字节编码，如 ASCII、UTF-8 等都是多字节编码，而WideChar字面意思是宽字符，在 Windows 内部宽字符特指 UTF-16 编码。 函数原型如下： 1234567891011int WideCharToMultiByte( UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar); 12345678int MultiByteToWideChar( UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar); 2. 封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118std::string UnicodeToANSI(const std::wstring &amp;str, UINT iCodePage = CP_ACP) &#123; std::string strRes; int iSize = ::WideCharToMultiByte(iCodePage, 0, str.c_str(), -1, NULL, 0, NULL, NULL); if (iSize == 0) return strRes; char *szBuf = new (std::nothrow) char[iSize]; if (!szBuf) return strRes; memset(szBuf, 0, iSize); ::WideCharToMultiByte(iCodePage, 0, str.c_str(), -1, szBuf, iSize, NULL, NULL); strRes = szBuf; delete[] szBuf; return strRes;&#125;std::wstring ANSIToUnicode(const std::string &amp;str, UINT iCodePage = CP_ACP) &#123; std::wstring strRes; int iSize = ::MultiByteToWideChar(iCodePage, 0, str.c_str(), -1, NULL, 0); if (iSize == 0) return strRes; wchar_t *szBuf = new (std::nothrow) wchar_t[iSize]; if (!szBuf) return strRes; memset(szBuf, 0, iSize * sizeof(wchar_t)); ::MultiByteToWideChar(iCodePage, 0, str.c_str(), -1, szBuf, iSize); strRes = szBuf; delete[] szBuf; return strRes;&#125;std::string UnicodeToUTF8(const std::wstring &amp;str) &#123; std::string strRes; int iSize = ::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, NULL, 0, NULL, NULL); if (iSize == 0) return strRes; char *szBuf = new (std::nothrow) char[iSize]; if (!szBuf) return strRes; memset(szBuf, 0, iSize); ::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, szBuf, iSize, NULL, NULL); strRes = szBuf; delete[] szBuf; return strRes;&#125;std::string UnicodeToUTF8BOM(const std::wstring &amp;str) &#123; std::string strRes; int iSize = ::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, NULL, 0, NULL, NULL); if (iSize == 0) return strRes; unsigned char *szBuf = new (std::nothrow) unsigned char[iSize + 3]; if (!szBuf) return strRes; memset(szBuf, 0, iSize + 3); if (::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, (LPSTR)(szBuf + 3), iSize, NULL, NULL) &gt; 0) &#123; szBuf[0] = 0xEF; szBuf[1] = 0xBB; szBuf[2] = 0xBF; &#125; strRes = (char*)szBuf; delete[] szBuf; return strRes;&#125;std::wstring UTF8ToUnicode(const std::string &amp;str) &#123; std::wstring strRes; int iSize = ::MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0); if (iSize == 0) return strRes; wchar_t *szBuf = new (std::nothrow) wchar_t[iSize]; if (!szBuf) return strRes; memset(szBuf, 0, iSize * sizeof(wchar_t)); ::MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, szBuf, iSize); strRes = szBuf; delete[] szBuf; return strRes;&#125;std::string ANSIToUTF8(const std::string &amp;str, UINT iCodePage = CP_ACP) &#123; return UnicodeToUTF8(ANSIToUnicode(str, iCodePage));&#125;std::string ANSIToUTF8BOM(const std::string &amp;str, UINT iCodePage = CP_ACP) &#123; return UnicodeToUTF8BOM(ANSIToUnicode(str, iCodePage));&#125;std::string UTF8ToANSI(const std::string &amp;str, UINT iCodePage = CP_ACP) &#123; return UnicodeToANSI(UTF8ToUnicode(str), iCodePage);&#125; 对于只支持简体中文（部分韩文、日文）的系统，iCodePage可以使用 CP_ACP，这时 API 会使用系统当前的代码页（简体中文系统为 CP936，即 GBK 字符集）来进行编码转换。 但遇到如下情况就需要手动指定代码页： 需要转换的字符串中的文字是系统当前代码页不支持的。如字符串中含有中文，而当前系统代码页确是英文的； GBK 字符集中只包含了一部分韩文和日文，部分韩文和日文的转换可以正常转换，若遇到不能转换的情况也需要将指定 iCodePage 为特定的支持韩文或日文的代码页了，特别是中文和韩文、日文等混合的情况下。如韩文“탉”不包含在 GBK 中，若这时仍然使用 CP_ACP 就会得到错误的转换结果?，十六进制3F。但 GB18030（代码页为 54936）支持“탉”，可以手动指定 iCodePage 为 54936。 如果代码中含有 GBK 不支持的字符，如“탉”、“𤭢”（念 suì）等，Visual Studio 会弹出如下提示：选择“以其他编码保存” -&gt; “Unicode（UTF-8 带签名）- 代码页 65001”保存。虽然“简体中文（GB18030) - 代码页 54936”也支持这些字符，但不能选择该选项进行保存，具体原因在拨开字符编码的迷雾(2)--编译器处理文件编码中有详细的介绍。 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["Windows","字符编码"],"categories":["字符编码"]},{"title":"拨开字符编码的迷雾(1)--字符编码概述","path":"/post/2720283852.html","content":"为什么有些软件界面上的韩文会显示乱码？ ASCII 和 ANSI 有什么区别？ 相信不少人在字符编码上面摔过跟头，这篇文章针对开发中需要了解的字符编码知识进行了简要的讲解，希望能够对大家有所帮助。 1. ASCII 及其扩展1.1 什么是 ASCII 字符集字符集就是一系列用于显示的字符的集合。 ASCII 字符集由美国国家标准协会（American National Standard Institute)于 1968 年制定一个字符映射集合。 ASCII 使用 7 位二进制位来表示一个字符，总共可以表示 128 个字符（即2^7，二进制000 0000 ～ 111 1111，十进制0～127）。 ASCII 字符集中每个数字对应一个唯一的字符，如下表： 因为其对应关系非常简单，不需要特殊的编码规则，所以严格来讲 ASCII 不能算字符编码，因为它没有规定编码规则。我们只是习惯性的将 ASCII 字符集称之为 ASCII 码、ASCII 编码。 1.2 ASCII 的扩展1.2.1 扩展最高位ASCII 字符集是美国人发明的，其中的字符完全是为其自己量身定制的。随着计算机技术普及到欧洲（如法国、德国）各国，欧洲很多国家使用的字符除了 ASCII 表中的 128 个字符之外，此时欧洲人民发现 ASCII 字符集不能完全表达他们所要表达的内容。 怎么办了？他们发现 ASCII 只使用了一个字节（8 位）之中的低 7 位，于是欧洲各国开始各显神通，打起了最高位（第 0 位）的主意，将最高位利用了起来，这样又多了 128 个字符，从而满足了欧洲人民的需要。 但因为每个国家的需求不一样，各国都设计了不同的方案。为了结束这种混乱的局面，国际标准化组织(ISO)及国际电工委员会(IEC)联合制定了一系列 8 位字符集的标准，统称为 ISO 8859（全称 ISO&#x2F;IEC 8859）。注意，这是一系列字符集的统称，如 ISO&#x2F;IEC 8859-1（也就是常听到的 Latin-1）支持西欧语言，ISO&#x2F;IEC 8859-4（Latin-4）支持北欧语言等。 完整列表如下（摘自百度百科）：ISO&#x2F;IEC 8859-1 (Latin-1) - 西欧语言ISO&#x2F;IEC 8859-2 (Latin-2) - 中欧语言ISO&#x2F;IEC 8859-3 (Latin-3) - 南欧语言，世界语也可用此字符集显示。ISO&#x2F;IEC 8859-4 (Latin-4) - 北欧语言ISO&#x2F;IEC 8859-5 (Cyrillic) - 斯拉夫语言ISO&#x2F;IEC 8859-6 (Arabic) - 阿拉伯语ISO&#x2F;IEC 8859-7 (Greek) - 希腊语ISO&#x2F;IEC 8859-8 (Hebrew) - 希伯来语(视觉顺序)ISO 8859-8-I - 希伯来语(逻辑顺序)ISO&#x2F;IEC 8859-9 (Latin-5 或 Turkish) - 它把 Latin-1 的冰岛语字母换走，加入土耳其语字母。ISO&#x2F;IEC 8859-10 (Latin-6 或 Nordic) - 北日耳曼语支，用来代替 Latin-4。ISO&#x2F;IEC 8859-11 (Thai) - 泰语，从泰国的 TIS620 标准字集演化而来。ISO&#x2F;IEC 8859-13 (Latin-7 或 Baltic Rim) - 波罗的语族ISO&#x2F;IEC 8859-14 (Latin-8 或 Celtic) - 凯尔特语族ISO&#x2F;IEC 8859-15 (Latin-9) - 西欧语言，加入 Latin-1 欠缺的芬兰语字母和大写法语重音字母，以及欧元符号。ISO&#x2F;IEC 8859-16 (Latin-10) - 东南欧语言。主要供罗马尼亚语使用，并加入欧元符号。 我们在数据库或 Qt 中常见到的 Latin-1、2、5、7 其实就是上面提到的针对特定语言的 ASCII 扩展字符集。 1.2.2 多字节扩展 - GB 系列前面讲到了，欧洲各国有效利用闲置的最高位对 ASCII 字符集进行了扩展。可是欧洲人民没有想到在大洋彼岸有着一个拥有五千年历史的伟大民族，她拥有着成千上万的汉字，1 个字节显然不够表达如此深厚的文化底蕴。 于是当计算机引入到中国之初，国家技术监督局就设计了 GB 系列编码方案（GB 为 guo biao 的首字母缩写)。 GB 编码方案使用 2 个字节来表达一个汉字。同时为了兼容 ASCII 编码，规定各个字节的最高位（首位）必须为 1，从而避免了和最高位为 0 的 ASCII 字符集的冲突。 GB 系列字符集经历下面的几个发展过程： 编码名称 发布时间 字节数 汉字范围 GB2312 1980 年 变字节（ASCII 1 字节，汉字 2 个字节） 6763 个汉字 GB13000 1993 年第一版 变字节（ASCII 1 字节，汉字 2 个字节） 20902 个汉字 GBK Windows95 中 2 个字节 21886 个汉字和图形符号（含 GB2312，BIG5 中所有字符） GB18030 2000 年第一版 变字节（ASCII 1 字节，汉字 2 个或 4 个字节） 27484 个汉字 每一次迭代，支持的字符数量都会增加，而且每一次迭代都会保留之前版本支持的编码，所以做到了向上兼容。 1.2.3 全角与半角因为汉字在显示器上的显示宽度要比英文字符的宽度要宽一倍，在一起排版显示时不太美观。所以 GB 编码不仅仅加入了汉字字符，而且包括了 ASCII 字符集中本来就有的数字、标点符号、字母等字符。这些被编入 GB 编码中的数字、英文标点符号、字母在显示器上的显示宽度比 ASCII 字符集中的宽度宽一倍，所以前者称为全角字符，后者称为半角字符。 2. ANSI2.1 ANSI 与代码页前面说到了世界各国针对 ASCII 的扩展方案（如欧洲的 ISO&#x2F;IEC 8859，中国的 GB 系列等），这些 ASCII 扩展编码方案的特点是：他们都兼容 ASCII 编码，但他们彼此之间是不兼容的。微软将这些编码方案统称为 ANSI 编码。故 ANSI 并不是特指某一种编码方案，只有知道了在哪个国家，哪个语言环境下，才知道它具体表示哪个编码方案。 在 Windows 操作系统上，默认使用 ANSI 来保存文件（但从 Windows 10 开始默认使用 UTF8 编码）。操作系统是如何知道 ANSI 到底应该表示哪种编码了，是 GBK 还是 ASCII，抑或还是 EUC-KR 了？ Windows 通过一个叫”Code Page”（翻译为中文叫代码页）的东西来判断系统的默认编码。 简体中文操作系统的代码页默认是 936，即 ANSI 使用的是 GBK 编码。 GB18030 编码对应的 Windows 代码页为 CP54936。 可以使用命令chcp来查看和修改系统默认的代码页。 汉字“𤭢”（念 suì）只包含在 GB18030 中，GB2312、GB13000、GBK 中均不包含。默认情况下，Visual Studio 会使用 CP936（即 GBK）来保存代码文件，如果在代码文件中输入该汉字，Visual Studio 弹出如下提示要求用户选择代码页： 2.2 更改默认代码页2.2.1 chcp 命令可以使用chcp命令来更改默认代码页，如chcp 437将默认代码页更改为 437（美国）。 2.2.2 控制面板在“控制面板”–&gt;“区域和语言”–&gt; “更改系统区域设置”中更改系统默认的代码页为“中文（简体，中国）”。 2.2.3 代码修改也可以通过代码更改默认的代码页： 1234char *setlocale( int category, const char *locale); 3. Unicode3.1 Unicode 产生背景各个国家使用不同的编码规则，虽然他们都是兼容 ASCII 的，但它们相互却是不兼容的。 试想法国人 Jack 写了一封名为”love_you.txt”的信，传给了他的德国朋友 Rose，Rose 想要在 windows 系统上打开这个文件，她需要知道德国使用的字符编码是 Latin-1，然后还要确保她的计算机上安装了该编码，才能顺利的打开这个文件。 如果上面这些还能忍受，那么随着网络的发展，你从互联网上获取的文件，你很有可能不知道它来自哪个国家，使用的哪种编码。这也就是 Email 刚诞生时常常出现乱码的原因，发信人和收信人使用的编码可能是不一样的。 于是The Unicode Standard（统一码标准）横空出世，它由 The Unicode Consortium 于 1991 年发布，我们习惯称它为 Unicode 字符集。 Unicode 字符集和 ASCII 字符集一样，也只是一个字符集合，标记着字符和数字之间的映射关系，它不包含任何编码规则和方案。和 ASCII 不一样的是，Unicode 字符集支持的字符数量是没有限制的（具体可以参考 Unicode 规范）。 我们通常认为的 Unicode 字符固定占用 2 个字节的观点是错误的。如“𤭢”（念 suì）的 Unicode 码为D852 DF62。 那么 Unicode 字符是怎样被编码成内存中的字节的呢？它是通过 UTF (Unicode Transformation Formats) 实现的，比较常见得有 UTF-8，UTF-16。 在 Windows 系统上汉字默认使用 CP936（即 GBK 编码），占 2 个字节。而大多数 Unicode 字符的 Unicode 码值也占 2 个字节，所以大多数人误以为汉字字符串在内存中的值就是 Unicode 值，这是错误的。可以从 站长工具-Unicode 查询汉字的 Unicode 码值。 3.3 字符集与字符编码的区别从 ASCII、GB2312、GBK、GB18030、Big5（繁体中文）、Latin-1 等采用的方案来看，它们都只是定义了单个字符与二进制数据的映射关系，一个字符在一个方案中只会存在一种表示方式，所以我们说 GB2312 是字符集还是字符编码方式都无所谓了。但是 Unicode 不一样，Unicode 作为一个字符集可以采用多种编码方式，如 UTF-8, UTF-16, UTF-32 等。所以自 Unicode 出现之后，字符集与字符编码需要明确区分开来。 3.4 UTF-16 编码的缺点UTF-16 编码方式规定用两个或四个字节来表示所有的字符。对于 ASCII 字符保持不变，只是将原来的 7 位扩展到了 16 位，其高 9 位永远是 0。 如字符’A’： 12ASCII: 0100 0001UTF-16: 0000 0000 0100 0001 从上面可以看到，对于 ASCII 字符，UTF-16 的存储空间扩大了一倍，因此 UTF-16 并不是完全兼容 ASCII 字符集的。这对于那些 ASCII 字符集已经满足需求的西方国家来说完全是没必要的，而且 ASCII 字符经过 UTF-16 编码之后高字节始终是 0，还会导致很多 C 语言函数（如strcpy,strlen）将此字节视为字符串的结束符&#39;\\0&#39;，从而出现错误的计算结果。 而且，UTF-16 还存在大小端的问题，“𤭢”（念 suì）Unicode 码在大端系统上为D852 DF62，小端系统上为52D8 62DF。 因此，UTF-16 一开始推出的时候就遭到很多西方国家的抵制，影响了 Unicode 的推行。于是后来又设计了 UTF-8 编码方式，才解决了这些问题。 3.5. Unicode 字符集常用编码方式：UTF-83.5.1 UTF-8 概述UTF-8 是互联网上使用最广泛的 Unicode 字符集编码方式。UTF-8 编码的最小单位由 8 位（1 个字节）组成，UTF-8 使用一个至四个字节来表示 Unicode 字符。另外，UTF-8 是完美兼容 ASCII 字符集的，这一点可以通过下面的 UTF-8 的编码规则得到证明。 3.5.2 UTF-8 编码规则UTF-8 编码规则很简单：（1）对于 ASCII（单字节字符）字符，采用和 ASCII 相同的编码方式，即只使用一个字节表示，且该字节第一位为 0.（2）对于多字节（2~4 字节）字符，假设字节数为 n（1 &lt; n &lt;&#x3D; 4），第一个字节：前 n 位都设为 1，第 n+1 位设为 0；后面的 n-1 个字节的前两位一律设为 10。所有字节中的没有提及的其他二进制位，全部为这个符号的 Unicode 码。按照这个规则，程序通过第一个字节中1的个数就可以知道当前字符编码所占的位数。 Unicode 符号范围(十六进制) UTF-8 编码方式(二进制) 单字节:00000000-0000 007F 0xxxxxxx 双字节:00000080-0000 07FF 110xxxxx 10xxxxxx 三字节:00000800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 四字节:0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 3.5.2 UTF-8 BOMBOM（byte order mark）从字面意义来看是标记字节顺序的。最早出现的原因是因为 UTF-16 和 UTF-32 编码采用 2 个或 4 个字节表示一个字符，面临大小端的问题。为了区分是使用的大端(Big Endian，简称 BE)还是小端(Little Endian，简称 LE)，采用了在串的前面加入指定的字节加以区分，UTF-16 大端加入FE FF，小端加入FF FE. 比如， 字符串“ABC”的 UTF-16 编码为 00 41 00 42 00 43，对应的各种的字节序列如下： 序列 数据 UTF-16BE (without BOM) 00 41 00 42 00 43 UTF-16LE (without BOM) 41 00 42 00 43 00 UTF-16BE (with BOM) FE FF 00 41 00 42 00 43 UTF-16LE (with BOM) FF FE 41 00 42 00 43 00 因为 UTF-8 和 ASCII 扩展字符集都是单字节序列，二者不好区分，微软采用在 UTF-8 编码的字符串前也加入 BOM（3 个字节EF BB BF）来标记 UTF-8 编码的串。UTF-8 BOM 这一规范大多在 Windows 下被使用，在其他平台下用的很少使用，如 Linux 全部采用 UTF-8 编码，不存在需要区分的情况；HTTP 协议可以通过 Content-Type:text/html; charset=utf-8 来指定当前使用 UTF8 编码，也没有区分的需求。 文章图片带有“CSDN”水印的说明：由于该文章和图片最初发表在我的CSDN 博客中，因此图片被 CSDN 自动添加了水印。","tags":["字符编码","ANSI","UTF8"],"categories":["字符编码"]},{"title":"SQL批量添加更新和删除","path":"/post/2842059394.html","content":"批量插入1INSERT INTO users(name, age) VALUES(&#x27;姚明&#x27;, 25), (&#x27;比尔.盖茨&#x27;, 50), (&#x27;火星人&#x27;, 600); 批量更新1UPDATE member SET descipt = &quot;默认&quot; WHERE usertypeid IN (1,2,3,4); 1234567UPDATE member SET descipt = CASE id WHEN 1 THEN &#x27;默认&#x27; WHEN 2 THEN &#x27;黄铜&#x27; WHEN 3 THEN &#x27;黄金&#x27; END WHERE id IN (1,2,3); 批量删除1DELETE FROM users WHERE id IN (1,2,3,4);","tags":["MySQL","SQL"],"categories":["数据库","MySQL"]},{"title":"P2P及NAT穿透技术介绍","path":"/post/2441416675.html","content":"一、 P2PP2P（peer to peer）是一个“点对点传输技术”，也就是两台计算机之间不需要第三台机器作为服务端就能实现数据的传输，每台计算机即是客户端又是服务端。 如果每台计算机都有自己的独立的公网 IP，那么 P2P 技术就比较好实现了，但是现实中由于 NAT（Network Address Translation） 的存在，使得 P2P 技术最大的难点就在于穿越 NAT 的限制，俗称“打洞”。 二、 NAT2.1 NAT 的产生背景如果我们把 Internet 比作一个邮政系统，那么 IP 地址的作用就等同于包含城市、街区、门牌编号在内的精确地址，通过 IP 地址可以准确的定位到具体的一台计算机。 IPv4 使用 32bits 整数表达一个地址，地址最大范围就是 232 约为 43 亿。以 IP 创始时期可以联网的设备数量来看，这样的一个空间已经很大，很难被短时间用完。然而，事实远远超出人们的设想，计算机网络在此后的几十年里迅速壮大，网络终端数量也呈爆炸性增长。 更为糟糕的是，为了路由和管理方便，43 亿的地址空间被按照不同前缀长度划分为 A,B,C,D 类地址网络和保留地址。IANA 向超大型企业&#x2F;组织分配 A 类网络地址，一次一段。向中型企业或教育机构分配 B 类网络地址，一次一段。这样一种分配策略使得 IP 地址浪费很严重，很多被分配出去的地址没有真实被利用，地址消耗很快。以至于二十世纪 90 年代初，网络专家们意识到，这样大手大脚下去，IPv4 地址很快就要耗光了。于是，人们开始考虑 IPv4 的替代方案，同时采取一系列的措施来减缓 IPv4 地址的消耗。正是在这样一个背景之下，NAT 应运而生。 IPv4 即网际网协议第 4 版——Internet Protocol Version 4 的缩写。 2.2 NATNAT（Network Address Translation）网络地址转换，就是在内网 IP 和公网 IP 之前相互转换。NAT 通常部署在一个组织的网络出口位置。 2.2.1 内部网络地址内部网络地址即内网 IP。 RFC1918 规定了三个保留地址段落，这三个范围分别处于 A,B,C 类的地址段，不向特定的用户分配，被 IANA 作为私有地址保留，这些地址可以在任何组织或企业内部使用。 和其他 IPv4 地址的区别就是，其仅能在内部使用，不能作为公网 IP。也就是说，出了组织的管理范围这些地址就不再有意义，无论是作为源地址，还是目的地址。对于一个封闭的组织，如果其网络不连接到外部 Internet，就可以使用这些地址而不用向 IANA 提出申请，在内网使用私有IP地址进行路由管理和报文传递的方式与其他网络没有差异。 三类地址段中的私有IP地址段分别如下： 12310.0.0.0 ~ 10.255.255.255 即 10.0.0.0/8172.16.0.0 ~ 172.31.255.255 即 172.16.0.0/12192.168.0.0 ~ 192.168.255.255 即 192.168.0.0/16 对于有 Internet 访问需求而在内部却使用私有地址的网络（目前绝大多数网络都是这样），就要在组织的出口位置部署 NAT 网关，在报文离开私网进入 Internet 时，将源 IP 替换为公网地址，通常是出口设备的接口地址。 一个对外的访问请求在到达目标以后，在目标看来是由本组织的出口网关所发起，因此被请求的目标将响应内容由 Internet 发回到出口网关。出口网关再将目的地址替换为私网的源主机地址和端口，发回内部（网关是如何将不同的响应替换成响应的私有IP和端口的呢？请看下一节）。这样一次由私网主机向公网服务端的请求和响应就在通信两端均无感知的情况下完成了。依据这种模型，数量庞大的内网主机就不再需要公有 IP 地址了。 需要注意，在一个网络中可以有多个NAT网关，也可以出现网关套网关的情况，内层网关可以没有公网IP。 2.2.2 NAT 分类 全锥形 NAT（Full Cone NAT） 一旦内部主机端口对(iAddr:iPort)被 NAT 网关映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；任何一个外部主机发送到(eAddr:ePort)的报文也将会被转换后发到(iAddr:iPort)。 限制锥形 NAT（Restricted Cone NAT） 一旦内部主机端口对(iAddr:iPort)被映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；但只有 (iAddr:iPort)向特定的外部主机 hAddr 发送过数据后，主机 hAddr 从任意端口发送到(eAddr:ePort)的报文将会被转发到(iAddr:iPort)。 端口限制锥形 NAT（Port Restricted Cone NAT） 一旦内部主机端口对(iAddr:iPort)被映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；但只有(iAddr:iPort)向特定的外部主机端口对(hAddr:hPort)发送过数据后，由 (hAddr:hPort)发送到(eAddr:ePort)的报文才会被转发到(iAddr:iPort)。 对称型 NAT（Symmetric NAT） 内部主机“地址端口对”(iAddr:iPort)请求特定外部主机“地址端口对”(iAddr:iPort)时，NAT 网关都会映射一个特有的(eAddr:ePort)。只有收到报文的外部主机从对应的端口对发送回应的报文，才能被转换。即使内部主机使用之前用过的“地址端口对”去连接不同外部主机(或端口)时，NAT 网关也会建立新的映射关系。 从上面描述可以看出，不同的NAT类型的安全性系数依次为 对称型 &gt; 端口受限锥型 &gt; 受限锥型 &gt; 全锥型，同样NAT穿越的难度也是依次降低。 三、 NAT 穿越技术常见的 NAT 穿越技术有：STUN、TURN、ICE。 3.1 STUN虽然在RFC3489和RFC5389中的名称都是 STUN，但其全称是不同的。 在 RFC3489 里，STUN 的全称是 Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)， 即穿越 NAT 的简单 UDP 传输，是一个轻量级的协议，允许应用程序发现自己和公网之间的 NAT 类型，同时也能允许应用程序发现自己被 NAT 分配的公网 IP。这个协议在 2003 年 3 月被提出，目前已经被 STUN&#x2F;RFC5389 所替代。 在 RFC5389 中，STUN 的全称变为 Session Traversal Utilities for NAT，即 NAT 环境下的会话传输工具，是一种处理 NAT 传输的协议，但主要作为一个工具来服务于其他协议。和 STUN&#x2F;RFC3489 类似，可以被终端用来发现其公网 IP 和端口，同时可以检测端点间的连接性，也可以作为一种保活（keep-alive）协议来维持 NAT 的绑定。和 RFC3489 最大的不同点在于，STUN 本身不再是一个 完整的 NAT 传输解决方案，而是在 NAT 传输环境中作为一个辅助的解决方法，同时也增加了 TCP 的支持。RFC5389 废弃了 RFC3489（因此RFC3489通常称为 classic STUN），但依旧是后向兼容的。STUN 是一种 Client&#x2F;Server 的协议，也是一种 Request&#x2F;Response 的协议，默认端口号是 3478。 STUN 完整的定义参考：RFC5398 3.2 TURNTURN 是 Traversal Using Relay NAT 的缩写，即使用中继穿透 NAT，STUN 的中继扩展。简单的说，TURN 与 STUN 的共同点都是通过修改应用层中的私网地址达到 NAT 穿透的效果，不同点是 TURN 是通过两方通讯的“中间人”方式实现穿透。 TURN 完整的定义参考：RFC5766 3.3 ICEICE 是 Interactive Connectivity Establishment 的缩写，即互动式连接建立，由 IETF 的 MMUSIC 工作组开发出来的，它所提供的是一种框架，使各种 NAT 穿透技术可以实现统一。 ICE 跟 STUN 和 TURN 不一样，ICE 不是一种协议，而是一个框架（Framework），它整合了 STUN 和 TURN。 ICE 完整的定义参考：RFC5245 参考：P2P 技术详解(一)：NAT 详解——详细原理、P2P 简介P2P 技术详解(二)：P2P 中的 NAT 穿越(打洞)方案详解P2P 技术详解(三)：P2P 技术之 STUN、TURN、ICE 详解","tags":["WebRTC","P2P","TURN","ICE","NAT"],"categories":["WebRTC"]},{"title":"MySQL中与时间和日期相关的用法","path":"/post/3556253141.html","content":"一、 时间、日期获取1.1 获取当前本地的日期和时间123456SELECT NOW(), CURRENT_TIMESTAMP(), LOCALTIME(), LOCALTIMESTAMP(), SYSDATE(); 上面5个函数都可以获取当前本地时间，但SYSDATE有所不同。 1SELECT NOW(), SLEEP(3), NOW(); 执行结果： 12NOW() sleep(3) NOW()2017-11-09 17:21:09 0 2017-11-09 17:21:09 虽然暂停了3秒，但 NOW() 前后2次获取到时间是一样的，也就是说 NOW() 函数获取的时间是在整个SQL语句开始执行时的时间，无论SQL语句中有多少个NOW()函数，获取到的时间都是一样的。CURRENT_TIMESTAMP(), LOCALTIME(), LOCALTIMESTAMP()和NOW()函数一样。 但SYSDATE不同，SYSDATE 获取到的是SYSDATE()函数执行时的实时时间： 1SELECT SYSDATE(), SLEEP(3), SYSDATE(); 执行结果： 12SYSDATE() sleep(3)\tSYSDATE()2017-11-09 17:25:05 0 2017-11-09 17:25:08 1.2 获取当前本地的日期123SELECT CURDATE(), CURRENT_DATE(); 1.3 获取当前本地的时间123SELECT CURTIME(), CURRENT_TIME(); 1.4 获取当前UTC日期和时间12SELECT UTC_TIMESTAMP(); 1.5 获取当前UTC日期12SELECT UTC_DATE(); 1.6 获取当前UTC时间12SELECT UTC_TIME(); 1.7 获取时间戳（自1970年经过的秒）12SELECT UNIX_TIMESTAMP(); -- 当前时间时间戳SELECT UNIX_TIMESTAMP(&#x27;2017-11-09 12:30:00&#x27;); -- 自1970年到2017-11-09 12:30:00经过的秒数 二、 时间操作2.1 从字符串提取时间和日期12345678910111213SET @dt = &#x27;2008-09-10 07:15:30.123456&#x27;;SELECT DATE(@dt); -- 2008-09-10SELECT TIME(@dt); -- 07:15:30.123456SELECT YEAR(@dt); -- 2008SELECT QUARTER(@dt); -- 3SELECT MONTH(@dt); -- 9SELECT WEEK(@dt); -- 36SELECT DAY(@dt); -- 10SELECT HOUR(@dt); -- 7SELECT MINUTE(@dt); -- 15SELECT SECOND(@dt); -- 30SELECT MICROSECOND(@dt); -- 123456 2.2 获取某天在周、月、年中所处位置12345SET @dt = &#x27;2017-11-09&#x27;;SELECT DAYOFWEEK(@dt); -- 5 星期日为0，5代表星期四SELECT DAYOFMONTH(@dt); -- 9 一个月的第9天SELECT DAYOFYEAR(@dt); -- 313 2017年的第313天 2.3 获取指定日期的最后一天1SELECT LAST_DAY(&#x27;2017-02-05&#x27;); -- 2017-02-28 2.4 时间加减123456789101112SET @dt = &quot;2017-11-09 17:10:20.0000001&quot;;SELECT DATE_ADD(@dt, INTERVAL 1 DAY); -- 加1天SELECT DATE_ADD(@dt, INTERVAL 2 HOUR); -- 加2小时SELECT DATE_ADD(@dt, INTERVAL 1 MINUTE); -- 加1分钟SELECT DATE_ADD(@dt, INTERVAL 1 SECOND);SELECT DATE_ADD(@dt, INTERVAL 1 MICROSECOND); -- 加1微妙SELECT DATE_ADD(@dt, INTERVAL 1 WEEK); -- 加1周SELECT DATE_ADD(@dt, INTERVAL 1 MONTH);SELECT DATE_ADD(@dt, INTERVAL 1 QUARTER); -- 加1个季度SELECT DATE_ADD(@dt, INTERVAL 1 YEAR);SELECT DATE_ADD(@dt, INTERVAL -1 DAY); -- 减1天 2.5 两个日期、时间加减12SELECT DATEDIFF(&#x27;2008-08-08&#x27;, &#x27;2008-08-01&#x27;); -- 7SELECT DATEDIFF(&#x27;2008-08-01&#x27;, &#x27;2008-08-08&#x27;); -- -7 第一个参数减去第二个参数 12SELECT TIMEDIFF(&#x27;2008-08-08 08:08:08&#x27;, &#x27;2008-08-08 00:00:00&#x27;); -- 08:08:08SELECT TIMEDIFF(&#x27;00:00:00&#x27;, &#x27;08:08:08&#x27;); -- -08:08:08 2.6 时间格式化123SELECT DATE_FORMAT(&#x27;2008-08-08 22:23:00&#x27;, &#x27;%W %M %Y&#x27;); -- Friday August 2008SELECT DATE_FORMAT(&#x27;2008-08-08 22:23:01&#x27;, &#x27;%Y%m%d%H%i%s&#x27;); -- 20080808222301SELECT TIME_FORMAT(&#x27;22:23:01&#x27;, &#x27;%H.%i.%s&#x27;); -- 22.23.01 2.7 秒计算计算指定时间折合多少秒，如00:01:00表示1分钟，等于60秒。 12SELECT TIME_TO_SEC(&#x27;01:00:05&#x27;); -- 3605SELECT SEC_TO_TIME(3605); -- &#x27;01:00:05&#x27;","tags":["MySQL"],"categories":["数据库","MySQL"]},{"title":"MySQL获取字符串长度的几种方式","path":"/post/1446858454.html","content":"MySQL 获取字符串长度的常用函数有char_length、length、bit_length，它们针对不同的字符编码的处理方式不一样。 总的来说： char_length 显示的字符个数； length 字符串在当前编码下存储，所占的字节数。 bit_length 字符串在当前编码下存储，所占的bit数，也就是length*8 GBK 编码1234select char_length(&#x27;中国&#x27;); -- 2select length(&#x27;中国&#x27;); -- 4select length(&#x27;china&#x27;); -- 5select bit_length(&#x27;中国&#x27;); -- 32 UTF-8 编码1234select char_length(&#x27;中国&#x27;); -- 2select length(&#x27;中国&#x27;); -- 6select length(&#x27;china&#x27;); -- 5select bit_length(&#x27;中国&#x27;); -- 48","tags":["MySQL"],"categories":["数据库","MySQL"]},{"title":"字节序列之大小端","path":"/post/2819651546.html","content":"大小端的定义Big-Endian 和 Little-Endian 的定义分别如下： Little-Endian 数据的低位字节位存放在内存的低地址端，高位字节存放在内存的高地址端。 Big-Endian 数据的高位字节位存放在内存的低地址端，低位字节存放在内存的高地址端。 以十六进制数字 0x12345678为例，它总共占 4 个字节（1个字节8位，2个16进制占8位，所以1个字节最大表示0xFF），该数据在大小端模式下的内存布局分别为： 大端模式 12低地址 -----------------&gt; 高地址0x12 | 0x34 | 0x56 | 0x78 小端模式 12低地址 ------------------&gt; 高地址0x78 | 0x56 | 0x34 | 0x12 程序判断大小端12345678bool IsLittleEndian() &#123; int a = 0x1234; char c = *(char *)&amp;a; if (c == 0x34) &#123; return true; &#125; return false;&#125; 常用系统的大小端目前 Intel的 80x86 系列芯片是唯一还在坚持使用小端的芯片（Windows系统就是基于该架构）。 ARM芯片默认采用小端，但可以切换为大端。 另外，对于大小端的处理也和编译器的实现有关，在 C 语言中，默认是小端（但在一些对于单片机的实现中却是基于大端，比如 Keil 51C），Java是平台无关的，默认是大端。 通过网络传输的数据普遍采用的都是大端模式。","tags":["字节序列","大小端"],"categories":["C++语言"]},{"title":"白酒入门","path":"/post/1855436935.html","content":"正值 9 月 9 全球酒水节，各大电商都在做活动，趁机网购了一批酒水。在享受这大自然馈赠的礼物的同时，也说一说自己对白酒的理解。希望在了解了白酒的这些知识后能明明白白喝酒。 1. 白酒酿造工艺1.1 粮食酒与勾兑酒首先，所有的白酒都是粮食经过发酵、蒸馏而成的，也就是我们常说的粮食酒，这也印证了人们常说的“酒是粮食精，越喝越年轻”这句话。 因为白酒都要经过蒸馏这个步骤，所以我们也称白酒为“蒸馏酒”。 但我们常提到的“非粮食酒”指的是用食用酒精（有的甚至用的工业酒精）勾兑而成的酒，我认为这种酒严格意义上可以称为“假酒”(虽然使用食用酒精勾兑在法律上是被允许的，也就是后面提到的液态发酵酒，但法律是禁止使用工业酒精勾兑酒的)，喝了之后对人体没有任何好处，最多只能麻痹神经（工业酒精勾兑的酒是绝对不能喝的，工业酒精成份是甲醇，少量就会使人失明或者致命）。 很多人对“勾兑”二字很敏感，认为凡是勾兑的酒都不是好酒，这个观点是错误的。 下面介绍白酒的酿造工艺时会说到，粮食等最初经过发酵、蒸馏形成的酒叫“原浆”，原浆的酒精度数一般在 70 度左右，是无法直接饮用的，需要降低其度数才能饮用。 如果在市面上看到如“茅台镇粮食原浆酒”等这样的“原浆酒”，但度数低于 70 度(左右)的，都不是真正的原浆酒。这样的商家要么是不诚信，要么就是不专业。 降低度数不是直接往酒里面掺水，这样口感会非常差，而且会使酒体变浑浊。 需要专门的白酒勾兑工艺，白酒勾兑一门很复杂的学科，勾兑主要是将不同的原料、不同窖池、不同环节、不同年份的酒进行调配，从而产生具有不同口味、香型的白酒。 标准的白酒勾兑工艺中是不允许添加化学添加剂的，白酒的口味、香型都是自然形成的。 我们可以认为市面上所有的酒都是“勾兑酒”，只是每种酒勾兑所用的原料、工艺不相同，茅台、五粮液、汾酒等无一例外也是勾兑而成的。好酒采用“酒勾兑酒”的方式，差酒采用“酒精勾兑水”或者“酒精+香精+添加剂勾兑水”的方式。 1.2 酿造工艺1.2.1 纯粮固态发酵、液态发酵白酒在酿造工艺上分为纯粮固态发酵和液态发酵 2 种。 纯粮固态发酵酒是通过 粮食 + 曲 + 发酵 + 陈酿 + 勾兑 等几个环节制成的。 液态发酵酒是用甘蔗和甜菜渣、薯干、玉米等（这几种植物发酵周期短、出酒率高、酒质差）制造出来的食用酒精为基础酒，加入增香调味物质模拟传统粮食白酒的口感，经调配而成的液态白酒，行话叫“三精一水”，即食用酒精、香精、糖精、水。 由于纯粮固态发酵工艺所遵循的都是自然的酿造规律，加之曲、老窖中微生物的作用，酒体中除了乙醇外，还蕴含了丰富的乙酸、乙酯等营养成分。 酸是白酒中的重要呈味物质，它与其他香味物质共同构成白酒所特有的芳香。优质纯粮固态发酵白酒的酸超过普通液态白酒的两倍。 酯也是固态发酵白酒的香味物质，优质白酒的酯类含量比液态白酒高出一倍以上，所以优质白酒香味浓郁，而液态发酵白酒的香味只能靠添加人工合成的香味物质来解决。 1.2.2 酿造流程这里只介绍白酒纯粮固态酿造的几大主要的流程，每个酒厂生产酒的特点不一样，具体细节也会有很大差异，但都离不开这几大流程。 1. 选料原料主要是粮食和水。 粮食以高粱、玉米、小麦、大米、糯米等中的一种或多种为主，每种粮食酿出的酒的口味都不一样，有行业术语叫“高粱香、玉米甜、大米净、小麦糙、糯米绵”。 水，酿酒对水的要求很高，常言道“水为酒之血，名酒必有佳泉”，这也是为什么只有赤水河的水才能酿出茅台的原因。 2. 制曲如果说粮食是酒的根本，那么“曲就是酒的骨髓”，曲类似于做馒头的酵母。 曲主要有 3 种： 大曲：由麦子高温制成，发酵周期长、微生物含量丰富，多用于高端白酒。 小曲：由米制成，发酵周期短、微生物含量低。 麸曲：由麸皮（小麦的壳，打碎之后叫糠，农村常用于喂猪）制成，发酵周期短，出酒率高，但酒质较差。多用于低端酒，如二锅头等。 3. 发酵将粮食和曲放入窖池中发酵，利用曲和窖池中的微生物将粮食糖化、发酵成酒精。 “千年老窖”中含有丰富的微生物，发酵出来的酒口感和味道也不一样。 4. 蒸馏靠发酵形成的酒的酒精度数很低，需要进行提纯。利用酒精与水的沸点不一样的原理，采用蒸馏法进行提纯。 蒸馏的过程分为头、中、尾 3 部分，产生的酒称为酒头、中馏酒、酒尾，每种酒在酒厂中都有不同的用处。 5. 陈酿经过蒸馏产生的高度源酒还只能算半成品，喝起来辛辣，不醇和。需要经过合理的贮存、陈酿，一方面自然的排除杂味，另一方面让酒分子（即乙醇分子）和水分子充分结合，使酒的口感更加醇厚。这一步陈酿的越久，口味就越好，成本就越高，价格也就越贵。 话说茅台在出厂前会自然陈酿三年。 6. 勾兑经过上面几个步骤所生产的酒就可以称为“原浆”了，但其度数较高、口味单一、香味不纯正。为了统一口味，协调香味、降低度数，需要专门的调酒师对原浆酒进行勾兑。 现在白酒市场越来越来乱，各种混、配，如固态发酵白酒+食用酒精+食用香精+其他添加物等等，认准好酒除了相信一分钱一分货之外，还有**好酒在酿造工艺上需具备这 3 个关键词 纯粮、纯固态、大曲**。瓶身都有配料表，出现“食用酒精”的不要购买。 话说现在配料表也有造假的。 1.3 年份酒我们在市面上经常遇到类似“白云边 12 年”，“白云边 15 年”，“白云边 20 年”这样的年份酒，很多人认为这个“12 年”、“15 年”、“20 年”指的这瓶酒存储的年份。 如果你是这么认为的，那只能说你“太年轻，太单纯”了。 拿“白云边 20 年”为例，它指的是在白酒勾兑过程中掺入了少许 20 年年份的酒，具体的这个“少许”指的是多少就不清楚了，可能是一缸酒:一杯 20 年酒，也可能更少或更多。 现实中由于酒的年份不同，价格差距也巨大，所以调酒时所用的基酒的品质等也会有差别，毕竟白云边 20 年和 15 年喝起来差别还是很大的。 1.4 白酒收藏一般收藏酒的年份指的是这整瓶酒存放的年份。 这个价值不是年份酒所能比拟的。我们经常听说“酒是陈的香”，但白酒是不是存放的越久就一定越好喝了？ 不一定，这个和酒的质量、存放的环境、密封程度等有很大关系。一般存放 3~5 年喝为宜，很多几十年的陈酒已经不适合直接喝了，可以用来作为基酒进行勾调。 有几种酒不适合陈： 含添加剂的酒。现在市面上很多低端酒都加入了香精，如果存放时间长了，香精挥发了，口感也会不一样。 低度酒（43 度以下的酒就算低度酒了）。要知道世界上没有绝对密封的环境，我们可能认为玻璃瓶、陶瓷瓶的瓶壁是绝对封闭的，但从分子的角度来看，仍然会有酒分子的渗漏挥发，更何况还有瓶口的密封等问题，酒或多或少都会有挥发，低度酒度数本来就不高，挥发之后酒的度数就会更低；另外，低度酒杀菌能力较弱，存储不当会导致微生物易在酒体中繁殖。 2. 白酒香型分类新中国成立之后，为了加强对白酒市场的管理，提高白酒质量，通过对白酒香味成分的分析（当然到现在也没弄清楚酱香型白酒的香味成分），提出了按香型对白酒分类的方案。 截止到现在，白酒的香型有十几种之多，但酱香型、浓香型、清香型这 3 种香型差不多占据了白酒市场 90% 的份额。 香型 代表酒 酱香型 茅台、郎酒、国窖 浓香型 五粮液、泸州老窖、剑南春 清香型 汾酒、二锅头 董香型 董酒 凤香型 西凤酒 兼香型 白云边 馥郁香型 酒鬼酒 米香型 三花酒 3. 酱香型白酒3.1 酱香白酒的优点为什么将酱香型白酒单独拿出来说了？一个是因为我自己爱喝（2025年更新：我现在什么酒都爱喝），另外一个原因是喝酱香型白酒的确有诸多好处。 酱香型白酒主要有以下特点： 正规酱香型白酒出厂前要经过三年以上的贮存，酒体中的易挥发物质少，对身体的刺激少。茅台酒空杯留香也和这有一定的关系。 因为易挥发物质少，酱香型的酒更适合存放，越陈越香。 酱香型白酒的酸度高、含 SOD 等物质，对软化血管，抗氧化等方面有一定的帮助。 目前还没找到可以产生酱香味的主要香味物质，所以很难通过香精、添加剂造假。 国家已经出台酱香型白酒国家标准，明确规定酱香型白酒不允许使用食用酒精及非白酒发酵生产的呈香、呈味、呈色物质，必须是使用纯粮食、固态法发酵而成。（但低端酱香酒因为成本等原有很难达使用大曲发酵）。 上面列出的酱香型酒的诸多好处都是基于适量饮酒的前提。 3.2 坤沙、碎沙、翻沙、串沙坤沙、碎沙、翻沙、串沙这些名词是专门用于酱香型白酒的工艺。“沙”指的是高粱，不是沙子。 坤沙酒“坤”是音译过来的，也叫做“捆”，表示用完整的高粱来酿酒。坤沙酒也叫捆沙酒、坤籽酒，也就是常说的正宗的酱香型白酒。严格按照传统的贵州茅台镇工艺进行生产，采用当地产的糯高粱、小麦，生产周期长达一年，出酒率低，但酒质好。需要经过很重要的“回沙“工艺，即 1 年生产、2 次投料、9 次蒸馏、8 次发酵、7 次取酒，也就是常说的 12987 生产工艺，然后还要经过三年以上的陈酿才能够出厂。在生产过程中高粱不能够粉碎，高粱的粉碎率需控制在 20% 以内。 坤沙酒生产流程非常复杂，周期长，且出酒率低，这也是茅台飞天等高端酱香型酒价格居高不下的一个原因吧。 碎沙酒碎沙工艺就是指用被完完全全粉碎的高粱来酿酒。碎沙工艺生产周期较短，出酒率高，不要经过像坤沙那么严格的”回沙“工艺，所出酒的酱香味单薄，不如坤沙那样酱香味浓郁。但较好入口，也赢得了一部分人的喜爱。市面上的中低端酱香白酒大多采用此种工艺。 翻沙酒翻沙就是利用坤沙工艺中最后一次（第 9 次）蒸馏之后废弃的酒糟，再次加入高粱和曲，重新发酵酿出来的酒。翻沙酒生产周期短，出酒率高，但品质差。这样做只是利用酒糟让酒多了一点酱香味。因为生产成本低廉，市场上很多低端酱香型酒多是用的这种方法。 串沙酒窜沙酒，也叫串香酒，也是利用坤沙工艺中最后一次（第 9 次）蒸馏之后废弃的酒糟，但是它是直接加入食用酒精蒸馏。酒质很差，成本非常低廉。这种酒不符合酱香型的国家标准，不能算酱香型白酒了。 3.3 茅台及子品牌说到酱香就不能不提茅台了，酱香型酒曾经一度也叫“茅香型酒”。“今茅已非彼茅”，茅台今天已经是一个上市公司，大集团，旗下有很多子公司，每个子公司都有自己的品牌。常见的有飞天茅台、五星茅台、茅台王子酒、茅台迎宾酒、汉酱等等，它们有贵的，也有便宜的，这也是茅台集团多品牌战略的核心，以适应各种消费层次的需求。 下图是茅台集团及其子公司的白酒类品牌： 我们常说的高端茅台指的贵州茅台酒股份有限公司生产的飞天茅台、五星茅台、茅台纪念酒、茅台生肖酒、茅台陈年酒，这些高端茅台酒大多有 43 度和 53 度 2 种度数。度数不同，价格差距很大，以飞天茅台市场价为例，43 度的差不多 900 元，53 度的将近 2400 元。 4. 如何喝酒喝酒当然是用嘴喝，这里说的喝酒一定程度上指的是品酒，但品酒是一个很专业的事情，不是一两句话可以说的清的，需要专业的知识和经验的累积，故这里使用“如何品酒”这个标题。酒是小口小口的品的，绝不是“我干了，你随意”式的喝法。下面列出我的一点喝酒的方法： 4.1 望倒入杯中看是否有酒花，是否挂杯。观察酒的颜色，如酱香型的酒会微微偏黄。 4.2 闻端起酒杯闻酒香，不同的酒有不同的香味，有时候通过香味是否纯在就可以判断一个酒的好坏。喝完之后，可以闻闻是否空杯留香等等。 4.3 咂含在口中，慢慢感受酒的气味，是柔和还是刺激；从舌尖滑到舌根，最后到喉咙；回味是否甘甜。 5. 白酒的执行标准目前，不同香型的酒执行不同的国家标准，而且有的品牌的酒还会执行其他标准，大体分为： 国家标准（GB） 地方标准（DB） 企业标准（QB） 地理标志产品标准 一般而言，国家标准是白酒厂商最低要遵守的底线，其他标准的执行要求会高于国家标准。 5.1 国家标准白酒的国家标准是由国家标准化管理委员会制定并发布的，具有强制性和指导性。 一瓶白酒的执行标准，则是保障其品质与风味的关键所在。在选购白酒时，需要留意商标上标明的该酒所执行国家标准。 GB&#x2F;T 10781.1 代表浓香型白酒 GB&#x2F;T 10781.2 代表清香型白酒 GB&#x2F;T 10781.3 代表米香型白酒 GB&#x2F;T 14867 代表凤香型白酒 GB&#x2F;T 23547 代表兼香型白酒 GB&#x2F;T 22736 代表馥郁香型白酒 GB&#x2F;T 26760 代表酱香型白酒，2025年6月1日将正式实施新的标准 GB&#x2F;T 10781.4—2024。 GB&#x2F;T 20821 针对液态法白酒的国家标准，即采用食用酒精和香精等勾兑而成的白酒 GB&#x2F;T 20822 针对固液法白酒的国家标准，即固态法白酒与液态法白酒的混合物。 这些标准对白酒的原料、生产工艺、感官指标、理化指标等方面都做出了详细规定，一定程度上确保了白酒的品质和安全性。 比如我们在选购浓香型白酒时，就要留意其是否执行的 GB&#x2F;T 10781.1 标准，如果不是，则可能酒质较差（但下面介绍的其他标准中的除外，如五粮液）。 5.2 企业标准白酒的企业标准实在太多了，无论大小酒厂都可以申请自己的企业标准。 可以在 企业标准信息公共服务平台 查询具体标准。 5.3 地理标志产品标准地理标志产品是指产自特定地域，所具有的质量、声誉或其他特性本质上取决于该产地的自然因素和人文因素，经审核批准以地理名称进行命名的产品。 地理标志产品白酒对于制曲有很严格的时间控制，而国标却没有明确规定。除了酒龄和制曲以外，地理标产品对于酿造的用粮用水以及产地的气候环境都有严格的要求。而国标产品并不会做出相应的规定。严格来讲国标只是一个行业底线，并且只是推荐执行，并没有任何强制规定，更没有比较严格的监管制度，完全靠企业自觉遵守。 白酒地理标志产品，为了更好和其他标准区分，一般在白酒包装上会印着的绿色雄鸡地图标识。 地理标志产品执行标准都比较严苛，执行标准基本都在国家标准（GB）、地方标准（DB）和企业标准（QB）之上。 目前常见的白酒地理标志产品标准有18个（横线后面的表示制定年份）： 贵州茅台酒：GB&#x2F;T18356-2007 国窖1573：GB&#x2F;T22041-2008 剑南春酒：GB&#x2F;T19961-2005 五粮液酒：GB&#x2F;T22211-2008 古井贡酒：GB&#x2F;T19327-2007 西凤酒：GB&#x2F;T19508-2007 玉泉酒：GB&#x2F;T21261-2007 水井坊酒：GB&#x2F;T18624-2007 洋河大曲：GB&#x2F;T22046-2008 口子窖酒：GB&#x2F;T19328-2007 舍得白酒：GB&#x2F;T21820-2008 沱牌白酒：GB&#x2F;T21822-2008 互助青稞酒：GB&#x2F;T19331-2007 景芝神酿酒：GB&#x2F;T22735-2008 道光廿五贡酒：GB&#x2F;T19329-2007 牛栏山二锅头：GB&#x2F;T21263-2007 泸州老窖特曲酒：GB&#x2F;T22045-2008 严东关五加皮白酒：GB&#x2F;T21821-2008","tags":["酒"],"categories":["杂念"]},{"path":"/404.html","content":""},{"title":"关于","path":"/author/index.html","content":"没有什么特别的头衔，也没被归为某一类别，除了不劳而获的姓名、性别和年龄，还真是一片空白。 我所知的，是我无限的无知。 意义在哪里在这个人心浮躁、短视频横行的年代，能静下心看书、看文字的人越来越少了，仅剩的一点流量也被知乎、CSDN、掘金等平台所蚕食殆尽，个人博客几乎等同于 1 IP 站。不过没关系，常说“时尚是个轮回”，我相信人生也是个轮回，生活习惯亦是个轮回。 我把这里当成我的一片自留地，我在这里记录知识，方便自己回顾和查阅，三年前写的东西，三年后重新感悟，又是一个完全不同的状态，我在这里写下了自己的所见所想，我还在这里转载一些自己喜欢的文章…… 我也希望通过码字输出的形式使自己静下来，系统的学习和思考，逼迫自己完善知识体系，将知识由点连成线，再从线变成面。 我以为能够通过书本、网络所学习到的知识本就没有稀缺性，它一直在那里，只是隔着一层面纱罢了。在没有揭开面纱之前，会给人一种高深而神秘的感觉，一旦掌握，揭开了面纱，也就平平无奇了。我把自己掌握的知识，加上个人的理解分享出来，希望能通过这种方式来帮助他人揭开知识的面纱。 版权声明本站所有内容除少数标明【转载】的以外，均为原创，我无法阻止你复制，但请注明出处，否则你会收到我诚挚的咒骂！ 其他123Email: smart7178@163.comGithub: https://github.com/winsoft666/CSDN: https://blog.csdn.net/china_jeffery 再见！"},{"title":"实用网址导航","path":"/sites/index.html","content":"在这里汇集了一些我认为比较有用、好玩的网站会不定期的更新，其中有些网站在国内可能无法访问。 资讯CCTV大数据导航 - 聚合了各个数据指标网站虫洞-随机访问十年之约成员博客 论坛Hacker News - 面向全球的技术类新闻聚合社区v2ex - 讨论网络和技术话题的中文社区cracking - 面向全球的黑客论坛，提供有关黑客技术、网络安全和计算机犯罪的讨论和资源吾爱破解 - 国内软件破解论坛，需要注册码才可以注册看雪论坛 - 国内专注于PC、移动、智能设备安全研究及逆向工程的开发者社区OpenRCE - Open Reverse Code Engineering 为逆向工程领域感兴趣的人员提供一个共享的学习环境 影视&#x2F;音乐vidhub - 免费的在线看剧网站硬核影视指南 - 专注于提供高清影视资源的网站人人电影网 - 免费电影、电视剧、动漫分享网站，需要通过网盘下载蚂蚁4K - 专注于提供高质量4K高清电影资源的网站SeedHub - 专注分享优质影视资源的网站悠悠MP4 - 主打迅雷下载的影视资源分享网站果核音乐 - 音乐分享网站，提供各种音乐资源的在线试听和下载MyFreeMP3 - 音乐在线播放和下载 书籍&#x2F;阅读Z-Library - 免费的数字图书馆题目自拟的书库 - 站长分享的一些他收集整理的书籍，分类未知，适合探索参考网 - 过期杂志阅读平台飞库文学网 - 提供各种类型的小说，可在线阅读和下载汇书网 - 提供各种类型电子书下载的平台搬书匠 - 专门提供计算机编程类的书籍 软件下载小众软件大眼仔老殁softoroom - 老毛子（俄语）的软件资源网站，很多破解软件都是出自此处 图片搜图导航 - 提供一站式快速搜索图像服务，还包含字体下载、在线设计工具等SVG Repo - 免费的矢量图下载网站 字体自由字体 - 汇聚全网的免费字体喵闪字库 - 提供免费商用和免版权字体下载 网盘搜索爱盼-网盘资源搜索口袋云小云搜索猫狸盘搜 在线病毒扫描VirScanVirusTotal腾讯哈勃分析系统 在线工具全景故宫 - 在线3D全景游览故宫photopea - 网页版的Photoshop火山在线翻译 - 字节跳动旗下的在线翻译网站，免登录LogoCook - 在线免费生成Logo的网站，通过简单的属性选项即可创造出个性化的LogoLook Scanned - 能够让 PDF 看起来就像是扫描件一样的纯前端网站，已开源telegra - 匿名的免费文章发布网站，支持文字和图片PhotoToAnime - 将照片转换成动漫风格，每天可以生成3次网络剪切板 - 数据暂存和传送服务，免登录，最大50MB的内容，支持密码保护，且国内网络可访问Catbox - 数据暂存和传送服务，免登录，最大200MB的内容，但国内网络无法访问asciiflow - 绘制完全由字符组成的流程图，适合绘制粘贴到注释中的流程图"},{"title":"友链","path":"/friends/index.html","content":"技术流Chaoszhu'Blog涛叔子舒的博客SONG'Blog鹏叔的技术博客往东行 最爱文艺范Yalan's Life 欢迎友链，大家一起玩起来。 本站友链信息如下： 网站名称：独钓寒江雪网站地址：https://jiangxueqiao.com网站图标：https://jiangxueqiao.com/images/logo.png网站简介：孤舟蓑笠翁，独钓寒江雪。"}]