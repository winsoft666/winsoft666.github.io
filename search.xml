<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一键启动神器之1key.run</title>
      <link href="/2023/07/03/yi-jian-qi-dong-shen-qi-zhi-1key-run/"/>
      <url>/2023/07/03/yi-jian-qi-dong-shen-qi-zhi-1key-run/</url>
      
        <content type="html"><![CDATA[<h1 id="一、1key-run"><a href="#一、1key-run" class="headerlink" title="一、1key.run"></a>一、1key.run</h1><p><img src="https://static.1key.run/blog/img/1keyrun_logo.png"></p><p><a href="https://1key.run/">1key.run</a>既是产品官网，亦是产品名称。</p><p>顾名思义，主打一键启动，可以一键启动本地应用、网页搜索，并内置了一些实用功能如日历、科学计算、截图、Spy++等。</p><h1 id="二、产品特色"><a href="#二、产品特色" class="headerlink" title="二、产品特色"></a>二、产品特色</h1><p>产品特色为三个字就是：轻、快、爽。</p><h2 id="2-1-轻"><a href="#2-1-轻" class="headerlink" title="2.1 轻"></a>2.1 轻</h2><p>“轻”为轻量化。减少系统资源的占用，不采用臃肿的Electron或CEF等Web技术架构，所有功能都采用纯C++ Native开发。<br>软件安装包仅有15MB（事实上还可以更小），运行时仅占用12MB内存。</p><h2 id="2-2-快"><a href="#2-2-快" class="headerlink" title="2.2 快"></a>2.2 快</h2><p>“快”为快速运行、快速上手。</p><p><strong>1. 输入本地应用的简写（如拼音首字母）可以快速启动该应用。</strong><br>输入<code>szqm</code>:<br><img src="https://static.1key.run/blog/img/1keyrun-1.jpg"></p><p>默认会选中第一项，也可以使用<code>Alt + 数字</code>快捷键快速定位到其他项。</p><p>按<code>Enter</code>键运行当前项，还可以在右键菜单中可以选择<code>“以管理员权限运行”</code>。</p><p><strong>2. 输入数学表达式，可以快速的计算该表达式的结果。</strong></p><p>输入<code>sin(90)+cos(45)+(2+3)*4</code>：<br><img src="https://static.1key.run/blog/img/1keyrun-2.jpg"></p><p>科学计算器为1key.run的内置功能，在表达式计算结果项上按<code>Enter</code>键可以进入该功能详情页：<br><img src="https://static.1key.run/blog/img/1keyrun-3.jpg"></p><p>也可以输入<code>kxjsq</code>启动该功能，按<code>Esc</code>键可以退出当前功能。</p><p><strong>3. 剪切板检测</strong><br>当1key.run被唤起时，会自动检查剪切板中的数据是否可以被1key.run的某个功能模块所使用。如复制<code>qq</code>到剪切板，使用快捷键<code>Alt+空格</code>唤起1key.run，会自动显示计算结果。<br><img src="https://static.1key.run/blog/img/1keyrun-4.jpg"></p><p><strong>4. 快速上手</strong><br>想到则输入，所输即所得。不用记忆繁琐的快捷键，只需知道三个快捷键即可上手使用：</p><ul><li><code>Alt + 空格</code>唤起1key.run</li><li><code>Enter</code>为执行当前选择项</li><li><code>Esc</code>为退出当前功能</li></ul><h1 id="2-3-爽"><a href="#2-3-爽" class="headerlink" title="2.3 爽"></a>2.3 爽</h1><p>完全免费，卸载无残留。</p><blockquote><p>免费版本和Pro版本仅在更新通道上有区别，Pro版本可以使用稳定的更新通道。<br>在功能方面，免费版本和Pro版本没有任何区别。</p></blockquote><h1 id="三、功能介绍"><a href="#三、功能介绍" class="headerlink" title="三、功能介绍"></a>三、功能介绍</h1><p>1key.run将功能划分成了不同的功能模块，包含如下功能模块：</p><ul><li>快速启动</li><li>网页搜索</li><li>科学计算器</li><li>颜色拾取</li><li>日历</li><li>截图</li><li>SpyWindow</li><li>JSON格式化</li><li>XML格式化</li></ul><p>可以在1key.run主搜索框输入功能模块支持的数据来唤起该功能，如<code>1+2+3</code>为科学计算器支持的数据，<code>{"a":1}</code>为JSON格式化支持的数据。</p><p>也可以直接输入功能模块的触发关键字（可以在“设置”中自定义）来启动该功能，如输入<code>qs</code>触发颜色拾取功能等。</p><h2 id="3-1-快速启动"><a href="#3-1-快速启动" class="headerlink" title="3.1 快速启动"></a>3.1 快速启动</h2><p>快速启动可以用来启动本地应用，支持中文拼音简写、分词，如：</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">有道翻译 -&gt; ydfyVisual Studio Code -&gt; vscWinHex -&gt; wh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当搜索结果不足时，会自动添加网页搜索引擎到列表的末尾。</p><p>可以在“设置”中自定义需要检索和监控的文件夹，1key.run会自动检索该文件夹及子文件夹下的可执行项(如.exe、.bat文件)，并添加到快速启动中。</p><p>当文件夹中有文件新增或删除时，1key.run会自动监控到这些改变，添加到启动项或从中移除。</p><p>如果某个目录下文件或子文件夹太多，检索和监控会消耗比较多的系统资源，可以在排除该目录。</p><p>最后，我们也可以添加单个启动项。</p><p><img src="https://static.1key.run/blog/img/1keyrun-5.jpg"></p><h2 id="3-2-网页搜索"><a href="#3-2-网页搜索" class="headerlink" title="3.2 网页搜索"></a>3.2 网页搜索</h2><p>1key.run内置了百度、谷歌、必应、百度百科、Microsoft Docs、Github等主流搜索引擎，输入对的引擎名或简写，可以快速定位到该搜索引擎。</p><p>如输入<code>baidu</code>并回车，定位并选择百度搜索引擎：<br><img src="https://static.1key.run/blog/img/1keyrun-6.jpg"></p><p>输入需要搜索的内容，回车即可搜索。<br><img src="https://static.1key.run/blog/img/1keyrun-7.jpg"></p><p>可以在“设置”中管理搜索引擎：<br><img src="https://static.1key.run/blog/img/1keyrun-8.jpg"></p><h2 id="3-3-科学计算器"><a href="#3-3-科学计算器" class="headerlink" title="3.3 科学计算器"></a>3.3 科学计算器</h2><p>提供传统科学计算器所拥有的全部功能，并且使用起来更加方便。</p><h2 id="3-4-颜色拾取"><a href="#3-4-颜色拾取" class="headerlink" title="3.4 颜色拾取"></a>3.4 颜色拾取</h2><p>实时提取鼠标位置的颜色值，实时显示RGB和十六进制颜色值。</p><p>与其他取色软件不同的是，1key.run提供的颜色拾取功能支持通过方向键进行像素级的移动。</p><p><img src="https://static.1key.run/blog/img/1keyrun-9.jpg"></p><h2 id="3-5-SpyWindow"><a href="#3-5-SpyWindow" class="headerlink" title="3.5 SpyWindow"></a>3.5 SpyWindow</h2><p>微软Spy++的增强版本，提供Spy++全部功能的同时添加了更多实用功能。</p><p>功能更强大，使用起来更方便。</p><p><img src="https://static.1key.run/blog/img/1keyrun-10.jpg"></p><h2 id="3-6-日历"><a href="#3-6-日历" class="headerlink" title="3.6 日历"></a>3.6 日历</h2><p>传统日历系统通常只显示阴历的“日”，而不显示“月”，有时为了查看当前阴历的月份不得前后翻阅，非常不便。<br>1key.run提供的轻量级的日历解决了上述问题，使用起来会更加方便，无需联网即可使用。</p><p><img src="https://static.1key.run/blog/img/1keyrun-11.jpg"></p><h2 id="3-7-截图"><a href="#3-7-截图" class="headerlink" title="3.7 截图"></a>3.7 截图</h2><p>1key.run内置的截图功能，支持对窗口、矩形进行截图，实时显示截取区域坐标和尺寸。<br>输入<code>jt</code>可以唤起该功能，也可以在“设置”中自定义全局快捷键。</p><h2 id="3-8-JSON格式化"><a href="#3-8-JSON格式化" class="headerlink" title="3.8 JSON格式化"></a>3.8 JSON格式化</h2><p><img src="https://static.1key.run/blog/img/1keyrun-12.jpg"></p><h2 id="3-9-XML格式化"><a href="#3-9-XML格式化" class="headerlink" title="3.9 XML格式化"></a>3.9 XML格式化</h2><p><img src="https://static.1key.run/blog/img/1keyrun-13.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 我的产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 1key.run </tag>
            
            <tag> 一键启动 </tag>
            
            <tag> 截图 </tag>
            
            <tag> 科学计算器 </tag>
            
            <tag> 网页搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++构造函数排雷</title>
      <link href="/2023/06/30/c-gou-zao-han-shu-pai-lei/"/>
      <url>/2023/06/30/c-gou-zao-han-shu-pai-lei/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一、默认构造函数"><a href="#一、默认构造函数" class="headerlink" title="一、默认构造函数"></a>一、默认构造函数</h1><h2 id="1-1-什么是默认构造函数？"><a href="#1-1-什么是默认构造函数？" class="headerlink" title="1.1 什么是默认构造函数？"></a>1.1 什么是默认构造函数？</h2><p>我们一般会认为默认构造函数就是编译器自动生成的那个构造函数，其实这种理解不全面。<br><strong>准确的说，默认构造函数就是在调用时不需要显示地传入实参的构造函数。</strong>根据这个原则，下面2种构造函数都是默认构造函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Sample</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">// 默认构造函数。</span><span class="token function">Sample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// do something</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Sample</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">// 默认构造函数。虽然有形参，但有默认值，调用的时候可以不显示的传入实参。</span><span class="token function">Sample</span><span class="token punctuation">(</span><span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// do something</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-默认构造函数调用时机"><a href="#1-2-默认构造函数调用时机" class="headerlink" title="1.2 默认构造函数调用时机"></a>1.2 默认构造函数调用时机</h2><p>如果定义一个对象时没有使用初始化式，编译器就会使用默认构造函数。如：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">Sample s;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-3-编译器何时生成默认构造函数"><a href="#1-3-编译器何时生成默认构造函数" class="headerlink" title="1.3 编译器何时生成默认构造函数"></a>1.3 编译器何时生成默认构造函数</h2><p>有一句很经典的话可以用来回答这个问题：<strong>惟有默认构造函数”被编译器需要“的时候，编译器才会生成默认构造函数。</strong></p><p>那我们只需知道什么时候“被编译器需要”，就可以知道什么情况下会生成默认构造函数了。下面几种情况下，编译需要生成默认构造函数：</p><ol><li>当该类的<code>类对象数据成员</code>有默认构造函数时。</li><li>当该类的基类有默认构造函数时。</li><li>当该类的基类为虚基类时。</li><li>当该类有虚函数时。</li></ol><h2 id="1-4-注意事项"><a href="#1-4-注意事项" class="headerlink" title="1.4 注意事项"></a>1.4 注意事项</h2><p><strong>1. 避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在</strong></p><p><code>无参数的默认构造函数</code>和<code>带缺省参数的默认构造函数</code>同时存在时，编译器会产生二义性，从而生成编译错误。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Sample</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">// 默认构造函数</span><span class="token function">Sample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// do something</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sample()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 默认构造函数</span><span class="token function">Sample</span><span class="token punctuation">(</span><span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// do something</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sample(int m = 10)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Sample s<span class="token punctuation">;</span> <span class="token comment">// error C2668: “Sample::Sample”: 对重载函数的调用不明确</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 使用无参构造函数创建对象时，不应在对象名后面加上括号</strong></p><p>使用无参构造函数创建对象时，不应在对象名后面加上括号，否则会产生编译警告<code>“warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?)”</code>。因为编译器误认为<code>Sample s();</code>语句时要声明返回值为<code>Sample</code>对象的函数<code>s</code>，而又没找到函数<code>s</code>的定义，所以产生了警告。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Sample</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">// 默认构造函数</span><span class="token function">Sample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// do something</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sample()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Sample <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、构造函数初始化列表"><a href="#二、构造函数初始化列表" class="headerlink" title="二、构造函数初始化列表"></a>二、构造函数初始化列表</h1><h2 id="2-1-何为构造函数初始化列表"><a href="#2-1-何为构造函数初始化列表" class="headerlink" title="2.1 何为构造函数初始化列表"></a>2.1 何为构造函数初始化列表</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Sample</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">// 构造函数内部赋值</span><span class="token function">Sample</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>  <span class="token punctuation">{</span>a_ <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 构造函数初始化列表</span><span class="token function">Sample</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a_</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> a_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中，<code>Sample</code>类的2个构造函数的功能是一样的，都是初始化成员变量<code>a_</code>，区别在于一个采用的是<code>构造函数内部赋值</code>的方式来初始化的，另一个采用的是<code>构造函数初始化列表</code>初始化列表的方式来初始化的。</p><h2 id="2-1-何时必须使用初始化列表"><a href="#2-1-何时必须使用初始化列表" class="headerlink" title="2.1 何时必须使用初始化列表"></a>2.1 何时必须使用初始化列表</h2><p>如果按照上面所说的，既然2种初始化成员变量的方式所起得作用是一样的，那么在哪些情况下<strong>必须</strong>使用<code>构造函数初始化列表</code>的了？<br>下面2种情况的成员变量必须使用<code>构造函数初始化列表</code>的方式来初始化：</p><ol><li>成员变量是const常量。</li><li>成员变量是引用类型。</li></ol><p>下面例子演示了成员变量是<code>const常量</code>和<code>引用类型</code>时，如何初始化它们：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Sample</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Sample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">kCount</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">name_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"jeff"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name_<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> kCount<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="2-3-初始化列表的顺序问题"><a href="#2-3-初始化列表的顺序问题" class="headerlink" title="2.3 初始化列表的顺序问题"></a>2.3 初始化列表的顺序问题</h2><p>使用<code>构造函数初始化列表</code>进行成员变量初始化时，要注意成员变量的初始化顺序。<br>举个例子来说明，现有类<code>SeqSample</code>有3个成员变量<code>a_, b_, c_</code>，构造函数被设计为将<code>a_, b_, c_</code>都初始化为<code>m</code>，也就是<code>a_ == b_ == c_ == m</code>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SeqSample</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">SeqSample</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a_</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b_</span><span class="token punctuation">(</span>a_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">c_</span><span class="token punctuation">(</span>b_<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> b_<span class="token punctuation">;</span><span class="token keyword">int</span> a_<span class="token punctuation">;</span><span class="token keyword">int</span> c_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>SeqSample <span class="token function">ss</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过调试器观察到执行构造函数初始化之后，成员变量<code>a_, b_, c_</code>的值分别为：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">b_ = -858993460a_ = 1c_ = -858993460<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>而不是我们期望的<code>a_ = 1  b_ = 1 c_ = 1</code>。</p><p>出现这种问题的原因在于：<strong>编译器对构造函数初始化列表中的变量进行初始化的时候，不是按照变量初始化列表中的顺序来进行初始化的，而是按照变量在类中的声明顺序来初始化的。</strong></p><p>所以，在初始化列表中的变量有依赖关系时（如上面的<code>b_</code>依赖于<code>a_</code>的初始化结果），要特别注意这种情况。</p><h2 id="2-4-初始化列表的另一个好处"><a href="#2-4-初始化列表的另一个好处" class="headerlink" title="2.4 初始化列表的另一个好处"></a>2.4 初始化列表的另一个好处</h2><p>先模糊的把这个好处说出来，不太明白的，可以看下面的示例：<br><strong>若成员变量是类对象，则使用构造函数的初始化列表可以减少一次默认构造函数的调用。</strong></p><p>测试代码如下（声明了一个<code>Apple类</code>，一个<code>Test类</code>，Test类中有2个Apple对象<code>apple1_</code>, <code>apple2_</code>，唯一不同的是，<code>apple1_</code>通过初始化列表来初始化，<code>apple2_</code>通过函数体中的赋值语句来初始化）：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">class Apple {public:Apple() {printf("默认构造函数\n");}Apple(const Apple &amp;that) {printf("复制构造函数\n");}Apple&amp; operator = (const Apple&amp;that) {printf("赋值运算符重载\n");return *this;}};class Test {public:Test(const Apple &amp;apple) : apple1_(apple) {apple2_ = apple;}private:Apple apple1_;Apple apple2_;};int main(){Apple apple;Test t(apple);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">默认构造函数复制构造函数默认构造函数赋值运算符重载<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>4行输出分别由不同的语句产生，如图：<br><img src="https://static.1key.run/blog/img/cpp-gzhs-1.png"></p><p><code>apple1_(apple)</code>直接执行的复制构造函数，所以只产生一行输出；<br>而<code>apple2_ = apple;</code>却是先使用默认构造函数构造了一个apple2_对象，然后再通过赋值运算符将apple的内容更新到apple2_中，所以产生了2行输出。</p><h2 id="2-5-构造函数初始化列表的异常捕获"><a href="#2-5-构造函数初始化列表的异常捕获" class="headerlink" title="2.5 构造函数初始化列表的异常捕获"></a>2.5 构造函数初始化列表的异常捕获</h2><p>构造的函数的初始化列表也可以使用异常捕获，具体使用方式如下：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">class Foo {public:Foo::Foo(int n)try :size(n), array(new int[n]) {//...  }catch (const std::bad_alloc&amp; e) {printf("%s\n", e.what());}private:int size;int *array;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 默认构造函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解C++虚函数</title>
      <link href="/2023/06/30/shen-ru-li-jie-c-xu-han-shu/"/>
      <url>/2023/06/30/shen-ru-li-jie-c-xu-han-shu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一-虚函数介绍"><a href="#一-虚函数介绍" class="headerlink" title="一. 虚函数介绍"></a>一. 虚函数介绍</h1><p>C++中的虚函数主要是用来实现多态（面向对象的三大特性之一）的。<br>下面是一个实现多态的<strong>错误</strong>例子：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 基类</span><span class="token comment">//</span><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Base::Base()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Base::Name()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 派生类</span><span class="token comment">//</span><span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Derive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Derive::Derive()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">Derive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Derive::Name()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Base<span class="token operator">*</span> pBase <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Derive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pBase<span class="token operator">-&gt;</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">delete</span> pBase<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">Call Base::Base()Call Derive::Derive()Call Base::Name()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出内容的第3行为：<code>Call Base::Name()</code>，并不是期望的<code>Call Derive::Name()</code>。<br>因为<code>void Name()</code>函数不是虚函数，所以<code>pBase-&gt;Name()</code>调用的是基类的Name()函数，并不是我们所期望的派生类Derive的Name()函数。 如果将基类中<code>void Name()</code>改成虚函数<code>virtual void Name()</code>，程序输出就会和我们期望的一样：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 基类</span><span class="token comment">//</span><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Base::Base()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Base::~Base()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Base::Name()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、-虚析构函数"><a href="#二、-虚析构函数" class="headerlink" title="二、 虚析构函数"></a>二、 虚析构函数</h1><p><code>virtual</code>不仅可以修饰成员函数，也可以用来修饰析构函数，也就是我们常说的<code>虚析构函数</code>。 下面的例子中的基类的析构函数没有使用virtual修饰，我们先执行程序，观察运行结果（类似上面的程序，只是在析构函数中多加入了输出打印语句）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 基类</span><span class="token comment">//</span><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Base::Base()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Base::~Base()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Base::Name()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 派生类</span><span class="token comment">//</span><span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Derive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Derive::Derive()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">Derive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Derive::~Derive()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Derive::Name()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Base<span class="token operator">*</span> pBase <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Derive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pBase<span class="token operator">-&gt;</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">delete</span> pBase<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Call Base::Base()Call Derive::Derive()Call Derive::Name()Call Base::~Base()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从输出内容的第4行可以看到，执行<code>delete pBase</code>语句只有基类Base类的析构函数被调用了，而派生类Derive的析构函数却没有被调用。如果此时派生类Derive中有需要在析构函数执行的代码（如内存释放，句柄关闭等），这些代码将不会执行，有可能就会造成内存泄漏、句柄泄漏、逻辑错误等问题。</p><p>正确的做法是：<strong>使用virtual修饰基类的析构函数</strong>，即虚析构函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 基类</span><span class="token comment">//</span><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Base::Base()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Base::~Base()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Call Base::Name()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时程序输出为：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Call Base::Base()Call Derive::Derive()Call Derive::Name()Call Derive::~Derive()Call Base::~Base()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用<code>delete pBase</code>之后，先执行了派生类Derive的析构函数，然后执行基类Base的析构函数。</p><blockquote><p>在《C++API设计》一书中有明确的说到：“如果希望一个类可以被继承，那么就应该将它的析构函数使用virtual修饰；反过来可以理解为，如果一个类的析构函数不是虚的，那么这个类是被设计为不可继承的。”</p></blockquote><h1 id="三、虚函数的实现原理"><a href="#三、虚函数的实现原理" class="headerlink" title="三、虚函数的实现原理"></a>三、虚函数的实现原理</h1><h2 id="3-1-实现原理"><a href="#3-1-实现原理" class="headerlink" title="3.1 实现原理"></a>3.1 实现原理</h2><p>C++的虚函数是使用虚函数表（即<code>指针数组</code>，也就是<code>指针的指针</code>）来实现的。 只要在类中声明了虚函数，编译器就会在类的对象中自动生成一个虚函数表，但一个<strong>对象</strong>最多只有一个虚函数表，不管这个类声明了多少个虚函数。虚函数表是针对于类的对象的。</p><h2 id="3-2-虚函数表（指针）存储位置"><a href="#3-2-虚函数表（指针）存储位置" class="headerlink" title="3.2 虚函数表（指针）存储位置"></a>3.2 虚函数表（指针）存储位置</h2><p>不同的编译器将自动生成的虚函数表指针存放的位置不同，有的存放在类对象所占内存的起始位置，有的存放在类对象所占内存的末尾。 可以通过如下代码来判断：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 返回值： ture  - 虚函数指针存放在对象内存起始位置</span><span class="token comment">//         false - 虚函数指针存放在对象内存末尾位置</span><span class="token comment">//</span><span class="token keyword">bool</span> <span class="token function">VirtualTableAtFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">class</span> <span class="token class-name">_C</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">char</span> _i<span class="token punctuation">;</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">_f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>_C c<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>_i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> p1 <span class="token operator">!=</span> p2<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过MSVC2015编译运行，返回<code>true</code>, 说明MSVC编译器是将虚函数表指针放置在类对象内存的起始位置处。</p><h2 id="3-3-虚函数表存储方式"><a href="#3-3-虚函数表存储方式" class="headerlink" title="3.3 虚函数表存储方式"></a>3.3 虚函数表存储方式</h2><p>既然知道了C++是使用虚函数表的形式来实现虚函数的，那个虚函数表中的数据是以何种形式来存储的了？ 现在我们根据类的继承方式的不同来分别说明。</p><h3 id="3-3-1-单继承无重载"><a href="#3-3-1-单继承无重载" class="headerlink" title="3.3.1 单继承无重载"></a>3.3.1 单继承无重载</h3><p>类结构如图，Derive继承于Base，但Derive没有重载Base类中的任何函数。</p><blockquote><blockquote><p>需要说明的是，函数f(), g(), h(), f1(), g1(), h1() 均为虚函数，这个在图上没有明确的写出来，后面的图也是一样。</p></blockquote></blockquote><p><img src="https://static.1key.run/blog/img/cpp-virtual-table-1.jpg"></p><p>这时<code>Base b;</code> 对象b的虚函数表为：<br><img src="https://static.1key.run/blog/img/cpp-virtual-table-2.jpg"></p><p><code>Derive d;</code> 对象d的虚函数表为：<br><img src="https://static.1key.run/blog/img/cpp-virtual-table-3.jpg"></p><h3 id="3-3-2-单继承有重载"><a href="#3-3-2-单继承有重载" class="headerlink" title="3.3.2 单继承有重载"></a>3.3.2 单继承有重载</h3><p>Derive重载Base类中的f()函数：<br><img src="https://static.1key.run/blog/img/cpp-virtual-table-4.jpg"></p><p>这时<code>Base b;</code> 对象b的虚函数表不变，无论继承于它派生类如何重载，都不会影响基类的虚函数：<br><img src="https://static.1key.run/blog/img/cpp-virtual-table-5.jpg"></p><p><code>Derive d;</code> 对象d的虚函数表为：<br><img src="https://static.1key.run/blog/img/cpp-virtual-table-6.jpg"></p><p>派生类中重载基类的f()函数指针替换了原来基类中虚函数Base::f()的指针； 派生类中其他的虚函数存放在基类虚函数之后。</p><h3 id="3-3-3-多继承无重载"><a href="#3-3-3-多继承无重载" class="headerlink" title="3.3.3 多继承无重载"></a>3.3.3 多继承无重载</h3><p><img src="https://static.1key.run/blog/img/cpp-virtual-table-7.jpg"></p><p>此时，<code>Derive d;</code> 对象d的虚函数表为：<br><img src="https://static.1key.run/blog/img/cpp-virtual-table-8.jpg"></p><p><strong><code>派生类自己的虚函数存放在第一个基类的虚函数表的最后面。</code></strong></p><h3 id="3-3-4-多继承有重载"><a href="#3-3-4-多继承有重载" class="headerlink" title="3.3.4 多继承有重载"></a>3.3.4 多继承有重载</h3><p><img src="https://static.1key.run/blog/img/cpp-virtual-table-9.jpg"></p><p>此时，<code>Derive d;</code> 对象d的虚函数表为：<br><img src="https://static.1key.run/blog/img/cpp-virtual-table-10.jpg"></p><h1 id="四、虚函数表的应用"><a href="#四、虚函数表的应用" class="headerlink" title="四、虚函数表的应用"></a>四、虚函数表的应用</h1><p>我们知道在C++中要调用类的私有方法，我们可以使用友员（<code>friend</code>）的方式。但其实如果我们知道类的定义，完全可以根据该类对象的内存布局来直接调用它的私有函数。</p><p>下面介绍如何使用<code>虚函数表</code>的方式来调用该类的<code>私有虚函数</code>。</p><p>现有如下<code>Test</code>类，提供了一个私有虚函数<code>virtual void Func()</code>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">virtual</span><span class="token operator">~</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Private Function\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们使用虚函数表来调用<code>Func</code>成员函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>PFN_Func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Test t<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token operator">*</span>VirtualTable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> FuncAddr <span class="token operator">=</span> VirtualTable<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>PFN_Func pfnFunc <span class="token operator">=</span> <span class="token punctuation">(</span>PFN_Func<span class="token punctuation">)</span>FuncAddr<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pfnFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">pfnFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们知道虚函数表其实就是一个二维数组。因为示例中的<code>Test</code>类没有继承于其他类，所以第一维只有一个元素；又因<code>Test</code>类有2个虚函数，故第二维有2个元素，且<code>Func</code>排在第二个，所以用<code>VirtualTable[0][1]</code>来取<code>Func</code>函数地址。</p><p>因为该示例运行在MSVC编译器环境，所以默认认为虚函数表位于类对象内存布局的起始位置，故直接使用了<code>unsigned long **VirtualTable = (unsigned long **)(&amp;t);</code>。<br>严谨的做法应该是先判断虚函数表是否位于对象的内存布局起始位置。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtual </tag>
            
            <tag> 虚函数表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高速文件下载器的实现</title>
      <link href="/2023/06/30/gao-su-wen-jian-xia-zai-qi-de-shi-xian/"/>
      <url>/2023/06/30/gao-su-wen-jian-xia-zai-qi-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<p>我们下载文件时通常会使用浏览器或者迅雷这样的下载工具，这些工具大多具有高速下载（下载速度快）、断点续传（可以暂停之后继续下载）等特性。</p><p>现在我们自己开发的应用软件中也需要支持这些特性，我们该如何设计和实现了？本文主要围绕这一问题进行论述，并在文章最后分享了作者自己开发的高速文件下载库。</p><p>首先，我们将一个完善的文件下载库需要具有的特性列举出来：</p><ol><li>多线程分片下载</li><li>断点续传</li><li>磁盘缓存</li><li>最高下载速率限制及实时下载速率反馈（可选）</li><li>多协议支持，跨平台（可选）</li></ol><h1 id="1-多线程分片下载"><a href="#1-多线程分片下载" class="headerlink" title="1. 多线程分片下载"></a>1. 多线程分片下载</h1><p>Chrome浏览器和迅雷能实现高速下载的核心就是多线程分片下载（这里忽略迅雷的离线加速等技术），以HTTP协议为例，HTTP协议支持在请求头中指明需要请求数据的<code>起始</code>和<code>结束</code>位置。我们可以开启多个线程同时进行不同的HTTP请求，这些请求分别请求同一文件的不同位置，我们将每个HTTP请求的内容称为<code>“片”</code>，在文件的所有片下载完成之后，我们再进行片的合并。</p><p>libcurl中可以通过如下方式指定请求文件的某一区域：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">curl_easy_setopt</span><span class="token punctuation">(</span>curl_<span class="token punctuation">,</span> CURLOPT_RANGE<span class="token punctuation">,</span> <span class="token string">"1024-2048"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何确定分片数量以及每片大小？文件分片有2种策略：</p><ol><li>分片数量固定<br> 除最后一片外，<code>每片的Size</code> = <code>文件总Size</code> / <code>分片Num</code></li><li>分片尺寸固定<br> <code>分片Num</code> = <code>文件总Size</code> / <code>每片的Size</code>，如果不能整除，还需要新建一个分片，将余数放到该分片中</li></ol><p>无论采用哪一种分片策略，在确定分片Num和每片Size之前，我们都需要先向文件服务器发起一个请求来获取原始文件总Size。</p><p><img src="https://static.1key.run/blog/img/file-download-1.png"></p><h1 id="2-断点续传"><a href="#2-断点续传" class="headerlink" title="2. 断点续传"></a>2. 断点续传</h1><p>试想我们正在下载一个4G大小的文件，下载到一半的时候，忽然因为某些原因需要中止下载，等可以再次下载的时候，却不能继续上次的下载进度进行下载，那岂不是让人很抓狂。断点续传功能就是来解决这种问题的，虽然目前市场上的下载器都支持这些功能，但我们需要自己开发下载器的话，还是不得不自己来实现这个功能的。</p><p>断点续传原理主要是将已下载的数据信息（偏移、大小等）记录到某个文件中（我们称之为索引文件），下次下载前读取该文件中已下载信息，跳过已下载的内容，直接下载未下载的数据。</p><p>断点续传一般都会和多线程分片下载结合使用。</p><h1 id="3-磁盘缓存"><a href="#3-磁盘缓存" class="headerlink" title="3. 磁盘缓存"></a>3. 磁盘缓存</h1><p>文件下载中涉及的磁盘缓存都是磁盘的写缓存，主要是为了避免频繁的对磁盘进行写操作，降低磁盘IO的效率。</p><p>原理：将网络下载数据存入预先分配好的内存缓冲区，待内存缓冲区满之后，再一次性写入磁盘。</p><p>关于内存缓冲区，建议采用双缓冲机制，因为磁盘写入操作是一个相对耗时的操作，在将缓冲区写入磁盘时，该缓冲区是禁止写入的，因而此时网络下载的数据写入缓冲区将被阻塞，从而影响下载速率。</p><h1 id="4-最高下载速率限制及实时下载速率反馈"><a href="#4-最高下载速率限制及实时下载速率反馈" class="headerlink" title="4. 最高下载速率限制及实时下载速率反馈"></a>4. 最高下载速率限制及实时下载速率反馈</h1><p>最高下载速率限制有助于减少用户电脑带宽占用，而实时下载速率反馈可以让用户看到实时的下载速度。</p><p>因为采用的是多线程下载，假如最高下载速率限制为N，则每个线程的最大下载速率为: <code>N / 线程Num</code>，但需要注意的是，如果当前活跃的线程数少于初始线程数时（如有的线程已经下载完了），需要重新计算每个线程的最大下载速率，否则总下载速率将会下载，无法达到最高下载速率。</p><h1 id="最后，teemo介绍"><a href="#最后，teemo介绍" class="headerlink" title="最后，teemo介绍"></a>最后，teemo介绍</h1><p><del><a href="https://github.com/winsoft666/teemo">teemo</a> 是一个支持如上所有特性的开源库，采用C++开发，teemo一词来源于英雄联盟游戏中的迅捷斥候。<br>该库已经在多个产品中使用，其稳定性得到了验证。</del></p><p><strong>由于该库被一些恶意/流氓软件使用，导致该库的代码特征被360等杀毒软件拉黑，因此作者取消了开源。如需学习，可以从其他途径下载。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> C++ </tag>
            
            <tag> libcurl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows实现文件强制占用</title>
      <link href="/2023/06/28/windows-shi-xian-wen-jian-qiang-zhi-zhan-yong/"/>
      <url>/2023/06/28/windows-shi-xian-wen-jian-qiang-zhi-zhan-yong/</url>
      
        <content type="html"><![CDATA[<p>实现的原理大致如下：</p><p>通过<code>DuplicateHandle</code>拷贝文件句柄给另外一个进程（一般是系统进程），因为系统进程不会被关闭，所以达到了占用某个文件，不让其他进程删除、读取、写入等。</p><p><code>DuplicateHandle</code>的用法参考：- <a href="/2023/06/28/windows-nei-he-dui-xiang/" title="Windows内核对象">Windows内核对象</a></p><p>因为需要拷贝文件句柄给系统进程，所以涉及到打开系统进程，可能需要提权操作，一般授权给进程<code>SE_DEBUG_NAME</code>权限即可。</p><p>实现一个用于锁住文件的函数<code>LockFile</code>，将文件句柄复制给系统<code>csrss.exe</code>进程，函数实现如下：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">bool LockFile(LPCTSTR lpFilePath) {if (lpFilePath == NULL)return false;// 查找进程csrss.exe//DWORD dwCsrssProcessID = 0;PROCESSENTRY32 pe;pe.dwSize = sizeof(PROCESSENTRY32);HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);while (Process32Next(hSnapShot, &amp;pe)) {if (lstrcmpi(pe.szExeFile, TEXT("csrss.exe")) == 0) {dwCsrssProcessID = pe.th32ProcessID;break;}}CloseHandle(hSnapShot);// 未找到if (dwCsrssProcessID == 0) {return false;}HANDLE hProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwCsrssProcessID);// 打开失败，可能是当前进程未提权导致，需要提前进行提权操作if (hProcess == NULL) {return false;}HANDLE hFile = CreateFile(lpFilePath,GENERIC_READ | GENERIC_EXECUTE | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL, NULL);if (hFile == INVALID_HANDLE_VALUE) {CloseHandle(hProcess);return false;}HANDLE hTargetHandle = INVALID_HANDLE_VALUE;BOOL bRet = DuplicateHandle(GetCurrentProcess(),hFile,hProcess,&amp;hTargetHandle,0,FALSE,DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE);CloseHandle(hProcess);return (bRet == TRUE);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核对象</title>
      <link href="/2023/06/28/windows-nei-he-dui-xiang/"/>
      <url>/2023/06/28/windows-nei-he-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是内核对象"><a href="#一、什么是内核对象" class="headerlink" title="一、什么是内核对象"></a>一、什么是内核对象</h2><p>我们在windows开发中经常会遇到内核对象，如事件(Event)，管道(Pipe)，互斥量(Mutex)，完成端口(IOCP)，进程(Process)，线程(Thread)等，他们都是内核对象。这些内核对象虽然通过不同的系统API来创建，但这些API都有一个共同特点，就是都需要传入<code>SECURITY_ATTRIBUTES</code>安全描述符结构体指针，并且返回句柄(HANDLE)。依据这个特点，我们有一个简单方法来判断对象是否是内核对象，就是看创建它的函数是否允许传入<code>SECURITY_ATTRIBUTES</code>安全描述符。</p><h2 id="二、内核对象的创建"><a href="#二、内核对象的创建" class="headerlink" title="二、内核对象的创建"></a>二、内核对象的创建</h2><p>大多数创建内核对象的系统API函数，如CreateEvent, CreateMutex, CreateThread, CreateProcess, CreatePipe, CreateNamedPipe等都会返回一个HANDLE（无论是以返回值的形式，还是以指针参数的形式返回），创建内核对象成功时HANDLE为<code>非NULL</code>，我们可以通过将HANDLE的值与NULL进行比较，来判断函数是否执行成功。但是有些函数比较例外，如<code>CreateFile</code>，这些函数执行失败时，返回的<code>HANDLE</code>的值为<code>INVALID_HANDLE_VALUIE</code>。</p><h2 id="三、内核对象的访问"><a href="#三、内核对象的访问" class="headerlink" title="三、内核对象的访问"></a>三、内核对象的访问</h2><p><strong>虽然内核对象属于系统内核，但创建函数返回的<code>HANDLE</code>句柄却只和当前进程有关，离开了当前进程这个句柄也就失去了意义。</strong><br>内核对象属于系统内核级别，为了系统安全性，Windows不允许我们直接访问内核对象的内存区域，只允许我们通过Windows提供的一系列API来访问内核对象，如<code>SetEvent</code>, <code>ResetEvent</code>等等，使用这些函数时我们都会用到<code>HANDLE</code>，windows头文件中<code>HANDLE</code>的定义如下：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">typedef void *HANDLE;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>虽然定义为<code>void*</code>类型，但很显然这个<code>HANDLE</code>不是指向内核对象的指针。</p><blockquote><p>如何证明HANDLE不是指向内核对象的指针？<br>一方面直接执行内核对象毫无安全性可言；<br>另一方面内核对象保存在内核地址空间（32位系统是<code>0x80000000 到 0xFFFFFFFF</code>，64位系统是<code>0x00000040 00000000到0xFFFFFFFF FFFFFFFF</code>），我们可以调用类似<code>CreateEvent</code>的函数创建一个内核对象，观察其返回的HANDLE，明显不在内核地址空间的范围内，且值一般比较小。</p></blockquote><p>那么这个<code>HANDLE句柄</code>是如何与内核对象关联起来的了？答案是：<strong>进程的句柄表。</strong><br>每个进程在初始化的时候，系统都会为它分配一个句柄表(Windows没有提供官方的文档来介绍句柄表)，参考《Windows核心编程》得知句柄表的结构，如图：</p><table><thead><tr><th>索引</th><th>指向内核对象内存块的指针</th><th>访问掩码</th><th>标志</th></tr></thead><tbody><tr><td>1</td><td>0x????????</td><td>0x????????</td><td>0x????????</td></tr><tr><td>2</td><td>0x????????</td><td>0x????????</td><td>0x????????</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>如我们调用类似<code>CreateEvent</code>的函数返回的句柄<code>HANDLE</code>就是句柄表中的<code>索引</code>。因为是<code>索引</code>，所以它的值一般比较小。我们向windows API函数传入这个<code>索引</code>，API再通过<code>索引</code>找到对应的<code>内核对象指针</code>。</p><h2 id="四、内核对象的销毁"><a href="#四、内核对象的销毁" class="headerlink" title="四、内核对象的销毁"></a>四、内核对象的销毁</h2><h3 id="4-1-引用计数"><a href="#4-1-引用计数" class="headerlink" title="4.1 引用计数"></a>4.1 引用计数</h3><p><strong>内核对象的所有者是操作系统内核，而不是创建它的进程。</strong></p><p>多个进程可以引用（使用）同一个内核对象，操作系统使用了计数器的方式来管理内核对象（这个和C++中的<code>std::shared_ptr</code>智能指针类似），一个内核对象其实有两个计数器：一个是给用户态(Ring3)用的句柄计数；另一个是指针计数，也叫引用计数，因为核心态程序(Ring0)也经常用到内核对象，为了使用方便，在核心态的代码用指针直接访问对象，所以内核对象的管理器也维护了这个指针引用计数。只有在内核对象的<code>句柄计数</code>和<code>引用计数</code>都为0时，该内核对象才被释放。一般而言，指针引用计数值比句柄计数值大。 </p><h3 id="4-2-正确的销毁方式"><a href="#4-2-正确的销毁方式" class="headerlink" title="4.2 正确的销毁方式"></a>4.2 正确的销毁方式</h3><p>当程序不再使用内核对象时，需要调用<code>CloseHandle</code>将内核对象的计数减1，这样系统内核在该对象计数为0时（也就是没有被任何东西引用时）将销毁该对象。 <strong>并且在调用<code>CloseHandle</code>之后，程序还应该将<code>HANDLE</code>置为<code>NULL</code>。</strong></p><p> 如果<code>CloseHandle</code>之后不将<code>HANDLE</code>置为<code>NULL</code>，反而再次使用该<code>HANDLE</code>，就会出现2种情况：</p><ol><li><p>进程句柄表中该<code>HANDLE</code>所在的索引项的记录已经被清除，且没有别的线程再次在该索引创建记录项，若此时使用这个过期的<code>HANDLE</code>调用Win32 API函数，Windows会返回无效参数错误。这种情况还比较好调试。</p></li><li><p>进程句柄表中该<code>HANDLE</code>所在的索引项的记录同样也已经被清除，但已经有别的线程（该进程中的其他线程）在该<code>索引</code>位置创建了记录项，若此时使用这个过期的<code>HANDLE</code>调用Win32 API函数，该<code>HANDLE</code>就会引用到其他线程新建的那个内核对象，从而出现一些难以预料的错误。这种错误很难调试。</p></li></ol><h3 id="4-3-获取内核对象的引用计数"><a href="#4-3-获取内核对象的引用计数" class="headerlink" title="4.3 获取内核对象的引用计数"></a>4.3 获取内核对象的引用计数</h3><p>虽然windows没有提供API让用户在用户态（Ring3）查询一个内核对象的句柄计数和引用计数，但我们可以从<code>Ntdll.dll</code>导出<code>NtQueryObject</code>函数来实现查询内核对象的当前状态(该函数没有被文档化)。 </p><p><code>NtQueryObject</code>函数声明如下：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">// 返回值：如果成功则返回0//DWORD WINAPI NtQueryObject(HANDLE   handle,       // 待查询的句柄DWORD   nQueryIndex,   // 0为查询对象的当前状态，包括句柄计数，引用计数等等。VOID*   pOutBuffer,    // 存放查询结果DWORD   cbInBufferSize,   // pOutBuffer的大小，如果nQueryIndex为0，这里为sizeof(SYSTEM_HANDLE_STATE)VOID*   cbOutBufferSize   // 实际大小);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将<code>NtQueryObject</code>函数调用的细节封装到<code>GetKernelObjectRefCount</code>函数中，方便使用：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">bool GetKernelObjectRefCount(HANDLE handle, DWORD &amp;handle_count, DWORD &amp;point_count) {typedef struct _SYSTEM_HANDLE_STATE {DWORD   r1;DWORD   GrantedAccess;DWORD   HandleCount;      // 减1为句柄计数 DWORD   ReferenceCount;   // 减1为指针引用计数 DWORD   r5;DWORD   r6;DWORD   r7;DWORD   r8;DWORD   r9;DWORD   r10;DWORD   r11;DWORD   r12;DWORD   r13;DWORD   r14;}SYSTEM_HANDLE_STATE, *PSYSTEM_HANDLE_STATE;typedef DWORD(WINAPI *PFN_NtQueryObject)(HANDLE handle,DWORD nQueryIndex,VOID* pOutBuffer,DWORD cbInBufferSize,VOID* cbOutBufferSize);static PFN_NtQueryObject pfnNtQueryObject = NULL;bool ret = false;do {if (pfnNtQueryObject == NULL) {HMODULE ntdll = GetModuleHandle(TEXT("Ntdll.dll"));if (ntdll == NULL)break;pfnNtQueryObject = (PFN_NtQueryObject)GetProcAddress(ntdll, "NtQueryObject");if (pfnNtQueryObject == NULL)break;}SYSTEM_HANDLE_STATE sys_handle_state;memset(&amp;sys_handle_state, 0, sizeof(SYSTEM_HANDLE_STATE));DWORD out_buf_size = 0;ret = (pfnNtQueryObject(handle, 0, &amp;sys_handle_state, sizeof(SYSTEM_HANDLE_STATE), &amp;out_buf_size) == 0);if (ret) {handle_count = sys_handle_state.HandleCount - 1;point_count = sys_handle_state.ReferenceCount - 1;}} while (false);return ret;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、内核对象跨进程访问"><a href="#五、内核对象跨进程访问" class="headerlink" title="五、内核对象跨进程访问"></a>五、内核对象跨进程访问</h2><p>虽然内核对象位于独立于进程之外的内核区域，我们在开发中却只能通过调用Win32 API传入HANDLE参数来操作内核对象（如<code>SetEvent</code>等）。然而<code>HANDLE句柄</code>只对当前进程有效，离开了当前进程该句柄就无效了。所以说，跨进程访问内核对象的关键在于我们怎么跨进程访问<code>句柄HANDLE</code>？</p><p>下面介绍几种方法来实现跨进程共享内核对象。</p><h3 id="5-1-使用句柄继承的方式"><a href="#5-1-使用句柄继承的方式" class="headerlink" title="5.1 使用句柄继承的方式"></a>5.1 使用句柄继承的方式</h3><p>只有进程之间有父子关系时，才可以使用句柄继承的方式。在这种情况下，父进程可以生成一个子进程，并允许子进程访问父进程的内核对象。为了使这种继承生效，父进程必须执行几个步骤：<br>（1）. 父进程在创建一个内核对象时，父进程必须向系统指定它希望这个内核对象的句柄是可以继承的。为了创建一个可继承的内核对象，必须分配并初始化一个<code>SECURITY_ATTRIBUTES</code>结构，如：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">SECURITY_ATTRIBUTES sa;sa.nLength = sizeof(SECURITY_ATTRIBUTES);sa.bInheritHandle = TRUE;  // 可继承的sa.lpSecurityDescriptor = NULL;HANDLE h = CreateEvent(&amp;sa, TRUE, FALSE, NULL); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）. 父进程通过CreateProcess生成子进程，且指定<code>bInheritHandles</code>为TRUE，从而允许子进程来继承父进程的那些“可继承的句柄”。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">// 启动子进程TestB.exe，将句柄h作为启动参数传给进程TestB//TCHAR cmd_buf[MAX_PATH];StringCchPrintf(cmd_buf, MAX_PATH, TEXT("TestB.exe %ld"), (long)h);STARTUPINFO si = { sizeof(si) };PROCESS_INFORMATION pi;BOOL ret = CreateProcess(NULL, cmd_buf, NULL, NULL, TRUE,  // 指定子进程可以继承父进程的“可继承句柄”0, NULL, NULL, &amp;si, &amp;pi);CloseHandle(pi.hProcess);CloseHandle(pi.hThread);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于我们传给<code>bInheritHandles</code>参数的值是<code>TRUE</code>，所以系统在创建子进程时会多做一件事情：它会遍历父进程的句柄表，对它的每一项进行检查，凡是包含一个有效的“可继承的句柄”的项，都会将该项完整的复制到子进程的句柄表。在子进程的句柄表中，复制项的位置与它在父进程句柄表中的位置完全一样（包含索引），这个就意味着：在父进程和子进程中，对一个内核对象进行标识的句柄值也是完全一样的。所以我们只需要通过某种方式（如上面示例中的启动参数的方式，或者环境变量的方式等任何进程间通讯的方式）将这个值告诉子进程，子进程就可以将该值转成<code>HANDLE</code>，然后使用这个<code>HANDLE</code>来调用系统API。</p><h3 id="5-2-使用DuplicateHandle方式"><a href="#5-2-使用DuplicateHandle方式" class="headerlink" title="5.2 使用DuplicateHandle方式"></a>5.2 使用DuplicateHandle方式</h3><p>DuplicateHandle函数可以将指定“源进程的句柄表”中的某一项<strong>复制</strong>到“目的进程句柄表”中（除了索引），并且返回该项在目的进程句柄表中的索引（即HADNLE）。<br>可以在任何时候调用DuplicateHandle函数，DuplicateHandle对源句柄是否是可继承的没有要求。</p><p>函数声明如下：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">BOOL DuplicateHandle(  HANDLE hSourceProcessHandle,  HANDLE hSourceHandle,  HANDLE hTargetProcessHandle,  LPHANDLE lpTargetHandle,  DWORD dwDesiredAccess,  BOOL bInheritHandle,  DWORD dwOptions);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>DuplicateHandle详细介绍可以参考MSDN：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724251(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms724251(v=vs.85).aspx</a></p></blockquote><p>DuplicateHandle函数不能复制所有类型的句柄，只能复制如下类型的句柄（从MSDN复制而来）：</p><table><thead><tr><th>Object</th><th>Description</th></tr></thead><tbody><tr><td>Access token</td><td>The handle is returned by the CreateRestrictedToken, DuplicateToken, DuplicateTokenEx, OpenProcessToken, or OpenThreadToken function.</td></tr><tr><td>Change notification</td><td>The handle is returned by the FindFirstChangeNotification function.</td></tr><tr><td>Communications device</td><td>The handle is returned by the CreateFile function.</td></tr><tr><td>Console input</td><td>The handle is returned by the CreateFile function when CONIN$ is specified, or by the GetStdHandle function when STD_INPUT_HANDLE is specified. Console handles can be duplicated for use only in the same process.</td></tr><tr><td>Console screen buffer</td><td>The handle is returned by the CreateFile function when CONOUT$ is specified, or by the GetStdHandle function when STD_OUTPUT_HANDLE is specified. Console handles can be duplicated for use only in the same process.</td></tr><tr><td>Desktop</td><td>The handle is returned by the GetThreadDesktop function.</td></tr><tr><td>Event</td><td>The handle is returned by the CreateEvent or OpenEvent function.</td></tr><tr><td>File</td><td>The handle is returned by the CreateFile function.</td></tr><tr><td>File mapping</td><td>The handle is returned by the CreateFileMapping function.</td></tr><tr><td>Job</td><td>The handle is returned by the CreateJobObject function.</td></tr><tr><td>Mailslot</td><td>The handle is returned by the CreateMailslot function.</td></tr><tr><td>Mutex</td><td>The handle is returned by the CreateMutex or OpenMutex function.</td></tr><tr><td>Pipe</td><td>A named pipe handle is returned by the CreateNamedPipe or CreateFile function. An anonymous pipe handle is returned by the CreatePipe function.</td></tr><tr><td>Process</td><td>The handle is returned by the CreateProcess, GetCurrentProcess, or OpenProcess function.</td></tr><tr><td>Registry key</td><td>The handle is returned by the RegCreateKey, RegCreateKeyEx, RegOpenKey, or RegOpenKeyEx function. Note that registry key handles returned by the RegConnectRegistry function cannot be used in a call to DuplicateHandle.</td></tr><tr><td>Semaphore</td><td>The handle is returned by the CreateSemaphore or OpenSemaphore function.</td></tr><tr><td>Thread</td><td>The handle is returned by the CreateProcess, CreateThread, CreateRemoteThread, or GetCurrentThread function</td></tr><tr><td>Timer</td><td>The handle is returned by the CreateWaitableTimer or OpenWaitableTimer function.</td></tr><tr><td>Transaction</td><td>The handle is returned by the CreateTransaction function.</td></tr><tr><td>Window station</td><td>The handle is returned by the GetProcessWindowStation function.</td></tr></tbody></table><p>不同的事件类型对应的<code>dwDesiredAccess</code>参数不同，具体参考<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724251(v=vs.85).aspx">MSDN</a>。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>进程TestA源码</strong></p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">int main(int argc, char** argv) {HANDLE h = CreateEvent(NULL, TRUE, FALSE, NULL);// 启动子进程TestB.exe//TCHAR cmd_buf[MAX_PATH];StringCchPrintf(cmd_buf, MAX_PATH, TEXT("D:\\TestB.exe"), (long)h);STARTUPINFO si = { sizeof(si) };PROCESS_INFORMATION pi;BOOL ret = CreateProcess(NULL, cmd_buf, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;pi);assert(ret);assert(pi.hProcess);HANDLE duplicated_h = NULL;ret = DuplicateHandle(GetCurrentProcess(), h, pi.hProcess, &amp;duplicated_h, 0, FALSE, DUPLICATE_SAME_ACCESS);WaitForSingleObject(pi.hProcess, INFINITE);CloseHandle(pi.hProcess);CloseHandle(pi.hThread);bool has_signal = WaitForSingleObject(h, 0) == WAIT_OBJECT_0;assert(has_signal == true);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>子进程TestB源码</strong></p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">int main(int argc, char** argv){long l = 0;printf("Input Handle:");scanf("%ld", &amp;l);HANDLE h = (HANDLE)l;bool has_signal = WaitForSingleObject(h, 0) == WAIT_OBJECT_0;assert(has_signal == false);SetEvent(h);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在父进程TestA中创建一个不可继承的事件 -&gt; 然后启动子进程TestB -&gt; 调用DuplicateHandle复制句柄项到TestB进程句柄表 -&gt; 并向TestB输入句柄值 -&gt; TestB访问该事件句柄，将事件置为有信号状态。</p><h3 id="5-3-使用命名的内核对象的方式"><a href="#5-3-使用命名的内核对象的方式" class="headerlink" title="5.3 使用命名的内核对象的方式"></a>5.3 使用命名的内核对象的方式</h3><h4 id="5-3-1-实现原理"><a href="#5-3-1-实现原理" class="headerlink" title="5.3.1 实现原理"></a>5.3.1 实现原理</h4><p>这种方式严格的说已经不是文章开头说到的跨进程访问句柄了，有点类似跨进程直接访问内核对象了。<br>该方式实现起来比较简单，就是在调用创建内核对象的<code>Create***</code>函数时，通过<code>pszName</code>参数为内核对象取一个名字。<br>如创建事件Event的函数<code>CreateEvent</code>：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">HANDLE WINAPI CreateEvent(  LPSECURITY_ATTRIBUTES lpEventAttributes,  BOOL bManualReset,  BOOL bInitialState,  LPCTSTR lpName  // 指定名称);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">HANDLE h = CreateEvent(NULL, TRUE, FALSE, TEXT("TestA_Obj"));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若在其他进程中要访问这个内核对象，只需要使用打开函数<code>Open***</code>打开该内核对象，<strong>系统就会在进程的句柄表中插入一条记录，并返回这条记录的索引，也就是句柄</strong>。需要注意的是，在打开内核对象时需要留意<code>返回值</code>和<code>GetLastError</code>函数的返回值。由于内核对象是有访问权限的，有时候虽然这个名字的内核对象存在，但该进程却不见得有权限可以打开它，这个时候<code>GetLastError</code>函数会返回失败的原因。</p><p>以打开事件的函数<code>OpenEvent</code>为例：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">HANDLE h = OpenEvent(READ_CONTROL, FALSE, TEXT("TestA_Obj"));if (h == NULL) {if (GetLastError() == ERROR_ACCESS_DENIED) { // 没有READ_CONTROL权限}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-2-全局命令空间"><a href="#5-3-2-全局命令空间" class="headerlink" title="5.3.2 全局命令空间"></a>5.3.2 全局命令空间</h4><p>不同的会话（Session）有不同的内核对象命名空间（如windows服务程序位于<code>Session 0</code>，而普通的用户进程位于<code>Session 1</code>），要通过名称访问其他会话中的内核对象，需要在名称前面加上<code>Session\&lt;当前会话ID&gt;</code>。Windows提供了一个全局的内核对象命名空间，处于任何会话中的进程都可以访问该命名空间，将内核对象放入全局命令空间的方式很简单：只需要在内核对象名称前加入<code>Global\</code>即可。</p><p>如：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">HANDLE h = CreateEvent(NULL, TRUE, FALSE, TEXT("Global\\TestA_Obj"));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核对象 </tag>
            
            <tag> 句柄 </tag>
            
            <tag> HANDLE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript基础语法</title>
      <link href="/2023/06/28/typescript-ji-chu-yu-fa/"/>
      <url>/2023/06/28/typescript-ji-chu-yu-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果你还不了解TypeScript是什么，或者其与JavaScript之前的关系，可以参考：- <a href="/2023/06/28/qian-hou-duan-chang-yong-gai-nian-sao-mang/" title="前后端常用概念扫盲">前后端常用概念扫盲</a></p></blockquote><p>TypeScript是JavaScript的一个超集，支持ES6的语法规范，并在此基础上进行了增强，二者最大的不同在于：TypeScript是强类型语言，而JavaScript是弱类型的语言。</p><p>下面着重介绍二者的不同之处。</p><h1 id="一、变量声明"><a href="#一、变量声明" class="headerlink" title="一、变量声明"></a>一、变量声明</h1><p>TypeScript支持使用<code>var</code>、<code>let</code>、<code>const</code>进行变量声明，但建议不要使用<code>var</code>。<br>TypeScript声明变量时，可以强制指定变量类型或者由编译器自动从“值”推导出变量类型，但无论哪种情况，一旦确定了类型，后面不能再次被赋值为其他类型：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token string">"x"</span><span class="token punctuation">;</span> ❌<span class="token keyword">let</span> <span class="token literal-property property">b</span> <span class="token operator">:</span> number <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token literal-property property">c</span> <span class="token operator">:</span> number <span class="token operator">=</span> <span class="token string">"x"</span><span class="token punctuation">;</span> ❌<span class="token keyword">let</span> <span class="token literal-property property">fibonacci</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token literal-property property">fibonacci</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>❌<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、函数参数"><a href="#二、函数参数" class="headerlink" title="二、函数参数"></a>二、函数参数</h1><p>TypeScript要求：调用函数时传入的参数必须与函数声明的参数一致（个数及类型），如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">x</span><span class="token operator">:</span> number<span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">{</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ❌<span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>❌<span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ❌<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TypeScript要求：可选参数必须在参数列表的最后，如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token parameter">firstName<span class="token operator">?</span><span class="token operator">:</span> string<span class="token punctuation">,</span> <span class="token literal-property property">lastName</span><span class="token operator">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>❌    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> lastName<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> lastName<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、枚举"><a href="#三、枚举" class="headerlink" title="三、枚举"></a>三、枚举</h1><p>枚举是TypeScript特有的：<br>第一个元素没有赋值，则默认为0，后面的元素的值依此递增：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">enum</span> Days <span class="token punctuation">{</span>    Sun<span class="token punctuation">,</span>   <span class="token comment">// 0</span>    Mon<span class="token punctuation">,</span>  <span class="token comment">// 1</span>    Tue<span class="token punctuation">,</span>  <span class="token comment">// 2</span>    Wed<span class="token punctuation">,</span>     Thu<span class="token punctuation">,</span>    Fri<span class="token punctuation">,</span>    Sat<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也支持：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">enum</span> Days <span class="token punctuation">{</span>    Sun <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>   <span class="token comment">// 1</span>    Mon<span class="token punctuation">,</span>  <span class="token comment">// 2</span>    Tue<span class="token punctuation">,</span>  <span class="token comment">// 3</span>    Wed <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>  <span class="token comment">// 10</span>    Thu<span class="token punctuation">,</span>  <span class="token comment">// 11</span>    Fri<span class="token punctuation">,</span>  <span class="token comment">// 12</span>    Sat   <span class="token comment">// 13</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>枚举元素可以是常量值或是可以通过编译期计算得出的值：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">enum</span> FileAccess <span class="token punctuation">{</span>    <span class="token comment">// 常量值</span>    None<span class="token punctuation">,</span>   <span class="token comment">// 0</span>    Read    <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span>    Write   <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">,</span>    ReadWrite  <span class="token operator">=</span> Read <span class="token operator">|</span> Write<span class="token punctuation">,</span>    <span class="token comment">// 计算得出的值</span>    <span class="token constant">G</span> <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">.</span>length<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、类"><a href="#四、类" class="headerlink" title="四、类"></a>四、类</h1><p>相比<code>ES6</code>，<code>TypeScript</code>新增了继承、成员访问控制修饰符。越来越有Java、C++的味道了。</p><h2 id="4-1-继承、成员访问控制修饰符"><a href="#4-1-继承、成员访问控制修饰符" class="headerlink" title="4.1 继承、成员访问控制修饰符"></a>4.1 继承、成员访问控制修饰符</h2><p>TypeScript继承需要使用<code>extends</code>关键字，只支持单继承，这点不同于C++。<br>类继承后，子类可以重写父类的方法。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token literal-property property">id</span><span class="token operator">:</span> string<span class="token punctuation">;</span>  <span class="token comment">// 私有的，只能被自身访问</span>    <span class="token keyword">protected</span> <span class="token literal-property property">name</span><span class="token operator">:</span> string<span class="token punctuation">;</span>  <span class="token comment">// 受保护，可以被其自身以及其子类和父类访问</span>    <span class="token keyword">protected</span> <span class="token literal-property property">age</span><span class="token operator">:</span> number<span class="token punctuation">;</span>   <span class="token comment">// 公开的</span>    <span class="token keyword">public</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> string <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> string <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> number <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"name:"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">", age:"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token literal-property property">grade</span> <span class="token operator">:</span> number<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">getGrade</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> number <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>grade<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span> <span class="token comment">// 重写了父类的方法</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用super直接调用父类方法</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"grade:"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>grade<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-instanceof"><a href="#4-2-instanceof" class="headerlink" title="4.2 instanceof"></a>4.2 instanceof</h2><p><code>instanceof</code> 运算符用于判断对象是否是指定的类型，如果是返回<code>true</code>，否则返回<code>false</code>。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> <span class="token literal-property property">isPerson</span> <span class="token operator">:</span> boolean <span class="token operator">=</span> obj <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="4-3-interface接口"><a href="#4-3-interface接口" class="headerlink" title="4.3 interface接口"></a>4.3 interface接口</h2><p>TypeScript新增interface接口的概念，这个接口的概念和Java中的interface类似，即：只有定义没有实现。</p><p>同时，接口也支持继承。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">interface</span> <span class="token class-name">IPerson</span> <span class="token punctuation">{</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> string<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">IStudent</span> <span class="token keyword">extends</span> <span class="token class-name">IPerson</span> <span class="token punctuation">{</span>  <span class="token comment">// 接口的继承</span>    <span class="token literal-property property">grade</span> <span class="token operator">:</span> number<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">implements</span> <span class="token class-name">IStudent</span> <span class="token punctuation">{</span>  <span class="token comment">// 实现接口的类</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> string<span class="token punctuation">;</span>    <span class="token literal-property property">grade</span> <span class="token operator">:</span> number<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="五、命名空间"><a href="#五、命名空间" class="headerlink" title="五、命名空间"></a>五、命名空间</h1><p>TypeScript中的命名空间的概念和C++中的命名空间的概念一样，而且关键字也都是<code>namespace</code>。</p><p>稍有不同的是，C++不需要将命名空间中的内容暴露出来，C++默认就是全部暴露的，而TypeScript需要手动添加export关键字将命名空间的中的内容暴露出来：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">namespace <span class="token constant">XYZ</span> <span class="token punctuation">{</span>    <span class="token keyword">export</span> <span class="token keyword">let</span> <span class="token literal-property property">name</span> <span class="token operator">:</span> string<span class="token punctuation">;</span>    <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">IPerson</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token constant">XYZ</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"jeff"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端常用概念扫盲</title>
      <link href="/2023/06/28/qian-hou-duan-chang-yong-gai-nian-sao-mang/"/>
      <url>/2023/06/28/qian-hou-duan-chang-yong-gai-nian-sao-mang/</url>
      
        <content type="html"><![CDATA[<h2 id="1-浏览器内核"><a href="#1-浏览器内核" class="headerlink" title="1. 浏览器内核"></a>1. 浏览器内核</h2><p>在Web大行其道的时代，网民需要上网浏览网页就需要依赖浏览器这个软件，掌握了浏览器就掌握了流量的入口，于是各大软件公司开始研发自己品牌的浏览器，不同品牌的浏览器其实现原理当然是有区别的，这个实现原理就是浏览器的核心，我们称其浏览器内核。</p><p>现在市面上有这么多的浏览器，如Chrome，QQ浏览器，搜狗浏览器，这些浏览器厂商是不是都是自己研发浏览器内核了？不是的！</p><p>因为有些公司或者团体将浏览器内核进行了开源，方便其他人基于该内核进行二次开发，常见的开源浏览器内核有Chromium、WebKit、Gecko。</p><p>正因为有了这些开源内核的存在，我们可以不用自己开发内核也可以开发属于自己品牌的浏览器，比如QQ浏览器，搜狗浏览器，360浏览器都是基于IE内核和Chromium内核二次封装而成，美其名曰双引擎（双内核）。</p><p>目前市面上流行的拥有自主内核的浏览器：</p><table><thead><tr><th>浏览器</th><th>内核</th></tr></thead><tbody><tr><td>Chrome</td><td>Chromium</td></tr><tr><td>Safari</td><td>WebKit</td></tr><tr><td>Firefox</td><td>Gecko</td></tr><tr><td>IE</td><td>IE内核</td></tr></tbody></table><h2 id="2-JavaScript-ECMAScript-ES6-TypeScript"><a href="#2-JavaScript-ECMAScript-ES6-TypeScript" class="headerlink" title="2. JavaScript, ECMAScript, ES6, TypeScript"></a>2. JavaScript, ECMAScript, ES6, TypeScript</h2><p><code>JavaScript</code>是一个编程语言的名称，类似Java，C++，PHP，是由Netscape公司开发的一种解释性编程语言，其运行的宿主环境大多是浏览器，但也可以是其他环境，如Node。</p><p>因为Netscape公司希望<code>JavaScript</code>成为一种浏览器脚本语言的标准规范，于是在1996年将 JavaScript 提交给标准化组织 ECMA。次年，ECMA就发布了标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种标准称为ECMAScript。</p><p>所以说，<code>ECMAScript</code>是一个的浏览器脚本语言的<strong>标准规范</strong>。</p><p>不同的浏览器内核及不同的版本对<code>ECMAScript</code>规范的支持情况不同， 截至 2012 年，所有浏览器都完整的支持<code>ECMAScript 5.1</code>；</p><p>从<code>ECMAScript 6</code>开始，标准制定者决定不再用诸如”3.1, 5.0”这样的版本号来命名，而是每年6月发布一个ECMAScript的正式版，并且以当年的年份来命名， 如2015年6月17日ECMA国际组织发布了ECMAScript的第六版，该版本正式名称为<code>ECMAScript 2015</code>。</p><p><code>ES6</code>只是<code>ECMAScript 6</code>版本的简称，我们一般用<code>ECMAScript 6</code>来统称<code>ECMAScript 2015</code>及其以后的版本。</p><p><code>TypeScript</code>是由微软开发的一种开源的编程语言。它是JavaScript 的一个严格超集，并添加了静态类型及其他特性。<code>TypeScript</code>目前已经支持<code>ECMAScript 2015</code>。</p><h2 id="3-CSS-CSS3"><a href="#3-CSS-CSS3" class="headerlink" title="3. CSS, CSS3"></a>3. CSS, CSS3</h2><p><code>CSS</code>即<code>Cascading Style Sheets</code>层叠样式表的简称，在Web开发中用来定义元素样式的一种标记型语言。<br><code>CSS3</code>是CSS（层叠样式表）的升级版本，2001年5月23日W3C完成了CSS3的工作草案。</p><h2 id="4-V8-Node-Node-js-npm-Yarn"><a href="#4-V8-Node-Node-js-npm-Yarn" class="headerlink" title="4. V8, Node, Node.js, npm, Yarn"></a>4. V8, Node, Node.js, npm, Yarn</h2><p>V8，我们通常叫做V8引擎，然而其并不是汽车发动机的V8引擎，而是由Google开发并开源的一个项目，可以解释和执行JavaScript，因为其性能非常高，目前得到了广泛的应用，如Node.js就是基于该引擎而开发。</p><p>Node.js和Node是一个东西，Node是Node.js的简称。</p><p><code>npm</code>（<code>node package management</code>）是Node.js的一个包管理工具，目前已经内置到了Node.js中，不需要再单独安装。</p><p><code>yarn</code>也是一个包管理工具，由Facebook、Google、Exponent 和 Tilde 联合推出，其目的是为了弥补npm的一些缺陷。</p><h2 id="5-React-Vue-Angular"><a href="#5-React-Vue-Angular" class="headerlink" title="5. React, Vue, Angular"></a>5. React, Vue, Angular</h2><p>这3个说白了都是Javascript库。</p><p>我们最初开发Web的时候用的是<code>HTML+CSS+JavaScript</code>，后来有人觉得用纯js撸太繁琐了，就有了后来的jQuery这样的JavaScript库，但随着业务的扩增，数据交互越来越复杂，使用jQuery也太繁琐了，于时又有了React, Vue, Angular这样的库。</p><p>总之，前端生态真繁荣。。。。</p><h2 id="6-Ant-Design-Element-UI"><a href="#6-Ant-Design-Element-UI" class="headerlink" title="6. Ant Design, Element UI"></a>6. Ant Design, Element UI</h2><p>前面说到了React, Vue, Angular，虽然又了这些库，数据交互方面变得简单了，但页面效果还是需要CSS和JS一行行代码来实现的，比如要实现一个下拉列表，动态按钮等。于时现在又出现了一些基于React, Vue和Angular这些库的UI组件库，这些UI库将常用的组件封装好了，在开发中直接引入使用，改改属性，设置下参数即可。</p><h2 id="7-Scaffold-脚手架"><a href="#7-Scaffold-脚手架" class="headerlink" title="7. Scaffold(脚手架)"></a>7. Scaffold(脚手架)</h2><p>通俗的讲就是将一些重复性的事情整合成一个工具，这个工具就可以叫脚手架。</p><h2 id="8-MySQL-Redis-MongoDB-Oracle-PostgreSQL-NoSQL"><a href="#8-MySQL-Redis-MongoDB-Oracle-PostgreSQL-NoSQL" class="headerlink" title="8. MySQL, Redis, MongoDB, Oracle, PostgreSQL, NoSQL"></a>8. MySQL, Redis, MongoDB, Oracle, PostgreSQL, NoSQL</h2><p>数据库目前分为关系型数据库和非关系型数据（即NoSQL），不同类型的数据各有其特点。同样，同一类型但不同品牌的数据库也各有其特点和应用领域  。</p><p>不能单纯的评判哪种数据库的好坏，一个项目中可能同时用到多个不同种类的数据库。</p><p>1、关系数据库<br>MySQL、MariaDB、PostgreSQL、Microsoft Access、Microsoft SQL Server、Oracle、Sybase等等。</p><p>2、非关系型数据库（NoSQL）<br>BigTable（Google）、Cassandra、MongoDB、CouchDB、Redis等等。</p><h2 id="9-Nginx-Apache"><a href="#9-Nginx-Apache" class="headerlink" title="9. Nginx, Apache"></a>9. Nginx, Apache</h2><p>都是Web服务器，不同的团队研发，各有其优缺点。</p><h2 id="10-反向代理"><a href="#10-反向代理" class="headerlink" title="10. 反向代理"></a>10. 反向代理</h2><p><code>反向代理</code>单纯从名字上理解就是<code>正向代理</code>的反方向。</p><p>那什么是正向代理？代理<code>内部网络</code>访问<code>外部网络</code>的代理就是正向代理，比如你需要从公司局域网中的电脑A经过代理服务器B访问网站C：</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">A --&gt; B --&gt; C<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你认为A是内部网络，C是外部网络，那B就是正向代理；</p><p>如果你认为A是外部网络，C是内部网络（当然我们一般不这么认为），那么B就是反向代理。</p><h2 id="11-RESTful"><a href="#11-RESTful" class="headerlink" title="11. RESTful"></a>11. RESTful</h2><p>一切具有REST特性的服务都可以成为RESTful服务，那么REST特性是什么了？</p><p>REST 是<code>Representational state transfer</code>的缩写，维基百科上的解释为：</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">Representational State Transfer (REST) is a software architecture style consisting of guidelines and best practices for creating scalable web services. REST is a coordinated set of constraints applied to the design of components in a distributed hypermedia system that can lead to a more performant and maintainable architecture.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>REST是一种架构风格, 只有满足这些约束，才能称之为符合REST架构风格。REST 的约束大致包括：</p><ol><li>客户端-服务器结构</li><li>无状态</li><li>可缓存</li><li>按需代码（可选）</li><li>统一接口</li></ol><blockquote><p>持续更新中….</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript6基础语法</title>
      <link href="/2023/06/28/ecmascript6-ji-chu-yu-fa/"/>
      <url>/2023/06/28/ecmascript6-ji-chu-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="【写在前面】"><a href="#【写在前面】" class="headerlink" title="【写在前面】"></a>【写在前面】</h1><p>ECMAScript标准的发展经历了一个漫长的过程，从1997年发布的<code>ECMAScript 1.0</code>，到2011年的<code>ECMAScript 5.1</code>，再到2015年的<code>ECMAScript 2015</code>，以及后面每年都会发布的一个新的ECMAScript版本，版本众多，而且每个版本都有新特性的加入。</p><blockquote><p>我们通常用<code>ECMAScript 6</code>来统称<code>ECMAScript 2015</code>及其之后的的版本。</p></blockquote><p>但<code>ECMAScript 2015</code>可谓是ECMAScript标准的分水岭，其从制定到发布前后经历了15年，目前绝大多数浏览器都支持了<code>ECMAScript 2015</code>特性，并部分的支持了6.0后面版本的新特性，所以对于需要快速入门的初学者，只需要直接学习<code>ECMAScript 2015</code>标准即可，编写完全遵守<code>ECMAScript 2015</code>标准的代码不仅更加严谨，而且可以节省不少学习时间。即便对于那些不支持<code>ECMAScript 6</code>的浏览器（如IE11），我们也可以使用<a href="https://babeljs.io/">Babel</a>之类的工具将其转换为<code>ECMAScript 5</code>标准的代码。</p><blockquote><p>查看浏览器对ES特性的支持情况，可以访问：<a href="https://kangax.github.io/compat-table/es6/">https://kangax.github.io/compat-table/es6/</a></p></blockquote><p><strong>下文讲述的都是支持ECMAScript 6标准的JavaScript语法</strong></p><h1 id="零"><a href="#零" class="headerlink" title="零"></a>零</h1><ol><li>JavaScript是大小写敏感的</li><li>在每行只写一条语句时，结尾可以不加分号<code>;</code>，但建议每条语句都以分号结尾</li></ol><h1 id="一、七种基本数据类型"><a href="#一、七种基本数据类型" class="headerlink" title="一、七种基本数据类型"></a>一、七种基本数据类型</h1><p>基本数据类型有以下7种：</p><ol><li>undefined</li><li>null</li><li>Boolean</li><li>String</li><li>Number</li><li>Object</li><li>Symbol</li></ol><p>JavaScript虽然是弱类型的语言，但不代表其没有数据类型，这个弱类型指的是在声明变量的时候不需要（<strong>也不能</strong>）指明变量类型，而且会根据“值”的类型自动将变量转换成合适的类型。</p><p>所以无论时值还是变量终究还是有类型的，但对于开发者而言，不需要关注什么类型的值应该赋值给什么类型的变量。</p><p>我们可以使用<code>typeof</code>查看每个变量或值的类型：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// number</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// string</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// boolean</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// object</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// object</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// function</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得注意的是<code>undefined</code>的类型是<code>undefined</code>，但<code>null</code>的类型是<code>object</code>，下面的章节会介绍<code>undefined</code>和<code>null</code>的区别。</p><h1 id="二、变量声明方式"><a href="#二、变量声明方式" class="headerlink" title="二、变量声明方式"></a>二、变量声明方式</h1><p>声明变量的方式有3种：</p><ol><li>let  用来声明变量</li><li>var 也是用来声明变量的</li><li>const  用来声明常量，必须在声明的时候赋初始值，且以后不能再修改</li></ol><blockquote><p><code>var</code>是<code>ES6</code>之前的，建议不要在代码中使用var，这样可以避免很多不必要的问题，比如<code>变量提升</code>、<code>暂时性死区</code>等，本文也只讲述<code>let</code>和<code>const</code>，忘记<code>var</code>吧，一起走向新世界。</p></blockquote><h2 id="2-1-变量具有作用域的概念"><a href="#2-1-变量具有作用域的概念" class="headerlink" title="2.1 变量具有作用域的概念"></a>2.1 变量具有作用域的概念</h2><p>用let和const声明的变量或常量的作用域可以精确到<code>“块级别”</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ReferenceError: a is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 依次输出0~9</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ReferenceError: i is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">789</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 无论是let还是const都是一样的，在同一个作用域内不能重复声明</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span>  <span class="token comment">// SyntaxError: Identifier 'a' has already been declared</span><span class="token punctuation">}</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span> <span class="token comment">// SyntaxError: Identifier 'a' has already been declared</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-块级作用域内的let"><a href="#2-2-块级作用域内的let" class="headerlink" title="2.2 块级作用域内的let"></a>2.2 块级作用域内的let</h2><p>只要“块级作用域内”存在let命令，它所声明的变量就“绑定”到这个区域，不再受外部的影响</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    a <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span>  <span class="token comment">// ReferenceError: Cannot access 'a' before initialization</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">789</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个和其他语言不太一样，如果是C/C++这样的语言是不会报错的，只会在<code>let a = 789;</code>给出“局部变量覆盖了全局变量”的警告。</p><p>但在ES6中却会报错，我们可以这样理解为“强龙压不过地头蛇”：<br>我用<code>let a = 789;</code>在蓝色区域内声明了变量<code>a</code>，那么在这个蓝色区域的一亩三分地内的都是我说了算，<code>a = 456;</code>敢在我还没声明前都赋值，那我还不给你报个错。<br><img src="https://static.1key.run/blog/img/es6-yufa-1.png"></p><h2 id="2-3-for循环的变量作用域"><a href="#2-3-for循环的变量作用域" class="headerlink" title="2.3 for循环的变量作用域"></a>2.3 for循环的变量作用域</h2><p>for循环设置循环变量的部分是一个父作用域，而循环体内部是一个单独的子作用域</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// abc</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>虽然编译器没有报错，但尽量不要写这样代码，不利于后期维护。</p><h1 id="三、Object与Class"><a href="#三、Object与Class" class="headerlink" title="三、Object与Class"></a>三、Object与Class</h1><p>Object（对象）是ES5就已经有的概念，Class（类）是ES6引入的概念。</p><h2 id="3-1-关于JavaScript中类和对象的叫法"><a href="#3-1-关于JavaScript中类和对象的叫法" class="headerlink" title="3.1 关于JavaScript中类和对象的叫法"></a>3.1 关于JavaScript中类和对象的叫法</h2><p>学过任何一个面向对象编程语言的同学都知道，<strong>对象是类的实例</strong>，比如在Java中：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>a</code>为对象，<code>A</code>为类，也就是“对象a为类型A的实例”。</p><p>而大家可能也发现了很多JavaScript教程称<code>Object</code>、<code>Number</code>、<code>String</code>为<strong>对象</strong>，如果根据这个称呼来，下面的代码岂不是“对象a为对象Number的实例”，很显然在这种叫法很别扭，也不科学：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为什么会出现这种蹩脚的叫法了？因为在ES6之前，JavaScript中没有完全引入<code>Class</code>类的概念，其最多只能算是一个伪的面向对象语言，估计也是为了降低学习理解的难度，所以统称为对象吧。</p><p>既然在ES6中明确引入了Class概念，我们在学习的时候就要明确区分“类”和“对象”的概念了。</p><h2 id="3-2-万物皆对象"><a href="#3-2-万物皆对象" class="headerlink" title="3.2 万物皆对象"></a>3.2 万物皆对象</h2><p>在JavaScript中万物皆对象。学过其他面向对象编程语言的同学知道，对象是类的实例，每个类都可以有构造函数、析构函数、属性和方法。</p><p>在JavaScript中，每个对象都有构造函数、属性、方法，但没有析构函数，我们可以通过下面的代码来验证“万物皆对象”：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [Function: String]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [Function: Number]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// [Function: Boolean]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">34</span><span class="token punctuation">}</span><span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// [Function: Object]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-1-隐式声明对象"><a href="#3-2-1-隐式声明对象" class="headerlink" title="3.2.1 隐式声明对象"></a>3.2.1 隐式声明对象</h3><p>JavaScript访问属性和方法的方式和其他面向对象语言类似：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> msg1 <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span>  <span class="token comment">// msg1为对象，String类的实例</span><span class="token keyword">let</span> x <span class="token operator">=</span> msg1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 访问length属性</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 12</span><span class="token keyword">let</span> msg2 <span class="token operator">=</span> <span class="token string">"Hello world!"</span><span class="token punctuation">;</span>  <span class="token comment">// // msg2为对象，String类的实例</span><span class="token keyword">let</span> y <span class="token operator">=</span> msg2<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问toUpperCase方法</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// HELLO WORLD!</span> <span class="token keyword">let</span> car <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"BMW"</span><span class="token punctuation">,</span> <span class="token literal-property property">price</span><span class="token operator">:</span> <span class="token number">123000</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// car也为对象，{name: "BMW", price: 123000}类的实例</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>car<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// BMW</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>car<span class="token punctuation">.</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大家可以看到上面的代码中都没有使用<code>new</code>来声明对象，但这些对象确确实实存在了，不然我们也无法访问其“属性”和“方法”，我们可以姑且认为这是JavaScript的语法糖吧，或者叫“隐式声明对象”吧。</p><h3 id="3-2-2-显式声明对象"><a href="#3-2-2-显式声明对象" class="headerlink" title="3.2.2 显式声明对象"></a>3.2.2 显式声明对象</h3><p>前面介绍的8种基本数据类型中除了<code>null</code>和<code>undefined</code>之外，都可以使用new来显示的声明对象：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// [Number: 123]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> a1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 124</span><span class="token keyword">let</span> a2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// [Function: anonymous]</span><span class="token keyword">let</span> a3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"xyz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// [String: 'xyz']</span><span class="token keyword">let</span> a4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">null</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// TypeError: null is not a constructor</span><span class="token keyword">let</span> a5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">undefined</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// TypeError: null is not a constructor</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-使用Class定义类"><a href="#3-3-使用Class定义类" class="headerlink" title="3.3 使用Class定义类"></a>3.3 使用Class定义类</h2><p>在ES6中可以使用Class关键字定义类，且每个类都有默认的name属性。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>    <span class="token comment">// 构造函数</span>    <span class="token comment">// constructor方法名称不能修改</span>    <span class="token comment">// 通过new命令生成对象实例时，自动调用该方法。</span>    <span class="token comment">// 一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">h<span class="token punctuation">,</span> w</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> h<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">=</span> w<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// Getter</span>    <span class="token keyword">get</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">calcArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token comment">// Settter</span>    <span class="token keyword">set</span> <span class="token function">setWidth</span><span class="token punctuation">(</span><span class="token parameter">w</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">=</span> w<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 方法</span>    <span class="token function">calcArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>width<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 静态方法</span>    <span class="token keyword">static</span> <span class="token function">printInfo</span><span class="token punctuation">(</span><span class="token parameter">w<span class="token punctuation">,</span> h</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"width:"</span> <span class="token operator">+</span> w <span class="token operator">+</span> <span class="token string">", height:"</span> <span class="token operator">+</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 注意：这个name属性是通过类本身来访问的，而不是类的实例来访问的，是不是有点乱了。。。</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Rectangle<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Rectangle</span><span class="token keyword">let</span> rect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rect<span class="token punctuation">.</span>area<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30</span><span class="token comment">//rect.printInfo(); // TypeError: rect.printInfo is not a function</span>Rectangle<span class="token punctuation">.</span><span class="token function">printInfo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// width:5, height:6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Class的成员都是公共的，外部都可以访问，目前没有从语法层面规定如何定义一个私有的成员</strong></p><h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><p>一个类表达式是定义一个类的另一种方式。类表达式可以是具名的或匿名的。</p><p>一个具名类表达式的名称是类内的一个局部属性，它可以通过类的name属性来获取。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 匿名类</span><span class="token keyword">let</span> Rectangle1 <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">height<span class="token punctuation">,</span> width</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">=</span> width<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Rectangle1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Rectangle1</span>    <span class="token comment">// 具名类</span>  <span class="token keyword">let</span> RectangleX <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">Rectangle2</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">height<span class="token punctuation">,</span> width</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">=</span> width<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RectangleX<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Rectangle2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h1><h2 id="4-1-函数参数是默认声明的变量"><a href="#4-1-函数参数是默认声明的变量" class="headerlink" title="4.1 函数参数是默认声明的变量"></a>4.1 函数参数是默认声明的变量</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo1</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// SyntaxError: Identifier 'x' has already been declared</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="4-2-函数参数可以有默认值"><a href="#4-2-函数参数可以有默认值" class="headerlink" title="4.2 函数参数可以有默认值"></a>4.2 函数参数可以有默认值</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo2</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y <span class="token operator">=</span><span class="token number">1</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//  2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>与C++不同，JavaSript没有要求拥有默认值的参数必须放在参数列表的尾部，所以可以这样写：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo2</span><span class="token punctuation">(</span><span class="token parameter">x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但仔细想一想，这样写并没有什么实际意义。</p><p>另外值得注意的是，函数参数的默认值是每次函数调用时都会动态计算的：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">99</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">p <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 100</span>x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 101</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3-箭头函数"><a href="#4-3-箭头函数" class="headerlink" title="4.3 箭头函数"></a>4.3 箭头函数</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 等同于</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果函数只有一个参数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 等同于</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 括号可以省略，等同于</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果函数没有返回值大括号可以省略：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 大括号可以省略，等同于</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-4-函数的name，length属性"><a href="#4-4-函数的name，length属性" class="headerlink" title="4.4 函数的name，length属性"></a>4.4 函数的name，length属性</h2><p> <code>name</code>可以返回函数名；<br> <code>length</code>可以返回没有指定默认值的参数个数；</p><h1 id="五、数据结构"><a href="#五、数据结构" class="headerlink" title="五、数据结构"></a>五、数据结构</h1><h2 id="5-1-Object"><a href="#5-1-Object" class="headerlink" title="5.1 Object"></a>5.1 Object</h2><p>我们可以向Object对象添加任何属性，所以Object也是一个容器或集合：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [String: 'hello']</span>obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"jeff"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// jeff</span>obj<span class="token punctuation">.</span><span class="token function-variable function">print</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"I'm object"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>obj<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// I'm object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-2-数组"><a href="#5-2-数组" class="headerlink" title="5.2 数组"></a>5.2 数组</h2><p>JavaScript中使用Array类创建数组对象：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 使用Array类创建数组</span><span class="token keyword">let</span> cars1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token string">"Saab"</span><span class="token punctuation">,</span> <span class="token string">"Volvo"</span><span class="token punctuation">,</span> <span class="token string">"BMW"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用Array类创建数组</span><span class="token keyword">let</span> cars2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cars2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Saab"</span><span class="token punctuation">;</span>  <span class="token comment">// 支持[]方式访问和赋值，下标从0开始</span>cars2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Volvo"</span><span class="token punctuation">;</span>cars2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"BMW"</span><span class="token punctuation">;</span><span class="token comment">// 简写方式</span><span class="token keyword">let</span> cars3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Saab"</span><span class="token punctuation">,</span> <span class="token string">"Volvo"</span><span class="token punctuation">,</span> <span class="token string">"BMW"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cars3<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><span class="token comment">// 数组中的元素可以为不同的类型</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"x"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// x</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined，访问数组中不存在的元素会返回undefined，不会报错</span>a<span class="token punctuation">.</span>testProp <span class="token operator">=</span> <span class="token string">"xyz"</span><span class="token punctuation">;</span>      <span class="token comment">// 可以向Array对象添加任意属性</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>testProp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// xyz</span>a<span class="token punctuation">.</span><span class="token function-variable function">print</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"I'm a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>a<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// I'm a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-1-Array类完整的属性"><a href="#5-2-1-Array类完整的属性" class="headerlink" title="5.2.1 Array类完整的属性"></a>5.2.1 Array类完整的属性</h3><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>length</td><td><strong>设置</strong>或获取数组元素的个数</td></tr><tr><td>prototype</td><td>允许你向数组对象添加属性或方法</td></tr></tbody></table><h3 id="5-2-2-Array类完整的方法"><a href="#5-2-2-Array类完整的方法" class="headerlink" title="5.2.2 Array类完整的方法"></a>5.2.2 Array类完整的方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>concat()</td><td>连接两个或更多的数组，并返回结果</td></tr><tr><td>copyWithin()</td><td>从数组的指定位置拷贝元素到数组的另一个指定位置中</td></tr><tr><td>entries()</td><td>返回数组的可迭代对象</td></tr><tr><td>every()</td><td>检测数值元素的每个元素是否都符合条件</td></tr><tr><td>fill()</td><td>使用一个固定值来填充数组</td></tr><tr><td>filter()</td><td>检测数值元素，并返回符合条件所有元素的数组</td></tr><tr><td>find()</td><td>返回符合传入测试（函数）条件的数组元素</td></tr><tr><td>findIndex()</td><td>返回符合传入测试（函数）条件的数组元素索引</td></tr><tr><td>forEach()</td><td>数组每个元素都执行一次回调函数</td></tr><tr><td>from()</td><td>通过给定的对象中创建一个数组</td></tr><tr><td>includes()</td><td>判断一个数组是否包含一个指定的值</td></tr><tr><td>indexOf()</td><td>搜索数组中的元素，并返回它所在的位置</td></tr><tr><td>isArray()</td><td>判断对象是否为数组</td></tr><tr><td>join()</td><td>把数组的所有元素放入一个字符串</td></tr><tr><td>keys()</td><td>返回数组的可迭代对象，包含原始数组的键(key)</td></tr><tr><td>lastIndexOf()</td><td>搜索数组中的元素，并返回它最后出现的位置</td></tr><tr><td>map()</td><td>通过指定函数处理数组的每个元素，并返回处理后的数组</td></tr><tr><td>pop()</td><td>删除数组的最后一个元素并返回删除的元素</td></tr><tr><td>push()</td><td>向数组的末尾添加一个或更多元素，并返回新的长度</td></tr><tr><td>reduce()</td><td>将数组元素计算为一个值（从左到右）</td></tr><tr><td>reduceRight()</td><td>将数组元素计算为一个值（从右到左）</td></tr><tr><td>reverse()</td><td>反转数组的元素顺序</td></tr><tr><td>shift()</td><td>删除并返回数组的第一个元素</td></tr><tr><td>slice()</td><td>选取数组的一部分，并返回一个新数组</td></tr><tr><td>some()</td><td>检测数组元素中是否有元素符合指定条件</td></tr><tr><td>sort()</td><td>对数组的元素进行排序</td></tr><tr><td>splice()</td><td>从数组中添加或删除元素</td></tr><tr><td>toString()</td><td>把数组转换为字符串，并返回结果</td></tr><tr><td>unshift()</td><td>向数组的开头添加一个或更多元素，并返回新的长度</td></tr><tr><td>valueOf()</td><td>返回数组对象的原始值</td></tr></tbody></table><h3 id="5-2-3-数组的复制"><a href="#5-2-3-数组的复制" class="headerlink" title="5.2.3 数组的复制"></a>5.2.3 数组的复制</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> a2 <span class="token operator">=</span> a1<span class="token punctuation">;</span>a2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的例子中，我们发现改变数组<code>a2[1]</code>的值时，数组<code>a1[1]</code>的值也随着改变了，这说明a1和a2指向的是同一块内存区域，这个在C/C++中就是指针的概念，<code>let a2 = a1;</code> 做的是<code>浅拷贝</code>操作。</p><p>如果需要做<code>深拷贝</code>，也就是将数组a1的所有元素克隆一份给a2，可以通过下面的两种方式：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> a2 <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>a2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> a2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>a1<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 也可以写成 let [...a2] = a1;</span>a2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-3-Map"><a href="#5-3-Map" class="headerlink" title="5.3 Map"></a>5.3 Map</h2><p>Map对象用来存储键值对(key-value)，并且能够记住键的原始<strong>插入顺序</strong>。任何对象都可以作为键或值。<br>在Map中Key是唯一的。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> myMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">let</span> keyObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token function-variable function">keyFunc</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> keyString <span class="token operator">=</span> <span class="token string">"a string"</span><span class="token punctuation">;</span> <span class="token comment">// 添加键</span>myMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>keyString<span class="token punctuation">,</span> <span class="token string">"和键'a string'关联的值"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>keyObj<span class="token punctuation">,</span> <span class="token string">"和键keyObj关联的值"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>keyFunc<span class="token punctuation">,</span> <span class="token string">"和键keyFunc关联的值"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMap<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span> <span class="token comment">// 读取值</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>keyString<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 和键'a string'关联的值</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"a string"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 和键'a string'关联的值</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>keyObj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 和键keyObj关联的值</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>keyFunc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 和键keyFunc关联的值</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// undefined, 因为keyObj !== {}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined, 因为keyFunc !== function () {}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMap<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3，返回有多少个键值对</span><span class="token comment">// 和Array一样，可以添加任意属性和方法</span>myMap<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMap<span class="token punctuation">.</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>myMap<span class="token punctuation">.</span><span class="token function-variable function">print</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"I'm map"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>myMap<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// I'm map</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-1-Map与Array相互转换"><a href="#5-3-1-Map与Array相互转换" class="headerlink" title="5.3.1 Map与Array相互转换"></a>5.3.1 Map与Array相互转换</h3><p><strong>Array =&gt; Map</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Map { 1 =&gt; 'one', 2 =&gt; 'two' }</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Map =&gt; Array</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"tow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> arr2 <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// [ [ 1, 'one' ], [ 2, 'two' ] ]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-2-Map的复制"><a href="#5-3-2-Map的复制" class="headerlink" title="5.3.2 Map的复制"></a>5.3.2 Map的复制</h3><p>Map在直接赋值的时候会遇到和Array同样的“浅拷贝”的问题，如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> map1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map1<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map1<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"tow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> map2 <span class="token operator">=</span> map1<span class="token punctuation">;</span>map2<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// three，修改map2会导致map1的值也被修改了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 可以通过下面的方式完成Map的深拷贝：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> map1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map1<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map1<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"tow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> map2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span>map1<span class="token punctuation">)</span><span class="token punctuation">;</span> map2<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// one</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// three</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-4-Set"><a href="#5-4-Set" class="headerlink" title="5.4 Set"></a>5.4 Set</h2><p>Map是键值对的集合，而Set则只是键（key）的集合。</p><p>Set中的每个元素都是唯一的。</p><p>任何对象都可以作为Set的元素。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"str"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 自动去重了</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Set { 1, 2, 3, 'str' }</span><span class="token comment">// 新增使用Add</span>s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Set { 1, 2, 3, 'str', 9, [Function] }</span><span class="token comment">// 删除使用delete</span>s<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Set { 2, 3, 'str', 9, [Function] }</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-5-迭代器"><a href="#5-5-迭代器" class="headerlink" title="5.5 迭代器"></a>5.5 迭代器</h2><p>前面介绍Object、Array、Map、Set这些容器的时候，都避开了一个话题：遍历。本节主要介绍如何遍历JavaScript中的容器或集合。</p><p>迭代器（Iterator）就是一个接口，为各种不同的数据结构提供统一的遍历访问机制。任何数据结构只要实现Iterator 接口，就可以完成遍历操作。</p><p>在学习如何自定义迭代器之前，我们先学习一下如何遍历JavaScript常用的数据集合：</p><h3 id="5-5-1-遍历字符串"><a href="#5-5-1-遍历字符串" class="headerlink" title="5.5.1 遍历字符串"></a>5.5.1 遍历字符串</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">of</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*hello*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-5-2-遍历数组"><a href="#5-5-2-遍历数组" class="headerlink" title="5.5.2 遍历数组"></a>5.5.2 遍历数组</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"str"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*1str2*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-5-3-遍历Map"><a href="#5-5-3-遍历Map" class="headerlink" title="5.5.3 遍历Map"></a>5.5.3 遍历Map</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>k<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token keyword">of</span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*1:one2:two3:function () { }*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="六、解构赋值"><a href="#六、解构赋值" class="headerlink" title="六、解构赋值"></a>六、解构赋值</h1><p>解构(Destructuring)赋值分为“数组的解构赋值”和“对象的解构赋值”。</p><h2 id="6-1-数组的解构赋值"><a href="#6-1-数组的解构赋值" class="headerlink" title="6.1 数组的解构赋值"></a>6.1 数组的解构赋值</h2><pre class="line-numbers language-Javascript" data-language="Javascript"><code class="language-Javascript">let [a, b, c] = [1, 2, 3];   // 根据位置依次取值// a = 1// b = 2// c = 3let [foo, [[bar], baz]] = [1, [[2], 3]];// foo = 1// bar = 2// baz = 3let [ , , third] = ["foo", "bar", "baz"];// third = "baz"let [head, ...tail] = [1, 2, 3, 4];// head = 1// tail = [2,3,4]let [x, y, ...z] = ["a"];  // x = "a"// y = undefined// z = []let [foo] = [];        // foo = undefinedlet [bar, foo] = [1];  // foo = undefinedlet [bar, foo = true] = [1]; // 可以赋默认值// bar = 1// foo = truelet [x, y] = [1, 2, 3];// x = 1// y = 2let [a, [b], d] = [1, [2, 3], 4];// a = 1// b = 2// d = 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-2-对象的解构赋值"><a href="#6-2-对象的解构赋值" class="headerlink" title="6.2 对象的解构赋值"></a>6.2 对象的解构赋值</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">"aaa"</span><span class="token punctuation">,</span> <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token string">"bbb"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 和顺序没关系，根据属性名来取值</span><span class="token comment">// foo = "aaa"</span><span class="token comment">// bar = "bbb"</span><span class="token keyword">let</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token string">'baz'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// foo = undefined</span><span class="token comment">// 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量</span><span class="token comment">// 如：console对象有log方法，我们可以这样使用：</span><span class="token keyword">const</span> <span class="token punctuation">{</span> log <span class="token punctuation">}</span> <span class="token operator">=</span> console<span class="token punctuation">;</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span> <span class="token comment">// hello</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="七、promise、async、await"><a href="#七、promise、async、await" class="headerlink" title="七、promise、async、await"></a>七、promise、async、await</h1><p>promise、async、await这三个关键字都和异步编程有关。</p><h2 id="7-1-Promise"><a href="#7-1-Promise" class="headerlink" title="7.1 Promise"></a>7.1 Promise</h2><p>Promise翻译成中文就是“承诺”的意思，声明一个Promise就是立下了一个承诺，无论怎么样，都会给被承诺人一个结果，而且这个结果是板上钉钉的，不会再变。</p><p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p><p>声明Promise对象时需要传入一个函数对象作为参数，这个函数对象的2个参数也是函数对象（<code>resolve</code>, <code>reject</code>），<code>resolve</code>和<code>reject</code>不需要开发者定义，Javascript引擎会自动生成这2个函数。</p><p>当Promise对象生成后会立即变成<code>pending</code>状态，调用<code>resolve</code>函数会将Promise对象标记为<code>fulfilled</code>状态，而调用<code>reject</code>函数则会将当前Promise对象标记<code>rejected</code>状态。</p><p><code>resolve</code>和<code>rejected</code>函数，我们只能调用它们中的一个，不能即调用<code>resolve</code>又调用<code>rejected</code>。如果我们先调用了<code>resolve</code>，此时Promise状态会标记为<code>fulfilled</code>，然后又调用了<code>rejected</code>函数，此时Promise状态并不会再改变，仍然使<code>fulfilled</code>状态，因为承诺的结果是板上钉钉的，不会再变。建议将<code>resolve</code>和<code>reject</code>作为最后一行代码调用，简单起见，可以在这2个函数前面加上<code>return</code>, 即<code>return resolve();</code>或<code>return reject();</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// Promise的参数为一个函数对象，函数有2个参数resolve, reject</span><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token comment">// 做一些耗时的操作，比如网络请求</span>    <span class="token comment">// 这里我们使用一个延时器来模拟耗时的网络请求</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 延时1000ms之后成功</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 成功则调用 resolve();</span>    <span class="token comment">// 失败则调用 reject();</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么，我想在这个异步操作完成之后，再根据结果（是成功了，还是失败了）来继续做下一件事情，那我们该怎么做了？<br>Promise对象提供了<code>then</code>方法，该方法接受2个函数对象作为参数：<br>第一个回调函数是Promise对象的状态变为<code>resolved</code>时调用;<br>第二个回调函数是Promise对象的状态变为<code>rejected</code>时调用。<br>其中，第二个函数是可选的，不一定要提供。每个回调函数都可以接受一个参数，这个参数就是上一步调用resolve或reject时传入的。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 上面的耗时操作完成之后，我们可能还需要根据结果来继续做一些事情</span><span class="token comment">// 此时就可以使用then，then函数有2个参数，分别为2个函数对象。</span><span class="token comment">// 上一步操作中，如果调用resolve(data)，则then函数第一个函数对象参数会被调用；</span><span class="token comment">// 如果调用reject(data)，则then函数第二个函数对象参数会被调用</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"resolve1: "</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"reject1: "</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我在第一个参数中直接通过return返回了”hello”字符串，那这个返回值的意义在哪里了？还有其他人可以使用到这个返回值吗？<br>是的，还可以继续使用。因为<code>then</code>的返回值是一个Promise对象，虽然我只是使用的<code>return "hello";</code>，并没有<code>new Promise</code>，但JavaScript引擎会自动包装成一个Promise对象，等同于：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"resolve1: "</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"reject1: "</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这儿了，我们知道了<code>then</code>的返回的是一个<code>Promise</code>对象。既然<code>then</code>返回的是<code>Promise</code>对象，那么<code>Promise</code>就可以继续<code>then</code>呀，然后一直<code>then</code>下去….这样我们就可以将一系列异步的操作串联起来了：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token comment">// ...</span>    <span class="token comment">// resolve(); 或 reject();</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>     <span class="token comment">// ...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token comment">// ...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>     <span class="token comment">// ...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但多个异步操作串联执行，还有一点需要注意，我们看下面的例子：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 延时1000ms</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"ok1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"resolve1: "</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 延时1000ms</span>        <span class="token keyword">return</span> <span class="token string">"ok2"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"resolve2: "</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们期望的输出是：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">resolve1</span><span class="token operator">:</span> ok1<span class="token literal-property property">resolve2</span><span class="token operator">:</span> ok2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但实际的输出却是：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">resolve1</span><span class="token operator">:</span> ok1<span class="token literal-property property">resolve2</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>问题出在第二个setTimeout模拟的耗时操作，我们以为程序会等第二个setTimeout执行完了再执行第二个then，但事实上setTimeout也是一个异步操作，虽然其延时了一秒执行其回调函数，但setTimeout这条语句却马上执行完成了，导致第一个then没有任何返回，针对这种情况，我们需要将代码改成下面的：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 延时1000ms</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"ok1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"resolve1: "</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 延时1000ms</span>            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"ok2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"resolve2: "</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-2-Promise异常捕获"><a href="#7-2-Promise异常捕获" class="headerlink" title="7.2 Promise异常捕获"></a>7.2 Promise异常捕获</h2><p>Promise对象还提供了<code>catch</code>方法，用来捕获异常。在介绍<code>catch</code>前，我们先看看下面的代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"an error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"resolve: "</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"reject: "</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出：</span><span class="token comment">// reject: Error: an error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在Promise中人为抛出了一个异常，但是程序却还是没有中止，而是运行到了reject过程中去了。</p><p>这是因为Promise默认会捕获其操作过程中的异常，如果有异常发生，其状态就会自动变成<code>rejected</code>，还记得前面说过Promise状态一旦确定就不会再改变了吧，所以即便后面的<code>resolve("ok");</code>执行了，也不会改变promise状态（事实上throw语句后的代码并没有机会执行）。</p><p>那么，假如我们没有写reject回调函数会怎么样了？看看下面的代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"an error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"resolve: "</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中由于没有指定异常处理函数，所以程序抛出了异常信息，中止执行了。</p><p>另外，<strong>Promise的异常是会一直向下传递的</strong>，直到最后有人处理，如果始终没人处理，程序就会抛出异常信息，然后中止：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"an error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"resolve1: "</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"resolve2: "</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"reject2: "</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出：</span><span class="token comment">// reject: Error: an error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中，第一个then没有处理异常，异常向下传递给第二个then, 第二个then处理了该异常，程序继续运行。</p><p>现在理解<code>Promise.catch()</code>方法就容易多了。<code>catch()</code>方法其实就是<code>.then(null, rejectiion)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><p>我们一般总是建议，Promise 对象后面要跟catch()方法，这样可以处理 Promise 内部发生的错误。catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()方法。</p><h2 id="7-3-async-await"><a href="#7-3-async-await" class="headerlink" title="7.3 async, await"></a>7.3 async, await</h2><p>async 是<code>ES7</code>才有的与异步操作有关的关键字，需要和<code>Promise</code>配合使用，<code>async</code>函数返回一个 <code>Promise</code>对象，可以使用<code>then</code>方法添加回调函数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">helloAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"helloAsync"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">helloAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">helloAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">// 输出：</span><span class="token comment">// Promise { 'helloAsync' }</span><span class="token comment">// helloAsync</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>await</code>关键字<code>只</code>能用在被<code>async</code>标记的函数体内，<code>async</code>函数执行时，如果遇到<code>await</code>就会先暂停执行，等到触发的异步操作完成后，恢复<code>async</code>函数的执行并返回解析值。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">testAwait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"testAwait"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">helloAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token function">testAwait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"helloAsync"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">helloAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出：</span><span class="token comment">// testAwait</span><span class="token comment">// helloAsync</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECMAScript6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows平台生成Dump文件</title>
      <link href="/2023/06/28/windows-ping-tai-sheng-cheng-dump-wen-jian/"/>
      <url>/2023/06/28/windows-ping-tai-sheng-cheng-dump-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>​<br>转储文件也就是我们常说的dump文件。可以把转储文件看成软件的某个时刻的一个快照。转储文件一般都是在软件出现问题时手动生成或者程序自动生成。</p><h1 id="一、工具篇"><a href="#一、工具篇" class="headerlink" title="一、工具篇"></a>一、工具篇</h1><p>下面我们介绍几种借助第三方工具生成转储文件的方法。</p><h2 id="1-1-任务管理器"><a href="#1-1-任务管理器" class="headerlink" title="1.1 任务管理器"></a>1.1 任务管理器</h2><p>任务管理器可以说是最易获取的系统工具，同时它具有生成转储文件的功能。但要注意的是在64位操作系统上面，默认启动的是64位的任务管理器。使用任务管理器生成转储文件需要遵循一个原则：用32位任务管理器给32位进程（无论该进程是运行在32位还是64位系统上面）生成转储文件，用64位任务管理器给64位进程生成转储文件。</p><p>在64位系统上，32位的任务管理器位于<code>C:\Windows\SysWOW64\taskmgr.exe</code>。</p><p>生成方法：右键进程 –&gt; 创建转储文件–&gt;弹出对话框提示生成成功，以及dmp文件位置。<br><img src="https://static.1key.run/blog/img/windows-sc-dump-1.jpg"></p><p>类似的工具还有：Process Explorer，PCHunter等。</p><h2 id="1-2-注册表"><a href="#1-2-注册表" class="headerlink" title="1.2 注册表"></a>1.2 注册表</h2><p>可以通过在注册表中进行配置，让操作系统在程序崩溃时自动生成dmp文件，并放到指定位置。<br>在注册表项HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting\LocalDumps下面根据进程名（含.exe）新建子项，并配置如下值：<br>名称：DumpCount，类型：REG_DWORD，最大保留Dump个数，默认为10.<br>名称：DumpType，类型：REG_DWORD，Dump类型(1-Mini dump, 2-Full dump)，默认为1.<br>名称：DumpFolder，类型：REG_EXPAND_SZ，Dump文件保存的位置。</p><p><img src="https://static.1key.run/blog/img/windows-sc-dump-2.jpg"></p><h2 id="1-3-Windbg"><a href="#1-3-Windbg" class="headerlink" title="1.3 Windbg"></a>1.3 Windbg</h2><p>生成方法：File菜单–&gt;Attach to Process–&gt;输入命令<code>.dump /ma /u d:\test.dmp</code><br>提示成功之后，可以在D盘看到生成dmp文件到test_0bf0_2017-08-13_23-46-37-244_11cc.dmp文件。</p><p>0bf0_2017-08-13_23-46-37-244_11cc是/u参数附加上去的，意思是2017年08月13日 23时46分37秒244毫秒，进程PID位11cc。</p><p>.dump命令参数比较多，常用的组合就是<code>/ma</code>，/m表示生成minidump，/a表示dmp包含所有信息，/u参数就是上面说的附加时间和PID信息到文件名。</p><h2 id="1-4-Windbg-I"><a href="#1-4-Windbg-I" class="headerlink" title="1.4 Windbg -I"></a>1.4 Windbg -I</h2><p>Windbg -I&nbsp;可以将Windbg设置为及时调试器（开启了UAC的系统上面，需要以管理员权限运行），也就是我们常说的JIT调试器。设置成功之后，如遇到程序崩溃，Windbg会自动运行并附加到崩溃进程。</p><p>设置成功之后会弹出对话框提示设置成功。如果不想弹出对话框，可以加上S（slient首字母）Windbg -IS.</p><p>也可以通过修改注册表项AeDebug来实现和windbg -I同样的功能。<br>根据windbg位数（32/64）和系统的位数（32/64）的不同，修改的注册表项的位置也不同：</p><ul><li>32位windbg–32位系统：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug</li><li>32位windbg–64位系统：HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\AeDebug</li><li>64位windbg–64位系统：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug</li></ul><p>AeDebug项下面有2个值：<br>名称：Auto，类型：REG_SZ，0表示出现崩溃弹出对话框，让用户选择关闭程序还是调试程序；1表示自动弹出设置调试器。<br>名称：Debugger，类型：REG_SZ，调试器值。默认为”C:\WINDOWS\system32\vsjitdebugger.exe” -p %ld -e %ld，设置为windbg需更改为”C:\Debuggers\WinDbg\x86\windbg.exe” -p %ld -e %ld -g</p><p>看起来挺复杂，其实挺好理解的。</p><h2 id="1-5-Adplus"><a href="#1-5-Adplus" class="headerlink" title="1.5 Adplus"></a>1.5 Adplus</h2><p>adplus工具位于windbg安装目录，最早叫adplus.vbs，以VBScript脚本提供，最新版改成了adplus.exe。adplus.exe不仅可以在程序崩溃时手动运行来生成dmp文件，也可以在崩溃之前就运行它，当程序崩溃时它会自动生成dmp文件；甚至可以在程序没有运行之前就先运行adplus，当程序崩溃时它会自动生成dmp文件。<br>如：adplus -pn powerpnt.exe -pn wincmd32.exe -hang -o c:\test</p><p>Adplus用法：</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">ADPlus &lt;RunMode&gt; -o &lt;OutputDirectory&gt; [Options]RunMode：-hang或-crash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-hang&nbsp;附加到进程，生成dmp，然后解除附加(detach)。多用于程序卡死的情况下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-crash&nbsp;附加到进程，直到程序崩溃或者其他事件发生，生成dmp文件，然后解除附加。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>常用参数：</p><ul><li><p>-o 目录<br>指定生成文件存储目录。</p></li><li><p>-p 进程ID<br>指定进程ID，可以同时使用多次-p来指定多个进程。</p></li><li><p>-pn 进程名<br>指定进程名，支持通配符，也可以同时使用多次-pn来指定多个进程，但进程名必须存在，不存在则失败。</p></li><li><p>-po 进程名<br>和-pn类似，但-po不要求进程名必须存在。可以在进程启动之前就先启动Adplus.</p></li><li><p>-pmn 进程名<br>pmn为Process Monitor缩写。顾名思义，可以监视进程列表，一旦指定进程运行，则附加上去。只适用于-crash&nbsp;模式。</p></li></ul><p>​# 二、代码篇<br>下面介绍如何使C++程序在崩溃时，自动生成Dump。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">// EasyDump.h#pragma once #include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;strsafe.h&gt; namespace cpp4j {typedef struct _EXCEPTION_POINTERS EXCEPTION_POINTERS, *PEXCEPTION_POINTERS; int __cdecl RecordExceptionInfo(PEXCEPTION_POINTERS pExceptPtrs, const TCHAR *szDumpNamePrefix);TCHAR *lstrrchr(LPCTSTR string, int ch);void DumpMiniDump(HANDLE hFile, PEXCEPTION_POINTERS excpInfo);} #define WINMAIN_BEGIN(szDumpNamePrefix) \    int __96A9695E_RUN_WINMAIN_FUNC(HINSTANCE hInstance, LPTSTR lpCmdLine);\    LONG WINAPI __96A9695E_UnhandledExceptionHandler( _EXCEPTION_POINTERS *pExceptionInfo ) \    { \        OutputDebugString(TEXT("Create a dump file sine an exception occurred in sub-thread.\n")); \        int iRet = cpp4j::RecordExceptionInfo(pExceptionInfo, szDumpNamePrefix); \        return iRet; \    } \    int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow) \    { \        UNREFERENCED_PARAMETER(hPrevInstance); \        UNREFERENCED_PARAMETER(nCmdShow); \        ::SetUnhandledExceptionFilter( __96A9695E_UnhandledExceptionHandler );\        int ret = 0;\        __try\        {\            ret = __96A9695E_RUN_WINMAIN_FUNC(hInstance, lpCmdLine);\        }\        __except(cpp4j::RecordExceptionInfo(GetExceptionInformation(), szDumpNamePrefix))\        {\            OutputDebugString(TEXT("Create a dump file sine an exception occurred in main-thread.\n")); \        }\        return ret;\    }\    int __96A9695E_RUN_WINMAIN_FUNC(HINSTANCE hInstance, LPTSTR lpCmdLine) \    { #define WINMAIN_END }    #define MAIN_BEGIN(szDumpName) \    int __96A9695E_RUN_MAIN_FUNC(int argc, _TCHAR* argv[]);\    LONG WINAPI __96A9695E_UnhandledExceptionHandler( _EXCEPTION_POINTERS *pExceptionInfo ) \    { \        OutputDebugString(TEXT("Create a dump file since an exception occurred in sub-thread.\n")); \        int iRet = cpp4j::RecordExceptionInfo(pExceptionInfo, szDumpName); \        return iRet; \    } \    int _tmain(int argc, _TCHAR* argv[])\    { \        ::SetUnhandledExceptionFilter( __96A9695E_UnhandledExceptionHandler );\        int ret = 0;\        __try\        {\            ret = __96A9695E_RUN_MAIN_FUNC(argc, argv);\        }\        __except(cpp4j::RecordExceptionInfo(GetExceptionInformation(), szDumpName))\        {\            OutputDebugString(TEXT("Create a dump file since an exception occurred in main-thread.\n")); \        }\        return ret;\    }\    int __96A9695E_RUN_MAIN_FUNC(int argc, _TCHAR* argv[]) \    { #define MAIN_END }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">// EasyDump.cpp#include "EasyDump.h"#include &lt;DbgHelp.h&gt;#pragma comment(lib, "Dbghelp.lib") namespace cpp4j {TCHAR *lstrrchr(LPCTSTR string, int ch) {TCHAR *start = (TCHAR *)string; while (*string++); while (--string != start &amp;&amp; *string != (TCHAR)ch); if (*string == (TCHAR)ch)return (TCHAR *)string; return NULL;} inline void DumpMiniDump(HANDLE hFile, PEXCEPTION_POINTERS excpInfo) {if (!excpInfo) {static int iTimes = 0;if (iTimes++ &gt; 1)return; __try {RaiseException(EXCEPTION_BREAKPOINT, 0, 0, NULL);}__except (DumpMiniDump(hFile, GetExceptionInformation()),EXCEPTION_CONTINUE_EXECUTION) {}}else {MINIDUMP_EXCEPTION_INFORMATION eInfo;eInfo.ThreadId = GetCurrentThreadId();eInfo.ExceptionPointers = excpInfo;eInfo.ClientPointers = FALSE; MiniDumpWriteDump(GetCurrentProcess(),GetCurrentProcessId(),hFile,MiniDumpNormal,excpInfo ? &amp;eInfo : NULL,NULL,NULL);}} int __cdecl RecordExceptionInfo(PEXCEPTION_POINTERS pExceptPtrs, const TCHAR *szDumpNamePrefix) {static bool bFirstTime = true; if (!bFirstTime)return EXCEPTION_CONTINUE_SEARCH; bFirstTime = false; // Dmp文件命名：前缀_年月日.时.分.秒.毫秒.dmp//TCHAR szLocalTime[50] = { 0 };SYSTEMTIME st;GetLocalTime(&amp;st);StringCchPrintf(szLocalTime, 50, TEXT("%04d%02d%02d.%02d.%02d.%02d.%04d"), st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds); TCHAR szExeDir[MAX_PATH + 1] = { 0 }; GetModuleFileName(NULL, szExeDir, MAX_PATH); if (TCHAR *p = lstrrchr(szExeDir, TEXT('\\'))) {*(p + 1) = 0;} TCHAR szDumpFileName[MAX_PATH + 1] = { 0 };_stprintf_s(szDumpFileName, MAX_PATH, TEXT("%s%s_%s.dmp"), szExeDir, szDumpNamePrefix, szLocalTime); HANDLE hMiniDumpFile = CreateFile(szDumpFileName,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,NULL); if (hMiniDumpFile != INVALID_HANDLE_VALUE) {DumpMiniDump(hMiniDumpFile, pExceptPtrs); CloseHandle(hMiniDumpFile);hMiniDumpFile = NULL;} return EXCEPTION_EXECUTE_HANDLER;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MAIN_BEGIN中的参数为生成的dump文件的前缀，dump文件命名方式: <code>前缀_年月日.时.分.秒.毫秒.dmp</code>。</p><p>使用方法很简单，使用<code>MAIN_BEGIN</code>替换<code>main</code>，<code>WINMAIN_BEGIN</code>替换<code>WinMain</code>即可：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include "EasyDump.h" MAIN_BEGIN(TEXT("Test")) int i = 0;int *p = &amp;i;p = NULL;*p = 5; return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码会在程序的当前目录生成一个名为Test_20171101.14.49.57.0264.dmp的dump文件。</p>]]></content>
      
      
      <categories>
          
          <category> 软件调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dump </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windbg基本使用方法</title>
      <link href="/2023/06/28/windbg-ji-ben-shi-yong-fang-fa/"/>
      <url>/2023/06/28/windbg-ji-ben-shi-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>从下面的链接或其他链接下载安装：<br><a href="https://developer.microsoft.com/en-us/windows/hardware/download-windbg">Download Debugging tools for Windows</a></p><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>常用的配置包含符号文件搜索路径、可执行文件搜索路径、源码文件搜索路径配置。</p><ul><li><p>符号文件搜索路径配置（Symbol File Path）<br>在菜单项<code>File-&gt; Symbol File Path</code>中设置，如<code>D:\symbol_path;SRV*D:\symbolslocal*http://msdl.microsoft.com/download/symbols</code>意思是先从<code>D:\symbol_path</code>中找符号文件；如果没找到，就去服务器中下载并保存到<code>D:\symbolslocal</code>目录中。<br>可以使用<code>.sympath+ </code>命令来添加其他目录到搜索路径中，如<code>.sympath+ D:\other_symbol_dir</code>。 然后使用<code>.reload</code>来根据新的路径重新搜索并加载符号文件。</p></li><li><p>Image File Path配置<br>此项是在加载dump时，设置可执行文件exe、dll的路径的。</p></li><li><p>Source File Path配置<br>设置源代码目录。如果当前指令指针在源代码范围内，就会自动跳出源文件窗口。源文件窗口中的操作和vs类似。如果没有跳出，可以单机菜单项Open Source File手动选择源文件</p></li><li><p>启动命令<br>可以使用对windbg加入启动参数，通过启动参数指定符号文件路径和源码路径等等。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">start "" "%~dp0/Debuggers_x86/windbg.exe" -Q -y "D:\symbolslocal*http://msdl.microsoft.com/download/symbols" -srcpath "srv*C:\CodeCache"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="三、开始调试"><a href="#三、开始调试" class="headerlink" title="三、开始调试"></a>三、开始调试</h2><p>可以通过菜单项<code>File -&gt; Open Executable</code>来加载本地的一个exe来进行调试，也可以通过菜单项<code>File -&gt; Attache to a Process</code>来加载一个已经运行的exe来进行调试。 </p><p>具体调试指令可以参考：<br><code>Help -&gt; Contents -&gt; Debugging Tools for Windows -&gt; Debuggers -&gt; Debugger Reference</code></p><h2 id="四、工作空间"><a href="#四、工作空间" class="headerlink" title="四、工作空间"></a>四、工作空间</h2><p>Windbg会保存每个你调试的工程的信息，这些信息包括调试项目的属性、参数、会话状态、调试器设置、及图形界面信息，类似于ide的项目文件。<br>每个调试的工作空间信息默认保存在<br><code>HKEY_CURRENT_USER\Software\Microsoft\Windbg\Workspaces</code>中，在这个键下一般有4个子键User、Kernel、Dump、Explicit, 他们分别保存用户态调试，内核态调试、转储文件调试、以及手动保存（Save Workspace As）的工作空间信息。</p><h1 id="五、窗口界面介绍"><a href="#五、窗口界面介绍" class="headerlink" title="五、窗口界面介绍"></a>五、窗口界面介绍</h1><table><thead><tr><th>名称</th><th>热键</th><th>用途</th></tr></thead><tbody><tr><td>Command</td><td>Atl+1</td><td>输入命令、显示命令结果和调试信息输出</td></tr><tr><td>Watch</td><td>Atl+2</td><td>观察指令全局变量、局部变量和寄存器的信息</td></tr><tr><td>Locals</td><td>Atl+3</td><td>自动显示当前函数的所有局部变量</td></tr><tr><td>Registers</td><td>Atl+4</td><td>观察和修改寄存器的值</td></tr><tr><td>Memory</td><td>Atl+5</td><td>观察和修改内存数据</td></tr><tr><td>Call Stack</td><td>Atl+6</td><td>栈中记录的函数调用序列</td></tr><tr><td>Disassembly</td><td>Atl+7</td><td>反汇编</td></tr><tr><td>Scratch Pad</td><td>Atl+8</td><td>白板，可以用来做调试笔记等</td></tr><tr><td>Processes and Threads</td><td>Atl+9</td><td>显示所有调试目标的列表，包括进程和线程等</td></tr><tr><td>Command Browser</td><td>Ctrl+N</td><td>执行和浏览命令</td></tr></tbody></table><h1 id="六、常用命令"><a href="#六、常用命令" class="headerlink" title="六、常用命令"></a>六、常用命令</h1><p>windbg命令分为<code>标准命令</code>，<code>元命令</code>和<code>扩展命令</code>。<br>以<code>.</code>开头的元命令提供标准命令没有提供的功能，也内建在调试引擎中。<br>以<code>!</code>开头的扩展命令用于扩展某一方面的调试功能，实现在动态加载的扩展模块中。</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">tab键       自动完成命令.hh         查看指定命令的帮助手册.reload     重新加载符号文件 .restart    重新启动调试目标 bp $exentry 在程序入口点设置断点，$exentry是一个伪寄存器 bp 0x00401030              在地址0x00401030处设置断点 bp MyTestModule!MyTestFunc 在MyTestModule模块中的MyTestFunc函数处设置断点，前提是该模块符号已经加载 bp MyTestModule!MyTestClass::SetValue        在模块MyTestModule的MyTestClass类成员函数SetValue处设置断点 bp @@C++(MyTestModule!MyTestClass::SetValue) 与上面一样，语法不同，C++语法，上面的为MASM语法 bl 查看设置的断点 be 激活断点 bd 禁用断点 bc 删除某个断点 ba              设置访问断点 ba r 1 0044108c 在内存0044108c的位置开始的下一个字节的读断点 ba w4@@C++(&amp;i)  给变量i地址下4个字节的写断点 g               运行程序，相当于F5 gu              返回函数调用处，相当于shift+F11 u               查看当前正要执行的代码 k               查看当前调用堆栈 ~*kb        显示所有进程调用堆栈~           查看调试进程中的线程信息 !teb        线程环境块~.          当前线程信息~#          导致当前异常或调试事件的线程信息~[Number]s  线程切换a                                修改当前指令，输入修改的指令按Enter结束 s –a 00400000 L53000 “Wrong”     以ASCII码的形式从00400000处开始往后53000个字节搜索字符串“Wrong” db 400000       以二进制的方式显示内存地位为400000开始的内容 dd 400000       以DWORD类型查看 d               按上一次的d命令的方式来显示，如果不带参数，则从上一次显示结束的地方继续显示 ?i              查看局部变量i的值，会以10进制和16进制同时显示 eb 0012ff78 'a' 'b'      从内存地址0012ff78开始依次写入后面的值 r                        用于查看或者修改寄存器或伪寄存器 r $peb                   $peb是一个伪寄存器，调试器将它定义为当前进程的进程环境块地址 dt                       用于查看结构体内容 !address 400000          查看指定内存地址的信息 dv                       查看当前作用域下局部变量的类型和值.ecxr                 当前异常的上下文信息!analyze -v              详细显示当前异常信息，常用于分析dmp文件|             所有进程列表|.          当前进程信息|#          导致当前异常或调试事件的进程信息|[Number]s  进程切换!peb      进程环境块!locks              查看进程中有些锁处于锁定状态!cs -l              查看处于锁定状态的关键区!handle 000000c0 f  查看句柄000000c0的信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="七、常用调试方法"><a href="#七、常用调试方法" class="headerlink" title="七、常用调试方法"></a>七、常用调试方法</h1><h2 id="7-1、附加进程调试"><a href="#7-1、附加进程调试" class="headerlink" title="7.1、附加进程调试"></a>7.1、附加进程调试</h2><p>使用File菜单中的Attach to a Process选项来选择要附加调试的进程.</p><h2 id="7-2、启动调试新进程"><a href="#7-2、启动调试新进程" class="headerlink" title="7.2、启动调试新进程"></a>7.2、启动调试新进程</h2><ol><li>使用菜单<code>File-&gt; Open Executable</code>选项来选择要启动调试的进程。</li><li>启动windbg时将待调试的程序的文件路径作为参数传递给windbg。</li><li>在注册表<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options</code>下新建一个以程序名命名的子项，然后在这个子项中新建一个名为<code>Debugger</code>的<code>REG_SZ</code>类型的值，将值设置为windbg的全路径，比如C:\Program Files (x86)\Windows Kits\8.1\Debuggers\x86\windbg.exe。这样，再运行待调试的程序时，操作系统就会先启动windbg，并把要调试程序的路径传递给他。</li></ol><h2 id="7-3、调试转储文件"><a href="#7-3、调试转储文件" class="headerlink" title="7.3、调试转储文件"></a>7.3、调试转储文件</h2><p>使用File菜单中的Open Crash Dump选项来加载dump文件。</p><h2 id="7-4、远程调试"><a href="#7-4、远程调试" class="headerlink" title="7.4、远程调试"></a>7.4、远程调试</h2><p>服务器（被调试程序的机器）和客户端（发出远程请求的机器）都应该安装版本相同的windbg，应该有网络连接或者串行口连接。 </p><ul><li><p>以tcp端口方式：<br>以命令行的方式启动服务器中的windbg，如：windbg.exe -server tcp:port=5005<br>以命令行的方式启动客户端中的windbg，如：windbg.exe -remote tcp:port=5005,server=192.168.1.180</p></li><li><p>以管道方式：<br>以命令行的方式启动服务器中的windbg，如：windbg -server npipe:pipe=advdbg （adbdbg为命名管道名称）。<br>在客户端中以命令行的方式启动windbg，如：windbg -remote npipe:server=REMOTEHOSTNAME,pipe=advdbg （REMOTEHOSTNAME为远程主机名，dbvdbg为远程主机创建的命名管道名，也可以选择File菜单中的Connect to Remote Session,在弹出来的编辑框中输入远程参数npipe:server=REMOTEHOSTNAME,pipe=advdbg）</p></li></ul><p>成功连接后，命令行信息区会显示类似如下信息：<br>…(npipe advdbg) connected at Thu Jul 11 14:22:02 2017<br>之后可以在客户端或者服务器的windbg中执行各种调试命令，执行结果会同时显示在两个调试器中。</p><p>其它的远程调试方案，可以参考:<br><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/remode-debugging-using-windbg">https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/remode-debugging-using-windbg</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在C++中使用Lamada表达式</title>
      <link href="/2023/06/28/zai-c-zhong-shi-yong-lamada-biao-da-shi/"/>
      <url>/2023/06/28/zai-c-zhong-shi-yong-lamada-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<p>Lamada表达式是C++11最重要也是最常用的特性之一。Lamada来源于函数式编程的概念，也是现代编程语言的一个特点。</p><h1 id="一、Lamada表达式定义"><a href="#一、Lamada表达式定义" class="headerlink" title="一、Lamada表达式定义"></a>一、Lamada表达式定义</h1><p>下图展示出了C++ Lamada表示的组成部分：<br><img src="https://static.1key.run/blog/img/lambdaexpsyntax-1.png"></p><p>其中：<br>① 指明捕获列表。<br>② 指明参数列表。<br>③ <code>mutable</code>可选项。和常规的mutable用法类似，即当lamada表达式参数是const时，使用<code>mutable</code>可以取消这种const。<br>④ <code>throw</code>可选项。可以使用<code>noexcept</code>指明/约束表达式内不会抛出异常。<br>⑤ 指定返回类型。<br>⑥ Lamada函数体。</p><p>根据上图定义一个完整的lamada表达式：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">auto f = [](int a) noexcept -&gt; int { return a + 1; };<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="二、返回类型"><a href="#二、返回类型" class="headerlink" title="二、返回类型"></a>二、返回类型</h1><p>很多时候lamada表达式的返回值类型是非常明显的，编译器可以根据<code>return</code>语句自动推导出返回类型，这个时候我们可以省略表达式的返回值定义：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">auto x1 = [](int a) {return a + 1};     // OK: return type is int<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是，初始化列表不能用于返回值的自动推导：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">auto x2 = [](int a) {return {a+1, a+2}; };   // error: 无法推导出返回值类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="三、捕获列表"><a href="#三、捕获列表" class="headerlink" title="三、捕获列表"></a>三、捕获列表</h1><p>lamada表达式可以通过捕获列表捕获一定范围内的变量：</p><ul><li><code>[]</code> 不捕获任何变量。</li><li><code>[&amp;]</code> 按引用捕获：捕获外部作用域中的所有变量，并作为引用在函数体中使用。</li><li><code>[=]</code> 按值捕获：捕获外部作用域中的所有变量，并作为副本在函数体中使用。</li><li><code>[=, &amp;foo]</code> 按值捕获外部作用域中的所有变量，并按引用捕获foo变量。</li><li><code>[bar]</code> 按值捕获bar变量，同时不捕获其他变量。</li><li><code>[this]</code> 捕获lamada所在的当前类中的<code>this</code>指针，让lamada表达式拥有和当前类成员函数同样的访问权限。如果已经使用了<code>&amp;</code>或<code>=</code>，就默认添加此选项。捕获this的目的是可以在lamada中使用当前类的成员函数和成员变量。</li></ul><h1 id="四、异常约束"><a href="#四、异常约束" class="headerlink" title="四、异常约束"></a>四、异常约束</h1><p>可以使用<code>noexcept</code>来指定和约束Lamada表达内不会抛出异常，如果抛出异常，编译器会产生编译警告。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">// throw_lambda_expression.cpp// compile with: /W4 /EHscint main() // 产生编译警告C4297{   []() noexcept { throw 5; }();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="五、mutable"><a href="#五、mutable" class="headerlink" title="五、mutable"></a>五、mutable</h1><p>正常情况下，按值捕获的变量，其值在Lamada表达式内是不能被修改的（遵循<code>const-by-value</code>），如下面的代码编译会报错：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP"> int n = 1;auto fuc = [n]() {    n = 2;};// error C3491: “n”: 无法在非可变 lambda 中修改通过复制捕获<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用<code>mutable</code>关键字改变这种行为：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">int n = 1;auto fuc = [n]() mutable {    n = 2;};printf("%d", n); // 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然在Lamada表达式内可以修改<code>n</code>的值，但<code>n</code>仍是按值传递，因此外部<code>n</code>的值没有被改变。</p><blockquote><p>参考：<a href="https://msdn.microsoft.com/en-us/library/dd293608.aspx">https://msdn.microsoft.com/en-us/library/dd293608.aspx</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
            <tag> Lamada </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解DPI缩放</title>
      <link href="/2023/06/28/liao-jie-dpi-suo-fang/"/>
      <url>/2023/06/28/liao-jie-dpi-suo-fang/</url>
      
        <content type="html"><![CDATA[<h1 id="一、DPI介绍"><a href="#一、DPI介绍" class="headerlink" title="一、DPI介绍"></a>一、DPI介绍</h1><p>dpi是“Dots Per Inch”的缩写，表示每英寸的像素点个数，也就是像素点的密集度。<br><code>dpi = 总像素点 / 总面积</code></p><p>比如一个32寸的显示，但分辨率只有<code>1920*1440</code>，而一个24寸的显示器，分辨率却达到<code>3840*2160</code>，很明显后面这个显示器的每英寸的像素点的个数多，显示的画面更加细腻。<br>所以：高分辨率不等于高dpi。</p><p>苹果的视网膜屏幕的核心就是高dpi：屏幕面积小，却分辨率高达5k，每英寸的像素点（dpi）固然多，画面自然细腻。</p><h1 id="二、软件显示异常"><a href="#二、软件显示异常" class="headerlink" title="二、软件显示异常"></a>二、软件显示异常</h1><p>为什么高DPI显示器为什么会导致某些软件显示异常了？</p><p>随着2K、4K显示器的普及，在使用这些高DPI显示器时，为了保证系统软件界面看起来不至于太小，导致视觉疲劳，一般会在系统中设置缩放比例。</p><p>Windows操作系统对高dpi显示器缩放支持最好的是windows 10+，建议使用高DPI显示器时使用Windows 10+操作系统。<br><img src="https://static.1key.run/blog/img/dpi-1.png"></p><p>假设现在有一个软件界面（宽为950像素，高为700像素），该软件在24寸、分辨率为<code>1900*1400</code>的显示器上显示正常，但放到高dpi显示器（同样是24寸，但分辨率为<code>3800*2800</code>）上显示效果会如何？</p><p><img src="https://static.1key.run/blog/img/dpi-2.png"></p><p>从上图可以看到，同样尺寸的软件界面，在高dpi显示器上会显得非常小，会造成严重的视觉疲劳。</p><p>所以我们的软件需要针对高dpi进行缩放。</p><h1 id="三、Windows-10-DPI缩放规则"><a href="#三、Windows-10-DPI缩放规则" class="headerlink" title="三、Windows 10 DPI缩放规则"></a>三、Windows 10 DPI缩放规则</h1><p>Windows 10+操作系统针对dpi缩放制定了3种规则，每个进程都必须匹配下面的一种规则，默认为<code>PROCESS_DPI_UNAWARE</code>：</p><ol><li><p>PROCESS_DPI_UNAWARE<br>  在软件启动时， 操作系统会自动将软件进行缩放拉伸；在系统dpi缩放改变时，系统也会将软件自动进行缩放拉伸，但软件不会收到WM_DPICHANGED消息。</p></li><li><p>PROCESS_SYSTEM_DPI_AWARE<br>在软件启动时，系统不会将软件进行缩放拉伸；但在系统dpi缩放改变时，系统会将软件进行缩放拉伸，但软件仍然不会收到WM_DPICHANGED消息。</p></li><li><p>PROCESS_PER_MONITOR_DPI_AWARE<br>在软件启动时，系统不会将软件进行缩放拉伸；同样，在系统dpi缩放改变时，系统也不会将软件进行缩放拉伸，但软件会收到WM_DPICHANGED消息。</p></li></ol><blockquote><p>详见：<a href="https://docs.microsoft.com/zh-cn/windows/desktop/api/windef/ne-windef-dpi_awareness">dpi_awareness</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7申请免费LetsEncrypt证书并续期</title>
      <link href="/2023/06/28/centos7-shen-qing-mian-fei-letsencrypt-zheng-shu-bing-xu-qi/"/>
      <url>/2023/06/28/centos7-shen-qing-mian-fei-letsencrypt-zheng-shu-bing-xu-qi/</url>
      
        <content type="html"><![CDATA[<p>本文介绍在CentOS7环境下，使用Certbot申请免费的Lets Encrypt SSL证书，并自动续期。</p><h1 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h1><p>安装Python3：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">yum install python3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装Certbot和Python虚拟环境：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 假设certbot安装到/root/certbotmkdir -p /root/certbotcd /root/certbotpython3 -m venv venvsource venv/bin/activate# 升级pippip install --upgrade pip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>阿里云注册并解析的域名，执行如下命令：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 安装certbotpip install certbot certbot-nginx certbot-dns-aliyun -i https://pypi.tuna.tsinghua.edu.cn/simple<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="2-阿里云子账号"><a href="#2-阿里云子账号" class="headerlink" title="2. 阿里云子账号"></a>2. 阿里云子账号</h1><p>创建阿里云子账号（<a href="https://ram.console.aliyun.com/">https://ram.console.aliyun.com</a>），并分配AliyunDNSFullAccess权限。</p><p>为子账号生成access_key和access_secret。</p><p><img src="https://static.1key.run/blog/img/centos-lets-ssl-1.png"></p><p>创建<code>/root/certbot/aliyun.ini</code>文件，内容如下：</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">dns_aliyun_access_key = XXXXXdns_aliyun_access_key_secret = XXXXX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用如下命令修改该文件权限：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">chmod 600 /root/certbot/aliyun.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="3-申请证书"><a href="#3-申请证书" class="headerlink" title="3. 申请证书"></a>3. 申请证书</h1><p>以申请mytools123.com证书为例：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">/root/certbot/venv/bin/certbot certonly \-a dns-aliyun \--dns-aliyun-credentials /root/certbot/aliyun.ini \-d mytools123.com \-d "*.mytools123.com"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行成功后，生成的证书位于<code>/etc/letsencrypt/live/mytools123.com</code>目录</p><h1 id="4-手动续期"><a href="#4-手动续期" class="headerlink" title="4. 手动续期"></a>4. 手动续期</h1><p>Lets Encrypt的证书有效期只有3个月，到期后需要手动续期。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># --dry-run 的是模拟更新证书/root/certbot/venv/bin/certbot renew -a dns-aliyun --dns-aliyun-credentials /root/certbot/aliyun.ini --dry-run# 正式更新证书/root/certbot/venv/bin/certbot renew -a dns-aliyun --dns-aliyun-credentials /root/certbot/aliyun.ini<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-自动续期"><a href="#5-自动续期" class="headerlink" title="5. 自动续期"></a>5. 自动续期</h1><p>可以创建定时续期脚本，来实现自动续期。</p><p>创建脚本文件<code>/root/renew_cert.sh</code>，内容如下：</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell"># 更新证书/root/certbot/venv/bin/certbot renew -a dns-aliyun --dns-aliyun-credentials /root/certbot/aliyun.ini<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为sh添加可执行权限：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">chmod +x /root/renew_cert.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建定时任务：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">crontab -e<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新增如下内容：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">0 0,12 * * * python -c 'import random; import time; time.sleep(random.random() * 3600)' &amp;&amp; /root/renew_cert.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LetsEncrypt </tag>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7更新国内阿里源</title>
      <link href="/2023/06/28/centos7-geng-xin-guo-nei-a-li-yuan/"/>
      <url>/2023/06/28/centos7-geng-xin-guo-nei-a-li-yuan/</url>
      
        <content type="html"><![CDATA[<p>依次执行如下命令：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">yum install -y wget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 备份并下载阿里云的base和epel源mv -f /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backupwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repomv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backupwget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">yum clean allyum makecacheyum -y update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CentOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CMake依赖库查找相关问题</title>
      <link href="/2023/06/28/cmake-yi-lai-ku-cha-zhao-xiang-guan-wen-ti/"/>
      <url>/2023/06/28/cmake-yi-lai-ku-cha-zhao-xiang-guan-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="1-如何查找Vcpkg安装的依赖库"><a href="#1-如何查找Vcpkg安装的依赖库" class="headerlink" title="1. 如何查找Vcpkg安装的依赖库"></a>1. 如何查找Vcpkg安装的依赖库</h1><p>在CMake工具中指定跨平台工具链，如图：<br><img src="https://static.1key.run/blog/img/vcpkg-package-find-1.png"></p><p>指定Toolchain文件<code>D:/sourcecode/vcpkg/scripts/buildsystems/vcpkg.cmake</code>。</p><h1 id="2-如何查找本机安装的Qt库"><a href="#2-如何查找本机安装的Qt库" class="headerlink" title="2. 如何查找本机安装的Qt库"></a>2. 如何查找本机安装的Qt库</h1><p>设置环境变量<code>CMAKE_PREFIX_PATH</code>，值为Qt的安装目录，如<code>C:\Qt\5.15.2\msvc2019</code>，然后启动CMake即可。</p><p>也可以使用如下批处理来临时设置和启动：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">@echo offset CMAKE_PREFIX_PATH=C:\Qt\5.15.2\msvc2019start "" "C:\Program Files\CMake\bin\cmake-gui.exe"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> Vcpkg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vcpkg安装port历史版本</title>
      <link href="/2023/06/28/vcpkg-an-zhuang-port-li-shi-ban-ben/"/>
      <url>/2023/06/28/vcpkg-an-zhuang-port-li-shi-ban-ben/</url>
      
        <content type="html"><![CDATA[<p><strong>截至2023-05-22：vcpkg仅支持在manifest模式下指定port的版本，在命令行模式下不支持指定port版本。</strong></p><p>本文介绍如何在Vcpkg命令行模式下安装port时如何指定版本。</p><p>使用Git命令查看当前Vcpkg仓库的baseline：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">git rev-parse HEAD<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建<code>vcpkg_json</code>目录，并在该目录下创建<code>vcpkg.json</code>文件（以openssl为例）：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">{  "name": "cc",  "version": "1.0.1",  "builtin-baseline": "7b30311f0a79d395bf2d933d82fec1853c6a4e77",  "dependencies": [    {"name": "openssl"}  ],   "overrides": [        { "name": "openssl", "version-string": "1.1.1n#1" }    ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用如下命令安装：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">vcpkg install --triplet "x64-windows" "--x-manifest-root=D:\vcpkg_json\\" "--x-install-root=D:CODE\vcpkg\installed\\"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Vcpkg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vcpkg访问Github私有仓库</title>
      <link href="/2023/06/28/vcpkg-fang-wen-github-si-you-cang-ku/"/>
      <url>/2023/06/28/vcpkg-fang-wen-github-si-you-cang-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="1-在Github中添加TOKEN"><a href="#1-在Github中添加TOKEN" class="headerlink" title="1.在Github中添加TOKEN"></a>1.在Github中添加TOKEN</h2><p><img src="https://static.1key.run/blog/img/vcpkg-private-repo-1.png"></p><h2 id="2-添加Windows环境变量："><a href="#2-添加Windows环境变量：" class="headerlink" title="2. 添加Windows环境变量："></a>2. 添加Windows环境变量：</h2><p><code>VCPKG_KEEP_ENV_VARS</code>值为<code>GITHUB_TOKEN</code></p><p><code>GITHUB_TOKEN</code>值为第一步生成的TOKEN</p><h2 id="3-修改portfile-cmake"><a href="#3-修改portfile-cmake" class="headerlink" title="3.修改portfile.cmake"></a>3.修改portfile.cmake</h2><p>在<code>vcpkg\ports</code>目录下，找到对应库的portfile.cmake文件，加入<code>AUTHORIZATION_TOKEN</code>参数。</p><pre class="line-numbers language-Makefile" data-language="Makefile"><code class="language-Makefile">vcpkg_from_github(    OUT_SOURCE_PATH SOURCE_PATH    REPO xxx/xxx    HEAD_REF main    AUTHORIZATION_TOKEN $ENV{GITHUB_TOKEN})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Vcpkg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows用户界面特权隔离(UIPI)</title>
      <link href="/2023/06/28/windows-yong-hu-jie-mian-te-quan-ge-chi-uipi/"/>
      <url>/2023/06/28/windows-yong-hu-jie-mian-te-quan-ge-chi-uipi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一、用户界面特权隔离-UIPI"><a href="#一、用户界面特权隔离-UIPI" class="headerlink" title="一、用户界面特权隔离(UIPI)"></a>一、用户界面特权隔离(UIPI)</h1><p>在早期的Windows操作系统中，在同一用户下运行的所有进程有着相同的安全等级，拥有相同的权限。例如，一个进程可以自由地发送一个Windows消息到另外一个进程的窗口。</p><p>从Windows Vista开始，对于某些Windows消息，这一方式再也行不通了。进程（或者其他的对象）开始拥有一个新的属性–特权等级(Privilege Level)。</p><p>一个特权等级较低的进程不再可以向一个特权等级较高的进程发送消息，虽然他们在相同的用户权限下运行。这就是所谓的用户界面特权隔离(User Interface Privilege Isolation ，UIPI)。</p><p>引入UIPI的目的是为了防止恶意程序发送消息给那些拥有较高权限的窗口，从而利用该进程的高权限达到某种目的等等。</p><h1 id="二、UIPI的运行机制"><a href="#二、UIPI的运行机制" class="headerlink" title="二、UIPI的运行机制"></a>二、UIPI的运行机制</h1><p>　　在Windows 7中，当UAC(User Account Control)启用的时候，UIPI的运行可以得到最明显的体现。在UAC中，当一个管理员用户登录系统后，操作系统会创建两个令牌对象(Token Object)：一个是管理员令牌，拥有大多数特权(类似于Windows Vista之前的System中的用户)，而另一个是经过过滤后的简化版本，只拥有普通用户的权限。</p><p>　　默认情况下，以普通用户权限启动的进程拥有普通特权等级【UIPI的等级划分为低等级(low)，普通(normal)，高等级(high)，系统(system)】。同样的，以管理员权限运行的进程（例如用户右键单击选择“以管理员身份运行”或者是通过添加“runas”参数调用ShellExecute运行的进程）拥有高(high)特权等级。</p><p>　　系统中会运行多种不同类型、不同特权等级的进程(当然，从技术上讲这两个进程都是在同一用户下)。我们可以使用<a href="(http://www.microsoft.com/technet/sysinternals)">Windows Sysinternals</a>工具集中的<code>Process Explorer</code>查看各个进程的特权等级。 </p><p><img src="https://static.1key.run/blog/img/UIPI-1.jpg"></p><p>所以，当发现进程之间Windows消息通信发生问题时，不妨使用<code>Process Explorer</code>查看一下两个进程之间是否有合适的特权等级。</p><h1 id="三、UIPI所带来的限制"><a href="#三、UIPI所带来的限制" class="headerlink" title="三、UIPI所带来的限制"></a>三、UIPI所带来的限制</h1><p>正如我们前文所说，等级的划分，是为了防止以下犯上。所以，有了用户界面特权隔离，一个运行在较低特权等级的应用程序的行为就受到了诸多限制，它<strong>不可以</strong>进行如下操作：</p><ul><li>验证由较高特权等级进程创建的窗口句柄</li><li>通过调用SendMessage和PostMessage向由较高特权等级进程创建的窗口发送Windows消息</li><li>使用线程钩子处理较高特权等级进程</li><li>使用普通钩子(SetWindowsHookEx)监视较高特权等级进程</li><li>向一个较高特权等级进程执行DLL注入</li></ul><p>但是，一些特殊Windows消息是被容许的，因为这些消息对进程的安全性没有太大影响。这些Windows消息包括：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">　　0x000 - WM_NULL　　0x003 - WM_MOVE　　0x005 - WM_SIZE　　0x00D - WM_GETTEXT　　0x00E - WM_GETTEXTLENGTH　　0x033 - WM_GETHOTKEY　　0x07F - WM_GETICON　　0x305 - WM_RENDERFORMAT　　0x308 - WM_DRAWCLIPBOARD　　0x30D - WM_CHANGECBCHAIN　　0x31A - WM_THEMECHANGED　　0x313, 0x31B (WM_???)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、修复UIPI问题"><a href="#四、修复UIPI问题" class="headerlink" title="四、修复UIPI问题"></a>四、修复UIPI问题</h1><p>基于Windows Vista之前的操作系统行为所设计的应用程序，可能希望Windows消息能够在进程之间自由的传递，以完成一些特殊的工作。当这些应用程序在Windows 7/10上运行时，因为UIPI机制，这种消息传递被阻断了，应用程序就会遇到兼容性问题。</p><p>为了解决这个问题，Windows Vista引入了新的API函数<code>ChangeWindowMessageFilter</code>和<code>ChangeWindowMessageFilterEx</code>。利用这2个函数，我们可以添加或者删除能够通过特权等级隔离的Windows消息。这就像拥有较高特权等级的进程，设置了一个过滤器，被允许通过的Windows消息都将被添加到这个过滤器的白名单，只有在这个白名单上的消息才允许传递进来。</p><p>下面对添加/移除白名单功能进行了简单封装（<code>UIPIMsgFilter</code>函数），该函数可以针对特定的窗体添加、移除消息白名单：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">BOOL UIPIMsgFilter(HWND hWnd, UINT uMessageID, BOOL bAllow) {    OSVERSIONINFO VersionTmp;    VersionTmp.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);    GetVersionEx(&amp;VersionTmp);    BOOL res = FALSE;    if (VersionTmp.dwMajorVersion &gt;= 6) { // vista above.        BOOL(WINAPI * pfnChangeMessageFilterEx)(HWND, UINT, DWORD, PCHANGEFILTERSTRUCT);        BOOL(WINAPI * pfnChangeMessageFilter)(UINT, DWORD);        CHANGEFILTERSTRUCT filterStatus;        filterStatus.cbSize = sizeof(CHANGEFILTERSTRUCT);        HINSTANCE hlib = LoadLibrary(_T("user32.dll"));        if (hlib != NULL) {            (FARPROC &amp;)pfnChangeMessageFilterEx = GetProcAddress(hlib, "ChangeWindowMessageFilterEx");            if (pfnChangeMessageFilterEx != NULL &amp;&amp; hWnd != NULL) {                res = pfnChangeMessageFilterEx(hWnd, uMessageID, (bAllow ? MSGFLT_ADD : MSGFLT_REMOVE), &amp;filterStatus);            }            // If failed, try again.            if (!res) {                (FARPROC &amp;)pfnChangeMessageFilter = GetProcAddress(hlib, "ChangeWindowMessageFilter");                if (pfnChangeMessageFilter != NULL) {                    res = pfnChangeMessageFilter(uMessageID, (bAllow ? MSGFLT_ADD : MSGFLT_REMOVE));                }            }        }        if (hlib != NULL) {            FreeLibrary(hlib);        }    }    else {        res = TRUE;    }    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UIPI </tag>
            
            <tag> Process Explorer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows注入与拦截(1)--DLL注入基础</title>
      <link href="/2023/06/25/windows-zhu-ru-yu-lan-jie-1-dll-zhu-ru-ji-chu/"/>
      <url>/2023/06/25/windows-zhu-ru-yu-lan-jie-1-dll-zhu-ru-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="一-DLL注入技术的用途"><a href="#一-DLL注入技术的用途" class="headerlink" title="一. DLL注入技术的用途"></a>一. DLL注入技术的用途</h2><p>从<a href="/2023/06/20/windows-nei-cun-ti-xi-1-xu-ni-di-zhi-kong-jian/" title="Windows内存体系(1)--虚拟地址空间">Windows内存体系(1)--虚拟地址空间</a>文章中我们可以知道，在Windows系统中，每个进程都有自己私有的地址空间。当我们用指针来引用内存的时候，指针的值表示的是进程自己的地址空间的一个虚拟的内存地址。<strong>进程不能通过指针来引用其他进程地址空间的内存。</strong>因此，如果一个进程有缺陷会导致其引用和覆盖随机地址处的内存，那么这个缺陷的影响就会不会扩散到其他的进程。</p><p>独立的地址空间有利于系统的稳定性。但很多时候我们还是需要跨越进程的边界来访问另一个进程地址空间，比如：</p><ul><li>我们要从另一个进程创建的窗口来派生子类窗口。比如附着在windows资源管理器上的一些小插件等。</li><li>我们需要假借其他进程之名做某些事情。</li><li>我们需要获取其他进程的更多详细信息，如加载了哪些dll等。</li><li>我们需要对其他进程的某些操作进程拦截。</li><li>干一些羞羞的事情…</li></ul><p>为了满足上面的这些需求，我们可以使用DLL注入的技术，将我们自己开发的dll注入到另一个进程的地址空间中，让dll中的代码在该进程的地址空间中执行，那么我们就可以在那个中进程为所欲为了。</p><h2 id="二-什么样的DLL可以被注入？"><a href="#二-什么样的DLL可以被注入？" class="headerlink" title="二. 什么样的DLL可以被注入？"></a>二. 什么样的DLL可以被注入？</h2><p>理论上任何DLL都可以被注入到其他进程之中，但是大多数情况下，我们注入到其他进程之中是为了实现某些功能、做某些事情的，所以我们需要在我们的DLL被注入之后，DLL中的功能代码能够被调用执行。</p><p>我们知道DLL被<strong>首次</strong>载入到进程中时，会收到<code>DLL_PROCESS_ATTACH</code>的通知，即调用<code>DllMain</code>函数，并且参数<code>fdwReason</code>的值被设为<code>DLL_PROCESS_ATTACH</code>。我们可以在收到<code>DLL_PROCESS_ATTACH</code>通知时开始我们的业务逻辑。</p><p>下面是一个最简单的dll的源码，在被注入成功后（即收到<code>DLL_PROCESS_ATTACH</code>通知时）弹出消息提示框：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved ) {    switch(fdwReason) {        case DLL_PROCESS_ATTACH:        {MessageBox(NULL, TEXT("我已经被注入啦"), TEXT("信息"), MB_ICONINFORMATION);            break;        }        case DLL_THREAD_ATTACH:        {            break;        }        case DLL_THREAD_DETACH:        {            break;        }        case DLL_PROCESS_DETACH:        {            break;        }    }    return TRUE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，如果<code>DLL_PROCESS_ATTACH</code>通知处理过程中的操作被挂起（如消息提示框）或者被阻塞（如用户创建了一个消息循环），这样就会导致目标进程中的<code>LoadLibrary(Ex)</code>函数一直无法返回（dll都是通过<code>LoadLibrary(Ex)</code>函数来加载的），所以我们一般会在<code>DLL_PROCESS_ATTACH</code>通知处理过程中创建一个子线程，将业务逻辑放置到该子线程中执行，代码如下：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;process.h&gt;unsigned int __stdcall PluginProc(LPVOID pArg) {MessageBox(NULL, TEXT("我已经被注入啦"), TEXT("信息"), MB_OK | MB_ICONASTERISK);return 0;}BOOL APIENTRY DllMain(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved) {HANDLE hThread = NULL;    switch(fdwReason) {        case DLL_PROCESS_ATTACH:        {hThread = (HANDLE)_beginthreadex(NULL, 0, PluginProc, NULL, 0, NULL);if (hThread) {CloseHandle(hThread); // 关闭句柄，防止句柄泄漏}            break;        }        case DLL_THREAD_ATTACH:        {            break;        }        case DLL_THREAD_DETACH:        {            break;        }        case DLL_PROCESS_DETACH:        {            break;        }    }    return TRUE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，当DLL被从目标进程卸载时，DLL会收到<code>DLL_PROCESS_DETACH</code>通知，我们需要在该通知的处理过程中做好最后的善后工作，防止资源泄漏、程序崩溃等问题出现。</p>]]></content>
      
      
      <categories>
          
          <category> Windows注入与拦截 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DLL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存池实现</title>
      <link href="/2023/06/25/c-nei-cun-chi-shi-xian/"/>
      <url>/2023/06/25/c-nei-cun-chi-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="一、为什么需要使用内存池"><a href="#一、为什么需要使用内存池" class="headerlink" title="一、为什么需要使用内存池"></a>一、为什么需要使用内存池</h1><p>在C/C++中我们通常使用<code>malloc</code>,<code>free</code>或<code>new</code>,<code>delete</code>来动态分配内存。<br>一方面，因为这些函数涉及到了系统调用，所以频繁的调用必然会导致程序性能的损耗；</p><p>另一方面，频繁的分配和释放小块内存会导致大量的内存碎片的产生，当碎片积累到一定的量之后，将无法分配到连续的内存空间，系统不得不进行碎片整理来满足分配到连续的空间，这样不仅会导致系统性能损耗，而且会导致程序对内存的利用率低下。</p><p>当然，如果我们的程序不需要频繁的分配和释放小块内存，那就没有使用内存池的必要，直接使用<code>malloc</code>,<code>free</code>或<code>new</code>,<code>delete</code>函数即可。</p><h1 id="二、内存池的实现方案"><a href="#二、内存池的实现方案" class="headerlink" title="二、内存池的实现方案"></a>二、内存池的实现方案</h1><p>内存池的实现原理大致如下：<br>提前申请一块大内存由内存池自己管理，并分成小片供给程序使用。程序使用完之后将内存归还到内存池中（并没有真正的从系统释放），当程序再次从内存池中请求内存时，内存池将池子中的可用内存片返回给程序使用。</p><p>我们在设计内存池的实现方案时，需要考虑到以下问题：</p><ol><li><p>内存池是否可以自动增长？<br>如果内存池的最大空间是固定的（也就是非自动增长），那么当内存池中的内存被请求完之后，程序就无法再次从内存池请求到内存。所以需要根据程序对内存的实际使用情况来确定是否需要自动增长。</p></li><li><p>内存池的总内存占用是否只增不减？<br>如果内存池是自动增长的，就涉及到了“内存池的总内存占用是否是只增不减”这个问题了。试想，程序从一个自动增长的内存池中请求了1000个大小为100KB的内存片，并在使用完之后全部归还给了内存池，而且假设程序之后的逻辑最多只需要10个100KB的内存片，该内存池中的900个100KB的内存片就一直处于闲置状态，程序内存占用就一直降下来。对内存占用大小有要求的程序需要考虑到这一点。</p></li><li><p>内存池中内存片的大小是否固定？<br>如果每次从内存池中的请求的内存片的大小如果不固定，那么内存池中的每个可用内存片的大小就不一致，程序再次请求内存片的时候，内存池就需要在“匹配最佳大小的内存片”和“匹配操作时间”上作出衡量。“最佳大小的内存片”虽然可以减少内存的浪费，但可能会导致“匹配时间”变长。</p></li><li><p>内存池是否是线程安全的？<br>是否允许在多个线程中同时从同一个内存池中请求和归还内存片？这个线程安全可以由内存池来实现，也可以由使用者来保证。</p></li><li><p>内存片分配出去之前和归还到内存池之后，其中的内容是否需要被清除？<br>程序可能出现将内存片归还给内存池之后，仍然使用内存片的地址指针进行内存读写操作，这样就会导致不可预期的结果。将内容清零只能尽量的（也不一定能）将问题抛出来，但并不能解决任何问题，而且将内容清零会消耗一定的CPU时间。所以，最终最好还是需要由内存池的使用者来保证这种安全性。</p></li><li><p>是否兼容<code>std::allocator</code>？<br>STL标准库中的大多类都支持用户提供一个自定义的内存分配器，默认使用的是<code>std::allocator</code>，如<code>std::string</code>：<br><code>typedef basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt; string;</code></p></li></ol><p>如果我们的内存池兼容std::allocator，那么我们就可以使用我们自己的内存池来替换默认的std::allocator分配器，如：<br><code>typedef basic_string&lt;char, char_traits&lt;char&gt;, MemoryPoll&lt;char&gt; &gt; mystring;</code></p><blockquote><p>关于如何兼容<code>std::allocator</code>，可以参考<a href="http://www.cplusplus.com/reference/memory/allocator/">http://www.cplusplus.com/reference/memory/allocator/</a></p></blockquote><h1 id="三、内存池的具体实现"><a href="#三、内存池的具体实现" class="headerlink" title="三、内存池的具体实现"></a>三、内存池的具体实现</h1><p>计划实现一个内存池管理的类<code>MemoryPool</code>，它具有如下特性：</p><ol><li>内存池的总大小自动增长。</li><li>内存池中内存片的大小固定。</li><li>支持线程安全。</li><li>在内存片被归还之后，清除其中的内容。</li><li>兼容<code>std::allocator</code>。</li></ol><p>因为内存池的内存片的大小是固定的，不涉及到需要匹配最合适大小的内存片，由于会频繁的进行插入、移除的操作，但查找比较少，故选用<code>链表</code>数据结构来管理内存池中的内存片。</p><p>MemoryPool中有2个链表，它们都是双向链表（设计成双向链表主要是为了在移除指定元素时，能够快速定位该元素的前后元素，从而在该元素被移除后，将其前后元素连接起来，保证链表的完整性）：</p><ol><li><code>data_element_</code> 记录以及分配出去的内存片。</li><li><code>free_element_</code> 记录未被分配出去的内存片。</li></ol><h2 id="3-1-MemoryPool实现代码"><a href="#3-1-MemoryPool实现代码" class="headerlink" title="3.1 MemoryPool实现代码"></a>3.1 <code>MemoryPool</code>实现代码</h2><p>下面是完整的内存池实现的代码，代码中使用了std::mutex等C++11才支持的特性，所以需要编译器最低支持C++11。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">/* MemoryPool.hpp */#ifndef MEMORY_POOL_H_#define MEMORY_POOL_H_#include &lt;climits&gt;#include &lt;cstddef&gt;#include &lt;mutex&gt;template &lt;typename T, size_t BlockSize = 4096, bool ZeroOnDeallocate = true&gt;class MemoryPool {public:    /* Member types */    typedef T               value_type;    typedef T*              pointer;    typedef T&amp;              reference;    typedef const T*        const_pointer;    typedef const T&amp;        const_reference;    typedef size_t          size_type;    typedef ptrdiff_t       difference_type;    typedef std::false_type propagate_on_container_copy_assignment;    typedef std::true_type  propagate_on_container_move_assignment;    typedef std::true_type  propagate_on_container_swap;    template &lt;typename U&gt; struct rebind {        typedef MemoryPool&lt;U&gt; other;    };    /* Member functions */    MemoryPool() noexcept;    MemoryPool(const MemoryPool&amp; memoryPool) noexcept;    MemoryPool(MemoryPool&amp;&amp; memoryPool) noexcept;    template &lt;class U&gt; MemoryPool(const MemoryPool&lt;U&gt;&amp; memoryPool) noexcept;    ~MemoryPool() noexcept;    MemoryPool&amp; operator=(const MemoryPool&amp; memoryPool) = delete;    MemoryPool&amp; operator=(MemoryPool&amp;&amp; memoryPool) noexcept;    pointer address(reference x) const noexcept;    const_pointer address(const_reference x) const noexcept;    // Can only allocate one object at a time. n and hint are ignored    pointer allocate(size_type n = 1, const_pointer hint = 0);    void deallocate(pointer p, size_type n = 1);    size_type max_size() const noexcept;    template &lt;class U, class... Args&gt; void construct(U* p, Args&amp;&amp;... args);    template &lt;class U&gt; void destroy(U* p);    template &lt;class... Args&gt; pointer newElement(Args&amp;&amp;... args);    void deleteElement(pointer p);private:    struct Element_ {        Element_* pre;        Element_* next;    };    typedef char* data_pointer;    typedef Element_ element_type;    typedef Element_* element_pointer;    element_pointer data_element_;    element_pointer free_element_;    std::recursive_mutex m_;    size_type padPointer(data_pointer p, size_type align) const noexcept;    void allocateBlock();    static_assert(BlockSize &gt;= 2 * sizeof(element_type), "BlockSize too small.");};template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::size_type    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::padPointer(data_pointer p, size_type align)    const noexcept {    uintptr_t result = reinterpret_cast&lt;uintptr_t&gt;(p);    return ((align - result) % align);}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::MemoryPool()    noexcept {    data_element_ = nullptr;    free_element_ = nullptr;}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::MemoryPool(const MemoryPool&amp; memoryPool)    noexcept :    MemoryPool() {}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::MemoryPool(MemoryPool&amp;&amp; memoryPool)    noexcept {    std::lock_guard&lt;std::recursive_mutex&gt; lock(m_);    data_element_ = memoryPool.data_element_;    memoryPool.data_element_ = nullptr;    free_element_ = memoryPool.free_element_;    memoryPool.free_element_ = nullptr;}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;template&lt;class U&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::MemoryPool(const MemoryPool&lt;U&gt;&amp; memoryPool)    noexcept :    MemoryPool() {}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;&amp;    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::operator=(MemoryPool&amp;&amp; memoryPool)    noexcept {    std::lock_guard&lt;std::recursive_mutex&gt; lock(m_);    if (this != &amp;memoryPool) {        std::swap(data_element_, memoryPool.data_element_);        std::swap(free_element_, memoryPool.free_element_);    }    return *this;}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::~MemoryPool()    noexcept {    std::lock_guard&lt;std::recursive_mutex&gt; lock(m_);    element_pointer curr = data_element_;    while (curr != nullptr) {        element_pointer prev = curr-&gt;next;        operator delete(reinterpret_cast&lt;void*&gt;(curr));        curr = prev;    }    curr = free_element_;    while (curr != nullptr) {        element_pointer prev = curr-&gt;next;        operator delete(reinterpret_cast&lt;void*&gt;(curr));        curr = prev;    }}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::pointer    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::address(reference x)    const noexcept {    return &amp;x;}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::const_pointer    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::address(const_reference x)    const noexcept {    return &amp;x;}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;void    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::allocateBlock() {    // Allocate space for the new block and store a pointer to the previous one    data_pointer new_block = reinterpret_cast&lt;data_pointer&gt; (operator new(BlockSize));    element_pointer new_ele_pointer = reinterpret_cast&lt;element_pointer&gt;(new_block);    new_ele_pointer-&gt;pre = nullptr;    new_ele_pointer-&gt;next = nullptr;    if (data_element_) {        data_element_-&gt;pre = new_ele_pointer;    }    new_ele_pointer-&gt;next = data_element_;    data_element_ = new_ele_pointer;}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::pointer    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::allocate(size_type n, const_pointer hint) {    std::lock_guard&lt;std::recursive_mutex&gt; lock(m_);    if (free_element_ != nullptr) {        data_pointer body =            reinterpret_cast&lt;data_pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(free_element_) + sizeof(element_type));        size_type bodyPadding = padPointer(body, alignof(element_type));        pointer result = reinterpret_cast&lt;pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(body + bodyPadding));        element_pointer tmp = free_element_;        free_element_ = free_element_-&gt;next;        if (free_element_)            free_element_-&gt;pre = nullptr;        tmp-&gt;next = data_element_;        if (data_element_)            data_element_-&gt;pre = tmp;        tmp-&gt;pre = nullptr;        data_element_ = tmp;        return result;    }    else {        allocateBlock();        data_pointer body =            reinterpret_cast&lt;data_pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(data_element_) + sizeof(element_type));        size_type bodyPadding = padPointer(body, alignof(element_type));        pointer result = reinterpret_cast&lt;pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(body + bodyPadding));        return result;    }}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline void    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::deallocate(pointer p, size_type n) {    std::lock_guard&lt;std::recursive_mutex&gt; lock(m_);    if (p != nullptr) {        element_pointer ele_p =            reinterpret_cast&lt;element_pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(p) - sizeof(element_type));        if (ZeroOnDeallocate) {            memset(reinterpret_cast&lt;data_pointer&gt;(p), 0, BlockSize - sizeof(element_type));        }        if (ele_p-&gt;pre) {            ele_p-&gt;pre-&gt;next = ele_p-&gt;next;        }        if (ele_p-&gt;next) {            ele_p-&gt;next-&gt;pre = ele_p-&gt;pre;        }        if (ele_p-&gt;pre == nullptr) {            data_element_ = ele_p-&gt;next;        }        ele_p-&gt;pre = nullptr;        if (free_element_) {            ele_p-&gt;next = free_element_;            free_element_-&gt;pre = ele_p;        }        else {            ele_p-&gt;next = nullptr;        }        free_element_ = ele_p;    }}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::size_type    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::max_size()    const noexcept {    size_type maxBlocks = -1 / BlockSize;    return (BlockSize - sizeof(data_pointer)) / sizeof(element_type) * maxBlocks;}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;template &lt;class U, class... Args&gt;inline void    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::construct(U* p, Args&amp;&amp;... args) {    new (p) U(std::forward&lt;Args&gt;(args)...);}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;template &lt;class U&gt;inline void    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::destroy(U* p) {    p-&gt;~U();}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;template &lt;class... Args&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::pointer    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::newElement(Args&amp;&amp;... args) {    std::lock_guard&lt;std::recursive_mutex&gt; lock(m_);    pointer result = allocate();    construct&lt;value_type&gt;(result, std::forward&lt;Args&gt;(args)...);    return result;}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline void    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::deleteElement(pointer p) {    std::lock_guard&lt;std::recursive_mutex&gt; lock(m_);    if (p != nullptr) {        p-&gt;~value_type();        deallocate(p);    }}#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-使用示例"><a href="#3-2-使用示例" class="headerlink" title="3.2 使用示例"></a>3.2 使用示例</h2><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include "MemoryPool.hpp"#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;assert.h&gt;using namespace std;class Apple {public:    Apple() {        id_ = 0;        cout &lt;&lt; "Apple()" &lt;&lt; endl;    }    Apple(int id) {        id_ = id;        cout &lt;&lt; "Apple(" &lt;&lt; id_ &lt;&lt; ")" &lt;&lt; endl;    }    ~Apple() {        cout &lt;&lt; "~Apple()" &lt;&lt; endl;    }    void SetId(int id) {        id_ = id;    }    int GetId() {        return id_;    }private:    int id_;};void ThreadProc(MemoryPool&lt;char&gt; *mp) {    int i = 0;    while (i++ &lt; 100000) {        char* p0 = (char*)mp-&gt;allocate();        char* p1 = (char*)mp-&gt;allocate();        mp-&gt;deallocate(p0);        char* p2 = (char*)mp-&gt;allocate();        mp-&gt;deallocate(p1);                mp-&gt;deallocate(p2);    }}int main(){    MemoryPool&lt;char&gt; mp;    int i = 0;    while (i++ &lt; 100000) {        char* p0 = (char*)mp.allocate();        char* p1 = (char*)mp.allocate();        mp.deallocate(p0);        char* p2 = (char*)mp.allocate();        mp.deallocate(p1);        mp.deallocate(p2);    }    std::thread th0(ThreadProc, &amp;mp);    std::thread th1(ThreadProc, &amp;mp);    std::thread th2(ThreadProc, &amp;mp);    th0.join();    th1.join();    th2.join();    Apple* apple = nullptr;    MemoryPool&lt;Apple&gt; mp2;    apple = mp2.newElement(10);    assert(apple);    int a = apple-&gt;GetId(); // 10    assert(a == 10);    apple-&gt;SetId(12);    mp2.deleteElement(apple);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++生成条形码</title>
      <link href="/2023/06/25/c-sheng-cheng-tiao-xing-ma/"/>
      <url>/2023/06/25/c-sheng-cheng-tiao-xing-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="一、条形码介绍"><a href="#一、条形码介绍" class="headerlink" title="一、条形码介绍"></a>一、条形码介绍</h1><p>条形码(<code>barcode</code>)是将宽度不等的多个黑条和空白，按照一定的编码规则排列，用以表达一组信息的图形标识符。常见的条形码是由反射率相差很大的黑条（简称条）和白条（简称空）排成的平行线图案。</p><p><strong>条码种类很多，常见的大概有二十多种码制，其中包括：</strong><br>Code39码（标准39码）、Codabar码（库德巴码）、Code25码（标准25码）、ITF25码（交叉25码）、Matrix25码（矩阵25码）、UPC-A码、UPC-E码、EAN-13码（EAN-13国际商品条码）、EAN-8码（EAN-8国际商品条码）、中国邮政码（矩阵25码的一种变体）、Code-B码、MSI码、Code11码、Code93码、ISBN码、ISSN码、Code128码（Code128码，包括EAN128码）、Code39EMS（EMS专用的39码）等一维条码和PDF417等二维条码。</p><p><strong>目前，国际广泛使用的条码种类有：</strong></p><ul><li>EAN码 —— 国际物品编码协会制定的一种商品用条码，通用于全世界。EAN码符号有标准版（EAN-13）和缩短版（EAN-8）两种，我国的通用商品条码与其等效，日常购买的商品包装上所印的条码一般就是EAN码。</li><li>UPC码 —— UPC码是美国统一代码委员会制定的一种商品用条码，主要用于美国和加拿大地区，我们在美国进口的商品上可以看到。</li><li>Code39码 —— 因其可采用数字与字母共同组成的方式而在各行业内部管理上被广泛使用。</li><li>Code93码 —— Code 93码与39码具有相同的字符集，但它的密度要比39码高，所以在面积不足的情况下，可以用93码代替39码</li><li>Codebar码 —— 可表示数字0 - 9，字符$、+、 -、还有只能用作起始/终止符的a,b,c d四个字符，可变长度，没有校验位，多用于血库,图书馆和照像馆的业务中。</li><li>Code128码 —— 128可表示ASCII 0 到 ASCII 127 共计128个ASCII字符。</li><li>CodeI2of5码 —— 只能表示数字0 -9 可变长度，连续性条形码，所有条与空都表示代码，第一个数字由条开始，第二个数字由空组成，空白区比窄条宽10倍，应用于商品批发、仓库、机场、生产/包装识别、工业中，条形码的识读率高，可适用于固定扫描器可靠扫描，在所有一维条形码中的密度最高。</li></ul><h1 id="二、C-方式实现"><a href="#二、C-方式实现" class="headerlink" title="二、C++方式实现"></a>二、C++方式实现</h1><p><strong><code>barcode.h</code></strong> 中实现了Code39、Code93、Code128、CodeI2of5等4种格式的条形码的生成。<br>具体使用方法：调用对应类的<code>DrawBarcode</code>函数将条形码绘制到HDC上，绘制到HDC上之后可以保存为图片或者显示到界面。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#ifndef BARCODE_H_#define BARCODE_H_#pragma onceclass Barcode39;class Barcode93;class BarcodeIof5;class Barcode128;static const int ga2_Code128[2][207] ={    {        64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,        80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,        0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,        16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,        32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,        48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106,    },    {        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,        16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,        32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,        48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,        64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,        80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106,    },};class BarcodeBase {public:    BarcodeBase() {        Clear();        i_Ratio = 3;    }    void operator=(const BarcodeBase&amp;bc) {        i_LenBuf = bc.i_LenBuf;        i_Ratio = bc.i_Ratio;        memcpy(ia_Buf, bc.ia_Buf, sizeof(ia_Buf));    }    void Clear() {        memset(ia_Buf, 0, sizeof(ia_Buf));        i_LenBuf = 0;    }    int GetEncodeLength()const {        BYTE*pb = (BYTE*)ia_Buf;        int i, iLen = 0;        for (i = 0; i &lt; i_LenBuf; i++) {            //wide is 3            if (*pb &amp; 2)iLen += (i_Ratio - 1);            pb++;        }        return iLen + i_LenBuf;    }    int GetBufferLength()const {        return i_LenBuf;    }    const BYTE&amp;GetAt(int i)const {        return ia_Buf[i];    }    int GetRatio()const {        return i_Ratio;    }    int SetRatio(int iRatio) {        i_Ratio = iRatio;        if (i_Ratio &lt;= 0)i_Ratio = 1;    }    void DrawBarcode(HDC hDC, int iX, int iY0, int iY10, int iY11, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) {        HPEN hPenBar = ::CreatePen(PS_SOLID, iPenW, clrBar);        HPEN hPenSpace = ::CreatePen(PS_SOLID, iPenW, clrSpace);        HPEN hPenOld = (HPEN)::SelectObject(hDC, hPenBar);        BYTE*pb = ia_Buf;        int i0, iNum0 = i_LenBuf;        BYTE bBar;        int i1, iNum1;        int iY;        for (i0 = 0; i0 &lt; iNum0; i0++) {            bBar = *pb &amp; 0x01;            iNum1 = (*pb &amp; 0x02) ? i_Ratio : 1;            iY = (*pb &amp; 0x04) ? iY11 : iY10;            for (i1 = 0; i1 &lt; iNum1; i1++) {                if (bBar)::SelectObject(hDC, hPenBar);                else::SelectObject(hDC, hPenSpace);                ::MoveToEx(hDC, iX, iY0, 0);                ::LineTo(hDC, iX, iY);                iX += iPenW;            }            pb++;        }        ::SelectObject(hDC, hPenOld);        ::DeleteObject(hPenBar);        ::DeleteObject(hPenSpace);    }protected:    BYTEia_Buf[4096];    inti_LenBuf;    inti_Ratio;    struct IntString {        int ch;        char*psz;    };};class Barcode39 : public BarcodeBase {    //[n/a][n/a][n/a][n/a][n/a][n/a][w-n][b-s]public:    Barcode39() {    }    ~Barcode39() {    }    BOOL Encode39(const char*pszCodeIn) {        int iLen = strlen(pszCodeIn);        char*pszCode = new char[iLen + 3];        sprintf(pszCode, "*%s*", pszCodeIn);        strupr(pszCode);        BYTE*pFst = ia_Buf;        BYTE*p0 = pFst, *p1;        iLen += 2;        int i;        for (i = 0; i &lt; iLen; i++) {            p1 = P_GetNarrowWideBarSpace39(pszCode[i], p0);            if (p1 == 0)return 0;            p0 = p1;        }        i_LenBuf = p1 - pFst;        delete[]pszCode;        return 1;    }    void Draw39(HDC hDC, int iX, int iY0, int iY1, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) {        DrawBarcode(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW);    }private:    BYTE*P_GetNarrowWideBarSpace39(char ch, BYTE*pb) {        IntString infs[] =        {            {'1',"wnnwnnnnwn"},            {'2',"nnwwnnnnwn"},            {'3',"wnwwnnnnnn"},            {'4',"nnnwwnnnwn"},            {'5',"wnnwwnnnnn"},            {'6',"nnwwwnnnnn"},            {'7',"nnnwnnwnwn"},            {'8',"wnnwnnwnnn"},            {'9',"nnwwnnwnnn"},            {'0',"nnnwwnwnnn"},            {'A',"wnnnnwnnwn"},            {'B',"nnwnnwnnwn"},            {'C',"wnwnnwnnnn"},            {'D',"nnnnwwnnwn"},            {'E',"wnnnwwnnnn"},            {'F',"nnwnwwnnnn"},            {'G',"nnnnnwwnwn"},            {'H',"wnnnnwwnnn"},            {'I',"nnwnnwwnnn"},            {'J',"nnnnwwwnnn"},            {'K',"wnnnnnnwwn"},            {'L',"nnwnnnnwwn"},            {'M',"wnwnnnnwnn"},            {'N',"nnnnwnnwwn"},            {'O',"wnnnwnnwnn"},            {'P',"nnwnwnnwnn"},            {'Q',"nnnnnnwwwn"},            {'R',"wnnnnnwwnn"},            {'S',"nnwnnnwwnn"},            {'T',"nnnnwnwwnn"},            {'U',"wwnnnnnnwn"},            {'V',"nwwnnnnnwn"},            {'W',"wwwnnnnnnn"},            {'X',"nwnnwnnnwn"},            {'Y',"wwnnwnnnnn"},            {'Z',"nwwnwnnnnn"},            {'-',"nwnnnnwnwn"},            {'.',"wwnnnnwnnn"},            {' ',"nwwnnnwnnn"},            {'*',"nwnnwnwnnn"},            {'$',"nwnwnwnnnn"},            {'/',"nwnwnnnwnn"},            {'+',"nwnnnwnwnn"},            {'%',"nnnwnwnwnn"},        };        int i0, iNum0 = sizeof(infs) / sizeof(infs[0]);        int i1;        for (i0 = 0; i0 &lt; iNum0; i0++) {            IntString&amp;inf = infs[i0];            if (inf.ch == ch) {                for (i1 = 0; i1 &lt; 10; i1++) {                    if (inf.psz[i1] == 'w')*pb += 2;                    if (i1 % 2 == 0)*pb += 1;                    pb++;                }                return pb;            }        }        return 0;    }};class BarcodeI2of5 :public BarcodeBase {    //[n/a][n/a][n/a][n/a][n/a][n/a][w-n][b-s]public:    BarcodeI2of5() {    }    ~BarcodeI2of5() {    }    BOOL EncodeI2of5(const char*pszCode) {        Clear();        BYTE*pFst = ia_Buf;        BYTE*pb = pFst;        const int iNum = strlen(pszCode);        int i;        //"nnnn"        for (i = 0; i &lt; 4; i++) {            if (i % 2 == 0)*pb += 1;            pb++;        }        int iV;        for (i = 0; i &lt; iNum; i += 2) {            iV = pszCode[i] - '0';            iV = iV * 10;            iV += pszCode[i + 1] - '0';            pb = P_GetNarrorWideBarSpaceI2of5(pb, iV);            if (pb == 0)return 0;        }        //"wnn"        *pb += 3;pb++;        *pb += 0;pb++;        *pb += 1;pb++;        i_LenBuf = pb - pFst;        return 1;    }    void DrawI2of5(HDC hDC, int iX, int iY0, int iY1, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) {        DrawBarcode(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW);    }private:    BYTE*P_GetNarrorWideBarSpaceI2of5(BYTE*pb, int ch) {        if (ch &lt; 0)return 0;        if (ch &gt; 99)return 0;        IntString infs[] =        {            {0,"nnnnwwwwnn"},            {1,"nwnnwnwnnw"},            {2,"nnnwwnwnnw"},            {3,"nwnwwnwnnn"},            {4,"nnnnwwwnnw"},            {5,"nwnnwwwnnn"},            {6,"nnnwwwwnnn"},            {7,"nnnnwnwwnw"},            {8,"nwnnwnwwnn"},            {9,"nnnwwnwwnn"},            {10,"wnnnnwnwwn"},            {11,"wwnnnnnnww"},            {12,"wnnwnnnnww"},            {13,"wwnwnnnnwn"},            {14,"wnnnnwnnww"},            {15,"wwnnnwnnwn"},            {16,"wnnwnwnnwn"},            {17,"wnnnnnnwww"},            {18,"wwnnnnnwwn"},            {19,"wnnwnnnwwn"},            {20,"nnwnnwnwwn"},            {21,"nwwnnnnnww"},            {22,"nnwwnnnnww"},            {23,"nwwwnnnnwn"},            {24,"nnwnnwnnww"},            {25,"nwwnnwnnwn"},            {26,"nnwwnwnnwn"},            {27,"nnwnnnnwww"},            {28,"nwwnnnnwwn"},            {29,"nnwwnnnwwn"},            {30,"wnwnnwnwnn"},            {31,"wwwnnnnnnw"},            {32,"wnwwnnnnnw"},            {33,"wwwwnnnnnn"},            {34,"wnwnnwnnnw"},            {35,"wwwnnwnnnn"},            {36,"wnwwnwnnnn"},            {37,"wnwnnnnwnw"},            {38,"wwwnnnnwnn"},            {39,"wnwwnnnwnn"},            {40,"nnnnwwnwwn"},            {41,"nwnnwnnnww"},            {42,"nnnwwnnnww"},            {43,"nwnwwnnnwn"},            {44,"nnnnwwnnww"},            {45,"nwnnwwnnwn"},            {46,"nnnwwwnnwn"},            {47,"nnnnwnnwww"},            {48,"nwnnwnnwwn"},            {49,"nnnwwnnwwn"},            {50,"wnnnwwnwnn"},            {51,"wwnnwnnnnw"},            {52,"wnnwwnnnnw"},            {53,"wwnwwnnnnn"},            {54,"wnnnwwnnnw"},            {55,"wwnnwwnnnn"},            {56,"wnnwwwnnnn"},            {57,"wnnnwnnwnw"},            {58,"wwnnwnnwnn"},            {59,"wnnwwnnwnn"},            {60,"nnwnwwnwnn"},            {61,"nwwnwnnnnw"},            {62,"nnwwwnnnnw"},            {63,"nwwwwnnnnn"},            {64,"nnwnwwnnnw"},            {65,"nwwnwwnnnn"},            {66,"nnwwwwnnnn"},            {67,"nnwnwnnwnw"},            {68,"nwwnwnnwnn"},            {69,"nnwwwnnwnn"},            {70,"nnnnnwwwwn"},            {71,"nwnnnnwnww"},            {72,"nnnwnnwnww"},            {73,"nwnwnnwnwn"},            {74,"nnnnnwwnww"},            {75,"nwnnnwwnwn"},            {76,"nnnwnwwnwn"},            {77,"nnnnnnwwww"},            {78,"nwnnnnwwwn"},            {79,"nnnwnnwwwn"},            {80,"wnnnnwwwnn"},            {81,"wwnnnnwnnw"},            {82,"wnnwnnwnnw"},            {83,"wwnwnnwnnn"},            {84,"wnnnnwwnnw"},            {85,"wwnnnwwnnn"},            {86,"wnnwnwwnnn"},            {87,"wnnnnnwwnw"},            {88,"wwnnnnwwnn"},            {89,"wnnwnnwwnn"},            {90,"nnwnnwwwnn"},            {91,"nwwnnnwnnw"},            {92,"nnwwnnwnnw"},            {93,"nwwwnnwnnn"},            {94,"nnwnnwwnnw"},            {95,"nwwnnwwnnn"},            {96,"nnwwnwwnnn"},            {97,"nnwnnnwwnw"},            {98,"nwwnnnwwnn"},            {99,"nnwwnnwwnn"},        };        IntString&amp;inf = infs[ch];        int i;        for (i = 0; i &lt; 10; i++) {            if (inf.psz[i] == 'w')*pb += 2;            if (i % 2 == 0)*pb += 1;            pb++;        }        return pb;    }};class Barcode93 :public BarcodeBase {    //[n/a][n/a][n/a][n/a][n/a][n/a][n/a][b-s]public:    Barcode93() {    }    ~Barcode93() {    }    BOOL Encode93(const char* pszCode) {        Clear();        const int iNum = strlen(pszCode);        BYTE*pFst = ia_Buf;        BYTE*pb = pFst;        pb = P_GetBarSpace93(pb, 47);        if (pb == 0)return 0;        BOOL b;        int i, iFirst, iSecond;        for (i = 0; i &lt; iNum; i++) {            b = P_AscIItoCode93Sequence((int)pszCode[i], iFirst, iSecond);            if (b == 0)return 0;            pb = P_GetBarSpace93(pb, iFirst);            if (pb == 0)return 0;            if (iSecond != -1) {                pb = P_GetBarSpace93(pb, iSecond);                if (pb == 0)return 0;            }        }        pb = P_GetCheckDigits(pb, pszCode);        if (pb == 0)return 0;        pb = P_GetBarSpace93(pb, 48);        if (pb == 0)return 0;        i_LenBuf = pb - pFst;        return 1;    }    void Draw93(HDC hDC, int iX, int iY0, int iY1, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) {        DrawBarcode(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW);    }private:    BYTE*P_GetBarSpace93(BYTE*pb, int ch) {        if (ch &lt; 0)return 0;        if (ch &gt; 48)return 0;        IntString infs[] =        {            {0,"bsssbsbss"},            {1,"bsbssbsss"},            {2,"bsbsssbss"},            {3,"bsbssssbs"},            {4,"bssbsbsss"},            {5,"bssbssbss"},            {6,"bssbsssbs"},            {7,"bsbsbssss"},            {8,"bsssbssbs"},            {9,"bssssbsbs"},            {10,"bbsbsbsss"},            {11,"bbsbssbss"},            {12,"bbsbsssbs"},            {13,"bbssbsbss"},            {14,"bbssbssbs"},            {15,"bbsssbsbs"},            {16,"bsbbsbsss"},            {17,"bsbbssbss"},            {18,"bsbbsssbs"},            {19,"bssbbsbss"},            {20,"bsssbbsbs"},            {21,"bsbsbbsss"},            {22,"bsbssbbss"},            {23,"bsbsssbbs"},            {24,"bssbsbbss"},            {25,"bsssbsbbs"},            {26,"bbsbbsbss"},            {27,"bbsbbssbs"},            {28,"bbsbsbbss"},            {29,"bbsbssbbs"},            {30,"bbssbsbbs"},            {31,"bbssbbsbs"},            {32,"bsbbsbbss"},            {33,"bsbbssbbs"},            {34,"bssbbsbbs"},            {35,"bssbbbsbs"},            {36,"bssbsbbbs"},            {37,"bbbsbsbss"},            {38,"bbbsbssbs"},            {39,"bbbssbsbs"},            {40,"bsbbsbbbs"},            {41,"bsbbbsbbs"},            {42,"bbsbsbbbs"},            {43,"bssbssbbs"},            {44,"bbbsbbsbs"},            {45,"bbbsbsbbs"},            {46,"bssbbssbs"},            {47,"bsbsbbbbs"},            {48,"bsbsbbbbsb"},        };        IntString&amp;inf = infs[ch];        int i;        for (i = 0; i &lt; 9; i++) {            if (inf.psz[i] == 'b')*pb += 1;            pb++;        }        if (ch == 48) {            *pb += 1;            pb++;        }        return pb;    }private:    BYTE*P_GetCheckDigits(BYTE*pb, const char*&amp;pszCode) {        int i, iSum, iWeight, iFirst, iSecond;        // "C" check digit character        iWeight = 1;        iSum = 0;        const int iNum = strlen(pszCode);        for (i = iNum - 1; i &gt; -1; i--) {            P_AscIItoCode93Sequence((int)pszCode[i], iFirst, iSecond);            iSum += (iWeight*iFirst);            iWeight++;            if (iWeight &gt; 20)iWeight = 1;            if (iSecond != -1) {                iSum += (iWeight*iSecond);                iWeight++;                if (iWeight &gt; 20)iWeight = 1;            }        }        pb = P_GetBarSpace93(pb, iSum % 47);        if (pb == 0)return 0;        iWeight = 2;        iSum = iSum % 47;        for (i = iNum - 1; i &gt; -1; i--) {            P_AscIItoCode93Sequence((int)pszCode[i], iFirst, iSecond);            iSum += (iWeight * iFirst);            iWeight++;            if (iWeight &gt; 15)iWeight = 1;            if (iSecond != -1) {                iSum += (iWeight * iSecond);                iWeight++;                if (iWeight &gt; 15)iWeight = 1;            }        }        pb = P_GetBarSpace93(pb, iSum % 47);        if (pb == 0)return 0;        return pb;    }    BOOL P_AscIItoCode93Sequence(int iValue, int&amp;iFirst, int&amp;iSecond) {        if (iValue &lt; 0)return 0;        if (iValue &gt; 127)return 0;        structI3 { int iV, iFirst, iSecond; };        I3 i3s[] =        {            {0,44,30},            {1,43,10},            {2,43,11},            {3,43,12},            {4,43,13},            {5,43,14},            {6,43,15},            {7,43,16},            {8,43,17},            {9,43,18},            {10,43,19},            {11,43,20},            {12,43,21},            {13,43,22},            {14,43,23},            {15,43,24},            {16,43,25},            {17,43,26},            {18,43,27},            {19,43,28},            {20,43,29},            {21,43,30},            {22,43,31},            {23,43,32},            {24,43,33},            {25,43,34},            {26,43,35},            {27,44,10},            {28,44,11},            {29,44,12},            {30,44,13},            {31,44,14},            {32,38,-1},            {33,45,10},            {34,45,11},            {35,45,12},            {36,39,-1},            {37,42,-1},            {38,45,15},            {39,45,16},            {40,45,17},            {41,45,18},            {42,45,19},            {43,41,-1},            {44,45,21},            {45,36,-1},            {46,37,-1},            {47,40,-1},            {48,0,-1},            {49,1,-1},            {50,2,-1},            {51,3,-1},            {52,4,-1},            {53,5,-1},            {54,6,-1},            {55,7,-1},            {56,8,-1},            {57,9,-1},            {58,45,35},            {59,44,15},            {60,44,16},            {61,44,17},            {62,44,18},            {63,44,19},            {64,44,31},            {65,10,-1},            {66,11,-1},            {67,12,-1},            {68,13,-1},            {69,14,-1},            {70,15,-1},            {71,16,-1},            {72,17,-1},            {73,18,-1},            {74,19,-1},            {75,20,-1},            {76,21,-1},            {77,22,-1},            {78,23,-1},            {79,24,-1},            {80,25,-1},            {81,26,-1},            {82,27,-1},            {83,28,-1},            {84,29,-1},            {85,30,-1},            {86,31,-1},            {87,32,-1},            {88,33,-1},            {89,34,-1},            {90,35,-1},            {91,44,20},            {92,44,21},            {93,44,22},            {94,44,23},            {95,44,24},            {96,44,32},            {97,46,10},            {98,46,11},            {99,46,12},            {100,46,13},            {101,46,14},            {102,46,15},            {103,46,16},            {104,46,17},            {105,46,18},            {106,46,19},            {107,46,20},            {108,46,21},            {109,46,22},            {110,46,23},            {111,46,24},            {112,46,25},            {113,46,26},            {114,46,27},            {115,46,28},            {116,46,29},            {117,46,30},            {118,46,31},            {119,46,32},            {120,46,33},            {121,46,34},            {122,46,35},            {123,44,25},            {124,44,26},            {125,44,27},            {126,44,28},            {127,44,29},        };        I3&amp;i3 = i3s[iValue];        iFirst = i3.iFirst;        iSecond = i3.iSecond;        return 1;    }};class Barcode128 :public BarcodeBase {public:    Barcode128() {    }    ~Barcode128() {    }    BOOL Encode128A(const char* pszCode) { return P_Encode128((char*)pszCode, SUB::SETA); }    BOOL Encode128B(const char* pszCode) { return P_Encode128((char*)pszCode, SUB::SETB); }    BOOL Encode128C(const char* pszCode) { return P_Encode128((char*)pszCode, SUB::SETC); }    void Draw128(HDC hDC, int iX, int iY0, int iY1, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) {        DrawBarcode(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW);    }private:    struct SUB {        enum {            SETA = 0,            SETB = 1,            SETC = 2,        };    };    BOOL P_Encode128(char*pszCode, const int iSetIn) {        Clear();        BYTE*pFst = ia_Buf;        BYTE*pb = pFst;        if (iSetIn == SUB::SETA)pb = P_GetBarSpace128(pb, 103);        else            if (iSetIn == SUB::SETB)pb = P_GetBarSpace128(pb, 104);            elsepb = P_GetBarSpace128(pb, 105);            if (pb == 0)return 0;            const int iCheckDigit = GetCheckDigit(iSetIn, pszCode);            const int iNum = strlen(pszCode);            int iChar, iCharNext;            int iPosition = 0;            int iSet = iSetIn;            while (iPosition &lt; iNum) {                if (iSet == SUB::SETC) {                    if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 101) {                        pb = P_GetBarSpace128(pb, 101);                        iPosition++;                        iSet = SUB::SETA;                    }                    else                        if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 100) {                            pb = P_GetBarSpace128(pb, 100);                            iPosition++;                            iSet = SUB::SETB;                        }                        else if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 102) {                            pb = P_GetBarSpace128(pb, 100);                            iPosition++;                        }                        else {                            char chT = pszCode[iPosition + 2];                            pszCode[iPosition + 2] = 0;                            iChar = atoi(&amp;pszCode[iPosition]);                            pszCode[iPosition + 2] = chT;                            pb = P_GetBarSpace128(pb, iChar);                            if (pb == 0)return 0;                            iPosition += 2;                        }                }                else {                    int iTemp2 = pszCode[iPosition];                    if (iTemp2 &lt; -1)iTemp2 = iTemp2 &amp; 255;                    iChar = ga2_Code128[iSet][iTemp2];                    pb = P_GetBarSpace128(pb, iChar);                    if (pb == 0)return 0;                    iPosition++;                    if (iSet == SUB::SETA) {                        if (iChar == 100)iSet = SUB::SETB;                        else                            if (iChar == 99)iSet = SUB::SETC;                    }                    else if (iSet == SUB::SETB) {                        if (iChar == 101)iSet = SUB::SETA;                        else                            if (iChar == 99)iSet = SUB::SETC;                    }                    else                        if (iChar == 98) {                            if (iSet == SUB::SETA)                                iCharNext = ga2_Code128[SUB::SETB][pszCode[iPosition]];                            else                                iCharNext = ga2_Code128[SUB::SETA][pszCode[iPosition]];                            pb = P_GetBarSpace128(pb, iChar);                            if (pb == 0)return 0;                            iPosition++;                        }                }            }            pb = P_GetBarSpace128(pb, iCheckDigit);            if (pb == 0)return 0;            pb = P_GetBarSpace128(pb, 106);            i_LenBuf = pb - pFst;            return 1;    }    BYTE*P_GetBarSpace128(BYTE*pb, int iV) {        if (iV &lt; 0)return 0;        if (iV &gt; 106)return 0;        IntString infs[] =        {            {0,"bbsbbssbbss"},            {1,"bbssbbsbbss"},            {2,"bbssbbssbbs"},            {3,"bssbssbbsss"},            {4,"bssbsssbbss"},            {5,"bsssbssbbss"},            {6,"bssbbssbsss"},            {7,"bssbbsssbss"},            {8,"bsssbbssbss"},            {9,"bbssbssbsss"},            {10,"bbssbsssbss"},            {11,"bbsssbssbss"},            {12,"bsbbssbbbss"},            {13,"bssbbsbbbss"},            {14,"bssbbssbbbs"},            {15,"bsbbbssbbss"},            {16,"bssbbbsbbss"},            {17,"bssbbbssbbs"},            {18,"bbssbbbssbs"},            {19,"bbssbsbbbss"},            {20,"bbssbssbbbs"},            {21,"bbsbbbssbss"},            {22,"bbssbbbsbss"},            {23,"bbbsbbsbbbs"},            {24,"bbbsbssbbss"},            {25,"bbbssbsbbss"},            {26,"bbbssbssbbs"},            {27,"bbbsbbssbss"},            {28,"bbbssbbsbss"},            {29,"bbbssbbssbs"},            {30,"bbsbbsbbsss"},            {31,"bbsbbsssbbs"},            {32,"bbsssbbsbbs"},            {33,"bsbsssbbsss"},            {34,"bsssbsbbsss"},            {35,"bsssbsssbbs"},            {36,"bsbbsssbsss"},            {37,"bsssbbsbsss"},            {38,"bsssbbsssbs"},            {39,"bbsbsssbsss"},            {40,"bbsssbsbsss"},            {41,"bbsssbsssbs"},            {42,"bsbbsbbbsss"},            {43,"bsbbsssbbbs"},            {44,"bsssbbsbbbs"},            {45,"bsbbbsbbsss"},            {46,"bsbbbsssbbs"},            {47,"bsssbbbsbbs"},            {48,"bbbsbbbsbbs"},            {49,"bbsbsssbbbs"},            {50,"bbsssbsbbbs"},            {51,"bbsbbbsbsss"},            {52,"bbsbbbsssbs"},            {53,"bbsbbbsbbbs"},            {54,"bbbsbsbbsss"},            {55,"bbbsbsssbbs"},            {56,"bbbsssbsbbs"},            {57,"bbbsbbsbsss"},            {58,"bbbsbbsssbs"},            {59,"bbbsssbbsbs"},            {60,"bbbsbbbbsbs"},            {61,"bbssbssssbs"},            {62,"bbbbsssbsbs"},            {63,"bsbssbbssss"},            {64,"bsbssssbbss"},            {65,"bssbsbbssss"},            {66,"bssbssssbbs"},            {67,"bssssbsbbss"},            {68,"bssssbssbbs"},            {69,"bsbbssbssss"},            {70,"bsbbssssbss"},            {71,"bssbbsbssss"},            {72,"bssbbssssbs"},            {73,"bssssbbsbss"},            {74,"bssssbbssbs"},            {75,"bbssssbssbs"},            {76,"bbssbsbssss"},            {77,"bbbbsbbbsbs"},            {78,"bbssssbsbss"},            {79,"bsssbbbbsbs"},            {80,"bsbssbbbbss"},            {81,"bssbsbbbbss"},            {82,"bssbssbbbbs"},            {83,"bsbbbbssbss"},            {84,"bssbbbbsbss"},            {85,"bssbbbbssbs"},            {86,"bbbbsbssbss"},            {87,"bbbbssbsbss"},            {88,"bbbbssbssbs"},            {89,"bbsbbsbbbbs"},            {90,"bbsbbbbsbbs"},            {91,"bbbbsbbsbbs"},            {92,"bsbsbbbbsss"},            {93,"bsbsssbbbbs"},            {94,"bsssbsbbbbs"},            {95,"bsbbbbsbsss"},            {96,"bsbbbbsssbs"},            {97,"bbbbsbsbsss"},            {98,"bbbbsbsssbs"},            {99,"bsbbbsbbbbs"},            {100,"bsbbbbsbbbs"},            {101,"bbbsbsbbbbs"},            {102,"bbbbsbsbbbs"},            //{103,"bbsbsbbbbss"},                        {103,"bbsbssssbss"},                        {104,"bbsbssbssss"},                        {105,"bbsbssbbbss"},                        {106,"bbsssbbbsbsbb"},        };        int i;        IntString&amp;inf = infs[iV];        for (i = 0; i &lt; 11; i++) {            if (inf.psz[i] == 'b')*pb += 1;            pb++;        }        if (iV == 106) {            *pb += 1;pb++;            *pb += 1;pb++;        }        return pb;    }private:    int GetCheckDigit(const int iSet, char*pszCode) {        intiSum = 0, iCurSet = 0, iChar128, iCharNext, iWeight, iPosition;        iCurSet = iSet;        if (iSet == SUB::SETA) {            iSum = 103;        }        else            if (iSet == SUB::SETB) {                iSum = 104;            }            else                if (iSet == SUB::SETC) {                    iSum = 105;                }        iPosition = 0;        iWeight = 1;        const int iNum = strlen(pszCode);        while (iPosition &lt; iNum) {            if (iCurSet == SUB::SETC) {                if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 101) {                    iChar128 = 101;                    iSum += (iWeight*iChar128);                    iPosition++;                    iWeight++;                    iCurSet = SUB::SETA;                }                else if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 100) {                    iChar128 = 100;                    iSum += (iWeight*iChar128);                    iPosition++;                    iWeight++;                    iCurSet = SUB::SETB;                }                else                    if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 102) {                        iChar128 = 102;                        iSum += (iWeight*iChar128);                        iPosition++;                        iWeight++;                    }                    else {                        char chT = pszCode[iPosition + 2];                        pszCode[iPosition + 2] = 0;                        iChar128 = atol(&amp;pszCode[iPosition]);                        pszCode[iPosition + 2] = chT;                        iSum += (iWeight*iChar128);                        iPosition += 2;                        iWeight++;                    }            }            else {                int iTemp2 = pszCode[iPosition];                if (iTemp2 &lt; -1)iTemp2 = iTemp2 &amp; 255;                iChar128 = ga2_Code128[iCurSet][iTemp2];                iSum += (iWeight*iChar128);                iPosition++;                iWeight++;                if (iCurSet == SUB::SETA) {                    if (iChar128 == 100)                        iCurSet = SUB::SETB;                    else if (iChar128 == 99)                        iCurSet = SUB::SETC;                }                else                    if (iCurSet == SUB::SETB) {                        if (iChar128 == 101)iCurSet = SUB::SETA;                        else if (iChar128 == 99)iCurSet = SUB::SETC;                    }                    else                        if (iChar128 == 98) {                            if (iCurSet == SUB::SETA)                                iCharNext = ga2_Code128[SUB::SETB][pszCode[iPosition]];                            else                                iCharNext = ga2_Code128[SUB::SETA][pszCode[iPosition]];                            iSum += (iWeight*iCharNext);                            iPosition++;                            iWeight++;                        }            }        }        return iSum % 103;    }};//=============================================class BarcodeEan13 :public BarcodeBase {public:    BarcodeEan13() {    }    ~BarcodeEan13() {    }    BOOL EncodeEan13(const char*pszCodeIn) {        Clear();        //only allow 12 characters as input        char szCode[14];        const int iLen = strlen(pszCodeIn);        if (iLen &gt; 12) {            strncpy(szCode, pszCodeIn, 12);        }        else {            strcpy(szCode, pszCodeIn);            while (strlen(szCode) &lt; 12)strcat(szCode, "0");        }        BYTE*pFst = ia_Buf;        BYTE*pb = pFst;        //"bsb"-long        *pb += 5;pb++;        *pb += 4;pb++;        *pb += 5;pb++;        BYTE iaCountryCode[6];        BOOL b = P_GetCountryCode(szCode[0], iaCountryCode);        if (b == 0)return 0;        pb = P_GetLeftOddParity(pb, szCode[1]);        int i;        for (i = 2; i &lt; 7; i++) {            if (iaCountryCode[i - 2] == 'O') {                pb = P_GetLeftOddParity(pb, szCode[i]);            }            else                if (iaCountryCode[i - 2] == 'E') {                    pb = P_GetLeftEvenParity(pb, szCode[i]);                }        }        //"sbsbs"-long        *pb += 4;pb++;        *pb += 5;pb++;        *pb += 4;pb++;        *pb += 5;pb++;        *pb += 4;pb++;        for (i = 7; i &lt; 12; i++) {            pb = P_GetRightPattern(pb, szCode[i]);        }        i = P_GetCheckSumDigit(szCode);        pb = P_GetRightPattern(pb, (char)i);        //"bsb"-long        *pb += 5;pb++;        *pb += 4;pb++;        *pb += 5;pb++;        i_LenBuf = pb - pFst;        return 1;    }    void DrawEan13(HDC hDC, int iX, int iY0, int iY10, int iY11, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) {        DrawBarcode(hDC, iX, iY0, iY10, iY11, clrBar, clrSpace, iPenW);    }private:    BOOL P_GetCountryCode(char ch, BYTE*pbCountryCode) {        const int iV = ch - '0';        if (iV &lt; 0)return 0;        if (iV &gt; 9)return 0;        IntString infs[] =        {            {0,"OOOOO"},            {1,"OEOEE"},            {2,"OEEOE"},            {3,"OEEEO"},            {4,"EOOEE"},            {5,"EEOOE"},            {6,"EEEOO"},            {7,"EOEOE"},            {8,"EOEEO"},            {9,"EEOEO"},        };        memcpy(pbCountryCode, infs[iV].psz, 5);        return 1;    }    BYTE*P_GetLeftOddParity(BYTE*pb, char ch) {        const int iV = ch - '0';        if (iV &lt; 0)return 0;        if (iV &gt; 9)return 0;        IntString infs[] =        {            {0,"sssbbsb"},            {1,"ssbbssb"},            {2,"ssbssbb"},            {3,"sbbbbsb"},            {4,"sbsssbb"},            {5,"sbbsssb"},            {6,"sbsbbbb"},            {7,"sbbbsbb"},            {8,"sbbsbbb"},            {9,"sssbsbb"},        };        IntString&amp;inf = infs[iV];        int i;        for (i = 0; i &lt; 7; i++) {            if (inf.psz[i] == 'b')*pb += 1;            pb++;        }        return pb;    }    BYTE*P_GetLeftEvenParity(BYTE*pb, char ch) {        const int iV = ch - '0';        if (iV &lt; 0)return 0;        if (iV &gt; 9)return 0;        IntString infs[] =        {            {0,"sbssbbb"},            {1,"sbbssbb"},            {2,"ssbbsbb"},            {3,"sbssssb"},            {4,"ssbbbsb"},            {5,"sbbbssb"},            {6,"ssssbsb"},            {7,"ssbsssb"},            {8,"sssbssb"},            {9,"ssbsbbb"},        };        char*psz = infs[iV].psz;        int i;        for (i = 0; i &lt; 7; i++) {            if (psz[i] == 'b')*pb += 1;            pb++;        }        return pb;    }    BYTE*P_GetRightPattern(BYTE*pb, char ch) {        const int iV = ch - '0';        if (iV &lt; 0)return 0;        if (iV &gt; 9)return 0;        IntString infs[] =        {            {0,"bbbssbs"},            {1,"bbssbbs"},            {2,"bbsbbss"},            {3,"bssssbs"},            {4,"bsbbbss"},            {5,"bssbbbs"},            {6,"bsbssss"},            {7,"bsssbss"},            {8,"bssbsss"},            {9,"bbbsbss"},        };        char*psz = infs[iV].psz;        int i;        for (i = 0; i &lt; 7; i++) {            if (psz[i] == 'b')*pb += 1;            pb++;        }        return pb;    }    char P_GetCheckSumDigit(const char*pszCode) {        const int iLen = strlen(pszCode);        int i, iSum = 0, iItem;        for (i = iLen; i &gt;= 1; i--) {            iItem = i % 2 ? (pszCode[i - 1] - '0') * 1 : (pszCode[i - 1] - '0') * 3;            iSum += iItem;        }        iSum %= 10;        return '0' + (10 - iSum) % 10;    }};#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 条形码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows注册URL协议</title>
      <link href="/2023/06/25/windows-zhu-ce-url-xie-yi/"/>
      <url>/2023/06/25/windows-zhu-ce-url-xie-yi/</url>
      
        <content type="html"><![CDATA[<p>当电脑安装完Steam后，在浏览器中输入<code>steam://run/123</code>链接，浏览器会自动提示打开Steam程序。<br><img src="https://static.1key.run/blog/img/windows-zczdyxy-1.jpg"></p><p>类似的功能在迅雷、QQ等产品上都有使用。</p><p>实现上述功能只需要在注册表<code>HKEY_CLASSES_ROOT</code>项下添加对应的子项即可，以注册<code>test</code>协议为例：</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">indows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\test]@="URL:test protocol""URL Protocol"=""[HKEY_CLASSES_ROOT\test\DefaultIcon]@="mytest.exe"[HKEY_CLASSES_ROOT\test\Shell][HKEY_CLASSES_ROOT\test\Shell\Open][HKEY_CLASSES_ROOT\test\Shell\Open\Command]@="\"D:\\sourcecode\\mytest.exe\" -- \"%1\""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改完之后，在浏览器中输入<code>test://start/123</code>就会打开<code>D:\\sourcecode\\mytest.exe</code>，并且传递给<code>mytest.exe</code>的命令行参数为<code>test://start/123</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> URL协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个Dockerfile同时运行多个进程</title>
      <link href="/2023/06/25/yi-ge-dockerfile-tong-shi-yun-xing-duo-ge-jin-cheng/"/>
      <url>/2023/06/25/yi-ge-dockerfile-tong-shi-yun-xing-duo-ge-jin-cheng/</url>
      
        <content type="html"><![CDATA[<p>Docker容器的哲学是一个Docker容器只运行一个进程。</p><p>但如果需要在一个容器内运行多个进程或服务，可以采取将入口文件设置为Bash Shell脚本，在脚本内运行多个程序的方式。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">#!/bin/bash # start 1start1  &gt; /var/log/start1.log 2&gt;&amp;1 &amp;# start 2start2 &gt; /var/log/start2.log 2&gt;&amp;1 &amp; # just keep this script runningwhile [[ true ]]; do    sleep 1done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Dockerfile的入口中运行run.sh：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">FROM ubuntu:latest...COPY ./run.sh /ENTRYPOINT  ["run.sh"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dockerfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以管理员权限运行批处理脚本</title>
      <link href="/2023/06/25/yi-guan-li-yuan-quan-xian-yun-xing-pi-chu-li-jiao-ben/"/>
      <url>/2023/06/25/yi-guan-li-yuan-quan-xian-yun-xing-pi-chu-li-jiao-ben/</url>
      
        <content type="html"><![CDATA[<p>基本原理：</p><ul><li>根据cacls.exe是否能够访问”%SystemDrive%\System Volume Information”文件，来判断当前批处理进程是否具有管理员权限。</li><li>创建vbs脚本到临时目录，并运用该脚本提权执行当前bat文件。</li></ul><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">@echo offcd /d "%~dp0"cacls.exe "%SystemDrive%\System Volume Information" &gt;nul 2&gt;nulif %errorlevel%==0 goto Adminif exist "%temp%\getadmin.vbs" del /f /q "%temp%\getadmin.vbs"echo Set RequestUAC = CreateObject^("Shell.Application"^)&gt;"%temp%\getadmin.vbs"echo RequestUAC.ShellExecute "%~s0","","","runas",1 &gt;&gt;"%temp%\getadmin.vbs"echo WScript.Quit &gt;&gt;"%temp%\getadmin.vbs""%temp%\getadmin.vbs" /fif exist "%temp%\getadmin.vbs" del /f /q "%temp%\getadmin.vbs"exit:Adminrem ---------- Here is the script to be run ------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 批处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 管理员权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NPM和Yarn设置国内源</title>
      <link href="/2023/06/25/npm-he-yarn-she-zhi-guo-nei-yuan/"/>
      <url>/2023/06/25/npm-he-yarn-she-zhi-guo-nei-yuan/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Yarn设置"><a href="#1-Yarn设置" class="headerlink" title="1. Yarn设置"></a>1. Yarn设置</h1><p>查看当前使用的镜像源：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">yarn config get registry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>全局修改：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">yarn config set registry https://registry.npm.taobao.org -gyarn config set disturl https://npm.taobao.org/dist -gyarn config set electron_mirror https://npm.taobao.org/mirrors/electron/ -gyarn config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ -gyarn config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/ -gyarn config set chromedriver_cdnurl https://cdn.npm.taobao.org/dist/chromedriver -gyarn config set operadriver_cdnurl https://cdn.npm.taobao.org/dist/operadriver -gyarn config set fse_binary_host_mirror https://npm.taobao.org/mirrors/fsevents -g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>临时修改：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">yarn save 软件名 --registry https://registry.npm.taobao.org/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="2-NPM设置"><a href="#2-NPM设置" class="headerlink" title="2. NPM设置"></a>2. NPM设置</h1><p>查看当前使用的镜像源：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">npm get registry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>全局设置：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/distnpm config set electron_mirror https://npm.taobao.org/mirrors/electron/npm config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/npm config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>npm v9版本会报错：<code>ELECTRON_MIRROR</code> is not a valid npm option。<br>需要切换为npm v8版本：<code>npm install -g npm@^8</code></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NPM </tag>
            
            <tag> Yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除Qt控件虚线框</title>
      <link href="/2023/06/25/yi-chu-qt-kong-jian-xu-xian-kuang/"/>
      <url>/2023/06/25/yi-chu-qt-kong-jian-xu-xian-kuang/</url>
      
        <content type="html"><![CDATA[<h1 id="方式一：使用-StyleSheet"><a href="#方式一：使用-StyleSheet" class="headerlink" title="方式一：使用 StyleSheet"></a>方式一：使用 StyleSheet</h1><pre class="line-numbers language-CSS" data-language="CSS"><code class="language-CSS">QWidget:focus {   outline: none; /* 去掉得到焦点时的虚线框 */ }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="方式二：继承-QProxyStyle"><a href="#方式二：继承-QProxyStyle" class="headerlink" title="方式二：继承 QProxyStyle"></a>方式二：继承 QProxyStyle</h1><p>继承 QProxyStyle，PrimitiveElement为QStyle::PE_FrameFocusRect 时不绘制虚线框，然后在main() 函数里调用 QApplication::setStyle() 使用新的样式。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">// 文件名: NoFocusRectStyle.h#ifndef NOFOCUSRECTSTYLE_H#define NOFOCUSRECTSTYLE_H#include &lt;QProxyStyle&gt;class NoFocusRectStyle : public QProxyStyle{public:    NoFocusRectStyle(QStyle *baseStyle) : QProxyStyle(baseStyle) {}    void drawPrimitive(PrimitiveElement element,                       const QStyleOption *option,                       QPainter *painter,                       const QWidget *widget = 0) const{        if (element == QStyle::PE_FrameFocusRect)        {            return;        }        QProxyStyle::drawPrimitive(element, option, painter, widget);    }};#endif // NOFOCUSRECTSTYLE_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">// 文件名: main.cpp#include "Widget.h"#include "NoFocusRectStyle.h"#include &lt;QApplication&gt;int main(int argc, char *argv[]){    QApplication app(argc, argv);    NoFocusRectStyle *style = new NoFocusRectStyle(app.style());    app.setStyle(style); // Ownership of the style object is transferred to QApplication    Widget w;    w.show();    return app.exec();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QProxyStyle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QSS基本使用方法</title>
      <link href="/2023/06/25/qss-ji-ben-shi-yong-fang-fa/"/>
      <url>/2023/06/25/qss-ji-ben-shi-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="一、选择器类型"><a href="#一、选择器类型" class="headerlink" title="一、选择器类型"></a>一、选择器类型</h1><p>Qt QSS选择器和CSS2、CSS3的选择器类似，建议先学习或者复习<a href="https://www.w3school.com.cn/cssref/css_selectors.asp">CSS选择器的语法</a>。QSS虽然和CSS类型，但有也稍许不同，而且支持的语法也没那么多，具体如下。</p><h2 id="1-1-类选择器"><a href="#1-1-类选择器" class="headerlink" title="1.1 类选择器"></a>1.1 类选择器</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*匹配QPushButton的实例及其子类*/</span><span class="token selector">QPushButton</span> <span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*匹配QPushButton的实例，但不包含子类*/</span><span class="token selector">.QPushButton</span> <span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-选择器分组"><a href="#1-2-选择器分组" class="headerlink" title="1.2 选择器分组"></a>1.2 选择器分组</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*同时匹配QPushButton、QLineEdit的实例*/</span><span class="token selector">QPushButton, QLineEdit</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>blue<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="1-3-ID选择器"><a href="#1-3-ID选择器" class="headerlink" title="1.3 ID选择器"></a>1.3 ID选择器</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*匹配所有objectName为btnOK的实例*/</span><span class="token selector">*#btnOK</span> <span class="token punctuation">{</span><span class="token property">font-weight</span><span class="token punctuation">:</span>bold<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*和*#btnOK一样，匹配所有objectName为btnOK的实例*/</span><span class="token selector">#btnOK</span> <span class="token punctuation">{</span><span class="token property">font-weight</span><span class="token punctuation">:</span>bold<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*匹配所有objectName为btnOK的QPushButton实例*/</span><span class="token selector">QPushButton#btnOK</span> <span class="token punctuation">{</span><span class="token property">font-weight</span><span class="token punctuation">:</span>bold<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4-属性选择器"><a href="#1-4-属性选择器" class="headerlink" title="1.4 属性选择器"></a>1.4 属性选择器</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*匹配包含flat属性的所有实例*/</span><span class="token selector">*[flat]</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*匹配包含flat属性的所有QPushButton的实例*/</span><span class="token selector">QPushButton[flat]</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*匹配flat属性为true的所有QPushButton的实例*/</span><span class="token selector">QPushButton[flat="true"]</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*匹配falt属性为true且default属性为false的所有QPushButton的实例*/</span><span class="token selector">QPushButton[flat="true"][default="false"]</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-5-后代选择器"><a href="#1-5-后代选择器" class="headerlink" title="1.5 后代选择器"></a>1.5 后代选择器</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*匹配属于QDialog后代（孩子，孙子等）的QPushButton所有实例*/</span><span class="token selector">QDialog QPushButton</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-6-子元素选择器"><a href="#1-6-子元素选择器" class="headerlink" title="1.6 子元素选择器"></a>1.6 子元素选择器</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*匹配属于QDialog直接子类的QPushButton所有实例*/</span><span class="token selector">QDialog &gt; QPushButton</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-7-伪状态"><a href="#1-7-伪状态" class="headerlink" title="1.7 伪状态"></a>1.7 伪状态</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*匹配hover状态的所有QPushButton的实例*/</span><span class="token selector">QPushButton:hover</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> white <span class="token punctuation">}</span><span class="token comment">/*匹配同时为hover和enabled状态的所有QPushButton的实例*/</span><span class="token selector">QPushButton:hover:enabled</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> white <span class="token punctuation">}</span><span class="token comment">/*匹配不为hover状态的所有QPushButton的实例*/</span><span class="token selector">QRadioButton:!hover</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> red <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-8-子控件选择器"><a href="#1-8-子控件选择器" class="headerlink" title="1.8 子控件选择器"></a>1.8 子控件选择器</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">QRadioButton::indicator::unchecked:disabled</span> <span class="token punctuation">{</span>    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>:/qss/radiobutton_unchecked_disable.png<span class="token punctuation">)</span></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="二、选择器优先级"><a href="#二、选择器优先级" class="headerlink" title="二、选择器优先级"></a>二、选择器优先级</h1><p>一句话归纳为：<strong>优先使用更具体的选择器。</strong></p><p>具体实例如下：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*QPushButton#okButton选择器比QPushButton更具体，所以选择QPushButton#okButton*/</span><span class="token selector">QPushButton#okButton</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> gray <span class="token punctuation">}</span><span class="token selector">QPushButton</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> red <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*如下2个规则应用于QPushButton实例时：因为QPushButton继承QAbstractButton，所以QPushButton比QAbstractButton更具体，选择QPushButton*/</span><span class="token selector">QPushButton</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> red <span class="token punctuation">}</span><span class="token selector">QAbstractButton</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> gray <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*指定伪状态比不指定伪状态的选择器更具体，所以当鼠标悬停时选择QPushButton:hover，否则选择QPushButton*/</span><span class="token selector">QPushButton:hover</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> white <span class="token punctuation">}</span><span class="token selector">QPushButton</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> red <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*如下2个规则应用于处于Enabled状态的QPushButton实例时：鼠标悬停时，QPushButton:hover更能具体描述当前状态，所以选择QPushButton:hover其他时候选择QPushButton:enabled*/</span><span class="token selector">QPushButton:enabled</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">}</span><span class="token selector">QPushButton:hover</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*如下2个规则应用于处于Enabled状态的QPushButton实例时：鼠标悬停时，QPushButton:enabled:hover更能具体描述当前状态，所以选择QPushButton:enabled:hover其他时候选择QPushButton:enabled*/</span><span class="token selector">QPushButton:enabled</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">}</span><span class="token selector">QPushButton:hover</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">}</span><span class="token selector">QPushButton:enabled:hover</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、QSS支持的类型、属性、伪状态、子控件"><a href="#三、QSS支持的类型、属性、伪状态、子控件" class="headerlink" title="三、QSS支持的类型、属性、伪状态、子控件"></a>三、QSS支持的类型、属性、伪状态、子控件</h1><p>关于QSS支持哪些类型、每种类型支持哪些属性、伪状态和子控件，在Qt的官方的英文文档中有详细的介绍：<br><a href="https://doc.qt.io/qt-5/stylesheet-reference.html">《Qt Style Sheets Reference》</a></p><h1 id="四、盒子模型"><a href="#四、盒子模型" class="headerlink" title="四、盒子模型"></a>四、盒子模型</h1><p>在使用QSS设置样式时，有一个关键的概念需要知晓，那就是“盒子模型”（即<code>Box Model</code>）。<br><img src="https://static.1key.run/blog/img/qss-jbsyff-1.png"></p><p>每个Widget都被视为具有4个同心矩形的框：<br><code>MARGIN矩形</code>、<code>BORDER矩形</code>、<code>PADDING矩形</code>和<code>CONTENT矩形</code>，上图标注了每个矩形的区域。</p><p>默认情况下<code>MARGIN矩形</code>、<code>BORDER矩形</code>、<code>PADDING矩形</code>的宽度都为0，这样在默认情况下，4个矩形就重合为1个<code>CONTENT矩形</code>了。</p><p>同样，默认情况下<code>background-image</code>指定的背景，只在border内的区域绘制。但我们要也可以使用<code>background-clip</code>或<code>background-origin</code>属性来更改这种默认行为。</p><p><strong>如何实现背景图像随Widget大小自动缩放？</strong><br>background-image指定的背景图像无法随Widget大小自动缩放，要提供可以随Widget大小缩放的背景图像可以使用<code>border-image</code>和<code>image</code>属性，二者区别如下：</p><ul><li>border-image属性指定的图像从border及其内的区域开始绘制，会导致border属性被覆盖。</li><li>image属性指定的图像从绘制到content区域内，image指定的url为SVG图像，则支持自动缩放，非SVG图像仅支持自动缩小。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QSS的几种图片设置方法</title>
      <link href="/2023/06/25/qss-de-ji-chong-tu-pian-she-zhi-fang-fa/"/>
      <url>/2023/06/25/qss-de-ji-chong-tu-pian-she-zhi-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>大家在使用QSS进行图片设置时，也许被<code>image</code>, <code>border-image</code>, <code>background-image</code>这几个属性困扰过。比如他们之间有什么区别，什么时候该用哪个属性来设置等等。本文就来讲解一下这个几个属性的异同点。</p><h1 id="一、background-image"><a href="#一、background-image" class="headerlink" title="一、background-image"></a>一、background-image</h1><p><code>background-image</code>按图片实际尺寸显示图片，超过控件显示区域的部分会被裁剪掉，虽能显示SVG，但无法对SVG进行无损缩放；</p><p>关于<code>background-image</code>的几个附属属性的作用，可以一句话概括为：<br><strong>从</strong>**<code>background-origin</code><strong><strong>区域的</strong></strong><code>background-position</code><strong><strong>位置开始绘制图像，并以</strong></strong><code>background-repeat</code><strong><strong>方式进行重复；最后将图像</strong></strong><code>background-clip</code>**<strong>区域以外的范围裁剪掉（即不显示）。</strong></p><h1 id="二、image"><a href="#二、image" class="headerlink" title="二、image"></a>二、image</h1><p>按<strong>图片原长宽比</strong>来缩放图片，保证填充满控件content区域，支持SVG矢量图显示和无损缩放;</p><p>image可以使用<code>image-position</code>来指定图片开始显示的位置（参考上面<code>background-position</code>）。</p><h1 id="三、border-image"><a href="#三、border-image" class="headerlink" title="三、border-image"></a>三、border-image</h1><p>按<strong>控件border区域的长宽比</strong>来缩放图片，保证填充满控件border区域，支持SVG矢量图显示和无损缩放;</p><h1 id="四、绘制顺序"><a href="#四、绘制顺序" class="headerlink" title="四、绘制顺序"></a>四、绘制顺序</h1><p>如果在一个控件中同时指定<code>background-image</code>，<code>border-image</code>，<code>image</code>这三个属性，会按照如下的顺序进行绘制：</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">先绘制 background-image然后 border-image最后 image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="五、示例"><a href="#五、示例" class="headerlink" title="五、示例"></a>五、示例</h1><pre class="line-numbers language-CSS" data-language="CSS"><code class="language-CSS">QPushButton#pushButton4 {  border: 20px solid rgba(0,0,255,0.5);  padding: 20px;  margin: 20px;  background-image: url(:/QssUsage/Image/头像.png); /*下图中的圆形头像*/  background-origin: margin;  background-position:top left;  background-repeat:repeat-x;  background-clip: margin;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://static.1key.run/blog/img/qss-sztp-1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Windows内存体系》专栏</title>
      <link href="/2023/06/25/windows-nei-cun-ti-xi-zhuan-lan/"/>
      <url>/2023/06/25/windows-nei-cun-ti-xi-zhuan-lan/</url>
      
        <content type="html"><![CDATA[<p>力求全面的介绍在Ring3层开发过程中需要了解的Windows内存体系方面的知识。</p><p>文章列表：</p><ul><li><a href="/2023/06/20/windows-nei-cun-ti-xi-1-xu-ni-di-zhi-kong-jian/" title="Windows内存体系(1)--虚拟地址空间">Windows内存体系(1)--虚拟地址空间</a></li><li><a href="/2023/06/20/windows-nei-cun-ti-xi-2-xu-ni-nei-cun/" title="Windows内存体系(2)--虚拟内存">Windows内存体系(2)--虚拟内存</a></li><li><a href="/2023/06/20/windows-nei-cun-ti-xi-3-nei-cun-ying-she-wen-jian/" title="Windows内存体系(3)--内存映射文件">Windows内存体系(3)--内存映射文件</a></li><li><a href="/2023/06/20/windows-nei-cun-ti-xi-4-nei-cun-dui-qi/" title="Windows内存体系(4)--内存对齐">Windows内存体系(4)--内存对齐</a></li><li><a href="/2023/06/20/windows-nei-cun-ti-xi-5-dui/" title="Windows内存体系(5)--堆">Windows内存体系(5)--堆</a></li><li><a href="/2023/06/20/windows-nei-cun-ti-xi-6-kua-mo-kuai-nei-cun-fen-pei-shi-fang/" title="Windows内存体系(6)--跨模块内存分配释放">Windows内存体系(6)--跨模块内存分配释放</a></li><li><a href="/2023/06/20/windows-nei-cun-ti-xi-7-shi-yong-std-string-kua-mt-mo-kuai-chuan-can/" title="Windows内存体系(7)--使用std::string跨MT模块传参">Windows内存体系(7)--使用std::string跨MT模块传参</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟内存 </tag>
            
            <tag> 内存对齐 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++实现编译时断言</title>
      <link href="/2023/06/21/c-shi-xian-bian-yi-shi-duan-yan/"/>
      <url>/2023/06/21/c-shi-xian-bian-yi-shi-duan-yan/</url>
      
        <content type="html"><![CDATA[<p>C++自C++11起支持static_assert编译时断言，如：</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">static_assert ( bool_constexpr , message )(C++11 起)static_assert ( bool_constexpr )(C++17 起)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>若编译器不支持C++11（经测试VS2010已经支持<code>static_assert</code>），可以使用下面方式来实现编译断言：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#define COMPILE_ASSERT(expression) switch (0) {case 0: case expression:;}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用方法：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">COMPILE_ASSERT(1 != 1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译断言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++默认构造函数</title>
      <link href="/2023/06/21/c-mo-ren-gou-zao-han-shu/"/>
      <url>/2023/06/21/c-mo-ren-gou-zao-han-shu/</url>
      
        <content type="html"><![CDATA[<p>本文围绕3个问题来理解C++的默认构造函数：</p><ol><li>什么是默认构造函数？</li><li>默认构造函数什么时候被调用？</li><li>编译器在什么情况下会生成默认构造函数？</li></ol><h2 id="一-什么是默认构造函数？"><a href="#一-什么是默认构造函数？" class="headerlink" title="一. 什么是默认构造函数？"></a>一. 什么是默认构造函数？</h2><p>我们一般会认为默认构造函数就是编译器自动生成的那个构造函数，其实这种理解不全面。<br><strong>准确的说，默认构造函数就是在调用时不需要显示地传入实参的构造函数。</strong></p><p>根据这个原则，下面2种构造函数都是默认构造函数：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">class Sample {public:// 默认构造函数。Sample() {// do something}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">class Sample {public:// 默认构造函数。虽然有形参，但有默认值，调用的时候可以不显示的传入实参。Sample(int m = 10) {// do something}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二-默认构造函数什么时候被调用？"><a href="#二-默认构造函数什么时候被调用？" class="headerlink" title="二. 默认构造函数什么时候被调用？"></a>二. 默认构造函数什么时候被调用？</h2><p>如果定义一个对象时没有使用初始化式，编译器就会使用默认构造函数。如：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">Sample s;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三-编译器在什么情况下会生成默认构造函数？"><a href="#三-编译器在什么情况下会生成默认构造函数？" class="headerlink" title="三. 编译器在什么情况下会生成默认构造函数？"></a>三. 编译器在什么情况下会生成默认构造函数？</h2><p>有一句很经典的话可以用来回答这个问题：<strong>惟有默认构造函数被编译器需要的时候，编译器才会生成默认构造函数。</strong></p><p>那我们只需知道什么时候“被编译器需要”，就可以知道什么情况下会生成默认构造函数了。</p><p>下面几种情况下，编译需要生成默认构造函数：</p><ol><li>当该类的<code>类对象数据成员</code>有默认构造函数时。</li><li>当该类的基类有默认构造函数时。</li><li>当该类的基类为虚基类时。</li><li>当该类有虚函数时。</li></ol><h2 id="四-注意事项"><a href="#四-注意事项" class="headerlink" title="四. 注意事项"></a>四. 注意事项</h2><h3 id="4-1-避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在"><a href="#4-1-避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在" class="headerlink" title="4.1 避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在"></a>4.1 避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在</h3><p><code>无参数的默认构造函数</code>和<code>带缺省参数的默认构造函数</code>同时存在时，编译器会产生二义性，从而生成编译错误。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">class Sample {public:// 默认构造函数Sample() {// do somethingprintf("Sample()");}// 默认构造函数Sample(int m = 10) {// do somethingprintf("Sample(int m = 10)");}};int main(){Sample s; // error C2668: “Sample::Sample”: 对重载函数的调用不明确    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-不应在对象名后面加上括号"><a href="#4-2-不应在对象名后面加上括号" class="headerlink" title="4.2 不应在对象名后面加上括号"></a>4.2 不应在对象名后面加上括号</h3><p>使用无参构造函数创建对象时，不应在对象名后面加上括号，否则会产生编译警告</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为编译器误认为<code>Sample s();</code>语句时要声明返回值为<code>Sample</code>对象的函数<code>s</code>，而又没找到函数<code>s</code>的定义，所以产生了警告。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">class Sample {public:// 默认构造函数Sample() {// do somethingprintf("Sample()");}};int main(){Sample s(); // warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?)    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从汇编的角度分析函数调用过程</title>
      <link href="/2023/06/21/cong-hui-bian-de-jiao-du-fen-xi-han-shu-diao-yong-guo-cheng/"/>
      <url>/2023/06/21/cong-hui-bian-de-jiao-du-fen-xi-han-shu-diao-yong-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-函数参数传递形式"><a href="#一、-函数参数传递形式" class="headerlink" title="一、 函数参数传递形式"></a>一、 函数参数传递形式</h2><p>函数的参数传递有2种方式：</p><ul><li>堆栈方式</li><li>寄存器方式</li></ul><p>如果是堆栈方式传递的，就需要定义函数参数在堆栈中的传递顺序，并约定函数被调用之后，由谁来平衡堆栈；<br>如果是寄存器方式传递的，就需要确定参数存放在哪个寄存器中。<br>每一种方式都有其优缺点，而且与使用的编程语言有关系，不存在哪种方式好与坏。</p><p>我们在开发中经常遇到<code>调用约定类型</code>，如<code>__cdecl</code>、<code>stdcall</code>、<code>PASCAL</code>、<code>fastcall</code>。这些调用约定类型就用来指定函数参数的传递方式的。上面几种约定类型，除了<code>fastcall</code>是使用寄存器方式传递参数外，其他的都是使用堆栈传递参数的。</p><blockquote><p>Visual Studio中的C++工程，可以<code>C++</code> –&gt; <code>高级</code> –&gt; <code>调用约定</code>中进行调用约定的设置：<br><img src="https://static.1key.run/blog/img/hbfxhsdy-1.png"></p></blockquote><h2 id="二、使用堆栈方式传递函数参数"><a href="#二、使用堆栈方式传递函数参数" class="headerlink" title="二、使用堆栈方式传递函数参数"></a>二、使用堆栈方式传递函数参数</h2><p>堆栈是一种“后进先出”的数据结构，<code>ESP</code>寄存器始终指向栈顶。栈中数据地址从底部到顶部依次减小，也就是说，栈底对应高地址，栈顶对应低地址。</p><p>调用函数时，调用者依次把参数压栈，然后调用函数，函数被调用之后，在堆栈中取得参数数据。函数调用结束以后，堆栈需要恢复到函数调用之前的样子，而到底是由调用者来恢复还是由函数自身来恢复，根据不同的调用约定类型采用不同的方式。</p><table><thead><tr><th>约定类型</th><th>__cdecl</th><th>stdcall</th><th>PASCAL</th><th>fastcall</th></tr></thead><tbody><tr><td><strong>参数传递顺序</strong></td><td>从右到左</td><td>从右到左</td><td>从左到右</td><td>使用寄存器</td></tr><tr><td><strong>堆栈平衡者</strong></td><td>调用者</td><td>函数自身</td><td>函数自身</td><td>函数自身</td></tr></tbody></table><p><code>__cdcel</code>是C/C++/MFC程序默认的调用约定。<br><code>stdcall</code>是绝大多数Win32 API函数的约定方式，也有少部分使用<code>__cdcel</code>约定方式（如wsprintf等）。<br>在Windows C/C++开发中常用的就是<code>__cdecl</code>和<code>stdcall</code>这2种调用约定。</p><p>按照不同的<code>调用约定</code>来调用函数<code>int add(int a, int b)</code>。从调用者的视角来看，其汇编代码分别表示如下：</p><p><strong>__cdecl</strong></p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">push b     ;参数按从右到左传递push acall addadd esp, 8 ;调用者在函数外部平衡堆栈<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>stdcall</strong></p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">push b     ;参数按从右到左传递push acall add   ;函数自己内部平衡堆栈，调用者不需要平衡堆栈<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在函数调用过程中，参数入栈的过程如图：<br><img src="https://static.1key.run/blog/img/hbfxhsdy-2.png"></p><p>上图中，<code>EBP</code>和<code>函数返回地址ret</code>都是32位地址。因为函数调用完之后会将<code>EBP</code>恢复为暂存在堆栈中的原<code>EBP</code>值，所以从调用者角度来看，在函数的一次调用过程中<code>EBP</code>是不会变化的。</p><p>我们可以在函数中通过新的<code>EBP</code>获取函数各个参数的值：</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">参数a = EBP + 0x8参数b = EBP + 0xC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="三、调用过程分析"><a href="#三、调用过程分析" class="headerlink" title="三、调用过程分析"></a>三、调用过程分析</h2><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;stdio.h&gt;int add(int a, int b) {int c = 0;c = a + b;return c;}int main(){int r = add(1, 2);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用<code>Visual Studio 2017</code>编译上面代码，并在在工程配置中将函数调用约定设置为<code>__cdecl</code>。</p><p>在程序调试过程中，可以在<code>Visual Studio</code>的<code>反汇编窗口</code>中看到C++代码对应的汇编代码，以及<code>寄存器</code>窗口中看到各个寄存器的值。</p><p><code>main</code>函数的反汇编代码如下：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">int main(){00DD1720  push        ebp          // 参见add函数中关于这一部分的解析00DD1721  mov         ebp,esp  00DD1723  sub         esp,0CCh00DD1729  push        ebx  00DD172A  push        esi  00DD172B  push        edi  00DD172C  lea         edi,[ebp-0CCh]  00DD1732  mov         ecx,33h  00DD1737  mov         eax,0CCCCCCCCh  00DD173C  rep stos    dword ptr es:[edi]  int r = add(1, 2);        00DD173E  push        2                 // 参数b入栈00DD1740  push        1                 // 参数a入栈00DD1742  call        add (0DD1276h)    // 调用add函数。CALL指令相当于执行一条PUSH指令加一条JMP指令，PUSH指令用于压入该指令的下一条指令地址到栈中，用于执行完子函数之后返回来。JMP指令用于跳转到子函数所在位置开始执行子函数。00DD1747  add         esp,8            // 因为是__cdecl，所以由调用者来平衡堆栈.00DD174A  mov         dword ptr [r],eax      return 0;00DD174D  xor         eax,eax  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行进入<code>add</code>函数后，<code>add</code>函数内的汇编代码如下：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">int add(int a, int b) {00DD16D0  push        ebp      // ebp入栈，相当于暂存ebp的值00DD16D1  mov         ebp,esp  // 将esp赋值给ebp，在该函数之后的执行过程中不会再改变ebp的值。00DD16D3  sub         esp,0CCh // 在栈上分配0xCC大小的局部变量存储区域00DD16D9  push        ebx      // 暂存ebx00DD16DA  push        esi      // 暂存esi00DD16DB  push        edi      // 暂存edi00DD16DC  lea         edi,[ebp-0CCh]  //下面4行代码（含该条）实现将0xCC大小的局部变量存储区域全部赋值为0xCC00DD16E2  mov         ecx,33h         // ecx存储循环次数，结合rep指令使用。为什么是0x33次了？因为是按照4个字节赋值的，0x33 * 0x4 = 0xCC00DD16E7  mov         eax,0CCCCCCCCh00DD16EC  rep stos    dword ptr es:[edi]  // 循环赋值int c = 0;00DD16EE  mov         dword ptr [c],0     // 将局部变量c赋值为0c = a + b;00DD16F5  mov         eax,dword ptr [a]  00DD16F8  add         eax,dword ptr [b]  00DD16FB  mov         dword ptr [c],eax  return c;00DD16FE  mov         eax,dword ptr [c]  // 将结果存储到eax中。在函数调用中返回结果都是存储在eax中的。}01191701  pop         edi  // 将edi的值还原到函数调用前01191702  pop         esi  // 将esi的值还原到函数调用前01191703  pop         ebx  // 将ebx的值还原到函数调用前01191704  mov         esp,ebp  // 移动栈顶到ebp位置，从而跳过了局部变量存储区域01191706  pop         ebp      // 将ebp的值还原到函数调用前01191707  ret                  // ret指令等同于：弹出此时栈顶的值给eip，                               // 因为此时栈顶存储的刚好是函数返回地址，所以相当于将返回地址赋值给eip，从而实现了返回到函数调用的地方。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面代码的注释中已经包含了详细的解释，特别值得注意的几个地方是：</p><ol><li><code>rep stos    dword ptr es:[edi]</code>结合<code>edi</code>, <code>ecx</code>来初始化局部存储区域。</li><li>函数<code>call</code>指令之前的参数压栈顺序。</li><li><code>CALL</code>指令相当于执行一条<code>PUSH</code>指令加一条<code>JMP</code>指令，<code>PUSH</code>指令用于压入该指令的下一条指令地址到栈中，用于执行完子函数之后返回来。<code>JMP</code>指令用于跳转到子函数所在位置开始执行子函数。</li><li>因为是<code>__cdecl</code>，函数调用完之后，调用方使用<code>add         esp,8</code>来平衡堆栈。</li><li><code>ret</code>指令等同于：弹出此时栈顶的值给eip，巧妙之处在于此时栈顶存储的刚好是函数返回地址。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows程序如何删除自身</title>
      <link href="/2023/06/21/windows-cheng-xu-ru-he-shan-chu-zi-shen/"/>
      <url>/2023/06/21/windows-cheng-xu-ru-he-shan-chu-zi-shen/</url>
      
        <content type="html"><![CDATA[<p>本文介绍几种实现在程序退出后，从磁盘删除自身exe文件的方式。该技术通常应用于安装包卸载程序中。</p><h2 id="一、借用choice命令实现"><a href="#一、借用choice命令实现" class="headerlink" title="一、借用choice命令实现"></a>一、借用choice命令实现</h2><p>Windows提供了choice命令，允许用户从选择列表选择一个项目并返回所选项目的索引。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">C:\Users\akx&gt;choice /?CHOICE [/C choices] [/N] [/CS] [/T timeout /D choice] [/M text]描述:    该工具允许用户从选择列表选择一个项目并返回所选项目的索引。参数列表:   /C    choices       指定要创建的选项列表。默认列表是 "YN"。   /N                  在提示符中隐藏选项列表。提示前面的消息得到显示，                       选项依旧处于启用状态。   /CS                 允许选择分大小写的选项。在默认情况下，这个工具                       是不分大小写的。   /T    timeout       做出默认选择之前，暂停的秒数。可接受的值是从 0                       到 9999。如果指定了 0，就不会有暂停，默认选项                       会得到选择。   /D    choice        在 nnnn 秒之后指定默认选项。字符必须在用 /C 选                       项指定的一组选择中; 同时，必须用 /T 指定 nnnn。   /M    text          指定提示之前要显示的消息。如果没有指定，工具只                       显示提示。示例:   CHOICE /?   CHOICE /C YNC /M "确认请按 Y，否请按 N，或者取消请按 C。"   CHOICE /T 10 /C ync /CS /D y   CHOICE /C ab /M "选项 1 请选择 a，选项 2 请选择 b。"   CHOICE /C ab /N /M "选项 1 请选择 a，选项 2 请选择 b。"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现方式如下：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">bool DeleteSelf {    wchar_t szSystemDir[MAX_PATH] = {0};    if (GetSystemDirectoryW(szSystemDir, MAX_PATH) &gt; 0) {        PathAddBackslashW(szSystemDir);    }    wchar_t szFullCmd[MAX_PATH] = {0};    StringCchPrintfW(szFullCmd, MAX_PATH, L"%scmd.exe /C choice /C Y /N /D Y /T 4 &amp; rmdir \"%s\" /Q",                    szSystemDir, szPath);    STARTUPINFOW si = {sizeof(STARTUPINFOW)};    PROCESS_INFORMATION pi;    if (CreateProcessW(NULL, szFullCmd, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, szSystemDir, &amp;si,                        &amp;pi)) {        if (pi.hThread)            CloseHandle(pi.hThread);        if (pi.hProcess)            CloseHandle(pi.hProcess);        return true;    }    return false;}int main() {   bool ret = DeleteSelf();   return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、使用计划任务实现"><a href="#二、使用计划任务实现" class="headerlink" title="二、使用计划任务实现"></a>二、使用计划任务实现</h2><p>在程序退出前添加Windows计划任务，计划任务在程序退出几秒后执行删除文件的操作。</p><p><strong>这种实现方式需要程序具有管理员权限。</strong></p><p>此处省略具体的实现方式。</p>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> choice </tag>
            
            <tag> 计划任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++标准库线程的启动与退出</title>
      <link href="/2023/06/21/c-biao-zhun-ku-xian-cheng-de-qi-dong-yu-tui-chu/"/>
      <url>/2023/06/21/c-biao-zhun-ku-xian-cheng-de-qi-dong-yu-tui-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="一、std-thread"><a href="#一、std-thread" class="headerlink" title="一、std::thread"></a>一、std::thread</h1><p>std::thread未提供判断线程是否结束的方法。</p><p>如果线程未进行detach且此时该线程处理joinable状态，析构该线程对象会触发异常。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;iostream&gt;#include &lt;thread&gt;std::thread Thread1() {    std::thread t = std::thread([]() {        std::this_thread::sleep_for(std::chrono::milliseconds(1000));    });    return t;}int main(){    std::thread t1 = Thread1();    t1.join(); //等待线程结束    std::thread t2 = std::thread([]() {        std::this_thread::sleep_for(std::chrono::milliseconds(1000));    });    std::cout &lt;&lt; "thread id:" &lt;&lt; t2.get_id() &lt;&lt; std::endl;    std::cout &lt;&lt; "joinable:" &lt;&lt; t2.joinable() &lt;&lt; std::endl; // 1    t2.detach();    std::cout &lt;&lt; "joinable:" &lt;&lt; t2.joinable() &lt;&lt; std::endl; // 0    std::this_thread::sleep_for(std::chrono::milliseconds(2000));        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、std-async"><a href="#二、std-async" class="headerlink" title="二、std::async"></a>二、std::async</h1><p>通过<code>std::async</code>可以判断线程是否结束运行。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;iostream&gt;#include &lt;future&gt;int main(){    std::future&lt;void&gt; f = std::async(std::launch::async, []() {        std::this_thread::sleep_for(std::chrono::milliseconds(1000));    });    bool isRunning = f.valid() &amp;&amp; f.wait_for(std::chrono::milliseconds(0)) == std::future_status::timeout;    std::cout &lt;&lt; isRunning &lt;&lt; std::endl;    f.wait();    isRunning = f.valid() &amp;&amp; f.wait_for(std::chrono::milliseconds(0)) == std::future_status::timeout;    std::cout &lt;&lt; isRunning &lt;&lt; std::endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-1-判断std-future是否结束"><a href="#2-1-判断std-future是否结束" class="headerlink" title="2.1 判断std::future是否结束"></a>2.1 判断std::future是否结束</h2><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">bool isRunning = f.valid() &amp;&amp;                  f.wait_for(std::chrono::milliseconds(0)) == std::future_status::timeout;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-2-std-shared-future"><a href="#2-2-std-shared-future" class="headerlink" title="2.2 std::shared_future"></a>2.2 std::shared_future</h2><p><code>std::future</code>不支持赋值构造，需要使用<code>std::shared_future</code>。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">std::shared_future&lt;void&gt; f1 = std::async(std::launch::async, []() {       std::this_thread::sleep_for(std::chrono::milliseconds(1000)); });std::shared_future&lt;void&gt; f2 = f1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
            <tag> std::future </tag>
            
            <tag> std::async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLVM-Obfuscator代码混淆</title>
      <link href="/2023/06/21/llvm-obfuscator-dai-ma-hun-yao/"/>
      <url>/2023/06/21/llvm-obfuscator-dai-ma-hun-yao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>LLVM-Obfuscator只能用于混淆代码逻辑.</p></blockquote><h1 id="1-安装VS-Clang组件"><a href="#1-安装VS-Clang组件" class="headerlink" title="1. 安装VS Clang组件"></a>1. 安装VS Clang组件</h1><p><img src="https://static.1key.run/blog/img/LLVM-Obfuscator-1.png"></p><h1 id="2-编译LLVM-Obfuscator"><a href="#2-编译LLVM-Obfuscator" class="headerlink" title="2. 编译LLVM-Obfuscator"></a>2. 编译LLVM-Obfuscator</h1><p>使用heroims的Fork版本：<a href="https://github.com/heroims/obfuscator">heroims/obfuscator</a></p><h2 id="2-1-Clone最新13-x分支"><a href="#2-1-Clone最新13-x分支" class="headerlink" title="2.1 Clone最新13.x分支"></a>2.1 Clone最新13.x分支</h2><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">git clone -b llvm-13.x https://github.com/obfuscator-llvm/obfuscator.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-2-安装mingw"><a href="#2-2-安装mingw" class="headerlink" title="2.2 安装mingw"></a>2.2 安装mingw</h2><p>从<a href="https://github.com/niXman/mingw-builds-binaries/releases">https://github.com/niXman/mingw-builds-binaries/releases</a> 下载32位和64位MingW:</p><ul><li>i686-12.2.0-release-posix-dwarf-msvcrt-rt_v10-rev2.7z</li><li>x86_64-12.2.0-release-posix-seh-msvcrt-rt_v10-rev2.7z</li></ul><p>分别解压到不同的目录。</p><h2 id="2-3-编译64位LLVM-Obfuscator"><a href="#2-3-编译64位LLVM-Obfuscator" class="headerlink" title="2.3 编译64位LLVM-Obfuscator"></a>2.3 编译64位LLVM-Obfuscator</h2><p>打开CMD，将64位MingW的bin目录添加到PATH环境变量：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">SET PATH=%PATH%;C:\mingw64\x86_64-12.2.0-release-posix-seh-msvcrt-rt_v10-rev2\bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在命令行进入LLVM-Obfuscator所在目录，开始编译：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">mkdir build64cd build64cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS="clang" -DLLVM_CREATE_XCODE_TOOLCHAIN=ON -DLLVM_ENABLE_NEW_PASS_MANAGER=OFF -G "MinGW Makefiles" ../llvmmingw32-make.exe -j8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-编译32位LLVM-Obfuscator"><a href="#2-4-编译32位LLVM-Obfuscator" class="headerlink" title="2.4 编译32位LLVM-Obfuscator"></a>2.4 编译32位LLVM-Obfuscator</h2><p>重新打开CMD，将32位MingW的bin目录添加到PATH环境变量：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">SET PATH=%PATH%;C:\mingw32\i686-12.2.0-release-posix-dwarf-msvcrt-rt_v10-rev2\bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在命令行进入LLVM-Obfuscator所在目录，开始编译：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">mkdir build32cd build32cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS="clang" -DLLVM_CREATE_XCODE_TOOLCHAIN=ON -DLLVM_ENABLE_NEW_PASS_MANAGER=OFF -G "MinGW Makefiles" ../llvmmingw32-make.exe -j8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-用编译输出覆盖到VS-Clang"><a href="#3-用编译输出覆盖到VS-Clang" class="headerlink" title="3. 用编译输出覆盖到VS Clang"></a>3. 用编译输出覆盖到VS Clang</h1><p>Visual Studio的Clang位于<code>C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\Llvm</code>目录，分别将编译的32位和64位<code>bin</code>目录中的文件覆盖到VS Clang的<code>bin</code>目录中（注意：在覆盖之前，最好先备份）。</p><h1 id="4-设置环境变量"><a href="#4-设置环境变量" class="headerlink" title="4. 设置环境变量"></a>4. 设置环境变量</h1><p>在编译完之后，将32位和64位MingW的<code>bin</code>目录路径都添加到PATH环境变量中。因为VS编译时会启动clang.exe，而clang.exe需要依赖MingW。</p><h1 id="5-VS工程配置"><a href="#5-VS工程配置" class="headerlink" title="5. VS工程配置"></a>5. VS工程配置</h1><p><img src="https://static.1key.run/blog/img/LLVM-Obfuscator-2.png"></p><p><img src="https://static.1key.run/blog/img/LLVM-Obfuscator-3.png"></p><p>命令行其他选项如下：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">-D__CUDACC__ -D_ALLOW_COMPILER_AND_STL_VERSION_MISMATCH -mllvm -bcf -mllvm -bcf_prob=73 -mllvm -bcf_loop=1 -mllvm -sub -mllvm -sub_loop=5 -mllvm -fla -mllvm -split_num=5 -mllvm -aesSeed=DEADBEEFDEADCODEDEADBEEFDEADCODE <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="6-混淆配置参数"><a href="#6-混淆配置参数" class="headerlink" title="6. 混淆配置参数"></a>6. 混淆配置参数</h1><h3 id="开启控制流扁平化"><a href="#开启控制流扁平化" class="headerlink" title="开启控制流扁平化"></a>开启控制流扁平化</h3><p><code>-mllvm -fla</code> 开启控制流扁平化</p><p><code>-mllvm -split</code> 激活基本块划分。一起使用时能提高打平能力。</p><p><code>-mllvm -split_num=3</code> 如果激活控制流打平，对每一个基本块应用三次控制流打平。默认使用1次。</p><h3 id="开启指令替换"><a href="#开启指令替换" class="headerlink" title="开启指令替换"></a>开启指令替换</h3><p><code>-mllvm -sub</code> 开启指令替换</p><p><code>-mllvm -sub_loop=3</code> 如果激活了指令替换，使用这个选项在一个函数中应用3次指令替换。默认应用1次。</p><h3 id="开启虚假控制流"><a href="#开启虚假控制流" class="headerlink" title="开启虚假控制流"></a>开启虚假控制流</h3><p><code>-mllvm -bcf</code> 开启虚假控制流。</p><p>  <code>bcf</code>可以配合下面参数使用：</p><p>  <code>-mllvm -bcf_loop=3</code> 设置函数混淆次数为3次 不加此选项默认为1次。</p><p>  <code>-mllvm -bcf_prob=40</code> 设置代码块被混淆的概率是40%，默认30%</p><h1 id="7-CMakeList中配置混淆参数"><a href="#7-CMakeList中配置混淆参数" class="headerlink" title="7. CMakeList中配置混淆参数"></a>7. CMakeList中配置混淆参数</h1><pre class="line-numbers language-CMakeList" data-language="CMakeList"><code class="language-CMakeList">#debug and release all enableSET(CMAKE_CXX_FLAGS "-mllvm -fla -mllvm -sub -mllvm -sobf  ")#so体积优化，（按需开启）#SET(CMAKE_CXX_FLAGS_DEBUG "$ENV{CXXFLAGS}   -O0 -Wall -g2 -ggdb")#SET(CMAKE_CXX_FLAGS_RELEASE "$ENV{CXXFLAGS}  -Os -Wall -s")#设置llvm debug模式混淆编译SET(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -mllvm -fla")SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -mllvm -fla")#设置llvm release模式混淆编译SET(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -mllvm -fla -mllvm -sub -mllvm -bcf")SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -mllvm -fla -mllvm -sub -mllvm -bcf")SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -s -O3 -Wall -fvisibility=hidden  -mllvm -fla")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码混淆 </tag>
            
            <tag> LLVM-Obfuscator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译器基础概念</title>
      <link href="/2023/06/21/bian-yi-qi-ji-chu-gai-nian/"/>
      <url>/2023/06/21/bian-yi-qi-ji-chu-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、C-代码编译流程"><a href="#一、C-代码编译流程" class="headerlink" title="一、C++代码编译流程"></a>一、C++代码编译流程</h2><p>以下面C++代码为例：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;stdio.h&gt;​int main(){    printf("Hello World");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译成二进制文件需要经过如下4个过程：</p><ul><li><strong>预编译</strong>：将hello.c和stdio.h预编译为hello.i</li><li><strong>编译</strong>：将hello.i编译为hello.s</li><li><strong>汇编</strong>：将hello.s翻译为机器指令hello.o（.o目标文件）</li><li><strong>链接</strong>：链接各种需要的库和其他目标文件（该hello程序不需要）得到可执行文件hello.out（相当于windows的.exe）。</li></ul><h2 id="二、编译器架构"><a href="#二、编译器架构" class="headerlink" title="二、编译器架构"></a>二、编译器架构</h2><p>编译器通常分为三个部分：</p><ul><li>前端（FrontEnd）</li><li>优化器（Optimizer）</li><li>后端（BackEnd）</li></ul><p>在编译过程中，前端主要负责词法和语法分析，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。</p><h3 id="2-1-GCC"><a href="#2-1-GCC" class="headerlink" title="2.1 GCC"></a>2.1 GCC</h3><p>GCC(GNU Compiler Collection，GNU编译器集合)是一个完整的编译器，包含FrontEnd、Optimizer和BackEnd。</p><h3 id="2-2-LLVM架构"><a href="#2-2-LLVM架构" class="headerlink" title="2.2 LLVM架构"></a>2.2 LLVM架构</h3><p><code>Clang</code>是LLVM编译器架构的前端，可以用来编译 C，C++，ObjectiveC 等语言；</p><p><code>LLVM</code>是该架构的优化器和后端；</p><p>二者统称为LLVM架构。</p><p><img src="https://static.1key.run/blog/img/bianyiiqijichugailian-1.png"></p><h2 id="三、编译版本选择"><a href="#三、编译版本选择" class="headerlink" title="三、编译版本选择"></a>三、编译版本选择</h2><h3 id="3-1-x86、x86-64、AMD64"><a href="#3-1-x86、x86-64、AMD64" class="headerlink" title="3.1 x86、x86-64、AMD64"></a>3.1 x86、x86-64、AMD64</h3><p>x86是指Intel的开发的一种32位指令集，从386时代开始，一直沿用至今，所有Intel早期的cpu，以及amd早期的cpu都支持这种指令集。</p><p>AMD领先Intel制造出兼容x86的商用CPU，AMD称之为AMD64，且得到用户的认同。</p><p>Intel选择设计了一种不兼容x86的全新64位指令集，称之为IA-64。由于是全新设计的CPU，没有编译器、不支持Windows，后来不得不在时机落后的情况下也开始支持AMD64指令集。因此换了个名字叫x86_64，表示x86指令集的64位扩展。</p><p>x86_64、x64、AMD64基本上是一个东西，我们现在用的intel/amd的桌面级CPU基本上都是x86_64。</p><h3 id="3-2-i386"><a href="#3-2-i386" class="headerlink" title="3.2 i386"></a>3.2 i386</h3><p>i386 即 Intel 80386。 其实i386通常被用来作为对Intel（英特尔）32位微处理器的统称。</p><p>但是目前更多的时候，我们公认i386为32位系统，其实就是x86。</p><h3 id="3-3-i686"><a href="#3-3-i686" class="headerlink" title="3.3 i686"></a>3.3 i686</h3><p>i686 仍然属于 i386 体系，不过相对于386 CPU的特性作了指令优化。</p><h3 id="3-4-MSVC编译器版本"><a href="#3-4-MSVC编译器版本" class="headerlink" title="3.4 MSVC编译器版本"></a>3.4 MSVC编译器版本</h3><ul><li>x86：编译器为x86版本，输出文件为x86。</li><li>amd64_x86：编译器为amd64版本，输出文件为x86。</li><li>amd64：编译器为amd64版本，输出文件为amd64。</li><li>x86_amd64：编译器为x86版本，输出文件为amd64。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译器 </tag>
            
            <tag> LLVM </tag>
            
            <tag> GCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《网络协议》专栏</title>
      <link href="/2023/06/21/wang-luo-xie-yi-zhuan-lan/"/>
      <url>/2023/06/21/wang-luo-xie-yi-zhuan-lan/</url>
      
        <content type="html"><![CDATA[<p>本栏目系统性的介绍了常用的网络协议（如ARP, IP, TCP, UDP, HTTP等），并深入剖析协议的原理。让读者不仅可以知其然，而且可以知其所以然。同时也覆盖面试中的一些常见问题。</p><p>文章列表：</p><ul><li><a href="/2023/06/20/wang-luo-xie-yi-1-ji-chu-gai-nian/" title="网络协议(1)--基础概念">网络协议(1)--基础概念</a></li><li><a href="/2023/06/20/wang-luo-xie-yi-2-arp-he-rarp-xie-yi/" title="网络协议(2)--ARP和RARP协议">网络协议(2)--ARP和RARP协议</a></li><li><a href="/2023/06/20/wang-luo-xie-yi-3-ip-xie-yi/" title="网络协议(3)--IP协议">网络协议(3)--IP协议</a></li><li><a href="/2023/06/21/wang-luo-xie-yi-4-icmp-xie-yi/" title="网络协议(4)--ICMP协议">网络协议(4)--ICMP协议</a></li><li><a href="/2023/06/21/wang-luo-xie-yi-5-udp-xie-yi/" title="网络协议(5)--UDP协议">网络协议(5)--UDP协议</a></li><li><a href="/2023/06/21/wang-luo-xie-yi-6-tcp-xie-yi/" title="网络协议(6)--TCP协议">网络协议(6)--TCP协议</a></li><li><a href="/2023/06/21/wang-luo-xie-yi-7-http-yu-https-xie-yi/" title="网络协议(7)--HTTP与HTTPS协议">网络协议(7)--HTTP与HTTPS协议</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP </tag>
            
            <tag> ICMP </tag>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
            <tag> HTTP(s) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(7)--HTTP与HTTPS协议</title>
      <link href="/2023/06/21/wang-luo-xie-yi-7-http-yu-https-xie-yi/"/>
      <url>/2023/06/21/wang-luo-xie-yi-7-http-yu-https-xie-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一、HTTP协议介绍"><a href="#一、HTTP协议介绍" class="headerlink" title="一、HTTP协议介绍"></a>一、HTTP协议介绍</h1><h2 id="1-1-什么是HTTP"><a href="#1-1-什么是HTTP" class="headerlink" title="1.1 什么是HTTP"></a>1.1 什么是HTTP</h2><p>HTTP是<code>Hyper Text Transfer Protocol</code>（超文本传输协议）的缩写。HTTP协议位于TCP/IP协议栈的应用层。</p><p>HTTP是一个客户端和服务器端请求和应答的标准，主要用于从万维网（即<code>WWW</code>，全称 <code>World Wide Web</code>）服务器传输超文本到本地浏览器之间的请求数据和响应数据的协议。客户端通过使用网页浏览器或者其它的工具发起一个HTTP请求到服务器上指定端口（默认端口为<code>80</code>），服务器在收到请求之后，返回响应内容（文本、图片等）。</p><p>HTTP协议是基于TCP协议来进行数据传输的。</p><h2 id="1-2-HTTP的版本"><a href="#1-2-HTTP的版本" class="headerlink" title="1.2 HTTP的版本"></a>1.2 HTTP的版本</h2><p>HTTP协议已经演化出了很多版本，它们中的大部分都是向下兼容的。客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。现在大多使用的都是<code>1.1</code>版本。</p><ul><li><p><strong>1.0版本：</strong> HTTP 协议非常老的标准，为了提高系统的效率，HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。正式因为这种特性造成了一些性能上的缺陷。</p></li><li><p><strong>1.1版本：</strong> 克服了HTTP 1.0的缺陷，HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。同时还增加更多的请求头和响应头来改进和扩充HTTP 1.0的功能（如POST请求头字段等）。</p></li><li><p><strong>2.0版本：</strong> 2015年5月作为互联网标准正式发布。主要新增如下特性：多路复用，二进制分帧，首部压缩，服务端推送。</p></li></ul><h1 id="二、HTTP消息请求"><a href="#二、HTTP消息请求" class="headerlink" title="二、HTTP消息请求"></a>二、HTTP消息请求</h1><h2 id="2-1-URI、URL、URN"><a href="#2-1-URI、URL、URN" class="headerlink" title="2.1 URI、URL、URN"></a>2.1 URI、URL、URN</h2><p>通过HTTP或者HTTPS协议请求的资源由统一资源标识符（<code>Uniform Resource Identifiers</code>，<code>URI</code>）来标识。我们常用的是URL，那么URI, URL, URN之前有什么区别和联系了？</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">URI = Uniform Resource Identifier 统一资源标识符URL = Uniform Resource Locator    统一资源定位符URN = Universal Resource Name     统一资源名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>三者关系如下图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-http-1.png"></p><p><code>URI</code>用来唯一标识符来标识一个资源，是一个通用的概念，<code>URI</code>由<code>URL</code>和<code>URN</code>两个子集组成。</p><p><code>URL</code>通过描述资源的位置来标识资源。</p><p><code>URN</code>通过资源的名字来标识资源，与其所处的位置无关，这样即使资源的位置发生变动，其<code>URN</code>也不会变化。</p><p>HTTP规范将更通用的概念URI作为其资源标识符，但是实际上，HTTP应用程序处理的只是URI的URL子集.</p><h2 id="2-2-消息请求格式"><a href="#2-2-消息请求格式" class="headerlink" title="2.2 消息请求格式"></a>2.2 消息请求格式</h2><p><img src="https://static.1key.run/blog/img/wangluoxieyi-http-2.png"></p><h2 id="2-3-HTTP常见的请求方法"><a href="#2-3-HTTP常见的请求方法" class="headerlink" title="2.3 HTTP常见的请求方法"></a>2.3 HTTP常见的请求方法</h2><p>HTTP消息请求的第一个字段就是“请求方法”，HTTP 1.1 中定义的几种常见的请求方法如下（<strong>只列出了常用的</strong>）：</p><ul><li>GET<br>向服务器获取数据。使用GET请求方法时，消息Body中没有“请求数据”（见上面消息格式的图）部分，所以将需要提交到服务器的数据放在URL中，因此能够提交到服务器的数据会受到URL长度的限制。<br><img src="https://static.1key.run/blog/img/wangluoxieyi-http-3.png"></li></ul><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT"> 各个浏览器对URL长度的限制如下（这些限制值可能随着浏览器的版本的更新而发生改变，仅供参考）：1. IE浏览器（Microsoft Internet Explorer） 对URL长度限制是2083（2K+53），超过这个限制，则自动截断（若是form提交则提交按钮不起作用）。2. FirefoxFirefox（火狐浏览器）对URL长度限制是65536字符，但实际上有效的URL最大长度不少于100,000个字符。3. Chromechrome对URL长度限制是8182个字符。4. SafariSafari对URL长度限制是80000字符。5. OperaOpera浏览器对URL长度限制是190000 字符。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>POST<br>向服务器提交数据（例如提交表单或者上传文件）。提交的数据包含在Body中。<br><img src="https://static.1key.run/blog/img/wangluoxieyi-http-4.png"></li></ul><h1 id="三、HTTP消息响应"><a href="#三、HTTP消息响应" class="headerlink" title="三、HTTP消息响应"></a>三、HTTP消息响应</h1><h2 id="3-1-消息响应格式"><a href="#3-1-消息响应格式" class="headerlink" title="3.1 消息响应格式"></a>3.1 消息响应格式</h2><p><img src="https://static.1key.run/blog/img/wangluoxieyi-http-5.png"></p><p><img src="https://static.1key.run/blog/img/wangluoxieyi-http-6.png"></p><h2 id="3-2-HTTP状态码"><a href="#3-2-HTTP状态码" class="headerlink" title="3.2 HTTP状态码"></a>3.2 HTTP状态码</h2><p>状态代码由三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">1xx消息—— 请求已被服务器接收，继续处理2xx成功 —— 请求已成功被服务器接收、理解、并接受3xx重定向 —— 需要后续操作才能完成这一请求4xx请求错误 —— 请求含有词法错误或者无法被执行5xx服务器错误 —— 服务器在处理某个正确请求时发生错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常见的状态码有：</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">200 OK                        //客户端请求成功400 Bad Request               //客户端请求有语法错误，不能被服务器所理解401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden                 //服务器收到请求，但是拒绝提供服务404 Not Found                 //请求资源不存在，比如：输入了错误的URL500 Internal Server Error     //服务器发生不可预期的错误503 Server Unavailable        //由于超载或系统维护，服务器暂时的无法处理客户端的请求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关于HTTP状态码的完整定义见：<a href="https://tools.ietf.org/html/rfc2616#page-39">https://tools.ietf.org/html/rfc2616#page-39</a></p></blockquote><h1 id="四、HTTPS之密码学基础"><a href="#四、HTTPS之密码学基础" class="headerlink" title="四、HTTPS之密码学基础"></a>四、HTTPS之密码学基础</h1><h2 id="4-1-对称加密算法"><a href="#4-1-对称加密算法" class="headerlink" title="4.1 对称加密算法"></a>4.1 对称加密算法</h2><p>对称加密算法（英文：<code>Symmetric-key algorithm</code>）是指密码学中的一类加密算法，又称为：私钥加密、共享密钥加密。这类算法在加密和解密时使用相同的<strong>密钥</strong>（或者这2个密钥可以通过简单的规则相互推算）。<br>“对称加密算法”比“非对称加密算法”速度更快，但对称加密算法的主要缺点在于要求加密和解密的双方获取相同的密钥，这样只要密钥被泄漏，则密文将不再安全。</p><p><img src="https://static.1key.run/blog/img/wangluoxieyi-http-7.png"></p><p>常见的对称加密算法有：</p><ul><li>DES: <code>Data Encryption Standard</code>, 数据加密标准，速度较快，适用于加密大量数据的场合。</li><li>3DES: <code>Triple DES</code>, 是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。</li><li>AES: <code>Advanced Encryption Standard</code>, 高级加密标准，是下一代的加密算法标准，速度快，安全级别高。</li><li>Blowfish: 一个64位分组及可变密钥长度的对称密钥分组密码算法，可用来加密64比特长度的字符串。</li><li>IDEA: 在DES算法的基础上发展出来的，密钥为128位。</li><li>RC5</li><li>RC6</li></ul><h2 id="4-2-非对称加密算法"><a href="#4-2-非对称加密算法" class="headerlink" title="4.2 非对称加密算法"></a>4.2 非对称加密算法</h2><p>“非对称加密算法”又称为“公开密钥加密”（英语：<code>public-key cryptography</code>）。也一种密码学算法类型，在这类加密算法中，需要一个“密钥对”，即“私钥”和“公钥”。这两个密钥是数学相关，用某个密钥对的“私钥”加密的信息，只能用该密钥对的“公钥”才能解密。同样，用“公钥”加密的信息，也只能用该密钥对的“私钥”才能解密。</p><p>“私钥”一般都是自己保留，不透露给他人；而“公钥”可以公开给他人。</p><p>“非对称加密算法”比“对称加密算法”安全性更高，不用担心加密密钥的泄漏，因为“公钥”是公开的，不存在泄漏。但“私钥”还是要保存妥当，不能泄露给他人，因为我们不需要在网络上传输“私钥”，所以“私钥”泄露的可能性会小很多。</p><p>但是“非对称加密算法”比“对称加密算法”的运算速度慢很多，一般在数据量比较少的时候采用“非对称加密算法”。</p><p><img src="https://static.1key.run/blog/img/wangluoxieyi-http-8.jpg"></p><p>如上图，因为李四的“公钥”是公开的，所以张三要给李四发送信息，可以使用李四的“公钥”来加密信息。李四收到密文信息之后就可以使用自己的“私钥”来解密信息。因为其他人没有李四的“私钥”，所以就算密文信息被他人截获也无法解密。</p><p>常见的非对称加密算法有：</p><ul><li>RSA: 由RSA公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的。</li><li>DSA: <code>Digital Signature Algorithm</code>, 数字签名算法，是一种标准的 DSS（数字签名标准）。</li><li>ECC: <code>Elliptic Curves Cryptography</code>, 椭圆曲线密码编码学。</li></ul><blockquote><p>非对称算法虽然安全，但运算速度很慢，而对称算法的速度虽快，但在管理和传输密钥方面会存在安全隐患。在实际的操作过程中，我们通常采用的方式是：采用“非对称加密算法”管理“对称加密算法”的密钥，然后用“对称加密算法”加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。</p></blockquote><p><strong>使用OpenSSL生成RSA公私钥对</strong></p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">// 生成1024位的私钥openssl genrsa -out d:\rsa_private.pem 1024// 生成私钥对应的公钥openssl rsa -in d:\rsa_private.pem -pubout -out d:\ca_public.pem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>git客户端安装文件中的提供的<code>ssh-keygen.exe</code>工具也可以用来生产非对称加密的公私钥对。</p><h2 id="4-3-散列函数"><a href="#4-3-散列函数" class="headerlink" title="4.3 散列函数"></a>4.3 散列函数</h2><p>散列函数（英文：<code>Hash Function</code>）是将任意长度的的输入转化为定长输出的算法。编程中对散列函数使用非常普遍，如<code>MD5</code>,但并不是所有的散列函数都适用于密码学。密码学的散列函数必须同时具有如下几个额外的特性：</p><ul><li>单向性：给定一个散列值，无法反向找到或者构造出生成它的消息。</li><li>抗碰撞性：给定一个消息和它的散列值，无法找到具有相同散列值的不同的消息。</li></ul><p>散列函数最常用的场合是以紧凑的方式来唯一表示大量数据，如“数字签名”中用到散列函数生成摘要信息等。</p><p>常见的散列函数：</p><ul><li><code>MD5：</code>1991年对MD4的改进版本，该算法不可逆。2004年王小云等人证明了完全碰撞，在理论上说明MD5可以被完全攻破，2005年，Lenstra等人证明了现实中的碰撞，展示了两张完全不同的证书却拥有同样的MD5散列值。所以，目前<code>MD5</code>已经不安全了。</li><li><code> SHA-1：</code>SHA-1在许多安全协议中广为使用，包括TLS和SSL、PGP、SSH、S/MIME和IPsec，曾被视为是MD5的后继者，但因为在理论在已经证明SHA1可以被破解，但限制于计算机的计算能力所以SHA-1被破解还是很困难，所以SHA-1的安全性如今被密码学家严重质疑。</li><li><code>SHA-256：</code>SHA-224、SHA-256、SHA-384、SHA-512一起并称为SHA-2，至今尚找出对SHA-2有效的破解方法。</li></ul><h1 id="五、数字签名与数字证书"><a href="#五、数字签名与数字证书" class="headerlink" title="五、数字签名与数字证书"></a>五、数字签名与数字证书</h1><h2 id="5-1-数字签名"><a href="#5-1-数字签名" class="headerlink" title="5.1 数字签名"></a>5.1 数字签名</h2><p>数字签名（英文：<code>Digital Signature</code>）类似于我们写在纸上的手写签名，它的诞生主要是为了解决如下问题：</p><ol><li>证明该文件（或信息）是由你发送的。</li><li>证明该文件（或信息）没有被他人篡改过。</li></ol><p>其实，我们生活中手写签名的纸质合同也是通过各种形式达到上面2个效果（如：合同一式多份，每份合同都有双方签名等）。</p><p>数字签名利用了“非对称加密算法”，签名和验证签名的过程如下图（图中的“认证”部分不是数字签名必须的，在“数字证书”部分会介绍）：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-http-9.jpg"></p><p>假设“李四”要发送一份数据给“张三”：<br>发送者“李四”对数据生成摘要信息（<code>摘要明文A</code>），然后使用<code>“李四”的“私钥”</code>加密摘要信息；接收者“张三”收到加密的摘要信息之后：</p><ol><li><p>使用<code>“李四”的“公钥”</code>对加密的摘要信息进行解密。若能解密则证明签名是由“李四”所签，这是因为只有<code>“李四”的“私钥”</code>加密的数据才能由<code>“李四”的“公钥”</code>解密，而又只有“李四”才有<code>“李四”的“私钥”</code>。</p></li><li><p>并将数据使用相同的摘要算法自己也生成一份摘要信息（<code>摘要明文B</code>），然后比较A和B。若两者相等，则证明了该数据内容没有被他人篡改过。</p></li></ol><p>通过上面的过程我们可以知道：</p><ol><li>数字签名具有合法性的前提条件是用于加密散列值的<code>“私钥”</code>没有被泄露。</li><li>数字签名不负责数据的加密，若要防止数据被他人窥视，则还要结合其他手段，如使用接收者的“公钥”对数据进行加密等。</li></ol><blockquote><p>如何获取签名者的公钥？如何保证获得的公钥就是签名者的，而不是他人的？基于这些问题，数字签名需要结合后面介绍的数字证书来使用（也就是上图中的“认证”文件）。</p></blockquote><h2 id="5-2-数字证书"><a href="#5-2-数字证书" class="headerlink" title="5.2 数字证书"></a>5.2 数字证书</h2><p>有了上面的公开密钥算法（也就是“非对称加密算法”）之后，我们就可以通过他人的公开密钥（公钥）与其安全通信了，但是还有一些悬而未决的问题：</p><ul><li>如何获取那些从未谋面的人的公钥？</li><li>如何存储和吊销这些公钥？</li><li>如何确保获取的公钥就是那个人的？</li></ul><p>公钥基础设施（<code>public key infrastructure</code>, 简称<code>KPI</code>）就是为了解决这个问题而建立的。<code>PKI</code>的目标就是为了实现不同成员在不见面的情况下进行安全通信的，我们当前采用的PKI模型是基于可信的第三方机构，也就是“证书颁发机构”（<code>certification authority</code>，简称<code>CA</code>）签发的证书。证书中存储了使用“证书颁发机构”的私钥加密之后的申请者的公钥信息。</p><h2 id="5-2-1-数字证书的申请"><a href="#5-2-1-数字证书的申请" class="headerlink" title="5.2.1 数字证书的申请"></a>5.2.1 数字证书的申请</h2><p>数字证书需要向“证书颁发机构”提交申请，并通过审核之后才能颁发。因为数字证书中存储的是申请者的公钥，所以如果申请者的私钥丢失或泄漏，就需要向“证书颁发机构”申请注销该证书。</p><p><code>Web服务器</code>向<code>CA</code>申请证书的流程大致如图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-http-10.jpg"></p><p>“证书”中主要包含了经过<code>“证书颁发机构”的私钥</code>加密过后的<code>申请者的“公钥”</code>、<code>“证书有效期”</code>、<code>“申请者信息（如域名等）”</code>。更详细的信息，可以参考《HTTPS权威指南》第3.3.1章节。</p><h2 id="5-2-2-数字证书的验证"><a href="#5-2-2-数字证书的验证" class="headerlink" title="5.2.2 数字证书的验证"></a>5.2.2 数字证书的验证</h2><p>以“Chrome浏览器”为例：<br>浏览器会内置各大著名的“证书颁发机构”的<code>“公钥”</code>，当收到Web服务器返回的<code>“服务器证书”</code>后，Chrome会尝试使用内置的该“证书颁发机构”的<code>“公钥”</code>来解密该证书，如果能解密则说明该证书是“证书颁发机构”颁发的，且没有被篡改过的。然后通过解密所得的“域名”、“证书有效期”来校验该证书是否为该网站所有，是否过期等。</p><blockquote><p><strong>本文介绍的只是“数字证书”申请和验证的基本的流程，实际流程比这个复杂很多，关于“数字证书”的信息介绍可以参考《HTTPS权威指南》</strong></p></blockquote><h1 id="六、HTTPS"><a href="#六、HTTPS" class="headerlink" title="六、HTTPS"></a>六、HTTPS</h1><p>在HTTP请求过程中，客户端与服务端之前没有进行身份确认，而且传输的数据都没有加密处理，所以很容易被劫持和篡改。</p><p>基于HTTP协议的这些弊端，后面就出现了<code>HTTPS</code>（<strong>严格的说，HTTPS并不是一个协议，所以前面文章都没有使用“HTTPS协议”</strong>），HTTPS是基于<code>SSL/TSL</code>协议的，说白了就是<code>HTTP+SSL/TSL</code>，可以把HTTPS大致理解为<code>“HTTP Over SSL”</code>或者<code>“HTTP Over TSL”</code>。</p><p>HTTP, SSL/TSL, HTTPS的关系如下图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-http-11.jpg"></p><h2 id="6-1-SSL-x2F-TSL协议"><a href="#6-1-SSL-x2F-TSL协议" class="headerlink" title="6.1 SSL/TSL协议"></a>6.1 SSL/TSL协议</h2><h3 id="6-1-1-SSL"><a href="#6-1-1-SSL" class="headerlink" title="6.1.1 SSL"></a>6.1.1 SSL</h3><p>SSL（英文：<code>Secure Sockets Layer</code>的缩写）中文叫“安全套接层”。最开始由NetScape公司研发，用以保障互联网上数据传输的安全，利用数据加密技术确保数据在网络上之传输过程中不会被截取及窃听。<br>SSL协议在TCP/IP协议栈中位于<code>传输层</code>和<code>应用层</code>之间。以<code>HTTPS</code>为例，SSL协议就位于TCP和HTTP之间：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-http-12.gif"></p><h3 id="6-1-2-TLS"><a href="#6-1-2-TLS" class="headerlink" title="6.1.2 TLS"></a>6.1.2 TLS</h3><p>TLS（英文：<code>Transport Layer Security</code>的缩写）中文叫“传输层安全协议”，<code>TLS 1.0</code>是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在<code>SSL 3.0协议</code>规范之上，是<code>SSL 3.0</code>的后续版本，可以理解为SSL 3.1，它定义在<a href="https://tools.ietf.org/html/rfc5246">RFC5246</a>中。</p><p>因为TLS是基于SSL 3.0的，所以也可以认为TLS是SSL的加强版。</p><p><strong>我们一般将二者并称为<code>SSL/TSL协议</code>，因为这二者可以视为同一个产品的不同阶段。</strong></p><h2 id="6-2-SSL-x2F-TSL协议的握手过程"><a href="#6-2-SSL-x2F-TSL协议的握手过程" class="headerlink" title="6.2 SSL/TSL协议的握手过程"></a>6.2 SSL/TSL协议的握手过程</h2><blockquote><p>在了解SSL/TSL协议的握手过程之前，需要先阅读关于HTTPS的前几篇文章，对相关预备知识有所了解。</p></blockquote><p><img src="https://static.1key.run/blog/img/wangluoxieyi-http-13.jpg"></p><p>参考上面的流程图，握手过程可以分为4个步骤：</p><p>1).  客户端发送Client Hello请求到服务端，包含如下内容：</p><ul><li>SSL或TSL协议的版本</li><li>客户端生成的随机串<code>Client random</code>；</li><li>客户端支持的加密算法列表，用于客户端和服务端加密算法的协商；</li><li>客户端支持的HASH算法；</li></ul><p>2). 服务端发送Sever Hello响应到客户端，包含如下内容：</p><ul><li>服务端生成的随机串<code>Server random</code>（第3步会用到）；</li><li>由“CA证书机构”颁发的证书的<code>Public key</code>部分（<code>Public key</code>和<code>Private Key</code>为一对，用于非对称加密和解密）；</li><li>会话ID</li><li>协商的加密算法（对称加密和非对称加密）和HASH算法。</li></ul><p>3). 客户端发送Client Key到服务端，包含如下内容或步骤：</p><ul><li>检查服务端返回的“证书”的有效性，如果无效则在浏览器上显示警告。</li><li>客户端使用前2步生成的<code>Client random</code>和<code>Server random</code>作为随机因子，生成另外一个随机串<code>Premaster</code>。</li><li>使用<code>Public key</code>（第2步服务端返回）非对称加密的随机串<code>Premaster</code>。</li></ul><p>4). 服务端通知客户端握手结束，包含如下内容：</p><ul><li>通过解密出来的<code>Premaster</code>生成的本次会话的<code>Session key</code>。</li><li>前面所有握手内容的HASH值，供客户端校验。</li></ul><blockquote><p>参考：<br><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a><br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> HTTPS </tag>
            
            <tag> TLS/SSL </tag>
            
            <tag> 数字证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(6)--TCP协议</title>
      <link href="/2023/06/21/wang-luo-xie-yi-6-tcp-xie-yi/"/>
      <url>/2023/06/21/wang-luo-xie-yi-6-tcp-xie-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一、TCP特性"><a href="#一、TCP特性" class="headerlink" title="一、TCP特性"></a>一、TCP特性</h1><p>尽管TCP和UDP都是用IP协议作为网络层，但TCP却提供和UDP完全不同的网络服务。TCP是<code>面向连接的</code>、<code>稳定可靠</code>的<code>字节流</code>服务。TCP首部的很多字段都是为了实现这2大特性而设计的。</p><p>在一个TCP连接中，仅有两方能进行彼此通信。所以说广播和多播不适用于TCP协议。</p><p>为了通过IP数据报实现可靠性传输，需要考虑很多事情，如数据的破坏、丢包、重复以及分片顺序混乱等问题。TCP通过检验和、序列号、确认序列号、重发控制、连接管理以及窗口控制等机制来实现可靠性传输。</p><h1 id="二、TCP协议首部"><a href="#二、TCP协议首部" class="headerlink" title="二、TCP协议首部"></a>二、TCP协议首部</h1><p>摘自《TCP/IP详解卷1》中的关于TCP首部定义的图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-1.jpg"></p><p><strong>TCP协议的实现较UDP协议复杂太多，它的首部的各个字段的用法也比UDP首部字段复杂多，这里先对TCP首部字段的功能做个大概的介绍。</strong></p><ul><li>16位源端口号：表示发送端端口号。传输层使用端口号来标识发送端和接收端的应用程序，而网络层是通过IP地址来标识主机，这样使用“IP地址+端口”就可以精确定位到某一台主机上的某一应用程序。</li><li>16位目的端口号：表示接收端端口号。</li><li>32位序列号：序列号用来标识从TCP发送端已经发送的字节数。达到最大值$2^{32}-1$之后，再从0开始。</li><li>32位确认序列号：确认序列号用来标识TCP接收端期望接收的下一个序列号（反过来想也就是，TCP接收端已经接受到的字节数为<code>确认序列号减去1</code>）。<strong>只有<code>ACK标志位</code>为1时，该字段才有效。</strong>只要TCP连接建立，这个字段会一直起作用，也就是说只要TCP连接建立，<code>ACK标志位</code>会一直为1。</li><li>4位首部长度：和IP首部一样，是以<code>4个字节(32 bit)</code>为单位的，所以TCP首部最大长度也是<code>15*4=60</code>字节。若没有“选项”字段，长度固定为20字节。</li><li>6位标志位：他们中的多个可以同时被设置为1。<pre class="line-numbers language-none"><code class="language-none">URG 标记后面的"16位紧急指针"是否有效。ACK 标记前面的"32位确认序号"是否有效。PSH 接收方应该尽快的将这个报文交给上层的网络层。RST 重建连接。SYN 标记这个TCP段是用来同步初始序号（ISN）的。FIN 标记发送端已经完成了发送任务。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>16位窗口大小：窗口大小为字节数，用于TCP的流量控制，这个值是接收端期望接受的字节数。</li><li>16位校验和：和UDP类似，校验和覆盖首部和数据部分。</li><li>16位紧急指针：只有前面提到的<code>URG</code>标记位为1时，这个字段才有效。</li><li>选项：添加一些附加数据。和UDP不同，TCP的“选项”字段使用的比较多。</li></ul><h1 id="三、三次握手与四次挥手"><a href="#三、三次握手与四次挥手" class="headerlink" title="三、三次握手与四次挥手"></a>三、三次握手与四次挥手</h1><h2 id="3-1-完整的TCP会话流程图"><a href="#3-1-完整的TCP会话流程图" class="headerlink" title="3.1 完整的TCP会话流程图"></a>3.1 完整的TCP会话流程图</h2><p>本文通过真实的网络示例来讲解TCP的三次握手和四次挥手。读者可以先<a href="https://static.1key.run/misc/tcp.pcapng">下载</a>作者写本文时使用的网络包示例，然后使用wireshark打开（当然也可以使用wireshark随便抓取一个网络包），选中编号为<code>No.9</code>的包，右键选择“追踪流” –&gt; “TCP流”：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-2.jpg"></p><p><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-3.jpg"></p><p>上图是使用wireshark抓取的一个Http接口请求的过程（不含DNS解析等步骤），包含了TCP连接建立、Http请求、Http响应、TCP连接断开。现在以这个示例为基础，来画出该Http接口请求中涉及的整个TCP会话的流程（也是本文最重要的图）：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-4.png"></p><blockquote><ul><li>箭头上方标出了该TCP包<code>SYN、ACK、FIN、PSH</code>等标志位的设置情况（大家可能注意到，除了第一个箭头上没有<code>ACK</code>之外，其他的箭头上都有<code>ACK</code>，这是因为<code>ACK</code>标记位只是用于标记TCP首部的<code>32位确认序列号</code>是否有效。在此之后的<code>32位确认序列号</code>一直有效，所以也就一直有<code>ACK</code>标记位。）；箭头下发标出了该TCP包的序号和确认序号。</li><li>seq_num：表示32位的序号，紧跟其后括号[]中的是相对序号。</li><li>ack_num：表示32位的确认序号，紧跟其后括号[]中的是相对确认序号。</li><li>payload_len：表示本次TCP携带的数据大小（字节）。</li><li>在三次握手和四次挥手的部分，旁边的红色粗体字表示当前端的TCP状态。<strong>在这个示例中是服务端执行主动关闭。</strong></li></ul></blockquote><h2 id="3-2-Wireshark的相对序号"><a href="#3-2-Wireshark的相对序号" class="headerlink" title="3.2 Wireshark的相对序号"></a>3.2 Wireshark的相对序号</h2><p><code>相对序号</code>是Wireshark引出的概念，TCP协议中没有这个概念。Wireshark使用相对数值来显示序号和确认序号，这个相对值是相对于初始序号（ISN）而言的。因为人类更加习惯跟踪更小数值，所以Wireshark默认用相对数值来展示。如果需要查看真实的序号，可以在wireshark中选中该网络包，在最下方的数据窗口查看，如：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-5.jpg"></p><h2 id="3-3-Wireshark的TCP流量图"><a href="#3-3-Wireshark的TCP流量图" class="headerlink" title="3.3 Wireshark的TCP流量图"></a>3.3 Wireshark的TCP流量图</h2><p>我们也可以使用Wireshark自带的统计功能来查看整个TCP会话的过程。通过菜单“统计” –&gt; “流量图”打开流量图窗口，在“显示”选项选择“显示的分组”，“流类型”选项选择“TCP流”，如图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-6.jpg"></p><h1 id="四、TIME-WAIT及MSL"><a href="#四、TIME-WAIT及MSL" class="headerlink" title="四、TIME_WAIT及MSL"></a>四、TIME_WAIT及MSL</h1><h2 id="4-1-TIME-WAIT状态为何存在？"><a href="#4-1-TIME-WAIT状态为何存在？" class="headerlink" title="4.1 TIME_WAIT状态为何存在？"></a>4.1 TIME_WAIT状态为何存在？</h2><p>这里我们不使用“客户端”、“服务端”来表示TCP连接的2端，转而使用“主动断开连接端”、“被动断开连接端”来表示TCP通讯的2端。因为执行主动断开连接的端可能是服务端也可能是客户端（虽然我们大多数情况下遇到的是客户端执行主动断开）。</p><p>在“主动断开连接端”收到了“被动断开连接端”发来的<code>LAST_ACK</code>之后，会给“被动断开连接端”回复一个<code>ACK</code>确认消息。但这个时候为了确保“被动断开连接端”有足够的时间能够收到该消息，“主动断开连接端”不能马上关闭socket，需要等待一定的时间来确保“被动断开连接端”可以收到<code>ACK</code>确认消息。“主动断开连接端”在等待的这个时间段内的状态我们称之为<code>TIME_WAIT</code>状态。</p><p>归纳为一句话就是：<strong>TIME_WAIT状态就是“主动断开的一方”在发送完最后一次ACK后进入的等待状态。</strong></p><h2 id="4-2-等待时间"><a href="#4-2-等待时间" class="headerlink" title="4.2 等待时间"></a>4.2 等待时间</h2><p>那么<code>TIME_WAIT</code>状态需要持续多久了，也就是“主动断开连接端”在发送完最后一个ACK之后需要等待多久了？<br><a href="http://www.52im.net/topic-tcpipvol1.html">《TCP/IP详解 卷1：协议》</a>中提到：默认TIME_WAIT的超时时间是2倍的MSL。MSL是<code>Maximum Segment Lifetime</code>的缩写，表示报文的最大生存时间，这个时间和系统的TCP实现有关，每个系统是不一样的。</p><h3 id="4-2-1-windows系统MSL"><a href="#4-2-1-windows系统MSL" class="headerlink" title="4.2.1 windows系统MSL"></a>4.2.1 windows系统MSL</h3><p>注册表<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters</code>下的<code>TcpTimedWaitDelay</code>键（如果没有可以新建一个）就对应了<code>2*MSL</code>（2倍的MSL）的值。<br><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-7.jpg"></p><h3 id="4-2-2-Linux系统MSL"><a href="#4-2-2-Linux系统MSL" class="headerlink" title="4.2.2 Linux系统MSL"></a>4.2.2 Linux系统MSL</h3><p>以CentOS为例（<strong>摘自网络，仅供参考</strong>）：</p><ul><li><p>查看默认的MSL值（60s）：</p><pre class="line-numbers language-none"><code class="language-none">cat /proc/sys/net/ipv4/tcp_fin_timeout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改默认为120：</p><pre class="line-numbers language-none"><code class="language-none">echo 120 &gt; /proc/sys/net/ipv4/tcp_fin_timeout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改完成后，重新加载配置文件：</p><pre class="line-numbers language-none"><code class="language-none">sysctl -p /etc/sysctl.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看是否已经生效：</p><pre class="line-numbers language-none"><code class="language-none">sysctl -a | grep fin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="4-3-SO-REUSEADDR"><a href="#4-3-SO-REUSEADDR" class="headerlink" title="4.3 SO_REUSEADDR"></a>4.3 SO_REUSEADDR</h2><ul><li><p>如果进程中的某个TCP连接处于<code>TIME_WAIT</code>等待状态，因为这个等待时间比较长，在这期间该连接使用的端口将一直被占用。</p></li><li><p>如果一个服务端进程（绑定了某个端口）退出（正常退出或异常退出）后，立即启动一个新的该进程，可能由于Windows系统对端口的释放不及时，导致这个端口还没有被释放，不能被再次绑定，从而导致新进程绑定端口失败。</p></li></ul><p>那么遇到上面的问题如何解决了？<br>我们在网络编程中经常设置的<code>SO_REUSEADDR</code>选项就可以解决这个问题，</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">int flag = 1;setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast&lt;const char*&gt;(&amp;flag), sizeof(flag));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong><code>SO_REUSEADDR</code>提供如下四个功能：</strong></p><ul><li><p>SO_REUSEADDR允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在。这通常是重启监听服务器时出现，若不设置此选项，则<code>bind</code>时将出错。</p></li><li><p>SO_REUSEADDR允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可。对于TCP，我们根本不可能启动捆绑相同IP地址和相同端口号的多个服务器。</p></li><li><p>SO_REUSEADDR允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地IP地址即可。这一般不用于TCP服务器。</p></li><li><p>SO_REUSEADDR允许完全重复的捆绑：当一个IP地址和端口绑定到某个套接口上时，还允许此IP地址和端口捆绑到另一个套接口上。一般来说，这个特性仅在支持多播的系统上才有，而且只对UDP套接口而言（TCP不支持多播）。</p></li></ul><p>其中第一个功能就可以用来解决该问题。</p><h1 id="五、为什么要进行3次握手？"><a href="#五、为什么要进行3次握手？" class="headerlink" title="五、为什么要进行3次握手？"></a>五、为什么要进行3次握手？</h1><p>前面的文章介绍了TCP的三次握手，那么TCP的握手为什么是3次了？</p><p><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-8.png"></p><p>本文从3个角度来解释为什么要进行3次握手？</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>TCP的握手的目的是让通信双方都确定双方能够正常发送和接收信息。</p><p>第一步，服务端收到客户端发送的SYN，服务端能够确定如下信息：“客户端的发送功能正常，服务端自己的接受功能正常”。但客户端还什么都不能确定。<br>第二步，客户端收到服务端回复的SYN+ACK，截至目前，客户端能够确定如下信息：“客户端自己的发送/接收功能都正常，服务端的接收和发送功能都正常”；服务端还是只能确定自己的接受功能正常，还不知道自己的发送功能是否正常，客户端的接受功能是否正常。</p><p>大家可以看到，到第二步完成，客户端和服务端能够确认的信息分别如下：</p><pre class="line-numbers language-none"><code class="language-none">客户端能够确定：  客户端-发送 正常  客户端-接收 正常  服务端-发送 正常  服务端-接收 正常服务端能够确定：  客户端-发送 正常  客户端-接收 ？  服务端-发送 ？  服务端-接收 正常<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面表可以看到，第二步完成之后，服务端还能不能确定“服务端的发送功能”和“客户端的接收功能”是否正常。所以需要第三步。</p><p>第三步，服务端收到客户端回复的ACK，服务端能够确定如下信息：客户端的发送功能正常，服务端的接收功能正常。</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>我们可以假设“客户端”和“服务端”是2个人，模拟这2个人打招呼的形式来理解为什么需要3次握手。</p><pre class="line-numbers language-none"><code class="language-none">客户端：hi，服务端，你能听到我说话吗？服务端：hi，客户端，我能听到你说的话，你能听到我说的话吗？客户端：嗯，服务端，我也能听到你说的话。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>对照文章开始处TCP握手图的前2步，现在我们假设TCP只有2次握手：</p><p>服务端在收到客户端的<code>SYN</code>并且回复<code>SYN+AKC</code>之后，就认为连接已经建立完成了，并为之分配相应的资源。<br>但客户机却因为网络延迟等问题一直没收到服务端回复的<code>SYN+ACK</code>，这样客户端就认为连接没有建立成功，糟糕的是，客户端会因为连接没有成功而不停的重试，这样每次服务端都会认为连接建立成功并分配资源。</p><p>如果按照上面描述的那样，客户端一直没有收到服务端回复的<code>SYN+ACK</code>，且一直这样尝试建立连接，就会造成服务端资源极大的浪费，加重服务端的负担。</p><h1 id="六、为什么要进行4次挥手？"><a href="#六、为什么要进行4次挥手？" class="headerlink" title="六、为什么要进行4次挥手？"></a>六、为什么要进行4次挥手？</h1><p><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-9.png"></p><p>对比上面的图，我们不难发现：4次挥手相比3次握手多了一次，主要是因为握手的<code>ACK和SYN</code>是合并在一条发送的，而挥手的<code>ACK和FIN</code>是分开发送的，所以挥手比握手多了一次。</p><p><strong>现在我们分析为什么TCP挥手的<code>ACK和FIN</code>（分别对应图中的第2,3条线）要分开发送？</strong></p><p><code>“被动断开方”</code>之所以叫称之为“被动”是因为TCP连接的断开并不是它想的，也不是它主动触发的，是对面的<code>“主动断开方”</code>想要断开的，也许这个时候<code>“被动断开方”</code>还正想发送点数据给<code>“主动断开方”</code>了。</p><p>为了让<code>“被动断开方”</code>有机会将想要发送的数据发送完，主动断开方在发送完<code>FIN</code>并收到了<code>ACK</code>确认信息进入<code>FIN_WAIT_2</code>状态后，只关闭了发送功能了，但仍然保留接收功能。这样<code>“被动断开方”</code>就有机会将没有发送完的数据发送完成，发送完成之后，<code>“被动断开方”</code>也发送一个<code>FIN</code>，相当于告诉<code>“主动断开方”</code>：“我的数据已经发完了呀，以后不会再发数据了，你可以安心的把接收功能关闭了，另外我自己也要关闭了呀”。</p><blockquote><p>《TCP/IP详解 卷1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 三次握手 </tag>
            
            <tag> 四次挥手 </tag>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(5)--UDP协议</title>
      <link href="/2023/06/21/wang-luo-xie-yi-5-udp-xie-yi/"/>
      <url>/2023/06/21/wang-luo-xie-yi-5-udp-xie-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、什么是UDP协议？"><a href="#一、什么是UDP协议？" class="headerlink" title="一、什么是UDP协议？"></a>一、什么是UDP协议？</h2><p>UDP是User Datagram Protocol的简称，中文名是用户数据报协议，是OSI参考模型中的传输层协议，它是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。<br>UDP的正式规范是<a href="https://www.ietf.org/rfc/rfc768.txt">IETF RFC768</a>。UDP在IP报文的协议号是17。</p><blockquote><p>ISO七层模型：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-udp-1.jpg"></p></blockquote><h2 id="二、UDP报头"><a href="#二、UDP报头" class="headerlink" title="二、UDP报头"></a>二、UDP报头</h2><p>UDP报头的结构如图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-udp-2.jpg"></p><p>UDP报头由4个部分组成，其中两个是可选的（粉红背景标出部分）：</p><ul><li><p>各16bit的<code>来源端口</code>和<code>目的端口</code>用来标记发送和接受的应用进程。因为UDP不需要应答，所以来源端口是可选的，如果来源端口不用，那么置为零。</p></li><li><p>在目的端口后面是长度固定的以字节为单位的报文长度域，用来指定UDP数据报包括数据部分的长度，长度最小值为8byte。</p></li><li><p>首部剩下地16bit是用来对首部和数据部分一起做<code>校验和</code>（Checksum）的，这部分是可选的，但在实际应用中一般都使用这一功能。</p></li><li><p>UDP和TCP的<code>校验和</code>都覆盖到了他们的首部和数据，而之前介绍的IP首部的<code>校验和</code>只覆盖了IP首部。</p></li></ul><h2 id="三、TCP和UDP区别"><a href="#三、TCP和UDP区别" class="headerlink" title="三、TCP和UDP区别"></a>三、TCP和UDP区别</h2><table><thead><tr><th>特征点</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接</td><td>面向非连接</td></tr><tr><td>传输可靠性</td><td>可靠</td><td>会丢包，不可靠</td></tr><tr><td>应用场景</td><td>传输数据量大</td><td>传输量小</td></tr><tr><td>速度</td><td>慢</td><td>快</td></tr></tbody></table><p>TCP(传输控制协议)提供的是面向连接、可靠的字节流服务。当客户端和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。<br>UDP(用户数据报协议)是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。</p><p>由于UDP缺乏拥塞控制（congestion control），需要基于网络的机制来减少因失控和高速UDP流量负荷而导致的拥塞崩溃效应。换句话说，因为UDP发送者不能够检测拥塞，所以像使用包队列和丢弃技术的路由器这样的网络基本设备往往就成为降低UDP过大通信量的有效工具。数据报拥塞控制协议（DCCP）设计成通过在诸如流媒体类型的高速率UDP流中，增加主机拥塞控制，来减小这个潜在的问题。</p><h2 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景"></a>四、应用场景</h2><p>由于缺乏可靠性且属于非连接导向协议，UDP的应用一般必须允许一定量的丢包、出错和复制粘贴。但有些应用，比如TFTP，需要可靠性保证，则必须在应用层增加根本的可靠机制。但是绝大多数UDP应用都不需要可靠机制，甚至可能因为引入可靠机制而降低性能。流媒体、即时多媒体游戏和IP电话（VoIP）就是典型的UDP应用。如果某个应用需要很高的可靠性，那么可以用传输控制协议（即TCP协议）来代替UDP。</p><p>使用UDP协议的应用有：域名系统（DNS）、简单网络管理协议（SNMP）、动态主机配置协议（DHCP）、路由信息协议（RIP）等等。</p><p>因为UDP不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失几个数据包，也不会对接收结果产生太大影响。</p><h2 id="五、单播、多播、广播、组播"><a href="#五、单播、多播、广播、组播" class="headerlink" title="五、单播、多播、广播、组播"></a>五、单播、多播、广播、组播</h2><p>假设A(all简写)代表所有的机器，M(multiple简写)代表A中的多个机器，G(group简写)代表一组机器，1代表一台机器，那么：</p><pre class="line-numbers language-none"><code class="language-none">1 -&gt; 1 就是单播；1 -&gt; M 就是多播；1 -&gt; A 就是广播；1 -&gt; G 就是组播；当M=A时，多播就是广播；当M=G时，多播就是组播；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多播包括组播和广播，组播、广播都是多播的一种表现形式。</p><h3 id="5-1-单播"><a href="#5-1-单播" class="headerlink" title="5.1 单播"></a>5.1 单播</h3><p>单播是主机之间“一对一”的通讯模式。发送方需要指定一个接收方的IP和端口，只有这个接收方会收到数据报。不会对子网内的其他机器产生影响。<br>在单播模式下，服务器针对每个客户机都要发送数据流，<code>服务器流量=客户机数量×客户机流量</code>，在客户机数量大、每个客户机流量大的应用（如流媒体）中，服务器将不堪重负。</p><h4 id="5-1-1-单播发送端"><a href="#5-1-1-单播发送端" class="headerlink" title="5.1.1 单播发送端"></a>5.1.1 单播发送端</h4><p>因为UDP不是面向连接的，且不可靠的，所以发送端在调用<code>sendto</code>之后，就算<code>sendto</code>返回成功，也不代表接收端一定收到了数据，可能接收端压根都没启动，也是有可能的。不能根据<code>sendto</code>的返回值来确保接收端一定收到了数据。如果需要数据传输的可靠性得到保证，可以使用TCP或者通过业务逻辑来保证。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;WinSock2.h&gt;#pragma comment(lib, "Ws2_32.lib")void SendLogic() {WSADATA wsaData;WORD wVersionRequested = MAKEWORD(1, 0);WSAStartup(wVersionRequested, &amp;wsaData);SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0);if (socket == INVALID_SOCKET) {printf("WSASocket failed, error=%d\n", WSAGetLastError());return;}sockaddr_in addr;addr.sin_family = AF_INET;addr.sin_port = htons(6000);  // 接收端端口addr.sin_addr.s_addr = inet_addr("127.0.0.1"); // 接收端IPchar buf[100] = { "hello" };int err = sendto(socket, buf, strlen(buf), 0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr));if (err == SOCKET_ERROR) {printf("sendto failed, error=%d\n", WSAGetLastError());return;}printf("[SEND] %s OK\n", buf);WSACleanup();}int main(){SendLogic();getchar();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-1-2-单播接收端"><a href="#5-1-2-单播接收端" class="headerlink" title="5.1.2 单播接收端"></a>5.1.2 单播接收端</h4><p>因为UDP不是面向连接的，所以接收端不用listen，也不用accept，只需要绑定到指定的端口和地址即可。<br><code>recvfrom</code>是同步的，会阻塞住等待数据的到来。如果要使用异步方式，可以使用<code>WSARecvFrom</code>结合ICOP的方式来实现。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;WinSock2.h&gt;#pragma comment(lib, "Ws2_32.lib")void RecvLogic() {WSADATA wsaData;WORD wVersionRequested = MAKEWORD(1, 0);WSAStartup(wVersionRequested, &amp;wsaData);SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0);if (socket == INVALID_SOCKET) {printf("WSASocket failed, error=%d\n", WSAGetLastError());return;}sockaddr_in addr;addr.sin_family = AF_INET;addr.sin_port = htons(6000);  // 端口addr.sin_addr.s_addr = INADDR_ANY;  // 任意IP地址int err = bind(socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr));if (err == SOCKET_ERROR) {printf("bind failed, error=%d\n", WSAGetLastError());return;}while (true) { // TODO：未考虑退出的情况char buf[100] = { 0 };int fromlen = sizeof(addr);err = recvfrom(socket, buf, 100, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;addr), &amp;fromlen);if (err == SOCKET_ERROR) {printf("recvfrom failed, error=%d\n", WSAGetLastError());return;}printf("[RECV] %s\n", buf);}WSACleanup();}int main(){RecvLogic();getchar();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-广播"><a href="#5-2-广播" class="headerlink" title="5.2 广播"></a>5.2 广播</h3><p>广播是主机之间“一对所有”的通讯模式。子网的一台主机作为发送发广播一条信息，该子网中的所有主机都可以接收到该信息（不管你是否需要该信息）。<br>在广播模式下，由于服务器不用向每个客户机单独发送数据，所以服务器流量负载极低。<br>无法在广域网上进行广播，而且广播消息不会被路由转发，所以只能在一个子网中进行广播。因为如果路由器转发了广播信息，那么势必会引起网络瘫痪。这也是为什么IP协议的设计者故意没有定义互联网范围的广播机制。</p><p>主机发送广播消息时，需要指定目的IP地址为<code>255.255.255.255</code>和接受者的端口号。</p><p>UDP的广播和单播的不同在于发送端（接收端的实现和单播方式没有区别）的实现上：</p><ol><li>发送端将套接字配置为发送广播消息，使用<code>setsockopt</code>函数。</li><li>发送地址更改为受限的广播地址<code>255.255.255.255</code>。</li></ol><blockquote><p>需要说明的是广播地址不仅仅只有<code>255.255.255.255</code>一个。广播地址分为受限的广播、指向网络的广播、指向子网的广播、指向所有子网的网广播。<code>255.255.255.255</code>只是受限的广播地址。</p></blockquote><h4 id="5-2-1-广播发送端"><a href="#5-2-1-广播发送端" class="headerlink" title="5.2.1 广播发送端"></a>5.2.1 广播发送端</h4><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;WinSock2.h&gt;#pragma comment(lib, "Ws2_32.lib")void SendLogic() {WSADATA wsaData;WORD wVersionRequested = MAKEWORD(1, 0);WSAStartup(wVersionRequested, &amp;wsaData);SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0);if (socket == INVALID_SOCKET) {printf("WSASocket failed, error=%d\n", WSAGetLastError());return;}// 将套接字配置为发送广播消息int broadcast = 1;int err = setsockopt(socket, SOL_SOCKET, SO_BROADCAST, reinterpret_cast&lt;const char*&gt;(&amp;broadcast), sizeof(int));if (err == SOCKET_ERROR) {printf("setsockopt failed, error=%d\n", WSAGetLastError());return;}sockaddr_in addr;addr.sin_family = AF_INET;addr.sin_port = htons(6000);addr.sin_addr.s_addr = INADDR_BROADCAST; // 也可以换成inet_addr("255.255.255.255")char buf[100] = { "hello" };err = sendto(socket, buf, strlen(buf), 0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr));if (err == SOCKET_ERROR) {printf("sendto failed, error=%d\n", WSAGetLastError());return;}printf("[BROADCAST] %s OK\n", buf);WSACleanup();}int main(){SendLogic();getchar();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-2-2-广播接收端-和单播一样"><a href="#5-2-2-广播接收端-和单播一样" class="headerlink" title="5.2.2 广播接收端(和单播一样)"></a>5.2.2 广播接收端(和单播一样)</h4><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;WinSock2.h&gt;#pragma comment(lib, "Ws2_32.lib")void RecvLogic() {WSADATA wsaData;WORD wVersionRequested = MAKEWORD(1, 0);WSAStartup(wVersionRequested, &amp;wsaData);SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0);if (socket == INVALID_SOCKET) {printf("WSASocket failed, error=%d\n", WSAGetLastError());return;}sockaddr_in addr;addr.sin_family = AF_INET;addr.sin_port = htons(6000);addr.sin_addr.s_addr = INADDR_ANY;int err = bind(socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr));if (err == SOCKET_ERROR) {printf("bind failed, error=%d\n", WSAGetLastError());return;}while (true) {char buf[100] = { 0 };int fromlen = sizeof(addr);err = recvfrom(socket, buf, 100, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;addr), &amp;fromlen);if (err == SOCKET_ERROR) {printf("recvfrom failed, error=%d\n", WSAGetLastError());return;}printf("[RECV] %s\n", buf);}WSACleanup();}int main(){RecvLogic();getchar();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-组播"><a href="#5-3-组播" class="headerlink" title="5.3 组播"></a>5.3 组播</h3><p>组播是主机之间“一对多”的通讯模式。一台主机加入一个组播IP后，之后向该组播IP发送的数据报都会发送到该主机。<br>专门为组播划出了一个地址范围，在IPv4中为D类地址，范围是<code>224.0.0.0 ~ 239.255.255.255</code>，并将D类地址划分为局部链接组播地址、预留组播地址、管理权限组播地址如下：<br>局部链接地址：<code>224.0.0.0～224.0.0.255</code>，用于局域网，路由器不转发属于此范围的IP包。</p><p>预留组播地址：<code>224.0.1.0～238.255.255.255</code>，用于全球范围或网络协议。</p><p>管理权限地址：<code>239.0.0.0～239.255.255.255</code>，组织内部使用，用于限制组播范围。</p><p>组播就是将数据发送到一组主机。接收端如果要接收消息，则需要加入到该分组，分组是用IP来标识的。<br>从<a href="/2023/06/20/wang-luo-xie-yi-3-ip-xie-yi/" title="网络协议(3)--IP协议">网络协议(3)--IP协议</a>可以知道，适用于分组的IP有<code>224.0.0.0 ~ 239.255.255.255</code>。<br>同样，发送端就需要将数据发送到该分组IP。</p><h4 id="5-3-1-组播发送端"><a href="#5-3-1-组播发送端" class="headerlink" title="5.3.1 组播发送端"></a>5.3.1 组播发送端</h4><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;WinSock2.h&gt;#pragma comment(lib, "Ws2_32.lib")void SendLogic() {WSADATA wsaData;WORD wVersionRequested = MAKEWORD(1, 0);WSAStartup(wVersionRequested, &amp;wsaData);SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0);if (socket == INVALID_SOCKET) {printf("WSASocket failed, error=%d\n", WSAGetLastError());return;}// 将套接字配置为发送广播消息int broadcast = 1;int err = setsockopt(socket, SOL_SOCKET, SO_BROADCAST, reinterpret_cast&lt;const char*&gt;(&amp;broadcast), sizeof(int));if (err == SOCKET_ERROR) {printf("setsockopt failed, error=%d\n", WSAGetLastError());return;}sockaddr_in addr;addr.sin_family = AF_INET;addr.sin_port = htons(6000);addr.sin_addr.s_addr = inet_addr("225.0.0.37"); // 向指定广播组发送消息char buf[100] = { "hello" };err = sendto(socket, buf, strlen(buf), 0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr));if (err == SOCKET_ERROR) {printf("sendto failed, error=%d\n", WSAGetLastError());return;}printf("[BROADCAST] %s OK\n", buf);WSACleanup();}int main(){SendLogic();getchar();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-2-组播接收端"><a href="#5-3-2-组播接收端" class="headerlink" title="5.3.2 组播接收端"></a>5.3.2 组播接收端</h4><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;WinSock2.h&gt;#include &lt;Ws2ipdef.h&gt;#pragma comment(lib, "Ws2_32.lib")void RecvLogic() {WSADATA wsaData;WORD wVersionRequested = MAKEWORD(1, 0);WSAStartup(wVersionRequested, &amp;wsaData);SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0);if (socket == INVALID_SOCKET) {printf("WSASocket failed, error=%d\n", WSAGetLastError());return;}sockaddr_in addr;addr.sin_family = AF_INET;addr.sin_port = htons(6000);addr.sin_addr.s_addr = htonl(INADDR_ANY);int err = bind(socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr));if (err == SOCKET_ERROR) {printf("bind failed, error=%d\n", WSAGetLastError());return;}// 将SOCKET加入广播组//struct ip_mreq mreq; // 引入头文件&lt;Ws2ipdef.h&gt;mreq.imr_multiaddr.s_addr = inet_addr("225.0.0.37");  // 广播组地址mreq.imr_interface.s_addr = htonl(INADDR_ANY);// 注：使用IP_DROP_MEMBERSHIP可以离开广播组err = setsockopt(socket, IPPROTO_IP, IP_ADD_MEMBERSHIP, reinterpret_cast&lt;const char*&gt;(&amp;mreq), sizeof(ip_mreq));if (err == SOCKET_ERROR) {printf("setsockopt failed, error=%d\n", WSAGetLastError());return;}while (true) {char buf[100] = { 0 };int fromlen = sizeof(addr);err = recvfrom(socket, buf, 100, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;addr), &amp;fromlen);if (err == SOCKET_ERROR) {printf("recvfrom failed, error=%d\n", WSAGetLastError());return;}printf("[RECV] %s\n", buf);}WSACleanup();}int main(){RecvLogic();getchar();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>《TCP/IP详解 卷1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UDP </tag>
            
            <tag> 单播 </tag>
            
            <tag> 多播 </tag>
            
            <tag> 广播 </tag>
            
            <tag> 组播 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(4)--ICMP协议</title>
      <link href="/2023/06/21/wang-luo-xie-yi-4-icmp-xie-yi/"/>
      <url>/2023/06/21/wang-luo-xie-yi-4-icmp-xie-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><p>互联网控制消息协议（英文：<code>Internet Control Message Protocol</code>，ICMP）是互联网协议族的核心协议之一。定义在RFC 792文档中。<br>ICMP的消息大致可以分为两类：一类是差错报文，即通知出错原因的错误消息（如<code>traceroute</code>），另一类是查询报文，即用于诊断的查询消息（如<code>ping</code>）。<br>使用ICMP协议的典型应用有<code>ping</code>和<code>traceroute</code>（windows上叫<code>tracert</code>）。</p><p><strong>ICMP是在IP数据报的内部被传输的，紧跟着IP报文的首部（如果IP首部有可选部分，则紧跟着可选部分）</strong>：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-icmp-1.jpg"><br><strong>图上的IP首部20字节是在IP报文首部不含可选部分的情况下，若IP首部含可选部分，则大于20字节。</strong></p><h1 id="一、-ICMP报文格式"><a href="#一、-ICMP报文格式" class="headerlink" title="一、 ICMP报文格式"></a>一、 ICMP报文格式</h1><p><img src="https://static.1key.run/blog/img/wangluoxieyi-icmp-2.jpg"><br><strong>所有ICMP报文的前4个字节都是一样的，但剩下的其他字节则根据报文类型的不同而不同。</strong></p><ul><li><p><code>8位类型字段</code>和<code>8位代码字段</code>共同决定一种ICMP报文的类型。<br><img src="https://static.1key.run/blog/img/wangluoxieyi-icmp-3.jpg"></p></li><li><p>校验和的计算方法和IP首部校验和的计算方式相同，但ICMP校验和覆盖整个ICMP报文。</p><blockquote><p>IP首部校验和的计算方式和原理参考：<a href="/2023/06/20/wang-luo-xie-yi-3-ip-xie-yi/" title="网络协议(3)--IP协议">网络协议(3)--IP协议</a><br>UDP和TCP的校验和同样也都覆盖到了他们的首部和数据。</p></blockquote></li></ul><blockquote><p>《TCP/IP详解 卷1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p></blockquote><h1 id="二、实际应用"><a href="#二、实际应用" class="headerlink" title="二、实际应用"></a>二、实际应用</h1><h2 id="2-1-Ping"><a href="#2-1-Ping" class="headerlink" title="2.1 Ping"></a>2.1 Ping</h2><h3 id="2-1-1-Ping程序原理"><a href="#2-1-1-Ping程序原理" class="headerlink" title="2.1.1 Ping程序原理"></a>2.1.1 Ping程序原理</h3><p>大多数系统都已经在内核中内置了ping服务器的功能，所以不需要单独的其他进程来接收主机的ping请求。</p><p>windows系统下，输入<code>ping /?</code>命令查看ping的用法如下：</p><pre class="line-numbers language-none"><code class="language-none">用法: ping [-t] [-a] [-n count] [-l size] [-f] [-i TTL] [-v TOS]           [-r count] [-s count] [[-j host-list] | [-k host-list]]           [-w timeout] [-R] [-S srcaddr] [-4] [-6] target_name选项:    -t             Ping 指定的主机，直到停止。                   若要查看统计信息并继续操作 - 请键入 Control-Break；                   若要停止 - 请键入 Control-C。    -a             将地址解析成主机名。    -n count       要发送的回显请求数。    -l size        发送缓冲区大小。    -f             在数据包中设置“不分段”标志(仅适用于 IPv4)。    -i TTL         生存时间。    -v TOS         服务类型(仅适用于 IPv4。该设置已不赞成使用，且                   对 IP 标头中的服务字段类型没有任何影响)。    -r count       记录计数跃点的路由(仅适用于 IPv4)。    -s count       计数跃点的时间戳(仅适用于 IPv4)。    -j host-list   与主机列表一起的松散源路由(仅适用于 IPv4)。    -k host-list   与主机列表一起的严格源路由(仅适用于 IPv4)。    -w timeout     等待每次回复的超时时间(毫秒)。    -R             同样使用路由标头测试反向路由(仅适用于 IPv6)。    -S srcaddr     要使用的源地址。    -4             强制使用 IPv4。    -6             强制使用 IPv6。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>-r</code>参数用于记录跃点路由，类似tracert的功能，但他们的实现方式不一样，ping是通过在IP头部“选项”字段记录经过的每个路由的IP来实现记录路由功能的，这种实现有个限制，就是IP首部“选项”字段的最大字节数为40字节，所以最多只能记录10个IP。</p><p>ping功能通过ICMP的回显请求和回显应答来实现，也就是说ping是基于ICMP协议实现的。</p><p>ICMP回显请求和回显应答的报文格式如下：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-icmp-4.jpg"></p><ul><li>标识符：在实现中，一般将该字段设置为当前进程ID。这样即使在同一台主机上同时运行了多个ping程序实例， ping程序也可以识别出返回的信息属于哪个进程。</li><li>序号：序号一般从0开始（没有强制性，从任何数字开始都可以），每发送一次新的回显请求就加1。因为ICMP是在IP数据报内部被传输的，而IP协议又是不可靠、无连接的，所以ping程序打印出返回的每个分组的序列号，方便我们查看是否有分组丢失、失序或重复。 </li><li>选项：在“选项”字段中，我们一般放入发送时间戳，这样在收到回应的时候可以用来计算本次ping的耗时。我们经常会指定ping包的大小，所以也会在“选项”字段中填充一些废数据来让包达到一定大小，在下面的<code>FillPingPacket</code>函数就有这样的实现。</li></ul><h3 id="2-1-2-C-代码实现"><a href="#2-1-2-C-代码实现" class="headerlink" title="2.1.2 C++代码实现"></a>2.1.2 C++代码实现</h3><h4 id="定义ICMP、ping首部"><a href="#定义ICMP、ping首部" class="headerlink" title="定义ICMP、ping首部"></a>定义ICMP、ping首部</h4><p><code>networkprotocolheader.h</code>头文件中定义了IP协议、ICMP协议等协议的首部结构体。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#pragma pack(1)#define __u8 unsigned char#define __u16 unsigned short#define __u32 unsigned longstruct icmp_common_hdr {__u8 type;__u8 code;__u16 check;/*Other content start here. */};struct ping_header {icmp_common_hdr common_hdr;__u16 id;__u16 seq;__u32 timestamp;};#pragma pack()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="程序执行参数"><a href="#程序执行参数" class="headerlink" title="程序执行参数"></a>程序执行参数</h4><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">DECLARE_bool(h); // 帮助DECLARE_bool(t); // ping指定的主机直到停止DECLARE_int(w);  // 等待每次回复的超时时间(毫秒)DECLARE_int(s);  // 发送ping包超时时间(毫秒)DECLARE_int(l);  // 发送缓冲区大小DECLARE_int(i);  // TTLDEFINE_bool(h, false, "帮助");DEFINE_bool(t, false, "ping指定的主机直到停止");DEFINE_int(w, 3000, "等待每次回复的超时时间(毫秒)");DEFINE_int(s, 3000, "发送ping包超时时间(毫秒)");DEFINE_int(l, 32, "发送缓冲区大小");DEFINE_int(i, 128, "TTL");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ping程序的执行参数的定义和解析由webrtc的<code>"rtc_base/flags.h"</code>支持。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>代码中的某些功能，如参数解析、断言、时间戳等基于webrtc的<code>rtc_base</code>实现，这些功能也可以很方便的自己实现。</p><p>另外，使用原始套接字需要管理员权限，如果需要绕开管理员权限，可以使用windows提供的<code>IcmpSendEcho</code>系列函数。</p><p><strong>在发送ping请求的时候，我们只封装了一个ICMP报文，并没有自己手动添加IP头，封装IP报文。因为内核会自动添加IP头，如果想自己添加IP头，可以调用<code>setsockopt</code>设置<code>IP_HDRINCL</code>选项，告诉内核由我们自己来封装IP头。</strong></p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;WinSock2.h&gt;#include &lt;ws2spi.h&gt;#include &lt;ws2tcpip.h&gt;#include "rtc_base/networkprotocolheader.h"#include "rtc_base/checks.h"#include "rtc_base/flags.h"#include "rtc_base/timeutils.h"DECLARE_bool(h); // 帮助DECLARE_bool(t); // ping指定的主机直到停止DECLARE_int(w);  // 等待每次回复的超时时间(毫秒)DECLARE_int(s);  // 发送ping包超时时间(毫秒)DECLARE_int(l);  // 发送缓冲区大小DECLARE_int(i);  // TTLDEFINE_bool(h, false, "帮助");DEFINE_bool(t, false, "ping指定的主机直到停止");DEFINE_int(w, 3000, "等待每次回复的超时时间(毫秒)");DEFINE_int(s, 3000, "发送ping包超时时间(毫秒)");DEFINE_int(l, 32, "发送数据大小");DEFINE_int(i, 128, "TTL");void FillPingPacket(__u8* icmp_packet, __u16 seq, __u16 icmp_packet_size) {RTC_DCHECK(icmp_packet);ping_hdr* pping_hdr = reinterpret_cast&lt;ping_hdr*&gt;(icmp_packet);pping_hdr-&gt;common_hdr.type = 8;pping_hdr-&gt;common_hdr.code = 0;pping_hdr-&gt;id = (__u16)GetCurrentProcessId();pping_hdr-&gt;seq = seq;__u32 now = rtc::Time32();memcpy((icmp_packet + sizeof(ping_hdr)), &amp;now, sizeof(__u32));// fill some junk in the buffer.int junk_data_size = FLAG_l - sizeof(__u32); // timestampint junk_offset = icmp_packet_size - junk_data_size;if(junk_data_size &gt; 0)memset((icmp_packet + junk_offset), 'E', junk_data_size);pping_hdr-&gt;common_hdr.check = 0;pping_hdr-&gt;common_hdr.check = rtc::GetCheckSum(reinterpret_cast&lt;__u16*&gt;(icmp_packet), icmp_packet_size);}void DecodeIPPacket(__u8* ip_packet, __u16 packet_size) {iphdr* ip_hdr = reinterpret_cast&lt;iphdr*&gt;(ip_packet);__u32 now = rtc::Time32();__u16 ip_hdr_len = ip_hdr-&gt;ihl * 4; // bytesping_hdr *pping_hdr = reinterpret_cast&lt;ping_hdr*&gt;(ip_packet + ip_hdr_len);if (pping_hdr-&gt;common_hdr.type != 0 || pping_hdr-&gt;common_hdr.code != 0) {printf("non-echo response, type=%d, code=%d\n", pping_hdr-&gt;common_hdr.type, pping_hdr-&gt;common_hdr.code);return;}if (pping_hdr-&gt;id != (__u16)GetCurrentProcessId()) {printf("other process ping response packet, pid=%d\n", GetCurrentProcessId());return;}__u32 timestamp = 0;memcpy(&amp;timestamp, reinterpret_cast&lt;__u32*&gt;((__u8*)pping_hdr + sizeof(ping_hdr)), sizeof(__u32));in_addr from;from.s_addr = ip_hdr-&gt;saddr;printf("%d bytes from %s, time &lt; %d ms, icmp_seq = %d, TTL = %d \n", packet_size - ip_hdr_len - sizeof(ping_hdr),inet_ntoa(from),now - timestamp,pping_hdr-&gt;seq,ip_hdr-&gt;ttl);}int main(int argc, char**argv){rtc::FlagList::SetFlagsFromCommandLine(&amp;argc, argv, true);if (FLAG_h) {rtc::FlagList::Print(NULL, false);return 1;}char *hostname = argv[argc - 1];if (!hostname || strlen(hostname) == 0) {printf("Invalid host name\n");return 1;}if (FLAG_l &lt;= 4) {return 1;}WSADATA wsaData;WORD wVersionRequested = MAKEWORD(2, 2);WSAStartup(wVersionRequested, &amp;wsaData);sockaddr_in from;int from_len = sizeof(sockaddr_in);sockaddr_in dest;memset(&amp;dest, 0, sizeof(sockaddr_in));dest.sin_family = AF_INET;dest.sin_addr.s_addr = inet_addr(hostname);// resolve host nameif (dest.sin_addr.s_addr == INADDR_NONE) {unsigned long begin_time = rtc::Time32();struct addrinfo* result = nullptr;struct addrinfo hints = { 0 };hints.ai_family = AF_UNSPEC;hints.ai_flags = AI_ADDRCONFIG;int ret = getaddrinfo(hostname, nullptr, &amp;hints, &amp;result);if (ret != 0) {printf("Resolve host name failed, error code = %d\n", ret);return 1;}unsigned long end_time = rtc::Time32();struct addrinfo* cursor = result;printf("------------------------------\n");printf("Resolve [time &lt; %d ms]: \n", end_time - begin_time);bool flag = false;for (; cursor; cursor = cursor-&gt;ai_next) {sockaddr_in *paddr_in = reinterpret_cast&lt;sockaddr_in *&gt;(cursor-&gt;ai_addr);printf("%s\n", inet_ntoa(paddr_in-&gt;sin_addr));if (!flag) {dest.sin_addr = paddr_in-&gt;sin_addr;flag = true;}}freeaddrinfo(result);printf("-------------------------------\n");}printf("Ping %s [TTL %d]: \n", inet_ntoa(dest.sin_addr), FLAG_i);// socket函数需要管理员权限// 需要绕开管理员权限，可以使用IcmpSendEcho系列函数//SOCKET s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);if (s == INVALID_SOCKET) {printf("create socket failed, error code = %d\n", WSAGetLastError());WSACleanup();return 1;}int err = setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_s), sizeof(FLAG_s));RTC_DCHECK(err != SOCKET_ERROR);if (err == SOCKET_ERROR) {printf("setsockopt for SO_SNDTIMEO failed, error code = %d\n", WSAGetLastError());closesocket(s);WSACleanup();return 1;}err = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_w), sizeof(FLAG_w));RTC_DCHECK(err != SOCKET_ERROR);if (err == SOCKET_ERROR) {printf("setsockopt for SO_RCVTIMEO failed, error code = %d\n", WSAGetLastError());closesocket(s);WSACleanup();return 1;}err = setsockopt(s, IPPROTO_IP, IP_TTL, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_i), sizeof(FLAG_i));RTC_DCHECK(err != SOCKET_ERROR);if (err == SOCKET_ERROR) {printf("setsockopt for IP_TTL failed, error code = %d\n", WSAGetLastError());closesocket(s);WSACleanup();return 1;}// ping requestint icmp_packet_size = sizeof(ping_hdr)+ FLAG_l; // data__u8 *icmp_packet = new __u8[icmp_packet_size];RTC_DCHECK(icmp_packet);// ping response__u16 ip_packet_size = icmp_packet_size + 20; // 20 bytes ip header, no option.__u8 *ip_packet = new __u8[ip_packet_size];RTC_DCHECK(ip_packet);if (!icmp_packet || !ip_packet) {closesocket(s);WSACleanup();return 1;}__u16 i = 0;while (true) {if (i == 0xFFFF)i = 0;i++;if (!FLAG_t) {if(i &gt; 4)break;}FillPingPacket(icmp_packet, i, icmp_packet_size);int sent = sendto(s, reinterpret_cast&lt;const char*&gt;(icmp_packet), icmp_packet_size,0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;dest), sizeof(sockaddr));if (sent == SOCKET_ERROR) {int gle = WSAGetLastError();if (gle == WSAETIMEDOUT) {printf("request timeout\n");continue;}else {printf("ping %s failed, error code = %d\n", inet_ntoa(dest.sin_addr), gle);break;}}if (sent &lt; FLAG_l) {printf("warning, sent %d bytes\n", sent);}int bread = recvfrom(s, reinterpret_cast&lt;char*&gt;(ip_packet),ip_packet_size, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;from), &amp;from_len);if (bread == SOCKET_ERROR) {int gle = WSAGetLastError();if (gle == WSAETIMEDOUT) {printf("receive timeout\n");continue;}else {printf("ping %s failed, error code = %d\n", inet_ntoa(dest.sin_addr), gle);break;}}if (bread &lt; ip_packet_size) {printf("too few bytes from %s\n", inet_ntoa(from.sin_addr));continue;}DecodeIPPacket(reinterpret_cast&lt;__u8*&gt;(ip_packet), ip_packet_size);Sleep(1000);}delete [] icmp_packet;delete [] ip_packet;if (s != INVALID_SOCKET) {closesocket(s);}WSACleanup();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h4><p><img src="https://static.1key.run/blog/img/wangluoxieyi-icmp-5.jpg"></p><h2 id="2-2-Tracert"><a href="#2-2-Tracert" class="headerlink" title="2.2 Tracert"></a>2.2 Tracert</h2><p>Tracert是windows系统提供的一个工具，使用该程序可以让我们看到IP数据报从一台主机到另一台主机所经过的路由器。Linux系统也提供了类似的工具，叫traceroute，功能和Tracert一样。</p><h3 id="2-2-1-Tracert原理"><a href="#2-2-1-Tracert原理" class="headerlink" title="2.2.1 Tracert原理"></a>2.2.1 Tracert原理</h3><p>在介绍Tracert的原理之前，需要先弄清楚IP首部TTL字段的含义，IP报文每经过一个路由器，路由器都会将该IP报文首部的TTL字段减1，<br>当路由器收到一份IP数据报的TTL是0或1时，路由器此时不会转发该数据报，而会丢弃该数据报，并且给IP数据报首部中的源地址发送一份ICMP超时报文。</p><blockquote><p>IP首部的定义见：<a href="/2023/06/20/wang-luo-xie-yi-3-ip-xie-yi/" title="网络协议(3)--IP协议">网络协议(3)--IP协议</a></p></blockquote><p>Tracert利用了路由器会丢弃TTL为1或0的数据报且返回ICMP超时报文的特性，来实现侦测路由的功能。Tracert程序先发送TTL值为1的IP数据报，处理这份数据报的第一个路由器将TTL减1，丢弃该数据报并返回ICMP超时报文，这样程序就得到了第一个路由器的地址，以此方式，递增IP数据报TTL的值，直到数据报最终到达目标主机。</p><p><strong>那么怎么判断数据报到达了最终的目标主机呢？</strong><br>我们不能单纯的通过未收到路由器返回的ICMP差错报文的方式来判断数据报到达目的地了，因为有可能我们由于接收ICMP差错报文超时等原因导致我们收不到ICMP差错报文（这也是为什么我们后面会介绍每一个TTL跃点会发送3次或多次请求的原因）。windows平台的tracert与linux平台的traceroute的实现原理稍有不同，判断数据报到达目标主机的方式也有不同。<br>tracert是通过发送ping包，因为windows系统内核都实现了ping功能，所以如果目的主机收到了ping请求就会回复相应的ping包，tracert就是通过这种方式来判断数据报是否到达了目标主机。而traceroute是通过发送UDP包（UDP端口选择一个不可能使用的UDP端口，比如大于30000的端口），因为目的主机没有监听该端口，所以不会响应接收到的该UDP请求，因此当UDP包到达时，目标主机会返回“端口不可达”的错误，traceroute就是通过该错误来判断UDP包到达了目的主机。</p><p>从实现方式来看，traceroute通过UDP的方式来实现更加稳定可靠，因为大多数主机的防火墙会组织ICMP报文，而不会阻止UDP报文。</p><p>下图使用wireshark抓取的<code>tracert 192.168.3.76</code>命令的数据包，从图中可以看到tracert是通过发送ping包来实现的，以及每个ping包的TTL递增过程：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-icmp-6.jpg"></p><h3 id="2-2-2-ICMP差错报文格式"><a href="#2-2-2-ICMP差错报文格式" class="headerlink" title="2.2.2 ICMP差错报文格式"></a>2.2.2 ICMP差错报文格式</h3><p>路由器在丢弃TTL为0或1的数据报时，会发送一个一份ICMP差错报文，该ICMP的差错报文的type为11, code为0.</p><p>type为11的报文格式如下（code有0和1两种，格式一样）：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-icmp-7.jpg"></p><h3 id="2-2-3-实现"><a href="#2-2-3-实现" class="headerlink" title="2.2.3 实现"></a>2.2.3 实现</h3><p>该示例和之前的Ping程序的示例有所不同，该示例设置了<code>IP_HDRINCL</code>选项来自己构造IP头部。</p><p>程序的启动参数使用webrtc的<code>"rtc_base/flags.h"</code>实现。</p><p>代码中的其他某些功能，如断言、时间戳等基于webrtc的<code>rtc_base</code>实现，这些功能也可以很方便的自己实现。 </p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;WinSock2.h&gt;#include &lt;ws2spi.h&gt;#include &lt;ws2tcpip.h&gt;#include &lt;strsafe.h&gt;#include &lt;algorithm&gt;#include "rtc_base/networkprotocolheader.h"#include "rtc_base/checks.h"#include "rtc_base/flags.h"#include "rtc_base/timeutils.h"DECLARE_bool(h); // 帮助DECLARE_int(m);  // 最大跃点数DECLARE_int(w);  // 等待每次回复的超时时间(毫秒)DECLARE_int(s);  // 发送ICMP包超时时间(毫秒)DECLARE_int(n);  // 每个跃点发送的请求数DEFINE_bool(h, false, "帮助");DEFINE_int(m, 30, "最大跃点数");DEFINE_int(w, 3000, "等待每次回复的超时时间(毫秒)");DEFINE_int(s, 3000, "发送ICMP包超时时间(毫秒)");DEFINE_int(n, 3, "每个跃点发送的请求数");const int kPingDataSize = 36;__u32 kLocalIP = 0;__u32 GetLocalIPv4Address() {return inet_addr("192.168.42.26");char hostname[MAX_PATH] = { 0 };gethostname(hostname, MAX_PATH);struct hostent FAR* lpHostEnt = gethostbyname(hostname);if (lpHostEnt == NULL) {return htonl(0x7f000001); //127.0.0.1}LPSTR lpAddr = lpHostEnt-&gt;h_addr_list[0];struct in_addr addr;memcpy(&amp;addr, lpAddr, 4);return addr.s_addr;}std::string IPv4ToString(__u32 ip) {in_addr addr;addr.s_addr = ip;char *p= inet_ntoa(addr);if (p)return p;return "";}std::string GetPrintString(const char* fmt, ...) {char buf[100];va_list arglist;va_start(arglist, fmt);StringCchVPrintfA(buf, 100, fmt, arglist);va_end(arglist);return buf;}bool print_ip(__u32* ips, int count, __u32 dest_ip) {bool has_ip = false;bool trace_end = false;for (int i = 0; i &lt; count; i++) {if (ips[i] != 0) {printf("  %s", IPv4ToString(ips[i]).c_str());has_ip = true;trace_end = (ips[i] == dest_ip);}}if (!has_ip)printf("  timeout");printf("\n");if (trace_end)printf("Trace Complete\n");return trace_end;}void FillRequestIPPacket(__u8* ip_packet, __u16 ip_packet_size, __u16 seq, __u8 ttl, __u32 dest_addr) {RTC_DCHECK(ip_packet);iphdr* p_iphdr = reinterpret_cast&lt;iphdr*&gt;(ip_packet);memset(p_iphdr, 0, sizeof(iphdr));p_iphdr-&gt;version = 4;p_iphdr-&gt;ihl = sizeof(iphdr)/4; // no optionp_iphdr-&gt;tos = 0;p_iphdr-&gt;frag_off = 0;p_iphdr-&gt;id = (__u16)rtc::Time32();p_iphdr-&gt;ttl = ttl;p_iphdr-&gt;protocol = IPPROTO_ICMP;p_iphdr-&gt;tot_len = ip_packet_size;p_iphdr-&gt;daddr = dest_addr;p_iphdr-&gt;saddr = kLocalIP;p_iphdr-&gt;check = rtc::GetCheckSum(reinterpret_cast&lt;__u16*&gt;(p_iphdr), p_iphdr-&gt;ihl*4);ping_hdr* p_ping_hdr = reinterpret_cast&lt;ping_hdr*&gt;(ip_packet + p_iphdr-&gt;ihl*4);p_ping_hdr-&gt;common_hdr.type = 8;p_ping_hdr-&gt;common_hdr.code = 0;p_ping_hdr-&gt;id = (__u16)GetCurrentProcessId();p_ping_hdr-&gt;seq = seq;// fill some junk in the buffer.if (kPingDataSize &gt; 0)memset((void*)((__u8*)p_ping_hdr+sizeof(ping_hdr)), 'E', kPingDataSize);p_ping_hdr-&gt;common_hdr.check = 0;p_ping_hdr-&gt;common_hdr.check = rtc::GetCheckSum(reinterpret_cast&lt;__u16*&gt;(p_ping_hdr), ip_packet_size - p_iphdr-&gt;ihl*4);}// return source ip addressbool DecodeIPPacket(const __u8* ip_packet, __u16 ip_packet_size, __u32 send_time, __u32* src_addr) {const iphdr* ip_hdr = reinterpret_cast&lt;const iphdr*&gt;(ip_packet);__u32 use_time = rtc::Time32() - send_time;__u16 ip_hdr_len = ip_hdr-&gt;ihl * 4; // bytesconst icmp_common_hdr *icmp_hdr = reinterpret_cast&lt;const icmp_common_hdr*&gt;(ip_packet + ip_hdr_len);if (icmp_hdr-&gt;type == 0 &amp;&amp; icmp_hdr-&gt;code == 0) { // 回显应答const ping_hdr *p_ping_hdr = reinterpret_cast&lt;const ping_hdr*&gt;(icmp_hdr);if (p_ping_hdr-&gt;id != (__u16)GetCurrentProcessId()) {printf("other process ping response packet, pid=%d\n", GetCurrentProcessId());return false;}printf("%-10s", GetPrintString("&lt;%d ms", use_time == 0 ? 1 : use_time).c_str());*src_addr = ip_hdr-&gt;saddr;return true;}else if (icmp_hdr-&gt;type == 11 &amp;&amp; icmp_hdr-&gt;code == 0) { // cause by ttl == 0printf("%-10s", GetPrintString("&lt;%d ms", use_time == 0 ? 1 : use_time).c_str());*src_addr = ip_hdr-&gt;saddr;return true;}else {printf("unexpected response, type=%d, code=%d\n", icmp_hdr-&gt;type, icmp_hdr-&gt;code);return false;}}#define SAFE_RELEASE \if (req_ip_packet) { \delete[] req_ip_packet; \req_ip_packet = NULL;\}\if (rsp_ip_packet) { \delete[] rsp_ip_packet; \rsp_ip_packet = NULL;\}\if (s != INVALID_SOCKET) {\closesocket(s);\s = INVALID_SOCKET;\}\WSACleanup();int main(int argc, char**argv) {rtc::FlagList::SetFlagsFromCommandLine(&amp;argc, argv, true);if (FLAG_h) {rtc::FlagList::Print(NULL, false);return 1;}char *hostname = argv[argc - 1];if (!hostname || strlen(hostname) == 0) {printf("Invalid host name\n");return 1;}printf("Trace %s\n", hostname);WSADATA wsaData;WORD wVersionRequested = MAKEWORD(2, 2);WSAStartup(wVersionRequested, &amp;wsaData);sockaddr_in from;int from_len = sizeof(sockaddr_in);kLocalIP = GetLocalIPv4Address();sockaddr_in dest;memset(&amp;dest, 0, sizeof(sockaddr_in));dest.sin_family = AF_INET;dest.sin_addr.s_addr = inet_addr(hostname);// resolve host nameif (dest.sin_addr.s_addr == INADDR_NONE) {unsigned long begin_time = rtc::Time32();struct addrinfo* result = nullptr;struct addrinfo hints = { 0 };hints.ai_family = AF_UNSPEC;hints.ai_flags = AI_ADDRCONFIG;int ret = getaddrinfo(hostname, nullptr, &amp;hints, &amp;result);if (ret != 0) {printf("Resolve host name failed, error code = %d\n", ret);return 1;}unsigned long end_time = rtc::Time32();struct addrinfo* cursor = result;printf("------------------------------\n");printf("Resolve [time &lt; %d ms]: \n", end_time - begin_time);bool flag = false;for (; cursor; cursor = cursor-&gt;ai_next) {sockaddr_in *paddr_in = reinterpret_cast&lt;sockaddr_in *&gt;(cursor-&gt;ai_addr);printf("%s\n", inet_ntoa(paddr_in-&gt;sin_addr));if (!flag) {dest.sin_addr = paddr_in-&gt;sin_addr;flag = true;}}freeaddrinfo(result);printf("-------------------------------\n");}printf("Tracing %s [%d max hops]: \n", inet_ntoa(dest.sin_addr), FLAG_m);SOCKET s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);if (s == INVALID_SOCKET) {printf("create socket failed, error code = %d\n", WSAGetLastError());WSACleanup();return 1;}int err = setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_s), sizeof(FLAG_s));RTC_DCHECK(err != SOCKET_ERROR);if (err == SOCKET_ERROR) {printf("setsockopt for SO_SNDTIMEO failed, error code = %d\n", WSAGetLastError());closesocket(s);WSACleanup();return 1;}err = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_w), sizeof(FLAG_w));RTC_DCHECK(err != SOCKET_ERROR);if (err == SOCKET_ERROR) {printf("setsockopt for SO_RCVTIMEO failed, error code = %d\n", WSAGetLastError());closesocket(s);WSACleanup();return 1;}int opt = 1;err = setsockopt(s, IPPROTO_IP, IP_HDRINCL, reinterpret_cast&lt;const char*&gt;(&amp;opt), sizeof(opt));RTC_DCHECK(err != SOCKET_ERROR);if (err == SOCKET_ERROR) {printf("setsockopt for IP_HDRINCL failed, error code = %d\n", WSAGetLastError());closesocket(s);WSACleanup();return 1;}// ip packet for ping request.__u16 req_ip_packet_size = sizeof(iphdr) + sizeof(ping_hdr) + kPingDataSize;__u8 *req_ip_packet = new __u8[req_ip_packet_size];memset(req_ip_packet, 0, req_ip_packet_size);// ip packet for icmp response or ping echo.__u16 rsp_ip_packet_size = // ICMP差错报文的大小sizeof(iphdr)+ sizeof(icmp_common_hdr)  // ICMP(type=11,code=0或1)差错报文+ 4 // unused+ sizeof(iphdr) + 8;//取ping包大小和ICMP差错报文大小的最大值，保证无论返回哪种报文缓冲区都够用，//也可以直接分配一个足够大的缓冲区，如1024//rsp_ip_packet_size = std::max(rsp_ip_packet_size, req_ip_packet_size);__u8 *rsp_ip_packet = new __u8[rsp_ip_packet_size];memset(rsp_ip_packet, 0, rsp_ip_packet_size);RTC_DCHECK(rsp_ip_packet);int ttl = 1;int seq = 0;__u32 *ips = new __u32[FLAG_n];for(int hop = 1; hop &lt;= FLAG_m; hop++) {printf(" %-4d", hop);for (int i = 0; i &lt; FLAG_n; i++) {ips[i] = 0;seq++;FillRequestIPPacket(req_ip_packet, req_ip_packet_size, seq, ttl, dest.sin_addr.s_addr);__u32 send_time = rtc::Time32();int sent = sendto(s,reinterpret_cast&lt;const char*&gt;(req_ip_packet),req_ip_packet_size,0,reinterpret_cast&lt;const sockaddr*&gt;(&amp;dest),sizeof(sockaddr));if (sent == SOCKET_ERROR) {printf("%-10s", "*");if (i == FLAG_n - 1)if (print_ip(ips, FLAG_n, dest.sin_addr.s_addr)) {SAFE_RELEASE;return 0;}continue;}int bread = recvfrom(s,reinterpret_cast&lt;char*&gt;(rsp_ip_packet),rsp_ip_packet_size,0,reinterpret_cast&lt;sockaddr*&gt;(&amp;from),&amp;from_len);if (bread == SOCKET_ERROR) {int gle = WSAGetLastError();printf("%-10s", "*");if (i == FLAG_n - 1)if (print_ip(ips, FLAG_n, dest.sin_addr.s_addr)) {SAFE_RELEASE;return 0;}continue;}__u32 dest_ip = 0;DecodeIPPacket(reinterpret_cast&lt;const __u8*&gt;(rsp_ip_packet), rsp_ip_packet_size, send_time, &amp;dest_ip);ips[i] = dest_ip;if (i == FLAG_n - 1)if (print_ip(ips, FLAG_n, dest.sin_addr.s_addr)) {SAFE_RELEASE;return 0;}}ttl++;}SAFE_RELEASE;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-4-运行效果："><a href="#2-2-4-运行效果：" class="headerlink" title="2.2.4 运行效果："></a>2.2.4 运行效果：</h3><p><img src="https://static.1key.run/blog/img/wangluoxieyi-icmp-8.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICMP </tag>
            
            <tag> Ping </tag>
            
            <tag> Tracert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《拨开字符编码的迷雾》专栏</title>
      <link href="/2023/06/21/bo-kai-zi-fu-bian-ma-de-mi-wu-zhuan-lan/"/>
      <url>/2023/06/21/bo-kai-zi-fu-bian-ma-de-mi-wu-zhuan-lan/</url>
      
        <content type="html"><![CDATA[<p>本专栏从字符编码的基础概念开始，一步步理清在开发过程中遇到的各种编码问题，从此告别编码、乱码的烦恼。</p><p>文章列表：</p><ul><li><a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-1-zi-fu-bian-ma-gai-shu/" title="拨开字符编码的迷雾(1)--字符编码概述">拨开字符编码的迷雾(1)--字符编码概述</a></li><li><a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-2-bian-yi-qi-chu-li-wen-jian-bian-ma/" title="拨开字符编码的迷雾(2)--编译器处理文件编码">拨开字符编码的迷雾(2)--编译器处理文件编码</a></li><li><a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-3-zi-fu-bian-ma-zhuan-huan/" title="拨开字符编码的迷雾(3)--字符编码转换">拨开字符编码的迷雾(3)--字符编码转换</a></li><li><a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-4-mysql-zi-fu-bian-ma/" title="拨开字符编码的迷雾(4)--MySQL字符编码">拨开字符编码的迷雾(4)--MySQL字符编码</a></li><li><a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-5-qt-zi-fu-bian-ma/" title="拨开字符编码的迷雾(5)--Qt字符编码">拨开字符编码的迷雾(5)--Qt字符编码</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(3)--IP协议</title>
      <link href="/2023/06/20/wang-luo-xie-yi-3-ip-xie-yi/"/>
      <url>/2023/06/20/wang-luo-xie-yi-3-ip-xie-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><p>IP协议是TCP/IP协议族中最核心的协议。所有的TCP、UDP、ICMP、IGMP数据都以IP数据报的格式传输。</p><p>IP协议是不可靠、无连接的：</p><ul><li><p><code>不可靠</code>表示IP协议不能保证IP数据报能成功的到达目的地。IP仅提供传输服务，任何可靠性的要求都必须由上层来提供（如TCP）。如果传输过程发生错误，IP协议简单的丢弃该数据报，然后发送ICMP消息给发送端。</p></li><li><p><code>无连接</code>表示IP协议不维护任何关于后续数据报的状态信息，每个数据报都是相互独立的。这也说明，IP数据报可能不是按照发送顺序被接收到的，很有可能后发送的数据被先收到。</p></li></ul><h2 id="一、IP首部"><a href="#一、IP首部" class="headerlink" title="一、IP首部"></a>一、IP首部</h2><p>IP数据报的格式如图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-ip-1.jpg"></p><ul><li><p>4位版本：标识目前采用的IP协议的版本号。IPv4为0100, IPv6为0110</p></li><li><p>4位首部长度：用于标识首部的长度，单位为<strong>4字节</strong>，所以首部的最大长度为<code>15*4字节=60字节</code>。</p></li><li><p>8位服务类型：包括3bit的优先权字段（已被忽略），4bit的TOS字段，1bit的始终为0的未使用位。</p></li><li><p>16位总长度(字节数)：整个IP数据报的长度。数据报中<code>数据内容的长度=总长度 - 首部长度</code></p></li><li><p>16位标识：唯一地标识主机发送的每一份数据报。IP数据报的最大长度可达65535字节，但大多数链路层都会对它进行分片。由于TCP本身会把用户数据分成若干片，因此这个字段一般来说不会影响到TCP。</p></li><li><p>3位标志：用于IP数据报分片。该字段第1bit不使用，第2bit是DF(<code>Don't Fragment</code>)位，DF位设为1时表明IP不对该数据包分片。第3bit是MF(<code>More Fragments</code>)位，当对数据包分片时，除了最后一片外，其他每个组成数据报的片都要把此位设为1。</p></li><li><p>13位偏移：用于IP数据报分片。单位为8字节。表示该片相对于原始数据报开始处的位置，能表示的最大偏移为$2^{13}$*8=65536字节。</p></li></ul><blockquote><p>另外，数据报被分片之后，每个片的总长度要更改为该片的长度值。IP层分片是透明的，但是即使只丢失一片数据也要重传整个数据报，因为IP层本身没有超时重传的机制。</p></blockquote><ul><li><p>8位生存时间(TTL)：设置数据报可以经过的最多路由器数量，每经过一个路由器，该值就减去1。当该值为0时，数据报就被丢弃。通常初始值为32或64.</p></li><li><p>8位协议：表示上层传输层所用的协议类型。1表示ICMP协议，2表示IGMP协议，6表示TCP协议，17表示UDP协议。</p></li><li><p>16位首部校验和：用于对IP首部的正确性进行校验，但不包括数据部分，这点不同于TCP和UDP的首部校验和。</p></li><li><p>32位源IP地址：发送端的32bit的IP地址。</p></li><li><p>32位目的IP地址：接收端的32bit的IP地址。</p></li><li><p>选项：可变长度的可选信息。如果首部不含“选项字段”，则IP首部长度为20字节。</p></li></ul><h2 id="二、IP首部校验和"><a href="#二、IP首部校验和" class="headerlink" title="二、IP首部校验和"></a>二、IP首部校验和</h2><ul><li>发送端对IP数据报的校验和的计算步骤：</li></ul><ol><li>把IP数据报的校验和字段置为0；</li><li>把首部看成以16位为单位的数字组成，依次进行二进制反码求和；</li><li>把求和得到的结果取反。</li><li>将第2、3步得到的2个字节数据存入首部校验和。</li></ol><ul><li>接收端对IP数据报的校验和的校验步骤：</li></ul><ol><li>把首部看成以16位为单位的数字组成，依次进行二进制反码求和；</li><li>把求和得到的结果取反码。</li><li>如果结果为0，则表示检验和校验通过，IP报文没有被修改过。</li></ol><h2 id="三、使用代码计算校验和"><a href="#三、使用代码计算校验和" class="headerlink" title="三、使用代码计算校验和"></a>三、使用代码计算校验和</h2><p>通过wireshark抓取一帧数据报，如图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-ip-2.jpg"></p><p>以该数据报的IP首部为基础，使用C++代码来验证IP首部校验和的计算步骤和校验步骤：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;assert.h&gt;// GetChecksum函数用于实现上面所说的计算步骤中的第2步、第3步：// 把首部看成以16位（2字节）为单位的数字组成，依次进行二进制反码求和，// 但实际的算法实现上需要考虑取和溢出时的改进计算方法（见函数内部注释）//unsigned short GetChecksum(unsigned short* ip_header, int size) {assert(sizeof(unsigned short) == 2);// 为什么使用unsigned long（4字节）？// 因为虽然首部校验和只占16位（2个字节），但执行“以16位（2字节）为单位的二进制反码数据”求和操作得到的checksum可能会超过16位（2字节），// 所以这里用4个字节的unsigned long来接收相加得到的结果，后面再进行处理。//unsigned long checksum = 0;while (size &gt; 1) {checksum += *ip_header; // 因为都是正数，所以反码与原码相同；故直接相加求和ip_header++; // ip_header为unsigned short类型的指针每次按2个字节相加size -= 2;}// 执行到这：checksum = 0x2850c// IP首部如果不包含“选项”字段，则为20字节，偶数；如果包含了“选项”，则字节数就可能为奇数了，// 这里针对字节数为奇数的情况进行处理。// 注：示例main函数中构造的ip_header不含有“选项”//if (size == 1) {checksum += *(unsigned char*)ip_header;}// 因为上面相加之后的结果大于2个字节，所以执行额外的处理步骤：// checksum &gt;&gt; 16 右移16位// 即除以2的16次方（0xffff），就是去除右边的2个字节，如：0x2850c &gt;&gt; 16 = 0x2//// checksum &amp; 0xffff 位运算，得到后2个字节// 如：0x2850c &amp; 0xffff = 0x850c//// checksum = 0x2 + 0x850c = 0x850e//checksum = (checksum &gt;&gt; 16) + (checksum &amp; 0xffff);// 假如还大于2个字节，再次将多余的字节和checksum相加。checksum += (checksum &gt;&gt; 16);// 求和得到的结果的取反return (unsigned short)(~checksum);}int main(){// 将上面wirkshark抓的数据包的IP头部，使用char数组，按字节构造出来//unsigned char ip_header[20] = {0x45, // 4位版本+4位首部长度0x00, // 8位服务类型（TOS）0x00, 0x1c,  // 16位总长度（字节数）0x50, 0xaa,  // 16位标识0x00, 0x00,  // 3位标志+13位片偏移0xff, // 8位生存时间（TTL）0x01, // 8位协议0xf1, 0x7a, // 16位首部校验和0xc0, 0xa8, 0x2e, 0x55, // 32位源IP地址0xee, 0x73, 0x9c, 0x4a  // 32位目的IP地址};// 第1步：把IP数据包的校验和字段置为0；//ip_header[10] = 0x00;ip_header[11] = 0x00;// 第2、3步计算校验和//unsigned short checksum = GetChecksum((unsigned short*)ip_header, sizeof(ip_header));printf("%02hhx %02hhx\n", *(char*)(&amp;checksum), *((char*)(&amp;checksum) + 1));// 第4步：将第2、3步得到的2个字节数据存入首部校验和//ip_header[10] = *(char*)(&amp;checksum);ip_header[11] = *((char*)(&amp;checksum) + 1);// 模拟接收到IP包之后，对IP首部的校验和进行校验//unsigned short checksum_check = GetChecksum((unsigned short*)ip_header, sizeof(ip_header));if (checksum_check == 0) {printf("checksum check successful!\n");}else {printf("checksum check failed!\n");}    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、IP校验和的设计原理"><a href="#四、IP校验和的设计原理" class="headerlink" title="四、IP校验和的设计原理"></a>四、IP校验和的设计原理</h2><p>我们将IP首部进行简化来讲解IP校验和的设计原理，假设IP首部只有6个字节，第5,6字节存放校验和：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-ip-3.jpg"></p><p>计算校验和时第5,6字节置为0，校验和等于：A+B+0，然后取反，即：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-ip-4.jpg"></p><p>接收端收到之后校验步骤为：求校验和（不同的是：校验和位不置0），若此时求得校验和为0，则校验通过。即：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-ip-5.jpg"></p><h2 id="五、IP地址相关操作"><a href="#五、IP地址相关操作" class="headerlink" title="五、IP地址相关操作"></a>五、IP地址相关操作</h2><p>本节介绍在网络编程中涉及到的与IP地址相关的操作</p><h3 id="struct-in-addr"><a href="#struct-in-addr" class="headerlink" title="struct in_addr"></a>struct in_addr</h3><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">// sizeof(in_addr) == sizeof(ULONG) == 4//typedef struct in_addr {        union {                struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b;                struct { USHORT s_w1,s_w2; } S_un_w;                ULONG S_addr;   // 4个字节，按网络字节序列存储                // 可以使用inet_addr函数将IP格式字符串转为网络字节序列的整数。        } S_un;// 定义的一些宏，方便访问结构体成员#define s_addr  S_un.S_addr /* can be used for most tcp &amp; ip code */#define s_host  S_un.S_un_b.s_b2    // host on imp#define s_net   S_un.S_un_b.s_b1    // network#define s_imp   S_un.S_un_w.s_w2    // imp#define s_impno S_un.S_un_b.s_b4    // imp ##define s_lh    S_un.S_un_b.s_b3    // logical host} IN_ADDR, *PIN_ADDR, FAR *LPIN_ADDR;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="struct-sockaddr-in"><a href="#struct-sockaddr-in" class="headerlink" title="struct sockaddr_in"></a>struct sockaddr_in</h3><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">// sizeof(sockaddr_in) == 16struct sockaddr_in {        short   sin_family;        u_short sin_port;        struct  in_addr sin_addr;        char    sin_zero[8];};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="struct-sockaddr"><a href="#struct-sockaddr" class="headerlink" title="struct sockaddr"></a>struct sockaddr</h3><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">// sizeof(sockaddr) == 16//struct sockaddr {        u_short sa_family;              /* address family */        char    sa_data[14];            /* up to 14 bytes of direct address */};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-转换函数"><a href="#5-1-转换函数" class="headerlink" title="5.1 转换函数"></a>5.1 转换函数</h3><blockquote><p>webrtc中的<code>IPAddress</code>类和<code>SocketAddress</code>类，对网络地址的操作进行了很好的封装，值得参考。</p></blockquote><h4 id="5-1-1-IP字符串-gt-整数"><a href="#5-1-1-IP字符串-gt-整数" class="headerlink" title="5.1.1 IP字符串 -> 整数"></a>5.1.1 IP字符串 -&gt; 整数</h4><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">unsigned long inet_addr(  _In_ const char *cp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将类似<code>127.0.0.1</code>这样的IP字符串转换为网络字节序列的整数</p><h4 id="5-1-2-整数-gt-IP字符串"><a href="#5-1-2-整数-gt-IP字符串" class="headerlink" title="5.1.2 整数 -> IP字符串"></a>5.1.2 整数 -&gt; IP字符串</h4><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">char* FAR inet_ntoa(  _In_ struct   in_addr in);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将in_addr（也可以理解为网络字节序列整数）转换为IP字符串。</p><h3 id="5-2-字节序列转换"><a href="#5-2-字节序列转换" class="headerlink" title="5.2 字节序列转换"></a>5.2 字节序列转换</h3><pre class="line-numbers language-none"><code class="language-none">htonshtonlntohsntohlhtonllntohll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对整数（short、long、longlong）进行网络字节序列和主机字节序列间的转换操作。<br>以htons为例：<br><code>h</code>是host的首字母，表示主机字节序列；<br><code>n</code>是network的首字母，表示网络字节序列；<br><code>s</code>代表short；<br>所以htons的功能是，将short从主机字节序列转为网络字节序列。</p><blockquote><p>字节序列可以参考：<a href="http://blog.csdn.net/china_jeffery/article/details/78401731">http://blog.csdn.net/china_jeffery/article/details/78401731</a></p></blockquote><h3 id="5-3-获取本机IP地址"><a href="#5-3-获取本机IP地址" class="headerlink" title="5.3 获取本机IP地址"></a>5.3 获取本机IP地址</h3><h4 id="5-3-1-使用gethostbyname"><a href="#5-3-1-使用gethostbyname" class="headerlink" title="5.3.1 使用gethostbyname"></a>5.3.1 使用gethostbyname</h4><p>这种方式有一个弊端：只能获取一个网卡的IP地址。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">unsigned long GetLocalIPv4Address() {char hostname[MAX_PATH] = { 0 };gethostname(hostname, MAX_PATH);struct hostent FAR* lpHostEnt = gethostbyname(hostname);if (lpHostEnt == NULL) {return htonl(0x7f000001); //127.0.0.1}LPSTR lpAddr = lpHostEnt-&gt;h_addr_list[0];struct in_addr addr;memcpy(&amp;addr, lpAddr, 4);return addr.s_addr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-2-使用GetAdaptersInfo"><a href="#5-3-2-使用GetAdaptersInfo" class="headerlink" title="5.3.2 使用GetAdaptersInfo"></a>5.3.2 使用GetAdaptersInfo</h4><p>该方式可以获取本机多块网卡的信息（不限于IP地址）。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;windows.h&gt;#include &lt;Iphlpapi.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#pragma comment(lib,"Iphlpapi.lib")bool GetLocalAddress(std::vector&lt;std::string&gt; &amp;ip_list) {PIP_ADAPTER_INFO pIpAdapterInfo = new IP_ADAPTER_INFO();unsigned long stSize = sizeof(IP_ADAPTER_INFO);int nRet = GetAdaptersInfo(pIpAdapterInfo, &amp;stSize);if (ERROR_BUFFER_OVERFLOW == nRet) {delete pIpAdapterInfo;pIpAdapterInfo = (PIP_ADAPTER_INFO)new BYTE[stSize];nRet = GetAdaptersInfo(pIpAdapterInfo, &amp;stSize);}if (ERROR_SUCCESS != nRet) {if (pIpAdapterInfo) {delete pIpAdapterInfo;}return false;}while (pIpAdapterInfo) {IP_ADDR_STRING *pIpAddrString = &amp;(pIpAdapterInfo-&gt;IpAddressList);switch (pIpAdapterInfo-&gt;Type) {case MIB_IF_TYPE_OTHER:case MIB_IF_TYPE_ETHERNET:case MIB_IF_TYPE_TOKENRING:case MIB_IF_TYPE_FDDI:case MIB_IF_TYPE_PPP:case MIB_IF_TYPE_LOOPBACK:case MIB_IF_TYPE_SLIP: {std::string address = pIpAddrString-&gt;IpAddress.String;if ("0.0.0.0" == address)break;ip_list.push_back(address);break;}default:break;}pIpAdapterInfo = pIpAdapterInfo-&gt;Next;}if (pIpAdapterInfo) {delete pIpAdapterInfo;}return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>《TCP/IP详解 卷1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP </tag>
            
            <tag> 校验和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(2)--ARP和RARP协议</title>
      <link href="/2023/06/20/wang-luo-xie-yi-2-arp-he-rarp-xie-yi/"/>
      <url>/2023/06/20/wang-luo-xie-yi-2-arp-he-rarp-xie-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一、ARP协议"><a href="#一、ARP协议" class="headerlink" title="一、ARP协议"></a>一、ARP协议</h1><h2 id="1-1-ARP协议介绍"><a href="#1-1-ARP协议介绍" class="headerlink" title="1.1 ARP协议介绍"></a>1.1 ARP协议介绍</h2><p><code>ARP</code>(<code>Address Resolution Protocol</code>)地址解析协议，位于TCP/IP协议栈中的链路层。当局域网内主机间（或者是主机与网关间）需要通信时，通过使用<code>ARP协议</code>获取<code>目标IP地址</code>对应的<code>硬件MAC地址</code>，然后主机间通过该<code>硬件MAC地址</code>完成数据包发送和接收。<br>具体过程如下：</p><ol><li>本地主机在局域网中<code>广播</code>ARP请求，ARP请求数据帧中包含目的主机的IP地址。意思是“如果你是这个IP地址的拥有者，请回答你的硬件MAC地址”。</li><li>目的主机的ARP层解析这份<code>广播</code>报文，识别出是询问其硬件地址。于是发送（<code>单播</code>）ARP应答包，里面包含IP地址及其对应的硬件地址。</li><li>本地主机收到ARP应答后，知道了目的地址的硬件地址，之后的数据报就可以传送了。</li></ol><p><img src="https://static.1key.run/blog/img/wangluoxieyi-arp-1.jpg"></p><h2 id="1-2-ARP缓存"><a href="#1-2-ARP缓存" class="headerlink" title="1.2 ARP缓存"></a>1.2 ARP缓存</h2><p>如果像上面说的那样，每次发包之前都要发送ARP请求硬件地址会不会太慢，但是实际上ARP的运行是非常高效的。那是因为每一个主机上都有一个ARP高速缓存，我们可以通过命令<code>arp -a</code>获取本机ARP高速缓存的所有内容：</p><pre class="line-numbers language-none"><code class="language-none">λ arp -a接口: 192.168.42.26 --- 0xb  Internet 地址         物理地址              类型  192.168.1.1           00-00-00-00-00-ff     静态  192.168.40.1          f8-75-88-c2-df-c1     动态  192.168.40.74         c8-5b-76-86-c6-06     动态  192.168.40.245        38-d5-47-e1-8a-2f     动态  192.168.42.131        60-a4-4c-65-9f-68     动态  224.14.51.28          01-00-5e-0e-33-1c     静态  224.19.133.150        01-00-5e-13-85-96     静态  224.49.6.212          01-00-5e-31-06-d4     静态  224.50.134.225        01-00-5e-32-86-e1     静态  224.68.111.100        01-00-5e-44-6f-64     静态  224.80.154.130        01-00-5e-50-9a-82     静态  224.88.174.75         01-00-5e-58-ae-4b     静态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过命令<code>arp -d</code>清除arp缓存内容。</p><h2 id="1-3-ARP缓存生存周期"><a href="#1-3-ARP缓存生存周期" class="headerlink" title="1.3 ARP缓存生存周期"></a>1.3 ARP缓存生存周期</h2><p>在默认情况下，Windows Server 2003家族和Windows XP中，ARP缓存中的表项仅存储2分钟。如果一个ARP缓存表项在2分钟内被用到，则其期限再延长2分钟，直到最大生命期限10分钟为止。超过10分钟的最大期限后，ARP缓存表项将被移出，并且通过另外一个ARP请求来获得新的对应关系。</p><p>ARP缓存表项的存放时间可以通过改变<code>ArpCacheLife</code>和<code>ArpCacheMinReferencedLife</code>的注册表值来重新设置。</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Tcpip/Parameters键值：ArpCacheLife，设置未被使用的ARP缓存表项可以被保持的时间，类型为Dword，单位为秒，默认值为120。ArpCacheMinReferencedLife，设置被重复使用的表项可以在ARP缓存中存放的时间，类型为Dword，单位为秒，默认值为600。ArpCacheMinReferencedLife和ArpCacheLife的值的使用方法如下：如果ArpCacheLife &gt;= ArpCacheMinReferencedLife，则被使用和未被使用的ARP缓存表项可存储的时间都是ArpCacheLife。如果ArpCacheLife &lt; ArpCacheMinReferencedLife，则未被使用的ARP缓存表项在ArpCacheLife秒的时间后就过期了，被使用的表项的生存期为ArpCacheMinReferencedLife秒。注意：这些键值默认是不存在的，如果你想修改，必须自行创建；修改后重启计算机后生效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-ARP帧格式"><a href="#1-3-ARP帧格式" class="headerlink" title="1.3 ARP帧格式"></a>1.3 ARP帧格式</h2><p><img src="https://static.1key.run/blog/img/wangluoxieyi-arp-2.jpg"></p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">以太网目的地址：目的主机的硬件地址。目的地址全为1的特殊地址是广播地址。以太网源地址：源主机的硬件地址。帧类型：对于ARP协议，该字段为0x0806。对于RARP协议，该字段为0x8035。硬件类型：表示硬件地址的类型。值为1时表示以太网地址。ARP协议不仅仅应用于以太网协议，还可以支持别的链路层协议。协议类型：表示要映射的协议地址类型。值为0x0800时表示IP协议。硬件地址长度：与硬件类型对应的硬件地址的长度，以字节为单位。如果是以太网，则是6字节（MAC长度）。协议地址长度：与协议类型对应的协议地址长度，以字节为单位。如果是IP协议，则是4字节（IP地址长度）。操作类型（op）：四种操作类型。ARP请求（1），ARP应答（2），RARP请求（3），RARP应答（4）。发送端硬件地址：如果是以太网，则是源主机以太网地址，此处和以太网头中的源地址对应。发送端协议地址：如果是IP协议，则表示源主机的IP地址。目的端硬件地址：如果是以太网，则是目的以太网地址，和以太网头中的目的地址对应。目的端协议地址：如果是IP协议，则表示源主机要请求硬件地址的IP地址。对应ARP请求包来说，目的端的硬件地址字段无须填充，其他字段都需要填充。对于ARP回复包来说，所有字段都需要填充。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4-ARP欺骗"><a href="#1-4-ARP欺骗" class="headerlink" title="1.4 ARP欺骗"></a>1.4 ARP欺骗</h2><p>ARP欺骗一般目的是通过某种方式把自己伪装成网关，从而欺骗目标机器，使本应发送到真实网关的数据包发送到欺骗者的机器。</p><p>现有如下网络：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-arp-3.jpg"></p><h4 id="1-4-1-如何伪装成网关？"><a href="#1-4-1-如何伪装成网关？" class="headerlink" title="1.4.1 如何伪装成网关？"></a>1.4.1 如何伪装成网关？</h4><p>我们以主机A请求<code>www.csdn.net</code>网站为例，涉及到ARP的主要流程如下：</p><ol><li><p>主机A通过浏览器打开<code>www.csdn.net</code>（假设通过DNS得到的IP是<code>47.95.163.175</code>），然后组装需要发送http请求包。</p></li><li><p>主机A准备根据默认路由（网关）将数据包发送给<code>192.168.0.1</code>, 但是最开始的时候主机A不知道 <code>192.168.0.1</code> 的MAC地址, 所以主机A广播一条ARP请求, 询问 <code>192.168.0.1</code> 的 MAC地址。</p></li><li><p>路由器（网关）收到该 ARP 请求, 发现自己是 192.168.0.1 于是向主机 A 回复一条 ARP应答包, 告诉主机 A 192.168.0.1 的 MAC 地址是 xxxGW.</p></li><li><p>主机 A 收到该ARP响应包, 并向该响应包中的 MAC 地址发送一个Http请求包。</p></li><li><p>路由器（网关）收到该 Http请求包, 发现目标 IP 是公网 IP, 便将该包放送到公网, 公网返回Http应答包给路由器（网关）。</p></li><li><p>路由器（网关）准备将Http响应包发送给<code>192.168.0.100</code>, 但是同第2步, 路由器最开始的时候也不知道 <code>192.168.0.100</code> 的MAC地址是多少, 所以路由器会广播一条ARP请求, 询问 192.168.0.100 的MAC地址是多少。</p></li><li><p>主机A收到ARP请求, 发现自己是<code>192.168.0.100</code>, 于是向路由器回复一个ARP应答包, 告诉路由器<code>192.168.0.100</code> 的 MAC地址是 xxxA.</p></li><li><p>路由器（网关）收到ARP应答包, 并使用该APR应答包中的MAC地址将第5步收到Http响应包发送出去。</p></li></ol><p>试想，如果现在主机B做了如下2件事情会有什么后果：</p><ol><li>主机B不停的向主机A发送ARP应答包, 告诉路由器（网关）192.168.0.1 的MAC地址是 xxxB, 会发生什么?</li><li>主机B不停的向路由器（网关）发送 ARP应答包, 告诉主机A 192.168.0.100的MAC是 xxxB, 会发生什么?</li></ol><p>如果主机B做了上面说的两件事的, 那么主机A访问网络的所有数据都会先经过主机 B, 并且从网关发送到主机A的数据也都会经过B, 至此, 整个ARP欺骗完成。</p><p>但是，如果欺骗者机器不对这些数据包作处理，当被欺骗数据包到达后就会被本机丢弃（因为自己到底不是网关，还不知道如何处理这类数据包），这当然是不允许的。这时开启IP转发功能可以解决该问题，IP转发负责把该类数据包再转发给真正的网关处理，开启IP转发的方法：</p><pre class="line-numbers language-none"><code class="language-none">sysctl net.ipv4.ip_forward=1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-4-2-arpspoof使用"><a href="#1-4-2-arpspoof使用" class="headerlink" title="1.4.2 arpspoof使用"></a>1.4.2 arpspoof使用</h4><p>在Ubuntu或Kali等系统上有<code>arpspoof</code>工具可以轻松实现ARP欺骗的整个流程。</p><pre class="line-numbers language-none"><code class="language-none">arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host参数：-i 指定用攻击机的哪个网络接口，可以使用ifconfig命令查看攻击机接口列表。-c own|host|both-t 指定arp攻击的目标。如果不指定，则目标为该局域网内的所有机器。可以指定多个目标，如：arpspoof -i etho -t 192.168.32.100 -t 192.168.32.101-r host 希望拦截攻击机和哪个host之间的通信，一般都是网关。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、RARP协议"><a href="#二、RARP协议" class="headerlink" title="二、RARP协议"></a>二、RARP协议</h1><p>RARP协议（Reverse Address Resolution Protocol），反向地址转换协议，也叫逆地址解析协议，主要被那些没有磁盘驱动器的系统使用，如无盘工作站等。</p><p>具有本地磁盘的系统引导时，一般是从磁盘中的配置文件读取IP地址。但是无盘机，如无盘工作站，则需要采用其他方法获取ip地址。<br>网络上的每个系统都具有唯一的硬件地址，它是由网络接口生产厂家配置的。无盘系统的RARP实现过程是从网卡上读取唯一的硬件地址，然后发送RARP请求到RARP服务器，请求该主机在无盘系统的IP地址。</p><p><img src="https://static.1key.run/blog/img/wangluoxieyi-arp-4.jpg"></p><blockquote><p>文章参考：<a href="https://segmentfault.com/a/1190000009562333">https://segmentfault.com/a/1190000009562333</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARP </tag>
            
            <tag> RARP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(1)--基础概念</title>
      <link href="/2023/06/20/wang-luo-xie-yi-1-ji-chu-gai-nian/"/>
      <url>/2023/06/20/wang-luo-xie-yi-1-ji-chu-gai-nian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一、TCP-x2F-IP协议栈"><a href="#一、TCP-x2F-IP协议栈" class="headerlink" title="一、TCP/IP协议栈"></a>一、TCP/IP协议栈</h1><p><img src="https://static.1key.run/blog/img/wangluoxieyi-jichugailian-1.jpg"></p><h1 id="二、IP地址、子网掩码、网关"><a href="#二、IP地址、子网掩码、网关" class="headerlink" title="二、IP地址、子网掩码、网关"></a>二、IP地址、子网掩码、网关</h1><h2 id="2-1-IP地址及分类"><a href="#2-1-IP地址及分类" class="headerlink" title="2.1 IP地址及分类"></a>2.1 IP地址及分类</h2><p>IP地址相当于互联网上的门牌号, 计算机在启动的时候可以从磁盘（无盘系统例外）上读取该主机的IP配置。IP地址由4个字节（也就是32位）的二进制码组成，包含了<code>网络号( net-id )</code>和<code>主机号( host-id )</code>。但现实中，我们经常还需要再继续划分<code>“子网”</code>，这时就需要借用主机号的一部分充任子网号，这样IP地址也就可以看成由<code>标准网络号、子网号、主机号</code>3部分组成的了，即<code>IP地址=标准网络号+子网号+主机号</code>。</p><blockquote><p>网络号、子网号、主机号三者间的关系，形象的描述如下：假设你的住址IP是<code>武汉市文治街16号</code>，那么，<br>IP地址 = 武汉市文治街16号<br>网络号 = 武汉市<br>子网号 = 文治街<br>主机号 = 16号</p></blockquote><table><thead><tr><th>IP地址种类</th><th>二进制组成(前缀位+网络位+主机位)</th><th>IP范围</th><th>网络数</th><th>主机数/网络</th></tr></thead><tbody><tr><td>A类地址</td><td><code>0</code>+7位网络号+24位主机号</td><td>1.0.0.0 - 127.255.255.255</td><td>$2^7-2$</td><td>$2^{24}-2$</td></tr><tr><td>B类地址</td><td><code>10</code>+14位网络号+16位主机号</td><td>128.0.0.0 - 191.255.255.255</td><td>$2^{14}-1$</td><td>$2^{16}-2$</td></tr><tr><td>C类地址</td><td><code>110</code>+21位网络号+8位主机号</td><td>192.0.0.0 - 223.255.255.255</td><td>$2^{21}-1$</td><td>$2^8-2$</td></tr><tr><td>D类地址</td><td><code>1110</code>+多播地址(用于多播)</td><td>224.0.0.0 - 239.255.255.255</td><td>-</td><td>-</td></tr><tr><td>E类地址</td><td><code>1111</code>+保留位(不开放, 保留使用)</td><td>240.0.0.0-249.255.255.255</td><td>-</td><td>-</td></tr></tbody></table><p>从表中可以看出，A类IP的第1位（二进制位）必须是0，所以A类IP的第一个整数的范围是<code>0000 0000 ~ 01111 11111</code>，转换为十进制就是<code>0 ~ 127</code>，以此类推。</p><h3 id="关于网络数的解释"><a href="#关于网络数的解释" class="headerlink" title="关于网络数的解释"></a>关于网络数的解释</h3><p>网络数就是一种网络的子网数, 比如A类地址, 可以分为多少个子网。看表格可以推出网络数的计算公式为: $2^{网络号位数}$。<br>规定网络地址全为<code>0</code>的IP地址是保留地址，意思是“本网络”。</p><ul><li>在A类地址中，实际上 <code>0.0.0.0</code> 是不指派的，而可以指派的最小网络是 <code>1.0.0.0</code>；网络地址为 <code>127</code> 的A类IP地址保留作为本地软件环回测试本主机的进程之间的通信(比如常用的 <code>127.0.0.1</code>，<strong>但实际上网络地址为<code>127</code>的都可以用作本地环回地址</strong>)。所以A类地址网络数为 $2^7-2$。</li><li>在B类地址中，实际上 <code>128.0.0.0</code> 是不指派的，而可以指派的最小网络是 `128.1.0.0，所以B类地址网络数是 $2^{14} - 1$。</li><li>在C类地址中，实际上 <code>192.0.0.0</code> 是不指派的，而可以指派的最小网络是 192.0.1.0，所以C类地址网络数是 $2^{21}-1$。</li></ul><h3 id="关于主机数的解释"><a href="#关于主机数的解释" class="headerlink" title="关于主机数的解释"></a>关于主机数的解释</h3><p>主机数就是一个子网里面可以容纳多少台主机。看表格可以推出主机数的计算公式为: <code>2^主机号位数-2</code>。主机号全为0表示该网络，而主机号全为1表示广播地址，所以要排除掉这两个。比如A类地址 <code>1.0.0.0</code> 表示主机所在的网段的网络地址, <code>1.255.255.255</code> 为该网段的广播地址。</p><h2 id="2-2-私有IP地址"><a href="#2-2-私有IP地址" class="headerlink" title="2.2 私有IP地址"></a>2.2 私有IP地址</h2><p>经常可以看到<code>192.168.1.101</code>这类的IP地址, 这些是私有IP地址, 专用地址, 也就是局域网内使用的的IP地址。<br>公网IP地址是需要向有关部门申请备案的，私有IP地址不用申请, 但是仅限内网使用, 也节约公网IP。</p><table><thead><tr><th>IP地址种类</th><th>私有IP范围</th></tr></thead><tbody><tr><td>A类地址</td><td>10.0.0.0 - 10.255.255.255</td></tr><tr><td>B类地址</td><td>172.16.0.0 - 172.31.255.255</td></tr><tr><td>C类地址</td><td>192.168.0.0 - 192.168.255.255</td></tr></tbody></table><p>路由器看到专用地址就不转发，所以说专用地址作为目的地址是不可能在因特网上传送的。专用IP地址也可叫做可重用地址。那好，问题来了，如果配置了这些专用地址的主机想和因特网上的主机通信，怎么办呢？NAT(network address translation: 网络地址转换)在这种情况下就应运而生了。NAT就是将这种地址转换成有效的外部全球IP地址，使得整个专用网只需要一个全球IP地址就可以与因特网联通。</p><h2 id="2-3-子网掩码"><a href="#2-3-子网掩码" class="headerlink" title="2.3 子网掩码"></a>2.3 子网掩码</h2><p><code>IP地址=标准网络号+子网号+主机号</code>。从IP分类可以很容易确定“标准网络号”，<code>32bit</code>的IP地址除去前面的“标准网络号”之后，剩下的就是“子网号”和“主机号”，那么怎么确定“子网号”和“主机号”了？ 这就需要借助<code>“子网掩码”</code>了。子网掩码也是一个32bit(<code>xxx.xxx.xxx.xxx</code>)的值，其中值为1的bit留给“标准网络号”和“子网号”，为0的bit留给“主机号”。我们可以将子网掩码和IP地址进行二进制<code>“与运算”</code>，通过得到的结果来确定“子网号”。</p><p>以C类IP地址为例，对于规范的C类IP地址来说，规范子网掩码为<code>255.255.255.0</code>，即用32比特IP地址的前24比特标识网络号，后8比特标识主机号。因而，每个C类网络下共可容纳254台主机($2^8-2$)。 如今，我们先思索借用2比特的主机号来充任子网络号的情形。</p><p>C类网络地址<code>210.31.233.0</code>，我们借用2bit的主机号来充当子网号，子网的数目为$2^2-2$(子网号无法全为0或1，所以减2).</p><p><img src="https://static.1key.run/blog/img/wangluoxieyi-jichugailian-2.jpg"></p><p>为了借用原来8位主机号中的前2位充任子网络号，采用了新的非规范子网掩255.255.255.192。<br>采用了新的子网掩码后，借用的2位子网号可以用来标识两个子网：01子网和10子网(子网号无法全为0或1，因而00、11子网无法用)。 </p><p><strong>对于上图的01子网来说</strong>，其网络号的点分十进制的方式为：<code>210.31.233.64</code>，该子网的最小IP地址为：<code>210.31.233.65</code>，最大IP地址为：<code>210.31.233.126</code>（主机号全为1位广播地址），共可容纳62台主机。对该子网的直接广播地址为：<code>210.31.233.127</code>（主机号全为1）。</p><blockquote><p>经常见到像<code>192.168.1.0/24</code>这样的写法，它的意思是网络号为<code>192.168.1.0</code>；子网掩码为24位，即<code>111111111 111111111 111111111 00000000</code>，转为点分十进制就为<code>255.255.255.0</code>，没有借用主机号来充当子网号，可以拥有的主机数为$2^8$-2.</p></blockquote><h2 id="2-3-网关的作用"><a href="#2-3-网关的作用" class="headerlink" title="2.3 网关的作用"></a>2.3 网关的作用</h2><p>你的住址IP是<code>武汉市洪山区文治街16号</code>，你的父母只允许你和文治街的小朋友（同一个子网）一起玩耍，如果你想要去和别的街道（别的子网）的小朋友玩耍，你就需要经过你的父母的同意，由你的父母带你过去，这时候你的父母就充当了<strong>网关</strong>的角色，没有你的父母，你就不能和其他街道（其他子网）的小朋友玩耍。</p><h1 id="三、包的封装与解封装"><a href="#三、包的封装与解封装" class="headerlink" title="三、包的封装与解封装"></a>三、包的封装与解封装</h1><blockquote><p>封装英文：Encapsulation<br>解封装英文：Demultiplexing</p></blockquote><p>当应用程序使用网络传送数据时，数据按照协议栈从上到下的顺序，逐次通过每一层。其中每一层对收到的数据都要增加一些首部信息（有时还增加尾部信息）。最终生成一串比特流通过以太网来传输，我们称这串比特流叫帧。<br>如图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-jichugailian-3.jpg"></p><p><strong>当数据报到达链路层时</strong>，链路层也要对IP数据包封装进行包装。链路层也要对IP数据包封装的方式主要有<code>以太网IP数据包封装</code>（RFC894）、<code>IEEE 802 IP数据报封装</code>（RFC1042）两种，最常使用的封装格式是以太网IP数据包封装（RFC894）。下图显示了这两种不同形式的封装格式：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-jichugailian-4.jpg"><br>从图中可以看到<code>以太网封装</code>限制了数据帧的最大长度为1500字节，这个限制叫做MTU，最大传输单元（详见第四节）。</p><p>接收端收到帧之后，按照和上面相反的顺序（协议栈从下到上）来解包，依次解析每一层加入的头部（或尾部），最终将原始数据传给最上层应用程序。<br>如图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-jichugailian-5.jpg"></p><p>因为传输层的TCP、UDP、ICMP等都有可能向网络层IP协议传送数据，这样在IP协议层解包的时候，需要知道这个包对应的上层协议是哪一个，因此IP协议必须在生成的IP首部加入某种标识，以表明数据的上一层的具体协议。为此，IP在首部中存入了一个长度为8bit的数值，称作协议域。常见的IP协议号有：<br>1表示ICMP协议，2表示IGMP协议，6表示TCP协议，17表示UDP协议。</p><blockquote><p>完整的IP协议号见：<a href="https://zh.wikipedia.org/wiki/IP%E5%8D%8F%E8%AE%AE%E5%8F%B7%E5%88%97%E8%A1%A8">IP协议号列表</a></p></blockquote><h1 id="四、MTU"><a href="#四、MTU" class="headerlink" title="四、MTU"></a>四、MTU</h1><p>前面第三节提到了以太网封装限制了数据帧的长度为1500字节，这个限制是在链路层封装IP数据报时作的。如果IP层的数据报比链路层的这个MTU值大，那么IP层就需要分片（英文：fragmentation），把数据报分成若干片，保证每一片的大小都小于MTU值。</p><h3 id="windows系统修改MTU值"><a href="#windows系统修改MTU值" class="headerlink" title="windows系统修改MTU值"></a>windows系统修改MTU值</h3><ul><li><p>查询当前MTU值</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">netsh interface ipv4 show subinterfaces<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://static.1key.run/blog/img/wangluoxieyi-jichugailian-6.jpg"></p></li><li><p>修改MTU值</p><pre class="line-numbers language-none"><code class="language-none">netsh interface ipv4 set subinterface "本地连接" mtu=1480 store=persistent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><blockquote><p>文章参考：<br><a href="https://m.vipcn.com/a/360973/">https://m.vipcn.com/a/360973/</a><br><a href="https://ahaochan.github.io/posts/IP_address,_subnet_mask,_gateway_Introduction.html">https://ahaochan.github.io/posts/IP_address,_subnet_mask,_gateway_Introduction.html</a><br><a href="https://www.zhihu.com/question/20717354">https://www.zhihu.com/question/20717354</a></p></blockquote><p>《TCP/IP详解 卷1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP地址 </tag>
            
            <tag> 子网掩码 </tag>
            
            <tag> 网关 </tag>
            
            <tag> MTU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解C/C++运行时库</title>
      <link href="/2023/06/20/li-jie-c-c-yun-xing-shi-ku/"/>
      <url>/2023/06/20/li-jie-c-c-yun-xing-shi-ku/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、什么是运行时库"><a href="#一、什么是运行时库" class="headerlink" title="一、什么是运行时库"></a>一、什么是运行时库</h2><p>运行时库（Runtime library）通俗的说就是我们的程序运行的时候所依赖的库文件，在Windows平台这些库由微软提供，并且是以2种形式提供：<code>静态库(lib)</code>、<code>动态库(lib+dll)</code>。每个库还都提供<code>debug</code>、<code>release</code> 2个版本。</p><p>C/C++运行时库从形式上来讲和我们自己开发的静态库、动态库没什么两样，只是它们由微软开发和维护，并提供了一些常用的功能支持（如<code>malloc</code>,<code> free</code>, <code>printf</code>等等），如果我们的程序需要使用这些功能（事实上，只要是C/C++程序就一定会用到运行时库提供的功能），就要链接C/C++运行时库。我们可以自主选择是链接“静态库”还是“动态库”，是链接“debug版本”的还是“release版本”的。</p><h2 id="二、如何链接运行时库"><a href="#二、如何链接运行时库" class="headerlink" title="二、如何链接运行时库"></a>二、如何链接运行时库</h2><p>大家可能注意到我们在平时开发中从来没有显式的来链接这些库，这是为什么了？<br>因为我们的编译器为我们提供了便利，我们只需要向编译器指定特定的编译选项（如<code>MT、MD、MTd、MDd</code>），编译器就会自动链接对应的库。</p><p>同时，编译器会根据<code>MT</code>和<code>MD</code>来定义相应的预处理宏：<code>MT</code> 对应 <code>_MT宏</code>，<code>MD</code>对应<code>_MD宏</code>。</p><p>例如，我们通过<code>Visual Studio</code>开发C/C++程序时，在工程属性中配置“运行库”为<code>MT、MD、MTd、MDd</code>中的一个：<br><img src="https://static.1key.run/blog/img/windows-hxbc-ljynsk-1.jpg"><br>就相当于间接的向编译器指定编译选项和定义相应的宏。</p><h2 id="三、不同版本和形态的运行时库"><a href="#三、不同版本和形态的运行时库" class="headerlink" title="三、不同版本和形态的运行时库"></a>三、不同版本和形态的运行时库</h2><h3 id="3-1-运行时库对应的文件"><a href="#3-1-运行时库对应的文件" class="headerlink" title="3.1 运行时库对应的文件"></a>3.1 运行时库对应的文件</h3><p>下表列出各种编译选项的含义以及对应的库文件：</p><table><thead><tr><th>类型</th><th>全称</th><th>含义</th><th>对应的库文件</th><th>备注</th></tr></thead><tbody><tr><td>ML</td><td>Single-Threaded</td><td>Release版的单线程静态库</td><td><code>libc.lib</code></td><td>从VS2005起被废弃</td></tr><tr><td>MLd</td><td>Single-Threaded Debug</td><td>Debug版的单线程静态库</td><td><code>libcd.lib</code></td><td>从VS2005起被废弃</td></tr><tr><td>MT</td><td>Multi-threaded</td><td>Release版的多线程静态库</td><td><code>libcmt.lib</code></td><td></td></tr><tr><td>MTd</td><td>Multi-threaded Debug</td><td>Debug版的多线程静态库</td><td><code>libcmtd.lib</code></td><td></td></tr><tr><td>MD</td><td>Multi-threaded DLL</td><td>Release版的多线程动态库</td><td><code>msvcrt.lib + msvcrxxx.dll</code> <code>msvcprt.lib+msvcpxxx.dll</code></td><td></td></tr><tr><td>MDd</td><td>Multi-threaded DLL Debug</td><td>Debug版的多线程动态库</td><td><code>msvcrtd.lib + msvcrxxxd.dll</code> <code>msvcprtd.lib + msvcpxxxd.dll</code></td><td></td></tr></tbody></table><p>如果计算机上安装了多个版本的VC++运行环境（或者多个版本的Visual Studio），则相同名称的lib或dll就会存在多份。如<code>msvcrt.lib</code>文件：<br><img src="https://static.1key.run/blog/img/windows-hxbc-ljynsk-2.jpg"></p><h3 id="3-2-运行时库文件命名规则"><a href="#3-2-运行时库文件命名规则" class="headerlink" title="3.2 运行时库文件命名规则"></a>3.2 运行时库文件命名规则</h3><p><code>msvcr100d.dll</code>为例：</p><pre class="line-numbers language-none"><code class="language-none">ms = Microsoftv = Visualc = C Programr = Run-time100 = Versiond = Debug   (不带d即为release版本)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>msvcp100d.dll</code>为例：</p><pre class="line-numbers language-none"><code class="language-none">ms = Microsoftv = Visualcp = C Plus Plus 即C++100 = Versiond = Debug   (不带d即为release版本)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、运行时库使用注意事项"><a href="#四、运行时库使用注意事项" class="headerlink" title="四、运行时库使用注意事项"></a>四、运行时库使用注意事项</h2><ul><li>不要混合使用运行时库的<code>静态库版</code>和<code>动态库版</code>。</li><li>不要混合使用运行时库的<code>debug版</code>和<code>release版</code>。</li><li>不要混合使用Visual Studio 2013 及更早版本的运行时库，但在 Visual Studio 2015 及更高版本中提供的运行时库可以保证二进制兼容。</li></ul><h2 id="五、Visual-Studio-版本之间的-C-二进制兼容性（摘自MSDN）"><a href="#五、Visual-Studio-版本之间的-C-二进制兼容性（摘自MSDN）" class="headerlink" title="五、Visual Studio 版本之间的 C++ 二进制兼容性（摘自MSDN）"></a>五、Visual Studio 版本之间的 C++ 二进制兼容性（摘自MSDN）</h2><p>Visual Studio 2013 及更早版本中的 Microsoft C++ (MSVC) 编译器工具集不保证主版本间的二进制兼容性。 无法链接由这些工具集的不同版本生成的对象文件、静态库、动态库和可执行文件。 ABI、对象格式和运行时库不兼容。</p><p>我们在 Visual Studio 2015 及更高版本中改变了此行为。 由其中任一版本的编译器编译的运行时库和应用具有二进制兼容性。 这反映在 C++ 工具集主版本号中，对于自 Visual Studio 2015 以来的所有版本，<strong>该版本号都以 14 开头</strong>。 （对于 Visual Studio 2015、2017、2019 和 2022，工具集版本分别为 v140、v141、v142 和 v143）。** 假设你具有 Visual Studio 2015 生成的第三方库。 你仍可在 Visual Studio 2017、2019 或 2022 生成的应用程序中使用它们。 无需使用匹配工具集重新编译**。 最新版本的 Microsoft Visual C++ 可再发行程序包（可再发行程序包）适用于所有版本。</p><h3 id="对二进制兼容性的限制"><a href="#对二进制兼容性的限制" class="headerlink" title="对二进制兼容性的限制"></a>对二进制兼容性的限制</h3><p>v140、v141、v142 和 v143 工具集与次要版本号更新之间的二进制兼容性方面存在三个重要限制：</p><ul><li>你可以混合使用由 v140、v141、v142 和 v143 工具集的不同版本生成的二进制文件。 但是，<strong>必须使用至少与应用中最新二进制文件同样新的工具集进行链接</strong>。 下面是一个示例：可以将使用任何 2017 工具集（v141，版本 15.0 到 15.9）编译的应用链接到使用 Visual Studio 2019 版本 16.2 (v142) 编译的静态库。 只是必须使用版本 16.2 或更高版本工具集链接它们。 只要使用 16.4 或更高版本工具集，便可以将版本 16.2 库链接到版本 16.4 应用。</li><li>应用使用的可再发行程序包具有类似的二进制兼容性限制。 混合使用由工具集的不同受支持版本生成的二进制文件时，可再发行程序包版本必须至少与任何应用组件使用的最新工具集一样新。</li><li>使用<a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/gl-whole-program-optimization?view=msvc-170">/GL</a><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/gl-whole-program-optimization?view=msvc-170">（全程序优化）</a>编译器开关编译或是使用 <a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/ltcg-link-time-code-generation?view=msvc-170">/LTCG</a><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/ltcg-link-time-code-generation?view=msvc-170">（链接时间代码生成）</a>链接的静态库或对象文件不在各个版本间二进制兼容（包括次要版本更新）。使用 <code>/GL</code> 和 <code>/LTCG</code> 编译的所有对象文件和库必须将完全相同的工具集用于编译和最终链接。 例如，使用 Visual Studio 2019 版本 16.7 工具集中的 <code>/GL</code>生成的代码无法链接到使用 Visual Studio 2019 版本 16.8 工具集中的 <code>/GL</code>生成的代码。 编译器会发出<a href="https://learn.microsoft.com/zh-cn/cpp/error-messages/compiler-errors-1/fatal-error-c1047?view=msvc-170">错误 C1047</a>。</li></ul><h3 id="从-Visual-Studio-2015-及更高版本升级-Microsoft-Visual-C-可再发行程序包"><a href="#从-Visual-Studio-2015-及更高版本升级-Microsoft-Visual-C-可再发行程序包" class="headerlink" title="从 Visual Studio 2015 及更高版本升级 Microsoft Visual C++ 可再发行程序包"></a>从 Visual Studio 2015 及更高版本升级 Microsoft Visual C++ 可再发行程序包</h3><p>对于 Visual Studio 2015、2017、2019 和 2022，我们使 Microsoft Visual C++ 可再发行程序包主版本号保持相同。 这意味着一次只能安装可再发行程序包的一个实例。 较新版本会覆盖已安装的任何较旧版本。 例如，一个应用可能会从 Visual Studio 2015 安装可再发行程序包。 随后另一个应用从 Visual Studio 2022 安装可再发行程序包。 2022 版本会覆盖较旧版本，但由于它们具有二进制兼容性，早期应用仍可正常工作。 我们确保最新版本的可再发行程序包具有所有最新的功能、安全更新和 bug 修补程序。 这便是为什么我们始终建议升级到最新可用版本。</p><p>同样，已安装了较新版本时，无法安装较旧的可再发行程序包。 如果尝试，则安装程序会报告错误。 如果在已具有 2022 版本的计算机上安装 2017 或 2019 可再发行程序，则会看到如下所示的错误：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">0x80070666 - Another version of this product is already installed. Installation of this version cannot continue. To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此错误是设计使然。 建议保持安装最新版本。 请确保安装程序可以在无提示的情况下从此错误中恢复。</p>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运行时库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(7)--使用std::string跨MT模块传参</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-7-shi-yong-std-string-kua-mt-mo-kuai-chuan-can/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-7-shi-yong-std-string-kua-mt-mo-kuai-chuan-can/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><p>前面的<a href="/2023/06/20/windows-nei-cun-ti-xi-6-kua-mo-kuai-nei-cun-fen-pei-shi-fang/" title="Windows内存体系(6)--跨模块内存分配释放">Windows内存体系(6)--跨模块内存分配释放</a>文章解释了跨MT模块分配的内存相互释放为什么会崩溃的问题。</p><h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>这篇文章主要介绍我们在实际开发中经常遇到的一个问题：针对MT模块定义接口函数时，接口参数使用<code>std::string</code>类型，在程序运行时遇到<code>"Debug Assertioni Failed"</code>错误的问题。<br><img src="https://static.1key.run/blog/img/windows-nctx-stdstring-mt-1.jpg"></p><p>上面的错误提示是<code>debug_heap.cpp</code>文件中的一个调试断言（<code>release模式</code>下调用的是<code>heap.cpp</code>中的分配函数），用于判断指针是否指向堆分配的内存块的第一块。在release模式下不会弹出这样的断言错误，程序可能会直接崩溃（崩溃相对来说还比较好排查），或者出现其他不可预料的、难以排查的错误。</p><h2 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h2><p>现有<code>DLLUser.exe</code>调用<code>DLL.dll</code>中的<code>TestFun</code>函数，代码量非常小：</p><h4 id="DLL-dll中TestFun函数定义："><a href="#DLL-dll中TestFun函数定义：" class="headerlink" title="DLL.dll中TestFun函数定义："></a><code>DLL.dll</code>中<code>TestFun</code>函数定义：</h4><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">DLL_API void TestFun( std::string str){return;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="DLLUser-exe中调用TestFun函数："><a href="#DLLUser-exe中调用TestFun函数：" class="headerlink" title="DLLUser.exe中调用TestFun函数："></a><code>DLLUser.exe</code>中调用<code>TestFun</code>函数：</h4><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">int _tmain(int argc, _TCHAR* argv[]){std::string str = "test";TestFun(str);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码运行之后程序就会弹出错误断言。原因是<code>std::string</code>在进行<code>值传参</code>的过程中会执行一次深拷贝，即：在堆上分配内存块，拷贝“test”到内存块中，然后将临时形参<code>std::string</code>对象传递到dll中，dll中的<code>TestFun</code>函数在作用域结束后对临时形参进行释放时就出现了错误，因为尝试在<code>dll的crt堆</code>中释放由在<code>exe的crt堆</code>中分配的内存块。</p><p><img src="https://static.1key.run/blog/img/windows-nctx-stdstring-mt-2.jpg"></p><h2 id="三、自定义std-allocator解决崩溃"><a href="#三、自定义std-allocator解决崩溃" class="headerlink" title="三、自定义std::allocator解决崩溃"></a>三、自定义<code>std::allocator</code>解决崩溃</h2><p>通过上面问题的分析，加上前面几篇文章对Windows内存体系的介绍，我们不难想出解决方案，其中一种方案就是让<code>std::string</code>统一在进程的默认堆上分配内存块，而不是在各个模块的<code>crt堆</code>上分配。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;windows.h&gt;#include &lt;string&gt;#include &lt;vector&gt;template &lt;typename T&gt;class vm_allocator : public std::allocator&lt;T&gt; {public:typedef size_t size_type;typedef T* pointer;typedef const T* const_pointer;template&lt;typename _Tp1&gt;struct rebind {typedef vm_allocator&lt;_Tp1&gt; other;};pointer allocate(size_type n, const void *hint = 0) {UNREFERENCED_PARAMETER(hint);void* pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, n * sizeof(T));return (pointer)pBuffer;}void deallocate(pointer p, size_type n) {UNREFERENCED_PARAMETER(n);if (p) {HeapFree(GetProcessHeap(), 0, p);}}vm_allocator() throw() : std::allocator&lt;T&gt;() {}vm_allocator(const vm_allocator &amp;a) throw() : std::allocator&lt;T&gt;(a) {}template &lt;class U&gt;vm_allocator(const vm_allocator&lt;U&gt; &amp;a) throw() : std::allocator&lt;T&gt;(a) {}~vm_allocator() throw() {}};typedef std::basic_string&lt;char, std::char_traits&lt;char&gt;, vm_allocator&lt;char&gt; &gt; mystring;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码使用自定义的内存分配器<code>vm_allocator&lt;char&gt;</code>定义了<code>mystring</code>类，我们只需要将<code>TestFun</code>函数接口中的<code>std::string</code>修改为<code>mystring</code>即可解决崩溃问题。</p>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> std::string </tag>
            
            <tag> MT </tag>
            
            <tag> DLL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(6)--跨模块内存分配释放</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-6-kua-mo-kuai-nei-cun-fen-pei-shi-fang/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-6-kua-mo-kuai-nei-cun-fen-pei-shi-fang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><p> <code>《Windows核心编程 第五版》第19章 DLL基础（511页）</code>中给出了一个建议：“当一个MT版本的模块如果提供一个内存分配函数的时候，它必须同时提供另一个用来释放内存的函数。”。说得更加直白一点就是，“对于MT的模块，不要跨模块进行内存释放。”。但是核心编程这本书上面没有具体分析原因，本文就来分析具体的原因。</p><h2 id="一、为什么不同堆分配的内存块不能相互释放？"><a href="#一、为什么不同堆分配的内存块不能相互释放？" class="headerlink" title="一、为什么不同堆分配的内存块不能相互释放？"></a>一、为什么不同堆分配的内存块不能相互释放？</h2><p>Windows的<code>堆管理器</code>对每个进程都维护了多个<code>“堆”</code>，我们从每个<code>“堆”</code>中分配处理的内存块的地址都不一样。所以我们不能将从“堆A”中分配出来的内存块拿到“堆B”中，让“堆B”来释放，这样就会导致程序异常。</p><p><img src="https://static.1key.run/blog/img/windows-nctx-kmkncsf-1.png"></p><p>如上图，通过<code>malloc</code>函数从“堆A”中分配100字节内存块，内存块地址为<code>0x123456</code>；从“堆B”中分配100字节内存块，内存块地址为<code>0x345678</code>.<br>如果将<code>0x123456</code>这个地址拿到“堆B”中去释放，势必会导致异常，因为“堆B”中没有这地址。</p><p>那么我们是不是可以使用<code>HeapFree</code>函数来释放<code>hHeap</code>参数指定的“堆”中的任何内存块了。答案是：不能。<br>回忆前面介绍的<code>HeapFree</code>函数，</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">BOOL HeapFree(  HANDLE hHeap,  DWORD dwFlags,  LPVOID lpMem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数只要求传入了内存块的起始地址指针，但没有要求传入需要释放的内存块的<code>大小</code>，那么该函数是如何知道起始地址指针指向的内存块的大小了？ </p><p>我们可以简单的理解为，<code>HeapAlloc</code>函数每次分配内存块的时候都会额外分配一点空间用于存储一个结构体，该结构体中存储了本次分配的内存块的大小等信息。大致如下图：<br><img src="https://static.1key.run/blog/img/windows-nctx-kmkncsf-2.jpg"></p><p>所以，<code>HeapFree</code>函数首先会通过<code>lpMem</code>指针计算出“结构体”的地址，然后从结构体中获取到分配的内存块的具体大小，最后执行释放操作。</p><p>基于上面的原因，我们不能在<code>HeapFree</code>函数的<code>lpMem</code>参数中传入随意的地址，因为该地址处可能没有存储用于存放内存块信息的结构体，所以释放操作就会失败。<code>free</code>函数也一样，因为<code>free</code>函数内部也是调用的<code>HeapFree</code>函数。</p><h2 id="二、为什么MT模块内存不能相互释放，而MD的却可以？"><a href="#二、为什么MT模块内存不能相互释放，而MD的却可以？" class="headerlink" title="二、为什么MT模块内存不能相互释放，而MD的却可以？"></a>二、为什么MT模块内存不能相互释放，而MD的却可以？</h2><h3 id="我们先分析为什么MT模块的内存间相互释放会崩溃。"><a href="#我们先分析为什么MT模块的内存间相互释放会崩溃。" class="headerlink" title="我们先分析为什么MT模块的内存间相互释放会崩溃。"></a>我们先分析为什么MT模块的内存间相互释放会崩溃。</h3><p>现在有2个模块（<code>A.dll</code>和<code>B.dll</code>）都是使用<code>MT</code>运行时库，即加载的静态库<code>libcmt.lib</code>（可以参考<a href="/2023/06/20/li-jie-c-c-yun-xing-shi-ku/" title="理解C/C++运行时库">理解C/C++运行时库</a>），在<code>A.dll</code>中使用<code>malloc</code>分配100字节的内存，<code>malloc</code>返回的内存地址为<code>0x123456</code>。然后将该地址传给<code>B.dll</code>，在<code>B.dll</code>中调用<code>free</code>函数来释放这个内存。如图：<br><img src="https://static.1key.run/blog/img/windows-nctx-kmkncsf-3.jpg"></p><p>从<a href="/2023/06/20/windows-nei-cun-ti-xi-5-dui/" title="Windows内存体系(5)--堆">Windows内存体系(5)--堆</a>我们知道，DLL在启动代码<code>_DllMainCRTStartup</code>中会建立一个“堆”（堆句柄存放在_crtheap变量中），所以A.dll和B.dll中都会有一个crt堆。</p><p>为了区分，我们将<code>A.dll</code>中的<code>crt堆</code>称作<code>_crtheap_A</code>，<code>B.dll</code>中的<code>crt堆</code>称作<code>_crtheap_B</code>。</p><p>从上面图可以看到，<code>A.dll</code>中<code>malloc</code>的内存拿到<code>B.dll</code>去中去<code>free</code>，就相当于从堆<code>_crtheap_A</code>中分配的内存拿到另一个堆<code>_crtheap_B</code>中的释放。第一节已经解释了为什么不能这样做了。</p><h3 id="现在我们分析为什么MD模块的内存间相互释放不会崩溃。"><a href="#现在我们分析为什么MD模块的内存间相互释放不会崩溃。" class="headerlink" title="现在我们分析为什么MD模块的内存间相互释放不会崩溃。"></a>现在我们分析为什么MD模块的内存间相互释放不会崩溃。</h3><p>还是2个模块（<code>A.dll</code>和<code>B.dll</code>），但是现在他们都是使用<code>MD</code>运行时库，即加载的动态库<code>msvcr100.dll</code>，程序的代码的过程和上面一样，还是在<code>A.dll</code>中使用<code>malloc</code>分配100字节的内存，<code>malloc</code>返回的内存地址为<code>0x123456</code>。然后将该地址传给<code>B.dll</code>，在<code>B.dll</code>中调用<code>free</code>函数来释放这个内存。但是这个时候程序却不会崩溃，通过下面的图我们基本可以明白原因了，如图：<br><img src="https://static.1key.run/blog/img/windows-nctx-kmkncsf-4.jpg"></p><p>因为A、B两个dll都是链接的·msvcr100.dll·，同一个dll在一个进程只会被加载一次，所以进程中只会有一个crt堆（<code>_crtheap</code>），<code>malloc</code>和<code>free</code>都是运行时库提供的函数，所以都会调到运行时库里面去，然后从运行时库里面的<code>_crtheap</code>分配和释放内存块。因为分配和释放都是在同一个堆上，所以不会崩溃。</p>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MT </tag>
            
            <tag> DLL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(5)--堆</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-5-dui/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-5-dui/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、为什么要使用堆-Heap-？"><a href="#一、为什么要使用堆-Heap-？" class="headerlink" title="一、为什么要使用堆 (Heap)？"></a>一、为什么要使用堆 (Heap)？</h2><p>应用程序虽然可以使用页面粒度的函数（如<code>VirualAlloc</code>）来分配一个最小为<code>4KB</code>或<code>8K</code>的内存块，但是很多时候我们并不需要分配这么大的内存块，我们可能只想分配1K，2K的内存块，那么这个时候无论从内存的使用率，还是从性能的角度来看，再分配这么大的一个内存区域显然不是最优的了。</p><p>为了满足这种需求，Windows提供了一个被称为<code>“堆管理器”</code>的组件，它负责管理大内存区域中的内存分配，这些大内存区域就是通过一些页面粒度的内存分配函数（如<code>VirualAlloc</code>）来预定（<code>reserve</code>）的。</p><p>堆管理器中的分配粒度相对比较小：<code>在32位系统上是8字节，在64位系统上是16字节</code>。</p><p>堆管理器已经被windows系统精心设计成：在这些很小的内存分配的情况下进行了内存使用率和性能两个方面的优化。</p><h2 id="二、进程的默认堆"><a href="#二、进程的默认堆" class="headerlink" title="二、进程的默认堆"></a>二、进程的默认堆</h2><p>每个进程至少有一个堆，那就是进程的<code>默认堆</code>。进程的<code>默认堆</code>是在进程启动的时候创建的，而且在进程的生命周期中永远不会被删除。</p><p><code>“默认堆”</code>的默认大小为<code>1MB</code>，但是可以通过<code>/HEAP</code>链接器编译器选项来指定一个更大的起始大小。这个大小值只是初始的保留内存大小，后期根据需要它可以自动扩充。</p><p>应用程序可以调用<code>GetProcessHeap</code>来获取进程的默认堆，也可以通过调用<code>HeapCreate</code>函数来创建额外的私有堆，当一个进程不在需要一个私有堆的时候，它可以调用<code>HeapDestory</code>来释放虚拟地址空间。</p><h2 id="三、crt堆"><a href="#三、crt堆" class="headerlink" title="三、crt堆"></a>三、crt堆</h2><p>C语言的<code>malloc,free</code>函数以及C++的<code>new,delete</code>都是从<code>堆</code>上分配和释放内存的。但是他们所使用的堆不是进程的<code>默认堆</code>，他们使用的是<code>私有堆</code>。可是我们在使用<code>malloc</code>函数之前并有进行任何私有堆的创建操作呀？ 因为<code>malloc</code>函数使用的这个私有堆不需要程序员来创建，而是在C或C++运行时库DLL的启动代码<code>_DllMainCRTStartup</code>中自动创建的。下面通过解析<code>malloc</code>函数的调用过程来说明这一点。</p><p><code>malloc</code>函数的定义在<code>malloc.c</code>文件中，调用流程如下：<br>（以<code>Microsoft Visual Studio 10.0</code>为例，<code>malloc.c</code>文件路径为<code>C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\crt\src</code>）</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">(1). void* __cdecl malloc(size_t const size)(2). void * __cdecl _malloc_base (size_t size)(3). void * __cdecl _heap_alloc (size_t size)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>_heap_alloc </code>的定义如下：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">__forceinline void * __cdecl _heap_alloc (size_t size){    if (_crtheap == 0) {        _FF_MSGBANNER();    /* write run-time error banner */        _NMSG_WRITE(_RT_CRT_NOTINIT);  /* write message */        __crtExitProcess(255);  /* normally _exit(255) */    }    return HeapAlloc(_crtheap, 0, size ? size : 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码中，我们可以看到分配内存块的时候使用的是<code>_crtheap</code>句柄标记的堆。那么<code>_crtheap</code>堆是何时创建的了？</p><p>我们从<code>heapinit.c</code>文件中的<code>_heap_init</code>函数可以看到<code>_crtheap</code>堆的创建过程：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">HANDLE _crtheap=NULL;/****_heap_init() - Initialize the heap**Purpose:*       Setup the initial C library heap.**       NOTES:*       (1) This routine should only be called once!*       (2) This routine must be called before any other heap requests.**Entry:*       &lt;void&gt;*Exit:*       Returns 1 if successful, 0 otherwise.**Exceptions:*       If heap cannot be initialized, the program will be terminated*       with a fatal runtime error.********************************************************************************/int __cdecl _heap_init (void){        ULONG HeapType = 2;        //  Initialize the "big-block" heap first.        if ( (_crtheap = HeapCreate(0, BYTES_PER_PAGE, 0)) == NULL )            return 0;#ifdef _WIN64        // Enable the Low Fragmentation Heap by default on Windows XP and        // Windows Server 2003.  It's the 8 byte overhead heap, and has        // generally better performance charateristics than standard heap,        // particularly for apps that perform lots of small allocations.        if (LOBYTE(GetVersion()) &lt; 6)        {            HeapSetInformation(_crtheap, HeapCompatibilityInformation,                               &amp;HeapType, sizeof(HeapType));        }#endif  /* _WIN64 */        return 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码，我们可以看到，创建的<code>私有堆</code>句柄存放在一个<code>全局的_crtheap变量</code>中，后面每次调用<code>malloc</code>函数都是从该堆分配内存块。</p><h2 id="四、Win32堆函数"><a href="#四、Win32堆函数" class="headerlink" title="四、Win32堆函数"></a>四、Win32堆函数</h2><p>我们最常用的Windows堆函数如下：</p><ul><li><code>HeapCreate</code>或<code>HeapDestory</code> — 创建或删除一个私有堆</li><li><code>HeapAlloc</code> — 分配一个堆内存块</li><li><code>HeapFree</code> — 释放一个原先由<code>HeapAlloc</code>分配的内存块</li><li><code>HeapReAlloc</code> — 增长或缩减一个已分配的内存块的大小</li><li><code>HeapLock</code>或<code>HeapUnLock</code> — 控制堆操作的内存访问</li><li><code>HeapWalk</code> — 列举一个堆内部的内存项和区域。</li></ul><h2 id="五、Windows内存管理API分层结构"><a href="#五、Windows内存管理API分层结构" class="headerlink" title="五、Windows内存管理API分层结构"></a>五、Windows内存管理API分层结构</h2><p><img src="https://static.1key.run/blog/img/windows-nctx-dui-1.gif"></p><p>从上图可以看到，虚拟内存机制（<code>Virtual Memory</code>）是windows内存体系的基础，无论你是使用<code>堆</code>，还是使用<code>内存映射文件</code>，它们的底层都是基于虚拟内存来实现的。</p><p>从上往下，每一层的API在内部会依次调用下一层的API。下图中列举了每层API中经常使用的函数：</p><ul><li><strong>CRT Memory Functions：</strong><code>malloc, free, new, delete</code></li><li><strong>Local, Global Memory API: ** <code>LocalAlloc, GlobalAlloc</code> （</strong>这2个函数现在不建议使用，注意是为了兼容以前的老代码才保留下来的**）</li><li><strong>Heap Memory API：</strong><code>HeapCreate, HeapAlloc, HeapDestory</code></li><li><strong>Virtual Memory API：</strong><code>VirtualAlloc, VirtualFree</code></li><li><strong>Memory Mapped File API：</strong><code>CreateFileMapping, MapViewOfFile, MapViewOfFileEx, UnMapViewOfFile</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> Heap </tag>
            
            <tag> 内存管理API分层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(4)--内存对齐</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-4-nei-cun-dui-qi/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-4-nei-cun-dui-qi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、内存为什么要对齐"><a href="#一、内存为什么要对齐" class="headerlink" title="一、内存为什么要对齐"></a>一、内存为什么要对齐</h2><p>虽然所有的变量都是保存在特定地址的内存中，但最好还是按照内存对齐的要求来存储。这主要出于两个方面的原因考虑： </p><ol><li>平台原因：<br>不是所有的硬件平台(特别是嵌入式系统中使用的低端处理器)都能访问任意地址上的任意数据，某些硬件平台只能访问对齐的地址，否则会出现硬件异常。 </li><li>性能原因：<br>如果数据存放在未对齐的内存空间中，则处理器访问变量时需要进行两次内存访问才能完整读取该变量的值，而对齐的内存访问仅需一次访问。</li></ol><h2 id="二、内存对齐的规则"><a href="#二、内存对齐的规则" class="headerlink" title="二、内存对齐的规则"></a>二、内存对齐的规则</h2><ol><li><p>对于结构（或联合）的各个成员，第一个成员位于偏移为0，以后每个数据成员的偏移量必须是<code>#pragma pack指定的数值和结构体(或联合)中最大数据成员长度 这2个数值中较小的一个</code>的倍数。<br>使用伪代码表示： <code>min(#pragma pack, 结构最大数据成员长度) * N</code></p></li><li><p>在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐也按照<code>#pragma pack指定的数值和结构(或联合)最大数据成员长度这2个数值中较小的一个</code>进行。</p></li></ol><blockquote><p>如果没有使用<code>#pragma pack</code>指令来显式的指定内存对齐的字节数，则按照默认字节数来对齐，各个平台的默认对齐规则如下：<code>32位CPU默认按照4字节对齐；64位CPU默认按照8字节对齐。</code></p></blockquote><h2 id="三、-pragma-pack命令"><a href="#三、-pragma-pack命令" class="headerlink" title="三、#pragma pack命令"></a>三、#pragma pack命令</h2><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#pragma pack(n) // 使用自定义n字节对齐  n可以为1，2，4，8，16#pragma pack()  // 使用缺省字节对齐#pragma pack(show) // 在编译输出窗口以警告的形式显示出当前的内存以几个字节对齐<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="四、结构体内存对齐示例"><a href="#四、结构体内存对齐示例" class="headerlink" title="四、结构体内存对齐示例"></a>四、结构体内存对齐示例</h2><p>在64位系统上编译下面的测试程序，已知在64位系统上各类型占用字节数如下：</p><pre class="line-numbers language-none"><code class="language-none">char     1字节short    2字节int      4字节long     4字节double   8字节long long 8字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例代码如下：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#pragma pack(8)struct A {char s[5];short c;int a;};int main(){int i = sizeof(A);printf("%d", i);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照第二节所讲的内存对齐规则，分析如下：<br>因为结构体中最大的数据成员长度为int（即4字节），而且<code>#pragma pack(8)</code>指令指定按照8字节对齐，所以<code>min(4,8) = 4</code>，故我们可以知道结构体A按照4字节对齐。</p><p>下图是结构体A按照4字节对齐的内存布局（需要注意的是“内存不是填充在s5后面，而是填充在c后面”）：<br><img src="https://static.1key.run/blog/img/windows-nctx-ncdq-1.jpg"></p><p>从图我们很容易知道<code>sizeof(A) = 12</code>.</p>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存对齐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(3)--内存映射文件</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-3-nei-cun-ying-she-wen-jian/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-3-nei-cun-ying-she-wen-jian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一、为什么需要内存映射"><a href="#一、为什么需要内存映射" class="headerlink" title="一、为什么需要内存映射"></a>一、为什么需要内存映射</h1><p><code>“内存映射文件”</code>可以将硬盘上的文件映射到<code>虚拟地址空间</code>，这样就不需要将所有东西都放入到页交换文件中，比如系统有许多程序同时运行时，如果将这些程序文件都加载到页交换文件中，<code>页交换文件</code>将会变得非常大。事实上，Windows也并没有将硬盘上的程序文件复制到<code>页交换文件</code>中，因为这样不仅会让<code>页交换文件</code>将会变得非常大，也会浪费很多时间，特别是可执行程序非常大的时候。</p><p>当用户要求执行一个应用程序时，系统会打开该应用程序的<code>.exe</code>文件，并计算出应用程序的代码和数据的大小，然后系统会在进程的虚拟地址空间预定一块地址空间，并注明与该区域相关联的物理存储器就是<code>.exe</code>文件本身。</p><p>当把一个位于硬盘上的文件（可以是<code>.exe</code>，<code>.dll</code>也可以是普通文件）映像用作地址空间区域对应的物理存储器时，我们称这个文件映像为<code>“内存映射文件”</code>。</p><p>现在我们可以对<a href="/2023/06/20/windows-nei-cun-ti-xi-2-xu-ni-nei-cun/" title="Windows内存体系(2)--虚拟内存">Windows内存体系(2)--虚拟内存</a>第2节的图进行完善了，加入“内存映射文件”部分：<br><img src="https://static.1key.run/blog/img/windows-nctx-ncys-1.png"></p><h1 id="二、内存映射文件技术介绍"><a href="#二、内存映射文件技术介绍" class="headerlink" title="二、内存映射文件技术介绍"></a>二、内存映射文件技术介绍</h1><p>常用的有Win32 API的<code>CreateFile()</code>、<code>WriteFile()</code>、<code>ReadFile()</code>和MFC提供的<code>CFile</code>类都可以实现文件的读写操作。一般来说，以上这些函数可以满足大多数场合的要求，但是对于某些特殊应用领域所需要的动辄几十GB、几百GB、乃至几TB的海量存储，此时在以平常的文件处理方法进行处理显然是行不通的（效率低下，而且内存没那么大）。目前，对于这种大文件的操作一般是以内存映射文件的方式来加以处理的。</p><p>内存映射文件也是Windows的一种内存管理方法，提供了一个统一的内存管理特征，使应用程序可以通过内存指针对磁盘上的文件进行访问。通过文件映射将磁盘文件内容（全部或者部分）与进程虚拟地址空间的某个区域建立映射关联，可以直接对被映射的文件进行访问，而不必执行文件I/O操作也无需对文件内容进行缓冲处理。内存文件映射的这种特性是非常适合于用来管理大尺寸文件的。</p><h1 id="三、大文件读写实例"><a href="#三、大文件读写实例" class="headerlink" title="三、大文件读写实例"></a>三、大文件读写实例</h1><p>通过C++调用系统API实现文件映射的步骤大致如下：<br><img src="https://static.1key.run/blog/img/windows-nctx-ncys-2.jpg"></p><p>本示例首先在<code>D:\</code>生成一个大小为1GB的<code>BigFile.data</code>文件，然后使用内存映射技术将该文件内全部填充字符A，随后读取其中的<code>第20000~20100字节</code>，并将这些字节修改为字符B，然后再次读取已验证是否修改成功。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;windows.h&gt;void Test() {HANDLE file_ = CreateFile(TEXT("D:\\BigFile.data"), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL,NULL);if (file_ == INVALID_HANDLE_VALUE) {printf("CreateFile failed, GLE:%d\n", GetLastError());return;}LARGE_INTEGER filesize;filesize.QuadPart = 1024 * 1024 * 1024; // 1GBHANDLE mapping_ = CreateFileMapping(file_, NULL, PAGE_READWRITE, filesize.HighPart, filesize.LowPart, NULL);if (mapping_ == NULL) {printf("CreateFileMapping failed, GLE:%d\n", GetLastError());return;}LARGE_INTEGER offset;offset.QuadPart = 0;LPVOID mapping_addr = MapViewOfFile(mapping_, FILE_MAP_WRITE | FILE_MAP_READ, offset.HighPart, offset.LowPart, 0);if (mapping_addr == NULL) {printf("MapViewOfFile failed, GLE:%d\n", GetLastError());return;}// 向文件中填充1GB的字符'A'//char buf[1024];for (int i = 0; i &lt; 1024; i++) {buf[i] = 'A';}// 每次填充1024字节，填充1024*1024次for (long l = 0; l &lt; 1024 * 1024; l++) {memcpy((LPVOID)((long)mapping_addr + l * 1024), buf, 1024);}// 填充完毕// 读取第20000~20100字节，共100字节//char read_content[101] = { 0 };memcpy(read_content, (LPVOID)((long)mapping_addr + 20000), 100);printf("%s\n", read_content);// 将第20000~20100字节，共100字节全部修改为字符'B'//char write_content[100];for (int i = 0; i &lt; 100; i++) {write_content[i] = 'B';}memcpy((LPVOID)((long)mapping_addr + 20000), write_content, 100);// 再次读取第20000~20100字节，共100字节，验证修改是成功//memcpy(read_content, (LPVOID)((long)mapping_addr + 20000), 100);printf("%s\n", read_content);UnmapViewOfFile(mapping_addr);CloseHandle(mapping_);CloseHandle(file_);return;}int main(){Test();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存映射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(2)--虚拟内存</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-2-xu-ni-nei-cun/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-2-xu-ni-nei-cun/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、页交换文件"><a href="#一、页交换文件" class="headerlink" title="一、页交换文件"></a>一、页交换文件</h2><p><code>虚拟地址空间</code>只是操作系统为进程“虚拟”出来的一块地址区域，并不代表任何实际的空间。而<code>“页交换文件”</code>却对应了实际的空间，这个空间一般是磁盘上名为<code>“pagefile.sys”</code>的文件。</p><p><code>“页交换文件”</code>的大小和位置可以在系统设置（<code>系统属性 -&gt; 高级 -&gt; 性能 -&gt; 设置 -&gt; 高级</code>  ）中进行设置：<br><img src="https://static.1key.run/blog/img/windows-nctx-xnnc-1.jpg"></p><p>从微软的官方文档来看，<code>“虚拟内存”</code>等于<code>“物理内存”+“分页文件”</code>总和。可以把<code>“虚拟内存”</code>理解为Windows的一种内存管理机制。</p><h2 id="二、虚拟地址空间、页交换文件、物理内存"><a href="#二、虚拟地址空间、页交换文件、物理内存" class="headerlink" title="二、虚拟地址空间、页交换文件、物理内存"></a>二、虚拟地址空间、页交换文件、物理内存</h2><p>虚拟地址空间、页交换文件、物理内存三者的关系如下图：<br><img src="https://static.1key.run/blog/img/windows-nctx-xnnc-2.jpg"></p><p>《Windows核心编程》第13章关于“物理存储器和页交换文件”章节中讲到了“页交换文件、物理存储器之间的数据交换过程”，流程如下：</p><p><img src="https://static.1key.run/blog/img/windows-nctx-xnnc-3.jpg"></p><p>应用程序从进程的虚拟地址空间<code>预定并调拨</code>了一块地址区域时，起初这块区域只是从“页交换文件”中调拨的，这样作有个好处就是：因为还不确定何时才会使用这块区域，如果立即从物理内存调拨，会将占用很多的物理内存。<br>当程序读写该地址区域时，此时就会出现上面图上的页交换文件和物理内存之间的数据交换过程。</p><h2 id="三、将页面锁定在物理内存"><a href="#三、将页面锁定在物理内存" class="headerlink" title="三、将页面锁定在物理内存"></a>三、将页面锁定在物理内存</h2><p>从上面的几节我们知道，当物理内存中没有闲置页面时，系统会将内存中的某些页面的数据写入到交换文件中，从而将该物理内存区域释放出来供后面的程序使用。 </p><p>我们可以通过调用<code>VirtualLock</code>方法，将页面锁定在物理内存中，从而防止虚拟内存管理机制将页面交换至页面文件，而引起不必要的硬盘和物理内存之间的低效页面交换。</p><p>也可以通过调用<code>VirtualUnlock</code>方法解锁页面，允许系统对页面进行交换操作。</p><p>需要注意的是，锁定页面时系统会根据当前可用实际物理内存情况，以及进程工作集配额判定当前最大可锁定的页面的实际数量，超过此数量会引起一个错误。我们可以调用<code>SetProcessWorkingSetSize</code>可以改变一个进程工作集大小的配额，从而可以锁定更多的物理页面。</p><h2 id="四、虚拟内存使用实例"><a href="#四、虚拟内存使用实例" class="headerlink" title="四、虚拟内存使用实例"></a>四、虚拟内存使用实例</h2><p>虚拟内存方面的API属于页面粒度API，通过这些API分配的内存的最小粒度是<code>64KB</code>。这些API分配（调拨）的内存区域最初都是位于<code>“页交换文件”</code>上面，当程序对该区域的某些“页面”（<strong>对虚拟内存的管理以页面为单位进行的</strong>）进行读写时，才会将这些页面交换到物理内存上面。</p><p>从<a href="/2023/06/20/windows-nei-cun-ti-xi-1-xu-ni-di-zhi-kong-jian/" title="Windows内存体系(1)--虚拟地址空间">Windows内存体系(1)--虚拟地址空间</a>中我们知道虚拟地址空间要经过<code>预定</code>和<code>调拨</code>2个步骤之后才能使用，这2个步骤都可以通过<code>VirtualAlloc</code>函数实现：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">LPVOID VirtualAlloc(  LPVOID lpAddress,   DWORD dwSize,   DWORD flAllocationType,   DWORD flProtect ); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当预定或者调拨的空间我们不在需要时，我们需要调用<code>VirtualFree</code>来释放该地址空间：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">BOOL VirtualFree(  LPVOID lpAddress,   DWORD dwSize,   DWORD dwFreeType ); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是的示例演示了在预定、调拨、使用等操作前后，进程的各项内存的占用情况：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#include &lt;windows.h&gt;int main(){SIZE_T size = 1 &lt;&lt; 30; // 1GB// 预定1GB的空间char *pVirtualAddress = (char *)VirtualAlloc(NULL, size, MEM_RESERVE, PAGE_READWRITE);if (pVirtualAddress == NULL) {printf("Reserve 1GB failed.\n");return 1;}// 验证分配粒度是不是64KBint n = (long)pVirtualAddress % (64*1024);if (n == 0) {printf("分配粒度为64K\n");}printf("已经预定1GB\n");getchar(); // 暂停if (VirtualAlloc(pVirtualAddress, size, MEM_COMMIT, PAGE_READWRITE) == NULL) {printf("Commit 1GB failed.\n");return 1;}printf("已经调拨1GB\n");getchar(); // 暂停// 页面大小为4K，访问2560个页面，即2560*4K = 10MB// for (int i = 0; i &lt; 2560; i++) {char * p = pVirtualAddress + i * (4 * 1024);*p = 'A'; // 只访问每个页面的第一个字节}printf("已经使用前10MB\n");getchar(); // 暂停    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在程序运行各个阶段进程的内存情况如下图：（“内存专用工作集”表示占用的物理内存的大小，“提交大小”表示调拨的页交换文件的大小）</p><p><img src="https://static.1key.run/blog/img/windows-nctx-xnnc-4.png"></p>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 页交换文件 </tag>
            
            <tag> 虚拟内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(1)--虚拟地址空间</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-1-xu-ni-di-zhi-kong-jian/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-1-xu-ni-di-zhi-kong-jian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、实模式下内存分配机制"><a href="#一、实模式下内存分配机制" class="headerlink" title="一、实模式下内存分配机制"></a>一、实模式下内存分配机制</h2><p>在8086或者80186以前，程序运行时，操作系统会把程序全都装入内存，程序都是直接运行在物理内存上的。也就是说程序中访问的内存地址都是实际的物理内存地址。当计算机同时运行多个程序时，必须保证这些程序用到的内存总量要小于计算机实际物理内存的大小。</p><p>例如某台计算机总的内存大小是<code>128M</code> ，现在同时运行两个程序 A和B ，A需占用内存<code>10M</code> ， B需占用内存<code>110M</code> 。计算机在给程序分配内存时会采取这样的方法：先将内存中的前<code>10M</code>分配给程序 A ，接着再从内存中剩余的<code>118M</code>中划分出 <code>110M</code>分配给程序B 。这种分配方法虽然可以保证程序A和程序B都能运行，但是这种简单的内存分配策略会导致很多问题：</p><ul><li><p>问题 1 ：进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意但有bug的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。这种情况对用户来说是无法容忍的，因为用户希望使用计算机的时候，其中一个任务失败了，不能影响其它的任务。</p></li><li><p>问题 2 ：内存使用效率低。在 A 和 B 都运行的情况下，如果用户又运行了程序 C ，而程序 C 需要 20M 大小的内存才能运行，而此时系统只剩下 8M 的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序 C 使用，然后再将程序 C 的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。</p></li><li><p>问题 3 ：程序运行的地址不确定。当内存中的剩余空间可以满足程序 C 的要求后，操作系统会在剩余空间中随机分配一段连续的 20M 大小的空间给程序 C 使用，因为是随机分配的，所以程序运行的地址是不确定的。</p></li></ul><hr><h2 id="二、虚拟地址空间介绍"><a href="#二、虚拟地址空间介绍" class="headerlink" title="二、虚拟地址空间介绍"></a>二、虚拟地址空间介绍</h2><p>操作系统让每个进程都有自己的虚拟地址空间（<code>Virtual Address Space</code>，简称<code>VAS</code>）。以32位进程为例，每个进程都有<code>0x00000000 ~ 0xFFFFFFFF</code>(4GB)的虚拟地址空间，所以每个进程都可能分配到<code>0x123456</code>地址的内存，但这个地址不能在进程间相互访问。 </p><p>因为这些都是“虚拟”的地址空间，这些“地址”都不能直接使用，CPU在寻址的时候虽然是按照虚拟地址来寻址的，但是还要通过<code>MMU</code>(内存管理单元)来将虚拟地址转换为物理存储器（如内存等）上的物理地址：</p><p><img src="https://static.1key.run/blog/img/windows-nctx-1.jpg"></p><p>从图上可以看出，进程A和B虽然都有地址<code>0x123456</code>，但它们分别对应的物理地址不一样。</p><hr><p>##三、虚拟地址空间分区<br>进程的虚拟地址空间虽然很大，但是它被划分成了很多分区，供Ring3层应用程序使用的用户模式分区并不大（一半不到），如图：<br><img src="https://static.1key.run/blog/img/windows-nctx-2.jpg"></p><h3 id="3-1-空指针赋值分区"><a href="#3-1-空指针赋值分区" class="headerlink" title="3.1 空指针赋值分区"></a>3.1 空指针赋值分区</h3><p>这一分区的进程地址空间的范围为：[<code>0x00000000</code>, <code>0x0000FFFF</code>]，总大小为<code>64K</code>，保留该分区的目的是为了帮助应用程序员捕获对空指针的赋值。如<code>malloc</code>分配内存失败，就会返回<code>NULL</code>。</p><p>如果进程中的线程试图访问该分区内的内存地址，就会引发访问违规。</p><h3 id="3-2-用户模式分区"><a href="#3-2-用户模式分区" class="headerlink" title="3.2 用户模式分区"></a>3.2 用户模式分区</h3><p>在Windows中，所有的exe和动态链接库都载入到这一区域。系统同时会把该进程可以访问的所有内存映射文件（后面会介绍）映射到这一分区。</p><p>进程无法通过指针来读取、写入、访问其他进程的这一分区，因此一个应用程序破坏另一个应用程序的可能性就非常小了，从而使整个系统更加坚固。</p><h3 id="3-3-内核模式分区"><a href="#3-3-内核模式分区" class="headerlink" title="3.3 内核模式分区"></a>3.3 内核模式分区</h3><p>内核模式分区是操作系统代码的驻地。与线程调度、内存管理、文件系统支持、网络支持以及设备驱动程序相关的代码都会载入到这一分区。该分区内的代码和数据被完全的保护起来了，如果一个应用程序试图读取或写入位于这一分区的内存地址，会引发访问违规。</p><p>驻留在这一分区内的代码为所有进程共有。</p><h2 id="四、虚拟地址空间的使用"><a href="#四、虚拟地址空间的使用" class="headerlink" title="四、虚拟地址空间的使用"></a>四、虚拟地址空间的使用</h2><p>虚拟地址空间的使用涉及到3个概念：<code>页面大小</code>、<code>分配粒度</code>、<code>预定和调拨</code>。</p><h3 id="4-1-页面大小"><a href="#4-1-页面大小" class="headerlink" title="4.1 页面大小"></a>4.1 页面大小</h3><p>虚拟地址空间被分成以<code>“页面”</code>为单位，因为硬件内存管理单元是以<code>页面</code>为粒度将虚拟地址转译成物理地址的。<code>页面</code>的大小根据不同的CPU不而有所不同。x86和x64系统使用的<code>页面</code>大小都是<code>4KB</code>，而IA-64系统使用的<code>页面</code>大小是<code>8KB</code>。</p><blockquote><p>IA-64操作系统只能在INTEL安腾系列处理器及AMD部分服务器处理器运行，所以主流市场并不常见</p></blockquote><p>当<strong>应用程序</strong>在虚拟地址空间分配空间时，系统需要确保分配区域的大小正好是系统<code>页面</code>大小的整数倍。</p><h3 id="4-2-分配粒度"><a href="#4-2-分配粒度" class="headerlink" title="4.2 分配粒度"></a>4.2 分配粒度</h3><p>当<strong>应用程序</strong>在从虚拟地址空间分配空间时，系统会确保所有分配区域的起始地址都是<code>分配粒度</code>的整数倍。<code>分配粒度</code>的会根据不同的CPU平台而有所不同，但目前所有的CPU平台的分配粒度都是使用<code>64KB</code>。也就是说，<code>分配的起始地址 = 64 * N</code>。</p><p>通过Windows的<code>GetSystemInfo</code>函数也可以获得此分配粒度值。</p><blockquote><p>上面所说的<code>分配粒度</code>和<code>页面大小</code>的限制，只是针对于<code>“应用程序”</code>，系统内核自己不存在这样的限制。</p></blockquote><h3 id="4-3-预定和调拨"><a href="#4-3-预定和调拨" class="headerlink" title="4.3 预定和调拨"></a>4.3 预定和调拨</h3><p>虚拟地址空间的使用分为2个步骤：</p><ol><li><p>预定（reserve）：告诉系统我们要从虚拟地址空间<code>预定</code>哪一块区域，系统为我们保留这一块区域。预定的局域的起始地址和大小遵循上面介绍的<code>分配粒度</code>和<code>页面大小</code>的要求。因为预定的只是虚拟地址空间，不占用任何其他物理存储器，所以没有形成实质的开销。</p></li><li><p>调拨（commit）：预定的区域还不能使用，我们还需要为<code>预定</code>的区域从<code>页交换文件</code>中<code>调拨</code>存储器，<code>调拨</code>之后我们才能使用该区域。<br>至于为什么要从<code>页交换文件</code>中调拨存储器？ <code>页交换文件</code>如何与物理内存之间交互？在下一篇文章<a href="/2023/06/20/windows-nei-cun-ti-xi-2-xu-ni-nei-cun/" title="Windows内存体系(2)--虚拟内存">Windows内存体系(2)--虚拟内存</a>中会详细介绍。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实模式 </tag>
            
            <tag> 虚拟地址 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(5)--Qt字符编码</title>
      <link href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-5-qt-zi-fu-bian-ma/"/>
      <url>/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-5-qt-zi-fu-bian-ma/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><p>我们以<code>“测试字符串-보고싶다-Test String.”</code>这个字符串来进行讲解，它包含了英文、中文和韩文。<br>因为我使用Qt的方式是<code>Visual Studio + Qt库</code>的形式，所以本文以<code>Visual Studio</code>的<code>MSVC编译器</code>为例来进行讲解。</p><p>QString中使用QChar来存储每一个字符，QChar是short类型，占2个字节，默认是按Unicode编码存储的。</p><p>首先，为了保证写到代码文件中的测试字符串能被MSVC编译器理解，我们需要将源文件保存为<code>Utf8-带签名</code>的格式。具体参考：<a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-2-bian-yi-qi-chu-li-wen-jian-bian-ma/" title="拨开字符编码的迷雾(2)--编译器处理文件编码">拨开字符编码的迷雾(2)--编译器处理文件编码</a></p><p><strong>QString中存储的字符串的编码格式就是“编译器执行字符集编码格式”。</strong> 这一句话很关键。</p><p>在MSVC中我们可以使用<code>#pragma execution_character_set("utf-8")</code>来指定该源文件的执行字符集编码格式为UTF8格式，这样QString中存储的字符串格式就是utf8编码了。</p><p>下面是完整的测试用例：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">void Demo01::qStringUseCase() {/*该源文件使用Utf8-BOM格式保存.源字符集为UTF8-BOM.可执行字符集为UTF8：#pragma execution_character_set("utf-8") 定义在stdafx.h.*/#define TEST_STR_A "测试字符串-보고싶다-Test String."#define TEST_STR_W L"测试字符串-보고싶다-Test String."{// 因为可执行字符集是utf8，所以使用OutputDebugStringA需要转换成ANSIOutputDebugStringA(Utf8ToAnsi(TEST_STR_A).c_str());}{ui.lblLanguage-&gt;setText(TEST_STR_A);}// char* --&gt; QString{QString qstr = TEST_STR_A;qInfo() &lt;&lt; qstr;}// QString --&gt; char*或std::string{QString qstr = TEST_STR_A;std::string str = qstr.toStdString(); // 不能直接使用qstr.toStdString().c_str()来获取，必须先将qstr.toStdString()存入std::string中const char* pStr = str.c_str();QString qstr2 = QString::fromUtf8(pStr);Q_ASSERT(qstr == qstr2);}// QString --&gt; wchar_t*或std::wstring{QString qstr = TEST_STR_A;std::wstring str = qstr.toStdWString();const wchar_t * pStr = str.c_str();QString qstr2 = QString::fromWCharArray(pStr);Q_ASSERT(qstr == qstr2);}// std::string --&gt; QString{std::string str = TEST_STR_A;  // std::string中存储的是UTF-8编码的字符串，因为可执行字符集为UTF8QString qstr = QString::fromStdString(str);}// std::wstring --&gt; QString{std::wstring str = TEST_STR_W;  // std::wstring中存储的是UTF-8编码的字符串，因为可执行字符集为UTF8QString qstr = QString::fromStdWString(str);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="关于QString-toLocal8Bit"><a href="#关于QString-toLocal8Bit" class="headerlink" title="关于QString::toLocal8Bit"></a>关于QString::toLocal8Bit</h1><p>QString有一个名为<code>toLocal8Bit</code>，网上很多介绍如何解决乱码的文章都会提到这个函数。关于这个函数官方的介绍如下：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Returns the local 8-bit representation of the string as a QByteArray. The returned byte array is undefined if the string contains characters not supported by the local 8-bit encoding.QTextCodec::codecForLocale() is used to perform the conversion from Unicode. If the locale encoding could not be determined, this function does the same as toLatin1().If this string contains any characters that cannot be encoded in the locale, the returned byte array is undefined. Those characters may be suppressed or replaced by another.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单来说，我们可以理解这个函数将字符串转换为的ANSI编码的字符串，通过<a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-1-zi-fu-bian-ma-gai-shu/" title="拨开字符编码的迷雾(1)--字符编码概述">拨开字符编码的迷雾(1)--字符编码概述</a>介绍，我们应该知道<code>ANSI</code>是和具体的代码页相关联的（在Windows中文环境下默认是代码页936）。Qt不是根据系统代码页来做判断的，而是通过<code>QTextCodec</code>来做判断的，所以文档中会提到这个函数需要结合<code>QTextCodec::codecForLocale()</code>来使用，<code>toLocal8Bit</code>根据对应的<code>QTextCodec</code>来做相应的转换。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以要想在使用Qt时，不遇到中文乱码问题，只需要在预编译头文件中加入：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">#pragma execution_character_set("utf-8") <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于部分韩文、日文等其他国家的字符不在Visual Studio默认的中文GB2312编码中，所以如果遇到Visual Studio提示“此文件的某些Unicode字符未能保存到当前代码页中”时，这时选择”<code>Utf8-带签名</code>“格式来保存即可。</p><p>综上所述，源文件保存为<code>Utf8-带签名</code>，且设置<code>#pragma execution_character_set("utf-8") </code>就可以解决所有乱码。</p>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 字符编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(4)--MySQL字符编码</title>
      <link href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-4-mysql-zi-fu-bian-ma/"/>
      <url>/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-4-mysql-zi-fu-bian-ma/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一-MySQL字符集和校对规则"><a href="#一-MySQL字符集和校对规则" class="headerlink" title="一. MySQL字符集和校对规则"></a>一. MySQL字符集和校对规则</h1><p>MySQL的字符集是用来定义MySQL存储字符串的方式，校对规则（有的软件叫排序规则）则是用来定义了比较字符串的方式。字符集和校对规则是一对多的关系。每种字符集都有一个默认校对规则。</p><p><strong>查看数据库支持的字符集:</strong>  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 方法1：</span><span class="token keyword">SHOW</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span><span class="token punctuation">;</span><span class="token comment"># 方法2：</span><span class="token keyword">USE</span> information_schema<span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> CHARACTER_SETS<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看数据库支持的校对规则：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 方法1：</span><span class="token keyword">SHOW</span> COLLATION<span class="token punctuation">;</span><span class="token comment"># 方法2：</span><span class="token keyword">USE</span> information_schema<span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> collations<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二-MySQL各个级别字符集"><a href="#二-MySQL各个级别字符集" class="headerlink" title="二. MySQL各个级别字符集"></a>二. MySQL各个级别字符集</h1><p>MySQL可以对如下字符集进行设置：</p><ul><li>服务器级字符集（CHARACTER_SET_SERVER）</li><li>数据库级字符集（CHARACTER_SET_DATABASE）</li><li>表级字符集</li><li>字段级字符集</li><li>连接字符集（CHARACTER_SET_CONNECTION），客户端连接数据库所用的字符集。</li><li>结果字符集（CHARACTER_SET_RESULTS），存储查询结果（含错误信息）所用的字符集。</li><li>客户端字符集（CHARACTER_SET_CLIENT），客户端发送给MySQL服务器的查询语句字符集。</li><li>系统字符集（CHARACTER_SET_SYSTEM），用于存储我们新建的或自带的数据库的表、列的名称，默认是UTF-8</li></ul><p><code>服务器级、数据库级、表级、字段级</code> 这4个字符集设置影响到数据库中存储数据的编码。 这4个级别的字符集继承关系为：<code>服务器级 --&gt; 数据库级 --&gt; 表级 --&gt; 字段级</code>, 从左到右，一级继承一级，和C++、Java中的类的继承类似，如果某一级未显式的指定字符集，那么将继承上一级的字符集设置。</p><h2 id="2-1-服务器级别字符集设置"><a href="#2-1-服务器级别字符集设置" class="headerlink" title="2.1 服务器级别字符集设置"></a>2.1 服务器级别字符集设置</h2><p>服务器级别的字符集可以从下面几个地方指定，从上到下优先级依次增加：</p><ul><li>编译MySQL时指定的字符集</li><li>my.cnf配置文件设置character-set-server</li><li>mysqld服务启动命令行中指定字符集</li></ul><p>影响数据存储的字符集之间的关系：<br><img src="https://static.1key.run/blog/img/mysql-zfbm-1.jpg"></p><p><strong>查看当前数据库的字符集设置：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 方法1：</span><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'%character%'</span><span class="token punctuation">;</span><span class="token comment"># 方法2：</span><span class="token keyword">USE</span> information_schema<span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> GLOBAL_VARIABLES <span class="token keyword">WHERE</span> VARIABLE_NAME <span class="token operator">LIKE</span> <span class="token string">'%character%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-utf8与utf8mb4区别"><a href="#3-utf8与utf8mb4区别" class="headerlink" title="3. utf8与utf8mb4区别"></a>3. utf8与utf8mb4区别</h1><p>UTF-8是多字节编码方案，采用1~4个字节来存储一个字符，但在MySQL设计之初，一个字符最多采用3个字节的就可以存储，所以Mysql的设计者将MySQL中的UTF-8字符集（UTF-8其实不是字符集，是字符编码方案，但在MySQL中一直这么叫）设计成了最大长度只能为3. 如图：<br><img src="https://static.1key.run/blog/img/mysql-zfbm-2.jpg"></p><p>但随着Unicode字符集的扩张，出现了需要4个字节才能存储的字符，如果这时仍然使用utf-8（指mysql中的3字节utf-8）来存储这些字符就会出现错误，<br>如执行<code>INSERT INTO member(memberName)VALUES('𤭢')</code>报错如下：</p><pre class="line-numbers language-none"><code class="language-none">Warning Code : 1366Incorrect string value: '\xF0\xA4\xAD\xA2' for column 'memberName' at row 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>于是MySQL后来新增了utf8mb4字符集，最大长度为4，兼容之前的utf8，但为了之前的数据库不报错，仍然保留了之前的utf8字符集。 所以MySQL中的UTF-8字符集是伪UTF-8，现在需要使用utf8mb4。</p><h1 id="4-完全避免字符乱码"><a href="#4-完全避免字符乱码" class="headerlink" title="4. 完全避免字符乱码"></a>4. 完全避免字符乱码</h1><p>要完全避免字符乱码，最简单也是最好的方法就是将各个字符集保持一致，可以都设置为utf8mb4。Mysql数据存储涉及到的4个字符集的设置可以使用第2节的方法进行设置，客户端字符集、连接字符集，结果字符集关系到数据显示的正确性，可以使用如下语句统一设置为utf8mb4，但这个设置只针对当前连接有效：</p><pre class="line-numbers language-none"><code class="language-none">set names utf8mb4;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编程开发中，一般使用MySQL API进行数据连接、查询等操作，可以使用<code>mysql_set_character_set</code>对每个连接进行设置，这个API会将客户端字符集、连接字符集，结果字符集都设置为指定字符集，代码大致如下：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">MYSQL* pMysql = NULL;mysql_real_connect(pMysql, szHost, szUser, szPwd, szDatabase, iPort, NULL, CLIENT_MULTI_STATEMENTS);mysql_set_character_set(pMysql, "utf8mb4");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(3)--字符编码转换</title>
      <link href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-3-zi-fu-bian-ma-zhuan-huan/"/>
      <url>/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-3-zi-fu-bian-ma-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="1-Windows-API介绍"><a href="#1-Windows-API介绍" class="headerlink" title="1. Windows API介绍"></a>1. Windows API介绍</h1><p>本文介绍使用Windows API进行字符编码的转换，涉及<code>WideCharToMultiByte</code>和<code>MultiByteToWideChar</code>2个API，<br>API接口名中的<code>MultiByte</code>对应着多字节编码，如ASCII、UTF-8等都是多字节编码，而<code>WideChar</code>字面意思是宽字符，在windows内部宽字符特指UTF-16编码。 </p><p>原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">WideCharToMultiByte</span><span class="token punctuation">(</span>  UINT CodePage<span class="token punctuation">,</span>   DWORD dwFlags<span class="token punctuation">,</span>   LPCWSTR lpWideCharStr<span class="token punctuation">,</span>   <span class="token keyword">int</span> cchWideChar<span class="token punctuation">,</span>   LPSTR lpMultiByteStr<span class="token punctuation">,</span>   <span class="token keyword">int</span> cbMultiByte<span class="token punctuation">,</span>   LPCSTR lpDefaultChar<span class="token punctuation">,</span>   LPBOOL lpUsedDefaultChar <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">MultiByteToWideChar</span><span class="token punctuation">(</span>  UINT CodePage<span class="token punctuation">,</span>   DWORD dwFlags<span class="token punctuation">,</span>   LPCSTR lpMultiByteStr<span class="token punctuation">,</span>   <span class="token keyword">int</span> cbMultiByte<span class="token punctuation">,</span>   LPWSTR lpWideCharStr<span class="token punctuation">,</span>   <span class="token keyword">int</span> cchWideChar <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-API封装"><a href="#2-API封装" class="headerlink" title="2. API封装"></a>2. API封装</h1><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">std::string UnicodeToANSI(const std::wstring &amp;str, UINT iCodePage = CP_ACP) {std::string strRes;int iSize = ::WideCharToMultiByte(iCodePage, 0, str.c_str(), -1, NULL, 0, NULL, NULL);if (iSize == 0)return strRes;char *szBuf = new (std::nothrow) char[iSize];if (!szBuf)return strRes;memset(szBuf, 0, iSize);::WideCharToMultiByte(iCodePage, 0, str.c_str(), -1, szBuf, iSize, NULL, NULL);strRes = szBuf;delete[] szBuf;return strRes;}std::wstring ANSIToUnicode(const std::string &amp;str, UINT iCodePage = CP_ACP) {std::wstring strRes;int iSize = ::MultiByteToWideChar(iCodePage, 0, str.c_str(), -1, NULL, 0);if (iSize == 0)return strRes;wchar_t *szBuf = new (std::nothrow) wchar_t[iSize];if (!szBuf)return strRes;memset(szBuf, 0, iSize * sizeof(wchar_t));::MultiByteToWideChar(iCodePage, 0, str.c_str(), -1, szBuf, iSize);strRes = szBuf;delete[] szBuf;return strRes;}std::string UnicodeToUTF8(const std::wstring &amp;str) {std::string strRes;int iSize = ::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, NULL, 0, NULL, NULL);if (iSize == 0)return strRes;char *szBuf = new (std::nothrow) char[iSize];if (!szBuf)return strRes;memset(szBuf, 0, iSize);::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, szBuf, iSize, NULL, NULL);strRes = szBuf;delete[] szBuf;return strRes;}std::string UnicodeToUTF8BOM(const std::wstring &amp;str) {std::string strRes;int iSize = ::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, NULL, 0, NULL, NULL);if (iSize == 0)return strRes;unsigned char *szBuf = new (std::nothrow) unsigned char[iSize + 3];if (!szBuf)return strRes;memset(szBuf, 0, iSize + 3);if (::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, (LPSTR)(szBuf + 3), iSize, NULL, NULL) &gt; 0) {szBuf[0] = 0xEF;szBuf[1] = 0xBB;szBuf[2] = 0xBF;}strRes = (char*)szBuf;delete[] szBuf;return strRes;}std::wstring UTF8ToUnicode(const std::string &amp;str) {std::wstring strRes;int iSize = ::MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0);if (iSize == 0)return strRes;wchar_t *szBuf = new (std::nothrow) wchar_t[iSize];if (!szBuf)return strRes;memset(szBuf, 0, iSize * sizeof(wchar_t));::MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, szBuf, iSize);strRes = szBuf;delete[] szBuf;return strRes;}std::string ANSIToUTF8(const std::string &amp;str, UINT iCodePage = CP_ACP) {return UnicodeToUTF8(ANSIToUnicode(str, iCodePage));}std::string ANSIToUTF8BOM(const std::string &amp;str, UINT iCodePage = CP_ACP) {return UnicodeToUTF8BOM(ANSIToUnicode(str, iCodePage));}std::string UTF8ToANSI(const std::string &amp;str, UINT iCodePage = CP_ACP) {return UnicodeToANSI(UTF8ToUnicode(str), iCodePage);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于只支持简体中文（部分韩文、日文）的系统，<code>iCodePage</code>可以使用CP_ACP，这时API会使用系统当前的代码页（简体中文系统为CP936，即GBK字符集）来进行编码转换。 但遇到如下情况就需要手动指定代码页：</p><ol><li>需要转换的字符串中的文字是系统当前代码页不支持的。如字符串中含有中文，而当前系统代码页确是英文的；</li><li>GBK字符集中只包含了一部分韩文和日文，部分韩文和日文的转换可以正常转换，若遇到不能转换的情况也需要将指定iCodePage为特定的支持韩文或日文的代码页了，特别是中文和韩文、日文等混合的情况下。如韩文“탉”不包含在GBK中，若这时仍然使用CP_ACP就会得到错误的转换结果<code>?</code>，十六进制<code>3F</code>。但GB18030（代码页为54936）支持“탉”，可以手动指定iCodePage为54936。</li></ol><blockquote><p>如果代码中含有GBK不支持的字符，如“탉”、“𤭢”（念suì）等，Visual Studio会弹出如下提示：<br><img src="https://static.1key.run/blog/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA1MTI5ODIz"><br>选择“以其他编码保存”，选择“Unicode（UTF-8带签名）- 代码页65001”保存。<br>虽然“简体中文（GB18030) - 代码页54936”也支持这些字符，但不能选择该选项进行保存，具体原因在<a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-2-bian-yi-qi-chu-li-wen-jian-bian-ma/" title="拨开字符编码的迷雾(2)--编译器处理文件编码">拨开字符编码的迷雾(2)--编译器处理文件编码</a>中有详细的介绍。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(2)--编译器处理文件编码</title>
      <link href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-2-bian-yi-qi-chu-li-wen-jian-bian-ma/"/>
      <url>/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-2-bian-yi-qi-chu-li-wen-jian-bian-ma/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一-Visual-Studio字符集"><a href="#一-Visual-Studio字符集" class="headerlink" title="一. Visual Studio字符集"></a>一. Visual Studio字符集</h1><p>使用Visual Studio创建的C++工程可以在工程属性<code>配置属性--&gt;常规</code>中配置字符集：<code>使用Unicode字符集</code>（默认）、<code>使用多字节字符集</code>。<br>如图：<br><img src="https://static.1key.run/blog/img/byqrhclzfbm-1.jpg"></p><p>但<strong>这个设置项不会对编译器处理字符编码产生直接的影响</strong>（注意这里的“直接”二字，第3节会说到），只会在工程属性<code>配置属性--&gt;C/C++--&gt;预处理器</code>加入相应的宏：</p><pre class="line-numbers language-none"><code class="language-none">使用Unicode字符集 --&gt; _UNICODE和UNICODE宏使用多字节字符集   --&gt; _MBCS宏<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这几个宏一般用来判断是使用char还是wchar_t，在系统API中使用比较多，如MessegeBox通过是否定义了UNICODE宏来决定是使用LPCSTR还是LPCWSTR（LPCSTR即const char*, LPCWSTR即const wchar_t*）：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">UNICODE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MessageBox</span>  <span class="token expression">MessageBoxW</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MessageBox</span>  <span class="token expression">MessageBoxA</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// !UNICODE</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二-char和wchar-t"><a href="#二-char和wchar-t" class="headerlink" title="二. char和wchar_t"></a>二. char和wchar_t</h1><p>上面提到了，定义API时通过判断UNICODE宏是否定义来决定是使用char还是wchar_t，那么char和wchar_t有什么不同了？</p><p>char和wchar_t是标准C/C++字符类型，并不是windows特有的。 char固定占1个字节，wchar_t固定占2个字节，从内存的角度来看，char、wchar_t和其他数据类型一样，只是代表一段内存块，用来存储固定长度的二进制0或1。 在编程时，我们一般习惯于将字符串储到char或wchar_t定义的内存空间中，将整形存储在int定义的内存空间中。</p><p>所以，用char还是wchar_t来存储字符，只是内存分配和数据存储上面的事情，<strong>它们本身也是与字符编码无直接关系的</strong>（ 同样注意这里的“直接”二字，第3节会说到）。</p><h1 id="三-编译器如何处理硬编码字符"><a href="#三-编译器如何处理硬编码字符" class="headerlink" title="三. 编译器如何处理硬编码字符"></a>三. 编译器如何处理硬编码字符</h1><p>VC++编译器编译源代码的步骤中，涉及编码处理的步骤主要有2个：<br>第1步：预处理<br>1.1) 读取源文件，判断源文件采用的字符编码类型。(<strong>这一步不会改变文件内容</strong>)</p><pre class="line-numbers language-none"><code class="language-none">编译器判断源文件编码类型的步骤为：1. 若文件开始处有BOM(EF BB BF)，则判定为UTF-8编码；2. 若没有BOM，则试图从文件的前8个字节来判断文件是否像UTF-16编码，如果像，则就判断为UTF-16编码。3. 如果既没BOM，也不是UTF-16编码，则使用系统当前的代码页（简体中文操作系统为CP936）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>1.2) 将源文件内容转成<code>源字符集</code>(Source Character Set)，默认为UTF-8编码。</p><p>第2步：链接<br>2.1) 将1.2中得到的UTF-8转为<code>执行字符集</code>(Execution Character Set)：</p><ul><li>对于宽字符串（即C/C++中以<code>L</code>标记的串，如<code>L"abc"</code>, <code>L'中'</code>），<code>执行字符集</code>为UTF-16编码。</li><li>对于窄字符串（和宽字符串对应，即不以<code>L</code>标记的串），<code>执行字符集</code>为系统当前的代码页。</li></ul><p><img src="https://static.1key.run/blog/img/byqrhclzfbm-2.jpg"></p><p>现在我们就可以说清楚Visual Studio字符集设置、char、wchar_t是如何<em><strong>间接</strong></em>影响到编译器对字符编码的处理了：</p><pre class="line-numbers language-none"><code class="language-none">Visual Studio字符集设置      |决定声明哪一个宏（UNICODE还是_MBCS宏）      |宏又决定了API参数使用char还是wchar_t      |编译器在进行【执行字符集】编码时对char和wchar_采用不同的处理方式，从而对字符编码产生了影响。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在Visual Studio 2010（含）之后，支持使用<code># pragma execution_character_set</code>来设置执行字符集。</p></blockquote><h1 id="四-实例分析"><a href="#四-实例分析" class="headerlink" title="四. 实例分析"></a>四. 实例分析</h1><ul><li>已知汉字“中”的各种编码如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">GBK        D6 D0Unicode    2D 4EUTF-8      E4 B8 AD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>函数<code>DumpCharacterCode</code>用于按字节打印内存中的数据：</li></ul><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">void DumpCharacterCode(const char* pChar, int iSize) {for(int i = 0; i &lt; iSize; i++) {char a = *pChar++;printf("%02X ", a &amp; 0xff);}printf("\n");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>设置系统代码页的方法：<br>“控制面板”  –&gt; “区域和语言” –&gt; “管理” –&gt; “非Unicode程序的语言” –&gt; “更改系统区域设置”</p></li><li><p>Visual Studio保存文件到指定编码方法：<br>“文件” –&gt; “高级保存选项”</p></li></ul><h2 id="4-1-测试编译器处理窄字符编码"><a href="#4-1-测试编译器处理窄字符编码" class="headerlink" title="4.1 测试编译器处理窄字符编码"></a>4.1 测试编译器处理窄字符编码</h2><p>测试代码如下：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">int _tmain(int argc, _TCHAR* argv[]){char buf[100] = {"中"};   // charDumpCharacterCode(buf, 2);  // 也可以打印4个字节return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对不同的系统代码页和源文件编码，打印出的汉字“中”的编码分别为：</p><table><thead><tr><th>测试用例</th><th>系统代码页</th><th>保存源文件编码</th><th>编译器判断文件采用的编码</th><th>源字符集(Source Character Set)</th><th>执行字符集(Execution Character Set)</th><th>打印输出</th></tr></thead><tbody><tr><td>用例1</td><td>简体中文 CP936</td><td>简体中文 CP936</td><td>简体中文 CP936</td><td>UTF-8</td><td>简体中文 CP936</td><td>D6 D0</td></tr><tr><td>用例2</td><td>简体中文 CP936</td><td>UTF-8 BOM</td><td>UTF-8 BOM</td><td>UTF-8</td><td>简体中文 CP936</td><td>D6 D0</td></tr><tr><td>用例3</td><td>简体中文 CP936</td><td>UTF-8</td><td>简体中文 CP936</td><td>UTF-8</td><td>简体中文 CP936</td><td>编译错误(C2146)</td></tr><tr><td>用例4</td><td>西欧 CP1252</td><td>简体中文 CP936</td><td>西欧 CP1252</td><td>UTF-8</td><td>西欧 CP1252</td><td>D6 D0</td></tr><tr><td>用例5</td><td>西欧 CP1252</td><td>UTF-8 BOM</td><td>UTF-8 BOM</td><td>UTF-8</td><td>西欧 CP1252</td><td>3F 00</td></tr></tbody></table><p>表格中列4~6依次对应编译处理源文件的几个步骤。<br><code>3F</code>对应的ASCII字符为<code>?</code>，编译器遇到不能识别的字符时，就会用<code>?</code>来替代。 出现<code>?</code>的情况会伴随着编译警告<code>C4566</code>。<br>上面出现了1次<code>3F</code>（用例5），导致乱码的原因是<code>UTF-8 --&gt; 西欧 CP1252</code>. <code>西欧 CP1252</code>也就是ASCII的扩展，不支持汉字，所以用<code>3F</code>替代。</p><h4 id="用例3为什么会编译错误？"><a href="#用例3为什么会编译错误？" class="headerlink" title="用例3为什么会编译错误？"></a>用例3为什么会编译错误？</h4><p>微软的编译器只能识别带BOM的UTF-8，用例3的UTF-8没带BOM，编译器会判定源文件编码为系统当前代码页CP936。“中”的UTF-8编码为<code>E4 B8 AD</code>，列5执行从CP936到UTF-8转换之后变成了<code>E6 B6 93 3F</code>，列6再要将<code>E6 B6 93 3F</code>转换为CP936肯定是转换不回去的，相当于 UTF-8（1） –&gt; UTF-8 （2），再将UTF-8（2）转换回CP936，这时肯定得到的字符不是原来的字符了。</p><h4 id="用例4为什么输出的D6-D0，而不是3F？"><a href="#用例4为什么输出的D6-D0，而不是3F？" class="headerlink" title="用例4为什么输出的D6 D0，而不是3F？"></a>用例4为什么输出的<code>D6 D0</code>，而不是<code>3F</code>？</h4><p>对着用例4的各个顺序来看，源文件通过CP936保存着，但编译器通过CP1252来读取的，CP1252就是ASCII扩展，单字节的，虽然此时显示为乱码，但各字节仍然是D6 D0；然后将读取到的文件内容从CP1252转成UTF-8编码，转码后为C3 96 C3 90；然后再将UTF-8编码转回为CP1251，转码就又变成了D6 D0。 但这个<code>D6 D0</code>在CP1252中是无法显示的，如果我们在用例4加入<code>MessageBoxA(NULL, "中", "test", MB_OK);</code> 会发现弹出的对话框中显示仍然是乱码。<br>可以使用下面的代码进行测试：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">int _tmain(int argc, _TCHAR* argv[]){char buf[3] = { 0 };    // 模拟CP936编码的“中”buf[0] = 0xD6;buf[1] = 0xD0;std::string strUTF8 = ANSIToUTF8(buf, 1252);char *p = (char*)strUTF8.c_str();  // 通过visual studio查看指针p处内存为： C3 96 C3 90std::string str = UTF8ToANSI(strUTF8, 1252);p = (char*)str.c_str();   // 通过visual studio查看指针p处内存为： D6 D0return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-测试编译器处理宽字符编码"><a href="#4-2-测试编译器处理宽字符编码" class="headerlink" title="4.2 测试编译器处理宽字符编码"></a>4.2 测试编译器处理宽字符编码</h2><p>测试代码如下：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">int _tmain(int argc, _TCHAR* argv[]){wchar_t buf[100] = {L"中"};   // wchar_tDumpCharacterCode((char*)buf, 4); // 打印4个字节return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样，针对不同的系统代码页和源文件编码，打印出的汉字“中”的编码分别为：</p><table><thead><tr><th>测试用例</th><th>系统代码页</th><th>保存源文件编码</th><th>编译器判断文件采用的编码</th><th>源字符集(Source Character Set)</th><th>执行字符集(Execution Character Set)</th><th>打印输出</th></tr></thead><tbody><tr><td>用例1</td><td>简体中文 CP936</td><td>简体中文 CP936</td><td>简体中文 CP936</td><td>UTF-8</td><td>UTF-16</td><td>2D 4E 00 00</td></tr><tr><td>用例2</td><td>简体中文 CP936</td><td>UTF-8 BOM</td><td>UTF-8 BOM</td><td>UTF-8</td><td>UTF-16</td><td>2D 4E 00 00</td></tr><tr><td>用例3</td><td>简体中文 CP936</td><td>UTF-8</td><td>简体中文 CP936</td><td>UTF-8</td><td>UTF-16</td><td>编译错误(C2146)</td></tr><tr><td>用例4</td><td>西欧 CP1252</td><td>简体中文 CP936</td><td>西欧 CP1252</td><td>UTF-8</td><td>UTF-16</td><td>D6 00 D0 00 <strong>大小端</strong></td></tr><tr><td>用例5</td><td>西欧 CP1252</td><td>UTF-8 BOM</td><td>UTF-8 BOM</td><td>UTF-8</td><td>UTF-16</td><td>2D 4E 00 00</td></tr></tbody></table><h1 id="五-彻底避免硬编码字符乱码"><a href="#五-彻底避免硬编码字符乱码" class="headerlink" title="五. 彻底避免硬编码字符乱码"></a>五. 彻底避免硬编码字符乱码</h1><p>通过第3节的说明，很容易知道，要开发支持多语言，在任意语言（系统代码页）的windows环境下都正常编译，且运行起来没有乱码的程序，需要遵循如下原则：</p><ol><li>代码文件采用UTF-8 with BOM编码。</li><li>Visual Studio字符集设置为Unicode字符集。</li><li>使用wchar_t。</li></ol><p>做到上面3步，你的代码被别人从github上clone下来编译，不会因为你代码中含有中文等字符，产生类似<code>error C2015</code>这样的编译错误，更不会产生乱码。</p><blockquote><p>本文介绍的方法只用来解决硬编码字符乱码的问题，至于数据传输中的乱码，需要统一字符编码来解决。</p></blockquote><blockquote><p>参考: <a href="https://blogs.msdn.microsoft.com/vcblog/2016/02/22/new-options-for-managing-character-sets-in-the-microsoft-cc-compiler">https://blogs.msdn.microsoft.com/vcblog/2016/02/22/new-options-for-managing-character-sets-in-the-microsoft-cc-compiler</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(1)--字符编码概述</title>
      <link href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-1-zi-fu-bian-ma-gai-shu/"/>
      <url>/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-1-zi-fu-bian-ma-gai-shu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><blockquote><p>为什么这样的字符串<code>{"data":"颸颸"}</code>，JSON库（如<code>jsoncpp</code>）会解析失败？<br>为什么界面上韩文显示乱码？<br>ASCII和ANSI有什么区别？<br>相信不少人在字符编码上面摔过跟头，这篇文章针对开发中需要了解的字符编码知识进行了简要的讲解，希望能够对大家有所帮助。</p></blockquote><h1 id="1-ASCII及其扩展"><a href="#1-ASCII及其扩展" class="headerlink" title="1. ASCII及其扩展"></a>1. ASCII及其扩展</h1><h2 id="1-1-什么是ASCII字符集"><a href="#1-1-什么是ASCII字符集" class="headerlink" title="1.1 什么是ASCII字符集"></a>1.1 什么是ASCII字符集</h2><p>字符集就是一系列用于显示的字符的集合。ASCII字符集由美国国家标准协会（American National Standard Institute)于1968年制定一个字符映射集合。</p><p>ASCII使用7位二进制位来表示一个字符，总共可以表示128个字符（即<code>2^7</code>，二进制<code>000 0000 ～ 111 1111</code> 十进制<code>0～127</code>）。</p><p>ASCII字符集中每个数字对应一个唯一的字符，如下表：<br><img src="https://static.1key.run/blog/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA0OTUyMDA5"></p><p>因为其对应关系非常简单，不需要特殊的编码规则，所以严格来讲ASCII不能算字符编码，因为它没有规定编码规则。我们只是习惯将ASCII字符集称之为ASCII码、ASCII编码。</p><h2 id="1-2-ASCII的扩展"><a href="#1-2-ASCII的扩展" class="headerlink" title="1.2 ASCII的扩展"></a>1.2 ASCII的扩展</h2><h3 id="1-2-1-最高位扩展-ISO-x2F-IEC-8859"><a href="#1-2-1-最高位扩展-ISO-x2F-IEC-8859" class="headerlink" title="1.2.1 最高位扩展 - ISO/IEC 8859"></a>1.2.1 最高位扩展 - ISO/IEC 8859</h3><p>ASCII字符集是美国人发明的，这些字符完全是为其量身定制的。但随着计算机技术的发展和普及，传到了欧洲（如法国、德国）各国。由于欧洲很多国家中使用的字符除了ASCII表中的128个字符之外，还有一些各国特有的字符，于是欧洲人民发现ASCII字符集表达不了他们所要表达的东西呀。怎么办了？他们发现ASCII只使用了一个字节（8位）之中的低7位，于是欧洲各国开始各显神通，打起了那1个最高位（第0位）的主意，将最高位利用了起来，这样又多了128个字符，从而满足了欧洲人民的需要。</p><p>但因为每个国家的需求不一样，各国都设计了不同的方案。为了结束这种混乱的局面，国际标准化组织(ISO)及国际电工委员会(IEC)联合制定了<strong>一系列8位字符集</strong>的标准，统称为ISO 8859（全称ISO/IEC 8859）。注意，这是一系列字符集的统称。如ISO/IEC 8859-1（也就是常听到的Latin-1）支持西欧语言，ISO/IEC 8859-4（Latin-4）支持北欧语言等。</p><p>完整列表如下（摘自百度百科）：<br>ISO/IEC 8859-1 (Latin-1) - 西欧语言<br>ISO/IEC 8859-2 (Latin-2) - 中欧语言<br>ISO/IEC 8859-3 (Latin-3) - 南欧语言，世界语也可用此字符集显示。<br>ISO/IEC 8859-4 (Latin-4) - 北欧语言<br>ISO/IEC 8859-5 (Cyrillic) - 斯拉夫语言<br>ISO/IEC 8859-6 (Arabic) - 阿拉伯语<br>ISO/IEC 8859-7 (Greek) - 希腊语<br>ISO/IEC 8859-8 (Hebrew) - 希伯来语(视觉顺序)<br>ISO 8859-8-I - 希伯来语(逻辑顺序)<br>ISO/IEC 8859-9 (Latin-5 或 Turkish) - 它把Latin-1的冰岛语字母换走，加入土耳其语字母。<br>ISO/IEC 8859-10 (Latin-6 或 Nordic) - 北日耳曼语支，用来代替Latin-4。<br>ISO/IEC 8859-11 (Thai) - 泰语，从泰国的 TIS620 标准字集演化而来。<br>ISO/IEC 8859-13 (Latin-7 或 Baltic Rim) - 波罗的语族<br>ISO/IEC 8859-14 (Latin-8 或 Celtic) - 凯尔特语族<br>ISO/IEC 8859-15 (Latin-9) - 西欧语言，加入Latin-1欠缺的芬兰语字母和大写法语重音字母，以及欧元符号。<br>ISO/IEC 8859-16 (Latin-10) - 东南欧语言。主要供罗马尼亚语使用，并加入欧元符号。</p><blockquote><p>我们在数据库中常见到的Latin-1、2、5、7其实就是上面提到的针对特定语言的ASCII扩展字符集。<br><img src="https://static.1key.run/blog/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA1MDA0NTIy"></p></blockquote><h3 id="1-2-2-多字节扩展-GB系列"><a href="#1-2-2-多字节扩展-GB系列" class="headerlink" title="1.2.2 多字节扩展 - GB系列"></a>1.2.2 多字节扩展 - GB系列</h3><p>前面讲到了，欧洲各国有效利用闲置的最高位，对ASCII字符集进行了扩展。可是欧洲人民没有想到的是（当然他们也不用想这么多），在大洋彼岸有着一个拥有五千年历史的伟大民族，她拥有着成千上万的汉字，1个字节显然不够表达如此深厚的文化底蕴。</p><p>于是当计算机引入到中国之初，国家技术监督局就设计了GB系列编码方案（GB=guo biao)。<br><strong>GB编码方案使用2个字节来表达一个汉字。同时为了兼容ASCII编码，规定各个字节的最高位（首位）必须为1，从而避免了和最高位为0的ASCII字符集的冲突。</strong></p><p>GB系列字符集经历下面的几个发展过程：</p><table><thead><tr><th>编码名称</th><th>发布时间</th><th>字节数</th><th>汉字范围</th></tr></thead><tbody><tr><td>GB2312</td><td>1980年</td><td>变字节（ASCII 1字节，汉字2个字节）</td><td>6763个汉字</td></tr><tr><td>GB13000</td><td>1993年第一版</td><td>变字节（ASCII 1字节，汉字2个字节）</td><td>20902个汉字</td></tr><tr><td>GBK</td><td>Windows95中</td><td>2个字节</td><td>21886个汉字和图形符号（含GB2312，BIG5中所有字符）</td></tr><tr><td>GB18030</td><td>2000年第一版</td><td>变字节（ASCII 1字节，汉字2个或4个字节）</td><td>27484个汉字</td></tr></tbody></table><p>每一次迭代，支持的字符数量都会增加，而且每一次迭代都会保留之前版本支持的编码，所以做到了向上兼容。</p><h3 id="1-2-3-全角与半角"><a href="#1-2-3-全角与半角" class="headerlink" title="1.2.3  全角与半角"></a>1.2.3  全角与半角</h3><p>因为汉字在显示器上的显示宽度要比英文字符的宽度要宽一倍，在一起排版显示时不太美观。所以GB编码不仅仅加入了汉字字符，而且包括了ASCII字符集中本来就有的数字、标点符号、字母等字符。这些被编入GB编码的数字、标点、字母在显示器上的显示宽度比ASCII字符集中的宽度宽一倍，所以前者称为全角字符，后者称为半角字符。</p><h1 id="2-ANSI"><a href="#2-ANSI" class="headerlink" title="2. ANSI"></a>2. ANSI</h1><h2 id="2-1-ANSI与代码页"><a href="#2-1-ANSI与代码页" class="headerlink" title="2.1 ANSI与代码页"></a>2.1 ANSI与代码页</h2><p>前面说到了世界各国针对ASCII的扩展方案（如欧洲的ISO/IEC 8859，中国的GB系列等），这些ASCII扩展编码方案的特点是：他们都兼容ASCII编码，但他们彼此之间是不兼容的。微软将这些编码方案统称为ANSI编码。故ANSI并不是特指某一种编码方案，只有知道了在哪个国家，哪个语言环境下，才知道它具体表示哪个编码方案。</p><p>在windows操作系统上，默认使用ANSI来保存文件。那么操作系统是如何知道ANSI到底应该表示哪种编码了，是GBK，还是ASCII，或者还是EUC-KR了？ windows通过一个叫”Code Page”（翻译为中文就叫代码页）的东西来判断系统的默认编码。<br>简体中文操作系统默认的代码页是936，它表示ANSI使用的是GBK编码。<br>GB18030编码对应的windows代码页为CP54936。</p><p>可以使用命令<code>chcp</code>来查看系统默认的代码页.</p><p>汉字“𤭢”（念suì）只包含在GB18030中，GB2312、GB13000、GBK中均不包含。默认情况下，在Visual Studio中输入该汉字，visual studio会使用CP936（即GBK）来保存代码文件，但如果在代码文件中输入该汉字，visual studio弹出如下提示要求用户选择代码页：<br><img src="https://static.1key.run/blog/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA1MTI5ODIz"><br><img src="https://static.1key.run/blog/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA1MTM4NTUx"></p><h2 id="2-2-更改默认代码页"><a href="#2-2-更改默认代码页" class="headerlink" title="2.2 更改默认代码页"></a>2.2 更改默认代码页</h2><h3 id="2-2-1-chcp命令"><a href="#2-2-1-chcp命令" class="headerlink" title="2.2.1 chcp命令"></a>2.2.1 chcp命令</h3><p>可以使用<code>chcp</code>命令来更改默认代码页，如<code>chcp 437</code>将默认代码页更改为437（美国）。</p><h3 id="2-2-2-控制面板"><a href="#2-2-2-控制面板" class="headerlink" title="2.2.2 控制面板"></a>2.2.2 控制面板</h3><p>在“控制面板”–&gt;“区域和语言”–&gt; “更改系统区域设置”中更改系统默认的代码页为“中文（简体，中国）”。</p><h3 id="2-2-3-代码修改"><a href="#2-2-3-代码修改" class="headerlink" title="2.2.3 代码修改"></a>2.2.3 代码修改</h3><p>也可以通过代码更改默认的代码页：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">setlocale</span><span class="token punctuation">(</span>   <span class="token keyword">int</span> category<span class="token punctuation">,</span>   <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>locale <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-Unicode"><a href="#3-Unicode" class="headerlink" title="3. Unicode"></a>3. Unicode</h1><h2 id="3-1-Unicode产生背景"><a href="#3-1-Unicode产生背景" class="headerlink" title="3.1 Unicode产生背景"></a>3.1 Unicode产生背景</h2><p>各个国家使用不同的编码规则，虽然他们都是兼容ASCII的，但它们相互却是不兼容的。</p><p>试想法国人Jack写了一封名为”love_you.txt”的信，传给了他的德国朋友Rose，Rose想要在windows系统上打开这个文件，她需要知道德国使用的字符编码是Latin-1，然后还要确保她的计算机上安装了该编码，才能顺利的打开这个文件。<br>如果上面这些还能忍受，那么随着网络的发展，你从互联网上获取的文件，你很有可能不知道它来自哪个国家，使用的哪种编码。这也就是Email刚诞生时常常出现乱码的原因，发信人和收信人使用的编码可能是不一样的。</p><p>于是<code>The Unicode Standard</code>（统一码标准）横空出世，它由The Unicode Consortium于1991年发布，我们习惯称它为Unicode字符集。 </p><p>Unicode字符集和ASCII字符集一样，也只是一个字符集合，标记着字符和数字之间的映射关系，它不包含任何编码规则和方案。和ASCII不一样的是，Unicode字符集支持的字符数量是没有限制的（具体可以参考Unicode规范）。</p><blockquote><p>我们通常认为的Unicode字符固定占用2个字节的观点是错误的。如“𤭢”（念suì）Unicode码为<code>D852 DF62</code>。 </p></blockquote><p>那么Unicode字符是怎样被编码成内存中的字节的了？它是通过UTF(Unicode Transformation Formats)实现的，比较常见得有UTF-8，UTF-16。</p><blockquote><p>在windows系统上汉字默认使用CP936（即GBK编码），占2个字节。而大多数Unicode字符的Unicode码值也占2个字节，所以大多数人误以为汉字字符串在内存中的值就是Unicode值，这是错误的。<br>可以从 <a href="http://tool.chinaz.com/tools/unicode.aspx" title="站长工具">站长工具-Unicode</a> 查询汉字的Unicode码值。</p></blockquote><h2 id="3-3-字符集与字符编码的区别"><a href="#3-3-字符集与字符编码的区别" class="headerlink" title="3.3 字符集与字符编码的区别"></a>3.3 字符集与字符编码的区别</h2><p>从ASCII、GB2312、GBK、GB18030、Big5（繁体中文）、Latin-1等采用的方案来看，它们都只是定义了单个字符与二进制数据的映射关系，一个字符在一个方案中只会存在一种表示方式，所以我们说GB2312是字符集还是字符编码方式都无所谓了。但是Unicode不一样，Unicode作为一个字符集可以采用多种编码方式，如UTF-8, UTF-16, UTF-32等。<strong>所以自Unicode出现之后，字符集与字符编码需要明确区分开来。</strong></p><h2 id="3-4-UTF-16编码的缺点"><a href="#3-4-UTF-16编码的缺点" class="headerlink" title="3.4 UTF-16编码的缺点"></a>3.4 UTF-16编码的缺点</h2><p>UTF-16编码方式规定用两个或四个字节来表示所有的字符。对于ASCII字符保持不变，只是将原来的7位扩展到了16位，其高9位永远是0。如字符’A’：</p><pre class="line-numbers language-none"><code class="language-none">ASCII: 100 0001UTF-16: 0000 0000 0100 0001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到对于ASCII字符，UTF-16的存储空间扩大了一倍，UTF-16并不是完全兼容ASCII字符集。这对于那些ASCII字符集已经满足需求的西方国家来说完全是没必要的，而且ASCII字符经过UTF-16编码之后高字节始终是0，导致很多C语言函数（如<code>strcpy</code>,<code>strlen</code>)会将此字节视为字符串的结束符<code>'\0'</code>，从而出现错误的计算结果。<br>而且，UTF-16还存在大小端的问题，“𤭢”（念suì）Unicode码在大端系统上为<code>D852 DF62</code>，小端系统上为<code>52D8 62DF</code>。<br>因此，UTF-16一开始推出的时候就遭到很多西方国家的抵制，影响了Unicode的推行。于是后来又设计了UTF-8编码方式，才解决了这些问题。</p><h2 id="3-5-Unicode字符集常用编码方式：UTF-8"><a href="#3-5-Unicode字符集常用编码方式：UTF-8" class="headerlink" title="3.5. Unicode字符集常用编码方式：UTF-8"></a>3.5. Unicode字符集常用编码方式：UTF-8</h2><h3 id="3-5-1-UTF-8概述"><a href="#3-5-1-UTF-8概述" class="headerlink" title="3.5.1 UTF-8概述"></a>3.5.1 UTF-8概述</h3><p>UTF-8是互联网上使用最广泛的Unicode字符集编码方式。UTF-8编码的最小单位由8位（1个字节）组成，UTF-8使用一个至四个字节来表示Unicode字符。另外，UTF-8是完美兼容ASCII字符集的，这一点可以通过下面的UTF-8的编码规则得到证明。</p><h3 id="3-5-2-UTF-8编码规则"><a href="#3-5-2-UTF-8编码规则" class="headerlink" title="3.5.2 UTF-8编码规则"></a>3.5.2 UTF-8编码规则</h3><p>UTF-8编码规则很简单：<br>（1）对于ASCII（单字节字符）字符，采用和ASCII相同的编码方式，即只使用一个字节表示，且该字节第一位为0.<br>（2）对于多字节（2~4字节）字符，假设字节数为n（1 &lt; n &lt;= 4），第一个字节：前n位都设为1，第n+1位设为0；后面的n-1个字节的前两位一律设为10。所有字节中的没有提及的其他二进制位，全部为这个符号的unicode码。 </p><table><thead><tr><th>Unicode符号范围(十六进制)</th><th>UTF-8编码方式(二进制)</th></tr></thead><tbody><tr><td>单字节:00000000-0000 007F</td><td>0xxxxxxx</td></tr><tr><td>双字节:00000080-0000 07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>三字节:00000800-0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>四字节:0001 0000-0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><h3 id="3-5-2-UTF-8-BOM"><a href="#3-5-2-UTF-8-BOM" class="headerlink" title="3.5.2 UTF-8 BOM"></a>3.5.2 UTF-8 BOM</h3><p>BOM（byte order mark）从字面意义来看是标记字节顺序的。最早出现的原因是因为UTF-16和UTF-32编码采用2个或4个字节表示一个字符，面临大小端的问题。为了区分是使用的大端(Big Endian，简称BE)还是小端(Little Endian，简称LE)，采用了在串的前面加入指定的字节加以区分，UTF-16大端加入<code>FE FF</code>，小端加入<code>FF FE</code>. 比如， 字符串“ABC”的UTF-16编码为 <code>00 41 00 42 00 43</code>，对应的各种的字节序列如下：</p><table><thead><tr><th>序列</th><th>数据</th></tr></thead><tbody><tr><td>UTF-16BE(withoutBOM)</td><td>00 41 00 42 00 43</td></tr><tr><td>UTF-16LE(withoutBOM)</td><td>41 00 42 00 43 00</td></tr><tr><td>UTF-16BE(with BOM)</td><td>FE FF 00 41 00 42 00 43</td></tr><tr><td>UTF-16LE(with BOM)</td><td>FF FE 41 00 42 00 43 00</td></tr></tbody></table><p>因为UTF-8和ASCII都是单字节序列，二者不好区分，微软采用在UTF-8编码的字符串前也加入BOM（3个字节<code>EF BB BF</code>）来标记UTF-8编码的串。UTF-8 BOM这一规范大多在windows下被使用，在其他平台下用的很少使用，如：Linux全部采用UTF-8编码，不存在要区分的情况；HTTP协议中可以包含<code>Content-Type:text/html; charset=utf-8</code>这样的说明，也不需要区分。</p>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
