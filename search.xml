<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络协议(2)--IP协议</title>
      <link href="/2023/06/20/wang-luo-xie-yi-2-ip-xie-yi/"/>
      <url>/2023/06/20/wang-luo-xie-yi-2-ip-xie-yi/</url>
      
        <content type="html"><![CDATA[<p>IP协议是TCP/IP协议族中最核心的协议。所有的TCP、UDP、ICMP、IGMP数据都以IP数据报的格式传输。</p><p>IP协议是不可靠、无连接的：</p><ul><li><p><code>不可靠</code>表示IP协议不能保证IP数据报能成功的到达目的地。IP仅提供传输服务，任何可靠性的要求都必须由上层来提供（如TCP）。如果传输过程发生错误，IP协议简单的丢弃该数据报，然后发送ICMP消息给发送端。</p></li><li><p><code>无连接</code>表示IP协议不维护任何关于后续数据报的状态信息，每个数据报都是相互独立的。这也说明，IP数据报可能不是按照发送顺序被接收到的，很有可能后发送的数据被先收到。</p></li></ul><h2 id="一、IP首部"><a href="#一、IP首部" class="headerlink" title="一、IP首部"></a>一、IP首部</h2><p>IP数据报的格式如图：<br><img src="https://static.1key.run/blog/wangluoxieyi-ip-1.jpg"></p><ul><li><p>4位版本：标识目前采用的IP协议的版本号。IPv4为0100, IPv6为0110</p></li><li><p>4位首部长度：用于标识首部的长度，单位为<strong>4字节</strong>，所以首部的最大长度为<code>15*4字节=60字节</code>。</p></li><li><p>8位服务类型：包括3bit的优先权字段（已被忽略），4bit的TOS字段，1bit的始终为0的未使用位。</p></li><li><p>16位总长度(字节数)：整个IP数据报的长度。数据报中<code>数据内容的长度=总长度 - 首部长度</code></p></li><li><p>16位标识：唯一地标识主机发送的每一份数据报。IP数据报的最大长度可达65535字节，但大多数链路层都会对它进行分片。由于TCP本身会把用户数据分成若干片，因此这个字段一般来说不会影响到TCP。</p></li><li><p>3位标志：用于IP数据报分片。该字段第1bit不使用，第2bit是DF(<code>Don't Fragment</code>)位，DF位设为1时表明IP不对该数据包分片。第3bit是MF(<code>More Fragments</code>)位，当对数据包分片时，除了最后一片外，其他每个组成数据报的片都要把此位设为1。</p></li><li><p>13位偏移：用于IP数据报分片。单位为8字节。表示该片相对于原始数据报开始处的位置，能表示的最大偏移为$2^{13}$*8=65536字节。</p></li></ul><blockquote><p>另外，数据报被分片之后，每个片的总长度要更改为该片的长度值。IP层分片是透明的，但是即使只丢失一片数据也要重传整个数据报，因为IP层本身没有超时重传的机制。</p></blockquote><ul><li><p>8位生存时间(TTL)：设置数据报可以经过的最多路由器数量，每经过一个路由器，该值就减去1。当该值为0时，数据报就被丢弃。通常初始值为32或64.</p></li><li><p>8位协议：表示上层传输层所用的协议类型。1表示ICMP协议，2表示IGMP协议，6表示TCP协议，17表示UDP协议。</p></li><li><p>16位首部校验和：用于对IP首部的正确性进行校验，但不包括数据部分，这点不同于TCP和UDP的首部校验和。</p></li><li><p>32位源IP地址：发送端的32bit的IP地址。</p></li><li><p>32位目的IP地址：接收端的32bit的IP地址。</p></li><li><p>选项：可变长度的可选信息。如果首部不含“选项字段”，则IP首部长度为20字节。</p></li></ul><h2 id="二、IP首部校验和"><a href="#二、IP首部校验和" class="headerlink" title="二、IP首部校验和"></a>二、IP首部校验和</h2><ul><li>发送端对IP数据报的校验和的计算步骤：</li></ul><ol><li>把IP数据报的校验和字段置为0；</li><li>把首部看成以16位为单位的数字组成，依次进行二进制反码求和；</li><li>把求和得到的结果取反。</li><li>将第2、3步得到的2个字节数据存入首部校验和。</li></ol><ul><li>接收端对IP数据报的校验和的校验步骤：</li></ul><ol><li>把首部看成以16位为单位的数字组成，依次进行二进制反码求和；</li><li>把求和得到的结果取反码。</li><li>如果结果为0，则表示检验和校验通过，IP报文没有被修改过。</li></ol><h2 id="三、使用代码计算校验和"><a href="#三、使用代码计算校验和" class="headerlink" title="三、使用代码计算校验和"></a>三、使用代码计算校验和</h2><p>通过wireshark抓取一帧数据报，如图：<br><img src="https://static.1key.run/blog/wangluoxieyi-ip-2.jpg"></p><p>以该数据报的IP首部为基础，使用C++代码来验证IP首部校验和的计算步骤和校验步骤：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;assert.h&gt;// GetChecksum函数用于实现上面所说的计算步骤中的第2步、第3步：// 把首部看成以16位（2字节）为单位的数字组成，依次进行二进制反码求和，// 但实际的算法实现上需要考虑取和溢出时的改进计算方法（见函数内部注释）//unsigned short GetChecksum(unsigned short* ip_header, int size) {assert(sizeof(unsigned short) == 2);// 为什么使用unsigned long（4字节）？// 因为虽然首部校验和只占16位（2个字节），但执行“以16位（2字节）为单位的二进制反码数据”求和操作得到的checksum可能会超过16位（2字节），// 所以这里用4个字节的unsigned long来接收相加得到的结果，后面再进行处理。//unsigned long checksum = 0;while (size &gt; 1) {checksum += *ip_header; // 因为都是正数，所以反码与原码相同；故直接相加求和ip_header++; // ip_header为unsigned short类型的指针每次按2个字节相加size -= 2;}// 执行到这：checksum = 0x2850c// IP首部如果不包含“选项”字段，则为20字节，偶数；如果包含了“选项”，则字节数就可能为奇数了，// 这里针对字节数为奇数的情况进行处理。// 注：示例main函数中构造的ip_header不含有“选项”//if (size == 1) {checksum += *(unsigned char*)ip_header;}// 因为上面相加之后的结果大于2个字节，所以执行额外的处理步骤：// checksum &gt;&gt; 16 右移16位// 即除以2的16次方（0xffff），就是去除右边的2个字节，如：0x2850c &gt;&gt; 16 = 0x2//// checksum &amp; 0xffff 位运算，得到后2个字节// 如：0x2850c &amp; 0xffff = 0x850c//// checksum = 0x2 + 0x850c = 0x850e//checksum = (checksum &gt;&gt; 16) + (checksum &amp; 0xffff);// 假如还大于2个字节，再次将多余的字节和checksum相加。checksum += (checksum &gt;&gt; 16);// 求和得到的结果的取反return (unsigned short)(~checksum);}int main(){// 将上面wirkshark抓的数据包的IP头部，使用char数组，按字节构造出来//unsigned char ip_header[20] = {0x45, // 4位版本+4位首部长度0x00, // 8位服务类型（TOS）0x00, 0x1c,  // 16位总长度（字节数）0x50, 0xaa,  // 16位标识0x00, 0x00,  // 3位标志+13位片偏移0xff, // 8位生存时间（TTL）0x01, // 8位协议0xf1, 0x7a, // 16位首部校验和0xc0, 0xa8, 0x2e, 0x55, // 32位源IP地址0xee, 0x73, 0x9c, 0x4a  // 32位目的IP地址};// 第1步：把IP数据包的校验和字段置为0；//ip_header[10] = 0x00;ip_header[11] = 0x00;// 第2、3步计算校验和//unsigned short checksum = GetChecksum((unsigned short*)ip_header, sizeof(ip_header));printf("%02hhx %02hhx\n", *(char*)(&amp;checksum), *((char*)(&amp;checksum) + 1));// 第4步：将第2、3步得到的2个字节数据存入首部校验和//ip_header[10] = *(char*)(&amp;checksum);ip_header[11] = *((char*)(&amp;checksum) + 1);// 模拟接收到IP包之后，对IP首部的校验和进行校验//unsigned short checksum_check = GetChecksum((unsigned short*)ip_header, sizeof(ip_header));if (checksum_check == 0) {printf("checksum check successful!\n");}else {printf("checksum check failed!\n");}    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、IP校验和的设计原理"><a href="#四、IP校验和的设计原理" class="headerlink" title="四、IP校验和的设计原理"></a>四、IP校验和的设计原理</h2><p>我们将IP首部进行简化来讲解IP校验和的设计原理，假设IP首部只有6个字节，第5,6字节存放校验和：<br><img src="https://static.1key.run/blog/wangluoxieyi-ip-3.jpg"></p><p>计算校验和时第5,6字节置为0，校验和等于：A+B+0，然后取反，即：<br><img src="https://static.1key.run/blog/wangluoxieyi-ip-4.jpg"></p><p>接收端收到之后校验步骤为：求校验和（不同的是：校验和位不置0），若此时求得校验和为0，则校验通过。即：<br><img src="https://static.1key.run/blog/wangluoxieyi-ip-5.jpg"></p><h2 id="五、IP地址相关操作"><a href="#五、IP地址相关操作" class="headerlink" title="五、IP地址相关操作"></a>五、IP地址相关操作</h2><p>本节介绍在网络编程中涉及到的与IP地址相关的操作</p><h3 id="struct-in-addr"><a href="#struct-in-addr" class="headerlink" title="struct in_addr"></a>struct in_addr</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// sizeof(in_addr) == sizeof(ULONG) == 4//typedef struct in_addr {        union {                struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b;                struct { USHORT s_w1,s_w2; } S_un_w;                ULONG S_addr;   // 4个字节，按网络字节序列存储                // 可以使用inet_addr函数将IP格式字符串转为网络字节序列的整数。        } S_un;// 定义的一些宏，方便访问结构体成员#define s_addr  S_un.S_addr /* can be used for most tcp &amp; ip code */#define s_host  S_un.S_un_b.s_b2    // host on imp#define s_net   S_un.S_un_b.s_b1    // network#define s_imp   S_un.S_un_w.s_w2    // imp#define s_impno S_un.S_un_b.s_b4    // imp ##define s_lh    S_un.S_un_b.s_b3    // logical host} IN_ADDR, *PIN_ADDR, FAR *LPIN_ADDR;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="struct-sockaddr-in"><a href="#struct-sockaddr-in" class="headerlink" title="struct sockaddr_in"></a>struct sockaddr_in</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// sizeof(sockaddr_in) == 16struct sockaddr_in {        short   sin_family;        u_short sin_port;        struct  in_addr sin_addr;        char    sin_zero[8];};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="struct-sockaddr"><a href="#struct-sockaddr" class="headerlink" title="struct sockaddr"></a>struct sockaddr</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// sizeof(sockaddr) == 16//struct sockaddr {        u_short sa_family;              /* address family */        char    sa_data[14];            /* up to 14 bytes of direct address */};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-转换函数"><a href="#5-1-转换函数" class="headerlink" title="5.1 转换函数"></a>5.1 转换函数</h3><blockquote><p>webrtc中的<code>IPAddress</code>类和<code>SocketAddress</code>类，对网络地址的操作进行了很好的封装，值得参考。</p></blockquote><h4 id="5-1-1-IP字符串-gt-整数"><a href="#5-1-1-IP字符串-gt-整数" class="headerlink" title="5.1.1 IP字符串 -> 整数"></a>5.1.1 IP字符串 -&gt; 整数</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unsigned long inet_addr(  _In_ const char *cp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将类似<code>127.0.0.1</code>这样的IP字符串转换为网络字节序列的整数</p><h4 id="5-1-2-整数-gt-IP字符串"><a href="#5-1-2-整数-gt-IP字符串" class="headerlink" title="5.1.2 整数 -> IP字符串"></a>5.1.2 整数 -&gt; IP字符串</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char* FAR inet_ntoa(  _In_ struct   in_addr in);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将in_addr（也可以理解为网络字节序列整数）转换为IP字符串。</p><h3 id="5-2-字节序列转换"><a href="#5-2-字节序列转换" class="headerlink" title="5.2 字节序列转换"></a>5.2 字节序列转换</h3><pre class="line-numbers language-none"><code class="language-none">htonshtonlntohsntohlhtonllntohll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对整数（short、long、longlong）进行网络字节序列和主机字节序列间的转换操作。<br>以htons为例：<br><code>h</code>是host的首字母，表示主机字节序列；<br><code>n</code>是network的首字母，表示网络字节序列；<br><code>s</code>代表short；<br>所以htons的功能是，将short从主机字节序列转为网络字节序列。</p><blockquote><p>字节序列可以参考：<a href="http://blog.csdn.net/china_jeffery/article/details/78401731">http://blog.csdn.net/china_jeffery/article/details/78401731</a></p></blockquote><h3 id="5-3-获取本机IP地址"><a href="#5-3-获取本机IP地址" class="headerlink" title="5.3 获取本机IP地址"></a>5.3 获取本机IP地址</h3><h4 id="5-3-1-使用gethostbyname"><a href="#5-3-1-使用gethostbyname" class="headerlink" title="5.3.1 使用gethostbyname"></a>5.3.1 使用gethostbyname</h4><p>这种方式有一个弊端：只能获取一个网卡的IP地址。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unsigned long GetLocalIPv4Address() {char hostname[MAX_PATH] = { 0 };gethostname(hostname, MAX_PATH);struct hostent FAR* lpHostEnt = gethostbyname(hostname);if (lpHostEnt == NULL) {return htonl(0x7f000001); //127.0.0.1}LPSTR lpAddr = lpHostEnt-&gt;h_addr_list[0];struct in_addr addr;memcpy(&amp;addr, lpAddr, 4);return addr.s_addr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-2-使用GetAdaptersInfo"><a href="#5-3-2-使用GetAdaptersInfo" class="headerlink" title="5.3.2 使用GetAdaptersInfo"></a>5.3.2 使用GetAdaptersInfo</h4><p>该方式可以获取本机多块网卡的信息（不限于IP地址）。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;windows.h&gt;#include &lt;Iphlpapi.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#pragma comment(lib,"Iphlpapi.lib")bool GetLocalAddress(std::vector&lt;std::string&gt; &amp;ip_list) {PIP_ADAPTER_INFO pIpAdapterInfo = new IP_ADAPTER_INFO();unsigned long stSize = sizeof(IP_ADAPTER_INFO);int nRet = GetAdaptersInfo(pIpAdapterInfo, &amp;stSize);if (ERROR_BUFFER_OVERFLOW == nRet) {delete pIpAdapterInfo;pIpAdapterInfo = (PIP_ADAPTER_INFO)new BYTE[stSize];nRet = GetAdaptersInfo(pIpAdapterInfo, &amp;stSize);}if (ERROR_SUCCESS != nRet) {if (pIpAdapterInfo) {delete pIpAdapterInfo;}return false;}while (pIpAdapterInfo) {IP_ADDR_STRING *pIpAddrString = &amp;(pIpAdapterInfo-&gt;IpAddressList);switch (pIpAdapterInfo-&gt;Type) {case MIB_IF_TYPE_OTHER:case MIB_IF_TYPE_ETHERNET:case MIB_IF_TYPE_TOKENRING:case MIB_IF_TYPE_FDDI:case MIB_IF_TYPE_PPP:case MIB_IF_TYPE_LOOPBACK:case MIB_IF_TYPE_SLIP: {std::string address = pIpAddrString-&gt;IpAddress.String;if ("0.0.0.0" == address)break;ip_list.push_back(address);break;}default:break;}pIpAdapterInfo = pIpAdapterInfo-&gt;Next;}if (pIpAdapterInfo) {delete pIpAdapterInfo;}return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>《TCP/IP详解 卷1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(2)--ARP和RARP协议</title>
      <link href="/2023/06/20/wang-luo-xie-yi-2-arp-he-rarp-xie-yi/"/>
      <url>/2023/06/20/wang-luo-xie-yi-2-arp-he-rarp-xie-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="一、ARP协议"><a href="#一、ARP协议" class="headerlink" title="一、ARP协议"></a>一、ARP协议</h1><h2 id="1-1-ARP协议介绍"><a href="#1-1-ARP协议介绍" class="headerlink" title="1.1 ARP协议介绍"></a>1.1 ARP协议介绍</h2><p><code>ARP</code>(<code>Address Resolution Protocol</code>)地址解析协议，位于TCP/IP协议栈中的链路层。当局域网内主机间（或者是主机与网关间）需要通信时，通过使用<code>ARP协议</code>获取<code>目标IP地址</code>对应的<code>硬件MAC地址</code>，然后主机间通过该<code>硬件MAC地址</code>完成数据包发送和接收。<br>具体过程如下：</p><ol><li>本地主机在局域网中<code>广播</code>ARP请求，ARP请求数据帧中包含目的主机的IP地址。意思是“如果你是这个IP地址的拥有者，请回答你的硬件MAC地址”。</li><li>目的主机的ARP层解析这份<code>广播</code>报文，识别出是询问其硬件地址。于是发送（<code>单播</code>）ARP应答包，里面包含IP地址及其对应的硬件地址。</li><li>本地主机收到ARP应答后，知道了目的地址的硬件地址，之后的数据报就可以传送了。</li></ol><p><img src="https://static.1key.run/blog/wangluoxieyi-arp-1.jpg"></p><h2 id="1-2-ARP缓存"><a href="#1-2-ARP缓存" class="headerlink" title="1.2 ARP缓存"></a>1.2 ARP缓存</h2><p>如果像上面说的那样，每次发包之前都要发送ARP请求硬件地址会不会太慢，但是实际上ARP的运行是非常高效的。那是因为每一个主机上都有一个ARP高速缓存，我们可以通过命令<code>arp -a</code>获取本机ARP高速缓存的所有内容：</p><pre class="line-numbers language-none"><code class="language-none">λ arp -a接口: 192.168.42.26 --- 0xb  Internet 地址         物理地址              类型  192.168.1.1           00-00-00-00-00-ff     静态  192.168.40.1          f8-75-88-c2-df-c1     动态  192.168.40.74         c8-5b-76-86-c6-06     动态  192.168.40.245        38-d5-47-e1-8a-2f     动态  192.168.42.131        60-a4-4c-65-9f-68     动态  224.14.51.28          01-00-5e-0e-33-1c     静态  224.19.133.150        01-00-5e-13-85-96     静态  224.49.6.212          01-00-5e-31-06-d4     静态  224.50.134.225        01-00-5e-32-86-e1     静态  224.68.111.100        01-00-5e-44-6f-64     静态  224.80.154.130        01-00-5e-50-9a-82     静态  224.88.174.75         01-00-5e-58-ae-4b     静态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过命令<code>arp -d</code>清除arp缓存内容。</p><h2 id="1-3-ARP缓存生存周期"><a href="#1-3-ARP缓存生存周期" class="headerlink" title="1.3 ARP缓存生存周期"></a>1.3 ARP缓存生存周期</h2><p>在默认情况下，Windows Server 2003家族和Windows XP中，ARP缓存中的表项仅存储2分钟。如果一个ARP缓存表项在2分钟内被用到，则其期限再延长2分钟，直到最大生命期限10分钟为止。超过10分钟的最大期限后，ARP缓存表项将被移出，并且通过另外一个ARP请求来获得新的对应关系。</p><p>ARP缓存表项的存放时间可以通过改变<code>ArpCacheLife</code>和<code>ArpCacheMinReferencedLife</code>的注册表值来重新设置。</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Tcpip/Parameters键值：ArpCacheLife，设置未被使用的ARP缓存表项可以被保持的时间，类型为Dword，单位为秒，默认值为120。ArpCacheMinReferencedLife，设置被重复使用的表项可以在ARP缓存中存放的时间，类型为Dword，单位为秒，默认值为600。ArpCacheMinReferencedLife和ArpCacheLife的值的使用方法如下：如果ArpCacheLife &gt;= ArpCacheMinReferencedLife，则被使用和未被使用的ARP缓存表项可存储的时间都是ArpCacheLife。如果ArpCacheLife &lt; ArpCacheMinReferencedLife，则未被使用的ARP缓存表项在ArpCacheLife秒的时间后就过期了，被使用的表项的生存期为ArpCacheMinReferencedLife秒。注意：这些键值默认是不存在的，如果你想修改，必须自行创建；修改后重启计算机后生效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-ARP帧格式"><a href="#1-3-ARP帧格式" class="headerlink" title="1.3 ARP帧格式"></a>1.3 ARP帧格式</h2><p><img src="https://static.1key.run/blog/wangluoxieyi-arp-2.jpg"></p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">以太网目的地址：目的主机的硬件地址。目的地址全为1的特殊地址是广播地址。以太网源地址：源主机的硬件地址。帧类型：对于ARP协议，该字段为0x0806。对于RARP协议，该字段为0x8035。硬件类型：表示硬件地址的类型。值为1时表示以太网地址。ARP协议不仅仅应用于以太网协议，还可以支持别的链路层协议。协议类型：表示要映射的协议地址类型。值为0x0800时表示IP协议。硬件地址长度：与硬件类型对应的硬件地址的长度，以字节为单位。如果是以太网，则是6字节（MAC长度）。协议地址长度：与协议类型对应的协议地址长度，以字节为单位。如果是IP协议，则是4字节（IP地址长度）。操作类型（op）：四种操作类型。ARP请求（1），ARP应答（2），RARP请求（3），RARP应答（4）。发送端硬件地址：如果是以太网，则是源主机以太网地址，此处和以太网头中的源地址对应。发送端协议地址：如果是IP协议，则表示源主机的IP地址。目的端硬件地址：如果是以太网，则是目的以太网地址，和以太网头中的目的地址对应。目的端协议地址：如果是IP协议，则表示源主机要请求硬件地址的IP地址。对应ARP请求包来说，目的端的硬件地址字段无须填充，其他字段都需要填充。对于ARP回复包来说，所有字段都需要填充。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4-ARP欺骗"><a href="#1-4-ARP欺骗" class="headerlink" title="1.4 ARP欺骗"></a>1.4 ARP欺骗</h2><p>ARP欺骗一般目的是通过某种方式把自己伪装成网关，从而欺骗目标机器，使本应发送到真实网关的数据包发送到欺骗者的机器。</p><p>现有如下网络：<br><img src="https://static.1key.run/blog/wangluoxieyi-arp-3.jpg"></p><h4 id="1-4-1-如何伪装成网关？"><a href="#1-4-1-如何伪装成网关？" class="headerlink" title="1.4.1 如何伪装成网关？"></a>1.4.1 如何伪装成网关？</h4><p>我们以主机A请求<code>www.csdn.net</code>网站为例，涉及到ARP的主要流程如下：</p><ol><li><p>主机A通过浏览器打开<code>www.csdn.net</code>（假设通过DNS得到的IP是<code>47.95.163.175</code>），然后组装需要发送http请求包。</p></li><li><p>主机A准备根据默认路由（网关）将数据包发送给<code>192.168.0.1</code>, 但是最开始的时候主机A不知道 <code>192.168.0.1</code> 的MAC地址, 所以主机A广播一条ARP请求, 询问 <code>192.168.0.1</code> 的 MAC地址。</p></li><li><p>路由器（网关）收到该 ARP 请求, 发现自己是 192.168.0.1 于是向主机 A 回复一条 ARP应答包, 告诉主机 A 192.168.0.1 的 MAC 地址是 xxxGW.</p></li><li><p>主机 A 收到该ARP响应包, 并向该响应包中的 MAC 地址发送一个Http请求包。</p></li><li><p>路由器（网关）收到该 Http请求包, 发现目标 IP 是公网 IP, 便将该包放送到公网, 公网返回Http应答包给路由器（网关）。</p></li><li><p>路由器（网关）准备将Http响应包发送给<code>192.168.0.100</code>, 但是同第2步, 路由器最开始的时候也不知道 <code>192.168.0.100</code> 的MAC地址是多少, 所以路由器会广播一条ARP请求, 询问 192.168.0.100 的MAC地址是多少。</p></li><li><p>主机A收到ARP请求, 发现自己是<code>192.168.0.100</code>, 于是向路由器回复一个ARP应答包, 告诉路由器<code>192.168.0.100</code> 的 MAC地址是 xxxA.</p></li><li><p>路由器（网关）收到ARP应答包, 并使用该APR应答包中的MAC地址将第5步收到Http响应包发送出去。</p></li></ol><p>试想，如果现在主机B做了如下2件事情会有什么后果：</p><ol><li>主机B不停的向主机A发送ARP应答包, 告诉路由器（网关）192.168.0.1 的MAC地址是 xxxB, 会发生什么?</li><li>主机B不停的向路由器（网关）发送 ARP应答包, 告诉主机A 192.168.0.100的MAC是 xxxB, 会发生什么?</li></ol><p>如果主机B做了上面说的两件事的, 那么主机A访问网络的所有数据都会先经过主机 B, 并且从网关发送到主机A的数据也都会经过B, 至此, 整个ARP欺骗完成。</p><p>但是，如果欺骗者机器不对这些数据包作处理，当被欺骗数据包到达后就会被本机丢弃（因为自己到底不是网关，还不知道如何处理这类数据包），这当然是不允许的。这时开启IP转发功能可以解决该问题，IP转发负责把该类数据包再转发给真正的网关处理，开启IP转发的方法：</p><pre class="line-numbers language-none"><code class="language-none">sysctl net.ipv4.ip_forward=1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-4-2-arpspoof使用"><a href="#1-4-2-arpspoof使用" class="headerlink" title="1.4.2 arpspoof使用"></a>1.4.2 arpspoof使用</h4><p>在Ubuntu或Kali等系统上有<code>arpspoof</code>工具可以轻松实现ARP欺骗的整个流程。</p><pre class="line-numbers language-none"><code class="language-none">arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host参数：-i 指定用攻击机的哪个网络接口，可以使用ifconfig命令查看攻击机接口列表。-c own|host|both-t 指定arp攻击的目标。如果不指定，则目标为该局域网内的所有机器。可以指定多个目标，如：arpspoof -i etho -t 192.168.32.100 -t 192.168.32.101-r host 希望拦截攻击机和哪个host之间的通信，一般都是网关。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、RARP协议"><a href="#二、RARP协议" class="headerlink" title="二、RARP协议"></a>二、RARP协议</h1><p>RARP协议（Reverse Address Resolution Protocol），反向地址转换协议，也叫逆地址解析协议，主要被那些没有磁盘驱动器的系统使用，如无盘工作站等。</p><p>具有本地磁盘的系统引导时，一般是从磁盘中的配置文件读取IP地址。但是无盘机，如无盘工作站，则需要采用其他方法获取ip地址。<br>网络上的每个系统都具有唯一的硬件地址，它是由网络接口生产厂家配置的。无盘系统的RARP实现过程是从网卡上读取唯一的硬件地址，然后发送RARP请求到RARP服务器，请求该主机在无盘系统的IP地址。</p><p><img src="https://static.1key.run/blog/wangluoxieyi-arp-4.jpg"></p><blockquote><p>文章参考：<a href="https://segmentfault.com/a/1190000009562333">https://segmentfault.com/a/1190000009562333</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARP </tag>
            
            <tag> RARP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(1)--基础概念</title>
      <link href="/2023/06/20/wang-luo-xie-yi-1-ji-chu-gai-nian/"/>
      <url>/2023/06/20/wang-luo-xie-yi-1-ji-chu-gai-nian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一、TCP-x2F-IP协议栈"><a href="#一、TCP-x2F-IP协议栈" class="headerlink" title="一、TCP/IP协议栈"></a>一、TCP/IP协议栈</h1><p><img src="https://static.1key.run/blog/wangluoxieyi-jichugailian-1.jpg"></p><h1 id="二、IP地址、子网掩码、网关"><a href="#二、IP地址、子网掩码、网关" class="headerlink" title="二、IP地址、子网掩码、网关"></a>二、IP地址、子网掩码、网关</h1><h2 id="2-1-IP地址及分类"><a href="#2-1-IP地址及分类" class="headerlink" title="2.1 IP地址及分类"></a>2.1 IP地址及分类</h2><p>IP地址相当于互联网上的门牌号, 计算机在启动的时候可以从磁盘（无盘系统例外）上读取该主机的IP配置。IP地址由4个字节（也就是32位）的二进制码组成，包含了<code>网络号( net-id )</code>和<code>主机号( host-id )</code>。但现实中，我们经常还需要再继续划分<code>“子网”</code>，这时就需要借用主机号的一部分充任子网号，这样IP地址也就可以看成由<code>标准网络号、子网号、主机号</code>3部分组成的了，即<code>IP地址=标准网络号+子网号+主机号</code>。</p><blockquote><p>网络号、子网号、主机号三者间的关系，形象的描述如下：假设你的住址IP是<code>武汉市文治街16号</code>，那么，<br>IP地址 = 武汉市文治街16号<br>网络号 = 武汉市<br>子网号 = 文治街<br>主机号 = 16号</p></blockquote><table><thead><tr><th>IP地址种类</th><th>二进制组成(前缀位+网络位+主机位)</th><th>IP范围</th><th>网络数</th><th>主机数/网络</th></tr></thead><tbody><tr><td>A类地址</td><td><code>0</code>+7位网络号+24位主机号</td><td>1.0.0.0 - 127.255.255.255</td><td>$2^7-2$</td><td>$2^{24}-2$</td></tr><tr><td>B类地址</td><td><code>10</code>+14位网络号+16位主机号</td><td>128.0.0.0 - 191.255.255.255</td><td>$2^{14}-1$</td><td>$2^{16}-2$</td></tr><tr><td>C类地址</td><td><code>110</code>+21位网络号+8位主机号</td><td>192.0.0.0 - 223.255.255.255</td><td>$2^{21}-1$</td><td>$2^8-2$</td></tr><tr><td>D类地址</td><td><code>1110</code>+多播地址(用于多播)</td><td>224.0.0.0 - 239.255.255.255</td><td>-</td><td>-</td></tr><tr><td>E类地址</td><td><code>1111</code>+保留位(不开放, 保留使用)</td><td>240.0.0.0-249.255.255.255</td><td>-</td><td>-</td></tr></tbody></table><p>从表中可以看出，A类IP的第1位（二进制位）必须是0，所以A类IP的第一个整数的范围是<code>0000 0000 ~ 01111 11111</code>，转换为十进制就是<code>0 ~ 127</code>，以此类推。</p><h3 id="关于网络数的解释"><a href="#关于网络数的解释" class="headerlink" title="关于网络数的解释"></a>关于网络数的解释</h3><p>网络数就是一种网络的子网数, 比如A类地址, 可以分为多少个子网。看表格可以推出网络数的计算公式为: $2^{网络号位数}$。<br>规定网络地址全为<code>0</code>的IP地址是保留地址，意思是“本网络”。</p><ul><li>在A类地址中，实际上 <code>0.0.0.0</code> 是不指派的，而可以指派的最小网络是 <code>1.0.0.0</code>；网络地址为 <code>127</code> 的A类IP地址保留作为本地软件环回测试本主机的进程之间的通信(比如常用的 <code>127.0.0.1</code>，<strong>但实际上网络地址为<code>127</code>的都可以用作本地环回地址</strong>)。所以A类地址网络数为 $2^7-2$。</li><li>在B类地址中，实际上 <code>128.0.0.0</code> 是不指派的，而可以指派的最小网络是 `128.1.0.0，所以B类地址网络数是 $2^{14} - 1$。</li><li>在C类地址中，实际上 <code>192.0.0.0</code> 是不指派的，而可以指派的最小网络是 192.0.1.0，所以C类地址网络数是 $2^{21}-1$。</li></ul><h3 id="关于主机数的解释"><a href="#关于主机数的解释" class="headerlink" title="关于主机数的解释"></a>关于主机数的解释</h3><p>主机数就是一个子网里面可以容纳多少台主机。看表格可以推出主机数的计算公式为: <code>2^主机号位数-2</code>。主机号全为0表示该网络，而主机号全为1表示广播地址，所以要排除掉这两个。比如A类地址 <code>1.0.0.0</code> 表示主机所在的网段的网络地址, <code>1.255.255.255</code> 为该网段的广播地址。</p><h2 id="2-2-私有IP地址"><a href="#2-2-私有IP地址" class="headerlink" title="2.2 私有IP地址"></a>2.2 私有IP地址</h2><p>经常可以看到<code>192.168.1.101</code>这类的IP地址, 这些是私有IP地址, 专用地址, 也就是局域网内使用的的IP地址。<br>公网IP地址是需要向有关部门申请备案的，私有IP地址不用申请, 但是仅限内网使用, 也节约公网IP。</p><table><thead><tr><th>IP地址种类</th><th>私有IP范围</th></tr></thead><tbody><tr><td>A类地址</td><td>10.0.0.0 - 10.255.255.255</td></tr><tr><td>B类地址</td><td>172.16.0.0 - 172.31.255.255</td></tr><tr><td>C类地址</td><td>192.168.0.0 - 192.168.255.255</td></tr></tbody></table><p>路由器看到专用地址就不转发，所以说专用地址作为目的地址是不可能在因特网上传送的。专用IP地址也可叫做可重用地址。那好，问题来了，如果配置了这些专用地址的主机想和因特网上的主机通信，怎么办呢？NAT(network address translation: 网络地址转换)在这种情况下就应运而生了。NAT就是将这种地址转换成有效的外部全球IP地址，使得整个专用网只需要一个全球IP地址就可以与因特网联通。</p><h2 id="2-3-子网掩码"><a href="#2-3-子网掩码" class="headerlink" title="2.3 子网掩码"></a>2.3 子网掩码</h2><p><code>IP地址=标准网络号+子网号+主机号</code>。从IP分类可以很容易确定“标准网络号”，<code>32bit</code>的IP地址除去前面的“标准网络号”之后，剩下的就是“子网号”和“主机号”，那么怎么确定“子网号”和“主机号”了？ 这就需要借助<code>“子网掩码”</code>了。子网掩码也是一个32bit(<code>xxx.xxx.xxx.xxx</code>)的值，其中值为1的bit留给“标准网络号”和“子网号”，为0的bit留给“主机号”。我们可以将子网掩码和IP地址进行二进制<code>“与运算”</code>，通过得到的结果来确定“子网号”。</p><p>以C类IP地址为例，对于规范的C类IP地址来说，规范子网掩码为<code>255.255.255.0</code>，即用32比特IP地址的前24比特标识网络号，后8比特标识主机号。因而，每个C类网络下共可容纳254台主机($2^8-2$)。 如今，我们先思索借用2比特的主机号来充任子网络号的情形。</p><p>C类网络地址<code>210.31.233.0</code>，我们借用2bit的主机号来充当子网号，子网的数目为$2^2-2$(子网号无法全为0或1，所以减2).</p><p><img src="https://static.1key.run/blog/wangluoxieyi-jichugailian-2.jpg"></p><p>为了借用原来8位主机号中的前2位充任子网络号，采用了新的非规范子网掩255.255.255.192。<br>采用了新的子网掩码后，借用的2位子网号可以用来标识两个子网：01子网和10子网(子网号无法全为0或1，因而00、11子网无法用)。 </p><p><strong>对于上图的01子网来说</strong>，其网络号的点分十进制的方式为：<code>210.31.233.64</code>，该子网的最小IP地址为：<code>210.31.233.65</code>，最大IP地址为：<code>210.31.233.126</code>（主机号全为1位广播地址），共可容纳62台主机。对该子网的直接广播地址为：<code>210.31.233.127</code>（主机号全为1）。</p><blockquote><p>经常见到像<code>192.168.1.0/24</code>这样的写法，它的意思是网络号为<code>192.168.1.0</code>；子网掩码为24位，即<code>111111111 111111111 111111111 00000000</code>，转为点分十进制就为<code>255.255.255.0</code>，没有借用主机号来充当子网号，可以拥有的主机数为$2^8$-2.</p></blockquote><h2 id="2-3-网关的作用"><a href="#2-3-网关的作用" class="headerlink" title="2.3 网关的作用"></a>2.3 网关的作用</h2><p>你的住址IP是<code>武汉市洪山区文治街16号</code>，你的父母只允许你和文治街的小朋友（同一个子网）一起玩耍，如果你想要去和别的街道（别的子网）的小朋友玩耍，你就需要经过你的父母的同意，由你的父母带你过去，这时候你的父母就充当了<strong>网关</strong>的角色，没有你的父母，你就不能和其他街道（其他子网）的小朋友玩耍。</p><h1 id="三、包的封装与解封装"><a href="#三、包的封装与解封装" class="headerlink" title="三、包的封装与解封装"></a>三、包的封装与解封装</h1><blockquote><p>封装英文：Encapsulation<br>解封装英文：Demultiplexing</p></blockquote><p>当应用程序使用网络传送数据时，数据按照协议栈从上到下的顺序，逐次通过每一层。其中每一层对收到的数据都要增加一些首部信息（有时还增加尾部信息）。最终生成一串比特流通过以太网来传输，我们称这串比特流叫帧。<br>如图：<br><img src="https://static.1key.run/blog/wangluoxieyi-jichugailian-3.jpg"></p><p><strong>当数据报到达链路层时</strong>，链路层也要对IP数据包封装进行包装。链路层也要对IP数据包封装的方式主要有<code>以太网IP数据包封装</code>（RFC894）、<code>IEEE 802 IP数据报封装</code>（RFC1042）两种，最常使用的封装格式是以太网IP数据包封装（RFC894）。下图显示了这两种不同形式的封装格式：<br><img src="https://static.1key.run/blog/wangluoxieyi-jichugailian-4.jpg"><br>从图中可以看到<code>以太网封装</code>限制了数据帧的最大长度为1500字节，这个限制叫做MTU，最大传输单元（详见第四节）。</p><p>接收端收到帧之后，按照和上面相反的顺序（协议栈从下到上）来解包，依次解析每一层加入的头部（或尾部），最终将原始数据传给最上层应用程序。<br>如图：<br><img src="https://static.1key.run/blog/wangluoxieyi-jichugailian-5.jpg"></p><p>因为传输层的TCP、UDP、ICMP等都有可能向网络层IP协议传送数据，这样在IP协议层解包的时候，需要知道这个包对应的上层协议是哪一个，因此IP协议必须在生成的IP首部加入某种标识，以表明数据的上一层的具体协议。为此，IP在首部中存入了一个长度为8bit的数值，称作协议域。常见的IP协议号有：<br>1表示ICMP协议，2表示IGMP协议，6表示TCP协议，17表示UDP协议。</p><blockquote><p>完整的IP协议号见：<a href="https://zh.wikipedia.org/wiki/IP%E5%8D%8F%E8%AE%AE%E5%8F%B7%E5%88%97%E8%A1%A8">IP协议号列表</a></p></blockquote><h1 id="四、MTU"><a href="#四、MTU" class="headerlink" title="四、MTU"></a>四、MTU</h1><p>前面第三节提到了以太网封装限制了数据帧的长度为1500字节，这个限制是在链路层封装IP数据报时作的。如果IP层的数据报比链路层的这个MTU值大，那么IP层就需要分片（英文：fragmentation），把数据报分成若干片，保证每一片的大小都小于MTU值。</p><h3 id="windows系统修改MTU值"><a href="#windows系统修改MTU值" class="headerlink" title="windows系统修改MTU值"></a>windows系统修改MTU值</h3><ul><li><p>查询当前MTU值</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">netsh interface ipv4 show subinterfaces<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://static.1key.run/blog/wangluoxieyi-jichugailian-6.jpg"></p></li><li><p>修改MTU值</p><pre class="line-numbers language-none"><code class="language-none">netsh interface ipv4 set subinterface "本地连接" mtu=1480 store=persistent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><blockquote><p>文章参考：<br><a href="https://m.vipcn.com/a/360973/">https://m.vipcn.com/a/360973/</a><br><a href="https://ahaochan.github.io/posts/IP_address,_subnet_mask,_gateway_Introduction.html">https://ahaochan.github.io/posts/IP_address,_subnet_mask,_gateway_Introduction.html</a><br><a href="https://www.zhihu.com/question/20717354">https://www.zhihu.com/question/20717354</a></p></blockquote><p>《TCP/IP详解 卷1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> IP地址 </tag>
            
            <tag> 子网掩码 </tag>
            
            <tag> 网关 </tag>
            
            <tag> MTU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解C/C++运行时库</title>
      <link href="/2023/06/20/li-jie-c-c-yun-xing-shi-ku/"/>
      <url>/2023/06/20/li-jie-c-c-yun-xing-shi-ku/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、什么是运行时库"><a href="#一、什么是运行时库" class="headerlink" title="一、什么是运行时库"></a>一、什么是运行时库</h2><p>运行时库（Runtime library）通俗的说就是我们的程序运行的时候所依赖的库文件，在Windows平台这些库由微软提供，并且是以2种形式提供：<code>静态库(lib)</code>、<code>动态库(lib+dll)</code>。每个库还都提供<code>debug</code>、<code>release</code> 2个版本。</p><p>C/C++运行时库从形式上来讲和我们自己开发的静态库、动态库没什么两样，只是它们由微软开发和维护，并提供了一些常用的功能支持（如<code>malloc</code>,<code> free</code>, <code>printf</code>等等），如果我们的程序需要使用这些功能（事实上，只要是C/C++程序就一定会用到运行时库提供的功能），就要链接C/C++运行时库。我们可以自主选择是链接“静态库”还是“动态库”，是链接“debug版本”的还是“release版本”的。</p><h2 id="二、如何链接运行时库"><a href="#二、如何链接运行时库" class="headerlink" title="二、如何链接运行时库"></a>二、如何链接运行时库</h2><p>大家可能注意到我们在平时开发中从来没有显式的来链接这些库，这是为什么了？<br>因为我们的编译器为我们提供了便利，我们只需要向编译器指定特定的编译选项（如<code>MT、MD、MTd、MDd</code>），编译器就会自动链接对应的库。</p><p>同时，编译器会根据<code>MT</code>和<code>MD</code>来定义相应的预处理宏：<code>MT</code> 对应 <code>_MT宏</code>，<code>MD</code>对应<code>_MD宏</code>。</p><p>例如，我们通过<code>Visual Studio</code>开发C/C++程序时，在工程属性中配置“运行库”为<code>MT、MD、MTd、MDd</code>中的一个：<br><img src="https://static.1key.run/blog/windows-hxbc-ljynsk-1.jpg"><br>就相当于间接的向编译器指定编译选项和定义相应的宏。</p><h2 id="三、不同版本和形态的运行时库"><a href="#三、不同版本和形态的运行时库" class="headerlink" title="三、不同版本和形态的运行时库"></a>三、不同版本和形态的运行时库</h2><h3 id="3-1-运行时库对应的文件"><a href="#3-1-运行时库对应的文件" class="headerlink" title="3.1 运行时库对应的文件"></a>3.1 运行时库对应的文件</h3><p>下表列出各种编译选项的含义以及对应的库文件：</p><table><thead><tr><th>类型</th><th>全称</th><th>含义</th><th>对应的库文件</th><th>备注</th></tr></thead><tbody><tr><td>ML</td><td>Single-Threaded</td><td>Release版的单线程静态库</td><td><code>libc.lib</code></td><td>从VS2005起被废弃</td></tr><tr><td>MLd</td><td>Single-Threaded Debug</td><td>Debug版的单线程静态库</td><td><code>libcd.lib</code></td><td>从VS2005起被废弃</td></tr><tr><td>MT</td><td>Multi-threaded</td><td>Release版的多线程静态库</td><td><code>libcmt.lib</code></td><td></td></tr><tr><td>MTd</td><td>Multi-threaded Debug</td><td>Debug版的多线程静态库</td><td><code>libcmtd.lib</code></td><td></td></tr><tr><td>MD</td><td>Multi-threaded DLL</td><td>Release版的多线程动态库</td><td><code>msvcrt.lib + msvcrxxx.dll</code> <code>msvcprt.lib+msvcpxxx.dll</code></td><td></td></tr><tr><td>MDd</td><td>Multi-threaded DLL Debug</td><td>Debug版的多线程动态库</td><td><code>msvcrtd.lib + msvcrxxxd.dll</code> <code>msvcprtd.lib + msvcpxxxd.dll</code></td><td></td></tr></tbody></table><p>如果计算机上安装了多个版本的VC++运行环境（或者多个版本的Visual Studio），则相同名称的lib或dll就会存在多份。如<code>msvcrt.lib</code>文件：<br><img src="https://static.1key.run/blog/windows-hxbc-ljynsk-2.jpg"></p><h3 id="3-2-运行时库文件命名规则"><a href="#3-2-运行时库文件命名规则" class="headerlink" title="3.2 运行时库文件命名规则"></a>3.2 运行时库文件命名规则</h3><p><code>msvcr100d.dll</code>为例：</p><pre class="line-numbers language-none"><code class="language-none">ms = Microsoftv = Visualc = C Programr = Run-time100 = Versiond = Debug   (不带d即为release版本)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>msvcp100d.dll</code>为例：</p><pre class="line-numbers language-none"><code class="language-none">ms = Microsoftv = Visualcp = C Plus Plus 即C++100 = Versiond = Debug   (不带d即为release版本)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、运行时库使用注意事项"><a href="#四、运行时库使用注意事项" class="headerlink" title="四、运行时库使用注意事项"></a>四、运行时库使用注意事项</h2><ul><li>不要混合使用运行时库的<code>静态库版</code>和<code>动态库版</code>。</li><li>不要混合使用运行时库的<code>debug版</code>和<code>release版</code>。</li><li>不要混合使用Visual Studio 2013 及更早版本的运行时库，但在 Visual Studio 2015 及更高版本中提供的运行时库可以保证二进制兼容。</li></ul><h2 id="五、Visual-Studio-版本之间的-C-二进制兼容性（摘自MSDN）"><a href="#五、Visual-Studio-版本之间的-C-二进制兼容性（摘自MSDN）" class="headerlink" title="五、Visual Studio 版本之间的 C++ 二进制兼容性（摘自MSDN）"></a>五、Visual Studio 版本之间的 C++ 二进制兼容性（摘自MSDN）</h2><p>Visual Studio 2013 及更早版本中的 Microsoft C++ (MSVC) 编译器工具集不保证主版本间的二进制兼容性。 无法链接由这些工具集的不同版本生成的对象文件、静态库、动态库和可执行文件。 ABI、对象格式和运行时库不兼容。</p><p>我们在 Visual Studio 2015 及更高版本中改变了此行为。 由其中任一版本的编译器编译的运行时库和应用具有二进制兼容性。 这反映在 C++ 工具集主版本号中，对于自 Visual Studio 2015 以来的所有版本，<strong>该版本号都以 14 开头</strong>。 （对于 Visual Studio 2015、2017、2019 和 2022，工具集版本分别为 v140、v141、v142 和 v143）。** 假设你具有 Visual Studio 2015 生成的第三方库。 你仍可在 Visual Studio 2017、2019 或 2022 生成的应用程序中使用它们。 无需使用匹配工具集重新编译**。 最新版本的 Microsoft Visual C++ 可再发行程序包（可再发行程序包）适用于所有版本。</p><h3 id="对二进制兼容性的限制"><a href="#对二进制兼容性的限制" class="headerlink" title="对二进制兼容性的限制"></a>对二进制兼容性的限制</h3><p>v140、v141、v142 和 v143 工具集与次要版本号更新之间的二进制兼容性方面存在三个重要限制：</p><ul><li>你可以混合使用由 v140、v141、v142 和 v143 工具集的不同版本生成的二进制文件。 但是，<strong>必须使用至少与应用中最新二进制文件同样新的工具集进行链接</strong>。 下面是一个示例：可以将使用任何 2017 工具集（v141，版本 15.0 到 15.9）编译的应用链接到使用 Visual Studio 2019 版本 16.2 (v142) 编译的静态库。 只是必须使用版本 16.2 或更高版本工具集链接它们。 只要使用 16.4 或更高版本工具集，便可以将版本 16.2 库链接到版本 16.4 应用。</li><li>应用使用的可再发行程序包具有类似的二进制兼容性限制。 混合使用由工具集的不同受支持版本生成的二进制文件时，可再发行程序包版本必须至少与任何应用组件使用的最新工具集一样新。</li><li>使用<a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/gl-whole-program-optimization?view=msvc-170">/GL</a><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/gl-whole-program-optimization?view=msvc-170">（全程序优化）</a>编译器开关编译或是使用 <a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/ltcg-link-time-code-generation?view=msvc-170">/LTCG</a><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/ltcg-link-time-code-generation?view=msvc-170">（链接时间代码生成）</a>链接的静态库或对象文件不在各个版本间二进制兼容（包括次要版本更新）。使用 <code>/GL</code> 和 <code>/LTCG</code> 编译的所有对象文件和库必须将完全相同的工具集用于编译和最终链接。 例如，使用 Visual Studio 2019 版本 16.7 工具集中的 <code>/GL</code>生成的代码无法链接到使用 Visual Studio 2019 版本 16.8 工具集中的 <code>/GL</code>生成的代码。 编译器会发出<a href="https://learn.microsoft.com/zh-cn/cpp/error-messages/compiler-errors-1/fatal-error-c1047?view=msvc-170">错误 C1047</a>。</li></ul><h3 id="从-Visual-Studio-2015-及更高版本升级-Microsoft-Visual-C-可再发行程序包"><a href="#从-Visual-Studio-2015-及更高版本升级-Microsoft-Visual-C-可再发行程序包" class="headerlink" title="从 Visual Studio 2015 及更高版本升级 Microsoft Visual C++ 可再发行程序包"></a>从 Visual Studio 2015 及更高版本升级 Microsoft Visual C++ 可再发行程序包</h3><p>对于 Visual Studio 2015、2017、2019 和 2022，我们使 Microsoft Visual C++ 可再发行程序包主版本号保持相同。 这意味着一次只能安装可再发行程序包的一个实例。 较新版本会覆盖已安装的任何较旧版本。 例如，一个应用可能会从 Visual Studio 2015 安装可再发行程序包。 随后另一个应用从 Visual Studio 2022 安装可再发行程序包。 2022 版本会覆盖较旧版本，但由于它们具有二进制兼容性，早期应用仍可正常工作。 我们确保最新版本的可再发行程序包具有所有最新的功能、安全更新和 bug 修补程序。 这便是为什么我们始终建议升级到最新可用版本。</p><p>同样，已安装了较新版本时，无法安装较旧的可再发行程序包。 如果尝试，则安装程序会报告错误。 如果在已具有 2022 版本的计算机上安装 2017 或 2019 可再发行程序，则会看到如下所示的错误：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">0x80070666 - Another version of this product is already installed. Installation of this version cannot continue. To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此错误是设计使然。 建议保持安装最新版本。 请确保安装程序可以在无提示的情况下从此错误中恢复。</p>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运行时库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(7)--使用std::string跨MT模块传参</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-7-shi-yong-std-string-kua-mt-mo-kuai-chuan-can/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-7-shi-yong-std-string-kua-mt-mo-kuai-chuan-can/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><p>前面的<a href="/2023/06/20/windows-nei-cun-ti-xi-6-kua-mo-kuai-nei-cun-fen-pei-shi-fang/" title="Windows内存体系(6)--跨模块内存分配释放">Windows内存体系(6)--跨模块内存分配释放</a>文章解释了跨MT模块分配的内存相互释放为什么会崩溃的问题。</p><h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>这篇文章主要介绍我们在实际开发中经常遇到的一个问题：针对MT模块定义接口函数时，接口参数使用<code>std::string</code>类型，在程序运行时遇到<code>"Debug Assertioni Failed"</code>错误的问题。<br><img src="https://static.1key.run/blog/windows-nctx-stdstring-mt-1.jpg"></p><p>上面的错误提示是<code>debug_heap.cpp</code>文件中的一个调试断言（<code>release模式</code>下调用的是<code>heap.cpp</code>中的分配函数），用于判断指针是否指向堆分配的内存块的第一块。在release模式下不会弹出这样的断言错误，程序可能会直接崩溃（崩溃相对来说还比较好排查），或者出现其他不可预料的、难以排查的错误。</p><h2 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h2><p>现有<code>DLLUser.exe</code>调用<code>DLL.dll</code>中的<code>TestFun</code>函数，代码量非常小：</p><h4 id="DLL-dll中TestFun函数定义："><a href="#DLL-dll中TestFun函数定义：" class="headerlink" title="DLL.dll中TestFun函数定义："></a><code>DLL.dll</code>中<code>TestFun</code>函数定义：</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">DLL_API void TestFun( std::string str){return;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="DLLUser-exe中调用TestFun函数："><a href="#DLLUser-exe中调用TestFun函数：" class="headerlink" title="DLLUser.exe中调用TestFun函数："></a><code>DLLUser.exe</code>中调用<code>TestFun</code>函数：</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int _tmain(int argc, _TCHAR* argv[]){std::string str = "test";TestFun(str);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码运行之后程序就会弹出错误断言。原因是<code>std::string</code>在进行<code>值传参</code>的过程中会执行一次深拷贝，即：在堆上分配内存块，拷贝“test”到内存块中，然后将临时形参<code>std::string</code>对象传递到dll中，dll中的<code>TestFun</code>函数在作用域结束后对临时形参进行释放时就出现了错误，因为尝试在<code>dll的crt堆</code>中释放由在<code>exe的crt堆</code>中分配的内存块。</p><p><img src="https://static.1key.run/blog/windows-nctx-stdstring-mt-2.jpg"></p><h2 id="三、自定义std-allocator解决崩溃"><a href="#三、自定义std-allocator解决崩溃" class="headerlink" title="三、自定义std::allocator解决崩溃"></a>三、自定义<code>std::allocator</code>解决崩溃</h2><p>通过上面问题的分析，加上前面几篇文章对Windows内存体系的介绍，我们不难想出解决方案，其中一种方案就是让<code>std::string</code>统一在进程的默认堆上分配内存块，而不是在各个模块的<code>crt堆</code>上分配。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;windows.h&gt;#include &lt;string&gt;#include &lt;vector&gt;template &lt;typename T&gt;class vm_allocator : public std::allocator&lt;T&gt; {public:typedef size_t size_type;typedef T* pointer;typedef const T* const_pointer;template&lt;typename _Tp1&gt;struct rebind {typedef vm_allocator&lt;_Tp1&gt; other;};pointer allocate(size_type n, const void *hint = 0) {UNREFERENCED_PARAMETER(hint);void* pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, n * sizeof(T));return (pointer)pBuffer;}void deallocate(pointer p, size_type n) {UNREFERENCED_PARAMETER(n);if (p) {HeapFree(GetProcessHeap(), 0, p);}}vm_allocator() throw() : std::allocator&lt;T&gt;() {}vm_allocator(const vm_allocator &amp;a) throw() : std::allocator&lt;T&gt;(a) {}template &lt;class U&gt;vm_allocator(const vm_allocator&lt;U&gt; &amp;a) throw() : std::allocator&lt;T&gt;(a) {}~vm_allocator() throw() {}};typedef std::basic_string&lt;char, std::char_traits&lt;char&gt;, vm_allocator&lt;char&gt; &gt; mystring;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码使用自定义的内存分配器<code>vm_allocator&lt;char&gt;</code>定义了<code>mystring</code>类，我们只需要将<code>TestFun</code>函数接口中的<code>std::string</code>修改为<code>mystring</code>即可解决崩溃问题。</p>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MT </tag>
            
            <tag> DLL </tag>
            
            <tag> std::string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(6)--跨模块内存分配释放</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-6-kua-mo-kuai-nei-cun-fen-pei-shi-fang/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-6-kua-mo-kuai-nei-cun-fen-pei-shi-fang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><p> <code>《Windows核心编程 第五版》第19章 DLL基础（511页）</code>中给出了一个建议：“当一个MT版本的模块如果提供一个内存分配函数的时候，它必须同时提供另一个用来释放内存的函数。”。说得更加直白一点就是，“对于MT的模块，不要跨模块进行内存释放。”。但是核心编程这本书上面没有具体分析原因，本文就来分析具体的原因。</p><h2 id="一、为什么不同堆分配的内存块不能相互释放？"><a href="#一、为什么不同堆分配的内存块不能相互释放？" class="headerlink" title="一、为什么不同堆分配的内存块不能相互释放？"></a>一、为什么不同堆分配的内存块不能相互释放？</h2><p>Windows的<code>堆管理器</code>对每个进程都维护了多个<code>“堆”</code>，我们从每个<code>“堆”</code>中分配处理的内存块的地址都不一样。所以我们不能将从“堆A”中分配出来的内存块拿到“堆B”中，让“堆B”来释放，这样就会导致程序异常。</p><p><img src="https://static.1key.run/blog/windows-nctx-kmkncsf-1.png"></p><p>如上图，通过<code>malloc</code>函数从“堆A”中分配100字节内存块，内存块地址为<code>0x123456</code>；从“堆B”中分配100字节内存块，内存块地址为<code>0x345678</code>.<br>如果将<code>0x123456</code>这个地址拿到“堆B”中去释放，势必会导致异常，因为“堆B”中没有这地址。</p><p>那么我们是不是可以使用<code>HeapFree</code>函数来释放<code>hHeap</code>参数指定的“堆”中的任何内存块了。答案是：不能。<br>回忆前面介绍的<code>HeapFree</code>函数，</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">BOOL HeapFree(  HANDLE hHeap,  DWORD dwFlags,  LPVOID lpMem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数只要求传入了内存块的起始地址指针，但没有要求传入需要释放的内存块的<code>大小</code>，那么该函数是如何知道起始地址指针指向的内存块的大小了？ </p><p>我们可以简单的理解为，<code>HeapAlloc</code>函数每次分配内存块的时候都会额外分配一点空间用于存储一个结构体，该结构体中存储了本次分配的内存块的大小等信息。大致如下图：<br><img src="https://static.1key.run/blog/windows-nctx-kmkncsf-2.jpg"></p><p>所以，<code>HeapFree</code>函数首先会通过<code>lpMem</code>指针计算出“结构体”的地址，然后从结构体中获取到分配的内存块的具体大小，最后执行释放操作。</p><p>基于上面的原因，我们不能在<code>HeapFree</code>函数的<code>lpMem</code>参数中传入随意的地址，因为该地址处可能没有存储用于存放内存块信息的结构体，所以释放操作就会失败。<code>free</code>函数也一样，因为<code>free</code>函数内部也是调用的<code>HeapFree</code>函数。</p><h2 id="二、为什么MT模块内存不能相互释放，而MD的却可以？"><a href="#二、为什么MT模块内存不能相互释放，而MD的却可以？" class="headerlink" title="二、为什么MT模块内存不能相互释放，而MD的却可以？"></a>二、为什么MT模块内存不能相互释放，而MD的却可以？</h2><h3 id="我们先分析为什么MT模块的内存间相互释放会崩溃。"><a href="#我们先分析为什么MT模块的内存间相互释放会崩溃。" class="headerlink" title="我们先分析为什么MT模块的内存间相互释放会崩溃。"></a>我们先分析为什么MT模块的内存间相互释放会崩溃。</h3><p>现在有2个模块（<code>A.dll</code>和<code>B.dll</code>）都是使用<code>MT</code>运行时库，即加载的静态库<code>libcmt.lib</code>（可以参考<a href="/2023/06/20/li-jie-c-c-yun-xing-shi-ku/" title="理解C/C++运行时库">理解C/C++运行时库</a>），在<code>A.dll</code>中使用<code>malloc</code>分配100字节的内存，<code>malloc</code>返回的内存地址为<code>0x123456</code>。然后将该地址传给<code>B.dll</code>，在<code>B.dll</code>中调用<code>free</code>函数来释放这个内存。如图：<br><img src="https://static.1key.run/blog/windows-nctx-kmkncsf-3.jpg"></p><p>从<a href="/2023/06/20/windows-nei-cun-ti-xi-5-dui/" title="Windows内存体系(5)--堆">Windows内存体系(5)--堆</a>我们知道，DLL在启动代码<code>_DllMainCRTStartup</code>中会建立一个“堆”（堆句柄存放在_crtheap变量中），所以A.dll和B.dll中都会有一个crt堆。</p><p>为了区分，我们将<code>A.dll</code>中的<code>crt堆</code>称作<code>_crtheap_A</code>，<code>B.dll</code>中的<code>crt堆</code>称作<code>_crtheap_B</code>。</p><p>从上面图可以看到，<code>A.dll</code>中<code>malloc</code>的内存拿到<code>B.dll</code>去中去<code>free</code>，就相当于从堆<code>_crtheap_A</code>中分配的内存拿到另一个堆<code>_crtheap_B</code>中的释放。第一节已经解释了为什么不能这样做了。</p><h3 id="现在我们分析为什么MD模块的内存间相互释放不会崩溃。"><a href="#现在我们分析为什么MD模块的内存间相互释放不会崩溃。" class="headerlink" title="现在我们分析为什么MD模块的内存间相互释放不会崩溃。"></a>现在我们分析为什么MD模块的内存间相互释放不会崩溃。</h3><p>还是2个模块（<code>A.dll</code>和<code>B.dll</code>），但是现在他们都是使用<code>MD</code>运行时库，即加载的动态库<code>msvcr100.dll</code>，程序的代码的过程和上面一样，还是在<code>A.dll</code>中使用<code>malloc</code>分配100字节的内存，<code>malloc</code>返回的内存地址为<code>0x123456</code>。然后将该地址传给<code>B.dll</code>，在<code>B.dll</code>中调用<code>free</code>函数来释放这个内存。但是这个时候程序却不会崩溃，通过下面的图我们基本可以明白原因了，如图：<br><img src="https://static.1key.run/blog/windows-nctx-kmkncsf-4.jpg"></p><p>因为A、B两个dll都是链接的·msvcr100.dll·，同一个dll在一个进程只会被加载一次，所以进程中只会有一个crt堆（<code>_crtheap</code>），<code>malloc</code>和<code>free</code>都是运行时库提供的函数，所以都会调到运行时库里面去，然后从运行时库里面的<code>_crtheap</code>分配和释放内存块。因为分配和释放都是在同一个堆上，所以不会崩溃。</p>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MT </tag>
            
            <tag> DLL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(5)--堆</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-5-dui/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-5-dui/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、为什么要使用堆-Heap-？"><a href="#一、为什么要使用堆-Heap-？" class="headerlink" title="一、为什么要使用堆 (Heap)？"></a>一、为什么要使用堆 (Heap)？</h2><p>应用程序虽然可以使用页面粒度的函数（如<code>VirualAlloc</code>）来分配一个最小为<code>4KB</code>或<code>8K</code>的内存块，但是很多时候我们并不需要分配这么大的内存块，我们可能只想分配1K，2K的内存块，那么这个时候无论从内存的使用率，还是从性能的角度来看，再分配这么大的一个内存区域显然不是最优的了。</p><p>为了满足这种需求，Windows提供了一个被称为<code>“堆管理器”</code>的组件，它负责管理大内存区域中的内存分配，这些大内存区域就是通过一些页面粒度的内存分配函数（如<code>VirualAlloc</code>）来预定（<code>reserve</code>）的。</p><p>堆管理器中的分配粒度相对比较小：<code>在32位系统上是8字节，在64位系统上是16字节</code>。</p><p>堆管理器已经被windows系统精心设计成：在这些很小的内存分配的情况下进行了内存使用率和性能两个方面的优化。</p><h2 id="二、进程的默认堆"><a href="#二、进程的默认堆" class="headerlink" title="二、进程的默认堆"></a>二、进程的默认堆</h2><p>每个进程至少有一个堆，那就是进程的<code>默认堆</code>。进程的<code>默认堆</code>是在进程启动的时候创建的，而且在进程的生命周期中永远不会被删除。</p><p><code>“默认堆”</code>的默认大小为<code>1MB</code>，但是可以通过<code>/HEAP</code>链接器编译器选项来指定一个更大的起始大小。这个大小值只是初始的保留内存大小，后期根据需要它可以自动扩充。</p><p>应用程序可以调用<code>GetProcessHeap</code>来获取进程的默认堆，也可以通过调用<code>HeapCreate</code>函数来创建额外的私有堆，当一个进程不在需要一个私有堆的时候，它可以调用<code>HeapDestory</code>来释放虚拟地址空间。</p><h2 id="三、crt堆"><a href="#三、crt堆" class="headerlink" title="三、crt堆"></a>三、crt堆</h2><p>C语言的<code>malloc,free</code>函数以及C++的<code>new,delete</code>都是从<code>堆</code>上分配和释放内存的。但是他们所使用的堆不是进程的<code>默认堆</code>，他们使用的是<code>私有堆</code>。可是我们在使用<code>malloc</code>函数之前并有进行任何私有堆的创建操作呀？ 因为<code>malloc</code>函数使用的这个私有堆不需要程序员来创建，而是在C或C++运行时库DLL的启动代码<code>_DllMainCRTStartup</code>中自动创建的。下面通过解析<code>malloc</code>函数的调用过程来说明这一点。</p><p><code>malloc</code>函数的定义在<code>malloc.c</code>文件中，调用流程如下：<br>（以<code>Microsoft Visual Studio 10.0</code>为例，<code>malloc.c</code>文件路径为<code>C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\crt\src</code>）</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">(1). void* __cdecl malloc(size_t const size)(2). void * __cdecl _malloc_base (size_t size)(3). void * __cdecl _heap_alloc (size_t size)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>_heap_alloc </code>的定义如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">__forceinline void * __cdecl _heap_alloc (size_t size){    if (_crtheap == 0) {        _FF_MSGBANNER();    /* write run-time error banner */        _NMSG_WRITE(_RT_CRT_NOTINIT);  /* write message */        __crtExitProcess(255);  /* normally _exit(255) */    }    return HeapAlloc(_crtheap, 0, size ? size : 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码中，我们可以看到分配内存块的时候使用的是<code>_crtheap</code>句柄标记的堆。那么<code>_crtheap</code>堆是何时创建的了？</p><p>我们从<code>heapinit.c</code>文件中的<code>_heap_init</code>函数可以看到<code>_crtheap</code>堆的创建过程：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">HANDLE _crtheap=NULL;/****_heap_init() - Initialize the heap**Purpose:*       Setup the initial C library heap.**       NOTES:*       (1) This routine should only be called once!*       (2) This routine must be called before any other heap requests.**Entry:*       &lt;void&gt;*Exit:*       Returns 1 if successful, 0 otherwise.**Exceptions:*       If heap cannot be initialized, the program will be terminated*       with a fatal runtime error.********************************************************************************/int __cdecl _heap_init (void){        ULONG HeapType = 2;        //  Initialize the "big-block" heap first.        if ( (_crtheap = HeapCreate(0, BYTES_PER_PAGE, 0)) == NULL )            return 0;#ifdef _WIN64        // Enable the Low Fragmentation Heap by default on Windows XP and        // Windows Server 2003.  It's the 8 byte overhead heap, and has        // generally better performance charateristics than standard heap,        // particularly for apps that perform lots of small allocations.        if (LOBYTE(GetVersion()) &lt; 6)        {            HeapSetInformation(_crtheap, HeapCompatibilityInformation,                               &amp;HeapType, sizeof(HeapType));        }#endif  /* _WIN64 */        return 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码，我们可以看到，创建的<code>私有堆</code>句柄存放在一个<code>全局的_crtheap变量</code>中，后面每次调用<code>malloc</code>函数都是从该堆分配内存块。</p><h2 id="四、Win32堆函数"><a href="#四、Win32堆函数" class="headerlink" title="四、Win32堆函数"></a>四、Win32堆函数</h2><p>我们最常用的Windows堆函数如下：</p><ul><li><code>HeapCreate</code>或<code>HeapDestory</code> — 创建或删除一个私有堆</li><li><code>HeapAlloc</code> — 分配一个堆内存块</li><li><code>HeapFree</code> — 释放一个原先由<code>HeapAlloc</code>分配的内存块</li><li><code>HeapReAlloc</code> — 增长或缩减一个已分配的内存块的大小</li><li><code>HeapLock</code>或<code>HeapUnLock</code> — 控制堆操作的内存访问</li><li><code>HeapWalk</code> — 列举一个堆内部的内存项和区域。</li></ul><h2 id="五、Windows内存管理API分层结构"><a href="#五、Windows内存管理API分层结构" class="headerlink" title="五、Windows内存管理API分层结构"></a>五、Windows内存管理API分层结构</h2><p><img src="https://static.1key.run/blog/windows-nctx-dui-1.gif"></p><p>从上图可以看到，虚拟内存机制（<code>Virtual Memory</code>）是windows内存体系的基础，无论你是使用<code>堆</code>，还是使用<code>内存映射文件</code>，它们的底层都是基于虚拟内存来实现的。</p><p>从上往下，每一层的API在内部会依次调用下一层的API。下图中列举了每层API中经常使用的函数：</p><ul><li><strong>CRT Memory Functions：</strong><code>malloc, free, new, delete</code></li><li><strong>Local, Global Memory API: ** <code>LocalAlloc, GlobalAlloc</code> （</strong>这2个函数现在不建议使用，注意是为了兼容以前的老代码才保留下来的**）</li><li><strong>Heap Memory API：</strong><code>HeapCreate, HeapAlloc, HeapDestory</code></li><li><strong>Virtual Memory API：</strong><code>VirtualAlloc, VirtualFree</code></li><li><strong>Memory Mapped File API：</strong><code>CreateFileMapping, MapViewOfFile, MapViewOfFileEx, UnMapViewOfFile</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> Heap </tag>
            
            <tag> 内存管理API分层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(4)--内存对齐</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-4-nei-cun-dui-qi/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-4-nei-cun-dui-qi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、内存为什么要对齐"><a href="#一、内存为什么要对齐" class="headerlink" title="一、内存为什么要对齐"></a>一、内存为什么要对齐</h2><p>虽然所有的变量都是保存在特定地址的内存中，但最好还是按照内存对齐的要求来存储。这主要出于两个方面的原因考虑： </p><ol><li>平台原因：<br>不是所有的硬件平台(特别是嵌入式系统中使用的低端处理器)都能访问任意地址上的任意数据，某些硬件平台只能访问对齐的地址，否则会出现硬件异常。 </li><li>性能原因：<br>如果数据存放在未对齐的内存空间中，则处理器访问变量时需要进行两次内存访问才能完整读取该变量的值，而对齐的内存访问仅需一次访问。</li></ol><h2 id="二、内存对齐的规则"><a href="#二、内存对齐的规则" class="headerlink" title="二、内存对齐的规则"></a>二、内存对齐的规则</h2><ol><li><p>对于结构（或联合）的各个成员，第一个成员位于偏移为0，以后每个数据成员的偏移量必须是<code>#pragma pack指定的数值和结构体(或联合)中最大数据成员长度 这2个数值中较小的一个</code>的倍数。<br>使用伪代码表示： <code>min(#pragma pack, 结构最大数据成员长度) * N</code></p></li><li><p>在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐也按照<code>#pragma pack指定的数值和结构(或联合)最大数据成员长度这2个数值中较小的一个</code>进行。</p></li></ol><blockquote><p>如果没有使用<code>#pragma pack</code>指令来显式的指定内存对齐的字节数，则按照默认字节数来对齐，各个平台的默认对齐规则如下：<code>32位CPU默认按照4字节对齐；64位CPU默认按照8字节对齐。</code></p></blockquote><h2 id="三、-pragma-pack命令"><a href="#三、-pragma-pack命令" class="headerlink" title="三、#pragma pack命令"></a>三、#pragma pack命令</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma pack(n) // 使用自定义n字节对齐  n可以为1，2，4，8，16#pragma pack()  // 使用缺省字节对齐#pragma pack(show) // 在编译输出窗口以警告的形式显示出当前的内存以几个字节对齐<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="四、结构体内存对齐示例"><a href="#四、结构体内存对齐示例" class="headerlink" title="四、结构体内存对齐示例"></a>四、结构体内存对齐示例</h2><p>在64位系统上编译下面的测试程序，已知在64位系统上各类型占用字节数如下：</p><pre class="line-numbers language-none"><code class="language-none">char     1字节short    2字节int      4字节long     4字节double   8字节long long 8字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma pack(8)struct A {char s[5];short c;int a;};int main(){int i = sizeof(A);printf("%d", i);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照第二节所讲的内存对齐规则，分析如下：<br>因为结构体中最大的数据成员长度为int（即4字节），而且<code>#pragma pack(8)</code>指令指定按照8字节对齐，所以<code>min(4,8) = 4</code>，故我们可以知道结构体A按照4字节对齐。</p><p>下图是结构体A按照4字节对齐的内存布局（需要注意的是“内存不是填充在s5后面，而是填充在c后面”）：<br><img src="https://static.1key.run/blog/windows-nctx-ncdq-1.jpg"></p><p>从图我们很容易知道<code>sizeof(A) = 12</code>.</p>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存对齐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(3)--内存映射文件</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-3-nei-cun-ying-she-wen-jian/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-3-nei-cun-ying-she-wen-jian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一、为什么需要内存映射"><a href="#一、为什么需要内存映射" class="headerlink" title="一、为什么需要内存映射"></a>一、为什么需要内存映射</h1><p><code>“内存映射文件”</code>可以将硬盘上的文件映射到<code>虚拟地址空间</code>，这样就不需要将所有东西都放入到页交换文件中，比如系统有许多程序同时运行时，如果将这些程序文件都加载到页交换文件中，<code>页交换文件</code>将会变得非常大。事实上，Windows也并没有将硬盘上的程序文件复制到<code>页交换文件</code>中，因为这样不仅会让<code>页交换文件</code>将会变得非常大，也会浪费很多时间，特别是可执行程序非常大的时候。</p><p>当用户要求执行一个应用程序时，系统会打开该应用程序的<code>.exe</code>文件，并计算出应用程序的代码和数据的大小，然后系统会在进程的虚拟地址空间预定一块地址空间，并注明与该区域相关联的物理存储器就是<code>.exe</code>文件本身。</p><p>当把一个位于硬盘上的文件（可以是<code>.exe</code>，<code>.dll</code>也可以是普通文件）映像用作地址空间区域对应的物理存储器时，我们称这个文件映像为<code>“内存映射文件”</code>。</p><p>现在我们可以对<a href="/2023/06/20/windows-nei-cun-ti-xi-2-xu-ni-nei-cun/" title="Windows内存体系(2)--虚拟内存">Windows内存体系(2)--虚拟内存</a>第2节的图进行完善了，加入“内存映射文件”部分：<br><img src="https://static.1key.run/blog/windows-nctx-ncys-1.png"></p><h1 id="二、内存映射文件技术介绍"><a href="#二、内存映射文件技术介绍" class="headerlink" title="二、内存映射文件技术介绍"></a>二、内存映射文件技术介绍</h1><p>常用的有Win32 API的<code>CreateFile()</code>、<code>WriteFile()</code>、<code>ReadFile()</code>和MFC提供的<code>CFile</code>类都可以实现文件的读写操作。一般来说，以上这些函数可以满足大多数场合的要求，但是对于某些特殊应用领域所需要的动辄几十GB、几百GB、乃至几TB的海量存储，此时在以平常的文件处理方法进行处理显然是行不通的（效率低下，而且内存没那么大）。目前，对于这种大文件的操作一般是以内存映射文件的方式来加以处理的。</p><p>内存映射文件也是Windows的一种内存管理方法，提供了一个统一的内存管理特征，使应用程序可以通过内存指针对磁盘上的文件进行访问。通过文件映射将磁盘文件内容（全部或者部分）与进程虚拟地址空间的某个区域建立映射关联，可以直接对被映射的文件进行访问，而不必执行文件I/O操作也无需对文件内容进行缓冲处理。内存文件映射的这种特性是非常适合于用来管理大尺寸文件的。</p><h1 id="三、大文件读写实例"><a href="#三、大文件读写实例" class="headerlink" title="三、大文件读写实例"></a>三、大文件读写实例</h1><p>通过C++调用系统API实现文件映射的步骤大致如下：<br><img src="https://static.1key.run/blog/windows-nctx-ncys-2.jpg"></p><p>本示例首先在<code>D:\</code>生成一个大小为1GB的<code>BigFile.data</code>文件，然后使用内存映射技术将该文件内全部填充字符A，随后读取其中的<code>第20000~20100字节</code>，并将这些字节修改为字符B，然后再次读取已验证是否修改成功。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;windows.h&gt;void Test() {HANDLE file_ = CreateFile(TEXT("D:\\BigFile.data"), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL,NULL);if (file_ == INVALID_HANDLE_VALUE) {printf("CreateFile failed, GLE:%d\n", GetLastError());return;}LARGE_INTEGER filesize;filesize.QuadPart = 1024 * 1024 * 1024; // 1GBHANDLE mapping_ = CreateFileMapping(file_, NULL, PAGE_READWRITE, filesize.HighPart, filesize.LowPart, NULL);if (mapping_ == NULL) {printf("CreateFileMapping failed, GLE:%d\n", GetLastError());return;}LARGE_INTEGER offset;offset.QuadPart = 0;LPVOID mapping_addr = MapViewOfFile(mapping_, FILE_MAP_WRITE | FILE_MAP_READ, offset.HighPart, offset.LowPart, 0);if (mapping_addr == NULL) {printf("MapViewOfFile failed, GLE:%d\n", GetLastError());return;}// 向文件中填充1GB的字符'A'//char buf[1024];for (int i = 0; i &lt; 1024; i++) {buf[i] = 'A';}// 每次填充1024字节，填充1024*1024次for (long l = 0; l &lt; 1024 * 1024; l++) {memcpy((LPVOID)((long)mapping_addr + l * 1024), buf, 1024);}// 填充完毕// 读取第20000~20100字节，共100字节//char read_content[101] = { 0 };memcpy(read_content, (LPVOID)((long)mapping_addr + 20000), 100);printf("%s\n", read_content);// 将第20000~20100字节，共100字节全部修改为字符'B'//char write_content[100];for (int i = 0; i &lt; 100; i++) {write_content[i] = 'B';}memcpy((LPVOID)((long)mapping_addr + 20000), write_content, 100);// 再次读取第20000~20100字节，共100字节，验证修改是成功//memcpy(read_content, (LPVOID)((long)mapping_addr + 20000), 100);printf("%s\n", read_content);UnmapViewOfFile(mapping_addr);CloseHandle(mapping_);CloseHandle(file_);return;}int main(){Test();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存映射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(2)--虚拟内存</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-2-xu-ni-nei-cun/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-2-xu-ni-nei-cun/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、页交换文件"><a href="#一、页交换文件" class="headerlink" title="一、页交换文件"></a>一、页交换文件</h2><p><code>虚拟地址空间</code>只是操作系统为进程“虚拟”出来的一块地址区域，并不代表任何实际的空间。而<code>“页交换文件”</code>却对应了实际的空间，这个空间一般是磁盘上名为<code>“pagefile.sys”</code>的文件。</p><p><code>“页交换文件”</code>的大小和位置可以在系统设置（<code>系统属性 -&gt; 高级 -&gt; 性能 -&gt; 设置 -&gt; 高级</code>  ）中进行设置：<br><img src="https://static.1key.run/blog/windows-nctx-xnnc-1.jpg"></p><p>从微软的官方文档来看，<code>“虚拟内存”</code>等于<code>“物理内存”+“分页文件”</code>总和。可以把<code>“虚拟内存”</code>理解为Windows的一种内存管理机制。</p><h2 id="二、虚拟地址空间、页交换文件、物理内存"><a href="#二、虚拟地址空间、页交换文件、物理内存" class="headerlink" title="二、虚拟地址空间、页交换文件、物理内存"></a>二、虚拟地址空间、页交换文件、物理内存</h2><p>虚拟地址空间、页交换文件、物理内存三者的关系如下图：<br><img src="https://static.1key.run/blog/windows-nctx-xnnc-2.jpg"></p><p>《Windows核心编程》第13章关于“物理存储器和页交换文件”章节中讲到了“页交换文件、物理存储器之间的数据交换过程”，流程如下：</p><p><img src="https://static.1key.run/blog/windows-nctx-xnnc-3.jpg"></p><p>应用程序从进程的虚拟地址空间<code>预定并调拨</code>了一块地址区域时，起初这块区域只是从“页交换文件”中调拨的，这样作有个好处就是：因为还不确定何时才会使用这块区域，如果立即从物理内存调拨，会将占用很多的物理内存。<br>当程序读写该地址区域时，此时就会出现上面图上的页交换文件和物理内存之间的数据交换过程。</p><h2 id="三、将页面锁定在物理内存"><a href="#三、将页面锁定在物理内存" class="headerlink" title="三、将页面锁定在物理内存"></a>三、将页面锁定在物理内存</h2><p>从上面的几节我们知道，当物理内存中没有闲置页面时，系统会将内存中的某些页面的数据写入到交换文件中，从而将该物理内存区域释放出来供后面的程序使用。 </p><p>我们可以通过调用<code>VirtualLock</code>方法，将页面锁定在物理内存中，从而防止虚拟内存管理机制将页面交换至页面文件，而引起不必要的硬盘和物理内存之间的低效页面交换。</p><p>也可以通过调用<code>VirtualUnlock</code>方法解锁页面，允许系统对页面进行交换操作。</p><p>需要注意的是，锁定页面时系统会根据当前可用实际物理内存情况，以及进程工作集配额判定当前最大可锁定的页面的实际数量，超过此数量会引起一个错误。我们可以调用<code>SetProcessWorkingSetSize</code>可以改变一个进程工作集大小的配额，从而可以锁定更多的物理页面。</p><h2 id="四、虚拟内存使用实例"><a href="#四、虚拟内存使用实例" class="headerlink" title="四、虚拟内存使用实例"></a>四、虚拟内存使用实例</h2><p>虚拟内存方面的API属于页面粒度API，通过这些API分配的内存的最小粒度是<code>64KB</code>。这些API分配（调拨）的内存区域最初都是位于<code>“页交换文件”</code>上面，当程序对该区域的某些“页面”（<strong>对虚拟内存的管理以页面为单位进行的</strong>）进行读写时，才会将这些页面交换到物理内存上面。</p><p>从<a href="/2023/06/20/windows-nei-cun-ti-xi-1-xu-ni-di-zhi-kong-jian/" title="Windows内存体系(1)--虚拟地址空间">Windows内存体系(1)--虚拟地址空间</a>中我们知道虚拟地址空间要经过<code>预定</code>和<code>调拨</code>2个步骤之后才能使用，这2个步骤都可以通过<code>VirtualAlloc</code>函数实现：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LPVOID VirtualAlloc(  LPVOID lpAddress,   DWORD dwSize,   DWORD flAllocationType,   DWORD flProtect ); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当预定或者调拨的空间我们不在需要时，我们需要调用<code>VirtualFree</code>来释放该地址空间：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">BOOL VirtualFree(  LPVOID lpAddress,   DWORD dwSize,   DWORD dwFreeType ); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是的示例演示了在预定、调拨、使用等操作前后，进程的各项内存的占用情况：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;windows.h&gt;int main(){SIZE_T size = 1 &lt;&lt; 30; // 1GB// 预定1GB的空间char *pVirtualAddress = (char *)VirtualAlloc(NULL, size, MEM_RESERVE, PAGE_READWRITE);if (pVirtualAddress == NULL) {printf("Reserve 1GB failed.\n");return 1;}// 验证分配粒度是不是64KBint n = (long)pVirtualAddress % (64*1024);if (n == 0) {printf("分配粒度为64K\n");}printf("已经预定1GB\n");getchar(); // 暂停if (VirtualAlloc(pVirtualAddress, size, MEM_COMMIT, PAGE_READWRITE) == NULL) {printf("Commit 1GB failed.\n");return 1;}printf("已经调拨1GB\n");getchar(); // 暂停// 页面大小为4K，访问2560个页面，即2560*4K = 10MB// for (int i = 0; i &lt; 2560; i++) {char * p = pVirtualAddress + i * (4 * 1024);*p = 'A'; // 只访问每个页面的第一个字节}printf("已经使用前10MB\n");getchar(); // 暂停    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在程序运行各个阶段进程的内存情况如下图：（“内存专用工作集”表示占用的物理内存的大小，“提交大小”表示调拨的页交换文件的大小）</p><p><img src="https://static.1key.run/blog/windows-nctx-xnnc-4.png"></p>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 页交换文件 </tag>
            
            <tag> 虚拟内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(1)--虚拟地址空间</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-1-xu-ni-di-zhi-kong-jian/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-1-xu-ni-di-zhi-kong-jian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、实模式下内存分配机制"><a href="#一、实模式下内存分配机制" class="headerlink" title="一、实模式下内存分配机制"></a>一、实模式下内存分配机制</h2><p>在8086或者80186以前，要运行一个程序，操作系统会把这些程序全都装入内存，程序都是直接运行在物理内存上的，也就是说程序中访问的内存地址都是实际的物理内存地址。当计算机同时运行多个程序时，必须保证这些程序用到的内存总量要小于计算机实际物理内存的大小。</p><p>例如某台计算机总的内存大小是<code>128M</code> ，现在同时运行两个程序 A和B ，A需占用内存<code>10M</code> ， B需占用内存<code>110M</code> 。计算机在给程序分配内存时会采取这样的方法：先将内存中的前<code>10M</code>分配给程序 A ，接着再从内存中剩余的<code>118M</code>中划分出 <code>110M</code>分配给程序B 。这种分配方法虽然可以保证程序A和程序B都能运行，但是这种简单的内存分配策略会导致很多问题：</p><ul><li><p>问题 1 ：进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意的，但是有 bug 的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。这种情况对用户来说是无法容忍的，因为用户希望使用计算机的时候，其中一个任务失败了，至少不能影响其它的任务。</p></li><li><p>问题 2 ：内存使用效率低。在 A 和 B 都运行的情况下，如果用户又运行了程序 C ，而程序 C 需要 20M 大小的内存才能运行，而此时系统只剩下 8M 的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序 C 使用，然后再将程序 C 的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。</p></li><li><p>问题 3 ：程序运行的地址不确定。当内存中的剩余空间可以满足程序 C 的要求后，操作系统会在剩余空间中随机分配一段连续的 20M 大小的空间给程序 C 使用，因为是随机分配的，所以程序运行的地址是不确定的。</p></li></ul><hr><h2 id="二、虚拟地址空间介绍"><a href="#二、虚拟地址空间介绍" class="headerlink" title="二、虚拟地址空间介绍"></a>二、虚拟地址空间介绍</h2><p>操作系统让每个进程都有自己的虚拟地址空间（<code>Virtual Address Space</code>，简称<code>VAS</code>）。以32位进程为例，每个进程都有<code>0x00000000 ~ 0xFFFFFFFF</code>(4GB)的虚拟地址空间，所以每个进程都可能分配到<code>0x123456</code>地址的内存，但这个地址不能在进程间相互访问。 </p><p>因为这些都是“虚拟”的地址空间，这些“地址”都不能直接使用，CPU在寻址的时候虽然是按照虚拟地址来寻址的，但是还要通过<code>MMU</code>(内存管理单元)来将虚拟地址转换为物理存储器（如内存等）上的物理地址：</p><p><img src="https://static.1key.run/blog/windows-nctx-1.jpg"></p><p>从图上可以看出，进程A和B虽然都有地址<code>0x123456</code>，但它们分别对应的物理地址不一样。</p><hr><p>##三、虚拟地址空间分区<br>进程的虚拟地址空间虽然很大，但是它被划分成了很多分区，供Ring3层应用程序使用的用户模式分区并不大（一半不到），如图：<br><img src="https://static.1key.run/blog/windows-nctx-2.jpg"></p><h4 id="3-1-空指针赋值分区"><a href="#3-1-空指针赋值分区" class="headerlink" title="3.1 空指针赋值分区"></a>3.1 空指针赋值分区</h4><p>这一分区的进程地址空间的范围为：[<code>0x00000000</code>, <code>0x0000FFFF</code>]，总大小为<code>64K</code>，保留该分区的目的是为了帮助应用程序员捕获对空指针的赋值。如<code>malloc</code>分配内存失败，就会返回<code>NULL</code>。</p><p>如果进程中的线程试图访问该分区内的内存地址，就会引发访问违规。</p><h4 id="3-2-用户模式分区"><a href="#3-2-用户模式分区" class="headerlink" title="3.2 用户模式分区"></a>3.2 用户模式分区</h4><p>在Windows中，所有的exe和动态链接库都载入到这一区域。系统同时会把该进程可以访问的所有内存映射文件（后面会介绍）映射到这一分区。</p><p>进程无法通过指针来读取、写入、访问其他进程的这一分区，因此一个应用程序破坏另一个应用程序的可能性就非常小了，从而使整个系统更加坚固。</p><h4 id="3-3-内核模式分区"><a href="#3-3-内核模式分区" class="headerlink" title="3.3 内核模式分区"></a>3.3 内核模式分区</h4><p>内核模式分区是操作系统代码的驻地。与线程调度、内存管理、文件系统支持、网络支持以及设备驱动程序相关的代码都会载入到这一分区。该分区内的代码和数据被完全的保护起来了，如果一个应用程序试图读取或写入位于这一分区的内存地址，会引发访问违规。</p><p>驻留在这一分区内的代码为所有进程共有。</p><hr><p>##四、虚拟地址空间的使用<br>虚拟地址空间的使用涉及到3个概念：<code>页面大小</code>、<code>分配粒度</code>、<code>预定和调拨</code>。</p><p>####4.1 页面大小<br>虚拟地址空间被分成以<code>“页面”</code>为单位，因为硬件内存管理单元是以<code>页面</code>为粒度将虚拟地址转译成物理地址的。<code>页面</code>的大小根据不同的CPU不而有所不同。x86和x64系统使用的<code>页面</code>大小都是<code>4KB</code>，而IA-64系统使用的<code>页面</code>大小是<code>8KB</code>。</p><blockquote><p>IA-64操作系统只能在INTEL安腾系列处理器及AMD部分服务器处理器运行，所以主流市场并不常见</p></blockquote><p>当<strong>应用程序</strong>在虚拟地址空间分配空间时，系统需要确保分配区域的大小正好是系统<code>页面</code>大小的整数倍。</p><h4 id="4-2-分配粒度"><a href="#4-2-分配粒度" class="headerlink" title="4.2 分配粒度"></a>4.2 分配粒度</h4><p>当<strong>应用程序</strong>在从虚拟地址空间分配空间时，系统会确保所有分配区域的起始地址都是<code>分配粒度</code>的整数倍。<code>分配粒度</code>的会根据不同的CPU平台而有所不同，但目前所有的CPU平台的分配粒度都是使用<code>64KB</code>。也就是说，<code>分配的起始地址 = 64 * N</code>。</p><p>通过Windows的<code>GetSystemInfo</code>函数也可以获得此分配粒度值。</p><blockquote><p>上面所说的<code>分配粒度</code>和<code>页面大小</code>的限制，只是针对于<code>“应用程序”</code>，系统内核自己不存在这样的限制。</p></blockquote><h4 id="4-3-预定和调拨"><a href="#4-3-预定和调拨" class="headerlink" title="4.3 预定和调拨"></a>4.3 预定和调拨</h4><p>虚拟地址空间的使用分为2个步骤：</p><ol><li><p>预定（reserve）：告诉系统我们要从虚拟地址空间<code>预定</code>哪一块区域，系统为我们保留这一块区域。预定的局域的起始地址和大小遵循上面介绍的<code>分配粒度</code>和<code>页面大小</code>的要求。因为预定的只是虚拟地址空间，不占用任何其他物理存储器，所以没有形成实质的开销。</p></li><li><p>调拨（commit）：预定的区域还不能使用，我们还需要为<code>预定</code>的区域从<code>页交换文件</code>中<code>调拨</code>存储器，<code>调拨</code>之后我们才能使用该区域。<br>至于为什么要从<code>页交换文件</code>中调拨存储器？ <code>页交换文件</code>如何与物理内存之间交互？在下一篇文章<a href="/2023/06/20/windows-nei-cun-ti-xi-2-xu-ni-nei-cun/" title="Windows内存体系(2)--虚拟内存">Windows内存体系(2)--虚拟内存</a>中会详细介绍。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实模式 </tag>
            
            <tag> 虚拟地址 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(5)--Qt字符编码</title>
      <link href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-5-qt-zi-fu-bian-ma/"/>
      <url>/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-5-qt-zi-fu-bian-ma/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><p>我们以<code>“测试字符串-보고싶다-Test String.”</code>这个字符串来进行讲解，它包含了英文、中文和韩文。<br>因为我使用Qt的方式是<code>Visual Studio + Qt库</code>的形式，所以本文以<code>Visual Studio</code>的<code>MSVC编译器</code>为例来进行讲解。</p><p>QString中使用QChar来存储每一个字符，QChar是short类型，占2个字节，默认是按Unicode编码存储的。</p><p>首先，为了保证写到代码文件中的测试字符串能被MSVC编译器理解，我们需要将源文件保存为<code>Utf8-带签名</code>的格式。具体参考：<a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-2-bian-yi-qi-chu-li-wen-jian-bian-ma/" title="拨开字符编码的迷雾(2)--编译器处理文件编码">拨开字符编码的迷雾(2)--编译器处理文件编码</a></p><p><strong>QString中存储的字符串的编码格式就是“编译器执行字符集编码格式”。</strong> 这一句话很关键。</p><p>在MSVC中我们可以使用<code>#pragma execution_character_set("utf-8")</code>来指定该源文件的执行字符集编码格式为UTF8格式，这样QString中存储的字符串格式就是utf8编码了。</p><p>下面是完整的测试用例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Demo01::qStringUseCase() {/*该源文件使用Utf8-BOM格式保存.源字符集为UTF8-BOM.可执行字符集为UTF8：#pragma execution_character_set("utf-8") 定义在stdafx.h.*/#define TEST_STR_A "测试字符串-보고싶다-Test String."#define TEST_STR_W L"测试字符串-보고싶다-Test String."{// 因为可执行字符集是utf8，所以使用OutputDebugStringA需要转换成ANSIOutputDebugStringA(Utf8ToAnsi(TEST_STR_A).c_str());}{ui.lblLanguage-&gt;setText(TEST_STR_A);}// char* --&gt; QString{QString qstr = TEST_STR_A;qInfo() &lt;&lt; qstr;}// QString --&gt; char*或std::string{QString qstr = TEST_STR_A;std::string str = qstr.toStdString(); // 不能直接使用qstr.toStdString().c_str()来获取，必须先将qstr.toStdString()存入std::string中const char* pStr = str.c_str();QString qstr2 = QString::fromUtf8(pStr);Q_ASSERT(qstr == qstr2);}// QString --&gt; wchar_t*或std::wstring{QString qstr = TEST_STR_A;std::wstring str = qstr.toStdWString();const wchar_t * pStr = str.c_str();QString qstr2 = QString::fromWCharArray(pStr);Q_ASSERT(qstr == qstr2);}// std::string --&gt; QString{std::string str = TEST_STR_A;  // std::string中存储的是UTF-8编码的字符串，因为可执行字符集为UTF8QString qstr = QString::fromStdString(str);}// std::wstring --&gt; QString{std::wstring str = TEST_STR_W;  // std::wstring中存储的是UTF-8编码的字符串，因为可执行字符集为UTF8QString qstr = QString::fromStdWString(str);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="关于QString-toLocal8Bit"><a href="#关于QString-toLocal8Bit" class="headerlink" title="关于QString::toLocal8Bit"></a>关于QString::toLocal8Bit</h1><p>QString有一个名为<code>toLocal8Bit</code>，网上很多介绍如何解决乱码的文章都会提到这个函数。关于这个函数官方的介绍如下：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Returns the local 8-bit representation of the string as a QByteArray. The returned byte array is undefined if the string contains characters not supported by the local 8-bit encoding.QTextCodec::codecForLocale() is used to perform the conversion from Unicode. If the locale encoding could not be determined, this function does the same as toLatin1().If this string contains any characters that cannot be encoded in the locale, the returned byte array is undefined. Those characters may be suppressed or replaced by another.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单来说，我们可以理解这个函数将字符串转换为的ANSI编码的字符串，通过<a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-1-zi-fu-bian-ma-gai-shu/" title="拨开字符编码的迷雾(1)--字符编码概述">拨开字符编码的迷雾(1)--字符编码概述</a>介绍，我们应该知道<code>ANSI</code>是和具体的代码页相关联的（在Windows中文环境下默认是代码页936）。Qt不是根据系统代码页来做判断的，而是通过<code>QTextCodec</code>来做判断的，所以文档中会提到这个函数需要结合<code>QTextCodec::codecForLocale()</code>来使用，<code>toLocal8Bit</code>根据对应的<code>QTextCodec</code>来做相应的转换。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以要想在使用Qt时，不遇到中文乱码问题，只需要在预编译头文件中加入：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma execution_character_set("utf-8") <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于部分韩文、日文等其他国家的字符不在Visual Studio默认的中文GB2312编码中，所以如果遇到Visual Studio提示“此文件的某些Unicode字符未能保存到当前代码页中”时，这时选择”<code>Utf8-带签名</code>“格式来保存即可。</p><p>综上所述，源文件保存为<code>Utf8-带签名</code>，且设置<code>#pragma execution_character_set("utf-8") </code>就可以解决所有乱码。</p>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(4)--MySQL字符编码</title>
      <link href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-4-mysql-zi-fu-bian-ma/"/>
      <url>/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-4-mysql-zi-fu-bian-ma/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一-MySQL字符集和校对规则"><a href="#一-MySQL字符集和校对规则" class="headerlink" title="一. MySQL字符集和校对规则"></a>一. MySQL字符集和校对规则</h1><p>MySQL的字符集是用来定义MySQL存储字符串的方式，校对规则（有的软件叫排序规则）则是用来定义了比较字符串的方式。字符集和校对规则是一对多的关系。每种字符集都有一个默认校对规则。</p><p><strong>查看数据库支持的字符集:</strong>  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 方法1：</span><span class="token keyword">SHOW</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span><span class="token punctuation">;</span><span class="token comment"># 方法2：</span><span class="token keyword">USE</span> information_schema<span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> CHARACTER_SETS<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看数据库支持的校对规则：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 方法1：</span><span class="token keyword">SHOW</span> COLLATION<span class="token punctuation">;</span><span class="token comment"># 方法2：</span><span class="token keyword">USE</span> information_schema<span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> collations<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二-MySQL各个级别字符集"><a href="#二-MySQL各个级别字符集" class="headerlink" title="二. MySQL各个级别字符集"></a>二. MySQL各个级别字符集</h1><p>MySQL可以对如下字符集进行设置：</p><ul><li>服务器级字符集（CHARACTER_SET_SERVER）</li><li>数据库级字符集（CHARACTER_SET_DATABASE）</li><li>表级字符集</li><li>字段级字符集</li><li>连接字符集（CHARACTER_SET_CONNECTION），客户端连接数据库所用的字符集。</li><li>结果字符集（CHARACTER_SET_RESULTS），存储查询结果（含错误信息）所用的字符集。</li><li>客户端字符集（CHARACTER_SET_CLIENT），客户端发送给MySQL服务器的查询语句字符集。</li><li>系统字符集（CHARACTER_SET_SYSTEM），用于存储我们新建的或自带的数据库的表、列的名称，默认是UTF-8</li></ul><p><code>服务器级、数据库级、表级、字段级</code> 这4个字符集设置影响到数据库中存储数据的编码。 这4个级别的字符集继承关系为：<code>服务器级 --&gt; 数据库级 --&gt; 表级 --&gt; 字段级</code>, 从左到右，一级继承一级，和C++、Java中的类的继承类似，如果某一级未显式的指定字符集，那么将继承上一级的字符集设置。</p><h2 id="2-1-服务器级别字符集设置"><a href="#2-1-服务器级别字符集设置" class="headerlink" title="2.1 服务器级别字符集设置"></a>2.1 服务器级别字符集设置</h2><p>服务器级别的字符集可以从下面几个地方指定，从上到下优先级依次增加：</p><ul><li>编译MySQL时指定的字符集</li><li>my.cnf配置文件设置character-set-server</li><li>mysqld服务启动命令行中指定字符集</li></ul><p>影响数据存储的字符集之间的关系：<br><img src="https://static.1key.run/blog/mysql-zfbm-1.jpg"></p><p><strong>查看当前数据库的字符集设置：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 方法1：</span><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'%character%'</span><span class="token punctuation">;</span><span class="token comment"># 方法2：</span><span class="token keyword">USE</span> information_schema<span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> GLOBAL_VARIABLES <span class="token keyword">WHERE</span> VARIABLE_NAME <span class="token operator">LIKE</span> <span class="token string">'%character%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-utf8与utf8mb4区别"><a href="#3-utf8与utf8mb4区别" class="headerlink" title="3. utf8与utf8mb4区别"></a>3. utf8与utf8mb4区别</h1><p>UTF-8是多字节编码方案，采用1~4个字节来存储一个字符，但在MySQL设计之初，一个字符最多采用3个字节的就可以存储，所以Mysql的设计者将MySQL中的UTF-8字符集（UTF-8其实不是字符集，是字符编码方案，但在MySQL中一直这么叫）设计成了最大长度只能为3. 如图：<br><img src="https://static.1key.run/blog/mysql-zfbm-2.jpg"></p><p>但随着Unicode字符集的扩张，出现了需要4个字节才能存储的字符，如果这时仍然使用utf-8（指mysql中的3字节utf-8）来存储这些字符就会出现错误，<br>如执行<code>INSERT INTO member(memberName)VALUES('𤭢')</code>报错如下：</p><pre class="line-numbers language-none"><code class="language-none">Warning Code : 1366Incorrect string value: '\xF0\xA4\xAD\xA2' for column 'memberName' at row 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>于是MySQL后来新增了utf8mb4字符集，最大长度为4，兼容之前的utf8，但为了之前的数据库不报错，仍然保留了之前的utf8字符集。 所以MySQL中的UTF-8字符集是伪UTF-8，现在需要使用utf8mb4。</p><h1 id="4-完全避免字符乱码"><a href="#4-完全避免字符乱码" class="headerlink" title="4. 完全避免字符乱码"></a>4. 完全避免字符乱码</h1><p>要完全避免字符乱码，最简单也是最好的方法就是将各个字符集保持一致，可以都设置为utf8mb4。Mysql数据存储涉及到的4个字符集的设置可以使用第2节的方法进行设置，客户端字符集、连接字符集，结果字符集关系到数据显示的正确性，可以使用如下语句统一设置为utf8mb4，但这个设置只针对当前连接有效：</p><pre class="line-numbers language-none"><code class="language-none">set names utf8mb4;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编程开发中，一般使用MySQL API进行数据连接、查询等操作，可以使用<code>mysql_set_character_set</code>对每个连接进行设置，这个API会将客户端字符集、连接字符集，结果字符集都设置为指定字符集，代码大致如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MYSQL* pMysql = NULL;mysql_real_connect(pMysql, szHost, szUser, szPwd, szDatabase, iPort, NULL, CLIENT_MULTI_STATEMENTS);mysql_set_character_set(pMysql, "utf8mb4");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(3)--字符编码转换</title>
      <link href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-3-zi-fu-bian-ma-zhuan-huan/"/>
      <url>/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-3-zi-fu-bian-ma-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="1-Windows-API介绍"><a href="#1-Windows-API介绍" class="headerlink" title="1. Windows API介绍"></a>1. Windows API介绍</h1><p>本文介绍使用Windows API进行字符编码的转换，涉及<code>WideCharToMultiByte</code>和<code>MultiByteToWideChar</code>2个API，<br>API接口名中的<code>MultiByte</code>对应着多字节编码，如ASCII、UTF-8等都是多字节编码，而<code>WideChar</code>字面意思是宽字符，在windows内部宽字符特指UTF-16编码。 </p><p>原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">WideCharToMultiByte</span><span class="token punctuation">(</span>  UINT CodePage<span class="token punctuation">,</span>   DWORD dwFlags<span class="token punctuation">,</span>   LPCWSTR lpWideCharStr<span class="token punctuation">,</span>   <span class="token keyword">int</span> cchWideChar<span class="token punctuation">,</span>   LPSTR lpMultiByteStr<span class="token punctuation">,</span>   <span class="token keyword">int</span> cbMultiByte<span class="token punctuation">,</span>   LPCSTR lpDefaultChar<span class="token punctuation">,</span>   LPBOOL lpUsedDefaultChar <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">MultiByteToWideChar</span><span class="token punctuation">(</span>  UINT CodePage<span class="token punctuation">,</span>   DWORD dwFlags<span class="token punctuation">,</span>   LPCSTR lpMultiByteStr<span class="token punctuation">,</span>   <span class="token keyword">int</span> cbMultiByte<span class="token punctuation">,</span>   LPWSTR lpWideCharStr<span class="token punctuation">,</span>   <span class="token keyword">int</span> cchWideChar <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-API封装"><a href="#2-API封装" class="headerlink" title="2. API封装"></a>2. API封装</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::string UnicodeToANSI(const std::wstring &amp;str, UINT iCodePage = CP_ACP) {std::string strRes;int iSize = ::WideCharToMultiByte(iCodePage, 0, str.c_str(), -1, NULL, 0, NULL, NULL);if (iSize == 0)return strRes;char *szBuf = new (std::nothrow) char[iSize];if (!szBuf)return strRes;memset(szBuf, 0, iSize);::WideCharToMultiByte(iCodePage, 0, str.c_str(), -1, szBuf, iSize, NULL, NULL);strRes = szBuf;delete[] szBuf;return strRes;}std::wstring ANSIToUnicode(const std::string &amp;str, UINT iCodePage = CP_ACP) {std::wstring strRes;int iSize = ::MultiByteToWideChar(iCodePage, 0, str.c_str(), -1, NULL, 0);if (iSize == 0)return strRes;wchar_t *szBuf = new (std::nothrow) wchar_t[iSize];if (!szBuf)return strRes;memset(szBuf, 0, iSize * sizeof(wchar_t));::MultiByteToWideChar(iCodePage, 0, str.c_str(), -1, szBuf, iSize);strRes = szBuf;delete[] szBuf;return strRes;}std::string UnicodeToUTF8(const std::wstring &amp;str) {std::string strRes;int iSize = ::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, NULL, 0, NULL, NULL);if (iSize == 0)return strRes;char *szBuf = new (std::nothrow) char[iSize];if (!szBuf)return strRes;memset(szBuf, 0, iSize);::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, szBuf, iSize, NULL, NULL);strRes = szBuf;delete[] szBuf;return strRes;}std::string UnicodeToUTF8BOM(const std::wstring &amp;str) {std::string strRes;int iSize = ::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, NULL, 0, NULL, NULL);if (iSize == 0)return strRes;unsigned char *szBuf = new (std::nothrow) unsigned char[iSize + 3];if (!szBuf)return strRes;memset(szBuf, 0, iSize + 3);if (::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, (LPSTR)(szBuf + 3), iSize, NULL, NULL) &gt; 0) {szBuf[0] = 0xEF;szBuf[1] = 0xBB;szBuf[2] = 0xBF;}strRes = (char*)szBuf;delete[] szBuf;return strRes;}std::wstring UTF8ToUnicode(const std::string &amp;str) {std::wstring strRes;int iSize = ::MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0);if (iSize == 0)return strRes;wchar_t *szBuf = new (std::nothrow) wchar_t[iSize];if (!szBuf)return strRes;memset(szBuf, 0, iSize * sizeof(wchar_t));::MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, szBuf, iSize);strRes = szBuf;delete[] szBuf;return strRes;}std::string ANSIToUTF8(const std::string &amp;str, UINT iCodePage = CP_ACP) {return UnicodeToUTF8(ANSIToUnicode(str, iCodePage));}std::string ANSIToUTF8BOM(const std::string &amp;str, UINT iCodePage = CP_ACP) {return UnicodeToUTF8BOM(ANSIToUnicode(str, iCodePage));}std::string UTF8ToANSI(const std::string &amp;str, UINT iCodePage = CP_ACP) {return UnicodeToANSI(UTF8ToUnicode(str), iCodePage);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于只支持简体中文（部分韩文、日文）的系统，<code>iCodePage</code>可以使用CP_ACP，这时API会使用系统当前的代码页（简体中文系统为CP936，即GBK字符集）来进行编码转换。 但遇到如下情况就需要手动指定代码页：</p><ol><li>需要转换的字符串中的文字是系统当前代码页不支持的。如字符串中含有中文，而当前系统代码页确是英文的；</li><li>GBK字符集中只包含了一部分韩文和日文，部分韩文和日文的转换可以正常转换，若遇到不能转换的情况也需要将指定iCodePage为特定的支持韩文或日文的代码页了，特别是中文和韩文、日文等混合的情况下。如韩文“탉”不包含在GBK中，若这时仍然使用CP_ACP就会得到错误的转换结果<code>?</code>，十六进制<code>3F</code>。但GB18030（代码页为54936）支持“탉”，可以手动指定iCodePage为54936。</li></ol><blockquote><p>如果代码中含有GBK不支持的字符，如“탉”、“𤭢”（念suì）等，Visual Studio会弹出如下提示：<br><img src="https://static.1key.run/blog/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA1MTI5ODIz"><br>选择“以其他编码保存”，选择“Unicode（UTF-8带签名）- 代码页65001”保存。<br>虽然“简体中文（GB18030) - 代码页54936”也支持这些字符，但不能选择该选项进行保存，具体原因在<a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-2-bian-yi-qi-chu-li-wen-jian-bian-ma/" title="拨开字符编码的迷雾(2)--编译器处理文件编码">拨开字符编码的迷雾(2)--编译器处理文件编码</a>中有详细的介绍。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(2)--编译器处理文件编码</title>
      <link href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-2-bian-yi-qi-chu-li-wen-jian-bian-ma/"/>
      <url>/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-2-bian-yi-qi-chu-li-wen-jian-bian-ma/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一-Visual-Studio字符集"><a href="#一-Visual-Studio字符集" class="headerlink" title="一. Visual Studio字符集"></a>一. Visual Studio字符集</h1><p>使用Visual Studio创建的C++工程可以在工程属性<code>配置属性--&gt;常规</code>中配置字符集：<code>使用Unicode字符集</code>（默认）、<code>使用多字节字符集</code>。<br>如图：<br><img src="https://static.1key.run/blog/byqrhclzfbm-1.jpg"></p><p>但<strong>这个设置项不会对编译器处理字符编码产生直接的影响</strong>（注意这里的“直接”二字，第3节会说到），只会在工程属性<code>配置属性--&gt;C/C++--&gt;预处理器</code>加入相应的宏：</p><pre class="line-numbers language-none"><code class="language-none">使用Unicode字符集 --&gt; _UNICODE和UNICODE宏使用多字节字符集   --&gt; _MBCS宏<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这几个宏一般用来判断是使用char还是wchar_t，在系统API中使用比较多，如MessegeBox通过是否定义了UNICODE宏来决定是使用LPCSTR还是LPCWSTR（LPCSTR即const char*, LPCWSTR即const wchar_t*）：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">UNICODE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MessageBox</span>  <span class="token expression">MessageBoxW</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MessageBox</span>  <span class="token expression">MessageBoxA</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// !UNICODE</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二-char和wchar-t"><a href="#二-char和wchar-t" class="headerlink" title="二. char和wchar_t"></a>二. char和wchar_t</h1><p>上面提到了，定义API时通过判断UNICODE宏是否定义来决定是使用char还是wchar_t，那么char和wchar_t有什么不同了？</p><p>char和wchar_t是标准C/C++字符类型，并不是windows特有的。 char固定占1个字节，wchar_t固定占2个字节，从内存的角度来看，char、wchar_t和其他数据类型一样，只是代表一段内存块，用来存储固定长度的二进制0或1。 在编程时，我们一般习惯于将字符串储到char或wchar_t定义的内存空间中，将整形存储在int定义的内存空间中。</p><p>所以，用char还是wchar_t来存储字符，只是内存分配和数据存储上面的事情，<strong>它们本身也是与字符编码无直接关系的</strong>（ 同样注意这里的“直接”二字，第3节会说到）。</p><h1 id="三-编译器如何处理硬编码字符"><a href="#三-编译器如何处理硬编码字符" class="headerlink" title="三. 编译器如何处理硬编码字符"></a>三. 编译器如何处理硬编码字符</h1><p>VC++编译器编译源代码的步骤中，涉及编码处理的步骤主要有2个：<br>第1步：预处理<br>1.1) 读取源文件，判断源文件采用的字符编码类型。(<strong>这一步不会改变文件内容</strong>)</p><pre class="line-numbers language-none"><code class="language-none">编译器判断源文件编码类型的步骤为：1. 若文件开始处有BOM(EF BB BF)，则判定为UTF-8编码；2. 若没有BOM，则试图从文件的前8个字节来判断文件是否像UTF-16编码，如果像，则就判断为UTF-16编码。3. 如果既没BOM，也不是UTF-16编码，则使用系统当前的代码页（简体中文操作系统为CP936）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>1.2) 将源文件内容转成<code>源字符集</code>(Source Character Set)，默认为UTF-8编码。</p><p>第2步：链接<br>2.1) 将1.2中得到的UTF-8转为<code>执行字符集</code>(Execution Character Set)：</p><ul><li>对于宽字符串（即C/C++中以<code>L</code>标记的串，如<code>L"abc"</code>, <code>L'中'</code>），<code>执行字符集</code>为UTF-16编码。</li><li>对于窄字符串（和宽字符串对应，即不以<code>L</code>标记的串），<code>执行字符集</code>为系统当前的代码页。</li></ul><p><img src="https://static.1key.run/blog/byqrhclzfbm-2.jpg"></p><p>现在我们就可以说清楚Visual Studio字符集设置、char、wchar_t是如何<em><strong>间接</strong></em>影响到编译器对字符编码的处理了：</p><pre class="line-numbers language-none"><code class="language-none">Visual Studio字符集设置      |决定声明哪一个宏（UNICODE还是_MBCS宏）      |宏又决定了API参数使用char还是wchar_t      |编译器在进行【执行字符集】编码时对char和wchar_采用不同的处理方式，从而对字符编码产生了影响。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在Visual Studio 2010（含）之后，支持使用<code># pragma execution_character_set</code>来设置执行字符集。</p></blockquote><h1 id="四-实例分析"><a href="#四-实例分析" class="headerlink" title="四. 实例分析"></a>四. 实例分析</h1><ul><li>已知汉字“中”的各种编码如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">GBK        D6 D0Unicode    2D 4EUTF-8      E4 B8 AD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>函数<code>DumpCharacterCode</code>用于按字节打印内存中的数据：</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void DumpCharacterCode(const char* pChar, int iSize) {for(int i = 0; i &lt; iSize; i++) {char a = *pChar++;printf("%02X ", a &amp; 0xff);}printf("\n");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>设置系统代码页的方法：<br>“控制面板”  –&gt; “区域和语言” –&gt; “管理” –&gt; “非Unicode程序的语言” –&gt; “更改系统区域设置”</p></li><li><p>Visual Studio保存文件到指定编码方法：<br>“文件” –&gt; “高级保存选项”</p></li></ul><h2 id="4-1-测试编译器处理窄字符编码"><a href="#4-1-测试编译器处理窄字符编码" class="headerlink" title="4.1 测试编译器处理窄字符编码"></a>4.1 测试编译器处理窄字符编码</h2><p>测试代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int _tmain(int argc, _TCHAR* argv[]){char buf[100] = {"中"};   // charDumpCharacterCode(buf, 2);  // 也可以打印4个字节return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对不同的系统代码页和源文件编码，打印出的汉字“中”的编码分别为：</p><table><thead><tr><th>测试用例</th><th>系统代码页</th><th>保存源文件编码</th><th>编译器判断文件采用的编码</th><th>源字符集(Source Character Set)</th><th>执行字符集(Execution Character Set)</th><th>打印输出</th></tr></thead><tbody><tr><td>用例1</td><td>简体中文 CP936</td><td>简体中文 CP936</td><td>简体中文 CP936</td><td>UTF-8</td><td>简体中文 CP936</td><td>D6 D0</td></tr><tr><td>用例2</td><td>简体中文 CP936</td><td>UTF-8 BOM</td><td>UTF-8 BOM</td><td>UTF-8</td><td>简体中文 CP936</td><td>D6 D0</td></tr><tr><td>用例3</td><td>简体中文 CP936</td><td>UTF-8</td><td>简体中文 CP936</td><td>UTF-8</td><td>简体中文 CP936</td><td>编译错误(C2146)</td></tr><tr><td>用例4</td><td>西欧 CP1252</td><td>简体中文 CP936</td><td>西欧 CP1252</td><td>UTF-8</td><td>西欧 CP1252</td><td>D6 D0</td></tr><tr><td>用例5</td><td>西欧 CP1252</td><td>UTF-8 BOM</td><td>UTF-8 BOM</td><td>UTF-8</td><td>西欧 CP1252</td><td>3F 00</td></tr></tbody></table><p>表格中列4~6依次对应编译处理源文件的几个步骤。<br><code>3F</code>对应的ASCII字符为<code>?</code>，编译器遇到不能识别的字符时，就会用<code>?</code>来替代。 出现<code>?</code>的情况会伴随着编译警告<code>C4566</code>。<br>上面出现了1次<code>3F</code>（用例5），导致乱码的原因是<code>UTF-8 --&gt; 西欧 CP1252</code>. <code>西欧 CP1252</code>也就是ASCII的扩展，不支持汉字，所以用<code>3F</code>替代。</p><h4 id="用例3为什么会编译错误？"><a href="#用例3为什么会编译错误？" class="headerlink" title="用例3为什么会编译错误？"></a>用例3为什么会编译错误？</h4><p>微软的编译器只能识别带BOM的UTF-8，用例3的UTF-8没带BOM，编译器会判定源文件编码为系统当前代码页CP936。“中”的UTF-8编码为<code>E4 B8 AD</code>，列5执行从CP936到UTF-8转换之后变成了<code>E6 B6 93 3F</code>，列6再要将<code>E6 B6 93 3F</code>转换为CP936肯定是转换不回去的，相当于 UTF-8（1） –&gt; UTF-8 （2），再将UTF-8（2）转换回CP936，这时肯定得到的字符不是原来的字符了。</p><h4 id="用例4为什么输出的D6-D0，而不是3F？"><a href="#用例4为什么输出的D6-D0，而不是3F？" class="headerlink" title="用例4为什么输出的D6 D0，而不是3F？"></a>用例4为什么输出的<code>D6 D0</code>，而不是<code>3F</code>？</h4><p>对着用例4的各个顺序来看，源文件通过CP936保存着，但编译器通过CP1252来读取的，CP1252就是ASCII扩展，单字节的，虽然此时显示为乱码，但各字节仍然是D6 D0；然后将读取到的文件内容从CP1252转成UTF-8编码，转码后为C3 96 C3 90；然后再将UTF-8编码转回为CP1251，转码就又变成了D6 D0。 但这个<code>D6 D0</code>在CP1252中是无法显示的，如果我们在用例4加入<code>MessageBoxA(NULL, "中", "test", MB_OK);</code> 会发现弹出的对话框中显示仍然是乱码。<br>可以使用下面的代码进行测试：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int _tmain(int argc, _TCHAR* argv[]){char buf[3] = { 0 };    // 模拟CP936编码的“中”buf[0] = 0xD6;buf[1] = 0xD0;std::string strUTF8 = ANSIToUTF8(buf, 1252);char *p = (char*)strUTF8.c_str();  // 通过visual studio查看指针p处内存为： C3 96 C3 90std::string str = UTF8ToANSI(strUTF8, 1252);p = (char*)str.c_str();   // 通过visual studio查看指针p处内存为： D6 D0return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-测试编译器处理宽字符编码"><a href="#4-2-测试编译器处理宽字符编码" class="headerlink" title="4.2 测试编译器处理宽字符编码"></a>4.2 测试编译器处理宽字符编码</h2><p>测试代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int _tmain(int argc, _TCHAR* argv[]){wchar_t buf[100] = {L"中"};   // wchar_tDumpCharacterCode((char*)buf, 4); // 打印4个字节return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样，针对不同的系统代码页和源文件编码，打印出的汉字“中”的编码分别为：</p><table><thead><tr><th>测试用例</th><th>系统代码页</th><th>保存源文件编码</th><th>编译器判断文件采用的编码</th><th>源字符集(Source Character Set)</th><th>执行字符集(Execution Character Set)</th><th>打印输出</th></tr></thead><tbody><tr><td>用例1</td><td>简体中文 CP936</td><td>简体中文 CP936</td><td>简体中文 CP936</td><td>UTF-8</td><td>UTF-16</td><td>2D 4E 00 00</td></tr><tr><td>用例2</td><td>简体中文 CP936</td><td>UTF-8 BOM</td><td>UTF-8 BOM</td><td>UTF-8</td><td>UTF-16</td><td>2D 4E 00 00</td></tr><tr><td>用例3</td><td>简体中文 CP936</td><td>UTF-8</td><td>简体中文 CP936</td><td>UTF-8</td><td>UTF-16</td><td>编译错误(C2146)</td></tr><tr><td>用例4</td><td>西欧 CP1252</td><td>简体中文 CP936</td><td>西欧 CP1252</td><td>UTF-8</td><td>UTF-16</td><td>D6 00 D0 00 <strong>大小端</strong></td></tr><tr><td>用例5</td><td>西欧 CP1252</td><td>UTF-8 BOM</td><td>UTF-8 BOM</td><td>UTF-8</td><td>UTF-16</td><td>2D 4E 00 00</td></tr></tbody></table><h1 id="五-彻底避免硬编码字符乱码"><a href="#五-彻底避免硬编码字符乱码" class="headerlink" title="五. 彻底避免硬编码字符乱码"></a>五. 彻底避免硬编码字符乱码</h1><p>通过第3节的说明，很容易知道，要开发支持多语言，在任意语言（系统代码页）的windows环境下都正常编译，且运行起来没有乱码的程序，需要遵循如下原则：</p><ol><li>代码文件采用UTF-8 with BOM编码。</li><li>Visual Studio字符集设置为Unicode字符集。</li><li>使用wchar_t。</li></ol><p>做到上面3步，你的代码被别人从github上clone下来编译，不会因为你代码中含有中文等字符，产生类似<code>error C2015</code>这样的编译错误，更不会产生乱码。</p><blockquote><p>本文介绍的方法只用来解决硬编码字符乱码的问题，至于数据传输中的乱码，需要统一字符编码来解决。</p></blockquote><blockquote><p>参考: <a href="https://blogs.msdn.microsoft.com/vcblog/2016/02/22/new-options-for-managing-character-sets-in-the-microsoft-cc-compiler">https://blogs.msdn.microsoft.com/vcblog/2016/02/22/new-options-for-managing-character-sets-in-the-microsoft-cc-compiler</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(1)--字符编码概述</title>
      <link href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-1-zi-fu-bian-ma-gai-shu/"/>
      <url>/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-1-zi-fu-bian-ma-gai-shu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><blockquote><p>为什么这样的字符串<code>{"data":"颸颸"}</code>，JSON库（如<code>jsoncpp</code>）会解析失败？<br>为什么界面上韩文显示乱码？<br>ASCII和ANSI有什么区别？<br>相信不少人在字符编码上面摔过跟头，这篇文章针对开发中需要了解的字符编码知识进行了简要的讲解，希望能够对大家有所帮助。</p></blockquote><h1 id="1-ASCII及其扩展"><a href="#1-ASCII及其扩展" class="headerlink" title="1. ASCII及其扩展"></a>1. ASCII及其扩展</h1><h2 id="1-1-什么是ASCII字符集"><a href="#1-1-什么是ASCII字符集" class="headerlink" title="1.1 什么是ASCII字符集"></a>1.1 什么是ASCII字符集</h2><p>字符集就是一系列用于显示的字符的集合。ASCII字符集由美国国家标准协会（American National Standard Institute)于1968年制定一个字符映射集合。</p><p>ASCII使用7位二进制位来表示一个字符，总共可以表示128个字符（即<code>2^7</code>，二进制<code>000 0000 ～ 111 1111</code> 十进制<code>0～127</code>）。</p><p>ASCII字符集中每个数字对应一个唯一的字符，如下表：<br><img src="https://static.1key.run/blog/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA0OTUyMDA5"></p><p>因为其对应关系非常简单，不需要特殊的编码规则，所以严格来讲ASCII不能算字符编码，因为它没有规定编码规则。我们只是习惯将ASCII字符集称之为ASCII码、ASCII编码。</p><h2 id="1-2-ASCII的扩展"><a href="#1-2-ASCII的扩展" class="headerlink" title="1.2 ASCII的扩展"></a>1.2 ASCII的扩展</h2><h3 id="1-2-1-最高位扩展-ISO-x2F-IEC-8859"><a href="#1-2-1-最高位扩展-ISO-x2F-IEC-8859" class="headerlink" title="1.2.1 最高位扩展 - ISO/IEC 8859"></a>1.2.1 最高位扩展 - ISO/IEC 8859</h3><p>ASCII字符集是美国人发明的，这些字符完全是为其量身定制的。但随着计算机技术的发展和普及，传到了欧洲（如法国、德国）各国。由于欧洲很多国家中使用的字符除了ASCII表中的128个字符之外，还有一些各国特有的字符，于是欧洲人民发现ASCII字符集表达不了他们所要表达的东西呀。怎么办了？他们发现ASCII只使用了一个字节（8位）之中的低7位，于是欧洲各国开始各显神通，打起了那1个最高位（第0位）的主意，将最高位利用了起来，这样又多了128个字符，从而满足了欧洲人民的需要。</p><p>但因为每个国家的需求不一样，各国都设计了不同的方案。为了结束这种混乱的局面，国际标准化组织(ISO)及国际电工委员会(IEC)联合制定了<strong>一系列8位字符集</strong>的标准，统称为ISO 8859（全称ISO/IEC 8859）。注意，这是一系列字符集的统称。如ISO/IEC 8859-1（也就是常听到的Latin-1）支持西欧语言，ISO/IEC 8859-4（Latin-4）支持北欧语言等。</p><p>完整列表如下（摘自百度百科）：<br>ISO/IEC 8859-1 (Latin-1) - 西欧语言<br>ISO/IEC 8859-2 (Latin-2) - 中欧语言<br>ISO/IEC 8859-3 (Latin-3) - 南欧语言，世界语也可用此字符集显示。<br>ISO/IEC 8859-4 (Latin-4) - 北欧语言<br>ISO/IEC 8859-5 (Cyrillic) - 斯拉夫语言<br>ISO/IEC 8859-6 (Arabic) - 阿拉伯语<br>ISO/IEC 8859-7 (Greek) - 希腊语<br>ISO/IEC 8859-8 (Hebrew) - 希伯来语(视觉顺序)<br>ISO 8859-8-I - 希伯来语(逻辑顺序)<br>ISO/IEC 8859-9 (Latin-5 或 Turkish) - 它把Latin-1的冰岛语字母换走，加入土耳其语字母。<br>ISO/IEC 8859-10 (Latin-6 或 Nordic) - 北日耳曼语支，用来代替Latin-4。<br>ISO/IEC 8859-11 (Thai) - 泰语，从泰国的 TIS620 标准字集演化而来。<br>ISO/IEC 8859-13 (Latin-7 或 Baltic Rim) - 波罗的语族<br>ISO/IEC 8859-14 (Latin-8 或 Celtic) - 凯尔特语族<br>ISO/IEC 8859-15 (Latin-9) - 西欧语言，加入Latin-1欠缺的芬兰语字母和大写法语重音字母，以及欧元符号。<br>ISO/IEC 8859-16 (Latin-10) - 东南欧语言。主要供罗马尼亚语使用，并加入欧元符号。</p><blockquote><p>我们在数据库中常见到的Latin-1、2、5、7其实就是上面提到的针对特定语言的ASCII扩展字符集。<br><img src="https://static.1key.run/blog/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA1MDA0NTIy"></p></blockquote><h3 id="1-2-2-多字节扩展-GB系列"><a href="#1-2-2-多字节扩展-GB系列" class="headerlink" title="1.2.2 多字节扩展 - GB系列"></a>1.2.2 多字节扩展 - GB系列</h3><p>前面讲到了，欧洲各国有效利用闲置的最高位，对ASCII字符集进行了扩展。可是欧洲人民没有想到的是（当然他们也不用想这么多），在大洋彼岸有着一个拥有五千年历史的伟大民族，她拥有着成千上万的汉字，1个字节显然不够表达如此深厚的文化底蕴。</p><p>于是当计算机引入到中国之初，国家技术监督局就设计了GB系列编码方案（GB=guo biao)。<br><strong>GB编码方案使用2个字节来表达一个汉字。同时为了兼容ASCII编码，规定各个字节的最高位（首位）必须为1，从而避免了和最高位为0的ASCII字符集的冲突。</strong></p><p>GB系列字符集经历下面的几个发展过程：</p><table><thead><tr><th>编码名称</th><th>发布时间</th><th>字节数</th><th>汉字范围</th></tr></thead><tbody><tr><td>GB2312</td><td>1980年</td><td>变字节（ASCII 1字节，汉字2个字节）</td><td>6763个汉字</td></tr><tr><td>GB13000</td><td>1993年第一版</td><td>变字节（ASCII 1字节，汉字2个字节）</td><td>20902个汉字</td></tr><tr><td>GBK</td><td>Windows95中</td><td>2个字节</td><td>21886个汉字和图形符号（含GB2312，BIG5中所有字符）</td></tr><tr><td>GB18030</td><td>2000年第一版</td><td>变字节（ASCII 1字节，汉字2个或4个字节）</td><td>27484个汉字</td></tr></tbody></table><p>每一次迭代，支持的字符数量都会增加，而且每一次迭代都会保留之前版本支持的编码，所以做到了向上兼容。</p><h3 id="1-2-3-全角与半角"><a href="#1-2-3-全角与半角" class="headerlink" title="1.2.3  全角与半角"></a>1.2.3  全角与半角</h3><p>因为汉字在显示器上的显示宽度要比英文字符的宽度要宽一倍，在一起排版显示时不太美观。所以GB编码不仅仅加入了汉字字符，而且包括了ASCII字符集中本来就有的数字、标点符号、字母等字符。这些被编入GB编码的数字、标点、字母在显示器上的显示宽度比ASCII字符集中的宽度宽一倍，所以前者称为全角字符，后者称为半角字符。</p><h1 id="2-ANSI"><a href="#2-ANSI" class="headerlink" title="2. ANSI"></a>2. ANSI</h1><h2 id="2-1-ANSI与代码页"><a href="#2-1-ANSI与代码页" class="headerlink" title="2.1 ANSI与代码页"></a>2.1 ANSI与代码页</h2><p>前面说到了世界各国针对ASCII的扩展方案（如欧洲的ISO/IEC 8859，中国的GB系列等），这些ASCII扩展编码方案的特点是：他们都兼容ASCII编码，但他们彼此之间是不兼容的。微软将这些编码方案统称为ANSI编码。故ANSI并不是特指某一种编码方案，只有知道了在哪个国家，哪个语言环境下，才知道它具体表示哪个编码方案。</p><p>在windows操作系统上，默认使用ANSI来保存文件。那么操作系统是如何知道ANSI到底应该表示哪种编码了，是GBK，还是ASCII，或者还是EUC-KR了？ windows通过一个叫”Code Page”（翻译为中文就叫代码页）的东西来判断系统的默认编码。<br>简体中文操作系统默认的代码页是936，它表示ANSI使用的是GBK编码。<br>GB18030编码对应的windows代码页为CP54936。</p><p>可以使用命令<code>chcp</code>来查看系统默认的代码页.</p><p>汉字“𤭢”（念suì）只包含在GB18030中，GB2312、GB13000、GBK中均不包含。默认情况下，在Visual Studio中输入该汉字，visual studio会使用CP936（即GBK）来保存代码文件，但如果在代码文件中输入该汉字，visual studio弹出如下提示要求用户选择代码页：<br><img src="https://static.1key.run/blog/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA1MTI5ODIz"><br><img src="https://static.1key.run/blog/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA1MTM4NTUx"></p><h2 id="2-2-更改默认代码页"><a href="#2-2-更改默认代码页" class="headerlink" title="2.2 更改默认代码页"></a>2.2 更改默认代码页</h2><h3 id="2-2-1-chcp命令"><a href="#2-2-1-chcp命令" class="headerlink" title="2.2.1 chcp命令"></a>2.2.1 chcp命令</h3><p>可以使用<code>chcp</code>命令来更改默认代码页，如<code>chcp 437</code>将默认代码页更改为437（美国）。</p><h3 id="2-2-2-控制面板"><a href="#2-2-2-控制面板" class="headerlink" title="2.2.2 控制面板"></a>2.2.2 控制面板</h3><p>在“控制面板”–&gt;“区域和语言”–&gt; “更改系统区域设置”中更改系统默认的代码页为“中文（简体，中国）”。</p><h3 id="2-2-3-代码修改"><a href="#2-2-3-代码修改" class="headerlink" title="2.2.3 代码修改"></a>2.2.3 代码修改</h3><p>也可以通过代码更改默认的代码页：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">setlocale</span><span class="token punctuation">(</span>   <span class="token keyword">int</span> category<span class="token punctuation">,</span>   <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>locale <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-Unicode"><a href="#3-Unicode" class="headerlink" title="3. Unicode"></a>3. Unicode</h1><h2 id="3-1-Unicode产生背景"><a href="#3-1-Unicode产生背景" class="headerlink" title="3.1 Unicode产生背景"></a>3.1 Unicode产生背景</h2><p>各个国家使用不同的编码规则，虽然他们都是兼容ASCII的，但它们相互却是不兼容的。</p><p>试想法国人Jack写了一封名为”love_you.txt”的信，传给了他的德国朋友Rose，Rose想要在windows系统上打开这个文件，她需要知道德国使用的字符编码是Latin-1，然后还要确保她的计算机上安装了该编码，才能顺利的打开这个文件。<br>如果上面这些还能忍受，那么随着网络的发展，你从互联网上获取的文件，你很有可能不知道它来自哪个国家，使用的哪种编码。这也就是Email刚诞生时常常出现乱码的原因，发信人和收信人使用的编码可能是不一样的。</p><p>于是<code>The Unicode Standard</code>（统一码标准）横空出世，它由The Unicode Consortium于1991年发布，我们习惯称它为Unicode字符集。 </p><p>Unicode字符集和ASCII字符集一样，也只是一个字符集合，标记着字符和数字之间的映射关系，它不包含任何编码规则和方案。和ASCII不一样的是，Unicode字符集支持的字符数量是没有限制的（具体可以参考Unicode规范）。</p><blockquote><p>我们通常认为的Unicode字符固定占用2个字节的观点是错误的。如“𤭢”（念suì）Unicode码为<code>D852 DF62</code>。 </p></blockquote><p>那么Unicode字符是怎样被编码成内存中的字节的了？它是通过UTF(Unicode Transformation Formats)实现的，比较常见得有UTF-8，UTF-16。</p><blockquote><p>在windows系统上汉字默认使用CP936（即GBK编码），占2个字节。而大多数Unicode字符的Unicode码值也占2个字节，所以大多数人误以为汉字字符串在内存中的值就是Unicode值，这是错误的。<br>可以从 <a href="http://tool.chinaz.com/tools/unicode.aspx" title="站长工具">站长工具-Unicode</a> 查询汉字的Unicode码值。</p></blockquote><h2 id="3-3-字符集与字符编码的区别"><a href="#3-3-字符集与字符编码的区别" class="headerlink" title="3.3 字符集与字符编码的区别"></a>3.3 字符集与字符编码的区别</h2><p>从ASCII、GB2312、GBK、GB18030、Big5（繁体中文）、Latin-1等采用的方案来看，它们都只是定义了单个字符与二进制数据的映射关系，一个字符在一个方案中只会存在一种表示方式，所以我们说GB2312是字符集还是字符编码方式都无所谓了。但是Unicode不一样，Unicode作为一个字符集可以采用多种编码方式，如UTF-8, UTF-16, UTF-32等。<strong>所以自Unicode出现之后，字符集与字符编码需要明确区分开来。</strong></p><h2 id="3-4-UTF-16编码的缺点"><a href="#3-4-UTF-16编码的缺点" class="headerlink" title="3.4 UTF-16编码的缺点"></a>3.4 UTF-16编码的缺点</h2><p>UTF-16编码方式规定用两个或四个字节来表示所有的字符。对于ASCII字符保持不变，只是将原来的7位扩展到了16位，其高9位永远是0。如字符’A’：</p><pre class="line-numbers language-none"><code class="language-none">ASCII: 100 0001UTF-16: 0000 0000 0100 0001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到对于ASCII字符，UTF-16的存储空间扩大了一倍，UTF-16并不是完全兼容ASCII字符集。这对于那些ASCII字符集已经满足需求的西方国家来说完全是没必要的，而且ASCII字符经过UTF-16编码之后高字节始终是0，导致很多C语言函数（如<code>strcpy</code>,<code>strlen</code>)会将此字节视为字符串的结束符<code>'\0'</code>，从而出现错误的计算结果。<br>而且，UTF-16还存在大小端的问题，“𤭢”（念suì）Unicode码在大端系统上为<code>D852 DF62</code>，小端系统上为<code>52D8 62DF</code>。<br>因此，UTF-16一开始推出的时候就遭到很多西方国家的抵制，影响了Unicode的推行。于是后来又设计了UTF-8编码方式，才解决了这些问题。</p><h2 id="3-5-Unicode字符集常用编码方式：UTF-8"><a href="#3-5-Unicode字符集常用编码方式：UTF-8" class="headerlink" title="3.5. Unicode字符集常用编码方式：UTF-8"></a>3.5. Unicode字符集常用编码方式：UTF-8</h2><h3 id="3-5-1-UTF-8概述"><a href="#3-5-1-UTF-8概述" class="headerlink" title="3.5.1 UTF-8概述"></a>3.5.1 UTF-8概述</h3><p>UTF-8是互联网上使用最广泛的Unicode字符集编码方式。UTF-8编码的最小单位由8位（1个字节）组成，UTF-8使用一个至四个字节来表示Unicode字符。另外，UTF-8是完美兼容ASCII字符集的，这一点可以通过下面的UTF-8的编码规则得到证明。</p><h3 id="3-5-2-UTF-8编码规则"><a href="#3-5-2-UTF-8编码规则" class="headerlink" title="3.5.2 UTF-8编码规则"></a>3.5.2 UTF-8编码规则</h3><p>UTF-8编码规则很简单：<br>（1）对于ASCII（单字节字符）字符，采用和ASCII相同的编码方式，即只使用一个字节表示，且该字节第一位为0.<br>（2）对于多字节（2~4字节）字符，假设字节数为n（1 &lt; n &lt;= 4），第一个字节：前n位都设为1，第n+1位设为0；后面的n-1个字节的前两位一律设为10。所有字节中的没有提及的其他二进制位，全部为这个符号的unicode码。 </p><table><thead><tr><th>Unicode符号范围(十六进制)</th><th>UTF-8编码方式(二进制)</th></tr></thead><tbody><tr><td>单字节:00000000-0000 007F</td><td>0xxxxxxx</td></tr><tr><td>双字节:00000080-0000 07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>三字节:00000800-0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>四字节:0001 0000-0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><h3 id="3-5-2-UTF-8-BOM"><a href="#3-5-2-UTF-8-BOM" class="headerlink" title="3.5.2 UTF-8 BOM"></a>3.5.2 UTF-8 BOM</h3><p>BOM（byte order mark）从字面意义来看是标记字节顺序的。最早出现的原因是因为UTF-16和UTF-32编码采用2个或4个字节表示一个字符，面临大小端的问题。为了区分是使用的大端(Big Endian，简称BE)还是小端(Little Endian，简称LE)，采用了在串的前面加入指定的字节加以区分，UTF-16大端加入<code>FE FF</code>，小端加入<code>FF FE</code>. 比如， 字符串“ABC”的UTF-16编码为 <code>00 41 00 42 00 43</code>，对应的各种的字节序列如下：</p><table><thead><tr><th>序列</th><th>数据</th></tr></thead><tbody><tr><td>UTF-16BE(withoutBOM)</td><td>00 41 00 42 00 43</td></tr><tr><td>UTF-16LE(withoutBOM)</td><td>41 00 42 00 43 00</td></tr><tr><td>UTF-16BE(with BOM)</td><td>FE FF 00 41 00 42 00 43</td></tr><tr><td>UTF-16LE(with BOM)</td><td>FF FE 41 00 42 00 43 00</td></tr></tbody></table><p>因为UTF-8和ASCII都是单字节序列，二者不好区分，微软采用在UTF-8编码的字符串前也加入BOM（3个字节<code>EF BB BF</code>）来标记UTF-8编码的串。UTF-8 BOM这一规范大多在windows下被使用，在其他平台下用的很少使用，如：Linux全部采用UTF-8编码，不存在要区分的情况；HTTP协议中可以包含<code>Content-Type:text/html; charset=utf-8</code>这样的说明，也不需要区分。</p>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
