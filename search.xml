<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开源库spdlog使用备忘</title>
      <link href="/post/2185523635.html"/>
      <url>/post/2185523635.html</url>
      
        <content type="html"><![CDATA[<p><code>spdlog</code>是一个高性能C++日志库，支持仅头文件（header-only）模式使用。</p><blockquote><p>官网地址： <a href="https://github.com/gabime/spdlog">https://github.com/gabime/spdlog</a></p></blockquote><p>spdlog是线程安全的，但不是进程安全的，可以多个线程同时使用一个spdlog对象输出日志，但不能多个进程同时往一个文件写入日志。</p><p>在spdlog内部使用<a href="https://github.com/fmtlib/fmt">fmt</a>进行字符串的格式化，因此spdlog字符串格式的方式与fmt库相同，如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">critical</span>(<span class="string">"Support for int: {0:d};  hex: {0:x};  oct: {0:o}; bin: {0:b}"</span>, <span class="number">42</span>);</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h1 id="一、日志级别"><a href="#一、日志级别" class="headerlink" title="一、日志级别"></a>一、日志级别</h1><p>大多数日志库都有日志级别的概念，通过设定日志级别可以动态控制我们需要打印输出的日志，spdlog支持如下日志级别：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trace = SPDLOG_LEVEL_TRACE   // 最低级</span><br><span class="line">debug = SPDLOG_LEVEL_DEBUG</span><br><span class="line">info = SPDLOG_LEVEL_INFO</span><br><span class="line">warn = SPDLOG_LEVEL_WARN</span><br><span class="line">err = SPDLOG_LEVEL_ERROR</span><br><span class="line">critical = SPDLOG_LEVEL_CRITICAL // 最高级    </span><br></pre></td></tr></tbody></table></figure><p>如下代码设置日志级别为<code>info</code>，此时只会打印输出info及比info级别高的日志：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">set_level</span>(spdlog::level::info);</span><br></pre></td></tr></tbody></table></figure><h1 id="二、Logger和Sink"><a href="#二、Logger和Sink" class="headerlink" title="二、Logger和Sink"></a>二、Logger和Sink</h1><p>spdlog主要由Logger(记录器)和Sink(输出位置)两部分组成，spdlog的高可拓展体现在Logger和Sink的可以由用户自定义。</p><p>每个程序可以创建多个Logger对象，而每个Logger对象又可以包含多个Sink（即可以同时输出到多个位置）。</p><h2 id="2-1-创建Sink"><a href="#2-1-创建Sink" class="headerlink" title="2.1 创建Sink"></a>2.1 创建Sink</h2><p>在介绍Logger的创建方法前，我们先看看如何创建Sink。</p><p>每个Sink都是一个<code>std::shared_ptr&lt;spdlog::sink&gt;</code>对象，创建Sink方法如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_sink_mt&gt;();</span><br></pre></td></tr></tbody></table></figure><p>spdlog有<code>_mt</code>（multi threaded）和<code>_st</code>（single threaded）两类后缀的sink对象，用于区分是否线程安全。单线程(<code>_st</code>后缀)的sink不能多线程使用，非线程安全。</p><p>spdlog支持多种不同的sink类型，如可以输出到文件、控制台、tcp/udp端口、Windows事件日志、mongo数据库等。完整的sink可以查看源代码的<a href="https://github.com/gabime/spdlog/tree/v1.x/include/spdlog/sinks/">sinks目录</a>，通常一个文件对应一个sink。</p><p>下面介绍几种常用的sink创建方法。</p><h3 id="simple-file-sink"><a href="#simple-file-sink" class="headerlink" title="simple_file_sink"></a>simple_file_sink</h3><p>一个简单的文件接收器，将日志写入到给定的日志文件，没有任何的限制。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"spdlog/sinks/basic_file_sink.h"</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">auto</span> logger = spdlog::<span class="built_in">basic_logger_mt</span>(<span class="string">"mylogger"</span>, <span class="string">"log.txt"</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>关于日志的输出目录，如上面的<code>data/logs</code>目录，从splog 1.5.0版本开始，spdlog将自动创建包含日志文件的文件夹。但在此之前，必须手动创建文件夹。</strong></p><h3 id="rotating-file-sink"><a href="#rotating-file-sink" class="headerlink" title="rotating_file_sink"></a>rotating_file_sink</h3><p>当达到最大文件大小时，关闭文件，并重命名，然后创建一个新的文件。最大文件大小和最大文件数都可以在构造函数中配置。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"spdlog/sinks/rotating_file_sink.h"</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> file_logger = spdlog::<span class="built_in">rotating_logger_mt</span>(<span class="string">"file_logger"</span>, <span class="string">"data/logs/mylogfile.log"</span>, <span class="number">1048576</span> * <span class="number">5</span>, <span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="daily-file-sink"><a href="#daily-file-sink" class="headerlink" title="daily_file_sink"></a>daily_file_sink</h3><p>每天在指定的时间创建一个新的日志文件，并在文件名后附加一个时间戳。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"spdlog/sinks/daily_file_sink.h"</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">auto</span> daily_logger = spdlog::<span class="built_in">daily_logger_mt</span>(<span class="string">"daily_logger"</span>, <span class="string">"logs/daily"</span>, <span class="number">14</span>, <span class="number">55</span>);</span><br></pre></td></tr></tbody></table></figure><p>上面代码将创建一个线程安全的sink，该sink将在每天14:55创建一个新的日志文件。</p><h3 id="stdout-sink"><a href="#stdout-sink" class="headerlink" title="stdout_sink"></a>stdout_sink</h3><p>输出到控制台。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"spdlog/sinks/stdout_sinks.h"</span></span></span><br><span class="line"><span class="keyword">auto</span> sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_sink_mt&gt;();</span><br></pre></td></tr></tbody></table></figure><h3 id="stdout-sink-with-colors"><a href="#stdout-sink-with-colors" class="headerlink" title="stdout_sink with colors"></a>stdout_sink with colors</h3><p>输出到控制台，并带颜色标记。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"spdlog/sinks/stdout_sinks.h"</span></span></span><br><span class="line"><span class="keyword">auto</span> sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_color_sink_mt&gt;();</span><br></pre></td></tr></tbody></table></figure><h3 id="msvc-sink"><a href="#msvc-sink" class="headerlink" title="msvc_sink"></a>msvc_sink</h3><p>输出到Windows调试接收器（如DbgView）,在spdlog内部实际使用<code>OutputDebugStringA</code>进行日志输出。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"spdlog/sinks/msvc_sink.h"</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">auto</span> sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::msvc_sink_mt&gt;(<span class="literal">false</span>);</span><br></pre></td></tr></tbody></table></figure><p><code>msvc_sink</code>的构造函数支持<code>check_debugger_present</code>参数，如果该参数为true，则仅在调试环境输出日志到Windows调试接收器。</p><h3 id="dup-filter-sink"><a href="#dup-filter-sink" class="headerlink" title="dup_filter_sink"></a>dup_filter_sink</h3><p>在日志输出时移除重复的日志。如果日志与前一条日志相同，并且间隔时间小于<code>max_skip_duration</code>，则跳过输出该日志。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"spdlog/sinks/dup_filter_sink.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> dup_filter = std::<span class="built_in">make_shared</span>&lt;dup_filter_sink_mt&gt;(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="function">spdlog::logger <span class="title">l</span><span class="params">(<span class="string">"logger"</span>, dup_filter)</span></span>;</span><br><span class="line">l.<span class="built_in">info</span>(<span class="string">"Hello"</span>);</span><br><span class="line">l.<span class="built_in">info</span>(<span class="string">"Hello"</span>);</span><br><span class="line">l.<span class="built_in">info</span>(<span class="string">"Hello"</span>);</span><br><span class="line">l.<span class="built_in">info</span>(<span class="string">"Different Hello"</span>);</span><br></pre></td></tr></tbody></table></figure><p>上面示例输出的日志如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[2019-06-25 17:50:56.511] [logger] [info] Hello</span><br><span class="line">[2019-06-25 17:50:56.512] [logger] [info] Skipped 3 duplicate messages..</span><br><span class="line">[2019-06-25 17:50:56.512] [logger] [info] Different Hello</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2-创建Logger"><a href="#2-2-创建Logger" class="headerlink" title="2.2 创建Logger"></a>2.2 创建Logger</h2><p>在创建完Sink对象后，就可以使用这些Sink来创建Logger对象。</p><p>下面示例创建了名为<code>mylogger</code>的同步Logger对象，为该对象配置了2个sink。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> file_sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::rotating_file_sink_mt&gt;(<span class="string">"logs/app.log"</span>, <span class="number">1048576</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> msvc_sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::msvc_sink_mt&gt;(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">std::vector&lt;spdlog::sink_ptr&gt; sinks = {file_sink, msvc_sink};</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> logger = std::<span class="built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="string">"mylogger"</span>,</span><br><span class="line">                                                sinks.<span class="built_in">begin</span>(),</span><br><span class="line">                                                sinks.<span class="built_in">end</span>());</span><br></pre></td></tr></tbody></table></figure><p>spdlog内部为每个进程都维护一张全局Logger记录表，记载了每个进程中通过工程方法创建的Logger实例(某些情况需要用户手动注册)。因而，在使用Logger时只需要知道创建时指定的名称即可：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> logger = spdlog::<span class="built_in">get</span>(<span class="string">"mylogger"</span>);</span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"some things want to say."</span>);</span><br></pre></td></tr></tbody></table></figure><h1 id="三、自定义日志格式"><a href="#三、自定义日志格式" class="headerlink" title="三、自定义日志格式"></a>三、自定义日志格式</h1><p>日志格式作用在Sink对象上，每个Sink都有一个格式化程序，spdlog的默认日志记录格式为：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2014-10-31 23:46:59.678] [my_loggername] [info] Some message</span><br></pre></td></tr></tbody></table></figure><p>我们可以通过下面方式为当前进程的所有Logger对象的所有Sink都统一设置日志格式：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">set_pattern</span>(<span class="string">"*** [%H:%M:%S %z] [thread %t] %v ***"</span>);</span><br></pre></td></tr></tbody></table></figure><p>也可以通过下面方式为指定的Logger对象的所有Sink设置日志格式：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_logger-&gt;<span class="built_in">set_pattern</span>(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br></pre></td></tr></tbody></table></figure><p>当然可以针对具体的Sink来设置日志格式：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">some_logger-&gt;<span class="built_in">sinks</span>()[<span class="number">0</span>]-&gt;<span class="built_in">set_pattern</span>(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">some_logger-&gt;<span class="built_in">sinks</span>()[<span class="number">1</span>]-&gt;<span class="built_in">set_pattern</span>(<span class="string">".."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">some_sink-&gt;<span class="built_in">set_pattern</span>(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br></pre></td></tr></tbody></table></figure><p>在设置日志格式时，spdlog都会对格式进程预编译，避免每次输出日志都进程格式解析，提升日志性能。</p><h2 id="3-1-格式标记"><a href="#3-1-格式标记" class="headerlink" title="3.1 格式标记"></a>3.1 格式标记</h2><p>下面列出了spdlog的pattern字符串支持的格式标记（类似<code>%flag</code>）。</p><table><thead><tr><th>标记</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>%v</td><td>实际的日志文本</td><td>some user text</td></tr><tr><td>%t</td><td>线程ID</td><td>1232</td></tr><tr><td>%P</td><td>进程ID</td><td>3456</td></tr><tr><td>%n</td><td>日志名称</td><td>some logger name</td></tr><tr><td>%l</td><td>The log level of the message</td><td>debug、info等</td></tr><tr><td>%L</td><td>Short log level of the message</td><td>D、I等</td></tr><tr><td>%a</td><td>简写星期名称</td><td>Thu</td></tr><tr><td>%A</td><td>星期名称全程</td><td>Thursday</td></tr><tr><td>%b</td><td>简写月份名称</td><td>Aug</td></tr><tr><td>%B</td><td>月份名称全程</td><td>August</td></tr><tr><td>%c</td><td>日期和时间</td><td>Thu Aug 23 15:35:46 2014</td></tr><tr><td>%C</td><td>两位数表示年份</td><td>2014输出14</td></tr><tr><td>%Y</td><td>四位数表示年份</td><td>2014</td></tr><tr><td>%D</td><td>r %xShort MM/DD/YY date</td><td>08/23/14</td></tr><tr><td>%m</td><td>Month 01-12</td><td>11</td></tr><tr><td>%d</td><td>Day of month 01-31</td><td>29</td></tr><tr><td>%H</td><td>Hours in 24 format 00-23</td><td>23</td></tr><tr><td>%I</td><td>Hours in 12 format 01-12</td><td>11</td></tr><tr><td>%M</td><td>Minutes 00-59</td><td>59</td></tr><tr><td>%S</td><td>Seconds 00-59</td><td>58</td></tr><tr><td>%e</td><td>毫秒</td><td>678</td></tr><tr><td>%f</td><td>微妙</td><td>056789</td></tr><tr><td>%F</td><td>纳秒</td><td>256789123</td></tr><tr><td>%p</td><td>AM/PM</td><td>AM</td></tr><tr><td>%r</td><td>12小时计时</td><td>02:55:02 PM</td></tr><tr><td>%R</td><td>24小时计时，等同于 %H:%M</td><td>23:55</td></tr><tr><td>%T或%X</td><td>ISO 8601时间格式，等同于%H:%M:%S</td><td>23:55:59</td></tr><tr><td>%z</td><td>ISO 8601时间格式，时区偏移 ([+/-]HH:MM)</td><td>如中国是东8区，+08:00</td></tr><tr><td>%E</td><td>时间戳</td><td>1528834770</td></tr><tr><td>%%</td><td>输出%</td><td>%</td></tr><tr><td>%+</td><td>spdlog默认格式</td><td>[2014-10-31 23:46:59.678] [mylogger] [info] Some message</td></tr><tr><td>%^</td><td>开始颜色标记（只能使用一次）</td><td>[mylogger] [info(green)] Some message</td></tr><tr><td>%$</td><td>结束颜色标记(如%^[+++]%$ %v) (只能使用一次)</td><td>[+++] Some message</td></tr><tr><td>%@</td><td>源文件路径和所在行数，等同于%g:%#</td><td>/some/dir/my_file.cpp:123</td></tr><tr><td>%s</td><td>源文件名</td><td>my_file.cpp</td></tr><tr><td>%g</td><td>源文件的完整路径或相对路径，等同于__FILE__宏</td><td>/some/dir/my_file.cpp</td></tr><tr><td>%#</td><td>源码所在行数</td><td>123</td></tr><tr><td>%!</td><td>源码所在函数名</td><td>my_func</td></tr><tr><td>%o</td><td>与上条日志的间隔时间（毫秒）</td><td>456</td></tr><tr><td>%i</td><td>与上条日志的间隔时间（微秒）</td><td>456</td></tr><tr><td>%u</td><td>与上条日志的间隔时间（纳秒）</td><td>11456</td></tr><tr><td>%O</td><td>与上条日志的间隔时间（秒）</td><td>4</td></tr></tbody></table><p>使用示例：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> file_sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::rotating_file_sink_mt&gt;(<span class="string">"logs/app.log"</span>, <span class="number">1048576</span>, <span class="number">7</span>);</span><br><span class="line">file_sink-&gt;<span class="built_in">set_pattern</span>(<span class="string">"%Y-%m-%d %H:%M:%S.%e %z %-10n %-8l [%P %t] %v"</span>);</span><br></pre></td></tr></tbody></table></figure><p>输出日志格式如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023-12-21 09:34:45.691 +08:00 Dock1703122417075610 info     [15460 6948] this is log text</span><br></pre></td></tr></tbody></table></figure><h3 id="源码位置标记"><a href="#源码位置标记" class="headerlink" title="源码位置标记"></a>源码位置标记</h3><p>如果需要使用源码位置标记，如<code>%s</code>, <code>%g</code>, <code>%#</code>, <code>%!</code>，需要在包含spdlog头文件之前，定义如下宏：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_TRACE</span></span><br></pre></td></tr></tbody></table></figure><h2 id="3-2-对齐"><a href="#3-2-对齐" class="headerlink" title="3.2 对齐"></a>3.2 对齐</h2><p>每个格式标记可以通过预先添加宽度标记来实现对齐。</p><p>使用<code>-</code>（左对齐）或<code>=</code>（中间对齐）控制对齐方向：</p><table><thead><tr><th>对齐</th><th>含义</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>%<width><flag></flag></width></td><td>右对齐</td><td>%8l</td><td>“    info”</td></tr><tr><td>%-<width><flag></flag></width></td><td>左对齐</td><td>%-8l</td><td>“info    “</td></tr><tr><td>%=<width><flag></flag></width></td><td>中间对齐</td><td>%=8l</td><td>“  info  “</td></tr></tbody></table><h2 id="3-3-截断"><a href="#3-3-截断" class="headerlink" title="3.3 截断"></a>3.3 截断</h2><p>还可以通过添加<code>!</code>标记来进行数据截断，如果宽度超过指定的宽度，则截断结果：</p><table><thead><tr><th>对齐</th><th>含义</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>%<width>!<flag></flag></width></td><td>右对齐并长度超过3个后截断</td><td>%3!l</td><td>“inf”</td></tr><tr><td>%-<width>!<flag></flag></width></td><td>左对齐并长度超过2个后截断</td><td>%-2!l</td><td>“in”</td></tr><tr><td>%=<width>!<flag></flag></width></td><td>中间对齐并长度超过1个后截断</td><td>%=1!l</td><td>“i”</td></tr></tbody></table><h1 id="四、输出策略-Flush-policy"><a href="#四、输出策略-Flush-policy" class="headerlink" title="四、输出策略(Flush policy)"></a>四、输出策略(Flush policy)</h1><p>基于性能考虑，spdlog不是立即输出日志，而是在内部通过日志队列的方式缓存日志，在合适的时候进行输出。</p><p>如果需要让spdlog立即输出队列中的日志，可以通过下面的几种方式。</p><h2 id="4-1-手动操作"><a href="#4-1-手动操作" class="headerlink" title="4.1 手动操作"></a>4.1 手动操作</h2><p>我们可以单独调用Sink的<code>flush</code>函数立即输出队列中的日志，也可以调用Logger对象的<code>flush</code>函数让该对象下的所有sink立即输出。</p><p>如果是异步日志，调用flush函数只会给日志队列发送一个flush消息，不会立即刷新。</p><p>在程序退出前，spdlog会确保队列中的所有日志都输出完成。如果想手动确保所有日志输出完成后退出程序，可以调用<code>spdlog::shutdown()</code>函数。</p><h2 id="4-2-基于日志等级的输出"><a href="#4-2-基于日志等级的输出" class="headerlink" title="4.2 基于日志等级的输出"></a>4.2 基于日志等级的输出</h2><p>您可以设置将触发自动输出的最低日志级别。例如，每当记录错误或更严重的消息时，这将触发立即输出：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_logger-&gt;<span class="built_in">flush_on</span>(spdlog::level::err); </span><br></pre></td></tr></tbody></table></figure><h2 id="4-3-定时输出"><a href="#4-3-定时输出" class="headerlink" title="4.3 定时输出"></a>4.3 定时输出</h2><p>所有已注册的Logger每5秒的定期输出：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">flush_every</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br></pre></td></tr></tbody></table></figure><p>这种方式只能使用在线程安全的sink上（即<code>_mt</code>后缀），因为定时输出任务执行在不同的线程上。</p><h1 id="五、异常"><a href="#五、异常" class="headerlink" title="五、异常"></a>五、异常</h1><p>spdlog在其文档中关于异常的说明，spdlog只会在构造Logger和Sink错误时主动抛出异常，因为spdlog认为这个错误是致命的，但这个并不可信，最多只能认为spdlog在其他情况下不会主动抛出异常，但不能保证其依赖的库（如fmt）不会抛出异常。</p><p>而且如果多个进程向同一个文件写入日志，当文件达到最大大小时，spdlog会自动重命名当前文件，并新建一个新的日志文件。如果多个进程向同一个文件写入日志，会导致重命名日志文件失败，splog会将该失败认为是致命错误，并抛出异常。</p><p>如果在打印日志时出现了spdlog能够预料的错误（非预料的及三方库抛出的异常仍然会传递到外部），spdlog默认将向<code>stderr</code>打印错误消息，为了避免错误消息充斥屏幕，每个Logger的错误消息输出速率限制为1条消息/分钟。</p><p>spdlog提供了错误处理方法，来让用户自定义如何处理错误信息，我们可以通过<code>set_error_handler</code>函数来自定义错误处理方法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局为每个Logger注册错误处理方法</span></span><br><span class="line">spdlog::<span class="built_in">set_error_handler</span>([](<span class="type">const</span> std::string&amp; msg) {</span><br><span class="line">      std::cerr &lt;&lt; <span class="string">"my err handler: "</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别为特定的Logger注册错误处理方法</span></span><br><span class="line">critical_logger-&gt;<span class="built_in">set_error_handler</span>([](<span class="type">const</span> std::string&amp; msg) {</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(msg);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>spdlog不是异常安全的，在使用spdlog时一定要注意异常捕获，否则可能因为一个格式化标记写错导致程序崩溃，本来是想通过日志来排除问题的，结果却因为日志导致程序崩溃，如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导致程序崩溃</span></span><br><span class="line">logger-&gt;<span class="built_in">error</span>(<span class="string">"create device enumerator failed, hr: {#x}"</span>, hr);</span><br></pre></td></tr></tbody></table></figure><h1 id="六、宽窄字符"><a href="#六、宽窄字符" class="headerlink" title="六、宽窄字符"></a>六、宽窄字符</h1><p>spdlog内部将字符作为<code>char</code>类型处理，如果需要输出<code>wchar_t</code>类型的字符串，需要将其转换为char类型，spdlog仅将char类型字符串原样输出，不做字符编码判断和处理，需要调用者来觉得字符串的编码，建议统一日志字符串的编码格式为UTF-8或ANSI。</p><h1 id="七、日志格式"><a href="#七、日志格式" class="headerlink" title="七、日志格式"></a>七、日志格式</h1><p>spdlog日志字符串的格式化处理使用的是开源<a href="https://github.com/fmtlib/fmt">fmt库</a>，其详细语法见：<a href="https://fmt.dev/latest/syntax.html">Format String Syntax</a>。</p><p>下面列举了常用的日志格式化方法。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出char字符串:{}"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 输出char字符串:hello</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出std::string:{}"</span>, std::<span class="built_in">string</span>(<span class="string">"hello"</span>));</span><br><span class="line"><span class="comment">// 输出std::string:hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 输出最小长度的字符串，如果长度不足则用固定字符填充，但超出不会截断字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出左对齐字符串(最小长度10，空格填充):{:&lt;10}"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 输出左对齐字符串(最小长度10，空格填充):hello     </span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出左对齐字符串(最小长度10):{:&lt;10}"</span>, <span class="string">"hello my world"</span>);</span><br><span class="line"><span class="comment">// 输出左对齐字符串(最小长度10):hello my world</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出右对齐字符串(最小长度10，空格填充):{:&gt;10}"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 输出右对齐字符串(最小长度10，空格填充):     hello</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出居中对齐字符串(最小长度10，空格填充):{:^10}"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 输出居中对齐字符串(最小长度10，空格填充):  hello   </span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出居中对齐字符串(最小长度10，*填充):{:*^10}"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 输出居中对齐字符串(最小长度10，*填充):**hello***</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出整型:{}"</span>, <span class="number">1234</span>);</span><br><span class="line"><span class="comment">// 输出整型:1234</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出布尔类型:{}"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 输出布尔类型:true</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出float:{}"</span>, <span class="number">3.1415936f</span>);</span><br><span class="line"><span class="comment">// 输出float:3.1415937</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出double:{}"</span>, <span class="number">3.1415936</span>);</span><br><span class="line"><span class="comment">// 输出double:3.1415936</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 输出最小位数（含小数点）的浮点型</span></span><br><span class="line"><span class="comment">* 小数点前部的最小位数=总位数-后部固定位数-1，位数不足默认填充空格，超过不截断；</span></span><br><span class="line"><span class="comment">* 小数点后部的位数始终固定，位数不足则在尾部添加0，超出则四舍五入后截断；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出浮点型(含小数点最小位数6位（左边填充空格），小数点后始终3位):{:6.3f}"</span>, <span class="number">3.1415936</span>);</span><br><span class="line"><span class="comment">// 输出浮点型(含小数点最小位数6位（左边填充空格），小数点后始终3位): 3.142</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出浮点型(含小数点最小位数6位（左边填充空格），小数点后始终3位):{:6.2f}"</span>, <span class="number">31415926.1</span>);</span><br><span class="line"><span class="comment">// 输出浮点型(含小数点最小位数6位（左边填充空格），小数点后始终3位):31415926.10</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出小写十六进制:{:x}"</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// 输出小写十六进制:7b</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出大写十六进制:{:X}"</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// 输出大写十六进制:7B</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出小写十六进制(带0x前缀):{:#x}"</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// 输出小写十六进制(带0x前缀):0x7b</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出大写十六进制(带0x前缀):{:#X}"</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// 输出大写十六进制(带0x前缀):0X7B</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出小写十六进制(固定8位，不足补0):{:08x}"</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// 输出小写十六进制(固定8位，不足补0):0000007b</span></span><br><span class="line"></span><br><span class="line">logger-&gt;<span class="built_in">info</span>(<span class="string">"输出小写十六进制(带0x前缀，固定8位，不足补0):{:#010x}"</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// 输出小写十六进制(带0x前缀，固定8位，不足补0):0x0000007b</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑪ 开源库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C/C++不同整数类型的区别</title>
      <link href="/post/2418701368.html"/>
      <url>/post/2418701368.html</url>
      
        <content type="html"><![CDATA[<p>在C/C++中涉及的整数相关的类型大致有如下几种：</p><ul><li>char、unsigned char</li><li>short、unsigned short</li><li>int、unsigned int</li><li>long、unsigned long</li><li>long long、unsigned long long</li><li>int8_t、uint8_t</li><li>int32_t、uint32_t</li><li>int64_t、uint64_t</li><li>DWORD</li><li>DWORD32、DWORD64</li><li>size_t、ssize_t</li><li>SIZE_T、SSIZE_T</li></ul><span id="more"></span><h2 id="一、原生数据类型"><a href="#一、原生数据类型" class="headerlink" title="一、原生数据类型"></a>一、原生数据类型</h2><p>以下数据类型C/C++语言中的原生整数类型，其长度取决于所使用的计算机系统和编译器：</p><ul><li>short、unsigned short</li><li>int、unsigned int</li><li>long、unsigned long</li><li>long long、unsigned long long</li></ul><p>如果需要开发跨平台的、具有良好可移植性的程序，请不要使用这些数据类型。<strong>通常情况下</strong>，这些数据类型所占字节数如下表所示：</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>范围</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>-128 ~ 127</td></tr><tr><td>unsigned char</td><td>1</td><td>0 ~ 255</td></tr><tr><td>short</td><td>2</td><td>-32,768 ~ 32,767</td></tr><tr><td>unsigned short</td><td>2</td><td>0 ~ 65,535</td></tr><tr><td>int</td><td>4</td><td>-2,147,483,648 ~ 2,147,483,647</td></tr><tr><td>unsigned int</td><td>0</td><td>0 ~ 4,294,967,295</td></tr><tr><td>long</td><td>4</td><td>-2,147,483,648 ~ 2,147,483,647</td></tr><tr><td>unsigned long</td><td>4</td><td>0 ~ 4,294,967,295</td></tr><tr><td>long long</td><td>8</td><td>-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807</td></tr><tr><td>unsigned long long</td><td>8</td><td>0 ~ 18,446,744,073,709,551,615</td></tr></tbody></table><h2 id="二、int-t数据类型"><a href="#二、int-t数据类型" class="headerlink" title="二、int*_t数据类型"></a>二、int*_t数据类型</h2><p><code>int*_t</code>格式的数据类型是使用typedef重新定义的数据类型。通过在不同的编译环境进行重定义，确保其所占用的字节数始终相同（即数据范围也相同）。</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>范围</th></tr></thead><tbody><tr><td>int8_t</td><td>1</td><td>-128 ~ 127</td></tr><tr><td>uint8_t</td><td>1</td><td>0 ~ 255</td></tr><tr><td>int32_t</td><td>4</td><td>-2,147,483,648 ~ 2,147,483,647</td></tr><tr><td>uint32_t</td><td>4</td><td>0 ~ 4,294,967,295</td></tr><tr><td>int64_t</td><td>8</td><td>-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807</td></tr><tr><td>uint64_t</td><td>8</td><td>0 ~ 18,446,744,073,709,551,615</td></tr></tbody></table><h2 id="三、size-t和std-size-t"><a href="#三、size-t和std-size-t" class="headerlink" title="三、size_t和std::size_t"></a>三、size_t和std::size_t</h2><p>size_t和std::size_t是不同的数据类型，size_t是定义在C语言的头文件，而std::size_t定义在C++标准库的<code>&lt;cstddef&gt;</code>头文件中。</p><p>虽然二者是不同的数据类型，但std::size_t在实现上兼容size_t了，二者所占的字节数始终相同。</p><p>size_t和std::size_t都是无符号整型，它们在32位编译环境占用4字节，64位编译环境占8字节。</p><p>如果需要使用有符号的size_t类型，在Linux上可以使用<code>ssize_t</code>类型，Windows上可以使用<code>SSIZE_T</code>类型。</p><h2 id="四、DWORD和DWORD32、DWORD64"><a href="#四、DWORD和DWORD32、DWORD64" class="headerlink" title="四、DWORD和DWORD32、DWORD64"></a>四、DWORD和DWORD32、DWORD64</h2><p>DWORD是32位无符号整型（范围<code>0 ~ 4,294,967,295</code>）</p><p><code>DWORD32</code>是32位无符号整型（范围<code>0 ~ 4,294,967,295</code>）,<code>DWORD64</code>是64位无符号整型（范围<code>0 ~ 18,446,744,073,709,551,615</code>）。</p><p>而<code>DWORD</code>也是32位无符号整型（范围<code>0 ~ 4,294,967,295</code>），可能微软在设计之初是打算让DWORD在不同的编译环境具有不同的位数，但从目前情况来看，这种希望已然破灭，<code>DWORD</code>将永远是32位的无符号整型。</p><h2 id="五、一点点建议"><a href="#五、一点点建议" class="headerlink" title="五、一点点建议"></a>五、一点点建议</h2><p>为了保证程序的可移植性，请在开发中只使用固定字节数的数据类型，如int8_t、int32_t、int64_t。</p>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows窗口调试利器-WinSpyPlus</title>
      <link href="/post/1533480858.html"/>
      <url>/post/1533480858.html</url>
      
        <content type="html"><![CDATA[<p>在Windows平台进行客户端开发时，不可避免的会遇到需要调试窗口的情况，如查看窗口句柄、窗口位置/尺寸、监听窗口消息等。虽然微软随Visual Stuido一同发布了Microsoft Spy++工具，但该工具的功能更新缓慢，这么多年过去了基本没有什么变化，比如：</p><ul><li>一直未提供单独的安装包。</li><li>强制以管理员权限启动，虽然以管理员权限启动可以避免很多问题（如无法监听管理员权限进程窗口的消息等），但这让用户失去了选择非管理员的权力。</li><li>不能通过标题或类名来查找窗口。</li><li>查找到的窗口不能自动定位到窗口树中。</li><li>不能过滤是否显示隐藏窗口、是否显示无标题窗口。</li><li>不能查看Message-Only窗口。</li><li>不能定时导出窗口树到文件中，以便做后续的对比分析。</li><li>默认启动的时32位进程，无法监听64位进程窗口的消息，监听失败时也未能提示用户。</li><li>未提供对窗口的快速操作指令，如显示/隐藏、最大化/最小化/还原、置顶/置底等。</li></ul><span id="more"></span><p>基于Microsoft Spy++的以上缺陷或不足，我开发了一个款为<code>WinSpyPlus</code>的工具，该工具解决了上述所有问题，而且功能特性还在不断扩充中。</p><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><ul><li><p>Github（更新及时）:</p><p><a href="https://github.com/winsoft666/winspyplus-bin">https://github.com/winsoft666/winspyplus-bin</a></p></li><li><p>奶牛快传（更新可能延后）：</p><p><a href="https://cowtransfer.com/s/aa5ab9c1ef2e46">https://cowtransfer.com/s/aa5ab9c1ef2e46</a></p></li></ul><h2 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h2><p><img src="https://blog-static.jiangxueqiao.com/blog/img/winspyplus-screenshot-1-TinyTu.png"></p>]]></content>
      
      
      <categories>
          
          <category> ③ Power By Me </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows API的不同返回状态</title>
      <link href="/post/2510508225.html"/>
      <url>/post/2510508225.html</url>
      
        <content type="html"><![CDATA[<p>在Windows编程中，我们经常接触到的Windows API返回值类型有：</p><ul><li>BOOL</li><li>HRESULT</li><li>LSTATUS</li></ul><span id="more"></span><h1 id="1-错误码"><a href="#1-错误码" class="headerlink" title="1. 错误码"></a>1. 错误码</h1><p>BOOL类型通常是0表示失败，非0表示成功，在BOOL类型返回失败时，通常还可以通过<code>GetLastError</code>函数获取错误码。错误码与调用线程相关联，每个线程的错误码是独立的，在调用完Windows API后，如下获取错误码，则需要立即获取，否则可能会被后面调用API所设置的错误码所覆盖。</p><p>应用程序也可以通过<code>SetLastError</code>函数来设置错误码。</p><p>Windows API通常在没有错误发生时，将错误码设置为0，有错误发生时，视具体错误而设置为其他非0值。</p><blockquote><p>微软官方文档：<a href="https://learn.microsoft.com/en-us/windows/win32/debug/system-error-codes">Debug system error codes</a></p></blockquote><h2 id="常见的错误码"><a href="#常见的错误码" class="headerlink" title="常见的错误码"></a>常见的错误码</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR_SUCCESS = <span class="number">0</span>  <span class="comment">// 成功</span></span><br><span class="line">ERROR_OUTOFMEMORY  <span class="comment">// 内存不足</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h1 id="2-HRESULT"><a href="#2-HRESULT" class="headerlink" title="2. HRESULT"></a>2. HRESULT</h1><h2 id="2-1-HRESULT结构"><a href="#2-1-HRESULT结构" class="headerlink" title="2.1 HRESULT结构"></a>2.1 HRESULT结构</h2><p>HRESULT是COM返回的错误码，总共32位，它由三个基本部分组成：</p><ul><li>高1位表示成功或失败（0表示成功，1表示失败）。</li><li>中间11位编码指示错误来源的设施/设备。</li><li>低16位编码错误编号。</li></ul><p>0~32位的作用分别如下：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/hresult-bit.png"></p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">S - 严重度 - 表示成功/失败</span><br><span class="line"></span><br><span class="line">    0 - 成功</span><br><span class="line">    1 - 失败 (COERROR)</span><br><span class="line"></span><br><span class="line">R - reserved portion of the facility code, corresponds to NT's second severity bit.</span><br><span class="line"></span><br><span class="line">C - reserved portion of the facility code, corresponds to NT's C field.</span><br><span class="line"></span><br><span class="line">N - reserved portion of the facility code. Used to indicate a mapped NT status value.</span><br><span class="line"></span><br><span class="line">r - reserved portion of the facility code. Reserved for internal</span><br><span class="line">        use. Used to indicate HRESULT values that are not status</span><br><span class="line">        values, but are instead message ids for display strings.</span><br><span class="line"></span><br><span class="line">Facility - 设备/设施码</span><br><span class="line"></span><br><span class="line">Code - 设备/设施的状态码</span><br></pre></td></tr></tbody></table></figure><p>在实际开发中，通常不需要关心其每一位的具体作用，我们使用更多的是下面的几个宏：</p><ul><li>使用<code>SUCCEEDED(hr)</code>宏判断是否成功（即hr&gt;= 0），<code>FAILED(hr)</code>判断是否失败(即hr&lt; 0)。</li><li>使用<code>HRESULT_CODE(hr)</code>宏获取错误码。</li><li>使用<code>HRESULT_FACILITY(hr)</code>宏获取设备码。</li></ul><blockquote><p>4字节（32位）整数能表示的最大正整数为<code>7FFF FFFFF</code>（最高位为0），当最高位为1时，则为负数。所以HRESULT能通过是否为负数来判断成功与否。</p></blockquote><h2 id="2-2-常见的HRESULT值"><a href="#2-2-常见的HRESULT值" class="headerlink" title="2.2 常见的HRESULT值"></a>2.2 常见的HRESULT值</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S_OK     <span class="comment">// 成功</span></span><br><span class="line">S_FALSE  <span class="comment">// 失败</span></span><br><span class="line">E_FAIL   <span class="comment">// 失败</span></span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-API错误码与HRESULT"><a href="#2-3-API错误码与HRESULT" class="headerlink" title="2.3 API错误码与HRESULT"></a>2.3 API错误码与HRESULT</h2><p>我们可以使用<code>HRESULT_FROM_WIN32</code>宏将上一节介绍的“Windows API的错误码”转成HRESULT。</p><h1 id="3-LSTATUS"><a href="#3-LSTATUS" class="headerlink" title="3. LSTATUS"></a>3. LSTATUS</h1><p>在Windows API中对LSTATUS的定义比较模糊，比如注册表API（如RegCreateEx等）返回的LSTATUS实际就是第一节介绍的Windows错误码。</p><p>所以当遇到返回LSTATUS类型的API时，需要参考API的文档说明。</p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Qt自定义和美化菜单</title>
      <link href="/post/711494356.html"/>
      <url>/post/711494356.html</url>
      
        <content type="html"><![CDATA[<p>在Qt中可以通过QSS对菜单进行样式设置，而且对于非标准菜单项我也可以通过自定义Widget的方法来实现，本文讲述在Qt中菜单的这些常用方法。</p><span id="more"></span><h2 id="一、菜单基本使用方法"><a href="#一、菜单基本使用方法" class="headerlink" title="一、菜单基本使用方法"></a>一、菜单基本使用方法</h2><p>下面示例演示了右键菜单的创建方法，该菜单包含了图标、选中/未选中状态、二级菜单、互斥选择等常用菜单特性，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QIcon <span class="title">settingIcon</span><span class="params">(<span class="string">":/MenuBeauty/setting.png"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Actions</span></span><br><span class="line">QAction* action1 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">"动作1"</span>);</span><br><span class="line">QAction* action2 = <span class="keyword">new</span> <span class="built_in">QAction</span>(settingIcon, <span class="string">"动作2 有图标"</span>);</span><br><span class="line"></span><br><span class="line">QAction* action3 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">"动作3 [未选中]"</span>);</span><br><span class="line">action3-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">action3-&gt;<span class="built_in">setChecked</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">connect</span>(action3, &amp;QAction::triggered, <span class="keyword">this</span>, [action3](<span class="type">bool</span> checked) {</span><br><span class="line">    action3-&gt;<span class="built_in">setText</span>(checked ? <span class="string">"动作3 [选中]"</span> : <span class="string">"动作3 [未选中]"</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">QAction* action4 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">"Action4 动作四测试"</span>);</span><br><span class="line"></span><br><span class="line">QAction* action5 = <span class="keyword">new</span> <span class="built_in">QAction</span>(settingIcon, <span class="string">"动作5 禁用"</span>);</span><br><span class="line">action5-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">QAction* action6 = <span class="keyword">new</span> <span class="built_in">QAction</span>(settingIcon, <span class="string">"动作6 子菜单"</span>);</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 动作6的子动作</span></span><br><span class="line">    QAction* action6_1 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">"动作6.1"</span>);</span><br><span class="line">    action6_1-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    QAction* action6_2 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">"动作6.1"</span>);</span><br><span class="line">    action6_2-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    QAction* action6_3 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">"动作6.1"</span>);</span><br><span class="line">    action6_3-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动作6的子菜单</span></span><br><span class="line">    QMenu* action6SubMenu = <span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    action6SubMenu-&gt;<span class="built_in">addAction</span>(action6_1);</span><br><span class="line">    action6SubMenu-&gt;<span class="built_in">addAction</span>(action6_2);</span><br><span class="line">    action6SubMenu-&gt;<span class="built_in">addAction</span>(action6_3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥子菜单项，同时只能选择一个</span></span><br><span class="line">    QActionGroup* action6Group = <span class="keyword">new</span> <span class="built_in">QActionGroup</span>(<span class="keyword">this</span>);</span><br><span class="line">    action6Group-&gt;<span class="built_in">setExclusive</span>(<span class="literal">true</span>);</span><br><span class="line">    action6Group-&gt;<span class="built_in">addAction</span>(action6_1);</span><br><span class="line">    action6Group-&gt;<span class="built_in">addAction</span>(action6_2);</span><br><span class="line">    action6Group-&gt;<span class="built_in">addAction</span>(action6_3);</span><br><span class="line"></span><br><span class="line">    action6-&gt;<span class="built_in">setMenu</span>(action6SubMenu);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义菜单</span></span><br><span class="line">QMenu* menu = <span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加Action</span></span><br><span class="line">menu-&gt;<span class="built_in">addActions</span>({action1, action2, action3});</span><br><span class="line">menu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">menu-&gt;<span class="built_in">addActions</span>({action4, action5, action6});</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标右键弹出菜单</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::CustomContextMenu);</span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;QWidget::customContextMenuRequested, <span class="keyword">this</span>, [<span class="keyword">this</span>, menu](<span class="type">const</span> QPoint&amp; pos) {</span><br><span class="line">    menu-&gt;<span class="built_in">exec</span>(<span class="keyword">this</span>-&gt;<span class="built_in">mapToGlobal</span>(pos));</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>上述菜单未经过任何美化，样式如下图所示：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/default-menu-style.png"></p><h2 id="二、使用QSS美化菜单"><a href="#二、使用QSS美化菜单" class="headerlink" title="二、使用QSS美化菜单"></a>二、使用QSS美化菜单</h2><p>现在我们使用如下QSS对上面创建的菜单进行美化，可以美化的项包含背景、文本颜色、边距、图标等。</p><p>为了使大家不被颜色值所困扰，下面QSS中的颜色统一使用颜色名称表示。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 菜单的属性 */</span></span><br><span class="line">QMenu {</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solod red;</span><br><span class="line">    <span class="comment">/* 圆角生效的前提是菜单窗口背景透明 */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"Microsoft YaHei"</span>;</span><br><span class="line">    <span class="comment">/* 设置菜单项最小宽度，此处有bug：虽可自动增长但实际宽度比所需宽度小 */</span></span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">160px</span>;</span><br><span class="line">    <span class="comment">/* 菜单内容上下边距为10px，预留圆角区域 */</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">0px</span> <span class="number">10px</span> <span class="number">0px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜单项的属性 */</span></span><br><span class="line">QMenu::item {</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="comment">/* 设置菜单项最小高度，可以让菜单项的高适应内容自动增长 */</span></span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="comment">/* 设置菜单项最小宽度，此处有bug：虽可自动增长但实际宽度比所需宽度小 */</span></span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">160px</span>;</span><br><span class="line">    <span class="comment">/* 使菜单项之间及菜单项和图标之间保持一定间隔，设置上下左右边距为8px，此处不能用margin */</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">8px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜单项-鼠标移入时的属性 */</span></span><br><span class="line">QMenu::item:selected {</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜单项-禁用时的属性 */</span></span><br><span class="line">QMenu::item:disabled {</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分割线的属性 */</span></span><br><span class="line">QMenu::separator {</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="comment">/* 左右边距：6px */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>x <span class="number">6px</span> <span class="number">0px</span> <span class="number">6px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图标的属性 */</span></span><br><span class="line">QMenu::icon {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="comment">/* 左边距：12px */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指示器的属性 */</span></span><br><span class="line"><span class="comment">/* 这里将互斥和非互斥Action的指示器样式设置为一样的，也可以设置为不一样 */</span></span><br><span class="line">QMenu::indicator:non-exclusive:checked, QMenu::indicator:exclusive:checked {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="comment">/* 左边距：8px */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span>;</span><br><span class="line">    image: <span class="built_in">url</span>(<span class="string">:/MenuBeauty/check.png</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">QMenu::indicator:non-exclusive:unchecked, QMenu::indicator:exclusive:unchecked {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="comment">/* 左边距：8px */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span>;</span><br><span class="line">    image: <span class="built_in">url</span>(<span class="string">:/MenuBeauty/unchecked.png</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了使菜单的圆角生效，我们还需要移除菜单的边框、阴影，并将背景设置为透明，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">menu-&gt;<span class="built_in">setWindowFlags</span>(action6SubMenu-&gt;<span class="built_in">windowFlags</span>() |</span><br><span class="line">                                Qt::FramelessWindowHint |   <span class="comment">// 无边框</span></span><br><span class="line">                                Qt::NoDropShadowWindowHint  <span class="comment">// 移除系统阴影</span></span><br><span class="line">);</span><br><span class="line">menu-&gt;<span class="built_in">setAttribute</span>(Qt::WA_TranslucentBackground); <span class="comment">// 背景透明</span></span><br></pre></td></tr></tbody></table></figure><p>美化后的菜单如下图所示：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/after-qss-menu-style.png"></p><h3 id="QSS可定制的QMenu部分"><a href="#QSS可定制的QMenu部分" class="headerlink" title="QSS可定制的QMenu部分"></a>QSS可定制的QMenu部分</h3><p>QMenu支持QSS盒子模型，其通用属性如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">border</span><br><span class="line">border-radius</span><br><span class="line">margin</span><br><span class="line">padding</span><br><span class="line">background</span><br><span class="line">color</span><br><span class="line">font</span><br><span class="line">border-image</span><br></pre></td></tr></tbody></table></figure><p>QSS还可以对QMenu的子控件进行设置，支持QMenu子控件如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">item</span><br><span class="line">indicator</span><br><span class="line">separator</span><br><span class="line">right-arrow</span><br><span class="line">left-arrow</span><br><span class="line">scroller</span><br><span class="line">tearoff</span><br></pre></td></tr></tbody></table></figure><p>QMenu不支持伪状态，只有其子控件支持伪状态，支持的伪状态如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default</span><br><span class="line">selected</span><br><span class="line">exclusive</span><br><span class="line">non-exclusive</span><br></pre></td></tr></tbody></table></figure><p>具体的子控件和伪状态的含义，可以参考 <a href="/post/749849405.html" title="QSS基本使用方法">QSS基本使用方法</a> 文章。</p><h2 id="三、自定义菜单项"><a href="#三、自定义菜单项" class="headerlink" title="三、自定义菜单项"></a>三、自定义菜单项</h2><p>大多数情况，上述常规的菜单项就可以满足要求，但有些情况下，我们的菜单项可能是更加复杂的Widget组合，比如下面播放器的菜单：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/music-menu-sample.png"></p><p>我们可以使用<code>QWidgetAction</code>来实现上述菜单效果，<code>QWidgetAction</code>可以将一个QWidget放入菜单项的容器内，从而实现自定义菜单项。</p><p>下面代码定义了一个包含3个按钮的菜单项，点击按钮会弹出对话框：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">QWidgetAction* action7 = <span class="keyword">new</span> <span class="built_in">QWidgetAction</span>(<span class="keyword">this</span>);</span><br><span class="line">{</span><br><span class="line">    QWidget* widget = <span class="keyword">new</span> <span class="built_in">QWidget</span>();</span><br><span class="line">    QHBoxLayout* hl = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>(widget);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> createPushButtonFn = [<span class="keyword">this</span>](QString title) {</span><br><span class="line">        QPushButton* btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(title);</span><br><span class="line">        <span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [<span class="keyword">this</span>]() {</span><br><span class="line">            QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">"Clicked"</span>, ((QPushButton*)<span class="built_in">sender</span>())-&gt;<span class="built_in">text</span>());</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> btn;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    hl-&gt;<span class="built_in">addWidget</span>(<span class="built_in">createPushButtonFn</span>(<span class="string">"Button1"</span>));</span><br><span class="line">    hl-&gt;<span class="built_in">addWidget</span>(<span class="built_in">createPushButtonFn</span>(<span class="string">"Button2"</span>));</span><br><span class="line">    hl-&gt;<span class="built_in">addWidget</span>(<span class="built_in">createPushButtonFn</span>(<span class="string">"Button3"</span>));</span><br><span class="line"></span><br><span class="line">    action7-&gt;<span class="built_in">setDefaultWidget</span>(widget);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">menu-&gt;<span class="built_in">addAction</span>(action7);</span><br></pre></td></tr></tbody></table></figure><p>效果如图所示：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/qwidgetaction-menu-sample.png"></p><p>我们也可以使用QSS对菜单项内的控件进行样式设置，如：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QMenu QPushButton {</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么SetParent会失败</title>
      <link href="/post/3832058229.html"/>
      <url>/post/3832058229.html</url>
      
        <content type="html"><![CDATA[<p>SetParent是Windows提供的设置窗口父窗体的API，函数原型比较简单：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">SetParent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           HWND hWndChild,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] HWND hWndNewParent</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p>我们通常的使用方法是：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">SetParent</span>(hChild, hParent)) {</span><br><span class="line">  <span class="comment">// Failed</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种使用方法在大多情况下不会失败，但有时却会失败。究其原因，其在微软官方文档中已有说明<a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setparent">SetParent Doc</a>。</p><p>由于兼容性问题，SetParent函数不会修改hWndChild窗口的<code>WS_CHILD</code>和<code>WS_POPUP</code>样式，因此：</p><ul><li>如果hWndNewParent为NULL，你需要在调用SetParent函数<strong>后</strong>清除<code>WS_CHILD</code>并设置<code>WS_POPUP</code>样式。</li><li>如果hWndNewParent不为NULL并且hWndChild之前是桌面的子窗口，你需要在调用SetParent函数<strong>前</strong>清除<code>WS_POPUP</code>并设置<code>WS_CHILD</code>样式。</li></ul><p>总结上述原因，SetParent的正确使用方法如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SetWinParent</span><span class="params">(HWND hChild, HWND hNewParent)</span> </span>{</span><br><span class="line">    HWND hOldParent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (hNewParent) {</span><br><span class="line">        LONG newStyle = <span class="built_in">GetWindowLong</span>(hChild, GWL_STYLE);</span><br><span class="line"></span><br><span class="line">        newStyle &amp;= ~WS_POPUP;</span><br><span class="line">        newStyle |= WS_CHILD;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">SetWindowLong</span>(hChild, GWL_STYLE, newStyle);</span><br><span class="line"></span><br><span class="line">        hOldParent = ::<span class="built_in">SetParent</span>(hChild, hNewParent);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        hOldParent = ::<span class="built_in">SetParent</span>(hChild, hNewParent);</span><br><span class="line"></span><br><span class="line">        LONG newStyle = <span class="built_in">GetWindowLong</span>(hChild, GWL_STYLE);</span><br><span class="line"></span><br><span class="line">        newStyle &amp;= ~WS_CHILD;</span><br><span class="line">        newStyle |= WS_POPUP;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">SetWindowLong</span>(hChild, GWL_STYLE, newStyle);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> !!hOldParent;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>窗口如何逃脱显示桌面指令</title>
      <link href="/post/2065788833.html"/>
      <url>/post/2065788833.html</url>
      
        <content type="html"><![CDATA[<p>在Windows系统中，在按下Win+D快捷键等操作执行“显示桌面”时，会将桌面上的所有窗口都最小化到任务栏，再次按下还原窗口。在显示桌面时，有些窗口仍然保持显示状态，不被最小话，即称之为逃脱显示桌面指令。</p><p>实现逃脱显示桌面的方式有三种，每种方式有不同的应用场景。</p><span id="more"></span><h2 id="一、置顶窗口的方式"><a href="#一、置顶窗口的方式" class="headerlink" title="一、置顶窗口的方式"></a>一、置顶窗口的方式</h2><p>首先创建WS_EX_TOOLWINDOW风格的窗口，WS_EX_TOOLWINDOW风格的窗口不会出现在任务栏，而且按<code>ALT+TAB</code>时也不会显示，然后为该窗口设置WS_EX_TOPMOST样式，使其始终置顶。</p><p>可以在创建窗口时通过扩展样式来指定WS_EX_TOOLWINDOW和WS_EX_TOPMOST样式：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HWND hWnd = <span class="built_in">CreateWindowExW</span>(</span><br><span class="line">    WS_EX_TOOLWINDOW | WS_EX_TOPMOST,</span><br><span class="line">    szWindowClass,</span><br><span class="line">    szTitle,</span><br><span class="line">    WS_OVERLAPPEDWINDOW,</span><br><span class="line">    CW_USEDEFAULT,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    CW_USEDEFAULT,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    hInstance,</span><br><span class="line">    <span class="literal">nullptr</span>);</span><br></pre></td></tr></tbody></table></figure><p>也可以先创建窗口，然后修改窗口样式：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LONG_PTR oldStyle = <span class="built_in">GetWindowLongPtr</span>(hWnd, GWL_EXSTYLE);</span><br><span class="line">oldStyle |= WS_EX_TOOLWINDOW;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetWindowLongPtr</span>(hWnd, GWL_EXSTYLE, oldStyle);</span><br></pre></td></tr></tbody></table></figure><p>并通过SetWindowPos函数来置顶窗口：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetWindowPos</span>(hWnd, HWND_TOPMOST, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, SWP_NOSIZE | SWP_NOMOVE);</span><br></pre></td></tr></tbody></table></figure><p>这种方式对系统的兼容性比较好，经测试可以支持Windows XP/7/8/10/11系统。但这种方式会导致窗口一直置顶显示，对于不需要置顶显示的窗口，这种方式就不适用了。</p><h2 id="二、改变窗口所有者的方式"><a href="#二、改变窗口所有者的方式" class="headerlink" title="二、改变窗口所有者的方式"></a>二、改变窗口所有者的方式</h2><p>在执行显示桌面指令时，桌面仍然会显示，因此我们可以将窗口的所有者设置为桌面窗口，来确保窗口不受“显示桌面”指令的影响。</p><h3 id="2-1-查找桌面窗口"><a href="#2-1-查找桌面窗口" class="headerlink" title="2.1 查找桌面窗口"></a>2.1 查找桌面窗口</h3><p>在Win7及之前的系统中，桌面窗口是Program Manager窗口的子窗口，如下图所示：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/win7-shelldll-defview-TinyTu.png"></p><p>而在Win8及以后的系统，桌面窗口变成了WorkerW窗口的子窗口，如下图所示：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/win11-shelldll-defview.png"></p><p>因此在查找桌面窗口句柄时，需要根据不同的系统环境采用不同的查找方式。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">FindShellDefViewWnd</span><span class="params">()</span> </span>{</span><br><span class="line">    HWND hShellDefView = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try Win7 and later</span></span><br><span class="line">    HWND hProgmanWnd = <span class="built_in">FindWindowW</span>(<span class="string">L"Progman"</span>, <span class="string">L"Program Manager"</span>);</span><br><span class="line">    <span class="keyword">if</span> (hProgmanWnd) {</span><br><span class="line">        hShellDefView = <span class="built_in">FindWindowExW</span>(hProgmanWnd, <span class="literal">NULL</span>, <span class="string">L"SHELLDLL_DefView"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try &gt; Win7</span></span><br><span class="line">    <span class="keyword">if</span> (!hShellDefView) {</span><br><span class="line">        <span class="comment">// When this fails, then look for the WorkerW windows list to get the correct desktop list handle.</span></span><br><span class="line">        HWND hDesktop = <span class="built_in">GetDesktopWindow</span>();</span><br><span class="line">        HWND hWorkerW = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            hWorkerW = <span class="built_in">FindWindowExW</span>(hDesktop, hWorkerW, <span class="string">L"WorkerW"</span>, <span class="literal">NULL</span>);</span><br><span class="line">            hShellDefView = <span class="built_in">FindWindowExW</span>(hWorkerW, <span class="literal">NULL</span>, <span class="string">L"SHELLDLL_DefView"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        } <span class="keyword">while</span> (hShellDefView == <span class="literal">NULL</span> &amp;&amp; hWorkerW != <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> hShellDefView;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-设置窗口拥有者"><a href="#2-2-设置窗口拥有者" class="headerlink" title="2.2 设置窗口拥有者"></a>2.2 设置窗口拥有者</h3><p>现在我们将窗口的拥有者设置为SHELLDLL_DefView窗口即可逃脱显示桌面的指令了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EscapeShowDesktop</span><span class="params">(HWND hWnd)</span> </span>{</span><br><span class="line">    HWND hShellDefView = <span class="built_in">FindShellDefViewWnd</span>();</span><br><span class="line">    <span class="keyword">if</span> (hShellDefView) {</span><br><span class="line">        <span class="built_in">SetWindowLongPtr</span>(hWnd, GWL_HWNDPARENT, (LONG_PTR)hShellDefView);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>需要注意：</strong> </p><p>采用这种方式可能会导致当前的活动桌面发生改变，这个行为会对某些Windows API产生影响，如会导致<code>GetAsyncKeyState</code>失效。</p></blockquote><h2 id="三、使用Appbar机制实现"><a href="#三、使用Appbar机制实现" class="headerlink" title="三、使用Appbar机制实现"></a>三、使用Appbar机制实现</h2><p>Windows提供了API来使应用程序具有模拟系统任务栏的能力，通常将模拟系统任务栏的程序成为Appbar（application desktop toolbar）。<br>Appbar窗口不受显示桌面指令的控制，但该窗口会和任务栏一样占据一部分桌面可用空间，可以通过API控制占用空间的大小和位置。</p><p>关于如何使用Appbar的API，可以参考Windows官方文档:<br><a href="https://learn.microsoft.com/en-us/previous-versions//bb776821(v=vs.85)?redirectedfrom=MSDN">Using Application Desktop Toolbars</a></p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>认识Windows顶级(top-level)窗口</title>
      <link href="/post/1431775047.html"/>
      <url>/post/1431775047.html</url>
      
        <content type="html"><![CDATA[<p>在Windows API中经常会出现关于顶级窗口的描述，如EnumWindows：</p><p>Enumerates all <strong>top-level</strong> windows on the screen by passing the handle to each window, in turn, to an application-defined callback function. EnumWindows continues until the last top-level window is enumerated or the callback function returns FALSE.</p><p>那么什么样的窗口才算得上是顶级窗口了？</p><p>简而言之，没有<code>WM_CHILD</code>属性的窗口都可以称为顶级窗口。</p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Qt中图片按九宫格模式缩放</title>
      <link href="/post/333631906.html"/>
      <url>/post/333631906.html</url>
      
        <content type="html"><![CDATA[<p>有时候，我们在缩放图片时没办法保持原图的长宽比，如保持图片高度不变仅拉伸宽度等，此时在不保持长宽比的情况进行图片缩放会导致图片变形。为了解决这种问题，我们可以考虑使用九宫格模式进行图片的缩放。</p><p>九宫格模式就是将图片切分为九块，不强制等分，如下图所示，在图片缩放时，我们通常保持1、3、7、9四个顶点位置的图片不变，对2、4、5、6、8五个区域进行缩放。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/jiugongge.png"></p><span id="more"></span><h2 id="1-使用QSS实现"><a href="#1-使用QSS实现" class="headerlink" title="1. 使用QSS实现"></a>1. 使用QSS实现</h2><p>在Qt中实现图片按九宫格缩放最简单的方法是使用QSS的<code>border-image</code>属性来实现，通过上下左右四个边框的宽度或高度来设置1、3、7、9四个顶点的大小。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">:/Sample/image/NinePatchTest.png</span>);</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">210px</span>;</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">180px</span>;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">227px</span>;</span><br></pre></td></tr></tbody></table></figure><p>为了便于测试，我制作了一个九宫格测试图片（整个图片宽高为1280*720）：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/NinePatchTest.png"></p><p>通过这种方法实现的九宫格缩放有一个弊端：</p><p>该方案会始终保持1、3、7、9四个区域图片的宽高不变，如1号区域是<code>210*180</code>，当我们对图片进行放大时，这个行为是没有问题的，但当我们缩小图片时，缩小后的图片宽高不足以容纳4个顶角图片时，缩小操作就会出现非预期的行为，可能如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/feiyuqitupiansuofang-1.png"></p><p>这种弊端还会体现在支持高DPI缩放的Qt程序中，例如在一个支持DPI缩放的程序中，对一个宽高为<code>640*360</code>的QWidget设置背景图片，我们知道不同的<code>devicePixelRatio</code>会导致实际渲染的图片宽高不同，如devicePixelRatio为1时图片渲染区域为<code>640*360</code>， 而devicePixelRatio为2时渲染区域为<code>1280*720</code>，为了保证程序在不同DPI的环境下都有比较好的界面呈现，我们通常简单得（当然也可以使用SVG或为不同DPI支持不同的图片）指定一个倍图（如2倍图）让程序自动进行图片缩放。而使用<code>border-left</code>等属性指定的宽度是固定的，顶点图片无法参与到自动缩放中来，从而会导致这一DPI适配机制失效。下一节介绍的方法可以解决这一弊端。</p><h2 id="2-使用代码实现九宫格缩放"><a href="#2-使用代码实现九宫格缩放" class="headerlink" title="2. 使用代码实现九宫格缩放"></a>2. 使用代码实现九宫格缩放</h2><p>本节介绍使用代码实现图片九宫格模式缩放，实现原理大致是：</p><p>提取九个区域的图片，保持1、3、7、9四个图片不变，对2、4、5、6、8五个区域图片进行缩放，分别得到新的图片，最后再将九个区域的图片合并成一张图。</p><h3 id="如何解决上述QSS方案的弊端？"><a href="#如何解决上述QSS方案的弊端？" class="headerlink" title="如何解决上述QSS方案的弊端？"></a>如何解决上述QSS方案的弊端？</h3><p>为了解决上述QSS方案的弊端，我们可以采取先将图片在保持长宽比的情况缩放到相应尺寸：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPixmap keepRatioScaledPix = src.<span class="built_in">scaled</span>(destSize, Qt::KeepAspectRatio, Qt::SmoothTransformation);</span><br></pre></td></tr></tbody></table></figure><p>由于keepRatioScaledPix实际尺寸肯定与我们想要得到的destSize不匹配，所以我们再把keepRatioScaledPix图片按九宫格模式缩放。</p><p>具体实现代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">ScaleByNinePatch</span><span class="params">(<span class="type">const</span> QPixmap&amp; src, <span class="comment">// 原图</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         QSize destSize, <span class="comment">// 目标尺寸</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">bool</span> keepVertexImageSize,  <span class="comment">// 是否保持1、3、7、9顶点图片大小不变，设置为true则与QSS方式效果类似（仅类似，因为该函数是直接返回原图）</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int</span> pos1Width, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int</span> pos1Height, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int</span> pos3Width, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int</span> pos7Height, </span></span></span><br><span class="line"><span class="params"><span class="function">                        Qt::TransformationMode mode = Qt::SmoothTransformation)</span> </span>{</span><br><span class="line">    <span class="comment">// 参数校准</span></span><br><span class="line">    pos1Width = <span class="built_in">qMax</span>(pos1Width, <span class="number">0</span>);</span><br><span class="line">    pos1Height = <span class="built_in">qMax</span>(pos1Height, <span class="number">0</span>);</span><br><span class="line">    pos3Width = <span class="built_in">qMax</span>(pos3Width, <span class="number">0</span>);</span><br><span class="line">    pos7Height = <span class="built_in">qMax</span>(pos7Height, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> handlePixW = <span class="number">0</span>, handlePixH = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> QPixmap* handlePix = <span class="literal">nullptr</span>;</span><br><span class="line">    QPixmap keepRatioScaledPix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (keepVertexImageSize) {</span><br><span class="line">        <span class="comment">// 保持顶点图片大小不变的情况，如果顶点图片宽或高已经大于了目标宽高，则直接返回原图</span></span><br><span class="line">        <span class="keyword">if</span> (pos1Width + pos3Width &gt; destSize.<span class="built_in">width</span>() || pos1Height + pos7Height &gt; destSize.<span class="built_in">height</span>())</span><br><span class="line">            <span class="keyword">return</span> src;</span><br><span class="line"></span><br><span class="line">        handlePixW = src.<span class="built_in">width</span>();</span><br><span class="line">        handlePixH = src.<span class="built_in">height</span>();</span><br><span class="line">        handlePix = &amp;src;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">const</span> qreal srcW = src.<span class="built_in">width</span>();</span><br><span class="line">        <span class="type">const</span> qreal srcH = src.<span class="built_in">height</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先等比缩放到适合的尺寸</span></span><br><span class="line">        keepRatioScaledPix = src.<span class="built_in">scaled</span>(destSize, Qt::KeepAspectRatio, mode);</span><br><span class="line">        handlePixW = keepRatioScaledPix.<span class="built_in">width</span>();</span><br><span class="line">        handlePixH = keepRatioScaledPix.<span class="built_in">height</span>();</span><br><span class="line">        qreal krsPixWidth = handlePixW;</span><br><span class="line">        qreal krsPixHeight = handlePixH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照之前的比例获取新顶点图片的大小</span></span><br><span class="line">        pos1Width = krsPixWidth * (qreal)pos1Width / srcW;</span><br><span class="line">        pos1Height = krsPixHeight * (qreal)pos1Height / srcH;</span><br><span class="line">        pos3Width = krsPixWidth * (qreal)pos3Width / srcW;</span><br><span class="line">        pos7Height = krsPixHeight * (qreal)pos7Height / srcH;</span><br><span class="line"></span><br><span class="line">        handlePix = &amp;keepRatioScaledPix;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提前各个区域图片</span></span><br><span class="line">    QPixmap pix1 = handlePix-&gt;<span class="built_in">copy</span>(<span class="number">0</span>, <span class="number">0</span>, pos1Width, pos1Height);</span><br><span class="line">    QPixmap pix2 = handlePix-&gt;<span class="built_in">copy</span>(pos1Width, <span class="number">0</span>, <span class="built_in">qMax</span>(handlePixW - pos1Width - pos3Width, <span class="number">0</span>), pos1Height);</span><br><span class="line">    QPixmap pix3 = handlePix-&gt;<span class="built_in">copy</span>(<span class="built_in">qMax</span>(handlePixW - pos3Width, <span class="number">0</span>), <span class="number">0</span>, pos3Width, pos1Height);</span><br><span class="line">    QPixmap pix4 = handlePix-&gt;<span class="built_in">copy</span>(<span class="number">0</span>, pos1Height, pos1Width, <span class="built_in">qMax</span>(handlePixH - pos1Height - pos7Height, <span class="number">0</span>));</span><br><span class="line">    QPixmap pix5 = handlePix-&gt;<span class="built_in">copy</span>(pos1Width, pos1Height, <span class="built_in">qMax</span>(handlePixW - pos1Width - pos3Width, <span class="number">0</span>), <span class="built_in">qMax</span>(handlePixH - pos1Height - pos7Height, <span class="number">0</span>));</span><br><span class="line">    QPixmap pix6 = handlePix-&gt;<span class="built_in">copy</span>(<span class="built_in">qMax</span>(handlePixW - pos3Width, <span class="number">0</span>), pos1Height, pos3Width, <span class="built_in">qMax</span>(handlePixH - pos1Height - pos7Height, <span class="number">0</span>));</span><br><span class="line">    QPixmap pix7 = handlePix-&gt;<span class="built_in">copy</span>(<span class="number">0</span>, <span class="built_in">qMax</span>(handlePixH - pos7Height, <span class="number">0</span>), pos1Width, pos7Height);</span><br><span class="line">    QPixmap pix8 = handlePix-&gt;<span class="built_in">copy</span>(pos1Width, <span class="built_in">qMax</span>(handlePixH - pos7Height, <span class="number">0</span>), <span class="built_in">qMax</span>(handlePixW - pos1Width - pos3Width, <span class="number">0</span>), pos7Height);</span><br><span class="line">    QPixmap pix9 = handlePix-&gt;<span class="built_in">copy</span>(<span class="built_in">qMax</span>(handlePixW - pos3Width, <span class="number">0</span>), <span class="built_in">qMax</span>(handlePixH - pos7Height, <span class="number">0</span>), pos3Width, pos7Height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对2、4、5、6、8区域图片进行缩放</span></span><br><span class="line">    pix2 = pix2.<span class="built_in">scaled</span>(<span class="built_in">qMax</span>(destSize.<span class="built_in">width</span>() - pos1Width - pos3Width, <span class="number">0</span>), pos1Height, Qt::IgnoreAspectRatio, mode);</span><br><span class="line">    pix4 = pix4.<span class="built_in">scaled</span>(pos1Width, <span class="built_in">qMax</span>(destSize.<span class="built_in">height</span>() - pos1Height - pos7Height, <span class="number">0</span>), Qt::IgnoreAspectRatio, mode);</span><br><span class="line">    pix5 = pix5.<span class="built_in">scaled</span>(<span class="built_in">qMax</span>(destSize.<span class="built_in">width</span>() - pos1Width - pos3Width, <span class="number">0</span>), <span class="built_in">qMax</span>(destSize.<span class="built_in">height</span>() - pos1Height - pos7Height, <span class="number">0</span>), Qt::IgnoreAspectRatio, mode);</span><br><span class="line">    pix6 = pix6.<span class="built_in">scaled</span>(pos3Width, <span class="built_in">qMax</span>(destSize.<span class="built_in">height</span>() - pos1Height - pos7Height, <span class="number">0</span>), Qt::IgnoreAspectRatio, mode);</span><br><span class="line">    pix8 = pix8.<span class="built_in">scaled</span>(<span class="built_in">qMax</span>(destSize.<span class="built_in">width</span>() - pos1Width - pos3Width, <span class="number">0</span>), pos7Height, Qt::IgnoreAspectRatio, mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接新的图片</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">dest</span><span class="params">(destSize)</span></span>;</span><br><span class="line">    dest.<span class="built_in">fill</span>(Qt::transparent); <span class="comment">// 使用透明色填充图片</span></span><br><span class="line"></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(&amp;dest)</span></span>;</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, <span class="number">0</span>, pix1);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(pos1Width, <span class="number">0</span>, pix2);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="built_in">qMax</span>(destSize.<span class="built_in">width</span>() - pos3Width, <span class="number">0</span>), <span class="number">0</span>, pix3);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, pos1Height, pix4);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(pos1Width, pos1Height, pix5);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="built_in">qMax</span>(destSize.<span class="built_in">width</span>() - pos3Width, <span class="number">0</span>), pos1Height, pix6);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, <span class="built_in">qMax</span>(destSize.<span class="built_in">height</span>() - pos7Height, <span class="number">0</span>), pix7);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(pos1Width, <span class="built_in">qMax</span>(destSize.<span class="built_in">height</span>() - pos7Height, <span class="number">0</span>), pix8);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="built_in">qMax</span>(destSize.<span class="built_in">width</span>() - pos3Width, <span class="number">0</span>), <span class="built_in">qMax</span>(destSize.<span class="built_in">height</span>() - pos7Height, <span class="number">0</span>), pix9);</span><br><span class="line">    painter.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>调试小技巧：</p><p>可以把每个区域的图片保存到本地，查看图片是否正确，如：<br>    </p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pix1.<span class="built_in">save</span>(<span class="string">"D:\\1.png"</span>);</span><br><span class="line">pix2.<span class="built_in">save</span>(<span class="string">"D:\\2.png"</span>);</span><br><span class="line">pix3.<span class="built_in">save</span>(<span class="string">"D:\\3.png"</span>);</span><br><span class="line">pix4.<span class="built_in">save</span>(<span class="string">"D:\\4.png"</span>);</span><br><span class="line">pix5.<span class="built_in">save</span>(<span class="string">"D:\\5.png"</span>);</span><br><span class="line">pix6.<span class="built_in">save</span>(<span class="string">"D:\\6.png"</span>);</span><br><span class="line">pix7.<span class="built_in">save</span>(<span class="string">"D:\\7.png"</span>);</span><br><span class="line">pix8.<span class="built_in">save</span>(<span class="string">"D:\\8.png"</span>);</span><br><span class="line">pix9.<span class="built_in">save</span>(<span class="string">"D:\\9.png"</span>);</span><br></pre></td></tr></tbody></table></figure><p></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《Windows套接字I/O模型》</title>
      <link href="/post/3383048230.html"/>
      <url>/post/3383048230.html</url>
      
        <content type="html"><![CDATA[<p>本栏目主要介绍Windows网络编程中涉及的一些网络模型，如WSAEventSelect模型，WSAAsyncSelect模型，完成端口模型等。</p><span id="more"></span><p>文章列表：</p><ul><li><a href="/post/2937580891.html" title="Windows套接字I/O模型(1)-阻塞模型">Windows套接字I/O模型(1)-阻塞模型</a></li><li><a href="/post/640627104.html" title="Windows套接字I/O模型(2)-Select模型">Windows套接字I/O模型(2)-Select模型</a></li><li><a href="/post/2544551173.html" title="Windows套接字I/O模型(3)-WSAAsyncSelect模型">Windows套接字I/O模型(3)-WSAAsyncSelect模型</a></li><li><a href="/post/547434843.html" title="Windows套接字I/O模型(4)-WSAEventSelect模型">Windows套接字I/O模型(4)-WSAEventSelect模型</a></li><li><a href="/post/326824759.html" title="Windows套接字I/O模型(5)-完成端口模型">Windows套接字I/O模型(5)-完成端口模型</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows套接字I/O模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小懒</title>
      <link href="/post/2501563677.html"/>
      <url>/post/2501563677.html</url>
      
        <content type="html"><![CDATA[<p>人生于世，一味勤，不见得是好事。</p><p>与人处，得小懒。管头管脚，大到原则问题，小至鸡毛蒜皮，样样都想插一手。这样的相处模式，除了惹人厌，再难有其他结果。容他人藏点隐私，给彼此留点空间，这样的小懒，比起所谓的无微不至更令人欣赏。</p><p>与人言，也得小懒。话不能说得太满，意犹未尽之处，于人于已都是余地。留有这样的余地，日后才好转圜。同样的意思，横冲直撞与婉转留余，可能带来不同的结果。留一线，好相见，这样的留，自然是小懒。</p><span id="more"></span><p>言语中的小懒，还在于倾听。话不说满，这满是话意，也是话频。一味照着自己的频率说，不顾对方的感受，也不理会对方的想法。这种单方面的所谓沟通，比起无言的槛尬，更令人心生庆烦。话不能说得太满，也不能说得太勤，时时带着点小懒，关注对方的心思，给对方表达的机会，这才是两相宜的沟通方式。</p><p>独处，也得带点小懒。忙忙碌碌，俗务缠身，这是很多人的常态。但再忙，总得有那么一些时光，一个人，一本书，一盏茶，静享闲暇之乐。紧绷与小懒，劳与逸，两相结合，人生的路才能走得更远。</p><p>养儿育女，其实也需要小懒。能干的父母，容易养出懒情的儿女。事无巨细，大包大揽，自然会让儿女养成依赖的习惯。久而久之，习惯就成了本性。到那时，再怎么怨叹，也无济于事。</p><p>人生的小懒，不同于彻底躺平的大懒，也不是任由本性的放纵。一路奔跑之余，总得留有那么一点儿时光，来放任自己的小懒。这样的小懒，如春日的阳光，又似秋日的微风，不多不少，却刚刚好。</p><blockquote><p>作者：郭华悦</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ⑬ 美文赏析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MSVC版本的二进制兼容性</title>
      <link href="/post/3437796039.html"/>
      <url>/post/3437796039.html</url>
      
        <content type="html"><![CDATA[<p>Visual Studio 2013 及更早版本中的 Microsoft C++ (MSVC) 编译器工具集<strong>不保证</strong>主版本间的二进制兼容性，无法链接由不同版本工具集生成的对象文件、静态库、动态库和可执行文件。 ABI、对象格式和运行时库不兼容。</p><p>微软在 Visual Studio 2015 及更高版本中改变了这个行为。对于自 Visual Studio 2015 以来的所有版本（<strong>该版本号都以 14 开头</strong>，如Visual Studio 2015、2017、2019 和 2022工具集的版本分别为 v140、v141、v142 和 v143）由其中任一版本编译器编译的运行时库和应用具有二进制兼容性。假设你使用 Visual Studio 2015 生成第三方库，你仍可在 Visual Studio 2017、2019 或 2022 生成的应用程序中使用它们，无需使用匹配工具集重新编译。 同时最新版本的 Microsoft Visual C++ 可再发行程序包（可再发行程序包）也适用于所有版本，无需为不同版本安装不同的运行时库，统一安装最新的即可。</p><span id="more"></span><h2 id="对二进制兼容性的限制"><a href="#对二进制兼容性的限制" class="headerlink" title="对二进制兼容性的限制"></a>对二进制兼容性的限制</h2><p>v140、v141、v142 和 v143 工具集与次要版本号更新之间的二进制兼容性方面存在三个重要限制：</p><ul><li><p>你可以混合使用由 v140、v141、v142 和 v143 工具集的不同版本生成的二进制文件。 但是，<strong>必须使用至少与应用中最新二进制文件同样新的工具集进行链接</strong>。 下面是一个示例：可以将使用任何版本的v141工具集（版本 15.0 到 15.9）编译的应用链接到使用 Visual Studio 2019 版本 16.2 (v142) 编译的静态库。 只是必须使用版本 16.2 或更高版本工具集链接它们。只要使用 16.4 或更高版本工具集，便可以将版本 16.2 库链接到版本 16.4 应用。</p></li><li><p>应用使用的可再发行程序包具有类似的二进制兼容性限制。 混合使用由工具集的不同受支持版本生成的二进制文件时，可再发行程序包版本必须至少与任何应用组件使用的最新工具集一样新。</p></li><li><p>使用 <a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/gl-whole-program-optimization?view=msvc-170">/GL</a><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/gl-whole-program-optimization?view=msvc-170">（全程序优化）</a>编译器开关编译或是使用 <a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/ltcg-link-time-code-generation?view=msvc-170">/LTCG</a><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/ltcg-link-time-code-generation?view=msvc-170">（链接时间代码生成）</a>链接的静态库或对象文件不在各个版本间二进制兼容（包括次要版本更新）。</p><p>使用 <code>/GL</code> 和 <code>/LTCG</code> 编译的所有对象文件和库必须将完全相同的工具集用于编译和最终链接。 例如，使用 Visual Studio 2019 版本 16.7 工具集中的 <code>/GL</code> 生成的代码无法链接到使用 Visual Studio 2019 版本 16.8 工具集中的 <code>/GL</code>生成的代码。 编译器会发出<a href="https://learn.microsoft.com/zh-cn/cpp/error-messages/compiler-errors-1/fatal-error-c1047?view=msvc-170">错误 C1047</a>。</p></li></ul><h2 id="从-Visual-Studio-2015-及更高版本升级-Microsoft-Visual-C-可再发行程序包"><a href="#从-Visual-Studio-2015-及更高版本升级-Microsoft-Visual-C-可再发行程序包" class="headerlink" title="从 Visual Studio 2015 及更高版本升级 Microsoft Visual C++ 可再发行程序包"></a>从 Visual Studio 2015 及更高版本升级 Microsoft Visual C++ 可再发行程序包</h2><p>对于 Visual Studio 2015、2017、2019 和 2022，微软将 Microsoft Visual C++ 可再发行程序包的主版本号保持一致。 这意味着我们一次只能安装可再发行程序包的一个实例。 较新版本会覆盖已安装的任何较旧版本。 例如，一个应用可能会从 Visual Studio 2015 安装可再发行程序包。 随后另一个应用从 Visual Studio 2022 安装可再发行程序包。 2022 版本会覆盖较旧版本，但由于它们具有二进制兼容性，早期应用仍可正常工作。 微软确保最新版本的可再发行程序包具有所有最新的功能、安全更新和 bug 修补程序。 这便是为什么微软始终建议升级到最新可用版本。</p><p>同样，已安装了较新版本时，无法安装较旧的可再发行程序包。 如果尝试，则安装程序会报告错误。 如果在已具有 2022 版本的计算机上安装 2017 或 2019 可再发行程序，则会看到如下所示的错误：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x80070666 - Another version of this product is already installed. Installation of this version cannot continue. To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel.</span><br></pre></td></tr></tbody></table></figure><p>此错误是微软故意这样设计的，以确保Microsoft Visual C++ 可再发行程序包为最新版本。 </p><blockquote><p>本文参考：<a href="https://learn.microsoft.com/zh-cn/cpp/porting/binary-compat-2015-2017?view=msvc-170">Visual Studio 版本之间的 C++ 二进制兼容性</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ⑩ 编程基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vcpkg使用仓库最新代码</title>
      <link href="/post/2065175920.html"/>
      <url>/post/2065175920.html</url>
      
        <content type="html"><![CDATA[<p>在向Vcpkg提交port时，我们会不断地对仓库进行修改和调试。如果采用<code>REF</code>方式指定源码版本，则需要不断地修改REF和SHA512，我们可以采用<code>HEAD_REF</code>的方式来简化调试流程。</p><p>在<code>portfile.cmake</code>文件中指定<code>HEAD_REF</code>，如：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vcpkg_from_github(</span><br><span class="line">    OUT_SOURCE_PATH SOURCE_PATH</span><br><span class="line">    REPO winsoft666/ashe</span><br><span class="line">    HEAD_REF main</span><br><span class="line">    AUTHORIZATION_TOKEN $ENV{GITHUB_TOKEN}</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>安装时指定<code>--head</code>参数：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg <span class="keyword">install</span> ashe:x64-windows-static --head</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑩ 编程基础 </category>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vcpkg </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake按目录层级进行分组</title>
      <link href="/post/1531265402.html"/>
      <url>/post/1531265402.html</url>
      
        <content type="html"><![CDATA[<p>为了提高项目的可维护性，我们通常会将不同用途的代码文件放到不同的文件夹中，如头文件放到include目录，源文件放到src目录，第三方库放到3rd目录等。</p><p>当使用CMake生成Visual Studio工程时，我们亦希望在Visual Studio中能看到这样的文件结构。当然，我们可以使用<code>source_group</code>指令进行添加，但当目录和层级很多时，这样添加起来就显得比较繁琐了，本文介绍一种懒人方法。</p><span id="more"></span><p>函数<code>group_sources</code>用于遍历传入文件并根据文件所在目录添加<code>source_group</code>指令。</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(group_sources)</span><br><span class="line">  <span class="keyword">foreach</span>(_source IN ITEMS <span class="variable">${ARGN}</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">IS_ABSOLUTE</span> <span class="string">"${_source}"</span>)</span><br><span class="line">        <span class="keyword">file</span>(RELATIVE_PATH _source_rel <span class="string">"${CMAKE_CURRENT_SOURCE_DIR}"</span> <span class="string">"${_source}"</span>)</span><br><span class="line">    <span class="keyword">else</span>()</span><br><span class="line">        <span class="keyword">set</span>(_source_rel <span class="string">"${_source}"</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取文件所在目录</span></span><br><span class="line">    <span class="keyword">get_filename_component</span>(_source_path <span class="string">"${_source_rel}"</span> PATH)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 替换为Windows路径样式</span></span><br><span class="line">    <span class="keyword">string</span>(REPLACE <span class="string">"/"</span> <span class="string">"\\"</span> _source_path_msvc <span class="string">"${_source_path}"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">source_group</span>(<span class="string">"${_source_path_msvc}"</span> FILES <span class="string">"${_source}"</span>)</span><br><span class="line">  <span class="keyword">endforeach</span>()</span><br><span class="line"><span class="keyword">endfunction</span>(group_sources)</span><br></pre></td></tr></tbody></table></figure><p>函数<code>group_sources</code>支持传入多个参数，使用方法如下：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE HEADER_FILES       ./<span class="keyword">include</span>/*.hpp ./<span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCE_FILES       ./src/*.cc ./src/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装目录层级对${HEADER_FILES}和${SOURCE_FILES}中的文件进行分组</span></span><br><span class="line">group_sources(<span class="variable">${HEADER_FILES}</span> <span class="variable">${SOURCE_FILES}</span>)</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑩ 编程基础 </category>
          
          <category> CMake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>做人做事做管理</title>
      <link href="/post/1719474789.html"/>
      <url>/post/1719474789.html</url>
      
        <content type="html"><![CDATA[<p>大道至简，越是根源和基本的问题，道理实际上越简单。关于如何做人、做事、做管理的书很多，我看得不多，但是我觉得这些书更多是侧重技术和实现细节上的，而很少从人的思想和观念去讲。从实际根本上去说，如何做人做事是世界观的问题，也是一个哲学话题。很多人和我一样，已经到了30的年纪，是需要去思考一下应该如何做人如何做事的，也需要一套简单、有效、完整的体系来指导自己，而这套体系将是让自己安身立命于这个世界的基石。</p><span id="more"></span><h1 id="职场上如何做人"><a href="#职场上如何做人" class="headerlink" title="职场上如何做人"></a>职场上如何做人</h1><p>关于在职场上如何做人，我只谨记两个字－－服务。</p><p>你要把自己当成一个品牌去爱惜，当成一家公司去经营，你要牢牢记住你之所以能在一家公司立足，是因为公司需要你的服务。</p><p>我们经常会抱怨某某银行的工作人员服务态度不好、某某商品的售后服务不好，但从来不去思考自己对公司的服务好不好？公司的任务有没有如期完成，有没有哪个任务是提前完成的，是否所有任务都拖到“最后期限”？工作完成的够不够彻底，是不是答复已经完成了，结果后面又出状况？完成后有没有向上级反馈，是不是等到上级问你完成了没有，你才去报告进度？拖延的任务有没有持续跟进，是不是上级不追了这个任务最后就不了了之了？上面这些问题我都是反复遇见，其实根本原因就是没有意识到你其实在做一项服务，你在公司的发展前景，全都取决你对公司的服务够不够好。设想一下，如果交给你的每件事情都可以迎刃而解、化险为夷，让人感觉稳妥、放心、踏实，你自然会收到更多更重要的“订单”。当你的单多到你忙不过来的时候怎么办？招下属啊，呵呵，恭喜你，你已经是领导了（当然我们也要排除极少数的任人唯亲的公司，大局面是积极向上的）。反之，如果给你一件事情你要拖延，给你一件事情你办不好，给你一件事情就没了下文了，让人不放心，久而久之你就“无单可做”了，那么公司重新请一个人就可以了，干嘛非要用你呢？</p><p>服务不光是对于自己供职的公司，对于公司的客户也是一样的。每一次去客户那里出差前，我总是再三叮嘱自己，我此次之行是为客户做服务的，是去为客户解决问题的。这个心态非常重要，我们做软件系统的，去见客户除了做演示、做培训，很多时候就是处理现场问题，难免遇到客户对系统的投诉，比如系统速度慢、bug多等问题。当你有了这样的心态，你就会谦虚地接受客户的批评，细致地记录客户提出的问题，然后一项项地去思考如何解决，并且应该给客户一份详尽的解决方案。有了这样的心态，你会不自觉地、自然而然地与客户站在一边，让他感到你是在为他着想，帮助他去解决问题的。在你面对客户时，应该有这样一个虔诚的信念：我是去为客户服务的，为他解决他所解决不了的问题的。如果你没有这样的心态，面对投诉很可能就会产生厌烦，而且容易为自己的问题进行辩解。这种做法给客户的感觉就是你竭力在证明你是对的他是错的，这样你就站在客户的对面了。</p><p>在客户面前的表现对你的职场发展也是非常有好处的，尤其是接触到一些跨国企业时，你优良的职业素养会为你赢来客户的认同与尊敬。这样当你哪天希望寻找更高的平台，只要放个口风出去，立即就会有Offer了。所以认真服务好客户只赚不赔。</p><h1 id="职场上如何做事"><a href="#职场上如何做事" class="headerlink" title="职场上如何做事"></a>职场上如何做事</h1><p>关于如何做事，也有很多的理论，比如要事第一，把事情分为紧急、重要等等，这些我都不讨论了，我只就我自己的经验来谈一谈。</p><p>对于如何做事，我也恪守一个信条：不焦不燥，把心沉下去，将注意力集中于要解决的问题上。</p><p>我看过这样一个故事，是说从前有一户人家，家里的菜园中有一块大石头，经常会有人不小心撞到；儿子就问：为什么不把他挖走呢？他的爸爸说：这个石头爷爷的时代就有了，就是因为它那么大，不好挖才一直在那里；又过了一代人，家里的一个媳妇实在受不了，就扛着锄头去挖了，她已经做好了心理准备要挖几天的时间，结果一天就挖完了… …原来那个石头的中间是空的。</p><p>我们遇到的很多事情也是一样的，看似棘手、难以解决，实际上只要你认真地去分析、去思考，然后放手去做，往往并没有想象中的那么困难。你需要克服心中的顽石。我发现一些人遇到问题后，很轻易地就会说：这个我做不了，这个实现不了，这个我也没办法。其实就好像看到这块大石头一样，被它的“外表”吓住了，而放弃了应有的行动。</p><p>而且我发现了一个有趣的现象，不管多么困难的问题，只要你沉下心去思考如何解决，就好像在冥冥之中上苍在看着你一样，当你拼到最后就要打算认输的时候，往往会出现新的契机和方法。</p><p>另外，我发现有些人遇到问题的时候，他想的是这件事如何困难如何难以完成，这样的思维方式是有问题的，是一种保守且退缩的思维；遇到问题的时候，想的应该是如何才能够完成。我一般采取这样几个步骤：1、列出所有的可能性；2、分析各种可能性；3、选择一种实现起来最简单、快速的可能性；4、去实现。</p><p>除此以外，我发现一些人在做事的时候，会以“这样做很麻烦”来作为不采纳方案的理由，而不是“这样是否必要”或者“这样是否更好”来作为标准，实际上“麻烦”应该是排在“是否必要”、“是否更好”后面进行考虑的。如果一种实现方式，虽然麻烦，但是很有必要，且对客户来说更好，那么就算麻烦也要去做。但是程序员往往关心的是会不会很麻烦，是不是要修改很多地方，是不是给自己带来很多工作量… …告诉你，你关心的这些不是最重要的。</p><h1 id="职场上如何做管理"><a href="#职场上如何做管理" class="headerlink" title="职场上如何做管理"></a>职场上如何做管理</h1><p>和上面一样，做管理也有很多的细节，我也都不谈了，因为这些都是一本书一本书的讲，而我觉得要简单、有效、好操作，所以我也只说三点。</p><p>我觉得做好一个技术经理，只要下面的三点就好了：</p><h2 id="1、德行"><a href="#1、德行" class="headerlink" title="1、德行"></a>1、德行</h2><p>德行其实就是品德，简单地讲就是要善良、诚恳。最重要的，你做事的出发点要是好的，对别人是没有坏心的。</p><p>为什么说出发点一定要是好的呢？我们还是以服务客户的例子来说，在为客户解决问题的时候，如果我们的出发点是好的，是站在客户一边尽心尽力去为客户解决问题的，那么即便由于方法、能力、条件等各方面的原因，事情搞砸了或者没有做好，也很容易获得客户的理解和原谅。很可能的情形是，你就算做失败了也一样赢得客户；相反，如果你的出发点是“省麻烦”，“赶紧交差了事”，“完成任务”，如果事情做成了也就算了，一旦失败了，你看看客户会怎么样？告诉你，好的客户会批评你、投诉你，因为他对你还有期望；更多的客户是什么话也不说，直接换个供应商就是了，才懒得理你。</p><p>记住永远不要把客户当成傻瓜，你是如何做事情的，客户是很容易感受得到的。所以，面对和服务客户没有那么多的技巧，你不需要有多好的口才和魅力，也用不着忽悠和夸大其词(我发现很多销售人员都是这样，你可以骗客户一次，但就没有第二次了)，你只需要放下身段，兢兢业业地为客户着想，设身处地地解决他的问题就可以。对待下属也是一样的，你对他的奖励也好，惩罚也好，出发点一定要是好的。我对待下属遵循的原则就是：我是在帮助你，帮你把工作做的更好，帮你获得更大的提高，而不是说找你茬儿，跟你过意不去，或者是挤兑你压迫你。德行是基本的，有一个好的德行，至少可以保证你的下属不会讨厌你。</p><blockquote><p>这一点放在做产品上仍然有效，做一个好的产品同样不需要那么多的技巧和花样，从用户实际需求出发，想用户所想，做用户想要的，用户自然买单，盈利也是水到渠成的事情。</p></blockquote><h2 id="2、敬业"><a href="#2、敬业" class="headerlink" title="2、敬业"></a>2、敬业</h2><p>如果有人问我，下属和经理的区别是什么。我会告诉他：下属等着别人交代事情做，经理想着还有哪些事情可以做。</p><p>这其实是一个积极心态的问题，作为一个中层干部，你需要将公司的事情当成自己家的事情来处理，当你有这样的心态，你就是再怎么加班都不会有怨言的，即便分文不取… （有谁见过给自己家装修叫苦不迭的？）如果你可以长期保持这样的状态，你的这种献身精神和敬业精神，会很轻易地感染你的下属和你的同事，你会感觉到在公司左右逢源，而且你也会更有话语权，大家会更重视你的意见，同事和下属也会对你报以更多的信任。当这种情况出现时，管理起下属还会困难吗？但需要注意的是，你的敬业精神不是说体现在无休止的加班上，工作异常繁忙、经常性加班其实是工作没有做好的表现之一，加班只应该出现在紧急情况发生的时候，而不应该是一种常态。</p><h2 id="3、技术"><a href="#3、技术" class="headerlink" title="3、技术"></a>3、技术</h2><p>如果有人问我，技术人员和其他人员最大的区别是什么。我会告诉他：技术人员个个自以为是，认为别人的技术都不如自己。</p><p>可能大家不爱听，但我观察到的现象就是这样的，而且往往那些自认为懂得很多的人，实际是还没敲开知识的大门。</p><p>很少有人愿意去读别人的代码，彼此都觉得写得好烂。所以，如果想赢得技术人员的钦佩，你需要有压倒性的技术能力。这个压倒性的优势，不是下属70分，你80分，而是下属70分，你要做到100分；下属100分，你要做到150分。所以，缺乏技术能力的人去管理技术人员往往是吃力不讨好的，可能下属表面上服从你，心里根本不当你一回事儿，这样管理起来就存在障碍了。当然，如果你的德行非常好，也非常敬业，技术就显得不那么重要了；而如果你已经满足了前面两条，同时技术也很精湛，那自然是锦上添花了。</p><p>上面就是一点点心得，欢迎交流。</p>]]></content>
      
      
      <categories>
          
          <category> ⑧ 软件架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Electron判断程序运行环境</title>
      <link href="/post/612028078.html"/>
      <url>/post/612028078.html</url>
      
        <content type="html"><![CDATA[<p>Electron官方未提供判断当前程序运行环境的方法。我认为官方不提供这个方法也是说的过去的，因为Electron扮演的是应用开发框架的角色，而运行环境这些东西本身属于开发者自己的事情，有的开发者喜欢定义“开发、测试、预生产、生成”四个环境，而有的开发者却只定义了一个生产环境，这些都不是框架需要参与的事情。</p><span id="more"></span><p>本文提供了几个定义和判断程序运行环境的方法，开发者可以根据实际情况选取相应的方法。</p><h1 id="1-根据是否打包来判断"><a href="#1-根据是否打包来判断" class="headerlink" title="1. 根据是否打包来判断"></a>1. 根据是否打包来判断</h1><p>Electron官方提供了<code>app.isPackaged</code>属性来判断应用是否是经过打包的。</p><p>一般开发环境不打包，而非开发环境会打包，我们可以通过这个属性来判断当前运行环境是否是开发环境。</p><h1 id="2-根据可执行文件名判断"><a href="#2-根据可执行文件名判断" class="headerlink" title="2. 根据可执行文件名判断"></a>2. 根据可执行文件名判断</h1><p>在开发环境中，我们通常使用如下命令启动程序：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">electron .</span><br></pre></td></tr></tbody></table></figure><p>此时程序是通过<code>electron.exe</code>（非Windows操作系统上是<code>electron</code>）来启动的，而在打包后的生产环境是通过我们指定的exe启动的，因此我们可以通过判断可执行文件名是否为<code>electron.exe</code>来检查是否为生产环境。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isProduction</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">if</span> (!process.<span class="property">versions</span>.<span class="property">electron</span>) {</span><br><span class="line">    <span class="comment">// Node.js process</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">platform</span> === <span class="string">"darwin"</span>) {</span><br><span class="line">    <span class="keyword">return</span> !<span class="regexp">/\/Electron\.app\//</span>.<span class="title function_">test</span>(process.<span class="property">execPath</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">platform</span> === <span class="string">"win32"</span>) {</span><br><span class="line">    <span class="keyword">return</span> !<span class="regexp">/\\electron\.exe$/</span>.<span class="title function_">test</span>(process.<span class="property">execPath</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">platform</span> === <span class="string">"linux"</span>) {</span><br><span class="line">    <span class="keyword">return</span> !<span class="regexp">/\/electron$/</span>.<span class="title function_">test</span>(process.<span class="property">execPath</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种方式只能用来检查是否为生产环境，不能定义和判断开发、测试、预生产这些环境。</p><h1 id="3-根据命令行参数判断"><a href="#3-根据命令行参数判断" class="headerlink" title="3. 根据命令行参数判断"></a>3. 根据命令行参数判断</h1><p>通过在不同环境中为程序添加不同的启动参数，然后在运行时校验这些命令行参数来判断当前的运行环境。</p><p>不同的环境添加启动参数的方式不太一样。由于开发环境不需要打包，因此可以通过下面方式添加：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">electron . --<span class="built_in">env</span>=development</span><br></pre></td></tr></tbody></table></figure><p>而非开发环境往往需要打包，因此需要在命令行中手动添加，如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo.exe --<span class="built_in">env</span>=<span class="built_in">test</span></span><br></pre></td></tr></tbody></table></figure><p>判断方法如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isProduction</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">if</span> (!process.<span class="property">versions</span>.<span class="property">electron</span>) {</span><br><span class="line">    <span class="comment">// Node.js process</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> process.<span class="property">argv</span>) {</span><br><span class="line">    <span class="keyword">if</span> (v === <span class="string">"--env=development"</span> || <span class="comment">// 开发环境</span></span><br><span class="line">      v === <span class="string">"--env=test"</span> <span class="comment">// 测试环境</span></span><br><span class="line">    ) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4-通过环境变量判断"><a href="#4-通过环境变量判断" class="headerlink" title="4. 通过环境变量判断"></a>4. 通过环境变量判断</h1><p>这个判断方法与方法2类似，不做过多介绍。需要注意的是，Windows和Unix上添加环境变量的方式略有不同。</p><p>Windows:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> APP_ENV=dev &amp;&amp; electron .</span><br></pre></td></tr></tbody></table></figure><p>Unix:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APP_ENV=dev electron .</span><br></pre></td></tr></tbody></table></figure><p>在Electron中通过<code>process.env.APP_ENV</code>就就可以获取到<code>APP_ENV</code>环境变量。</p>]]></content>
      
      
      <categories>
          
          <category> ④ Electron </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Electron启动和禁用调试工具的方法</title>
      <link href="/post/2191045165.html"/>
      <url>/post/2191045165.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-启用调试工具"><a href="#1-启用调试工具" class="headerlink" title="1. 启用调试工具"></a>1. 启用调试工具</h1><p>Electron中打开调试窗口的方法有多种，但前提都需要在创建Browser Window时启用devTools特性，如：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> win = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>({</span><br><span class="line">    <span class="attr">width</span>: <span class="number">1080</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">768</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">"test window"</span>,</span><br><span class="line">    <span class="attr">webPreferences</span>: {</span><br><span class="line">        <span class="attr">devTools</span>: <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p>启用devTools特性后，可以通过下面几种方式打开调试窗口：</p><h2 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h2><p>在代码中使用<code>BrowserWindow.webContents.openDevTools()</code>打开调试窗口。</p><h2 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h2><p>通过快捷键<code>Ctrl+Shift+I</code>打开调试窗口。</p><h2 id="方式3"><a href="#方式3" class="headerlink" title="方式3"></a>方式3</h2><p>在程序的启动命令行中添加<code>--remote-debugging-port=8888</code>参数，然后使用浏览器打开调试页面<code>http://127.0.0.1:8888</code>即可进行调试。</p><p>这种方式默认调试的是渲染进程，如需调试主进程则需要使用<code>--inspect=8888</code>参数。</p><p>另外，如果打开调试页面时提示<code>WebSockets request was expected</code>而无法显示调试工具，需要使用访问<code>chrome://inspect/</code>打开inspect页面，配置对应的发现ip和端口，如<code>localhost:8888</code>：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/electron-debug-1.png"></p><p>配置完成后，刷新inspect页面后在<code>Remote Target</code>中选择对应的调试目标进行调试。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/electron-debug-2.png"></p><h1 id="2-禁用调试工具"><a href="#2-禁用调试工具" class="headerlink" title="2. 禁用调试工具"></a>2. 禁用调试工具</h1><p>在软件上线发布时，我们需要在生产环境完全禁用调试工具，此时只需要将<code>devTools</code>属性设置为false即可，如：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> win = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>({</span><br><span class="line">    <span class="attr">width</span>: <span class="number">1080</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">768</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">"test window"</span>,</span><br><span class="line">    <span class="attr">webPreferences</span>: {</span><br><span class="line">        <span class="attr">devTools</span>: <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>上面的代码虽然可以禁用调试工具，但在开发环境中，我们往往需要打开调试工具，因此在每次“开发-&gt;发布版本”时都需要来回修改devTools，容易出现漏改的情况。</p><p>可以使用<a href="/post/612028078.html" title="Electron判断程序运行环境">Electron判断程序运行环境</a>介绍的方法来判断当前是否为生产环境，启用/禁用devTools的代码可以优化为：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> win = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>({</span><br><span class="line">    <span class="attr">width</span>: <span class="number">1080</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">768</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">"test window"</span>,</span><br><span class="line">    <span class="attr">webPreferences</span>: {</span><br><span class="line">        <span class="attr">devTools</span>: !<span class="title function_">isProduction</span>()</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ④ Electron </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在Qt中线条是如何占用空间的</title>
      <link href="/post/2292901264.html"/>
      <url>/post/2292901264.html</url>
      
        <content type="html"><![CDATA[<p>当线条宽度仅有1像素时，我们可能不太关心这1像素占用的是哪里的空间，但当线条宽度很大时，如50像素，此时我们就需要考虑这50像素占用的是哪里的空间了，否则绘制出来的效果和预期的会有很大的差别。</p><span id="more"></span><p>现有如下需求：</p><p>在窗口的(200,200)位置绘制长宽均为200px、边框宽度为50px的矩形。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QtWidgetsApplication::paintEvent</span><span class="params">(QPaintEvent* e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 窗口填充白色，方便观察</span></span><br><span class="line">    painter.<span class="built_in">fillRect</span>(<span class="built_in">rect</span>(), <span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    QPen pen;</span><br><span class="line">    <span class="comment">// 边框颜色为蓝色，宽度为40px</span></span><br><span class="line">    pen.<span class="built_in">setColor</span>(<span class="built_in">QColor</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">    pen.<span class="built_in">setWidth</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在(200,200)处绘制200*200的矩形</span></span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实际绘制出来的矩形左上角坐标不是预期的(200, 200)，长宽也不是200px，如下图所示（红色部分是为了便于讲解，后期使用工具添加上去的）：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/qt-xtrhzykj-1.png"></p><p>图中A处的实际坐标为(200, 200)，位于边框的中间位置。</p><p>实际绘制矩形位置为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">QRect</span>(<span class="number">200</span> - <span class="number">40</span> / <span class="number">2</span>, <span class="number">200</span> - <span class="number">40</span> / <span class="number">2</span>, <span class="number">200</span> + <span class="number">40</span>, <span class="number">200</span> + <span class="number">40</span>)</span><br><span class="line">=</span><br><span class="line"><span class="built_in">QRect</span>(<span class="number">180</span>, <span class="number">180</span>, <span class="number">240</span>, <span class="number">240</span>)</span><br></pre></td></tr></tbody></table></figure><p>总结起来就是：</p><p>我们在<code>drawRect</code>等函数中指定的<code>左上角坐标</code>实际是<code>左上方两条边框相交的中心点</code>，指定的<code>宽度</code>是<code>左右边框中心点的距离</code>，<code>高度</code>是<code>上下边框中心点的距离</code>。</p><p>使用<code>drawLine</code>绘制线条时，与绘制矩形时一样，指定的<code>起点坐标</code>实际是<code>起点处线条中心点位置</code>，指定的<code>终点坐标</code>实际是<code>终点处线条中心点位置</code>。</p><h2 id="为什么边框相交处是如下图所示的样式？"><a href="#为什么边框相交处是如下图所示的样式？" class="headerlink" title="为什么边框相交处是如下图所示的样式？"></a>为什么边框相交处是如下图所示的样式？</h2><p><img src="https://blog-static.jiangxueqiao.com/blog/img/qt-xtrhzykj-2.png"></p><p>这个是由QPen的相交样式（<code>Qt::PenJoinStyle</code>）控制的，可以通过<code>QPen::setJoinStyle</code>方法修改。</p>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何在批处理中执行SQL</title>
      <link href="/post/4169328538.html"/>
      <url>/post/4169328538.html</url>
      
        <content type="html"><![CDATA[<p>示例如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"%~dp0\mysql-5.6.19-win32\bin\mysql.exe" ^</span><br><span class="line">  -h127.0.0.1 -P31060 -uroot ^</span><br><span class="line">  --execute="update mysql.user SET password=PASSWORD('123456') WHERE user='root';";</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑩ 编程基础 </category>
          
          <category> 批处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由HANDLE返回值不确定性引发的思考</title>
      <link href="/post/3906615635.html"/>
      <url>/post/3906615635.html</url>
      
        <content type="html"><![CDATA[<p>HANDLE返回值的不确定性指的是Windows API函数的返回值为HANDLE类型时，有两种表示失败的方式：</p><ul><li>HANDLE == NULL，如CreateEvent等</li><li>HANDLE == INVALID_HANDLE_VALUE，如CreateFile等</li></ul><p>其中，NULL的值始终为0，而INVALID_HANDLE_VALUE的值为-1，其在32位和64位程序中分别使用0xFFFFFFFF和0xFFFFFFFFFFFFFFFF表示。</p><p>具体哪些函数失败时返回NULL，哪些返回INVALID_HANDLE_VALUE了？这个需要查阅MSDN文档来确定。</p><span id="more"></span><p><strong>为什么会出现这两种情况了？</strong></p><p>根据Windows强大的兼容性，我们不能猜测出这么做是为了向前兼容，兼容以前的16位程序。</p><p>在16位程序中无效的<code>HANDLE == INVALID_HANDLE_VALUE == 0xFFFF</code>，而到了32位（或64位）时代，则使用0xFFFFFFFF（或0xFFFFFFFFFFFFFFFF）表示。</p><p>所以我们在判断HANDLE是否合法时，要特别留意，需要根据API的不同来做不同的判断。</p><h2 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h2><p><code>GetCurrentProcess()</code>用于获取当前进程的伪句柄，当前进程的伪句柄值是<code>-1</code>，恰好与INVALID_HANDLE_VALUE值相等。</p><p>因此用<code>WaitForSingleObject</code>等待INVALID_HANDLE_VALUE也就是等同于等待当前进程结束。</p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/post/2185937873.html"/>
      <url>/post/2185937873.html</url>
      
        <content type="html"><![CDATA[<p>来都来了，那就留下点什么吧！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>🔥Power By Me</title>
      <link href="/post/3416050985.html"/>
      <url>/post/3416050985.html</url>
      
        <content type="html"><![CDATA[<p>本篇主要汇总一些在本站中提及的、由我开发的小工具和开源项目。</p><p>工具：</p><ul><li><a href="/post/776574933.html" title="一键启动神器之1key.run">一键启动神器之1key.run</a></li><li><a href="/post/2053741240.html" title="TinyTu-跨平台图片压缩软件">TinyTu-跨平台图片压缩软件</a></li><li><a href="/post/1533480858.html" title="Windows窗口调试利器-WinSpyPlus">Windows窗口调试利器-WinSpyPlus</a></li></ul><p>开源库：</p><ul><li><a href="/post/3157704992.html" title="高速文件下载器的实现">高速文件下载器的实现</a></li><li><a href="/post/2402568381.html" title="基于Qt的无边框窗体实现">基于Qt的无边框窗体实现</a></li></ul><hr><p>更多的开源项目见我的Github：</p><p><a href="https://github.com/winsoft666">https://github.com/winsoft666</a></p>]]></content>
      
      
      <categories>
          
          <category> ③ Power By Me </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>窗口无法接收WM_LBUTTONDBLCLK消息</title>
      <link href="/post/1955778079.html"/>
      <url>/post/1955778079.html</url>
      
        <content type="html"><![CDATA[<p>在开发中遇到了如下问题：</p><p>通过鼠标钩子获取某窗口的消息，发现可以接收到WM_LBUTTONDOWN消息，但始终无法接收到WM_LBUTTONDBLCLK消息。</p><p>经过一番排查，发现Windows窗口只有在拥有<code>CS_DBLCLKS</code>类样式时才能接收到鼠标双击事件，即在RegisterClassEx函数的<code>WNDCLASSEX.style</code>参数中指定CS_DBLCLKS样式。</p><p>但是窗口不是我们自己创建的，能否通过<code>SetClassLongPtr</code>函数来通过句柄改变窗口类样式，经过多方尝试最终以失败告终（SetClassLongPtr返回值0，GetLastError也为0）。</p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TinyTu-跨平台图片压缩软件</title>
      <link href="/post/2053741240.html"/>
      <url>/post/2053741240.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-static.jiangxueqiao.com/blog/img/tinytu.png"></p><p>我平时压缩图片通常会使用类似tinify这样的在线图片压缩网站，这些网站有很多，但使用起来总是感觉不太舒爽，似乎差了点什么，仔细想想它们或多或少有这些缺点：</p><ul><li>有的网站需要收费或者半收费。</li><li>支持图片格式不全，例如有的网站仅PNG格式，而有的网站又不支持jpg、gif等。</li><li>通常还会限制上传图片的数量和大小，毕竟上传和下载都会消耗服务器的网络带宽，网站为了节省成本做出此限制。</li><li>图片的压缩速度较慢，毕竟压缩速度越快对服务器的硬件要求越高，成本也会越高。</li></ul><span id="more"></span><h1 id="1-TinyTu"><a href="#1-TinyTu" class="headerlink" title="1. TinyTu"></a>1. TinyTu</h1><p>这些毛病我已经忍了许久，今天我不想再忍了，经过我一顿折腾（不得不说，想做得好用还得费点心思），一款名为<code>TinyTu</code>的图片压缩软件应运而生。因为TinyTu是本地客户端软件，所以不会限制图片的数量、大小，而且还可以使用本机GPU进行硬件加速，提升图片压缩速度。</p><p>TinyTu起来非常方便，不需要额外配置，只需要拖入图片，然后点击“立即压缩”即可。</p><p>目前支持的图片格式有：</p><ul><li>PNG</li><li>JPEG</li><li>不断扩展中…</li></ul><p><img src="https://blog-static.jiangxueqiao.com/blog/img/tinytu-01.png"></p><h1 id="2-下载"><a href="#2-下载" class="headerlink" title="2. 下载"></a>2. 下载</h1><ul><li><p>Github（更新及时）</p><p><a href="https://github.com/winsoft666/TinyTu-Setup/releases">https://github.com/winsoft666/TinyTu-Setup/releases</a></p></li><li><p>奶牛快传（更新可能延后）</p><p><a href="https://cowtransfer.com/s/752c3951b5f64b">https://cowtransfer.com/s/752c3951b5f64b</a></p></li></ul><h1 id="3-图片质量"><a href="#3-图片质量" class="headerlink" title="3. 图片质量"></a>3. 图片质量</h1><p>TinyTu目前支持高、正常、低三个挡位的质量设置。</p><p>这样极大简化了用户设置，用户只需选择某个图片质量，TinyTu会自动在压缩速度和图片质量间进行权衡，达到最理想的压缩效果。</p><p>默认值为“正常”，该挡位已可以媲美很多在线网站的压缩效果。</p><h1 id="4-输出策略"><a href="#4-输出策略" class="headerlink" title="4. 输出策略"></a>4. 输出策略</h1><p>TinyTu目前支持三种保存压缩后新文件的方式：</p><ul><li><p>直接覆盖源文件。</p><p>这种方式会直接使用压缩后的文件覆盖源文件（即压缩前的文件）。</p></li><li><p>输出到源目录（默认）</p><p>该方式会将压缩后的文件输出到和源文件相同的文件夹，但会在新文件名后添加“TinyTu”尾缀，如<code>test.png</code>压缩后的图片为<code>test_TinyTu.png</code>。</p></li><li><p>输出到其他目录。</p><p>我们也可以选择其他的文件夹作为压缩后文件的输出目录。</p></li></ul><h1 id="5-跳过已完成文件"><a href="#5-跳过已完成文件" class="headerlink" title="5. 跳过已完成文件"></a>5. 跳过已完成文件</h1><p>该选项默认开启。</p><p>有这样一种应用场景，我们向列表中添加了5个文件并已压缩完成，此时需要再添加新的文件继续压缩，通过设置该选项TinyTu会跳过之前已经完成的文件，而不需要我们每次添加新文件前都要清空列表。</p>]]></content>
      
      
      <categories>
          
          <category> ③ Power By Me </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>QListWidget使用记录</title>
      <link href="/post/3168359900.html"/>
      <url>/post/3168359900.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-解决无法拖入文件到QListWidget"><a href="#1-解决无法拖入文件到QListWidget" class="headerlink" title="1. 解决无法拖入文件到QListWidget"></a>1. 解决无法拖入文件到QListWidget</h2><p>一般而言，QWidget支持拖入文件只需要做如下操作即可：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setDragDropMode</span>(QAbstractItemView::DropOnly); <span class="comment">// 仅支持拖入文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写dragEnterEvent，当拖入文件进入时被调用，可以在该函数中取消拖入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dragEnterEvent</span><span class="params">(QDragEnterEvent* e)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写dropEvent，当拖入文件并释放鼠标时被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dropEvent</span><span class="params">(QDropEvent* e)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>但执行上述操作后，拖入文件到QListWidget却只能收到dragEnterEvent事件，却无法收到dropEvent事件。</p><span id="more"></span><p>因为还需要重写dragMoveEvent方法，如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dragMoveEvent</span><span class="params">(QDragMoveEvent* e)</span> </span>{</span><br><span class="line">    e-&gt;<span class="built_in">acceptProposedAction</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-QListWidgetItem自适应尺寸"><a href="#2-QListWidgetItem自适应尺寸" class="headerlink" title="2. QListWidgetItem自适应尺寸"></a>2. QListWidgetItem自适应尺寸</h2><p>QListWidget添加item的方法如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QListWidget* list = <span class="keyword">new</span> <span class="built_in">QListWidget</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">QListWidgetItem* item = <span class="keyword">new</span> <span class="built_in">QListWidgetItem</span>();</span><br><span class="line">list-&gt;<span class="built_in">addItem</span>(item);</span><br></pre></td></tr></tbody></table></figure><p>如需要自定义Item的布局，可以通过自定义Widget，如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QListWidget* list = <span class="keyword">new</span> <span class="built_in">QListWidget</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">QListWidgetItem* item = <span class="keyword">new</span> <span class="built_in">QListWidgetItem</span>();</span><br><span class="line">list-&gt;<span class="built_in">addItem</span>(item);</span><br><span class="line"></span><br><span class="line">CustomWidget * customWidget = <span class="keyword">new</span> <span class="built_in">CustomWidget</span>();</span><br><span class="line">list-&gt;<span class="built_in">setItemWidget</span>(item, customWidget);  <span class="comment">// 设置Item的自定义Widget</span></span><br></pre></td></tr></tbody></table></figure><p>此时还没有为item设置size hint，item会自动根据item的数据（如text）计算size hint。但如果是自定义的Widget，则无法自动计算size hint，需要手动设置size hint，如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> vScrollbarWidth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">verticalScrollBar</span>())</span><br><span class="line">    vScrollbarWidth = <span class="built_in">verticalScrollBar</span>()-&gt;<span class="built_in">width</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减去纵坐标的宽度</span></span><br><span class="line">item-&gt;<span class="built_in">setSizeHint</span>(<span class="built_in">QSize</span>(list-&gt;<span class="built_in">width</span>() - vScrollbarWidth, widget-&gt;<span class="built_in">height</span>()));</span><br></pre></td></tr></tbody></table></figure><p>QListWidget的滚动条默认显示策略是<code>ScrollBarAsNeeded</code>，当宽度不够显示Item时，滚动条就会显示出来，此时虽然QListWidget宽度改变了，但Item的宽度不会改变，因此Item不会收到ResizeEvent事件。如需Item的宽度跟随QListWidget宽度而改变，需要关闭滚动条显示并在QListWidget的ResizeEvent事件中实时设置每个Item的size hint，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list-&gt;<span class="built_in">setHorizontalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOff);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileList::resizeEvent</span><span class="params">(QResizeEvent* e)</span> </span>{</span><br><span class="line">    <span class="type">int</span> vScrollbarWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">verticalScrollBar</span>())</span><br><span class="line">        vScrollbarWidth = <span class="built_in">verticalScrollBar</span>()-&gt;<span class="built_in">width</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> w = <span class="built_in">width</span>();</span><br><span class="line">    <span class="type">int</span> cnt = <span class="built_in">count</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) {</span><br><span class="line">        QListWidgetItem* it = <span class="built_in">item</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (it) {</span><br><span class="line">            CustomWidget* customWidget = <span class="built_in">dynamic_cast</span>&lt;CustomWidget*&gt;(<span class="built_in">itemWidget</span>(it));</span><br><span class="line">            <span class="keyword">if</span> (customWidget) {</span><br><span class="line">                it-&gt;<span class="built_in">setSizeHint</span>(<span class="built_in">QSize</span>(w - vScrollbarWidth, customWidget-&gt;<span class="built_in">height</span>()));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    QListWidget::<span class="built_in">resizeEvent</span>(e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Qt静态库编译</title>
      <link href="/post/3406024791.html"/>
      <url>/post/3406024791.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>需要注意：使用Qt静态库违背了Qt的免费使用协议。</p></blockquote><h1 id="1-编译"><a href="#1-编译" class="headerlink" title="1. 编译"></a>1. 编译</h1><p>编译Qt源码需要提前安装如下工具：</p><ul><li>nasm</li><li>perl</li><li>gperf</li><li>win_flex_bison</li><li>llvm</li><li>python2</li><li>openssl</li></ul><span id="more"></span><h2 id="2-1-Windows编译"><a href="#2-1-Windows编译" class="headerlink" title="2.1 Windows编译"></a>2.1 Windows编译</h2><p>为了方便编译，我已将这些工具和打包脚本提交到了我的开源项目<a href="https://github.com/winsoft666/qt-source-compile">qt-source-compile</a>中。</p><p>只需克隆项目到本地，选择对应的批处理文件（如<code>msvc2022-5.15.2-x86-static-mt.bat</code>），然后编辑该文件中的<code>qt_src_folder</code>变量（Qt源码路径）和<code>vcvarsall_path</code>变量（Visual Studio路径），最后运行该批处理即可编译。</p><h1 id="2-疑难问题"><a href="#2-疑难问题" class="headerlink" title="2. 疑难问题"></a>2. 疑难问题</h1><h2 id="openssl链接失败"><a href="#openssl链接失败" class="headerlink" title="openssl链接失败"></a>openssl链接失败</h2><p>错误提示如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Feature 'openssl-linked' was enabled, but the pre-condition '!features.securetransport &amp;&amp; !features.schannel &amp;&amp; libs.openssl' failed.</span><br></pre></td></tr></tbody></table></figure><p>上述错误可能是由于指定openssl的include、lib目录最后包含<code>\</code>导致。</p>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows的DLL全局共享变量</title>
      <link href="/post/3002178342.html"/>
      <url>/post/3002178342.html</url>
      
        <content type="html"><![CDATA[<p>同一个DLL文件可以被多个进程加载。当不同的进程将DLL映射到自己的内存空间时，系统会为DLL中的全局和静态变量创建不同的实例，而不会共享同一个变量实例。</p><p>那我们如何实现在进程间共享DLL全局变量呢？<br>我们可以在DLL中使用如下语句来创建一个段，用来存放那些需要共享的变量：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg(<span class="string">"AnyName"</span>)  <span class="comment">// 开始</span></span></span><br><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg()   <span class="comment">// 结束</span></span></span><br></pre></td></tr></tbody></table></figure><p>共享的变量需要被初始化，并且还要设置链接器开关，使该段在所有映射DLL的进程中成为共享读写属性：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享读写</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">"/SECTION:AnyName,RWS"</span>)</span></span><br></pre></td></tr></tbody></table></figure><p>经过上述操作，共享的变量就可以跨不同进程进行读写操作了。</p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>批处理杂记</title>
      <link href="/post/3801212176.html"/>
      <url>/post/3801212176.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-exit"><a href="#1-exit" class="headerlink" title="1. exit"></a>1. exit</h1><p>exit命令用于退出当前的批处理脚本，并返回一个退出代码ExitCode（即返回值）。退出代码通常是一个整数，用于指示脚本执行的状态，例如成功（0）或失败（非零值）。</p><p><code>exit</code>命令的语法为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit [/b] [exitCode]</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>/b</code> 选项表示仅退出当前批处理脚本的执行，而不会影响调用脚本的父进程。如果不使用 <code>/b</code> 选项，则 exit 命令会终止当前整个的命令处理器进程（CMD.EXE），并返回退出代码给调用者。</p><p>exitCode 是一个可选参数，用于指定退出代码。如果未指定退出代码，则默认返回上一个命令的退出代码。</p><span id="more"></span><h1 id="2-变量延迟扩展"><a href="#2-变量延迟扩展" class="headerlink" title="2. 变量延迟扩展"></a>2. 变量延迟扩展</h1><p><code>SETLOCAL ENABLEDELAYEDEXPANSION</code>的作用是设置本地变量延迟扩展。</p><p>CMD在执行命令前会对脚本进行预处理，在这个过程中，如果有类似<code>%value%</code>这样的变量就会对其进行识别，并且查找这个变量对应的值，从而用该值替换掉变量，这个替换值的过程，就叫变量扩展，这个类似于C/C++中的宏。</p><p>请看下面示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set a=4</span><br><span class="line">set a=5 &amp; echo %a%</span><br></pre></td></tr></tbody></table></figure><p>结果：4</p><p>为什么输出是4而不是5呢？</p><p>原因是批处理是按行读取命令的（另外例如for命令等，其后用一对圆括号闭合的所有语句也当作一行），在执行之前要完成必要的预处理工作，这其中就包括对该行命令中的变量赋值。上例中，批处理在运行到<code>set a=5 &amp; echo %a%</code>之前，先把这一整句读取并做了预处理（对变量a赋了值），此时%a%当然就是4。</p><blockquote><p>明白这个道理之后，我们将上例修改为如下方式，就可以输出结果5。<br>  </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set a=4</span><br><span class="line">set a=5</span><br><span class="line">echo %a%</span><br></pre></td></tr></tbody></table></figure><p></p></blockquote><p>为了能够让批处理感知变量的动态变化，批处理设计了变量延迟，即在读取了一条完整的语句之后，不立即对该行的变量赋值，而会在单条语句执行之前再进行赋值，也就是说“延迟”了对变量的赋值。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">SETLOCAL ENABLEDELAYEDEXPANSION</span><br><span class="line">set a=4</span><br><span class="line">set a=5 &amp; echo !a!</span><br></pre></td></tr></tbody></table></figure><p>结果：5</p><p>由于启动了变量延迟，得到了输出结果5。</p><p>变量延迟的启动语句是<code>SETLOCAL ENABLEDELAYEDEXPANSION</code>，并且变量要用一对叹号括起来，否则就没有变量延迟的效果。</p><h1 id="3-调用npm命令无法返回原批处理"><a href="#3-调用npm命令无法返回原批处理" class="headerlink" title="3. 调用npm命令无法返回原批处理"></a>3. 调用npm命令无法返回原批处理</h1><p>需要使用<code>call</code>命令，如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call npm install</span><br></pre></td></tr></tbody></table></figure><p>具体原因参考：<a href="/post/2372684836.html" title="批处理运行外部程序">批处理运行外部程序</a></p><p>可以使用<code>%errorlevel%</code>获取命令的执行结果（通常0表示成功），如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">call npm run build-release</span><br><span class="line">if %errorlevel% NEQ 0 goto ERROR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:ERROR</span><br><span class="line">echo Compile Failed</span><br></pre></td></tr></tbody></table></figure><h1 id="4-切换脚本的当前目录"><a href="#4-切换脚本的当前目录" class="headerlink" title="4. 切换脚本的当前目录"></a>4. 切换脚本的当前目录</h1><p>有些命令依赖批处理程序的当前目录，如npm、yarn这样的命令。假如项目位于<code>D:\A\B</code>路径，使用批处理（文件位于<code>D:\build.bat</code>）进行自动构建：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">cd D:\A\B</span><br><span class="line">call npm run build</span><br></pre></td></tr></tbody></table></figure><p>运行上面批处理，构建会失败，通常会提示诸如“D:\package.json不存在”的错误，原因是npm命令是批处理程序的当前目录查找package.json文件的，批处理程序的当前目录默认为批处理文件所在的目录，即<code>D:\</code>，<code>D:\package.json</code>不存在，因此构建失败。</p><p>可以使用为<code>cd</code>命令指定<code>/d</code>参数来切换批处理程序的当前目录，上面示例可以修改为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">cd /d D:\A\B</span><br><span class="line">call npm run build</span><br></pre></td></tr></tbody></table></figure><h1 id="5-批处理命令换行"><a href="#5-批处理命令换行" class="headerlink" title="5. 批处理命令换行"></a>5. 批处理命令换行</h1><p>当批处理命令过长，如果都写在一行不便于阅读，可以使用<code>^</code>符号进行分割。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">call "%qt_src_folder%\configure.bat" -silent -debug-and-release -force-debug-info -strip ^</span><br><span class="line">    -platform win32-msvc -static -static-runtime -no-opengl -no-dbus -no-icu ^</span><br><span class="line">    -nomake examples -nomake tests -skip qtwebengine -skip qtlocation ^</span><br><span class="line">    -qt-harfbuzz -qt-freetype -qt-zlib -qt-doubleconversion ^</span><br><span class="line">    -mp -optimize-size -ltcg -no-pch ^</span><br><span class="line">    OPENSSL_LIBS="-lUser32 -lAdvapi32 -lGdi32 -lWS2_32 -lCRYPT32 -llibcrypto32 -llibssl32"</span><br></pre></td></tr></tbody></table></figure><h1 id="6-ECHO-处于关闭状态"><a href="#6-ECHO-处于关闭状态" class="headerlink" title="6. ECHO 处于关闭状态"></a>6. ECHO 处于关闭状态</h1><p>遇到“ECHO 处于关闭状态”提示，通常是因为输出变量为空导致。</p><p>此时需要注意如下情况：</p><ul><li>批处理变量左右不能有空格。如果有空格，空格会被当成变量名，如<code>set a =1</code>，变量名实际为<code>a </code>。</li><li>开启变量延迟扩展后，引用变量需要使用两个<code>!</code>的方式，如<code>!str_a!</code>。</li></ul><h1 id="7-显示选择项提示用户选择"><a href="#7-显示选择项提示用户选择" class="headerlink" title="7. 显示选择项提示用户选择"></a>7. 显示选择项提示用户选择</h1><p>使用<code>CHOICE</code>命令可以提供用户在指定的选项中选择一项，并使用<code>%ERRORLEVEL%</code>获取选择的值。</p><p><code>CHOICE</code>命令语法如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CHOICE [/C choices] [/N] [/CS] [/T timeout /D choice] [/M text]</span><br><span class="line"></span><br><span class="line">描述:</span><br><span class="line">    该工具允许用户从选择列表选择一个项目并返回所选项目的索引。</span><br><span class="line"></span><br><span class="line">参数列表:</span><br><span class="line">   /C    choices       指定要创建的选项列表。默认列表是 "YN"。</span><br><span class="line"></span><br><span class="line">   /N                  在提示符中隐藏选项列表。提示前面的消息得到显示，</span><br><span class="line">                       选项依旧处于启用状态。</span><br><span class="line"></span><br><span class="line">   /CS                 允许选择分大小写的选项。在默认情况下，这个工具</span><br><span class="line">                       是不分大小写的。</span><br><span class="line"></span><br><span class="line">   /T    timeout       做出默认选择之前，暂停的秒数。可接受的值是从 0</span><br><span class="line">                       到 9999。如果指定了 0，就不会有暂停，默认选项</span><br><span class="line">                       会得到选择。</span><br><span class="line"></span><br><span class="line">   /D    choice        在 nnnn 秒之后指定默认选项。字符必须在用 /C 选</span><br><span class="line">                       项指定的一组选择中; 同时，必须用 /T 指定 nnnn。</span><br><span class="line"></span><br><span class="line">   /M    text          指定提示之前要显示的消息。如果没有指定，工具只</span><br><span class="line">                       显示提示。</span><br><span class="line"></span><br><span class="line">   /?                  显示此帮助消息。</span><br><span class="line"></span><br><span class="line">   注意:</span><br><span class="line">   ERRORLEVEL 环境变量被设置为从选择集选择的键索引。列出的第一个选择返回 1，第二个选择返回 2，等等。</span><br><span class="line">   如果用户按的键不是有效的选择，该工具会发出警告响声。如果该工具检测到错误状态，它会返回 255 的ERRORLEVEL 值。</span><br><span class="line">   如果用户按 Ctrl+Break 或 Ctrl+C 键，该工具会返回 0的 ERRORLEVEL 值。</span><br><span class="line">   在一个批程序中使用 ERRORLEVEL 参数时，将参数降序排列。</span><br></pre></td></tr></tbody></table></figure><p>如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHOICE /C YNC /M "确认请按 Y，否请按 N，或者取消请按 C。"</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑩ 编程基础 </category>
          
          <category> 批处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Qt的无边框窗体实现</title>
      <link href="/post/2402568381.html"/>
      <url>/post/2402568381.html</url>
      
        <content type="html"><![CDATA[<p>Qt虽然提供了诸如<code>Qt::FramelessWindowHint</code>之类的属性可以移除窗体的边框，但是移除边框之后，窗体的一些默认行为同时也被移除了，如鼠标拖动改变大小、双击标题栏最大化等，这些行为需要开发者自己来实现。</p><p>本文主要介绍实现无边框窗体的几种方案，并在最后分享了作者实现的方案。</p><p>笔者认为，一个完美的无边框窗体解决方案需要支持如下功能：</p><ol><li>支持通过使用鼠标拖拽来改变窗体位置和大小；</li><li>支持双击标题栏最大化窗体和还原窗体；</li><li>支持<code>Windows Areo Snap</code>特性；</li><li>支持系统阴影；</li><li>支持跨不同DPI的屏幕拖拽；</li><li>适应分辨率和DPI改变；</li></ol><span id="more"></span><p>在Qt中实现无边框窗体有2种方案：</p><h2 id="一、Hook方案"><a href="#一、Hook方案" class="headerlink" title="一、Hook方案"></a>一、Hook方案</h2><p>通过重载<code>nativeEvent</code>函数拦截Windows消息（如<code>WM_NCHITTEST</code>）来实现，大致步骤如下：</p><ol><li>给窗体设置<code>WS_THICKFRAME | WS_CAPTION</code>属性从而还原窗体边框和标题栏，这样窗体就可以接收到<code>WM_NCHITTEST</code>消息。</li><li>在<code>WM_NCCALCSIZE</code>消息处理中再移除边框和标题栏。</li><li>在<code>WM_NCHITTEST</code>消息处理中通过判断鼠标位置来设置鼠标行为（<code>HTLEFT</code>, <code>HTRIGHT</code>等）。</li></ol><p>这种方案的优点是可以支持<code>Windows Areo Snap</code>和<code>系统阴影</code>的特性，但是针对Windows消息处理起来很复杂而且需要兼容Qt的各个版本，目前我还没有找到一个通过这种方案来完美实现无边框的解决方案。</p><p>据我所知，有如下的开源项目是通过这种方式来实现的，但都有些许问题，如不支持跨不同DPI屏幕拖拽、不能适应分辨率和DPI改变、<code>WM_NCHITTEST</code>有时无响应等。另外，在设置了背景透明属性之后（如<code>Qt::WA_TranslucentBackground</code>），系统阴影特性也将消失。</p><ul><li>qtdevs/FramelessHelper: <a href="https://github.com/qtdevs/FramelessHelper">https://github.com/qtdevs/FramelessHelper</a></li><li>wangwenx190/framelesshelper: <a href="https://github.com/wangwenx190/framelesshelper">https://github.com/wangwenx190/framelesshelper</a></li></ul><h2 id="二、纯Qt方案"><a href="#二、纯Qt方案" class="headerlink" title="二、纯Qt方案"></a>二、纯Qt方案</h2><p>这种方案不Hook windows的 <code>WM_NCHITTEST</code>、<code>WM_NCCALCSIZE</code>消息，也不改变窗体样式，通过纯Qt方式实现。通过对每个Widget设置<code>MouseTracking</code>，来使每个Widget都可以响应鼠标事件（mouseMoveEvent、mousePressEvent、mouseReleaseEvent等），然后这些事件中判断鼠标位置来设置鼠标的形状和行为。</p><p>这种方式虽然对鼠标位置的判断逻辑比较繁琐，但兼容性较好，较纯粹，不需要处理Windows的各个消息。</p><h2 id="三、Qt-FramelessWindow"><a href="#三、Qt-FramelessWindow" class="headerlink" title="三、Qt-FramelessWindow"></a>三、Qt-FramelessWindow</h2><p>👉 我根倾向于使用纯Qt方案，简单、稳定、兼容性好，不用关注那些烦人的Windows消息。针对该方案的实现，可以参考笔者的开源项目<a href="https://github.com/winsoft666/Qt-FramelessWindow">【Qt-FramelessWindow】</a>，目前可以支持上述除<code>“Windows Areo Snap”和“系统阴影”</code>特性之外的所有无边框窗体的特性，而且仅有一个头文件，使用起来也非常方便。</p><ul><li>Qt-FramelessWindow: <a href="https://github.com/winsoft666/Qt-FramelessWindow">https://github.com/winsoft666/Qt-FramelessWindow</a></li></ul><p><img src="https://blog-static.jiangxueqiao.com/blog/img/frameless.gif"></p>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo搭建静态博客</title>
      <link href="/post/2737986840.html"/>
      <url>/post/2737986840.html</url>
      
        <content type="html"><![CDATA[<p>Hexo是一个快速、简洁且高效的博客框架，使用Hexo可以快速地生成静态博客框架。在框架生成完成后，可以使用任意文本编辑器语法书写博客。我们可以使用Markdown语法书写博客，Hexo在生成博客时会自动将Markdown解析成Html静态页面。</p><blockquote><p>Hexo官网：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a><br>Hexo中文文档：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p></blockquote><h1 id="一、玩法说明"><a href="#一、玩法说明" class="headerlink" title="一、玩法说明"></a>一、玩法说明</h1><p>使用Hexo写博客的大致流程如下：</p><ol><li>生成博客框架</li><li>配置博客</li><li>选择自己喜欢的主题</li><li>配置博客和主题</li><li>写文章</li><li>生成博客</li><li>发布博客到服务器</li></ol><p>其中，<code>第1~4步</code>为前置操作，只需要执行一次。</p><p>Hexo只负责生成静态的HTML文件，不提供服务器。如需对外发布博客，我们还需将HTML文件部署到服务器上，可以选择如下的方式：</p><ul><li>Github Pages、GitLab Pages，免费，访问速度较慢。</li><li>Gitee Pages，收费。</li><li>对象存储服务，如阿里云OSS、腾讯云COS、七牛云OSS等。当访问量大时，需搭配CDN使用，避免因数据回源产生巨额流量费用。</li><li>自己购买服务器使用Nginx搭建Web服务器。当访问量大时，服务器出口带宽要求较高，此时仍然需要搭配对象存储服务和CDN使用。<span id="more"></span></li></ul><h1 id="二、生成博客框架"><a href="#二、生成博客框架" class="headerlink" title="二、生成博客框架"></a>二、生成博客框架</h1><h2 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h2><p>在搭建博客框架之前，确保电脑上已经安装如下软件（建议安装最新版本的Node.js，这样可以确保兼容最新版本的Hexo）：</p><ul><li>Node.js</li><li>Git</li></ul><h2 id="2-2-安装Hexo"><a href="#2-2-安装Hexo" class="headerlink" title="2.2 安装Hexo"></a>2.2 安装Hexo</h2><p>在所有必备的应用程序安装完成后，即可使用 npm 全局安装 Hexo工具：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-生成博客框架"><a href="#2-3-生成博客框架" class="headerlink" title="2.3 生成博客框架"></a>2.3 生成博客框架</h2><p>安装 Hexo 完成后，在指定文件夹下执行如下命令，Hexo 将会在<folder>目录下新建博客所需的文件：</folder></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></tbody></table></figure><blockquote><p>如果遇到网络错误等问题，请排除是否因为访问国外域名失败导致，可以尝试将npm源切换到国内，参考： <a href="/post/908211703.html" title="NPM和Yarn设置国内源">NPM和Yarn设置国内源</a></p></blockquote><p>新建完成后，指定文件夹的目录大致如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></tbody></table></figure><ul><li><p>_config.yml</p><p>网站的配置文件，可以在此配置大部分的参数，需要区别于主题的_config.yml配置文件。</p></li><li><p>package.json</p><p>应用程序的信息。</p></li><li><p>scaffolds</p><p>模版文件夹。当新建文章时，Hexo会根据scaffold来创建文件。<br>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果修改 scaffold/post.md 中的 Front-matter （即两个<code>---</code>中间的内容）内容，那么每次新建一篇文章时都会包含这个修改。</p></li><li><p>source</p><p>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件/文件夹和隐藏的文件将会被忽略。在生成博客时，Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被直接拷贝过去。</p></li><li><p>themes</p><p>主题文件夹。将下载的主题文件放置到该目录，Hexo 会根据主题来生成静态页面。</p></li></ul><h1 id="三、配置博客"><a href="#三、配置博客" class="headerlink" title="三、配置博客"></a>三、配置博客</h1><p><strong>Hexo的配置分别站点配置和主题配置，站点配置文件为博客根目录下的_config.yml文件，主题配置文件为位于<code>themes\&lt;主题目录&gt;</code>中的_config.yml文件。</strong></p><h2 id="3-1-站点配置"><a href="#3-1-站点配置" class="headerlink" title="3.1 站点配置"></a>3.1 站点配置</h2><p>本节介绍博客的站点配置，部分配置的含义如下：</p><ul><li>title网站标题</li><li>subtitle网站副标题</li><li>description网站描述，主要用于SEO</li><li>keywords网站的关键词。支持多个关键词。</li><li>author 作者名字</li><li>language网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。</li><li>timezone网站时区。对于中国大陆地区可以使用 Asia/Shanghai。</li><li>theme当前主题名称，名称为themes目录中的子目录名称。值为false时禁用主题。</li><li>per_page每页显示的文章量 (0 = 关闭分页功能)。</li><li>pagination_dir指定博客生成后，每页的index.html文件存放目录。</li></ul><h2 id="3-2-利用Hexo-abbrlink插件生成唯一文章链接"><a href="#3-2-利用Hexo-abbrlink插件生成唯一文章链接" class="headerlink" title="3.2 利用Hexo-abbrlink插件生成唯一文章链接"></a>3.2 利用Hexo-abbrlink插件生成唯一文章链接</h2><p>Hexo在生成博客文章链接时，默认是按照<code>年/月/日/标题</code>格式来生成的，可以在站点配置文件中指定new_post_name的值，默认是:year/:month/:day/:title这样的格式。如果你的标题是中文的话，你的URL链接还会包含中文。而且当我们修改原文章的日期或标题后，之前生成的链接将会失效。</p><p>为了给每一篇文章指定一个唯一的不含中文的链接，可以利用hexo-abbrlink插件，来解决这个问题。</p><p>先安装下hexo-abbrlink：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></tbody></table></figure><p>修改站点配置文件(_config.yml)：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">post/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></tbody></table></figure><p>生成完后原文章.md文件的Front-matter 内会增加abbrlink字段，值为生成的ID。这个字段确保了在我们修改了Front-matter内的title或date字段之后链接地址不会改变。换句话说，就是本篇文章有了自己的专属链接。</p><p>当然，也可以选择不同的算法和进制：</p><ul><li><p>crc16 &amp; hex</p><p><a href="https://post.zz173.com/posts/66c8.html">https://post.zz173.com/posts/66c8.html</a></p></li><li><p>crc16 &amp; dec</p><p><a href="https://post.zz173.com/posts/65535.html">https://post.zz173.com/posts/65535.html</a></p></li><li><p>crc32 &amp; hex</p><p><a href="https://post.zz173.com/posts/8ddf18fb.html">https://post.zz173.com/posts/8ddf18fb.html</a></p></li><li><p>crc32 &amp; dec</p><p><a href="https://post.zz173.com/posts/1690090958.html">https://post.zz173.com/posts/1690090958.html</a></p></li></ul><p>注意，配置完成之后，之前的文章的链接有可能会变成了undefined，需要执行<code>hexo clean</code>并重新生成部署。</p><h1 id="四、配置主题"><a href="#四、配置主题" class="headerlink" title="四、配置主题"></a>四、配置主题</h1><p>每个主题的配置内容都不一样，具体参考使用主题的帮助文档。我使用的是<a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a>主题。</p><h2 id="4-1-推荐主题"><a href="#4-1-推荐主题" class="headerlink" title="4.1 推荐主题"></a>4.1 推荐主题</h2><ul><li><a href="https://github.com/aircloud/hexo-theme-aircloud">hexo-theme-aircloud</a></li><li><a href="https://github.com/jackhanyuan/hexo-theme-new-yilia">hexo-theme-new-yilia</a></li><li><a href="https://github.com/yanm1ng/hexo-theme-vexo">hexo-theme-vexo</a></li><li><a href="https://github.com/next-theme/hexo-theme-next">hexo-theme-next</a></li><li><a href="https://github.com/jerryc127/hexo-theme-butterfly">hexo-theme-butterfly</a></li><li><a href="https://github.com/volantis-x/hexo-theme-volantis">hexo-theme-volantis</a></li><li><a href="https://github.com/ppoffice/hexo-theme-icarus">hexo-theme-icarus</a></li></ul><p>可以在Github中搜索<code>Hexo Theme</code>发现更多主题。</p><h1 id="五、写文章"><a href="#五、写文章" class="headerlink" title="五、写文章"></a>五、写文章</h1><h2 id="5-1-生成文章"><a href="#5-1-生成文章" class="headerlink" title="5.1 生成文章"></a>5.1 生成文章</h2><p>使用如下命令生成新的文章:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &lt;文章标题&gt;</span><br></pre></td></tr></tbody></table></figure><p>执行上述命令后，会在source_posts目录下生成对应的.md文件，文件内容如下：</p><h2 id="5-2-Front-matter"><a href="#5-2-Front-matter" class="headerlink" title="5.2 Front-matter"></a>5.2 Front-matter</h2><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量。Hexo预定义了一些变量，同时每个主题也会定义一些变量。</p><h3 id="5-2-1-Hexo预定义变量"><a href="#5-2-1-Hexo预定义变量" class="headerlink" title="5.2.1 Hexo预定义变量"></a>5.2.1 Hexo预定义变量</h3><ul><li>title标题，默认为文章的文件名</li><li>date建立日期，默认为文件建立日期</li><li>updated更新日期，默认文件更新日期</li><li>comments是否开启文章的评论功能，true/false.</li><li>tags标签（不适用于分页），支持多个。</li><li>categories分类（不适用于分页），支持多个。</li><li>permalink覆盖文章的永久链接，永久链接应该以/或.html结尾。</li><li>keywords: 文章关键字，用于SEO。</li></ul><p>如：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">从汇编的角度分析函数调用过程</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">C++</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">汇编</span></span><br><span class="line"><span class="attr">abbrlink:</span> <span class="number">4168021185</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-01-21 15:53:01</span></span><br><span class="line"><span class="attr">updated:</span> <span class="number">2023-01-21 15:53:01</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">函数</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">C++</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">汇编</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">C++</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">传参形式</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-2-hexo-theme-matery主题定义变量"><a href="#5-2-2-hexo-theme-matery主题定义变量" class="headerlink" title="5.2.2 hexo-theme-matery主题定义变量"></a>5.2.2 hexo-theme-matery主题定义变量</h3><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果<code>hide</code>值为<code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">typora-vue-theme主题介绍</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-09-07 09:25:00</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></tbody></table></figure><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">typora-vue-theme主题介绍</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-09-07 09:25:00</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">赵奇</span></span><br><span class="line"><span class="attr">img:</span> <span class="string">/source/images/xxx.jpg</span></span><br><span class="line"><span class="attr">top:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">hide:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">cover:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">coverImg:</span> <span class="string">/images/1.jpg</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">summary:</span> <span class="string">这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Markdown</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Typora</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Markdown</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></tbody></table></figure><h2 id="5-3-引用站内文章"><a href="#5-3-引用站内文章" class="headerlink" title="5.3 引用站内文章"></a>5.3 引用站内文章</h2><p>语法如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{% post_link slug [title] %}</span><br></pre></td></tr></tbody></table></figure><p>其中，slug 表示 _post 目录下的 Markdown 文件名。可以通过 title 指定链接标题。</p><h2 id="5-4-按钮"><a href="#5-4-按钮" class="headerlink" title="5.4 按钮"></a>5.4 按钮</h2><p>语法如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{% button /path/to/url/, text, icon [class], [alt] %}</span><br></pre></td></tr></tbody></table></figure><p>如：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{% button https://jiangxueqiao.com, 江雪桥的博客, home fa-fw fa-lg, 江雪桥 %}</span><br></pre></td></tr></tbody></table></figure><h2 id="5-5-插入图片"><a href="#5-5-插入图片" class="headerlink" title="5.5 插入图片"></a>5.5 插入图片</h2><p>Markdown 并不会保存插入的图片资源本身，只是记录了获取资源的链接。因此我们需要选择一款合适的图床来支持博客写作，目前各大云服务商都提供了对象存储服务，如七牛云 KODO、又拍云 USS、腾讯云 COS、阿里云 OSS 等。</p><p>可以使用<a href="https://github.com/Molunerfinn/PicGo">PicGo</a>工具上传图片到图床上。</p><h2 id="5-6-支持emoji表情"><a href="#5-6-支持emoji表情" class="headerlink" title="5.6 支持emoji表情"></a>5.6 支持emoji表情</h2><p>Hexo默认的 Markdown 渲染器是 hexo-renderer-marked，这个渲染器不支持 emoji 表情。可以利用 hexo-filter-github-emojis插件实现支持 emoji 表情。</p><p>安装插件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-github-emojis --save</span><br></pre></td></tr></tbody></table></figure><p>修改站点配置文件（_config.yml）添加如下配置：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">githubEmojis:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">className:</span> <span class="string">github-emoji</span></span><br><span class="line">  <span class="attr">inject:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">styles:</span></span><br><span class="line">  <span class="attr">customEmojis:</span></span><br></pre></td></tr></tbody></table></figure><p>在<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">emoji-cheat-sheet</a>中找到想要的表情，粘贴到文章中即可。</p><h1 id="五、发布"><a href="#五、发布" class="headerlink" title="五、发布"></a>五、发布</h1><p>使用如下命令生成静态HTML文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></tbody></table></figure><p>生成的HTML文件位于博客根目录的public中，将该目录部署中的所有文件部署到服务器即可。</p>]]></content>
      
      
      <categories>
          
          <category> ⑮ 爱折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis慢日志与BigKey</title>
      <link href="/post/851648499.html"/>
      <url>/post/851648499.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-static.jiangxueqiao.com/blog/img/redis.jpg"></p><h2 id="1-慢日志设置"><a href="#1-慢日志设置" class="headerlink" title="1. 慢日志设置"></a>1. 慢日志设置</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当命令耗时超过5毫秒时，记录慢日志</span></span><br><span class="line">CONFIG SET slowlog-log-slower-than 5000</span><br><span class="line"><span class="comment"># 只保留最近500条慢日志</span></span><br><span class="line">CONFIG SET slowlog-max-len 500</span><br></pre></td></tr></tbody></table></figure><h2 id="2-查看慢日志"><a href="#2-查看慢日志" class="headerlink" title="2. 查看慢日志"></a>2. 查看慢日志</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLOWLOG get 5</span><br><span class="line">1) 1) (<span class="built_in">integer</span>) 32693       <span class="comment"># 慢日志ID</span></span><br><span class="line">   2) (<span class="built_in">integer</span>) 1593763337  <span class="comment"># 执行时间戳</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 5299        <span class="comment"># 执行耗时(微秒)</span></span><br><span class="line">   4) 1) <span class="string">"LRANGE"</span>           <span class="comment"># 具体执行的命令和参数</span></span><br><span class="line">      2) <span class="string">"user_list:2000"</span></span><br><span class="line">      3) <span class="string">"0"</span></span><br><span class="line">      4) <span class="string">"-1"</span></span><br><span class="line">2) 1) (<span class="built_in">integer</span>) 32692</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1593763337</span><br><span class="line">   3) (<span class="built_in">integer</span>) 5044</span><br><span class="line">   4) 1) <span class="string">"GET"</span></span><br><span class="line">      2) <span class="string">"user_info:1000"</span></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h1 id="3-BigKey"><a href="#3-BigKey" class="headerlink" title="3. BigKey"></a>3. BigKey</h1><p>如果查询慢日志发现，并不是复杂度过高的命令导致的，而都是 SET / DEL 这种简单命令出现在慢日志中，此时需要考虑实例否写入了 BigKey。</p><p>BigKey 俗称“大 key”，Redis 是 key-value 的存储方式，当一个 Key 所对应的存储数值过长时，就会出现大 key 的情况。</p><p>Redis 在写入数据时，需要为新的数据分配内存，相对应的当从 Redis 中删除数据时，也会释放对应的内存空间。BigKey 会导致分配和释放内存的耗时都比较长。</p><p>可以使用下面命令扫描 Redis 中的 BigKey：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h 127.0.0.1 -p 6379 --bigkeys -i 0.01</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">-------- summary -------</span><br><span class="line"></span><br><span class="line">Sampled 829675 keys <span class="keyword">in</span> the keyspace!</span><br><span class="line">Total key length <span class="keyword">in</span> bytes is 10059825 (avg len 12.13)</span><br><span class="line"></span><br><span class="line">Biggest string found <span class="string">'key:291880'</span> has 10 bytes</span><br><span class="line">Biggest   list found <span class="string">'mylist:004'</span> has 40 items</span><br><span class="line">Biggest    <span class="built_in">set</span> found <span class="string">'myset:2386'</span> has 38 members</span><br><span class="line">Biggest   <span class="built_in">hash</span> found <span class="string">'myhash:3574'</span> has 37 fields</span><br><span class="line">Biggest   zset found <span class="string">'myzset:2704'</span> has 42 members</span><br><span class="line"></span><br><span class="line">36313 strings with 363130 bytes (04.38% of keys, avg size 10.00)</span><br><span class="line">787393 lists with 896540 items (94.90% of keys, avg size 1.14)</span><br><span class="line">1994 sets with 40052 members (00.24% of keys, avg size 20.09)</span><br><span class="line">1990 hashs with 39632 fields (00.24% of keys, avg size 19.92)</span><br><span class="line">1985 zsets with 39750 members (00.24% of keys, avg size 20.03)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>对线上实例进行 bigkey 扫描时，Redis 的 OPS 会突增，为了降低扫描过程中对 Redis 的影响，需要控制扫描的频率，指定 -i 参数即可，它表示扫描过程中每次扫描后休息的时间间隔，单位是秒。</strong></p>]]></content>
      
      
      <categories>
          
          <category> ⑥ 服务器开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Watchtower自动更新Docker</title>
      <link href="/post/1404510687.html"/>
      <url>/post/1404510687.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-static.jiangxueqiao.com/blog/img/logo-450px.png"></p><p>Watch­tower 官网: <a href="https://github.com/containrrr/watchtower">https://github.com/containrrr/watchtower</a></p><p>Watch­tower 可以用于自动更新 Docker 镜像与容器。Watch­tower 会监视正在运行的容器以及相关的镜像，当检测到 Reg­istry 中的镜像与本地的镜像有差异时，会拉取最新镜像并使用最初部署时相同的参数重新启动相应的容器。</p><span id="more"></span><h2 id="1-安装运行"><a href="#1-安装运行" class="headerlink" title="1. 安装运行"></a>1. 安装运行</h2><p>Watch­tower 本身被打包为 Docker 镜像，因此可以像运行其他容器一样运行它：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --name watchtower \</span><br><span class="line">    --restart unless-stopped \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">    containrrr/watchtower \</span><br><span class="line">    --cleanup \</span><br><span class="line">    --interval 60</span><br></pre></td></tr></tbody></table></figure><p>运行 Watch­tower 后，所有容器都会自动更新，也包括 Watch­tower 本身。</p><p>默认情况下 Watch­tower 每 5 分钟会轮询一次，可以使用<code>--interval</code>参数指定（单位秒）。</p><p><strong>查看帮助文档：</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> containrrr/watchtower -h</span><br></pre></td></tr></tbody></table></figure><h2 id="2-手动更新"><a href="#2-手动更新" class="headerlink" title="2. 手动更新"></a>2. 手动更新</h2><p>前面的使用方式是让 Watch­tower 以 detached（后台）模式在运行并自动更新容器，而 Watch­tower 也支持以 foreground（前台）模式来使用，即运行一次退出并删掉容器，来实现手动更新容器。这对于偶尔更新一次那些不在自动更新列表中的容器非常有用。</p><p>对于 foreground 模式，需要加上<code> --run-once</code> （<code>--run-once</code> 可以简写为 <code>-R</code>）这个专用的选项。下面的例子 Docker 会运行一次 Watch­tower 并检查 aria2-pro 容器的基础镜像更新，最后删掉本次运行创建的 Watch­tower 容器。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">    containrrr/watchtower --cleanup \</span><br><span class="line">    --run-once \</span><br><span class="line">    aria2-pro</span><br></pre></td></tr></tbody></table></figure><h2 id="3-更新私有镜像"><a href="#3-更新私有镜像" class="headerlink" title="3. 更新私有镜像"></a>3. 更新私有镜像</h2><p>如果是从私有 Docker 仓库获取镜像，则需提供身份验证凭据和环境变量 REPO_USER 和 REPO_PASS，或者通过将宿主机的 docker 配置文件挂载到容器的根目录下。</p><p>通过添加环境变量的方式：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">   --name watchtower \</span><br><span class="line">   -e REPO_USER=username \</span><br><span class="line">   -e REPO_PASS=password \</span><br><span class="line">   -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">       containrrr/watchtower container_to_watch --debug</span><br></pre></td></tr></tbody></table></figure><p>通过挂载宿主机 docker 配置文件的方式：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --name watchtower \</span><br><span class="line">    -v /home/&lt;user&gt;/.docker/config.json:/config.json \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">        containrrr/watchtower container_to_watch --debug</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑥ 服务器开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Watch­tower </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis常见异常及处理方案</title>
      <link href="/post/44844734.html"/>
      <url>/post/44844734.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-static.jiangxueqiao.com/blog/img/redis.jpg"></p><h2 id="1-缓存雪崩"><a href="#1-缓存雪崩" class="headerlink" title="1. 缓存雪崩"></a>1. 缓存雪崩</h2><p>在短时间内本应交由 Redis 处理的大量请求，都发送到了数据库进行处理，从而导致对数据库的压力迅速增大，严重时数据库可能崩溃，从而导致整个系统崩溃，就像雪崩一样，引发连锁效应，所以叫缓存雪崩。</p><p>出现上述情况的常见原因主要有以下两点：</p><ul><li>大量缓存数据同时过期，导致本应请求到缓存的需重新从数据库中获取数据。</li><li>redis 本身出现故障，无法处理请求，那自然会再请求到数据库那里。</li></ul><p><strong>针对大量缓存数据同时过期的情况：</strong></p><ul><li>实际设置过期时间时，应当尽量避免大量 key 同时过期的场景，如果真的有，那就通过<strong>随机、微调、均匀设置</strong>等方式设置过期时间，从而避免同一时间过期。</li><li>添加互斥锁，使得构建缓存的操作不会在同一时间进行。</li><li>双 key 策略，主 key 是原始缓存，备 key 为拷贝缓存，主 key 失效时，可以访问备 key，主 key 缓存失效时间设置为短期，备 key 设置为长期。</li><li>后台更新缓存策略，采用定时任务或者消息队列的方式进行 redis 缓存更新或移除等。</li></ul><p><strong>针对 Redis 本身出现故障的情况：</strong></p><ul><li>在预防层面，可以通过主从节点的方式构建高可用的集群，也就是实现主 Redis 实例挂掉后，能有其他从库快速切换为主库，继续提供服务。</li><li>如果事情已经发生了，那就要为了防止数据库被大量的请求搞崩溃，可以采用<strong>服务熔断或者请求限流</strong>的方法。当然服务熔断相对粗暴一些，停止服务直到 redis 服务恢复，请求限流相对温和一些，保证一些请求可以处理，不是一刀切，不过还是看具体业务情况选择合适的处理方案。</li></ul><span id="more"></span><h2 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2. 缓存击穿"></a>2. 缓存击穿</h2><p>缓存击穿一般出现在高并发系统中，是大量用户同时并发请求缓存中没有但数据库中有的数据，也就是同时读 Redis 缓存，但缓存中没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/redis-hcjc.png"></p><p>和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><p>出现这种情况一般因为某个热点数据缓存过期，由于是热点数据，请求并发量大，所以过期的时候还是会有大量请求同时过来，来不及更新缓存就全部打到数据库了。</p><p>针对这种情况有两种常见的处理方案：</p><ul><li>简单粗暴的对热点数据不设置过期时间，这样不会过期，自然也就不会出现上述情况了，如果后续想清理，可以通过后台进行清理。</li><li>添加互斥锁，即当过期之后，除了请求过来的第一个查询的请求可以获取到锁请求到数据库，并再次更新到缓存中，其他的会被阻塞住，直到锁被释放，同时新的缓存也被更新上去了，后续请求又会请求到缓存上，这样就不会出现缓存击穿了。</li></ul><h2 id="3-缓存穿透"><a href="#3-缓存穿透" class="headerlink" title="3. 缓存穿透"></a>3. 缓存穿透</h2><p>缓存穿透是指数据既不在 Redis 中，也不在数据库中，这样就导致每次请求过来的时候，在缓存中找不到对应 key 之后，每次都还要去数据库再查询一遍，发现数据库也没有，相当于进行了两次无用的查询。</p><p>这样请求就可以绕过缓存直接查数据库，如果这个时候有人想恶意攻击系统，就可以故意使用空值或者其他不存在的值进行频繁请求，那么就会对数据库造成比较大的压力。</p><p>针对缓存穿透，一般有以下三种处理方案：</p><ul><li><p>非法请求的限制，主要是指参数校验、鉴权校验等，从而一开始就把大量的非法请求拦截在外，这在实际业务开发中是必要的手段。</p></li><li><p>缓存空值或者默认值，如果从缓存取不到的数据，在数据库中也没有取到，那我们仍然把这个空结果进行缓存，同时设置一个较短的过期时间。通过这个设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库，可以防止有大量恶意请求是反复用同一个 key 进行攻击。</p></li><li><p>使用布隆过滤器快速判断数据是否存在。</p><p>那什么是布隆过滤器呢，简单来说，就是可以引入了多个相互独立的哈希函数，保证在给定的空间和误判率下，完成元素判重。因为我们知道，存在 hash 碰撞这样一种情况，那如果只使用一个 hash 函数，则碰撞冲突的概率明显会变大，那为了减少这种冲突，我们可以多引入几个 hash 函数，而布隆过滤器算法的核心思想就是利用多个不同的 hash 函数来解决这样一种冲突。它的优点是空间效率高，查询时间短，远超其他算法，而它的缺点就是会存在一定的误识别率，它不能完全保证请求过来的 key 通过布隆过滤器的校验就一定有这个数据，毕竟理论上还是会存在冲突情况，无论概率多小。但是，只要没有通过布隆过滤器的校验，那么这个 key 就一定不存在，只要利用这一点其实就已经可以过滤掉大部分不存在的 key 的请求了，在正常场景下已然足够了。</p></li></ul><h2 id="4-缓存预热"><a href="#4-缓存预热" class="headerlink" title="4. 缓存预热"></a>4. 缓存预热</h2><p>缓存预热就是系统上线前后，将相关的缓存数据直接加载到缓存系统中去，而不依赖用户触发请求时才加入。这样就可以避免在用户请求的时候，先查询数据库再将数据缓存的问题。用户直接查询事先被预热的缓存数据，这样可以避免那么系统上线初期，对于高并发的流量，都会访问到数据库中，对数据库造成流量的压力。</p><p>根据数据不同量级，可以有以下几种做法：</p><ul><li>数据量不大：项目启动的时候自动进行加载。</li><li>数据量较大：后台定时刷新缓存。</li><li>数据量极大：只针对热点数据进行预加载缓存操作。</li></ul><h2 id="5-缓存降级"><a href="#5-缓存降级" class="headerlink" title="5. 缓存降级"></a>5. 缓存降级</h2><p>当缓存失效或缓存服务出现故障时，我们为了防止数据库发生雪崩而不去访问数据库，但此时仍然想要保证服务的主体功能是基本可用的。因此对于不重要的缓存数据，我们可以采取服务降级策略。</p><p>一般做法有以下两种：</p><ul><li>直接访问内存部分的数据缓存。</li><li>直接返回系统设置的默认值。</li></ul>]]></content>
      
      
      <categories>
          
          <category> ⑥ 服务器开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows平台文件自签名</title>
      <link href="/post/667140500.html"/>
      <url>/post/667140500.html</url>
      
        <content type="html"><![CDATA[<p>本文使用的工具都是 Windows SDK 自带的，可以采用单独安装 <a href="https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/">Windows SDK</a>的方式，也可以通过安装 Visual Studio 来附带安装 Windows SDK。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 在弹出界面设置密码123456</span><br><span class="line">makecert.exe -sv test.pvk -r -n "CN=test.com" test.cer</span><br><span class="line"></span><br><span class="line">cert2spc.exe test.cer test.spc</span><br><span class="line"></span><br><span class="line">pvk2pfx.exe -pvk test.pvk -pi 123456 -spc test.spc -pfx test.pfx -f</span><br></pre></td></tr></tbody></table></figure><p>使用 SignTool 工具对 EXE 文件签名：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signtool.exe sign /f test.pfx /p 123456 Setup.exe</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows音频环回录制</title>
      <link href="/post/2236960039.html"/>
      <url>/post/2236960039.html</url>
      
        <content type="html"><![CDATA[<p>所谓音频环回录制就是录制扬声器播放的声音。播放到扬声器的声音已经过混合，Windows 提供了 WASAPI 来获取这种混合的音频信号。</p><p>本文将录制到原始音频样本数据写入到文件，可以使用<a href="https://www.audacityteam.org/">Audacity</a>导入原始数据试听。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-audio-loopback-2.png"></p><span id="more"></span><p>在 Audacity 中导入原始数据时需要选择正确的音频参数，否则会导致无法播放。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-audio-loopback-1.png"></p><h1 id="初始化设备"><a href="#初始化设备" class="headerlink" title="初始化设备"></a>初始化设备</h1><p>声明相关变量：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMMDeviceEnumerator* pDeviceEnum = <span class="literal">NULL</span>;</span><br><span class="line">IMMDevice* pDevice = <span class="literal">NULL</span>;</span><br><span class="line">IAudioClient* pAudioClient = <span class="literal">NULL</span>;</span><br><span class="line">WAVEFORMATEX* pWaveFormat = <span class="literal">NULL</span>;</span><br><span class="line">IAudioCaptureClient* pAudioCaptureClient = <span class="literal">NULL</span>;</span><br></pre></td></tr></tbody></table></figure><p>获取默认音频输出设备并初始化环回录制服务：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">InitRecord</span><span class="params">()</span> </span>{</span><br><span class="line">    HRESULT hr;</span><br><span class="line"></span><br><span class="line">    hr = <span class="built_in">CoCreateInstance</span>(CLSID_MMDeviceEnumerator, <span class="literal">NULL</span>, CLSCTX_ALL, IID_IMMDeviceEnumerator, (<span class="type">void</span>**)&amp;pDeviceEnum);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Create device enumerator failed, hr: 0x%x"</span>, hr);</span><br><span class="line">        <span class="keyword">return</span> hr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    hr = pDeviceEnum-&gt;<span class="built_in">GetDefaultAudioEndpoint</span>(eRender, eConsole, &amp;pDevice);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Get default audio device failed, hr: 0x%x"</span>, hr);</span><br><span class="line">        <span class="keyword">return</span> hr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    hr = pDevice-&gt;<span class="built_in">Activate</span>(IID_IAudioClient, CLSCTX_ALL, <span class="literal">NULL</span>, (<span class="type">void</span>**)&amp;pAudioClient);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Create audio client failed, hr: 0x%x"</span>, hr);</span><br><span class="line">        <span class="keyword">return</span> hr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    hr = pAudioClient-&gt;<span class="built_in">GetMixFormat</span>(&amp;pWaveFormat);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Get mix format failed, hr: 0x%x"</span>, hr);</span><br><span class="line">        <span class="keyword">return</span> hr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Channel: %d, SamplesPerSec: %d, BitsPerSample: %d\n"</span>, pWaveFormat-&gt;nChannels, pWaveFormat-&gt;nSamplesPerSec, pWaveFormat-&gt;wBitsPerSample);</span><br><span class="line"></span><br><span class="line">    hr = pAudioClient-&gt;<span class="built_in">Initialize</span>(AUDCLNT_SHAREMODE_SHARED, AUDCLNT_STREAMFLAGS_LOOPBACK, BUFFER_TIME_100NS, <span class="number">0</span>, pWaveFormat, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) {</span><br><span class="line">        <span class="comment">// 兼容Nahimic音频驱动</span></span><br><span class="line">        <span class="comment">// https://github.com/rainmeter/rainmeter/commit/0a3dfa35357270512ec4a3c722674b67bff541d6</span></span><br><span class="line">        <span class="comment">// https://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/bd8cd9f2-974f-4a9f-8e9c-e83001819942/iaudioclient-initialize-failure</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化失败，尝试使用立体声格式进行初始化</span></span><br><span class="line">        pWaveFormat-&gt;nChannels = <span class="number">2</span>;</span><br><span class="line">        pWaveFormat-&gt;nBlockAlign = (<span class="number">2</span> * pWaveFormat-&gt;wBitsPerSample) / <span class="number">8</span>;</span><br><span class="line">        pWaveFormat-&gt;nAvgBytesPerSec = pWaveFormat-&gt;nSamplesPerSec * pWaveFormat-&gt;nBlockAlign;</span><br><span class="line"></span><br><span class="line">        hr = pAudioClient-&gt;<span class="built_in">Initialize</span>(AUDCLNT_SHAREMODE_SHARED, AUDCLNT_STREAMFLAGS_LOOPBACK, BUFFER_TIME_100NS, <span class="number">0</span>, pWaveFormat, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Initialize audio client failed, hr: 0x%x"</span>, hr);</span><br><span class="line">            <span class="keyword">return</span> hr;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    hr = pAudioClient-&gt;<span class="built_in">GetService</span>(IID_IAudioCaptureClient, (<span class="type">void</span>**)&amp;pAudioCaptureClient);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Get audio capture client failed, hr: 0x%x"</span>, hr);</span><br><span class="line">        <span class="keyword">return</span> hr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h1><p>在初始化成功后，开启独立线程按固定间隔获取缓冲区中的音频样本。<code>exitFlag</code>用于控制线程是否退出。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueryAudioSampleThread</span><span class="params">()</span> </span>{</span><br><span class="line">    UINT32 bufferFrameCount = <span class="number">0</span>;</span><br><span class="line">    HRESULT hr = pAudioClient-&gt;<span class="built_in">GetBufferSize</span>(&amp;bufferFrameCount);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Get buffer frame count failed, hr: 0x%x"</span>, hr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据实际缓冲区中的样本数计算实际填满缓冲区需要的时间</span></span><br><span class="line">    REFERENCE_TIME  hnsActualDuration = (<span class="type">double</span>)BUFFER_TIME_100NS *</span><br><span class="line">        bufferFrameCount / pWaveFormat-&gt;nSamplesPerSec;</span><br><span class="line"></span><br><span class="line">    UINT32 packetLength = <span class="number">0</span>;</span><br><span class="line">    BYTE* buffer = <span class="literal">NULL</span>;</span><br><span class="line">    UINT32 numFramesAvailable = <span class="number">0</span>;</span><br><span class="line">    DWORD flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!exitFlag.<span class="built_in">load</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 等待半个缓冲周期</span></span><br><span class="line">        <span class="built_in">Sleep</span>(hnsActualDuration / <span class="number">10000</span> / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        hr = pAudioCaptureClient-&gt;<span class="built_in">GetNextPacketSize</span>(&amp;packetLength);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Get next package size failed, hr: 0x%x"</span>, hr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (packetLength &gt; <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            hr = pAudioCaptureClient-&gt;<span class="built_in">GetBuffer</span>(&amp;buffer, &amp;numFramesAvailable, &amp;flags, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Get capture buffer failed, hr: 0x%x"</span>, hr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将捕获到的样本写入文件</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">WriteSample</span>(buffer, numFramesAvailable * pWaveFormat-&gt;nChannels * pWaveFormat-&gt;wBitsPerSample / <span class="number">8</span>)) {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Write sample to file failed"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            hr = pAudioCaptureClient-&gt;<span class="built_in">ReleaseBuffer</span>(numFramesAvailable);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Release capture buffer failed, hr: 0x%x"</span>, hr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            hr = pAudioCaptureClient-&gt;<span class="built_in">GetNextPacketSize</span>(&amp;packetLength);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Get next package size failed, hr: 0x%x"</span>, hr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Sample和Frame的含义"><a href="#Sample和Frame的含义" class="headerlink" title="Sample和Frame的含义"></a>Sample和Frame的含义</h1><p><code>pWaveFormat-&gt;nSamplesPerSec</code>表示每秒采样的次数，如48000的采样率就是每秒采48000个Sample，一个Sample 是一个声道的一个采样。</p><p>而Frame 则是一个时间点的Sample集合，举例来说，一个线性的PCM 双声道音频文件每个Frame有2个Sample，一个左声道Sample，和一个右声道Sample。</p><h1 id="释放设备和内存"><a href="#释放设备和内存" class="headerlink" title="释放设备和内存"></a>释放设备和内存</h1><p>在录制结束后释放设备和内存：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UnInitRecord</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (pWaveFormat) {</span><br><span class="line">        <span class="built_in">CoTaskMemFree</span>(pWaveFormat);</span><br><span class="line">        pWaveFormat = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAFE_RELEASE</span>(pDeviceEnum);</span><br><span class="line">    <span class="built_in">SAFE_RELEASE</span>(pDevice);</span><br><span class="line">    <span class="built_in">SAFE_RELEASE</span>(pAudioClient);</span><br><span class="line">    <span class="built_in">SAFE_RELEASE</span>(pAudioCaptureClient);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整示例代码见：<a href="https://github.com/winsoft666/CodeSnippet/blob/main/AudioLoopbackRecord.cpp">AudioLoopbackRecord.cpp</a></p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>史铁生：职业事业（节选）</title>
      <link href="/post/1173742882.html"/>
      <url>/post/1173742882.html</url>
      
        <content type="html"><![CDATA[<p>选择一项事业（或者找一条能够载渡精神的船）的时候，应该想起兵书上的一句话：知己知彼，百战不殆。没有谁是为了失败而工作的，因为注定的失败不能引导出一个如醉如痴的过程。</p><p>所谓知己，就是要知道自己的兴趣何在？自己的禀赋何在？如果你喜欢文学，可你偏偏不肯舍弃一个学化学的机会，且不说没有兴趣你的化学很难学好，即便你小有成就那也是你的悲剧。如果你是一个数学天才，比如说是一个潜在的陈景润，可你对此昏然不知偏要去当一个写小说的，结果多半不妙。</p><p>所谓知彼，就是得知道客观条件允许你干什么。如果你热爱起足球的时候已经 40 多岁，你最好安心作一个球迷，千万别学马拉多纳了。如果你羡慕三毛，你也有文学才能，但是你的双腿一动都不能动，你就不要向往撒哈拉，你不如写一写自己心中的沙漠。</p><p>我一贯相信，每个人都有自己的所长，倘能扬长避短谁都能有所作为；相反如果弃长取短，天才也能成为蠢才，不信让陈景润与托尔斯泰调换一下工作试试看。对事业的选择，要根据“知己知彼”的原则，可别为“热门”或时髦所左右。</p><span id="more"></span><p>然后还得需要点勇气，需要冒一点风险，没有什么办法能保证你肯定有一条金光大道。我开始想写作的时候，人们提醒我说，你哪儿都去不了不能深入生活，你凭什么能干这一行呢？我自己心里也打鼓。可是我忍不住地想写。我有纸也有笔，还有好多想法，别人一天有 24 小时的生活，我一天也有 24 小时的生活，所有的生活一样都有品味不尽的深意，我就偷偷地写了一点，自己觉得还有希望，于是豁出去了，写！如果你看不出你的选择有什么不对头，你得豁得出去，你得敢于试试，一条道走到黑或者不撞南墙不回头。当然那时我已经在街道生活组挣着自己的饭钱了，我想我最不济是个 0，不会是个负数了。</p>]]></content>
      
      
      <categories>
          
          <category> ⑬ 美文赏析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 史铁生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++获取其他Windows进程命令行</title>
      <link href="/post/3666245140.html"/>
      <url>/post/3666245140.html</url>
      
        <content type="html"><![CDATA[<p>本文介绍如何根据进程 ID 获取进程命令行参数，使用 NTDLL 提供的未公开 API 实现。</p><p>由于需要使用应用层未公开的 API，这些 API 在 Windows 提供的头文件未提供函数的定义，因此我们需要使用<code>GetProcessAddress</code>动态地从 ntdll.dll 中获取函数地址。</p><p>在涉及调用函数比较多时，动态的获取函数地址就会显得比较繁琐，我们可以直接使用下面的库来简化上述操作。<br><a href="https://github.com/winsoft666/ndk">https://github.com/winsoft666/ndk</a></p><span id="more"></span><p>下面介绍如何使用<code>ndk</code>库来根据进程 ID 获取进程命令行参数。</p><p>首先需要包含头文件：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4005)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ntndk.h"</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>并引入对应 lib：<code>x86\ntdll.lib</code>或<code>x64\ntdll.lib</code>。</p><h2 id="拿去用吧"><a href="#拿去用吧" class="headerlink" title="拿去用吧"></a>拿去用吧</h2><p>具体获取命令行参数的方式已封装到下面<code>GetProcessCommandLine</code>函数，方便读者食用。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值为0表示成功</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetProcessCommandLine</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> pid, std::wstring&amp; strResult)</span> </span>{</span><br><span class="line">    BOOL result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SetLastError</span>(<span class="number">0</span>);</span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line">    PPEB ppebCopy = <span class="literal">NULL</span>;</span><br><span class="line">    PRTL_USER_PROCESS_PARAMETERS pRtlProcParamCopy = <span class="literal">NULL</span>;</span><br><span class="line">    PWSTR wBufferCopy = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">        hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">        <span class="keyword">if</span> (!hProcess)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        PROCESS_BASIC_INFORMATION basicInfo;</span><br><span class="line">        <span class="built_in">ZeroMemory</span>(&amp;basicInfo, <span class="built_in">sizeof</span>(PROCESS_BASIC_INFORMATION));</span><br><span class="line"></span><br><span class="line">        NTSTATUS status = <span class="built_in">NtQueryInformationProcess</span>(hProcess,</span><br><span class="line">            ProcessBasicInformation,</span><br><span class="line">            &amp;basicInfo,</span><br><span class="line">            <span class="built_in">sizeof</span>(PROCESS_BASIC_INFORMATION),</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        PPEB ppeb = basicInfo.PebBaseAddress;</span><br><span class="line">        ppebCopy = (PPEB)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(PEB));</span><br><span class="line">        <span class="keyword">if</span> (!ppebCopy)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        result = <span class="built_in">ReadProcessMemory</span>(hProcess,</span><br><span class="line">            ppeb,</span><br><span class="line">            ppebCopy,</span><br><span class="line">            <span class="built_in">sizeof</span>(PEB),</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        PRTL_USER_PROCESS_PARAMETERS pRtlProcParam = ppebCopy-&gt;ProcessParameters;</span><br><span class="line">        pRtlProcParamCopy = (PRTL_USER_PROCESS_PARAMETERS)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(RTL_USER_PROCESS_PARAMETERS));</span><br><span class="line">        <span class="keyword">if</span> (!pRtlProcParamCopy)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        result = <span class="built_in">ReadProcessMemory</span>(hProcess,</span><br><span class="line">            pRtlProcParam,</span><br><span class="line">            pRtlProcParamCopy,</span><br><span class="line">            <span class="built_in">sizeof</span>(RTL_USER_PROCESS_PARAMETERS),</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        PWSTR wBuffer = pRtlProcParamCopy-&gt;CommandLine.Buffer;</span><br><span class="line">        USHORT len = pRtlProcParamCopy-&gt;CommandLine.Length;</span><br><span class="line">        wBufferCopy = (PWSTR)<span class="built_in">malloc</span>(len + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (!wBufferCopy)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(wBufferCopy, <span class="number">0</span>, len + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        result = <span class="built_in">ReadProcessMemory</span>(hProcess,</span><br><span class="line">            wBuffer,</span><br><span class="line">            wBufferCopy, <span class="comment">// command line goes here</span></span><br><span class="line">            len,</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result)</span><br><span class="line">            strResult = wBufferCopy;</span><br><span class="line">    } <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    DWORD dwGLE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!result) {</span><br><span class="line">        dwGLE = <span class="built_in">GetLastError</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ppebCopy)</span><br><span class="line">        <span class="built_in">free</span>(ppebCopy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pRtlProcParamCopy)</span><br><span class="line">        <span class="built_in">free</span>(pRtlProcParamCopy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wBufferCopy)</span><br><span class="line">        <span class="built_in">free</span>(wBufferCopy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hProcess)</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dwGLE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开源库rpclib使用备忘</title>
      <link href="/post/1963116418.html"/>
      <url>/post/1963116418.html</url>
      
        <content type="html"><![CDATA[<p><code>rpclib</code>是一个 C++的 RPC 库，基于 MessagePack 进行二进制序列化和反序列化，底层使用 TCP 进行进程间通信。其功能与 Facebook 的 Thrift、Google 的 Protocol Buffers 相似，但 rpclib 更加轻量级，不需要依赖 Boost，而且不用声明接口描述文件。</p><span id="more"></span><blockquote><p>rpclib 官网：<a href="https://github.com/rpclib/rpclib">https://github.com/rpclib/rpclib</a></p></blockquote><h1 id="1-编译"><a href="#1-编译" class="headerlink" title="1. 编译"></a>1. 编译</h1><p>使用 CMake 生成对应编译系统的项目文件，编译即可，也可以使用 vcpkg 进行安装，如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install rpclib:x86-windows-static</span><br></pre></td></tr></tbody></table></figure><h1 id="2-简单应用"><a href="#2-简单应用" class="headerlink" title="2. 简单应用"></a>2. 简单应用</h1><p>rpclib 有服务端和客户端概念，只能由客户端调用服务端，接受服务端的返回值，服务端不能主动调用客户端函数。如需实现两端双向调用，则需要在两端分别启动一个服务端和客户端，并彼此相连。</p><p>rpclib 库的错误是通过 C++异常抛出的，因此在使用该库时需要使用 <code>try...catch</code> 进行异常捕获。</p><h2 id="2-1-服务端"><a href="#2-1-服务端" class="headerlink" title="2.1 服务端"></a>2.1 服务端</h2><p>在服务端完成端口监听，及函数的绑定操作。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rpc/server.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  std::shared_ptr&lt;rpc::server&gt; rpcServer =</span><br><span class="line">    std::<span class="built_in">make_shared</span>&lt;rpc::server&gt;(<span class="string">"0.0.0.0"</span>, <span class="number">8001</span>); <span class="comment">// 8001为监听端口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定Add函数，供客户端调用</span></span><br><span class="line">  rpcServer-&gt;<span class="built_in">bind</span>(<span class="string">"Add"</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> {</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  rpcServer-&gt;<span class="built_in">async_run</span>(); <span class="comment">// 异步启动Server循环，也可以使用run()同步启动</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">catch</span>(std::exception&amp; e) {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2.2 客户端"></a>2.2 客户端</h2><p>客户端通过 IP 和端口连接服务端，并调用服务端的函数。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rpc/client.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  std::shared_ptr&lt;rpc::client&gt; rpcClient =</span><br><span class="line">    std::<span class="built_in">make_shared</span>&lt;rpc::client&gt;(<span class="string">"127.0.0.1"</span>, <span class="number">8001</span>); <span class="comment">// 服务端监听端口</span></span><br><span class="line"></span><br><span class="line">  rpcClient-&gt;<span class="built_in">set_timeout</span>(<span class="number">200</span>);  <span class="comment">// 设置同步调用的超时时间</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> result = rpcClient-&gt;<span class="built_in">call</span>(<span class="string">"Add"</span>, <span class="number">100</span>, <span class="number">200</span>).<span class="built_in">as</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">// 调用Add函数，参数为100,200</span></span><br><span class="line">  <span class="comment">// result为Add函数的返回值</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">catch</span>(std::exception&amp; e) {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-支持的参数和返回值类型"><a href="#2-3-支持的参数和返回值类型" class="headerlink" title="2.3 支持的参数和返回值类型"></a>2.3 支持的参数和返回值类型</h2><p>rpclib 使用 MessagePack 进行序列化，支持的数据类型与 MessagePack 相同。<br>支持如下 C++类型：</p><ul><li>bool</li><li>char*</li><li>double</li><li>float</li><li>char，不支持 wchar_t</li><li>short</li><li>int</li><li>long</li><li>long long</li><li>std::string，不支持 std::wstring</li><li>std::vector</li><li>std::array</li><li>std::map</li><li>std::shared_ptr</li><li>std::unique_ptr</li></ul><h1 id="3-广告"><a href="#3-广告" class="headerlink" title="3. 广告"></a>3. 广告</h1><p>在这里推荐我的<a href="https://github.com/winsoft666/veigar">veigar</a>框架，一个基于共享内存的rpc框架，与rpclib相比有如下的优势：</p><ul><li><p>没有服务端和客户端的概念，每个Veigar实例间都可以相互调用。</p></li><li><p>没有网络问题，如端口占用、半关闭状态等。</p></li><li><p>没有诡异的端口假可用性问题（特别是在Windows系统上）。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> ⑪ 开源库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建JavaScript和TypeScript开发调试环境</title>
      <link href="/post/997636699.html"/>
      <url>/post/997636699.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、安装Visual-Studio-Code"><a href="#一、安装Visual-Studio-Code" class="headerlink" title="一、安装Visual Studio Code"></a>一、安装Visual Studio Code</h1><p>Visual Studio Code（简称VSCode）是由微软开发的一个开源的、跨平台的代码编辑器。Visual Studio Code的优势就是有丰富的扩展包，大多数功能都可以通过安装扩展包的方式来实现。</p><p>打开Visual Studio Code官网<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>，根据系统选择对应的版本进行安装：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/js-ts-debug-env-1.png"></p><span id="more"></span><p>安装选项可以根据个人喜欢来指定，没有强制的要求。但建议勾选如下4项：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/js-ts-debug-env-2.png"></p><h1 id="二、配置Visual-Studio-Code"><a href="#二、配置Visual-Studio-Code" class="headerlink" title="二、配置Visual Studio Code"></a>二、配置Visual Studio Code</h1><h2 id="2-1-将默认语言设置为中文"><a href="#2-1-将默认语言设置为中文" class="headerlink" title="2.1 将默认语言设置为中文"></a>2.1 将默认语言设置为中文</h2><p>安装完Visual Studio Code之后，其界面的默认语言是英文，我们只需要安装“简体中文的语言包”就可以将语言修改为中文：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/js-ts-debug-env-3.png"><br>点击左侧“扩展”图标，打开扩展工具栏，输入“Chinese”搜索简体中文语言扩展包，安装完重启Visual Studio Code即可。</p><h1 id="三、调试环境选择"><a href="#三、调试环境选择" class="headerlink" title="三、调试环境选择"></a>三、调试环境选择</h1><p>启动Visual Studio Code，按下快捷键<code>F5</code>，可以看到Visual Studio Code已经内置了几种调试环境的配置：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/js-ts-debug-env-4.png"><br>但我们需要使用这些配置还需要安装对应的运行时环境如Node.js、Chrome。</p><blockquote><p>Visual Studio Code也可以调试C++，C#，Python，Go，C++等语言，但需要在launch.json中进行适当的配置，后面在讲解使用Node.js调试TypeScript的时候会介绍如何配置launch.json。</p></blockquote><p>因为Node.js可以直接运行Javascript脚本文件，所以这里我们选择使用Node.js来调试JavaScript。</p><p>在开始调试前，我们还需要安装Node.js<strong>运行时</strong>环境，打开Node.js中文官网<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a>，选择长期支持版，下载安装即可（安装完成之后可能需要重启Visual Studio Code）：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/js-ts-debug-env-5.png"></p><h1 id="四、调试JavaScript"><a href="#四、调试JavaScript" class="headerlink" title="四、调试JavaScript"></a>四、调试JavaScript</h1><p>打开Visual Studio Code，新建一个JavaScript文件，输入任意JavaScript代码并保存，如：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/js-ts-debug-env-6.png"><br>点击左侧工具栏的“运行”图标（快捷键<code>Ctrl+Shift+D</code>）并选择“运行和调试”（或者按<code>F5</code>快捷键），在弹出的调试环境下拉框中中选择“Node.js”，此时就会使用Node.js来运行当前脚本。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/js-ts-debug-env-7.png"></p><p>此时是看不到<code>console.log</code>的输出，因为其输出到了”调试控制台”，我们需要在“查看”菜单中打开“调试控制台”，再次使用上面步骤运行JavaScript文件即可在“调试控制台”看到运行的输出了。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/js-ts-debug-env-8.png"></p><h2 id="4-1-断点"><a href="#4-1-断点" class="headerlink" title="4.1 断点"></a>4.1 断点</h2><p>设置/取消断点：用鼠标点击行号左侧区域（即下图画绿框的区域）即可设置断点，再次点击便是<code>取消断点</code>；也可以使用快捷键<code>F9</code>来设置/取消断点.<br><img src="https://blog-static.jiangxueqiao.com/blog/img/js-ts-debug-env-9.png"><br>设置断点后，<code>F5</code>开始调试代码，代码运行到断点处便会暂停，此时我们可以在左侧区域查看当前上下文涉及的”局部变量”和”全局变量”、”调用堆栈”、以及”断点列表”。</p><h2 id="4-2-调试快捷键"><a href="#4-2-调试快捷键" class="headerlink" title="4.2 调试快捷键"></a>4.2 调试快捷键</h2><ul><li>F5 开始调试或在代码暂停后继续执行到下一处断点</li><li>F10 单步执行</li><li>F11 单步步入，F10遇到函数不会调试进入函数内部，而F11却可以步入到函数内部</li><li>Shift+F11 单步跳出</li><li>Shift+F5 停止调试</li></ul><h1 id="五、调试TypeScript"><a href="#五、调试TypeScript" class="headerlink" title="五、调试TypeScript"></a>五、调试TypeScript</h1><p>Node.js是不能直接运行TypeScript脚本的，我们使用Node.js运行TypeScript脚本一般采用如下方法：<br>使用TypeScript官方提供的<code>tcs</code>工具将TypeScript脚本转化为JavaScript，然后再使用Node.js运行js脚本，大致流程如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcs --outFile index.js index.ts</span><br><span class="line">node index.js</span><br></pre></td></tr></tbody></table></figure><p>而Node.js的扩展模块<code>ts-node</code>可以简化上述操作（其内部也是使用的tcs和node），将上面二步操作合二为一：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts-node index.ts</span><br></pre></td></tr></tbody></table></figure><p>所以，我们这里采用<code>ts-node</code>模块来作为TypeScript脚本的运行时环境。</p><p>由于我们采用了<code>ts-node</code>工具来运行TypeScript脚本，Visual Studio Code没有内置该工具的调试配置，所以我们需要在<code>luanch.json</code>中自定义一个适用于<code>ts-node</code>的调试环境配置。</p><blockquote><p>注意：如果需要自定义配置，那么工程文件必须在一个单独的目录中，并使用Visual Studio Code打开这个目录（对着目录点右键选择使用Visual Studio Code打开即可）</p></blockquote><p>大致步骤如下：</p><ol><li><p>新建项目目录（假设叫<code>TSDemo</code>）</p></li><li><p>使用Visual Studio Code打开该目录，并在“查看”菜单中选择打开“终端”（之所以在Visual Studio Code中打开终端，纯属是为了方便，因为在Visual Studio Code中打开终端，终端会自动切换到项目当前目录，且不用多个窗口之间切换）。</p></li><li><p>在终端中依此执行如下命令：</p> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 生成package.json文件</span><br><span class="line">npm init -y</span><br><span class="line"></span><br><span class="line"># 安装typescript</span><br><span class="line">npm install typescript -S</span><br><span class="line"></span><br><span class="line"> # 安装ts-node</span><br><span class="line"> npm install ts-node -S</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>luanch.json</code>的路径为<code>项目目录\.vscode\luanch.json</code>，按照下图依此点击左侧工具栏“运行”-&gt;“创建launch.json文件”：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/js-ts-debug-env-10.png"></p></li><li><p>打开自动生成的<code>luanch.json</code>文件，在<code>configurations</code>节添加如下配置：</p> <figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"version"</span><span class="punctuation">:</span> <span class="string">"0.2.0"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"configurations"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"Current TS File"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"node"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"request"</span><span class="punctuation">:</span> <span class="string">"launch"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"program"</span><span class="punctuation">:</span> <span class="string">"${workspaceRoot}/node_modules/ts-node/dist/bin.js"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"args"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">"${relativeFile}"</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"cwd"</span><span class="punctuation">:</span> <span class="string">"${workspaceRoot}"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"protocol"</span><span class="punctuation">:</span> <span class="string">"inspector"</span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>打开需要调试的TypeScript文件，快捷键<code>F5</code>开始调试。</p></li></ol><blockquote><p><strong>因为ts-node既可以执行TypeScript，也可以执行JavaScript，所以这种方式也可以用来调试JavaScript脚本。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ⑫ Web开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则规则速查</title>
      <link href="/post/3005885000.html"/>
      <url>/post/3005885000.html</url>
      
        <content type="html"><![CDATA[<p>本文不是一个完整的正则表达式的教程，仅适用于已掌握正则表达式语法，需要进行规则速查的开发人员。</p><span id="more"></span><h2 id="一、元字符"><a href="#一、元字符" class="headerlink" title="一、元字符"></a>一、元字符</h2><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>一行开始</td></tr><tr><td>$</td><td>一行结束</td></tr><tr><td>\b</td><td>单词的开始或结束</td></tr><tr><td>.</td><td>除换行符外的任意字符</td></tr><tr><td>\w</td><td>单词字符（包括字母、数字、下划线和汉字）</td></tr><tr><td>\W</td><td>任意的非单词字符（包括字母、数字、下划线和汉字）</td></tr><tr><td>\s</td><td>任意的空白字符，如空格、制表符、换行符、中文全角空格等</td></tr><tr><td>\S</td><td>任意的非空白字符</td></tr><tr><td>\d</td><td>任意的数字</td></tr><tr><td>\D</td><td>任意的非数字字符</td></tr></tbody></table><h2 id="二、字符集合"><a href="#二、字符集合" class="headerlink" title="二、字符集合"></a>二、字符集合</h2><table><thead><tr><th>字符集合</th><th>说明</th></tr></thead><tbody><tr><td>[aeiou]</td><td>aeiou 字符集中的任何字符</td></tr><tr><td>[^aeiou]</td><td>除 aeiou 字符集之外的字符</td></tr><tr><td>[0-9a-z]</td><td>字符集合 0 到 9，a 到 z 中的任何字符</td></tr><tr><td>[^0-9a-z]</td><td>除字符集合 0 到 9， a 到 z 中的任何字符</td></tr></tbody></table><h2 id="三、限定符"><a href="#三、限定符" class="headerlink" title="三、限定符"></a>三、限定符</h2><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>{n}</td><td>重复次数=n 次</td></tr><tr><td>{n,}</td><td>重复次数&gt;=n 次</td></tr><tr><td>{n,m}</td><td>n&lt;=重复次数&lt;=m</td></tr><tr><td>*</td><td>重复次数&gt;=0</td></tr><tr><td>+</td><td>重复次数&gt;=1</td></tr><tr><td>?</td><td>0&lt;=重复次数&lt;=1</td></tr><tr><td>*?</td><td>尽可能少地使用重复的第一个匹配</td></tr><tr><td>+?</td><td>尽可能少地使用重复但至少使用一次</td></tr><tr><td>??</td><td>使用零次重复（如有可能）或一次重复</td></tr></tbody></table><h2 id="四、分组"><a href="#四、分组" class="headerlink" title="四、分组"></a>四、分组</h2><p>分组又称为子表达式，即把一个正则表达式的全部或部分分成一个或多个组。其中，分组使用的字符为<code>(</code>和<code>)</code>，即左圆括号和右圆括号。分组之后，可以将字符为<code>(</code>和<code>)</code>之中的表达式看成一个整体来处理。</p><p>以下正则表达式可以匹配重复出现字符串“abc”一次或两次的字符串。此时，表达式将“abc”看成一个整体来进行重复匹配。</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(abc){1,2}</span><br></pre></td></tr></tbody></table></figure><p>当一个正则表达式被分组之后，每一个组将自动被赋予一个组号，该组号可以代表该组的表达式。<br>其中，组号的编制规则为：从左到右、以分组的左括号<code>(</code>为标志，第一个分组的组号为 1，第二个分组的组号为 2，以此类推。<br>可以使用 <code>\数字</code> 的方式来引用分组。如<code>\1</code>，<code>\2</code>。</p><h2 id="五、贪婪与非贪婪"><a href="#五、贪婪与非贪婪" class="headerlink" title="五、贪婪与非贪婪"></a>五、贪婪与非贪婪</h2><p>比如说匹配输入串 A:&nbsp;<code>101000000000100</code></p><p>使用<code>1.*1</code>将会匹配到 <code>1010000000001</code>, 匹配方法: 先匹配至输入串 A 的最后, 然后向前匹配, 直到可以匹配到 1, 称之为贪婪匹配。</p><p>使用<code>1.*?1</code>将会匹配到 <code>101</code>, 匹配方法: <code>*</code>匹配下一个 1 之前的所有字符, 称之为非贪婪匹配。</p><p>所有带有量词的都是非贪婪匹配:&nbsp;<code>.*?</code>,&nbsp;<code>.+?</code>,&nbsp;<code>.{2,6}?</code>, <code>.??</code>。</p><h2 id="六、在线正则验证工具"><a href="#六、在线正则验证工具" class="headerlink" title="六、在线正则验证工具"></a>六、在线正则验证工具</h2><ul><li><a href="https://c.runoob.com/front-end/854/">https://c.runoob.com/front-end/854/</a></li><li><a href="http://www.yunjson.com/reg/">http://www.yunjson.com/reg/</a></li><li><a href="https://tool.oschina.net/regex/">https://tool.oschina.net/regex/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ⑩ 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git杂记</title>
      <link href="/post/2042033077.html"/>
      <url>/post/2042033077.html</url>
      
        <content type="html"><![CDATA[<p>本文记录 Git 使用中的一些零碎知识，方便自己查阅，亦希望成人之美。</p><span id="more"></span><h2 id="一、gitignore-文件规则"><a href="#一、gitignore-文件规则" class="headerlink" title="一、gitignore 文件规则"></a>一、gitignore 文件规则</h2><ul><li>所有空行或#开头的行都会被忽略；</li><li>文件或目录前加 /表示仓库根目录；</li><li>匹配模式最后跟反斜杠 / 指明是目录而非文件，忽略该目录下的所有文件，但不忽略该目录；</li><li>在模式前加!，指明不忽略某个文件或目录；</li><li>支持标准的 glob 模式匹配<ul><li><code>*</code> 匹配零个或多个任意字符；</li><li><code>?</code> 只匹配一个任意字符；</li><li><code>[abc]</code>匹配任何一个列在方括号中的字符；</li><li><code>[0-9]</code> 表示匹配所有 0 到 9 的数字，同理有<code>[a-z]</code>等；</li></ul></li></ul><h2 id="二、清空仓库历史提交"><a href="#二、清空仓库历史提交" class="headerlink" title="二、清空仓库历史提交"></a>二、清空仓库历史提交</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建新分支，如名称latest_branch</span></span><br><span class="line">git checkout --orphan latest_branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加所有文件</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 提交</span></span><br><span class="line">git commit -m <span class="string">"自定义提交说明"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 删除原来的主分支（master）</span></span><br><span class="line">git branch -D master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 将当前分支重命名为master</span></span><br><span class="line">git branch -m master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 强制推送到远端</span></span><br><span class="line">git push -f origin master</span><br></pre></td></tr></tbody></table></figure><p>有些仓库有 master 分支保护，不允许强制 push，需要在远程仓库项目把分支保护关掉才能推送。</p><p>推送前需要使用<code>git remote -v</code> 查看关联的远程仓库的信息（主要是远程库的别名）。虽然远程库的别名默认是 origin ,但可能设置过其他的别名（而非 origin）。</p>]]></content>
      
      
      <categories>
          
          <category> ⑩ 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt加载字体文件</title>
      <link href="/post/2767065786.html"/>
      <url>/post/2767065786.html</url>
      
        <content type="html"><![CDATA[<p>本文仅简单记录如何使用 Qt 加载外部字体文件，并遍历字体名称和样式名称。</p><span id="more"></span><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LoadFont</span><span class="params">(<span class="type">const</span> QString&amp; fontPath)</span> </span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> fontId = QFontDatabase::<span class="built_in">addApplicationFont</span>(fontPath);</span><br><span class="line">    <span class="keyword">if</span> (fontId == <span class="number">-1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历字体名和样式名</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> QT_VERSION &gt;= QT_VERSION_CHECK(6, 0, 0)</span></span><br><span class="line">    <span class="type">const</span> QStringList fontFamilyList = fontDb.<span class="built_in">applicationFontFamilies</span>(fontId);</span><br><span class="line"></span><br><span class="line">    QString fontFamily;</span><br><span class="line">    foreach (fontFamily, fontFamilyList) {</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Family:"</span> &lt;&lt; fontFamily;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> QStringList fontStyleList = QFontDatabase::<span class="built_in">styles</span>(fontFamily);</span><br><span class="line">        QString fontStyle;</span><br><span class="line">        foreach (fontStyle, fontStyleList) {</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"\tStyle:"</span> &lt;&lt; fontStyle;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    QFontDatabase fontDb;</span><br><span class="line">    <span class="type">const</span> QStringList fontFamilyList = fontDb.<span class="built_in">applicationFontFamilies</span>(fontId);</span><br><span class="line"></span><br><span class="line">    QString fontFamily;</span><br><span class="line">    foreach (fontFamily, fontFamilyList) {</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Family:"</span> &lt;&lt; fontFamily;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> QStringList fontStyleList = fontDb.<span class="built_in">styles</span>(fontFamily);</span><br><span class="line">        QString fontStyle;</span><br><span class="line">        foreach (fontStyle, fontStyleList) {</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"\tStyle:"</span> &lt;&lt; fontStyle;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>聊聊桌面客户端开发的技术选型</title>
      <link href="/post/3110746169.html"/>
      <url>/post/3110746169.html</url>
      
        <content type="html"><![CDATA[<p>桌面客户端（也叫 PC 客户端，支持 Windows、MacOS、Ubuntu 等系统）开发有多种技术选型的方式，每种方式各有优劣。采用不同的方式会导致在开发周期、技术人员构成、软件性能、安装包体积等方面有比较大的差别。本文结合作者多年客户端开发经验，聊聊在客户端开发方面的各种技术选型。</p><span id="more"></span><h1 id="1-WinForms"><a href="#1-WinForms" class="headerlink" title="1. WinForms"></a>1. WinForms</h1><p>WinForms（Windows Forms）是微软推出的 UI 框架，可以使用 C#和 Visual Basic 语言开发。<br>WinForms 框架适合开发传统 UI 元素和界面的应用程序，比如工业、医疗领域的管理、控制软件。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/llkhdjsxx-1.jpg"></p><blockquote><p>WinForms 也能开发出绚丽、非标准化的界面效果，但需要花费较多的时间，对开发人员的技术要求也更高。</p></blockquote><p>基于 WinForms 开发的应用程序需要依赖.Net Framework 运行时，如果用户电脑上未安装，则需要自动为用户安装，否则程序无法运行。</p><p>使用 WinForms 开发的应用程序体积本身很小，但为了适应不同的用户电脑环境，安装包需要检测用户电脑上的.Net Framework 运行时版本是否与软件所需版本匹配，如不匹配则需要自动安装相应的.Net Framework 运行时。</p><p>.Net Framework 很难做成便携版，通常需要使用微软提供的安装包进行安装，安装.Net Framework 运行时分为在线和离线安装两种方式：</p><ul><li>离线安装方式。<br>将微软提供的.Net Framework 离线安装包（不同版本体积不同，如 4.8 版本的离线安装包约 115M 左右）打包进程序安装包，安装时进行释放和安装。这种方式会增加程序安装包的体积。</li><li>在线安装方式。<br>将微软提供的.Net Framework 在线安装工具（体积很小，约 1.5M 左右）打包进程序安装包，安装时进行释放和在线安装，这种方式虽然可以减少安装包体积，但在线安装需要实时从微软服务器下载资源，受限于用户网络环境，可能导致安装失败。</li></ul><h2 id="1-1-Net-Framework-版本兼容性"><a href="#1-1-Net-Framework-版本兼容性" class="headerlink" title="1.1 .Net Framework 版本兼容性"></a>1.1 .Net Framework 版本兼容性</h2><p>在.Net Framework 4.5 版本之前，其各个版本之间不相互兼容（无论是向前还是向后都无法兼容），但从 4.5 及以后的版本就可以保证向后兼容了。</p><p>举例说明：</p><ul><li>如果程序使用.Net Framework 3.5 版本开发，则只能基于该版本的运行时运行。</li><li>如果程序使用.Net Framework 4.6 版本开发，则用户电脑上只需要安装<code>&gt;=4.6</code> 版本的运行时即可运行。</li></ul><h2 id="1-2-系统自带-Net-Framework-版本"><a href="#1-2-系统自带-Net-Framework-版本" class="headerlink" title="1.2 系统自带.Net Framework 版本"></a>1.2 系统自带.Net Framework 版本</h2><p>从 Windows Vista 开始，Windows 系统会自带.Net Framework 运行时，但各个系统自带的运行时版本不同。</p><p>下表列出了不同系统自带的.Net Framework 运行时的最低版本：</p><blockquote><p>为什么是最低版本了？<br>因为用户可能通过系统升级的方式更新了.Net Framework 运行时的版本。</p></blockquote><table><thead><tr><th>操作系统</th><th>.Net Framework 运行时版本</th></tr></thead><tbody><tr><td>Windows XP</td><td>1.0</td></tr><tr><td>Windows Vista</td><td>2.0</td></tr><tr><td>Windows 7</td><td>3.5</td></tr><tr><td>Windows 8</td><td>4.5</td></tr><tr><td>Windows 10</td><td>4.6 ~ 4.7</td></tr><tr><td>Windows 11</td><td>4.8+</td></tr></tbody></table><p>不同系统所支持的.Net Framework 最高版本也有所不同：</p><ul><li>Windows XP 最高支持.NET Framework 4.0</li><li>Windows 7 最高支持.NET Framework 4.6.2</li><li>Windows 8.1 最高支持.NET Framework 4.6.2</li><li>Windows 10 和 Windows 11 可以支持任意版本的.NET Framework</li></ul><h2 id="1-3-Net-Core"><a href="#1-3-Net-Core" class="headerlink" title="1.3 .Net Core"></a>1.3 .Net Core</h2><blockquote><p>.Net Core 官网：<a href="https://dotnet.microsoft.com/en-us/">https://dotnet.microsoft.com/en-us/</a></p></blockquote><p>.Net Core 是微软开发的一个开源的、跨平台的（支持 Windows、MacOS、Linux 等系统）通用软件开发框架。在.Net Core 出现之前，开发人员只能基于.Net Framwork 开发 WinForms 应用程序，.Net Core 出现之后，开发人员多了一种选择。</p><p>.Net Core 与.Net Framework 最大的不同在于.Net Core 是开源和跨平台的，基于.Net Core 开发的应用程序可以运行在不同的操作系统上，如 Windows、Linux、MacOS。</p><p>.Net Core 还处于快速的更新迭代中，之前的老版本对 WinForms 及 WPF 的支持不太好（甚至不支持），建议采用最新版本的.Net Core 进行开发。</p><p>使用.Net Core 开发的应用的体积本身非常小，但在打包分发时也需要携带.Net Core 运行时。不同于.Net Framework，.Net Core 运行时既支持安装包的方式，也支持便携版的方式。<br>以.Net Core 6.0 版本为例，微软官方提供的 WindowsDesktop 的运行时大小为 50M，我们可以根据程序实际依赖情况，安装包只包含程序依赖的文件，从而缩减安装包体积（缩减后约 20M 左右）。</p><h1 id="2-WPF"><a href="#2-WPF" class="headerlink" title="2. WPF"></a>2. WPF</h1><p>WPF（Windows Presentation Foundation）也是微软推出的 UI 框架。与 WinForms 一样，可以使用 C#和 Visual Basic 进行开发，也都支持.Net Framework 和.Net Core 两种开发平台。</p><p>使用 WPF 框架开发的应用程序界面更加炫酷，界面组件可随意定制化，适合用于对界面要求较高的应用。</p><p>WPF 程序的性能稍逊与 WinForms 应用，不过这种性能差别在计算机硬件配置快速提升的今天已在逐渐的被淡化，因此在进行技术选型时 WPF 的性能问题基本可以忽略。</p><p>需要注意的是，WPF 应用在启动时通常较慢，比如用户打开应用后需要花费大概 1 秒左右的时间才能看见主界面。</p><h1 id="3-MFC"><a href="#3-MFC" class="headerlink" title="3. MFC"></a>3. MFC</h1><p>MFC（Microsoft Foundation Classes）是微软提供的一个基础类库，对 Windows 系统 API 进行了封装，包含一些基础控件，从而减少应用开发人员的工作量。<br>MFC 应用程序的开发语言为 C++，MFC 提供的控件都是常规的 Windows 风格，和 WinForms 一样，如果需要开发炫丽、交互复杂的界面，需要开发人员花费精力自己绘制，会降低不少开发效率。</p><p>MFC 比较适合应用在对软件性能要求较高、调用系统 API 较多、界面交互较简单的软件上。</p><h1 id="4-DirectUI"><a href="#4-DirectUI" class="headerlink" title="4. DirectUI"></a>4. DirectUI</h1><p>DirectUI 是一类技术的统称，即 <code>Paint on parent dc directly</code>，直接在父窗体上进行绘制。是对 MFC 的一种改进，整个窗口只有一个句柄，而不是像 MFC 一样，每个控件都有一个句柄。</p><p>目前流行的 DirectUI 界面库大多由个人开发并开源，由于没有专门的团队进行维护，因此使用该类界面库的公司通常需要自己维护一个分支进行 Bug 修复和添加新功能。</p><p>常用的 DirectUI 界面库有：</p><ul><li><a href="https://github.com/duilib/duilib">duilib</a> 作者已基本不维护。</li><li><a href="https://github.com/qdtroy/DuiLib_Ultimate">DuiLib_Ultimate</a> 其他人维护的一个 duilib 版本。</li><li><a href="https://github.com/vczh-libraries/GacUI">GacUI</a></li><li>……</li></ul><p>建议选择技术人员熟练的库，最好熟悉源码可以进行 Bug 修复和功能定制开发。</p><p>DirectUI 界面库通常都是轻量级的，因此其开发的应用程序体积都会比较小。</p><h1 id="5-Qt"><a href="#5-Qt" class="headerlink" title="5. Qt"></a>5. Qt</h1><p>Qt 是一个跨平台的 C++图像界面开发框架，不仅支持 Windows、MacOS、Linux 等 PC 操作系统，还支持嵌入式 QNX、VxWorks 及 Android、iOS 等操作系统。</p><p>Qt 的应用非常广泛，是目前使用最广的 C++ 图像界面框架。Qt 应用程序的开发语言为 C++，Qt 比 MFC 上手更快，而且在控件定制、 UI 绘制上也比 MFC 方便。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/llkhdjsxx-2.gif"></p><p>以 Qt 5.15.2 版本为例，Qt 应用程序打包后的体积最小到 6MB 左右，如果使用更老版本的 Qt，体积可以更小。</p><h2 id="5-1-Qt-版权问题"><a href="#5-1-Qt-版权问题" class="headerlink" title="5.1 Qt 版权问题"></a>5.1 Qt 版权问题</h2><p>Qt 分为开源版本和商业版本，开源版本可以免费使用，商业版本需要付费才能使用。开源版本也可以用于商业用途，但需要遵守相应的规则。</p><p>Qt中的大多数模块采用LGPL开源协议，少部分模块采用的是GPL协议，在开发商业软件是我们应选择LGPL协议的模块，并采用Qt动态链接库的方式（而不是静态库的方式）。</p><blockquote><p>对应有些必须静态链接的模块，如<code>QtMain</code>，Qt采用BSD协议，允许在商业软件中使用。</p></blockquote><p>慎用采用GPL协议的模块，该协议具有传染性，它要求所有使用这些模块的软件要开源，因此要慎用GPL协议的模块。</p><p>可以在<a href="https://www.qt.io/product/features">https://www.qt.io/product/features</a>网站查询Qt模块对应的开源协议。</p><p>另外如果有对 Qt 源码进行修改，需要公布修改部分的源码。</p><h1 id="6-CEF"><a href="#6-CEF" class="headerlink" title="6. CEF"></a>6. CEF</h1><blockquote><p>CEF 官网：<br><a href="https://bitbucket.org/chromiumembedded/cef/wiki/Home">https://bitbucket.org/chromiumembedded/cef/wiki/Home</a>。</p></blockquote><p>CEF（Chromium Embedded Framework ）是 Google 公司开发的一个跨平台的浏览器内核框架（与 Chrome 浏览器为同一内核），以开源库的方式提供，可以内嵌到第三方程序中用于显示网页以及与网页进行交互。</p><p>CEF 自身主要使用 C++进行开发，目前也有 CEF 的其他语言的绑定，比如 CefSharp 就是 C#的绑定。因此基于 CEF 技术方案，可以使用 C++、C#或其他语言作为开发语言，但据我了解大多使用的还是 C++。</p><p>在开发中，我们通常不会直接使用 CEF，而是进行二次封装，将其封装成组件，该组件用于打开 Web 页面，由 Web 页面进行界面交互，Javascript 和 C++或 C#进行交互。</p><blockquote><p>为了节省开发时间，可以使用我封装的<a href="https://github.com/winsoft666/QCefWidget">QCefWidget</a>组件。</p></blockquote><p>CEF 经历了 CEF1 和 CEF3 两个大版本，CEF1 现已基本被淘汰，目前主流的是 CEF3（CEF 2623 版本是最后一个支持 Windows XP 的版本）。</p><p>由于版权问题，CEF 默认不支持 MP4 解码，如需支持，需要自行下载源码进行编译（这个过程可能会耗时 1 天左右）。</p><p>采用 CEF 内嵌 Web 页面的方式，可以借助 Web 开发的优势，极大提升软件开发效率，Web 页面更新起来也比客户端的升级更加方便。但由于本质还是客户端内嵌浏览器，因此软件内存占用会比较高，通常一个简单的程序可能会占用 100MB 左右。在性能方面，也远远不及上面介绍的其他原生开发方式。</p><p>CEF 不同版本的体积差距较大，2623 版本压缩后大约 25MB，而 89.0.18 版本压缩后大约 60MB。不同版本对 Web 新特效的支持程度不同，在不在乎安装包体积的情况下可以选择最新版本，如果需要考虑安装包体积，则需要做出权衡。</p><p>采用该技术方案需要由 Web 开发者开发客户端内嵌页面，并 C++开发者开发客户端主体框架，由于 Web 页面无法直接访问系统资源，因此还需 Web 与 C++进行交互，由 C++完成系统功能的开发。</p><h1 id="7-Electron"><a href="#7-Electron" class="headerlink" title="7. Electron"></a>7. Electron</h1><p>前面提到使用 CEF 时需要二次封装，而 CEF 的接口又不是那么易于使用，所以封装一个功能完整、稳定运行的 CEF 组件需要花费不少时间。而 Electron 则是基于 CEF 进行了深层次的封装，Electron 相比自己封装 CEF 会更加稳定，而且可以节省开发和后期维护的时间。</p><p>Electron 和 CEF 最大的不同之处是 Electron 可以直接调用 Node.js 的模块，如文件、系统、网络等模块，基于这些模块，理论上可以使用 JavaScript 完成客户端应用的开发，但这也仅限于理论上，实际上由于大多数的 Web 开发者缺少客户端软件开发经验，甚至缺少系统方面的理论基础，因此很难完全依靠 Web 开发者开发出功能完备的客户端软件。</p><p>基于 Electron 开发客户端应用时，大多数时候都需要有 C++开发者开发 Node 模块来供 JavaScript 调用。</p><h1 id="8-其他图像界面库"><a href="#8-其他图像界面库" class="headerlink" title="8. 其他图像界面库"></a>8. 其他图像界面库</h1><p>除了上面介绍的方案，还要很多其他的优秀界面库，这些库各有特色，目前它们的使用者还没有上面的多。</p><p>下面列举了一些我所知道的优秀界面库，欢迎补充：</p><ul><li><a href="https://github.com/mikke89/RmlUi">RmlUi</a></li><li><a href="https://github.com/yue/yue">yue</a></li><li><a href="https://github.com/cycfi/elements">elements</a></li><li><a href="https://github.com/ocornut/imgui">imgui</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ⑧ 软件架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>戴建业：阅读习惯与人生未来</title>
      <link href="/post/1878076142.html"/>
      <url>/post/1878076142.html</url>
      
        <content type="html"><![CDATA[<p>人有丑俊，书有浅深。就像人有种种色色一样，书也分不同的性质和层次。</p><span id="more"></span><p>东汉思想家王充将当时的书分为三种：作、述、论。他的名著《论衡》刚杀青时，有人恭维他“可谓作者”，也就是说他的著作算得上是“作”。王充谦逊地说自己的书“非作也，亦非述也，论也”。他把自己的代表作取名为《论衡》。原创性著作可称为“作”，它们横空出世而自铸伟词，属于前无古人且后启来者的经典。或阐述他人之思，或综贯百家之绪，或引申前人之学，虽然没有原创性，但能自成一家言，这一类书籍称为“述”；或记录“思想火花”，或更正当时邪说，或分析一时变故，按王充的说法，属于“杂说”一类的东西统称之为“论”。</p><p>今天书籍的种类更为繁多，有经典著作与流行书籍之别，有专业著作与大众读物之殊，有文字读物与视频读物之异……网络上的绝大多数读物没有“书”的形态，但它们赢得了绝大多数读者。这些东西多数不会成书，它们的作者也不想著书。</p><p>可喜的是，随着互联网的发达和手机的普及，人类有可能真正实现“知识的普惠”，任何层次任何形式的书籍都能轻易得到，前人蔑视的“引车卖浆之流”都能阅读。地铁里，公交上，休息时，随时随地都能看到“低头一族”。</p><blockquote><p>“引车卖浆之流”意思是拉大车的，做小买卖的。指平民百姓。</p></blockquote><p>不过，这种情况让人“亦喜亦忧”——随着知识的日益普及化，<strong>知识也日益浅表化和碎片化</strong>。</p><p>知识的浅表化不仅在社会大众中存在，在研究生和学者中也很普遍，区别只在五十步与百步之间。譬如要写一篇李白诗中“月亮”意象的论文，前人就得通读李白全集，今人只需要在电脑中敲上“月亮”二字，李白诗歌中所有与“月亮”有关的诗句都蹦了出来。你根本用不着读李白集，甚至用不着去完整地读一首李白诗，一篇上万字的论文就糊弄出来了。前人说李白诗“豪放飘逸”，李诗何以“豪放”，又如何“飘逸”，写文章的作者可能两眼茫然，对前人的评论缺乏深刻的理解，对李白诗歌也缺乏深度的体验。钱锺书谈到李白诗中的月亮，今天学者也谈到李白诗中的月亮，表面上看“月亮还是那个月亮”，但此“月亮”非彼“月亮”。</p><p>知识碎片化的情况更为严重。过去获取知识大多来于书本，书本上的知识具有一定的系统性，而且还需要一定的逻辑证明或事实依据，这种知识往往系统完整，而且还具有逻辑上的连贯性。今天，无论是日常生活，还是学术研究，我们都不必积累大量的知识，更不必建立自己的知识结构，什么知识都可以“谷歌”“百度”，什么材料都可以去文献检索。无须穷经皓首，无须博闻强记，无须学识渊博，在生活与研究中照样畅通无阻，在任何一个领域都潇洒无忧。只要你会“谷歌”，会“百度”，会搜索，无知可以显得有知，不学也可以显得博学。</p><p>长此以往，我们既难以认知哲人理论体系的深刻严谨，也难以体验诗人情感的博大崇高，甚至无法感受艺术作品的细腻美妙，因而认识会越来越浮浅，心灵会越来越荒芜，审美会越来越庸俗。从来不去碰一碰原创性的经典，我们自己怎么可能会有原创性？</p><p><strong>阅读大体上可以分为三大类：消遣性阅读、鉴赏性阅读与挑战性阅读。</strong></p><p>消遣性阅读纯粹是为了消磨时光，比如在手机上刷刷天南地北的奇闻，看看男女明星的恩怨，上购物网上看看今年穿什么裙子，上旅游网上看看去哪些地方自驾游……这种阅读表面上是在“看”，其实是一无所“看”，因为他本来就没有打算去“看”什么，所以他才会什么都“看”。他阅读只是为了排遣无聊，希望这百无聊赖的日子赶快溜走，盼只盼“马儿呀快快地走”，这就是所谓“不做无聊之事，何以遣有涯之生”。</p><p>鉴赏性阅读包括听轻盈优美的音乐，看赏心悦目的画册，读文字优美的游记，读情节曲折的小说等等。这类阅读轻松愉快，紧张思考之余，下班归来之后，听听音乐，翻翻画册，品品字帖，读读小品，既能使自己身心放松，又能提高自己的审美能力，还可以使自己情感丰富细腻，这种阅读有“一石三鸟”的多重好处。</p><p>最后一种阅读就是挑战性阅读。人类流传下来的伟大经典，还有专业公认的名著，这一类经典著作都是挑战性阅读的读物。要想挑战自己的智力极限，要想攀登灵魂的珠穆朗玛峰，最佳选择就是挑战性阅读，去阅读那些伟大的经典，去结交那些非凡的智者或崇高的伟人。</p><p>一位西方作家曾不无调侃地说，<strong>所谓“经典著作”就是人人说好，但人人不读的那些书籍</strong>。的确，经典大多数是在人们书架上被“供奉”，并不是在人们案头上被阅读。为什么会出现这种情况呢？或深度超出了自己的智力范围，初读往往不知所云，如罗素的《数学原理》、弗雷格的《算术基础》；或行文过于晦涩艰深，超出了一般读者忍受的极限，如康德的《纯粹理性批判》、海德格尔的《存在与时间》；或自己缺乏必要的知识准备，或时代相隔十分遥远，今人无法领略书中的美感，如屈原的骚赋、杜甫的诗歌、但丁的《神曲》。这些经典是人类的精神宝库，但大多数人不得其门而入，它只向那些勤奋坚毅者敞开大门。</p><p>经典绝不能“随便翻翻”，再三思考琢磨才能探骊得珠，反复咀嚼才能品咂出它的味道。<strong>经典不是心灵的“可口可乐”，我们可以咕噜咕噜地一饮而尽</strong>，它需要我们不断钻研才能常读常新，如先秦的《庄子》、司马迁的《史记》、马克思的《资本论》、黑格尔的《精神现象学》，你越读越觉得奇妙无比。倘若真正读懂了这些经典，你会有一种“一览众山小”的开豁；倘若终身浸润于伟大的经典之中，你将“身心获益靡涯，文笔增华有望”。</p><blockquote><p>“探骊得珠”的原意是骊珠，相传为藏在骊龙颔下的宝珠，骊龙栖息深渊中，欲取得骊珠，必须潜入深渊，待骊龙入睡后，再俟机窃取；指获得极为珍贵的宝物；后引申为写作文章能抓住重点，深得题旨的精髓。</p></blockquote><p>可惜，有“会当凌绝顶”雄心的人很多，但最后实现“凌绝顶”志向的人极少。古人常常感叹，“学者如牛毛，成者如麟角”，学无所成的原因是没有定力。人与人拉开差距的关键，大多不是智力的高下，而是毅力与恒心的大小。包括我在内的许多朋友，“会当凌绝顶”的雄心不过一时心血来潮，还没有爬到半山腰就见难而返。</p><p>弃难图易是人的天性，“东海西海，心同理同”，套用王尔德的话说，所有人都有惰性，连我也有惰性：只要能读消遣读物我就不读经典，只要能读中文我就不想读英文，只要能读现代文学我就不想读古代文学，只要能看电视我就不想读书，只要能玩手机我就不会看电视……</p><p>当然，今天人们无法拒绝手机阅读和网络阅读。问题是，能否让网络空间也飘溢书香？是否也能在手机上咀嚼经典？看来人们已经发现了问题的严重性，就像大家拒绝快餐食品一样，人们会逐渐改变消遣式浏览，在网络空间中培养挑战性阅读的习惯，同时在纸质书本与网络空间培植深度阅读的土壤。</p><p>稍稍留意一下就不难发现，不同的阅读和思考习惯，短时间内看不出有什么差别，时间一长就出现天差地别：有的才华出众，有的“泯然众人”。你自己选择了什么样的阅读习惯，你就为自己选择了什么样的人生。</p>]]></content>
      
      
      <categories>
          
          <category> ⑬ 美文赏析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 戴建业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QPixmap使用要点</title>
      <link href="/post/170290456.html"/>
      <url>/post/170290456.html</url>
      
        <content type="html"><![CDATA[<p>本文记录在使用 QPixmap 时容易感到困惑和犯错的地方，方便自己查阅，亦希望能成人之美。</p><span id="more"></span><h1 id="1-QPixmap-成员函数使用要点"><a href="#1-QPixmap-成员函数使用要点" class="headerlink" title="1. QPixmap 成员函数使用要点"></a>1. QPixmap 成员函数使用要点</h1><ul><li>QPixmap::size()值与程序 devicePixelRatio 无关，输出的是图片原始尺寸。</li><li>AspectRatioMode 取值：<ul><li>Qt::IgnoreAspectRatio 忽略图片原长宽比，将图片缩放到指定尺寸</li><li>Qt::KeepAspectRatio 在保持图片原长宽比和图片所有元素的情况下，尽量填充满目标矩形。</li><li>Qt::KeepAspectRatioByExpanding 在保持长宽比的情况下，拉伸图片保证填充满目标矩形，可能会舍弃部分图片元素。</li></ul></li></ul><p><img src="https://blog-static.jiangxueqiao.com/blog/img/qpixmap-syyd-2.png"></p><ul><li>scaledToWidth、scaledToHeight 函数可以实现在保持原图片长宽比的前提下，将图片缩放到指定的宽或者高。</li><li>drawPixmap 函数的参数从左到右依次是：目标区域 -&gt; pix -&gt; 源区域。<strong>目标区域会考虑当前 Widget 的 devicePixelRatio，而源区域则与 devicePixelRatio 无关。</strong></li></ul><h1 id="2-开启程序-DPI-缩放"><a href="#2-开启程序-DPI-缩放" class="headerlink" title="2. 开启程序 DPI 缩放"></a>2. 开启程序 DPI 缩放</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    QGuiApplication::<span class="built_in">setAttribute</span>(Qt::AA_EnableHighDpiScaling);</span><br><span class="line">    QGuiApplication::<span class="built_in">setAttribute</span>(Qt::AA_UseHighDpiPixmaps);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5, 14, 0))</span></span><br><span class="line">    QGuiApplication::<span class="built_in">setHighDpiScaleFactorRoundingPolicy</span>(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><h1 id="3-QPixmap-devicePixelRatio"><a href="#3-QPixmap-devicePixelRatio" class="headerlink" title="3. QPixmap::devicePixelRatio"></a>3. QPixmap::devicePixelRatio</h1><p>首先<code>QPixmap::devicePixelRatio</code>仅适用于开启了 DPI 缩放的程序。</p><p>高分辨率版本的图片有大于 1 的设备像素比（即<code>QPixmap::devicePixelRatio</code>），如果该值匹配底层 QPaintDevice 的值，它将直接绘制到设备上，而不应用额外的转换。</p><p><strong>该值用于指定当前 QPixmap 图片是基于 1 倍图的几倍缩放图。</strong></p><p>需要注意的是，在使用<code>drawPixmap</code>函数时，如果该目标区域参数未指定宽和高，<code>QPixmap::devicePixelRatio</code>才生效。</p><p>如下面的<code>drawPixmap</code>原型：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::drawPixmap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> QPixmap &amp;pixmap, <span class="type">int</span> sx, <span class="type">int</span> sy, <span class="type">int</span> sw, <span class="type">int</span> sh)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::drawPixmap</span><span class="params">(<span class="type">const</span> QPointF &amp;point, <span class="type">const</span> QPixmap &amp;pixmap, <span class="type">const</span> QRectF &amp;source)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::drawPixmap</span><span class="params">(<span class="type">const</span> QPoint &amp;point, <span class="type">const</span> QPixmap &amp;pixmap, <span class="type">const</span> QRect &amp;source)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::drawPixmap</span><span class="params">(<span class="type">const</span> QPointF &amp;point, <span class="type">const</span> QPixmap &amp;pixmap)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::drawPixmap</span><span class="params">(<span class="type">const</span> QPoint &amp;point, <span class="type">const</span> QPixmap &amp;pixmap)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPainter::drawPixmap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> QPixmap &amp;pixmap)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></tbody></table></figure><p>示例（程序已开启 DPI 缩放）：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QtWidgetsApplication1::paintEvent</span><span class="params">(QPaintEvent* e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">devicePixelRatioF</span>(); <span class="comment">// 当前程序的DPI缩放为1.5</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pix</span><span class="params">(<span class="string">"D:\\gril.png"</span>)</span></span>; <span class="comment">// gril.png图片实际尺寸为400*400</span></span><br><span class="line">    pix.<span class="built_in">setDevicePixelRatio</span>(<span class="number">4</span>);  <span class="comment">// 告知程序该图片是基于1倍图进行4倍放大后的，即1倍图为宽高为400/4</span></span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="built_in">QPoint</span>(<span class="number">100</span>,<span class="number">100</span>), pix);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://blog-static.jiangxueqiao.com/blog/img/qpixmap-syyd-1.png"></p>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>QSS设置滚动条样式</title>
      <link href="/post/140071237.html"/>
      <url>/post/140071237.html</url>
      
        <content type="html"><![CDATA[<p>本文仅简单记录如何使用 QSS 设置滚动条的样式。</p><span id="more"></span><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*垂直滚动条*/</span></span><br><span class="line">QScrollBar:vertical {</span><br><span class="line">  <span class="attribute">background</span>: transparent; <span class="comment">/*背景色*/</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>; <span class="comment">/*宽度*/</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">0px</span>; <span class="comment">/**/</span></span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">12px</span>; <span class="comment">/*距离上面12px*/</span></span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">12px</span>; <span class="comment">/*距离底部12px*/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*横向滚动条*/</span></span><br><span class="line">QScrollBar:horizontal {</span><br><span class="line">  <span class="attribute">background</span>: transparent; <span class="comment">/*背景色*/</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>; <span class="comment">/*高度*/</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">12px</span>; <span class="comment">/*距离左边12px*/</span></span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">12px</span>; <span class="comment">/*距离右边12px*/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*垂直/横向滚动条Hover效果*/</span></span><br><span class="line">QScrollBar:vertical:hover,</span><br><span class="line">QScrollBar:horizontal:hover {</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">30</span>); <span class="comment">/*背景色*/</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>; <span class="comment">/*圆角*/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*垂直滚动条 - 滑块*/</span></span><br><span class="line">QScrollBar::handle:vertical {</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*横向滚动条 - 滑块*/</span></span><br><span class="line">QScrollBar::handle:horizontal {</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*垂直/横向滚动条滑块Hover效果*/</span></span><br><span class="line">QScrollBar::handle:vertical:hover,</span><br><span class="line">QScrollBar::handle:horizontal:hover {</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*垂直滚动条下部分块*/</span></span><br><span class="line">QScrollBar::add-page:vertical {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: transparent;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*垂直滚动条上面部分块*/</span></span><br><span class="line">QScrollBar::sub-page:vertical {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: transparent;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*横向滚动条右边部分块*/</span></span><br><span class="line">QScrollBar::add-page:horizontal {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: transparent;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*横向滚动条左边部分块*/</span></span><br><span class="line">QScrollBar::sub-page:horizontal {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: transparent;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ----------- 对于扁平化设计风格，下面的样式可以不用设置 ----------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*垂直滚动条顶部三角形位置*/</span></span><br><span class="line">QScrollBar::sub-line:vertical {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: transparent;</span><br><span class="line">  subcontrol-<span class="attribute">position</span>: top;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*垂直滚动条顶部三角形图标*/</span></span><br><span class="line">QScrollBar::up-arrow:vertical {</span><br><span class="line">  image: <span class="built_in">url</span>(<span class="string">:/client/images/scrollbar_arrowup_normal.png</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*垂直滚动条顶部三角形图标 鼠标Hover效果*/</span></span><br><span class="line">QScrollBar::up-arrow:vertical:hover {</span><br><span class="line">  image: <span class="built_in">url</span>(<span class="string">:/client/images/scrollbar_arrowup_down.png</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*垂直滚动条顶部三角形图标 鼠标按下效果*/</span></span><br><span class="line">QScrollBar::up-arrow:vertical:pressed {</span><br><span class="line">  image: <span class="built_in">url</span>(<span class="string">:/client/images/scrollbar_arrowup_highlight.png</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*垂直滚动条底部三角形位置*/</span></span><br><span class="line">QScrollBar::add-line:vertical {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: transparent;</span><br><span class="line">  subcontrol-<span class="attribute">position</span>: bottom;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*垂直滚动条底部三角形图标*/</span></span><br><span class="line">QScrollBar::down-arrow:vertical {</span><br><span class="line">  image: <span class="built_in">url</span>(<span class="string">:/client/images/scrollbar_arrowdown_normal.png</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*垂直滚动条底部三角形图标 鼠标Hover效果*/</span></span><br><span class="line">QScrollBar::down-arrow:vertical:hover {</span><br><span class="line">  image: <span class="built_in">url</span>(<span class="string">:/client/images/scrollbar_arrowdown_down.png</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*垂直滚动条底部三角形图标 鼠标按下效果*/</span></span><br><span class="line">QScrollBar::down-arrow:vertical:pressed {</span><br><span class="line">  image: <span class="built_in">url</span>(<span class="string">:/client/images/scrollbar_arrowdown_highlight.png</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*横向滚动条左侧三角形位置*/</span></span><br><span class="line">QScrollBar::sub-line:horizontal {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">background</span>: transparent;</span><br><span class="line">  subcontrol-<span class="attribute">position</span>: left;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*横向滚动条左侧三角形图标*/</span></span><br><span class="line">QScrollBar::left-arrow:horizontal {</span><br><span class="line">  image: <span class="built_in">url</span>(<span class="string">:/client/images/scrollbar_arrowleft_normal.png</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*横向滚动条左侧三角形图标 鼠标Hover效果*/</span></span><br><span class="line">QScrollBar::left-arrow:horizontal:hover {</span><br><span class="line">  image: <span class="built_in">url</span>(<span class="string">:/client/images/scrollbar_arrowleft_down.png</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*横向滚动条左侧三角形图标 鼠标按下效果*/</span></span><br><span class="line">QScrollBar::left-arrow:horizontal:pressed {</span><br><span class="line">  image: <span class="built_in">url</span>(<span class="string">:/client/images/scrollbar_arrowleft_highlight.png</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*横向滚动条右侧三角形部分*/</span></span><br><span class="line">QScrollBar::add-line:horizontal {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">background</span>: transparent;</span><br><span class="line">  subcontrol-<span class="attribute">position</span>: right;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*横向滚动条右侧三角形图标*/</span></span><br><span class="line">QScrollBar::right-arrow:horizontal {</span><br><span class="line">  image: <span class="built_in">url</span>(<span class="string">:/client/images/scrollbar_arrowright_normal.png</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*横向滚动条右侧三角形图标 鼠标Hover效果*/</span></span><br><span class="line">QScrollBar::right-arrow:horizontal:hover {</span><br><span class="line">  image: <span class="built_in">url</span>(<span class="string">:/client/images/scrollbar_arrowright_down.png</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*横向滚动条右侧三角形图标 鼠标按下效果*/</span></span><br><span class="line">QScrollBar::right-arrow:horizontal:pressed {</span><br><span class="line">  image: <span class="built_in">url</span>(<span class="string">:/client/images/scrollbar_arrowright_highlight.png</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt子线程中更新UI</title>
      <link href="/post/3531733309.html"/>
      <url>/post/3531733309.html</url>
      
        <content type="html"><![CDATA[<p>本文介绍两种在Qt子线程（非UI线程）中更新UI组件的方法。</p><span id="more"></span><h1 id="1-使用信号槽"><a href="#1-使用信号槽" class="headerlink" title="1. 使用信号槽"></a>1. 使用信号槽</h1><p>这是一种非常常规的方式，通过自定义信号、槽，连接该信号和槽，在子线程中发送信号，在槽中更新 UI。</p><p>定义信号和槽：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateUi</span><span class="params">(<span class="type">int</span> v)</span></span>;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onUpdateUi</span><span class="params">(<span class="type">int</span> v)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>在子线程中发送信号：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接信号</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;UpdateUIInSubThread::updateUi, <span class="keyword">this</span>, &amp;UpdateUIInSubThread::onUpdateUi, Qt::AutoConnection);</span><br><span class="line"></span><br><span class="line">std::thread t = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {</span><br><span class="line">        emit <span class="built_in">updateUi</span>(i); <span class="comment">// 发送信号</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line">t.<span class="built_in">detach</span>();</span><br></pre></td></tr></tbody></table></figure><p>在槽函数中更新 UI：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateUIInSubThread::onUpdateUi</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ui.label-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(v));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种方式需要单独额外定义信号和槽，使用起来比较繁琐。</p><h1 id="2-使用-QMetaObject-invokeMethod"><a href="#2-使用-QMetaObject-invokeMethod" class="headerlink" title="2. 使用 QMetaObject::invokeMethod"></a>2. 使用 QMetaObject::invokeMethod</h1><p>使用 QMetaObject::invokeMethod 函数的原型如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor, <span class="keyword">typename</span> FunctorReturnType&gt; <span class="function"><span class="type">bool</span> <span class="title">QMetaObject::invokeMethod</span><span class="params">(QObject *context, Functor function, Qt::ConnectionType type = Qt::AutoConnection, FunctorReturnType *ret = <span class="literal">nullptr</span>)</span></span></span><br></pre></td></tr></tbody></table></figure><p>该函数可以在<code>context</code>的事件循环中执行<code>function</code>函数。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::thread t = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {</span><br><span class="line">        <span class="keyword">if</span> (QMetaObject::<span class="built_in">invokeMethod</span>(<span class="keyword">this</span>, [i, <span class="keyword">this</span>]() {</span><br><span class="line">            ui.label-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(i));</span><br><span class="line">        })) {</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Update UI success"</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line">t.<span class="built_in">detach</span>();</span><br></pre></td></tr></tbody></table></figure><p>由于在子线程中更新 UI，因此信号和槽肯定使用的是 QueuedConnection 的连接方式，所以无法将<code>FunctorReturnType</code>返回给调用者，否则会出现如下错误：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMetaObject::invokeMethod: Unable to invoke methods with return values in queued connections</span><br></pre></td></tr></tbody></table></figure><p>当然上述示例中也可以不使用 lambda 表达式，直接调用槽函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::thread t = std::<span class="built_in">thread</span>([<span class="keyword">this</span>]() {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {</span><br><span class="line">        QMetaObject::<span class="built_in">invokeMethod</span>(<span class="keyword">this</span>, <span class="string">"onUpdateUi"</span>, Qt::AutoConnection, <span class="built_in">Q_ARG</span>(<span class="type">int</span>, i));</span><br><span class="line"></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line">t.<span class="built_in">detach</span>();</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt弹窗外部点击时自动关闭</title>
      <link href="/post/3677374843.html"/>
      <url>/post/3677374843.html</url>
      
        <content type="html"><![CDATA[<p>本文介绍在 Qt 编程中如何实现在鼠标点击弹窗外部区域时，该弹窗可以自动关闭。</p><span id="more"></span><h1 id="1-ActivationChange-事件"><a href="#1-ActivationChange-事件" class="headerlink" title="1. ActivationChange 事件"></a>1. ActivationChange 事件</h1><p>弹窗通过监听 Activation 改变事件，来判断自身是否还是当前的活动窗口，如果不是则关闭自身。</p><p>在 QWidget 里面重写 event，捕获 QEvent::ActivationChange 事件：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UserCenterDlg::event</span><span class="params">(QEvent* e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() == QEvent::ActivationChange) {</span><br><span class="line">        QWidget* curActiveWin = QApplication::<span class="built_in">activeWindow</span>();</span><br><span class="line">        <span class="keyword">if</span> (curActiveWin != <span class="keyword">this</span>) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">event</span>(e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-Qt-WA-NoMouseReplay-介绍"><a href="#2-Qt-WA-NoMouseReplay-介绍" class="headerlink" title="2. Qt::WA_NoMouseReplay 介绍"></a>2. Qt::WA_NoMouseReplay 介绍</h1><blockquote><p>摘自 Qt 帮助文档：<br>Qt::WA_NoMouseReplay: Used for pop-up widgets. Indicates that the most recent mouse press event should not be replayed when the pop-up widget closes. The flag is set by the widget’s author and cleared by the Qt kernel every time the widget receives a new mouse event.</p></blockquote><p>Qt::WA_NoMouseReplay 属性可以用来避免如下情况的发生：<br>在鼠标点击 Popup Widget 外部区域时，该 Widget 接收到自身的 Activation 状态发生改变，关闭自身，但在该 Widget 在关闭后，Qt 依然会将鼠标点击事件继续向下传递，从而窗口外区域下面的控件也会被点击。</p><p>由于 Qt::WA_NoMouseReplay 属性只对具有 Popup 属性的 Widget 起作用，因此只能使用 QWidget，不能使用 QDialog，并设置 Qt::Popup 属性。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(<span class="built_in">windowFlags</span>() | Qt::Popup);</span><br></pre></td></tr></tbody></table></figure><p>何时设置 Qt::WA_NoMouseReplay 属性了？</p><p>重写 mousePressEvent，在鼠标按下事件发生时，设置 Qt::WA_NoMouseReplay 属性。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UserCenterDlg::mousePressEvent</span><span class="params">(QMouseEvent* e)</span> </span>{</span><br><span class="line">    <span class="built_in">setAttribute</span>(Qt::WA_NoMouseReplay);</span><br><span class="line">    QWidget::<span class="built_in">mousePressEvent</span>(e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-自定义-closed-信号"><a href="#3-自定义-closed-信号" class="headerlink" title="3. 自定义 closed 信号"></a>3. 自定义 closed 信号</h1><p>QWidget 没有关闭信号，我们可以自定义关闭信号，该信号在 closeEvent 中触发。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UserCenterDlg::closeEvent</span><span class="params">(QCloseEvent* e)</span> </span>{</span><br><span class="line">    <span class="function">emit <span class="title">closed</span><span class="params">()</span></span>;</span><br><span class="line">    QWidget::<span class="built_in">closeEvent</span>(e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开源库nlohmann json使用备忘</title>
      <link href="/post/1128187204.html"/>
      <url>/post/1128187204.html</url>
      
        <content type="html"><![CDATA[<p>nlohmann/json 是一个用于解析 JSON 的开源 C++库，口碑一流，无需额外安装其他第三方库，还支持单个头文件模式，使用起来非常方便直观。</p><span id="more"></span><h1 id="1-编译"><a href="#1-编译" class="headerlink" title="1. 编译"></a>1. 编译</h1><p>从官网<a href="https://github.com/nlohmann/json">https://github.com/nlohmann/json</a>的 Release 页面下载单个<code>json.hpp</code>即可直接使用，无需单独编译。</p><h1 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2. 使用示例"></a>2. 使用示例</h1><p>下面以示例的方式罗列 nlohmann/json 库的基本使用方法。</p><h2 id="2-1-生成-JSON"><a href="#2-1-生成-JSON" class="headerlink" title="2.1 生成 JSON"></a>2.1 生成 JSON</h2><h3 id="方式-1"><a href="#方式-1" class="headerlink" title="方式 1"></a>方式 1</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line">    json j;</span><br><span class="line">    j[<span class="string">"pi"</span>] = <span class="number">3.141</span>;</span><br><span class="line">    j[<span class="string">"happy"</span>] = <span class="literal">true</span>;</span><br><span class="line">    j[<span class="string">"name"</span>] = <span class="string">"Niels"</span>;</span><br><span class="line">    j[<span class="string">"nothing"</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">    j[<span class="string">"answer"</span>][<span class="string">"everything"</span>] = <span class="number">42</span>;</span><br><span class="line">    j[<span class="string">"list"</span>] = { <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span> };</span><br><span class="line">    j[<span class="string">"object"</span>] = { {<span class="string">"currency"</span>, <span class="string">"USD"</span>}, {<span class="string">"value"</span>, <span class="number">42.99</span>} };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转成字符串</span></span><br><span class="line">    std::string strJSON = j.<span class="built_in">dump</span>(<span class="number">2</span>); <span class="comment">// 2个空格的缩进</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; strJSON;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"answer"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"everything"</span><span class="punctuation">:</span> <span class="number">42</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"happy"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"list"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"Niels"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"nothing"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"object"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"currency"</span><span class="punctuation">:</span> <span class="string">"USD"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"value"</span><span class="punctuation">:</span> <span class="number">42.99</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"pi"</span><span class="punctuation">:</span> <span class="number">3.141</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="方式-2"><a href="#方式-2" class="headerlink" title="方式 2"></a>方式 2</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line">    json j = {</span><br><span class="line">        {<span class="string">"pi"</span>, <span class="number">3.141</span>},</span><br><span class="line">        {<span class="string">"happy"</span>, <span class="literal">true</span>},</span><br><span class="line">        {<span class="string">"name"</span>, <span class="string">"Niels"</span>},</span><br><span class="line">        {<span class="string">"nothing"</span>, <span class="literal">nullptr</span>},</span><br><span class="line">        {<span class="string">"answer"</span>, {{<span class="string">"everything"</span>, <span class="number">42</span>}}},</span><br><span class="line">        {<span class="string">"list"</span>, {<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>}},</span><br><span class="line">        {<span class="string">"object"</span>, {{<span class="string">"currency"</span>, <span class="string">"USD"</span>}, {<span class="string">"value"</span>, <span class="number">42.99</span>}}}</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转成字符串</span></span><br><span class="line">    std::string strJSON = j.<span class="built_in">dump</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; strJSON;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出内容与方式 1 一样。</p><h3 id="方式-3"><a href="#方式-3" class="headerlink" title="方式 3"></a>方式 3</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line">    json j;</span><br><span class="line">    j[<span class="string">"pi"</span>] = <span class="number">3.141</span>;</span><br><span class="line">    j[<span class="string">"happy"</span>] = <span class="literal">true</span>;</span><br><span class="line">    j[<span class="string">"name"</span>] = <span class="string">"Niels"</span>;</span><br><span class="line">    j[<span class="string">"nothing"</span>] = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    json j_answer;</span><br><span class="line">    j_answer[<span class="string">"everything"</span>] = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    j[<span class="string">"answer"</span>] = j_answer;</span><br><span class="line"></span><br><span class="line">    json j_list = json::<span class="built_in">array</span>();</span><br><span class="line">    j_list.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    j_list.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    j_list.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    j[<span class="string">"list"</span>] = j_list;</span><br><span class="line"></span><br><span class="line">    json j_object;</span><br><span class="line">    j_object[<span class="string">"currency"</span>] = <span class="string">"USD"</span>;</span><br><span class="line">    j_object[<span class="string">"value"</span>] = <span class="number">42.99</span>;</span><br><span class="line"></span><br><span class="line">    j[<span class="string">"object"</span>] = j_object;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转成字符串</span></span><br><span class="line">    std::string strJSON = j.<span class="built_in">dump</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; strJSON;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出内容与方式 1 一样。</p><h2 id="2-2-解析-JSON"><a href="#2-2-解析-JSON" class="headerlink" title="2.2 解析 JSON"></a>2.2 解析 JSON</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line">    std::string strJSON = <span class="string">u8R"(</span></span><br><span class="line"><span class="string">    {</span></span><br><span class="line"><span class="string">        "answer": {</span></span><br><span class="line"><span class="string">             "everything": 42</span></span><br><span class="line"><span class="string">        },</span></span><br><span class="line"><span class="string">        "happy": true,</span></span><br><span class="line"><span class="string">        "list": [</span></span><br><span class="line"><span class="string">            1,</span></span><br><span class="line"><span class="string">            0,</span></span><br><span class="line"><span class="string">            2</span></span><br><span class="line"><span class="string">         ],</span></span><br><span class="line"><span class="string">        "name": "Niels",</span></span><br><span class="line"><span class="string">        "nothing": null,</span></span><br><span class="line"><span class="string">        "object": {</span></span><br><span class="line"><span class="string">            "currency": "USD",</span></span><br><span class="line"><span class="string">            "value": 42.99</span></span><br><span class="line"><span class="string">        },</span></span><br><span class="line"><span class="string">        "pi": 3.141</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    )"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> jsonObj = json::<span class="built_in">parse</span>(strJSON);</span><br><span class="line">    std::cout &lt;&lt; jsonObj[<span class="string">"pi"</span>].<span class="built_in">get</span>&lt;<span class="type">float</span>&gt;() &lt;&lt; std::endl; <span class="comment">// 3.141</span></span><br><span class="line">    std::cout &lt;&lt; jsonObj[<span class="string">"pi"</span>].<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;() &lt;&lt; std::endl; <span class="comment">// 3.141</span></span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; jsonObj[<span class="string">"happy"</span>].<span class="built_in">get</span>&lt;<span class="type">bool</span>&gt;() &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; jsonObj[<span class="string">"name"</span>].<span class="built_in">get</span>&lt;std::string&gt;() &lt;&lt; std::endl; <span class="comment">// Niels</span></span><br><span class="line">    <span class="built_in">assert</span>(jsonObj[<span class="string">"nothing"</span>] == <span class="literal">nullptr</span>);</span><br><span class="line">    std::cout &lt;&lt; jsonObj[<span class="string">"answer"</span>][<span class="string">"everything"</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;() &lt;&lt; std::endl; <span class="comment">// 42</span></span><br><span class="line">    std::cout &lt;&lt; jsonObj[<span class="string">"list"</span>].<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 3</span></span><br><span class="line">    std::cout &lt;&lt; jsonObj[<span class="string">"list"</span>][<span class="number">0</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;() &lt;&lt; std::endl; <span class="comment">// 1</span></span><br><span class="line">    std::cout &lt;&lt; jsonObj[<span class="string">"list"</span>][<span class="number">1</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;() &lt;&lt; std::endl; <span class="comment">// 0</span></span><br><span class="line">    std::cout &lt;&lt; jsonObj[<span class="string">"list"</span>][<span class="number">2</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;() &lt;&lt; std::endl; <span class="comment">// 2</span></span><br><span class="line">    std::cout &lt;&lt; jsonObj[<span class="string">"object"</span>][<span class="string">"currency"</span>].<span class="built_in">get</span>&lt;std::string&gt;() &lt;&lt; std::endl; <span class="comment">// USD</span></span><br><span class="line">    std::cout &lt;&lt; jsonObj[<span class="string">"object"</span>][<span class="string">"value"</span>].<span class="built_in">get</span>&lt;<span class="type">float</span>&gt;() &lt;&lt; std::endl; <span class="comment">// 42.99</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次输出:</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (json::iterator it = jsonObj[<span class="string">"list"</span>].<span class="built_in">begin</span>(); it != jsonObj[<span class="string">"list"</span>].<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3. 异常处理"></a>3. 异常处理</h1><p>当解析和生成 JSON 出错时，nlohmann/json 会抛出异常，因此在解析和生成 JSON 时，需要进行异常捕获。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line">    std::string strJSON = <span class="string">u8R"(</span></span><br><span class="line"><span class="string">    {</span></span><br><span class="line"><span class="string">        "pi": 3.141</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    )"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">auto</span> jsonObj = json::<span class="built_in">parse</span>(strJSON);</span><br><span class="line">        std::cout &lt;&lt; jsonObj[<span class="string">"ppp"</span>].<span class="built_in">get</span>&lt;<span class="type">float</span>&gt;() &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) {</span><br><span class="line">        std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4-判断成员是否存在"><a href="#4-判断成员是否存在" class="headerlink" title="4. 判断成员是否存在"></a>4. 判断成员是否存在</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line">    std::string strJSON = <span class="string">u8R"(</span></span><br><span class="line"><span class="string">    {</span></span><br><span class="line"><span class="string">        "pi": 3.141</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    )"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> jsonObj = json::<span class="built_in">parse</span>(strJSON);</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; jsonObj.<span class="built_in">contains</span>(<span class="string">"pi"</span>) &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; jsonObj.<span class="built_in">contains</span>(<span class="string">"ppp"</span>) &lt;&lt; std::endl; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑪ 开源库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++字符串和字符字面量</title>
      <link href="/post/487899896.html"/>
      <url>/post/487899896.html</url>
      
        <content type="html"><![CDATA[<p>C++支持各种字符串和字符类型，并提供了表达每种类型字面值的方法。在源代码中，我们使用字符集来表示字符或字符串。同时我们还可以使用通用字符名和转义字符来通过基本的源字符集表示任何字符串。而原始字符串能够避免对转义字符进行转义，并可用于表示所有类型的字符串。</p><span id="more"></span><h1 id="1-字符和字符串字面量"><a href="#1-字符和字符串字面量" class="headerlink" title="1. 字符和字符串字面量"></a>1. 字符和字符串字面量</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Character literals</span></span><br><span class="line">    <span class="keyword">auto</span> c0 =   <span class="string">'A'</span>; <span class="comment">// char</span></span><br><span class="line">    <span class="keyword">auto</span> c1 = <span class="string">u8'A'</span>; <span class="comment">// char</span></span><br><span class="line">    <span class="keyword">auto</span> c2 =  <span class="string">L'A'</span>; <span class="comment">// wchar_t</span></span><br><span class="line">    <span class="keyword">auto</span> c3 =  <span class="string">u'A'</span>; <span class="comment">// char16_t</span></span><br><span class="line">    <span class="keyword">auto</span> c4 =  <span class="string">U'A'</span>; <span class="comment">// char32_t</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Multicharacter literals</span></span><br><span class="line">    <span class="keyword">auto</span> m0 = <span class="string">'abcd'</span>; <span class="comment">// int, value 0x61626364</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// String literals</span></span><br><span class="line">    <span class="keyword">auto</span> s0 =   <span class="string">"hello"</span>; <span class="comment">// const char*</span></span><br><span class="line">    <span class="keyword">auto</span> s1 = <span class="string">u8"hello"</span>; <span class="comment">// const char* before C++20, encoded as UTF-8,</span></span><br><span class="line">                         <span class="comment">// const char8_t* in C++20</span></span><br><span class="line">    <span class="keyword">auto</span> s2 =  <span class="string">L"hello"</span>; <span class="comment">// const wchar_t*</span></span><br><span class="line">    <span class="keyword">auto</span> s3 =  <span class="string">u"hello"</span>; <span class="comment">// const char16_t*, encoded as UTF-16</span></span><br><span class="line">    <span class="keyword">auto</span> s4 =  <span class="string">U"hello"</span>; <span class="comment">// const char32_t*, encoded as UTF-32</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-原始字符串"><a href="#2-原始字符串" class="headerlink" title="2. 原始字符串"></a>2. 原始字符串</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Raw string literals containing unescaped \ and "</span></span><br><span class="line">    <span class="keyword">auto</span> R0 =   <span class="string">R"("Hello \ world")"</span>; <span class="comment">// const char*</span></span><br><span class="line">    <span class="keyword">auto</span> R1 = <span class="string">u8R"("Hello \ world")"</span>; <span class="comment">// const char* before C++20, encoded as UTF-8,</span></span><br><span class="line">                                      <span class="comment">// const char8_t* in C++20</span></span><br><span class="line">    <span class="keyword">auto</span> R2 =  <span class="string">LR"("Hello \ world")"</span>; <span class="comment">// const wchar_t*</span></span><br><span class="line">    <span class="keyword">auto</span> R3 =  <span class="string">uR"("Hello \ world")"</span>; <span class="comment">// const char16_t*, encoded as UTF-16</span></span><br><span class="line">    <span class="keyword">auto</span> R4 =  <span class="string">UR"("Hello \ world")"</span>; <span class="comment">// const char32_t*, encoded as UTF-32</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-字符串后缀"><a href="#3-字符串后缀" class="headerlink" title="3. 字符串后缀"></a>3. 字符串后缀</h1><p>字符串后缀就是在字符串后面加<code>s</code>，如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> S0 =   <span class="string">"hello"</span>s; <span class="comment">// std::string</span></span><br><span class="line"><span class="keyword">auto</span> S1 = <span class="string">u8"hello"</span>s; <span class="comment">// std::string before C++20, std::u8string in C++20</span></span><br><span class="line"><span class="keyword">auto</span> S2 =  <span class="string">L"hello"</span>s; <span class="comment">// std::wstring</span></span><br><span class="line"><span class="keyword">auto</span> S3 =  <span class="string">u"hello"</span>s; <span class="comment">// std::u16string</span></span><br><span class="line"><span class="keyword">auto</span> S4 =  <span class="string">U"hello"</span>s; <span class="comment">// std::u32string</span></span><br><span class="line">std::string_view sv = <span class="string">"abc\0\0def"</span>sv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和原始字符串一起使用</span></span><br><span class="line"><span class="keyword">auto</span> S5 =   <span class="string">R"("Hello \ world")"</span>s; <span class="comment">// std::string from a raw const char*</span></span><br><span class="line"><span class="keyword">auto</span> S6 = <span class="string">u8R"("Hello \ world")"</span>s; <span class="comment">// std::string from a raw const char* before C++20, encoded as UTF-8,</span></span><br><span class="line">                                    <span class="comment">// std::u8string in C++20</span></span><br><span class="line"><span class="keyword">auto</span> S7 =  <span class="string">LR"("Hello \ world")"</span>s; <span class="comment">// std::wstring from a raw const wchar_t*</span></span><br><span class="line"><span class="keyword">auto</span> S8 =  <span class="string">uR"("Hello \ world")"</span>s; <span class="comment">// std::u16string from a raw const char16_t*, encoded as UTF-16</span></span><br><span class="line"><span class="keyword">auto</span> S9 =  <span class="string">UR"("Hello \ world")"</span>s; <span class="comment">// std::u32string from a raw const char32_t*, encoded as UTF-32</span></span><br></pre></td></tr></tbody></table></figure><p>和不加后缀的区别如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_with_zeros</span><span class="params">(<span class="keyword">auto</span> <span class="type">const</span> note, std::string <span class="type">const</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::cout &lt;&lt; note;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> c : s)</span><br><span class="line">        c ? std::cout &lt;&lt; c : std::cout &lt;&lt; <span class="string">"₀"</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">" (size = "</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</span><br><span class="line"></span><br><span class="line">    std::string s1 = <span class="string">"abc\0\0def"</span>;</span><br><span class="line">    std::string s2 = <span class="string">"abc\0\0def"</span>s;</span><br><span class="line">    <span class="built_in">print_with_zeros</span>(<span class="string">"s1: "</span>, s1);</span><br><span class="line">    <span class="built_in">print_with_zeros</span>(<span class="string">"s2: "</span>, s2);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"abcdef"</span>s.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1: abc (size = 3)</span><br><span class="line">s2: abc₀₀def (size = 8)</span><br><span class="line">bcde</span><br></pre></td></tr></tbody></table></figure><h1 id="4-自定义字符串后缀"><a href="#4-自定义字符串后缀" class="headerlink" title="4. 自定义字符串后缀"></a>4. 自定义字符串后缀</h1><p>字符串后缀是通过操作符的重载实现的：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string <span class="keyword">operator</span><span class="string">""</span><span class="built_in">s</span>( <span class="type">const</span> <span class="type">char</span> *str, std::<span class="type">size_t</span> len );</span><br></pre></td></tr></tbody></table></figure><p>我们也可以自定义操作符的重载来实现其他的字符串后缀，自定义的后缀建议以下划线开头，否则会产生编译警告：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning C4455: “operator ""mm”: 已保留不以下划线开头的文本后缀标识符</span><br></pre></td></tr></tbody></table></figure><p>下面自定义<code>_mm</code>、<code>_m</code>、<code>_km</code>后缀分别表示毫米、米、千米：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="keyword">operator</span><span class="string">""</span> _mm(<span class="type">long</span> <span class="type">double</span> x) {</span><br><span class="line">    <span class="keyword">return</span> x / <span class="number">1000</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="keyword">operator</span><span class="string">""</span> _m(<span class="type">long</span> <span class="type">double</span> x) {</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="keyword">operator</span><span class="string">""</span> _km(<span class="type">long</span> <span class="type">double</span> x) {</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">1000</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="number">1.0</span>_mm &lt;&lt; std::endl; <span class="comment">// 0.001</span></span><br><span class="line">    std::cout &lt;&lt; <span class="number">1.0</span>_m &lt;&lt; std::endl;  <span class="comment">// 1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="number">1.0</span>_km &lt;&lt; std::endl; <span class="comment">// 1000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7申请免费LetsEncrypt证书并续期</title>
      <link href="/post/2025031576.html"/>
      <url>/post/2025031576.html</url>
      
        <content type="html"><![CDATA[<p>本文介绍在 CentOS7 环境下，使用 Certbot 申请免费的 Lets Encrypt SSL 证书，并自动续期。</p><span id="more"></span><h1 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h1><p>安装 Python3：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install python3</span><br></pre></td></tr></tbody></table></figure><p>安装 Certbot 和 Python 虚拟环境：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设certbot安装到/root/certbot</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /root/certbot</span><br><span class="line"><span class="built_in">cd</span> /root/certbot</span><br><span class="line">python3 -m venv venv</span><br><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级pip</span></span><br><span class="line">pip install --upgrade pip</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>阿里云注册并解析的域名，执行如下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装certbot</span></span><br><span class="line">pip install certbot certbot-nginx certbot-dns-aliyun -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></tbody></table></figure><h1 id="2-阿里云子账号"><a href="#2-阿里云子账号" class="headerlink" title="2. 阿里云子账号"></a>2. 阿里云子账号</h1><p>创建阿里云子账号（<a href="https://ram.console.aliyun.com/">https://ram.console.aliyun.com</a>），并分配 AliyunDNSFullAccess 权限。</p><p>为子账号生成 access_key 和 access_secret。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/centos-lets-ssl-1.png"></p><p>创建<code>/root/certbot/aliyun.ini</code>文件，内容如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dns_aliyun_access_key = XXXXX</span><br><span class="line">dns_aliyun_access_key_secret = XXXXX</span><br></pre></td></tr></tbody></table></figure><p>使用如下命令修改该文件权限：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 /root/certbot/aliyun.ini</span><br></pre></td></tr></tbody></table></figure><h1 id="3-申请证书"><a href="#3-申请证书" class="headerlink" title="3. 申请证书"></a>3. 申请证书</h1><p>以申请 mytools123.com 证书为例：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/root/certbot/venv/bin/certbot certonly \</span><br><span class="line">-a dns-aliyun \</span><br><span class="line">--dns-aliyun-credentials /root/certbot/aliyun.ini \</span><br><span class="line">-d mytools123.com \</span><br><span class="line">-d <span class="string">"*.mytools123.com"</span></span><br></pre></td></tr></tbody></table></figure><p>执行成功后，生成的证书位于<code>/etc/letsencrypt/live/mytools123.com</code>目录</p><h1 id="4-手动续期"><a href="#4-手动续期" class="headerlink" title="4. 手动续期"></a>4. 手动续期</h1><p>Lets Encrypt 的证书有效期只有 3 个月，到期后需要手动续期。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --dry-run 的是模拟更新证书</span></span><br><span class="line">/root/certbot/venv/bin/certbot renew -a dns-aliyun --dns-aliyun-credentials /root/certbot/aliyun.ini --dry-run</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正式更新证书</span></span><br><span class="line">/root/certbot/venv/bin/certbot renew -a dns-aliyun --dns-aliyun-credentials /root/certbot/aliyun.ini</span><br></pre></td></tr></tbody></table></figure><h1 id="5-自动续期"><a href="#5-自动续期" class="headerlink" title="5. 自动续期"></a>5. 自动续期</h1><p>可以创建定时续期脚本，来实现自动续期。</p><p>创建脚本文件<code>/root/renew_cert.sh</code>，内容如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新证书</span></span><br><span class="line">/root/certbot/venv/bin/certbot renew -a dns-aliyun --dns-aliyun-credentials /root/certbot/aliyun.ini</span><br></pre></td></tr></tbody></table></figure><p>为 sh 添加可执行权限：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /root/renew_cert.sh</span><br></pre></td></tr></tbody></table></figure><p>新建定时任务：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></tbody></table></figure><p>新增如下内容：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0,12 * * * python -c <span class="string">'import random; import time; time.sleep(random.random() * 3600)'</span> &amp;&amp; /root/renew_cert.sh</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑥ 服务器开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> LetsEncrypt </tag>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vcpkg访问Github私有仓库</title>
      <link href="/post/1904533666.html"/>
      <url>/post/1904533666.html</url>
      
        <content type="html"><![CDATA[<p>Vcpkg 默认只支持从公共代码仓库进行下载编译，本文介绍如何使用 Vcpkg 从私有仓库进行源码下载/编译/安装。</p><span id="more"></span><h2 id="1-在-Github-中添加-TOKEN"><a href="#1-在-Github-中添加-TOKEN" class="headerlink" title="1.在 Github 中添加 TOKEN"></a>1.在 Github 中添加 TOKEN</h2><p><img src="https://blog-static.jiangxueqiao.com/blog/img/vcpkg-private-repo-1.png"></p><h2 id="2-添加-Windows-环境变量："><a href="#2-添加-Windows-环境变量：" class="headerlink" title="2. 添加 Windows 环境变量："></a>2. 添加 Windows 环境变量：</h2><p><code>VCPKG_KEEP_ENV_VARS</code>值为<code>GITHUB_TOKEN</code></p><p><code>GITHUB_TOKEN</code>值为第一步生成的 TOKEN</p><h2 id="3-修改-portfile-cmake"><a href="#3-修改-portfile-cmake" class="headerlink" title="3.修改 portfile.cmake"></a>3.修改 portfile.cmake</h2><p>在<code>vcpkg\ports</code>目录下，找到对应库的 portfile.cmake 文件，加入<code>AUTHORIZATION_TOKEN</code>参数。</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vcpkg_from_github(</span><br><span class="line">    OUT_SOURCE_PATH SOURCE_PATH</span><br><span class="line">    REPO xxx/xxx</span><br><span class="line">    HEAD_REF main</span><br><span class="line">    AUTHORIZATION_TOKEN $ENV{GITHUB_TOKEN}</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑩ 编程基础 </category>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vcpkg </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows实现文件强制占用</title>
      <link href="/post/434128163.html"/>
      <url>/post/434128163.html</url>
      
        <content type="html"><![CDATA[<p>本文介绍在 Windows 系统上实现使某个文件无法被用户或其他程序删除。</p><span id="more"></span><p>实现的原理大致如下：</p><p>通过<code>DuplicateHandle</code>拷贝文件句柄给另外一个进程（一般是系统进程），因为系统进程不会被关闭，所以达到了占用某个文件，不让其他进程删除、读取、写入等。</p><p><code>DuplicateHandle</code>的用法参考：- <a href="/post/14744864.html" title="Windows内核对象">Windows内核对象</a></p><p>因为需要拷贝文件句柄给系统进程，所以涉及到打开系统进程，可能需要提权操作，一般授权给进程<code>SE_DEBUG_NAME</code>权限即可。</p><p>实现一个用于锁住文件的函数<code>LockFile</code>，将文件句柄复制给系统<code>csrss.exe</code>进程，函数实现如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LockFile</span><span class="params">(LPCTSTR lpFilePath)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (lpFilePath == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找进程csrss.exe</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  DWORD dwCsrssProcessID = <span class="number">0</span>;</span><br><span class="line">  PROCESSENTRY32 pe;</span><br><span class="line">  pe.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">  HANDLE hSnapShot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(hSnapShot, &amp;pe)) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lstrcmpi</span>(pe.szExeFile, <span class="built_in">TEXT</span>(<span class="string">"csrss.exe"</span>)) == <span class="number">0</span>) {</span><br><span class="line">      dwCsrssProcessID = pe.th32ProcessID;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CloseHandle</span>(hSnapShot);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 未找到</span></span><br><span class="line">  <span class="keyword">if</span> (dwCsrssProcessID == <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_DUP_HANDLE, FALSE, dwCsrssProcessID);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开失败，可能是当前进程未提权导致，需要提前进行提权操作</span></span><br><span class="line">  <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  HANDLE hFile = <span class="built_in">CreateFile</span>(lpFilePath,</span><br><span class="line">    GENERIC_READ | GENERIC_EXECUTE | GENERIC_WRITE,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    OPEN_ALWAYS,</span><br><span class="line">    FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">    <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) {</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  HANDLE hTargetHandle = INVALID_HANDLE_VALUE;</span><br><span class="line">  BOOL bRet = <span class="built_in">DuplicateHandle</span>(<span class="built_in">GetCurrentProcess</span>(),</span><br><span class="line">    hFile,</span><br><span class="line">    hProcess,</span><br><span class="line">    &amp;hTargetHandle,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    FALSE,</span><br><span class="line">    DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (bRet == TRUE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vcpkg安装port历史版本</title>
      <link href="/post/1142527271.html"/>
      <url>/post/1142527271.html</url>
      
        <content type="html"><![CDATA[<p><strong>截至 2023-05-22：vcpkg 仅支持在 manifest 模式下指定 port 的版本，在命令行模式下不支持指定 port 版本。</strong></p><p>本文介绍如何在 Vcpkg 命令行模式下安装 port 时如何指定版本。</p><span id="more"></span><p>使用 Git 命令查看当前 Vcpkg 仓库的 baseline：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-parse HEAD</span><br></pre></td></tr></tbody></table></figure><p>创建<code>vcpkg_json</code>目录，并在该目录下创建<code>vcpkg.json</code>文件（以 openssl 为例）：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"cc"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.1"</span>,</span><br><span class="line">  <span class="string">"builtin-baseline"</span>: <span class="string">"7b30311f0a79d395bf2d933d82fec1853c6a4e77"</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: [</span><br><span class="line">    {<span class="string">"name"</span>: <span class="string">"openssl"</span>}</span><br><span class="line">  ],</span><br><span class="line">   <span class="string">"overrides"</span>: [</span><br><span class="line">        { <span class="string">"name"</span>: <span class="string">"openssl"</span>, <span class="string">"version-string"</span>: <span class="string">"1.1.1n#1"</span> }</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用如下命令安装：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install --triplet <span class="string">"x64-windows"</span> <span class="string">"--x-manifest-root=D:\vcpkg_json\\"</span> <span class="string">"--x-install-root=D:CODE\vcpkg\installed\\"</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑩ 编程基础 </category>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vcpkg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7更新国内阿里源</title>
      <link href="/post/1822204079.html"/>
      <url>/post/1822204079.html</url>
      
        <content type="html"><![CDATA[<p>依次执行如下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份并下载阿里云的base和epel源</span></span><br><span class="line"><span class="built_in">mv</span> -f /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="built_in">mv</span> /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backup</span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line">yum -y update</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑥ 服务器开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake依赖库查找相关问题</title>
      <link href="/post/2291877732.html"/>
      <url>/post/2291877732.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-如何查找-Vcpkg-安装的依赖库"><a href="#1-如何查找-Vcpkg-安装的依赖库" class="headerlink" title="1. 如何查找 Vcpkg 安装的依赖库"></a>1. 如何查找 Vcpkg 安装的依赖库</h1><p>在 CMake 工具中指定跨平台工具链，如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/vcpkg-package-find-1.png"></p><p>指定 Toolchain 文件<code>D:/sourcecode/vcpkg/scripts/buildsystems/vcpkg.cmake</code>。</p><span id="more"></span><h1 id="2-如何查找本机安装的-Qt-库"><a href="#2-如何查找本机安装的-Qt-库" class="headerlink" title="2. 如何查找本机安装的 Qt 库"></a>2. 如何查找本机安装的 Qt 库</h1><p>设置环境变量<code>CMAKE_PREFIX_PATH</code>，值为 Qt 的安装目录，如<code>C:\Qt\5.15.2\msvc2019</code>，然后启动 CMake 即可。</p><p>也可以使用如下批处理来临时设置和启动：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> CMAKE_PREFIX_PATH=C:\Qt\5.15.2\msvc2019</span><br><span class="line">start <span class="string">""</span> <span class="string">"C:\Program Files\CMake\bin\cmake-gui.exe"</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑩ 编程基础 </category>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vcpkg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NPM和Yarn设置国内源</title>
      <link href="/post/908211703.html"/>
      <url>/post/908211703.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Yarn-设置"><a href="#1-Yarn-设置" class="headerlink" title="1. Yarn 设置"></a>1. Yarn 设置</h1><p>查看当前使用的镜像源：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn config get registry</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p>全局修改：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yarn config <span class="built_in">set</span> registry https://registry.npm.taobao.org -g</span><br><span class="line">yarn config <span class="built_in">set</span> disturl https://npm.taobao.org/dist -g</span><br><span class="line">yarn config <span class="built_in">set</span> electron_mirror https://npm.taobao.org/mirrors/electron/ -g</span><br><span class="line">yarn config <span class="built_in">set</span> sass_binary_site https://npm.taobao.org/mirrors/node-sass/ -g</span><br><span class="line">yarn config <span class="built_in">set</span> phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/ -g</span><br><span class="line">yarn config <span class="built_in">set</span> chromedriver_cdnurl https://cdn.npm.taobao.org/dist/chromedriver -g</span><br><span class="line">yarn config <span class="built_in">set</span> operadriver_cdnurl https://cdn.npm.taobao.org/dist/operadriver -g</span><br><span class="line">yarn config <span class="built_in">set</span> fse_binary_host_mirror https://npm.taobao.org/mirrors/fsevents -g</span><br></pre></td></tr></tbody></table></figure><p>临时修改：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn save 软件名 --registry https://registry.npm.taobao.org/</span><br></pre></td></tr></tbody></table></figure><h1 id="2-NPM-设置"><a href="#2-NPM-设置" class="headerlink" title="2. NPM 设置"></a>2. NPM 设置</h1><p>查看当前使用的镜像源：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm get registry</span><br></pre></td></tr></tbody></table></figure><p>全局设置：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">npm config <span class="built_in">set</span> disturl https://npm.taobao.org/dist</span><br><span class="line">npm config <span class="built_in">set</span> electron_mirror https://npm.taobao.org/mirrors/electron/</span><br><span class="line">npm config <span class="built_in">set</span> sass_binary_site https://npm.taobao.org/mirrors/node-sass/</span><br><span class="line">npm config <span class="built_in">set</span> phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/</span><br></pre></td></tr></tbody></table></figure><p>npm v9 版本会报错：<code>ELECTRON_MIRROR</code> is not a valid npm option。<br>需要切换为 npm v8 版本：<code>npm install -g npm@^8</code></p>]]></content>
      
      
      <categories>
          
          <category> ⑫ Web开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LLVM-Obfuscator代码混淆</title>
      <link href="/post/2256274631.html"/>
      <url>/post/2256274631.html</url>
      
        <content type="html"><![CDATA[<p>LLVM-Obfuscator 可用于混淆程序的代码逻辑，本文介绍如何使用 LLVM-Obfuscator 进行代码逻辑的混淆。</p><span id="more"></span><h1 id="1-安装-VS-Clang-组件"><a href="#1-安装-VS-Clang-组件" class="headerlink" title="1. 安装 VS Clang 组件"></a>1. 安装 VS Clang 组件</h1><p><img src="https://blog-static.jiangxueqiao.com/blog/img/LLVM-Obfuscator-1.png"></p><h1 id="2-编译-LLVM-Obfuscator"><a href="#2-编译-LLVM-Obfuscator" class="headerlink" title="2. 编译 LLVM-Obfuscator"></a>2. 编译 LLVM-Obfuscator</h1><p>使用 heroims 的 Fork 版本：<a href="https://github.com/heroims/obfuscator">heroims/obfuscator</a></p><h2 id="2-1-Clone-最新-13-x-分支"><a href="#2-1-Clone-最新-13-x-分支" class="headerlink" title="2.1 Clone 最新 13.x 分支"></a>2.1 Clone 最新 13.x 分支</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b llvm-13.x https://github.com/obfuscator-llvm/obfuscator.git</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2-安装-mingw"><a href="#2-2-安装-mingw" class="headerlink" title="2.2 安装 mingw"></a>2.2 安装 mingw</h2><p>从<a href="https://github.com/niXman/mingw-builds-binaries/releases">https://github.com/niXman/mingw-builds-binaries/releases</a> 下载 32 位和 64 位 MingW:</p><ul><li>i686-12.2.0-release-posix-dwarf-msvcrt-rt_v10-rev2.7z</li><li>x86_64-12.2.0-release-posix-seh-msvcrt-rt_v10-rev2.7z</li></ul><p>分别解压到不同的目录。</p><h2 id="2-3-编译-64-位-LLVM-Obfuscator"><a href="#2-3-编译-64-位-LLVM-Obfuscator" class="headerlink" title="2.3 编译 64 位 LLVM-Obfuscator"></a>2.3 编译 64 位 LLVM-Obfuscator</h2><p>打开 CMD，将 64 位 MingW 的 bin 目录添加到 PATH 环境变量：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PATH=%PATH%;C:\mingw64\x86_64-12.2.0-release-posix-seh-msvcrt-rt_v10-rev2\bin</span><br></pre></td></tr></tbody></table></figure><p>在命令行进入 LLVM-Obfuscator 所在目录，开始编译：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> build64</span><br><span class="line"><span class="built_in">cd</span> build64</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=<span class="string">"clang"</span> -DLLVM_CREATE_XCODE_TOOLCHAIN=ON -DLLVM_ENABLE_NEW_PASS_MANAGER=OFF -G <span class="string">"MinGW Makefiles"</span> ../llvm</span><br><span class="line">mingw32-make.exe -j8</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-4-编译-32-位-LLVM-Obfuscator"><a href="#2-4-编译-32-位-LLVM-Obfuscator" class="headerlink" title="2.4 编译 32 位 LLVM-Obfuscator"></a>2.4 编译 32 位 LLVM-Obfuscator</h2><p>重新打开 CMD，将 32 位 MingW 的 bin 目录添加到 PATH 环境变量：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PATH=%PATH%;C:\mingw32\i686-12.2.0-release-posix-dwarf-msvcrt-rt_v10-rev2\bin</span><br></pre></td></tr></tbody></table></figure><p>在命令行进入 LLVM-Obfuscator 所在目录，开始编译：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build32</span><br><span class="line"><span class="built_in">cd</span> build32</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=<span class="string">"clang"</span> -DLLVM_CREATE_XCODE_TOOLCHAIN=ON -DLLVM_ENABLE_NEW_PASS_MANAGER=OFF -G <span class="string">"MinGW Makefiles"</span> ../llvm</span><br><span class="line">mingw32-make.exe -j8</span><br></pre></td></tr></tbody></table></figure><h1 id="3-用编译输出覆盖到-VS-Clang"><a href="#3-用编译输出覆盖到-VS-Clang" class="headerlink" title="3. 用编译输出覆盖到 VS Clang"></a>3. 用编译输出覆盖到 VS Clang</h1><p>Visual Studio 的 Clang 位于<code>C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\Llvm</code>目录，分别将编译的 32 位和 64 位<code>bin</code>目录中的文件覆盖到 VS Clang 的<code>bin</code>目录中（注意：在覆盖之前，最好先备份）。</p><h1 id="4-设置环境变量"><a href="#4-设置环境变量" class="headerlink" title="4. 设置环境变量"></a>4. 设置环境变量</h1><p>在编译完之后，将 32 位和 64 位 MingW 的<code>bin</code>目录路径都添加到 PATH 环境变量中。因为 VS 编译时会启动 clang.exe，而 clang.exe 需要依赖 MingW。</p><h1 id="5-VS-工程配置"><a href="#5-VS-工程配置" class="headerlink" title="5. VS 工程配置"></a>5. VS 工程配置</h1><p><img src="https://blog-static.jiangxueqiao.com/blog/img/LLVM-Obfuscator-2.png"></p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/LLVM-Obfuscator-3.png"></p><p>命令行其他选项如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D__CUDACC__ -D_ALLOW_COMPILER_AND_STL_VERSION_MISMATCH -mllvm -bcf -mllvm -bcf_prob=73 -mllvm -bcf_loop=1 -mllvm -sub -mllvm -sub_loop=5 -mllvm -fla -mllvm -split_num=5 -mllvm -aesSeed=DEADBEEFDEADCODEDEADBEEFDEADCODE</span><br></pre></td></tr></tbody></table></figure><h1 id="6-混淆配置参数"><a href="#6-混淆配置参数" class="headerlink" title="6. 混淆配置参数"></a>6. 混淆配置参数</h1><h3 id="开启控制流扁平化"><a href="#开启控制流扁平化" class="headerlink" title="开启控制流扁平化"></a>开启控制流扁平化</h3><p><code>-mllvm -fla</code> 开启控制流扁平化</p><p><code>-mllvm -split</code> 激活基本块划分。一起使用时能提高打平能力。</p><p><code>-mllvm -split_num=3</code> 如果激活控制流打平，对每一个基本块应用三次控制流打平。默认使用 1 次。</p><h3 id="开启指令替换"><a href="#开启指令替换" class="headerlink" title="开启指令替换"></a>开启指令替换</h3><p><code>-mllvm -sub</code> 开启指令替换</p><p><code>-mllvm -sub_loop=3</code> 如果激活了指令替换，使用这个选项在一个函数中应用 3 次指令替换。默认应用 1 次。</p><h3 id="开启虚假控制流"><a href="#开启虚假控制流" class="headerlink" title="开启虚假控制流"></a>开启虚假控制流</h3><p><code>-mllvm -bcf</code> 开启虚假控制流。</p><p><code>bcf</code>可以配合下面参数使用：</p><p><code>-mllvm -bcf_loop=3</code> 设置函数混淆次数为 3 次 不加此选项默认为 1 次。</p><p><code>-mllvm -bcf_prob=40</code> 设置代码块被混淆的概率是 40%，默认 30%</p><h1 id="7-CMakeList-中配置混淆参数"><a href="#7-CMakeList-中配置混淆参数" class="headerlink" title="7. CMakeList 中配置混淆参数"></a>7. CMakeList 中配置混淆参数</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#debug and release all enable</span><br><span class="line">SET(CMAKE_CXX_FLAGS "-mllvm -fla -mllvm -sub -mllvm -sobf  ")</span><br><span class="line"></span><br><span class="line">#so体积优化，（按需开启）</span><br><span class="line">#SET(CMAKE_CXX_FLAGS_DEBUG "$ENV{CXXFLAGS}   -O0 -Wall -g2 -ggdb")</span><br><span class="line">#SET(CMAKE_CXX_FLAGS_RELEASE "$ENV{CXXFLAGS}  -Os -Wall -s")</span><br><span class="line"></span><br><span class="line">#设置llvm debug模式混淆编译</span><br><span class="line">SET(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -mllvm -fla")</span><br><span class="line">SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -mllvm -fla")</span><br><span class="line"></span><br><span class="line">#设置llvm release模式混淆编译</span><br><span class="line">SET(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -mllvm -fla -mllvm -sub -mllvm -bcf")</span><br><span class="line">SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -mllvm -fla -mllvm -sub -mllvm -bcf")</span><br><span class="line"></span><br><span class="line">SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -s -O3 -Wall -fvisibility=hidden  -mllvm -fla")</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个Dockerfile同时运行多个进程</title>
      <link href="/post/2409581593.html"/>
      <url>/post/2409581593.html</url>
      
        <content type="html"><![CDATA[<p>Docker 容器的哲学是一个 Docker 容器只运行一个进程。</p><p>但如果需要在一个容器内运行多个进程或服务，可以采取将入口文件设置为 Bash Shell 脚本，在脚本内运行多个程序的方式。</p><span id="more"></span><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start 1</span></span><br><span class="line">start1  &gt; /var/log/start1.<span class="built_in">log</span> 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="comment"># start 2</span></span><br><span class="line">start2 &gt; /var/log/start2.<span class="built_in">log</span> 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># just keep this script running</span></span><br><span class="line"><span class="keyword">while</span> [[ <span class="literal">true</span> ]]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure><p>在 Dockerfile 的入口中运行 run.sh：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line">...</span><br><span class="line">COPY ./run.sh /</span><br><span class="line">ENTRYPOINT  [<span class="string">"run.sh"</span>]</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑥ 服务器开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++构造函数排雷</title>
      <link href="/post/3768553066.html"/>
      <url>/post/3768553066.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、默认构造函数"><a href="#一、默认构造函数" class="headerlink" title="一、默认构造函数"></a>一、默认构造函数</h1><h2 id="1-1-什么是默认构造函数？"><a href="#1-1-什么是默认构造函数？" class="headerlink" title="1.1 什么是默认构造函数？"></a>1.1 什么是默认构造函数？</h2><p>我们一般会认为默认构造函数就是编译器自动生成的那个构造函数，其实这种理解不全面。<br><strong>准确的说，默认构造函数就是在调用时不需要显示地传入实参的构造函数。</strong>根据这个原则，下面 2 种构造函数都是默认构造函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 默认构造函数。</span></span><br><span class="line">  <span class="built_in">Sample</span>() {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 默认构造函数。虽然有形参，但有默认值，调用的时候可以不显示的传入实参。</span></span><br><span class="line">  <span class="built_in">Sample</span>(<span class="type">int</span> m = <span class="number">10</span>) {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h2 id="1-2-默认构造函数调用时机"><a href="#1-2-默认构造函数调用时机" class="headerlink" title="1.2 默认构造函数调用时机"></a>1.2 默认构造函数调用时机</h2><p>如果定义一个对象时没有使用初始化式，编译器就会使用默认构造函数。如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sample s;</span><br></pre></td></tr></tbody></table></figure><h2 id="1-3-编译器何时生成默认构造函数"><a href="#1-3-编译器何时生成默认构造函数" class="headerlink" title="1.3 编译器何时生成默认构造函数"></a>1.3 编译器何时生成默认构造函数</h2><p>有一句很经典的话可以用来回答这个问题：<strong>惟有默认构造函数”被编译器需要“的时候，编译器才会生成默认构造函数。</strong></p><p>那我们只需知道什么时候“被编译器需要”，就可以知道什么情况下会生成默认构造函数了。下面几种情况下，编译需要生成默认构造函数：</p><ol><li>当该类的<code>类对象数据成员</code>有默认构造函数时。</li><li>当该类的基类有默认构造函数时。</li><li>当该类的基类为虚基类时。</li><li>当该类有虚函数时。</li></ol><h2 id="1-4-注意事项"><a href="#1-4-注意事项" class="headerlink" title="1.4 注意事项"></a>1.4 注意事项</h2><p><strong>1. 避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在</strong></p><p><code>无参数的默认构造函数</code>和<code>带缺省参数的默认构造函数</code>同时存在时，编译器会产生二义性，从而生成编译错误。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 默认构造函数</span></span><br><span class="line">  <span class="built_in">Sample</span>() {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Sample()"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认构造函数</span></span><br><span class="line">  <span class="built_in">Sample</span>(<span class="type">int</span> m = <span class="number">10</span>) {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Sample(int m = 10)"</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  Sample s; <span class="comment">// error C2668: “Sample::Sample”: 对重载函数的调用不明确</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>2. 使用无参构造函数创建对象时，不应在对象名后面加上括号</strong></p><p>使用无参构造函数创建对象时，不应在对象名后面加上括号，否则会产生编译警告<code>“warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?)”</code>。因为编译器误认为<code>Sample s();</code>语句时要声明返回值为<code>Sample</code>对象的函数<code>s</code>，而又没找到函数<code>s</code>的定义，所以产生了警告。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 默认构造函数</span></span><br><span class="line">  <span class="built_in">Sample</span>() {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Sample()"</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="function">Sample <span class="title">s</span><span class="params">()</span></span>; <span class="comment">// warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二、构造函数初始化列表"><a href="#二、构造函数初始化列表" class="headerlink" title="二、构造函数初始化列表"></a>二、构造函数初始化列表</h1><h2 id="2-1-何为构造函数初始化列表"><a href="#2-1-何为构造函数初始化列表" class="headerlink" title="2.1 何为构造函数初始化列表"></a>2.1 何为构造函数初始化列表</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 构造函数内部赋值</span></span><br><span class="line">  <span class="built_in">Sample</span>(<span class="type">int</span> a)  {</span><br><span class="line">    a_ = a;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数初始化列表</span></span><br><span class="line">  <span class="built_in">Sample</span>(<span class="type">int</span> a) : <span class="built_in">a_</span>(a) {</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>上面的代码中，<code>Sample</code>类的 2 个构造函数的功能是一样的，都是初始化成员变量<code>a_</code>，区别在于一个采用的是<code>构造函数内部赋值</code>的方式来初始化的，另一个采用的是<code>构造函数初始化列表</code>初始化列表的方式来初始化的。</p><h2 id="2-1-何时必须使用初始化列表"><a href="#2-1-何时必须使用初始化列表" class="headerlink" title="2.1 何时必须使用初始化列表"></a>2.1 何时必须使用初始化列表</h2><p>如果按照上面所说的，既然 2 种初始化成员变量的方式所起得作用是一样的，那么在哪些情况下<strong>必须</strong>使用<code>构造函数初始化列表</code>的了？<br>下面 2 种情况的成员变量必须使用<code>构造函数初始化列表</code>的方式来初始化：</p><ol><li>成员变量是 const 常量。</li><li>成员变量是引用类型。</li></ol><p>下面例子演示了成员变量是<code>const常量</code>和<code>引用类型</code>时，如何初始化它们：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Sample</span>() : <span class="built_in">kCount</span>(<span class="number">11</span>), <span class="built_in">name_</span>(std::<span class="built_in">string</span>(<span class="string">"jeff"</span>))  {</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string &amp;name_;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> kCount;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="2-3-初始化列表的顺序问题"><a href="#2-3-初始化列表的顺序问题" class="headerlink" title="2.3 初始化列表的顺序问题"></a>2.3 初始化列表的顺序问题</h2><p>使用<code>构造函数初始化列表</code>进行成员变量初始化时，要注意成员变量的初始化顺序。<br>举个例子来说明，现有类<code>SeqSample</code>有 3 个成员变量<code>a_, b_, c_</code>，构造函数被设计为将<code>a_, b_, c_</code>都初始化为<code>m</code>，也就是<code>a_ == b_ == c_ == m</code>：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SeqSample</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SeqSample</span>(<span class="type">int</span> m) :</span><br><span class="line">    <span class="built_in">a_</span>(m),</span><br><span class="line">    <span class="built_in">b_</span>(a_),</span><br><span class="line">    <span class="built_in">c_</span>(b_)</span><br><span class="line">  {</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> b_;</span><br><span class="line">  <span class="type">int</span> a_;</span><br><span class="line">  <span class="type">int</span> c_;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="function">SeqSample <span class="title">ss</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过调试器观察到执行构造函数初始化之后，成员变量<code>a_, b_, c_</code>的值分别为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b_ = <span class="number">-858993460</span></span><br><span class="line">a_ = <span class="number">1</span></span><br><span class="line">c_ = <span class="number">-858993460</span></span><br></pre></td></tr></tbody></table></figure><p>而不是我们期望的<code>a_ = 1  b_ = 1 c_ = 1</code>。</p><p>出现这种问题的原因在于：<strong>编译器对构造函数初始化列表中的变量进行初始化的时候，不是按照变量初始化列表中的顺序来进行初始化的，而是按照变量在类中的声明顺序来初始化的。</strong></p><p>所以，在初始化列表中的变量有依赖关系时（如上面的<code>b_</code>依赖于<code>a_</code>的初始化结果），要特别注意这种情况。</p><h2 id="2-4-初始化列表的另一个好处"><a href="#2-4-初始化列表的另一个好处" class="headerlink" title="2.4 初始化列表的另一个好处"></a>2.4 初始化列表的另一个好处</h2><p>先模糊的把这个好处说出来，不太明白的，可以看下面的示例：<br><strong>若成员变量是类对象，则使用构造函数的初始化列表可以减少一次默认构造函数的调用。</strong></p><p>测试代码如下（声明了一个<code>Apple类</code>，一个<code>Test类</code>，Test 类中有 2 个 Apple 对象<code>apple1_</code>, <code>apple2_</code>，唯一不同的是，<code>apple1_</code>通过初始化列表来初始化，<code>apple2_</code>通过函数体中的赋值语句来初始化）：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Apple</span>() {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"默认构造函数\n"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Apple</span>(<span class="type">const</span> Apple &amp;that) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"复制构造函数\n"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Apple&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Apple&amp;that) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"赋值运算符重载\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test</span>(<span class="type">const</span> Apple &amp;apple) : <span class="built_in">apple1_</span>(apple) {</span><br><span class="line">    apple2_ = apple;</span><br><span class="line">  }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Apple apple1_;</span><br><span class="line">  Apple apple2_;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  Apple apple;</span><br><span class="line">  <span class="function">Test <span class="title">t</span><span class="params">(apple)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">默认构造函数</span><br><span class="line">复制构造函数</span><br><span class="line">默认构造函数</span><br><span class="line">赋值运算符重载</span><br></pre></td></tr></tbody></table></figure><p>4 行输出分别由不同的语句产生，如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/cpp-gzhs-1.png"></p><p><code>apple1_(apple)</code>直接执行的复制构造函数，所以只产生一行输出；<br>而<code>apple2_ = apple;</code>却是先使用默认构造函数构造了一个 apple2<em>对象，然后再通过赋值运算符将 apple 的内容更新到 apple2</em>中，所以产生了 2 行输出。</p><h2 id="2-5-构造函数初始化列表的异常捕获"><a href="#2-5-构造函数初始化列表的异常捕获" class="headerlink" title="2.5 构造函数初始化列表的异常捕获"></a>2.5 构造函数初始化列表的异常捕获</h2><p>构造的函数的初始化列表也可以使用异常捕获，具体使用方式如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Foo::<span class="built_in">Foo</span>(<span class="type">int</span> n)</span><br><span class="line">    <span class="keyword">try</span> :<span class="built_in">size</span>(n), <span class="built_in">array</span>(<span class="keyword">new</span> <span class="type">int</span>[n]) {</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">int</span> *array;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++生成条形码</title>
      <link href="/post/3756556672.html"/>
      <url>/post/3756556672.html</url>
      
        <content type="html"><![CDATA[<p>条形码(<code>barcode</code>)是将宽度不等的多个黑条和空白，按照一定的编码规则排列，用以表达一组信息的图形标识符。常见的条形码是由反射率相差很大的黑条（简称条）和白条（简称空）排成的平行线图案。</p><span id="more"></span><h1 id="一、条形码介绍"><a href="#一、条形码介绍" class="headerlink" title="一、条形码介绍"></a>一、条形码介绍</h1><p><strong>条码种类很多，常见的大概有二十多种码制，其中包括：</strong><br>Code39 码（标准 39 码）、Codabar 码（库德巴码）、Code25 码（标准 25 码）、ITF25 码（交叉 25 码）、Matrix25 码（矩阵 25 码）、UPC-A 码、UPC-E 码、EAN-13 码（EAN-13 国际商品条码）、EAN-8 码（EAN-8 国际商品条码）、中国邮政码（矩阵 25 码的一种变体）、Code-B 码、MSI 码、Code11 码、Code93 码、ISBN 码、ISSN 码、Code128 码（Code128 码，包括 EAN128 码）、Code39EMS（EMS 专用的 39 码）等一维条码和 PDF417 等二维条码。</p><p><strong>目前，国际广泛使用的条码种类有：</strong></p><ul><li>EAN 码 —— 国际物品编码协会制定的一种商品用条码，通用于全世界。EAN 码符号有标准版（EAN-13）和缩短版（EAN-8）两种，我国的通用商品条码与其等效，日常购买的商品包装上所印的条码一般就是 EAN 码。</li><li>UPC 码 —— UPC 码是美国统一代码委员会制定的一种商品用条码，主要用于美国和加拿大地区，我们在美国进口的商品上可以看到。</li><li>Code39 码 —— 因其可采用数字与字母共同组成的方式而在各行业内部管理上被广泛使用。</li><li>Code93 码 —— Code 93 码与 39 码具有相同的字符集，但它的密度要比 39 码高，所以在面积不足的情况下，可以用 93 码代替 39 码</li><li>Codebar 码 —— 可表示数字 0 - 9，字符$、+、 -、还有只能用作起始/终止符的 a,b,c d 四个字符，可变长度，没有校验位，多用于血库,图书馆和照像馆的业务中。</li><li>Code128 码 —— 128 可表示 ASCII 0 到 ASCII 127 共计 128 个 ASCII 字符。</li><li>CodeI2of5 码 —— 只能表示数字 0 -9 可变长度，连续性条形码，所有条与空都表示代码，第一个数字由条开始，第二个数字由空组成，空白区比窄条宽 10 倍，应用于商品批发、仓库、机场、生产/包装识别、工业中，条形码的识读率高，可适用于固定扫描器可靠扫描，在所有一维条形码中的密度最高。</li></ul><h1 id="二、C-方式实现"><a href="#二、C-方式实现" class="headerlink" title="二、C++方式实现"></a>二、C++方式实现</h1><p><strong><code>barcode.h</code></strong> 中实现了 Code39、Code93、Code128、CodeI2of5 等 4 种格式的条形码的生成。<br>具体使用方法：调用对应类的<code>DrawBarcode</code>函数将条形码绘制到 HDC 上，绘制到 HDC 上之后可以保存为图片或者显示到界面。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BARCODE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BARCODE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Barcode39</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Barcode93</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BarcodeIof5</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Barcode128</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> ga2_Code128[<span class="number">2</span>][<span class="number">207</span>] =</span><br><span class="line">{</span><br><span class="line">    {</span><br><span class="line">        <span class="number">64</span>,  <span class="number">65</span>,  <span class="number">66</span>,  <span class="number">67</span>,  <span class="number">68</span>,  <span class="number">69</span>,  <span class="number">70</span>,  <span class="number">71</span>,  <span class="number">72</span>,  <span class="number">73</span>,  <span class="number">74</span>,  <span class="number">75</span>,  <span class="number">76</span>,  <span class="number">77</span>,  <span class="number">78</span>,  <span class="number">79</span>,</span><br><span class="line">        <span class="number">80</span>,  <span class="number">81</span>,  <span class="number">82</span>,  <span class="number">83</span>,  <span class="number">84</span>,  <span class="number">85</span>,  <span class="number">86</span>,  <span class="number">87</span>,  <span class="number">88</span>,  <span class="number">89</span>,  <span class="number">90</span>,  <span class="number">91</span>,  <span class="number">92</span>,  <span class="number">93</span>,  <span class="number">94</span>,  <span class="number">95</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">3</span>,   <span class="number">4</span>,   <span class="number">5</span>,   <span class="number">6</span>,   <span class="number">7</span>,   <span class="number">8</span>,   <span class="number">9</span>,  <span class="number">10</span>,  <span class="number">11</span>,  <span class="number">12</span>,  <span class="number">13</span>,  <span class="number">14</span>,  <span class="number">15</span>,</span><br><span class="line">        <span class="number">16</span>,  <span class="number">17</span>,  <span class="number">18</span>,  <span class="number">19</span>,  <span class="number">20</span>,  <span class="number">21</span>,  <span class="number">22</span>,  <span class="number">23</span>,  <span class="number">24</span>,  <span class="number">25</span>,  <span class="number">26</span>,  <span class="number">27</span>,  <span class="number">28</span>,  <span class="number">29</span>,  <span class="number">30</span>,  <span class="number">31</span>,</span><br><span class="line">        <span class="number">32</span>,  <span class="number">33</span>,  <span class="number">34</span>,  <span class="number">35</span>,  <span class="number">36</span>,  <span class="number">37</span>,  <span class="number">38</span>,  <span class="number">39</span>,  <span class="number">40</span>,  <span class="number">41</span>,  <span class="number">42</span>,  <span class="number">43</span>,  <span class="number">44</span>,  <span class="number">45</span>,  <span class="number">46</span>,  <span class="number">47</span>,</span><br><span class="line">        <span class="number">48</span>,  <span class="number">49</span>,  <span class="number">50</span>,  <span class="number">51</span>,  <span class="number">52</span>,  <span class="number">53</span>,  <span class="number">54</span>,  <span class="number">55</span>,  <span class="number">56</span>,  <span class="number">57</span>,  <span class="number">58</span>,  <span class="number">59</span>,  <span class="number">60</span>,  <span class="number">61</span>,  <span class="number">62</span>,  <span class="number">63</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">95</span>,  <span class="number">96</span>,  <span class="number">97</span>,  <span class="number">98</span>,  <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">104</span>, <span class="number">105</span>, <span class="number">106</span>,</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">3</span>,   <span class="number">4</span>,   <span class="number">5</span>,   <span class="number">6</span>,   <span class="number">7</span>,   <span class="number">8</span>,   <span class="number">9</span>,  <span class="number">10</span>,  <span class="number">11</span>,  <span class="number">12</span>,  <span class="number">13</span>,  <span class="number">14</span>,  <span class="number">15</span>,</span><br><span class="line">        <span class="number">16</span>,  <span class="number">17</span>,  <span class="number">18</span>,  <span class="number">19</span>,  <span class="number">20</span>,  <span class="number">21</span>,  <span class="number">22</span>,  <span class="number">23</span>,  <span class="number">24</span>,  <span class="number">25</span>,  <span class="number">26</span>,  <span class="number">27</span>,  <span class="number">28</span>,  <span class="number">29</span>,  <span class="number">30</span>,  <span class="number">31</span>,</span><br><span class="line">        <span class="number">32</span>,  <span class="number">33</span>,  <span class="number">34</span>,  <span class="number">35</span>,  <span class="number">36</span>,  <span class="number">37</span>,  <span class="number">38</span>,  <span class="number">39</span>,  <span class="number">40</span>,  <span class="number">41</span>,  <span class="number">42</span>,  <span class="number">43</span>,  <span class="number">44</span>,  <span class="number">45</span>,  <span class="number">46</span>,  <span class="number">47</span>,</span><br><span class="line">        <span class="number">48</span>,  <span class="number">49</span>,  <span class="number">50</span>,  <span class="number">51</span>,  <span class="number">52</span>,  <span class="number">53</span>,  <span class="number">54</span>,  <span class="number">55</span>,  <span class="number">56</span>,  <span class="number">57</span>,  <span class="number">58</span>,  <span class="number">59</span>,  <span class="number">60</span>,  <span class="number">61</span>,  <span class="number">62</span>,  <span class="number">63</span>,</span><br><span class="line">        <span class="number">64</span>,  <span class="number">65</span>,  <span class="number">66</span>,  <span class="number">67</span>,  <span class="number">68</span>,  <span class="number">69</span>,  <span class="number">70</span>,  <span class="number">71</span>,  <span class="number">72</span>,  <span class="number">73</span>,  <span class="number">74</span>,  <span class="number">75</span>,  <span class="number">76</span>,  <span class="number">77</span>,  <span class="number">78</span>,  <span class="number">79</span>,</span><br><span class="line">        <span class="number">80</span>,  <span class="number">81</span>,  <span class="number">82</span>,  <span class="number">83</span>,  <span class="number">84</span>,  <span class="number">85</span>,  <span class="number">86</span>,  <span class="number">87</span>,  <span class="number">88</span>,  <span class="number">89</span>,  <span class="number">90</span>,  <span class="number">91</span>,  <span class="number">92</span>,  <span class="number">93</span>,  <span class="number">94</span>,  <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">-1</span>,  <span class="number">95</span>,  <span class="number">96</span>,  <span class="number">97</span>,  <span class="number">98</span>,  <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">104</span>, <span class="number">105</span>, <span class="number">106</span>,</span><br><span class="line">    },</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BarcodeBase</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BarcodeBase</span>() {</span><br><span class="line">        <span class="built_in">Clear</span>();</span><br><span class="line">        i_Ratio = <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> BarcodeBase&amp;bc) {</span><br><span class="line">        i_LenBuf = bc.i_LenBuf;</span><br><span class="line">        i_Ratio = bc.i_Ratio;</span><br><span class="line">        <span class="built_in">memcpy</span>(ia_Buf, bc.ia_Buf, <span class="built_in">sizeof</span>(ia_Buf));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="built_in">memset</span>(ia_Buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(ia_Buf));</span><br><span class="line">        i_LenBuf = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetEncodeLength</span><span class="params">()</span>  <span class="type">const</span> </span>{</span><br><span class="line">        BYTE*pb = (BYTE*)ia_Buf;</span><br><span class="line">        <span class="type">int</span> i, iLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; i_LenBuf; i++) {</span><br><span class="line">            <span class="comment">//wide is 3</span></span><br><span class="line">            <span class="keyword">if</span> (*pb &amp; <span class="number">2</span>)  iLen += (i_Ratio - <span class="number">1</span>);</span><br><span class="line">            pb++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> iLen + i_LenBuf;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetBufferLength</span><span class="params">()</span>  <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> i_LenBuf;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">const</span> BYTE&amp;<span class="title">GetAt</span><span class="params">(<span class="type">int</span> i)</span>  <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> ia_Buf[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetRatio</span><span class="params">()</span>  <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> i_Ratio;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SetRatio</span><span class="params">(<span class="type">int</span> iRatio)</span> </span>{</span><br><span class="line">        i_Ratio = iRatio;</span><br><span class="line">        <span class="keyword">if</span> (i_Ratio &lt;= <span class="number">0</span>)  i_Ratio = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DrawBarcode</span><span class="params">(HDC hDC, <span class="type">int</span> iX, <span class="type">int</span> iY0, <span class="type">int</span> iY10, <span class="type">int</span> iY11, <span class="type">const</span> COLORREF clrBar, <span class="type">const</span> COLORREF clrSpace, <span class="type">const</span> <span class="type">int</span> iPenW)</span> </span>{</span><br><span class="line">        HPEN hPenBar = ::<span class="built_in">CreatePen</span>(PS_SOLID, iPenW, clrBar);</span><br><span class="line">        HPEN hPenSpace = ::<span class="built_in">CreatePen</span>(PS_SOLID, iPenW, clrSpace);</span><br><span class="line"></span><br><span class="line">        HPEN hPenOld = (HPEN)::<span class="built_in">SelectObject</span>(hDC, hPenBar);</span><br><span class="line"></span><br><span class="line">        BYTE*pb = ia_Buf;</span><br><span class="line">        <span class="type">int</span> i0, iNum0 = i_LenBuf;</span><br><span class="line"></span><br><span class="line">        BYTE bBar;</span><br><span class="line">        <span class="type">int</span> i1, iNum1;</span><br><span class="line">        <span class="type">int</span> iY;</span><br><span class="line">        <span class="keyword">for</span> (i0 = <span class="number">0</span>; i0 &lt; iNum0; i0++) {</span><br><span class="line">            bBar = *pb &amp; <span class="number">0x01</span>;</span><br><span class="line">            iNum1 = (*pb &amp; <span class="number">0x02</span>) ? i_Ratio : <span class="number">1</span>;</span><br><span class="line">            iY = (*pb &amp; <span class="number">0x04</span>) ? iY11 : iY10;</span><br><span class="line">            <span class="keyword">for</span> (i1 = <span class="number">0</span>; i1 &lt; iNum1; i1++) {</span><br><span class="line">                <span class="keyword">if</span> (bBar)  ::<span class="built_in">SelectObject</span>(hDC, hPenBar);</span><br><span class="line">                <span class="keyword">else</span>    ::<span class="built_in">SelectObject</span>(hDC, hPenSpace);</span><br><span class="line"></span><br><span class="line">                ::<span class="built_in">MoveToEx</span>(hDC, iX, iY0, <span class="number">0</span>);</span><br><span class="line">                ::<span class="built_in">LineTo</span>(hDC, iX, iY);</span><br><span class="line">                iX += iPenW;</span><br><span class="line">            }</span><br><span class="line">            pb++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ::<span class="built_in">SelectObject</span>(hDC, hPenOld);</span><br><span class="line"></span><br><span class="line">        ::<span class="built_in">DeleteObject</span>(hPenBar);</span><br><span class="line">        ::<span class="built_in">DeleteObject</span>(hPenSpace);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    BYTE  ia_Buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="type">int</span>    i_LenBuf;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>    i_Ratio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">IntString</span> {</span><br><span class="line">        <span class="type">int</span> ch;</span><br><span class="line">        <span class="type">char</span>*psz;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Barcode39</span> : <span class="keyword">public</span> BarcodeBase {</span><br><span class="line">    <span class="comment">//[n/a][n/a][n/a][n/a][n/a][n/a][w-n][b-s]</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Barcode39</span>() {</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Barcode39</span>() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">Encode39</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*pszCodeIn)</span> </span>{</span><br><span class="line">        <span class="type">int</span> iLen = <span class="built_in">strlen</span>(pszCodeIn);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>*pszCode = <span class="keyword">new</span> <span class="type">char</span>[iLen + <span class="number">3</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(pszCode, <span class="string">"*%s*"</span>, pszCodeIn);</span><br><span class="line">        <span class="built_in">strupr</span>(pszCode);</span><br><span class="line"></span><br><span class="line">        BYTE*pFst = ia_Buf;</span><br><span class="line">        BYTE*p0 = pFst, *p1;</span><br><span class="line"></span><br><span class="line">        iLen += <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; iLen; i++) {</span><br><span class="line">            p1 = <span class="built_in">P_GetNarrowWideBarSpace39</span>(pszCode[i], p0);</span><br><span class="line">            <span class="keyword">if</span> (p1 == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            p0 = p1;</span><br><span class="line">        }</span><br><span class="line">        i_LenBuf = p1 - pFst;</span><br><span class="line">        <span class="keyword">delete</span>[]pszCode;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Draw39</span><span class="params">(HDC hDC, <span class="type">int</span> iX, <span class="type">int</span> iY0, <span class="type">int</span> iY1, <span class="type">const</span> COLORREF clrBar, <span class="type">const</span> COLORREF clrSpace, <span class="type">const</span> <span class="type">int</span> iPenW)</span> </span>{</span><br><span class="line">        <span class="built_in">DrawBarcode</span>(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">BYTE*<span class="title">P_GetNarrowWideBarSpace39</span><span class="params">(<span class="type">char</span> ch, BYTE*pb)</span> </span>{</span><br><span class="line">        IntString infs[] =</span><br><span class="line">        {</span><br><span class="line">            {<span class="string">'1'</span>,  <span class="string">"wnnwnnnnwn"</span>},</span><br><span class="line">            {<span class="string">'2'</span>,  <span class="string">"nnwwnnnnwn"</span>},</span><br><span class="line">            {<span class="string">'3'</span>,  <span class="string">"wnwwnnnnnn"</span>},</span><br><span class="line">            {<span class="string">'4'</span>,  <span class="string">"nnnwwnnnwn"</span>},</span><br><span class="line">            {<span class="string">'5'</span>,  <span class="string">"wnnwwnnnnn"</span>},</span><br><span class="line">            {<span class="string">'6'</span>,  <span class="string">"nnwwwnnnnn"</span>},</span><br><span class="line">            {<span class="string">'7'</span>,  <span class="string">"nnnwnnwnwn"</span>},</span><br><span class="line">            {<span class="string">'8'</span>,  <span class="string">"wnnwnnwnnn"</span>},</span><br><span class="line">            {<span class="string">'9'</span>,  <span class="string">"nnwwnnwnnn"</span>},</span><br><span class="line">            {<span class="string">'0'</span>,  <span class="string">"nnnwwnwnnn"</span>},</span><br><span class="line">            {<span class="string">'A'</span>,  <span class="string">"wnnnnwnnwn"</span>},</span><br><span class="line">            {<span class="string">'B'</span>,  <span class="string">"nnwnnwnnwn"</span>},</span><br><span class="line">            {<span class="string">'C'</span>,  <span class="string">"wnwnnwnnnn"</span>},</span><br><span class="line">            {<span class="string">'D'</span>,  <span class="string">"nnnnwwnnwn"</span>},</span><br><span class="line">            {<span class="string">'E'</span>,  <span class="string">"wnnnwwnnnn"</span>},</span><br><span class="line">            {<span class="string">'F'</span>,  <span class="string">"nnwnwwnnnn"</span>},</span><br><span class="line">            {<span class="string">'G'</span>,  <span class="string">"nnnnnwwnwn"</span>},</span><br><span class="line">            {<span class="string">'H'</span>,  <span class="string">"wnnnnwwnnn"</span>},</span><br><span class="line">            {<span class="string">'I'</span>,  <span class="string">"nnwnnwwnnn"</span>},</span><br><span class="line">            {<span class="string">'J'</span>,  <span class="string">"nnnnwwwnnn"</span>},</span><br><span class="line">            {<span class="string">'K'</span>,  <span class="string">"wnnnnnnwwn"</span>},</span><br><span class="line">            {<span class="string">'L'</span>,  <span class="string">"nnwnnnnwwn"</span>},</span><br><span class="line">            {<span class="string">'M'</span>,  <span class="string">"wnwnnnnwnn"</span>},</span><br><span class="line">            {<span class="string">'N'</span>,  <span class="string">"nnnnwnnwwn"</span>},</span><br><span class="line">            {<span class="string">'O'</span>,  <span class="string">"wnnnwnnwnn"</span>},</span><br><span class="line">            {<span class="string">'P'</span>,  <span class="string">"nnwnwnnwnn"</span>},</span><br><span class="line">            {<span class="string">'Q'</span>,  <span class="string">"nnnnnnwwwn"</span>},</span><br><span class="line">            {<span class="string">'R'</span>,  <span class="string">"wnnnnnwwnn"</span>},</span><br><span class="line">            {<span class="string">'S'</span>,  <span class="string">"nnwnnnwwnn"</span>},</span><br><span class="line">            {<span class="string">'T'</span>,  <span class="string">"nnnnwnwwnn"</span>},</span><br><span class="line">            {<span class="string">'U'</span>,  <span class="string">"wwnnnnnnwn"</span>},</span><br><span class="line">            {<span class="string">'V'</span>,  <span class="string">"nwwnnnnnwn"</span>},</span><br><span class="line">            {<span class="string">'W'</span>,  <span class="string">"wwwnnnnnnn"</span>},</span><br><span class="line">            {<span class="string">'X'</span>,  <span class="string">"nwnnwnnnwn"</span>},</span><br><span class="line">            {<span class="string">'Y'</span>,  <span class="string">"wwnnwnnnnn"</span>},</span><br><span class="line">            {<span class="string">'Z'</span>,  <span class="string">"nwwnwnnnnn"</span>},</span><br><span class="line">            {<span class="string">'-'</span>,  <span class="string">"nwnnnnwnwn"</span>},</span><br><span class="line">            {<span class="string">'.'</span>,  <span class="string">"wwnnnnwnnn"</span>},</span><br><span class="line">            {<span class="string">' '</span>,  <span class="string">"nwwnnnwnnn"</span>},</span><br><span class="line">            {<span class="string">'*'</span>,  <span class="string">"nwnnwnwnnn"</span>},</span><br><span class="line">            {<span class="string">'$'</span>,  <span class="string">"nwnwnwnnnn"</span>},</span><br><span class="line">            {<span class="string">'/'</span>,  <span class="string">"nwnwnnnwnn"</span>},</span><br><span class="line">            {<span class="string">'+'</span>,  <span class="string">"nwnnnwnwnn"</span>},</span><br><span class="line">            {<span class="string">'%'</span>,  <span class="string">"nnnwnwnwnn"</span>},</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i0, iNum0 = <span class="built_in">sizeof</span>(infs) / <span class="built_in">sizeof</span>(infs[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> i1;</span><br><span class="line">        <span class="keyword">for</span> (i0 = <span class="number">0</span>; i0 &lt; iNum0; i0++) {</span><br><span class="line">            IntString&amp;inf = infs[i0];</span><br><span class="line">            <span class="keyword">if</span> (inf.ch == ch) {</span><br><span class="line">                <span class="keyword">for</span> (i1 = <span class="number">0</span>; i1 &lt; <span class="number">10</span>; i1++) {</span><br><span class="line">                    <span class="keyword">if</span> (inf.psz[i1] == <span class="string">'w'</span>)  *pb += <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i1 % <span class="number">2</span> == <span class="number">0</span>)      *pb += <span class="number">1</span>;</span><br><span class="line">                    pb++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> pb;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BarcodeI2of5</span> :<span class="keyword">public</span> BarcodeBase {</span><br><span class="line">    <span class="comment">//[n/a][n/a][n/a][n/a][n/a][n/a][w-n][b-s]</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BarcodeI2of5</span>() {</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">BarcodeI2of5</span>() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">EncodeI2of5</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*pszCode)</span> </span>{</span><br><span class="line">        <span class="built_in">Clear</span>();</span><br><span class="line">        BYTE*pFst = ia_Buf;</span><br><span class="line">        BYTE*pb = pFst;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> iNum = <span class="built_in">strlen</span>(pszCode);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="comment">//"nnnn"</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)  *pb += <span class="number">1</span>;</span><br><span class="line">            pb++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> iV;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; iNum; i += <span class="number">2</span>) {</span><br><span class="line">            iV = pszCode[i] - <span class="string">'0'</span>;</span><br><span class="line">            iV = iV * <span class="number">10</span>;</span><br><span class="line">            iV += pszCode[i + <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">            pb = <span class="built_in">P_GetNarrorWideBarSpaceI2of5</span>(pb, iV);</span><br><span class="line">            <span class="keyword">if</span> (pb == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//"wnn"</span></span><br><span class="line">        *pb += <span class="number">3</span>;  pb++;</span><br><span class="line">        *pb += <span class="number">0</span>;  pb++;</span><br><span class="line">        *pb += <span class="number">1</span>;  pb++;</span><br><span class="line"></span><br><span class="line">        i_LenBuf = pb - pFst;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DrawI2of5</span><span class="params">(HDC hDC, <span class="type">int</span> iX, <span class="type">int</span> iY0, <span class="type">int</span> iY1, <span class="type">const</span> COLORREF clrBar, <span class="type">const</span> COLORREF clrSpace, <span class="type">const</span> <span class="type">int</span> iPenW)</span> </span>{</span><br><span class="line">        <span class="built_in">DrawBarcode</span>(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">BYTE*<span class="title">P_GetNarrorWideBarSpaceI2of5</span><span class="params">(BYTE*pb, <span class="type">int</span> ch)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (ch &lt; <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt; <span class="number">99</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        IntString infs[] =</span><br><span class="line">        {</span><br><span class="line">            {<span class="number">0</span>,    <span class="string">"nnnnwwwwnn"</span>},</span><br><span class="line">            {<span class="number">1</span>,    <span class="string">"nwnnwnwnnw"</span>},</span><br><span class="line">            {<span class="number">2</span>,    <span class="string">"nnnwwnwnnw"</span>},</span><br><span class="line">            {<span class="number">3</span>,    <span class="string">"nwnwwnwnnn"</span>},</span><br><span class="line">            {<span class="number">4</span>,    <span class="string">"nnnnwwwnnw"</span>},</span><br><span class="line">            {<span class="number">5</span>,    <span class="string">"nwnnwwwnnn"</span>},</span><br><span class="line">            {<span class="number">6</span>,    <span class="string">"nnnwwwwnnn"</span>},</span><br><span class="line">            {<span class="number">7</span>,    <span class="string">"nnnnwnwwnw"</span>},</span><br><span class="line">            {<span class="number">8</span>,    <span class="string">"nwnnwnwwnn"</span>},</span><br><span class="line">            {<span class="number">9</span>,    <span class="string">"nnnwwnwwnn"</span>},</span><br><span class="line">            {<span class="number">10</span>,  <span class="string">"wnnnnwnwwn"</span>},</span><br><span class="line">            {<span class="number">11</span>,  <span class="string">"wwnnnnnnww"</span>},</span><br><span class="line">            {<span class="number">12</span>,  <span class="string">"wnnwnnnnww"</span>},</span><br><span class="line">            {<span class="number">13</span>,  <span class="string">"wwnwnnnnwn"</span>},</span><br><span class="line">            {<span class="number">14</span>,  <span class="string">"wnnnnwnnww"</span>},</span><br><span class="line">            {<span class="number">15</span>,  <span class="string">"wwnnnwnnwn"</span>},</span><br><span class="line">            {<span class="number">16</span>,  <span class="string">"wnnwnwnnwn"</span>},</span><br><span class="line">            {<span class="number">17</span>,  <span class="string">"wnnnnnnwww"</span>},</span><br><span class="line">            {<span class="number">18</span>,  <span class="string">"wwnnnnnwwn"</span>},</span><br><span class="line">            {<span class="number">19</span>,  <span class="string">"wnnwnnnwwn"</span>},</span><br><span class="line">            {<span class="number">20</span>,  <span class="string">"nnwnnwnwwn"</span>},</span><br><span class="line">            {<span class="number">21</span>,  <span class="string">"nwwnnnnnww"</span>},</span><br><span class="line">            {<span class="number">22</span>,  <span class="string">"nnwwnnnnww"</span>},</span><br><span class="line">            {<span class="number">23</span>,  <span class="string">"nwwwnnnnwn"</span>},</span><br><span class="line">            {<span class="number">24</span>,  <span class="string">"nnwnnwnnww"</span>},</span><br><span class="line">            {<span class="number">25</span>,  <span class="string">"nwwnnwnnwn"</span>},</span><br><span class="line">            {<span class="number">26</span>,  <span class="string">"nnwwnwnnwn"</span>},</span><br><span class="line">            {<span class="number">27</span>,  <span class="string">"nnwnnnnwww"</span>},</span><br><span class="line">            {<span class="number">28</span>,  <span class="string">"nwwnnnnwwn"</span>},</span><br><span class="line">            {<span class="number">29</span>,  <span class="string">"nnwwnnnwwn"</span>},</span><br><span class="line">            {<span class="number">30</span>,  <span class="string">"wnwnnwnwnn"</span>},</span><br><span class="line">            {<span class="number">31</span>,  <span class="string">"wwwnnnnnnw"</span>},</span><br><span class="line">            {<span class="number">32</span>,  <span class="string">"wnwwnnnnnw"</span>},</span><br><span class="line">            {<span class="number">33</span>,  <span class="string">"wwwwnnnnnn"</span>},</span><br><span class="line">            {<span class="number">34</span>,  <span class="string">"wnwnnwnnnw"</span>},</span><br><span class="line">            {<span class="number">35</span>,  <span class="string">"wwwnnwnnnn"</span>},</span><br><span class="line">            {<span class="number">36</span>,  <span class="string">"wnwwnwnnnn"</span>},</span><br><span class="line">            {<span class="number">37</span>,  <span class="string">"wnwnnnnwnw"</span>},</span><br><span class="line">            {<span class="number">38</span>,  <span class="string">"wwwnnnnwnn"</span>},</span><br><span class="line">            {<span class="number">39</span>,  <span class="string">"wnwwnnnwnn"</span>},</span><br><span class="line">            {<span class="number">40</span>,  <span class="string">"nnnnwwnwwn"</span>},</span><br><span class="line">            {<span class="number">41</span>,  <span class="string">"nwnnwnnnww"</span>},</span><br><span class="line">            {<span class="number">42</span>,  <span class="string">"nnnwwnnnww"</span>},</span><br><span class="line">            {<span class="number">43</span>,  <span class="string">"nwnwwnnnwn"</span>},</span><br><span class="line">            {<span class="number">44</span>,  <span class="string">"nnnnwwnnww"</span>},</span><br><span class="line">            {<span class="number">45</span>,  <span class="string">"nwnnwwnnwn"</span>},</span><br><span class="line">            {<span class="number">46</span>,  <span class="string">"nnnwwwnnwn"</span>},</span><br><span class="line">            {<span class="number">47</span>,  <span class="string">"nnnnwnnwww"</span>},</span><br><span class="line">            {<span class="number">48</span>,  <span class="string">"nwnnwnnwwn"</span>},</span><br><span class="line">            {<span class="number">49</span>,  <span class="string">"nnnwwnnwwn"</span>},</span><br><span class="line">            {<span class="number">50</span>,  <span class="string">"wnnnwwnwnn"</span>},</span><br><span class="line">            {<span class="number">51</span>,  <span class="string">"wwnnwnnnnw"</span>},</span><br><span class="line">            {<span class="number">52</span>,  <span class="string">"wnnwwnnnnw"</span>},</span><br><span class="line">            {<span class="number">53</span>,  <span class="string">"wwnwwnnnnn"</span>},</span><br><span class="line">            {<span class="number">54</span>,  <span class="string">"wnnnwwnnnw"</span>},</span><br><span class="line">            {<span class="number">55</span>,  <span class="string">"wwnnwwnnnn"</span>},</span><br><span class="line">            {<span class="number">56</span>,  <span class="string">"wnnwwwnnnn"</span>},</span><br><span class="line">            {<span class="number">57</span>,  <span class="string">"wnnnwnnwnw"</span>},</span><br><span class="line">            {<span class="number">58</span>,  <span class="string">"wwnnwnnwnn"</span>},</span><br><span class="line">            {<span class="number">59</span>,  <span class="string">"wnnwwnnwnn"</span>},</span><br><span class="line">            {<span class="number">60</span>,  <span class="string">"nnwnwwnwnn"</span>},</span><br><span class="line">            {<span class="number">61</span>,  <span class="string">"nwwnwnnnnw"</span>},</span><br><span class="line">            {<span class="number">62</span>,  <span class="string">"nnwwwnnnnw"</span>},</span><br><span class="line">            {<span class="number">63</span>,  <span class="string">"nwwwwnnnnn"</span>},</span><br><span class="line">            {<span class="number">64</span>,  <span class="string">"nnwnwwnnnw"</span>},</span><br><span class="line">            {<span class="number">65</span>,  <span class="string">"nwwnwwnnnn"</span>},</span><br><span class="line">            {<span class="number">66</span>,  <span class="string">"nnwwwwnnnn"</span>},</span><br><span class="line">            {<span class="number">67</span>,  <span class="string">"nnwnwnnwnw"</span>},</span><br><span class="line">            {<span class="number">68</span>,  <span class="string">"nwwnwnnwnn"</span>},</span><br><span class="line">            {<span class="number">69</span>,  <span class="string">"nnwwwnnwnn"</span>},</span><br><span class="line">            {<span class="number">70</span>,  <span class="string">"nnnnnwwwwn"</span>},</span><br><span class="line">            {<span class="number">71</span>,  <span class="string">"nwnnnnwnww"</span>},</span><br><span class="line">            {<span class="number">72</span>,  <span class="string">"nnnwnnwnww"</span>},</span><br><span class="line">            {<span class="number">73</span>,  <span class="string">"nwnwnnwnwn"</span>},</span><br><span class="line">            {<span class="number">74</span>,  <span class="string">"nnnnnwwnww"</span>},</span><br><span class="line">            {<span class="number">75</span>,  <span class="string">"nwnnnwwnwn"</span>},</span><br><span class="line">            {<span class="number">76</span>,  <span class="string">"nnnwnwwnwn"</span>},</span><br><span class="line">            {<span class="number">77</span>,  <span class="string">"nnnnnnwwww"</span>},</span><br><span class="line">            {<span class="number">78</span>,  <span class="string">"nwnnnnwwwn"</span>},</span><br><span class="line">            {<span class="number">79</span>,  <span class="string">"nnnwnnwwwn"</span>},</span><br><span class="line">            {<span class="number">80</span>,  <span class="string">"wnnnnwwwnn"</span>},</span><br><span class="line">            {<span class="number">81</span>,  <span class="string">"wwnnnnwnnw"</span>},</span><br><span class="line">            {<span class="number">82</span>,  <span class="string">"wnnwnnwnnw"</span>},</span><br><span class="line">            {<span class="number">83</span>,  <span class="string">"wwnwnnwnnn"</span>},</span><br><span class="line">            {<span class="number">84</span>,  <span class="string">"wnnnnwwnnw"</span>},</span><br><span class="line">            {<span class="number">85</span>,  <span class="string">"wwnnnwwnnn"</span>},</span><br><span class="line">            {<span class="number">86</span>,  <span class="string">"wnnwnwwnnn"</span>},</span><br><span class="line">            {<span class="number">87</span>,  <span class="string">"wnnnnnwwnw"</span>},</span><br><span class="line">            {<span class="number">88</span>,  <span class="string">"wwnnnnwwnn"</span>},</span><br><span class="line">            {<span class="number">89</span>,  <span class="string">"wnnwnnwwnn"</span>},</span><br><span class="line">            {<span class="number">90</span>,  <span class="string">"nnwnnwwwnn"</span>},</span><br><span class="line">            {<span class="number">91</span>,  <span class="string">"nwwnnnwnnw"</span>},</span><br><span class="line">            {<span class="number">92</span>,  <span class="string">"nnwwnnwnnw"</span>},</span><br><span class="line">            {<span class="number">93</span>,  <span class="string">"nwwwnnwnnn"</span>},</span><br><span class="line">            {<span class="number">94</span>,  <span class="string">"nnwnnwwnnw"</span>},</span><br><span class="line">            {<span class="number">95</span>,  <span class="string">"nwwnnwwnnn"</span>},</span><br><span class="line">            {<span class="number">96</span>,  <span class="string">"nnwwnwwnnn"</span>},</span><br><span class="line">            {<span class="number">97</span>,  <span class="string">"nnwnnnwwnw"</span>},</span><br><span class="line">            {<span class="number">98</span>,  <span class="string">"nwwnnnwwnn"</span>},</span><br><span class="line">            {<span class="number">99</span>,  <span class="string">"nnwwnnwwnn"</span>},</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        IntString&amp;inf = infs[ch];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (inf.psz[i] == <span class="string">'w'</span>)  *pb += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)      *pb += <span class="number">1</span>;</span><br><span class="line">            pb++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pb;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Barcode93</span> :<span class="keyword">public</span> BarcodeBase {</span><br><span class="line">    <span class="comment">//[n/a][n/a][n/a][n/a][n/a][n/a][n/a][b-s]</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Barcode93</span>() {</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Barcode93</span>() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">Encode93</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszCode)</span> </span>{</span><br><span class="line">        <span class="built_in">Clear</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> iNum = <span class="built_in">strlen</span>(pszCode);</span><br><span class="line"></span><br><span class="line">        BYTE*pFst = ia_Buf;</span><br><span class="line">        BYTE*pb = pFst;</span><br><span class="line"></span><br><span class="line">        pb = <span class="built_in">P_GetBarSpace93</span>(pb, <span class="number">47</span>);</span><br><span class="line">        <span class="keyword">if</span> (pb == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        BOOL b;</span><br><span class="line">        <span class="type">int</span> i, iFirst, iSecond;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; iNum; i++) {</span><br><span class="line">            b = <span class="built_in">P_AscIItoCode93Sequence</span>((<span class="type">int</span>)pszCode[i], iFirst, iSecond);</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            pb = <span class="built_in">P_GetBarSpace93</span>(pb, iFirst);</span><br><span class="line">            <span class="keyword">if</span> (pb == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (iSecond != <span class="number">-1</span>) {</span><br><span class="line">                pb = <span class="built_in">P_GetBarSpace93</span>(pb, iSecond);</span><br><span class="line">                <span class="keyword">if</span> (pb == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pb = <span class="built_in">P_GetCheckDigits</span>(pb, pszCode);</span><br><span class="line">        <span class="keyword">if</span> (pb == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        pb = <span class="built_in">P_GetBarSpace93</span>(pb, <span class="number">48</span>);</span><br><span class="line">        <span class="keyword">if</span> (pb == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        i_LenBuf = pb - pFst;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Draw93</span><span class="params">(HDC hDC, <span class="type">int</span> iX, <span class="type">int</span> iY0, <span class="type">int</span> iY1, <span class="type">const</span> COLORREF clrBar, <span class="type">const</span> COLORREF clrSpace, <span class="type">const</span> <span class="type">int</span> iPenW)</span> </span>{</span><br><span class="line">        <span class="built_in">DrawBarcode</span>(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">BYTE*<span class="title">P_GetBarSpace93</span><span class="params">(BYTE*pb, <span class="type">int</span> ch)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (ch &lt; <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt; <span class="number">48</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        IntString infs[] =</span><br><span class="line">        {</span><br><span class="line">            {<span class="number">0</span>,    <span class="string">"bsssbsbss"</span>},</span><br><span class="line">            {<span class="number">1</span>,    <span class="string">"bsbssbsss"</span>},</span><br><span class="line">            {<span class="number">2</span>,    <span class="string">"bsbsssbss"</span>},</span><br><span class="line">            {<span class="number">3</span>,    <span class="string">"bsbssssbs"</span>},</span><br><span class="line">            {<span class="number">4</span>,    <span class="string">"bssbsbsss"</span>},</span><br><span class="line">            {<span class="number">5</span>,    <span class="string">"bssbssbss"</span>},</span><br><span class="line">            {<span class="number">6</span>,    <span class="string">"bssbsssbs"</span>},</span><br><span class="line">            {<span class="number">7</span>,    <span class="string">"bsbsbssss"</span>},</span><br><span class="line">            {<span class="number">8</span>,    <span class="string">"bsssbssbs"</span>},</span><br><span class="line">            {<span class="number">9</span>,    <span class="string">"bssssbsbs"</span>},</span><br><span class="line">            {<span class="number">10</span>,  <span class="string">"bbsbsbsss"</span>},</span><br><span class="line">            {<span class="number">11</span>,  <span class="string">"bbsbssbss"</span>},</span><br><span class="line">            {<span class="number">12</span>,  <span class="string">"bbsbsssbs"</span>},</span><br><span class="line">            {<span class="number">13</span>,  <span class="string">"bbssbsbss"</span>},</span><br><span class="line">            {<span class="number">14</span>,  <span class="string">"bbssbssbs"</span>},</span><br><span class="line">            {<span class="number">15</span>,  <span class="string">"bbsssbsbs"</span>},</span><br><span class="line">            {<span class="number">16</span>,  <span class="string">"bsbbsbsss"</span>},</span><br><span class="line">            {<span class="number">17</span>,  <span class="string">"bsbbssbss"</span>},</span><br><span class="line">            {<span class="number">18</span>,  <span class="string">"bsbbsssbs"</span>},</span><br><span class="line">            {<span class="number">19</span>,  <span class="string">"bssbbsbss"</span>},</span><br><span class="line">            {<span class="number">20</span>,  <span class="string">"bsssbbsbs"</span>},</span><br><span class="line">            {<span class="number">21</span>,  <span class="string">"bsbsbbsss"</span>},</span><br><span class="line">            {<span class="number">22</span>,  <span class="string">"bsbssbbss"</span>},</span><br><span class="line">            {<span class="number">23</span>,  <span class="string">"bsbsssbbs"</span>},</span><br><span class="line">            {<span class="number">24</span>,  <span class="string">"bssbsbbss"</span>},</span><br><span class="line">            {<span class="number">25</span>,  <span class="string">"bsssbsbbs"</span>},</span><br><span class="line">            {<span class="number">26</span>,  <span class="string">"bbsbbsbss"</span>},</span><br><span class="line">            {<span class="number">27</span>,  <span class="string">"bbsbbssbs"</span>},</span><br><span class="line">            {<span class="number">28</span>,  <span class="string">"bbsbsbbss"</span>},</span><br><span class="line">            {<span class="number">29</span>,  <span class="string">"bbsbssbbs"</span>},</span><br><span class="line">            {<span class="number">30</span>,  <span class="string">"bbssbsbbs"</span>},</span><br><span class="line">            {<span class="number">31</span>,  <span class="string">"bbssbbsbs"</span>},</span><br><span class="line">            {<span class="number">32</span>,  <span class="string">"bsbbsbbss"</span>},</span><br><span class="line">            {<span class="number">33</span>,  <span class="string">"bsbbssbbs"</span>},</span><br><span class="line">            {<span class="number">34</span>,  <span class="string">"bssbbsbbs"</span>},</span><br><span class="line">            {<span class="number">35</span>,  <span class="string">"bssbbbsbs"</span>},</span><br><span class="line">            {<span class="number">36</span>,  <span class="string">"bssbsbbbs"</span>},</span><br><span class="line">            {<span class="number">37</span>,  <span class="string">"bbbsbsbss"</span>},</span><br><span class="line">            {<span class="number">38</span>,  <span class="string">"bbbsbssbs"</span>},</span><br><span class="line">            {<span class="number">39</span>,  <span class="string">"bbbssbsbs"</span>},</span><br><span class="line">            {<span class="number">40</span>,  <span class="string">"bsbbsbbbs"</span>},</span><br><span class="line">            {<span class="number">41</span>,  <span class="string">"bsbbbsbbs"</span>},</span><br><span class="line">            {<span class="number">42</span>,  <span class="string">"bbsbsbbbs"</span>},</span><br><span class="line">            {<span class="number">43</span>,  <span class="string">"bssbssbbs"</span>},</span><br><span class="line">            {<span class="number">44</span>,  <span class="string">"bbbsbbsbs"</span>},</span><br><span class="line">            {<span class="number">45</span>,  <span class="string">"bbbsbsbbs"</span>},</span><br><span class="line">            {<span class="number">46</span>,  <span class="string">"bssbbssbs"</span>},</span><br><span class="line">            {<span class="number">47</span>,  <span class="string">"bsbsbbbbs"</span>},</span><br><span class="line">            {<span class="number">48</span>,  <span class="string">"bsbsbbbbsb"</span>},</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        IntString&amp;inf = infs[ch];</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (inf.psz[i] == <span class="string">'b'</span>)  *pb += <span class="number">1</span>;</span><br><span class="line">            pb++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="number">48</span>) {</span><br><span class="line">            *pb += <span class="number">1</span>;</span><br><span class="line">            pb++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pb;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">BYTE*<span class="title">P_GetCheckDigits</span><span class="params">(BYTE*pb, <span class="type">const</span> <span class="type">char</span>*&amp;pszCode)</span> </span>{</span><br><span class="line">        <span class="type">int</span> i, iSum, iWeight, iFirst, iSecond;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// "C" check digit character</span></span><br><span class="line">        iWeight = <span class="number">1</span>;</span><br><span class="line">        iSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> iNum = <span class="built_in">strlen</span>(pszCode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = iNum - <span class="number">1</span>; i &gt; <span class="number">-1</span>; i--) {</span><br><span class="line">            <span class="built_in">P_AscIItoCode93Sequence</span>((<span class="type">int</span>)pszCode[i], iFirst, iSecond);</span><br><span class="line"></span><br><span class="line">            iSum += (iWeight*iFirst);</span><br><span class="line">            iWeight++;</span><br><span class="line">            <span class="keyword">if</span> (iWeight &gt; <span class="number">20</span>)  iWeight = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (iSecond != <span class="number">-1</span>) {</span><br><span class="line">                iSum += (iWeight*iSecond);</span><br><span class="line">                iWeight++;</span><br><span class="line">                <span class="keyword">if</span> (iWeight &gt; <span class="number">20</span>)  iWeight = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pb = <span class="built_in">P_GetBarSpace93</span>(pb, iSum % <span class="number">47</span>);</span><br><span class="line">        <span class="keyword">if</span> (pb == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        iWeight = <span class="number">2</span>;</span><br><span class="line">        iSum = iSum % <span class="number">47</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = iNum - <span class="number">1</span>; i &gt; <span class="number">-1</span>; i--) {</span><br><span class="line">            <span class="built_in">P_AscIItoCode93Sequence</span>((<span class="type">int</span>)pszCode[i], iFirst, iSecond);</span><br><span class="line"></span><br><span class="line">            iSum += (iWeight * iFirst);</span><br><span class="line">            iWeight++;</span><br><span class="line">            <span class="keyword">if</span> (iWeight &gt; <span class="number">15</span>)  iWeight = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (iSecond != <span class="number">-1</span>) {</span><br><span class="line">                iSum += (iWeight * iSecond);</span><br><span class="line">                iWeight++;</span><br><span class="line">                <span class="keyword">if</span> (iWeight &gt; <span class="number">15</span>)  iWeight = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pb = <span class="built_in">P_GetBarSpace93</span>(pb, iSum % <span class="number">47</span>);</span><br><span class="line">        <span class="keyword">if</span> (pb == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pb;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">P_AscIItoCode93Sequence</span><span class="params">(<span class="type">int</span> iValue, <span class="type">int</span>&amp;iFirst, <span class="type">int</span>&amp;iSecond)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (iValue &lt; <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (iValue &gt; <span class="number">127</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span>  <span class="title class_">I3</span> { <span class="type">int</span> iV, iFirst, iSecond; };</span><br><span class="line"></span><br><span class="line">        I3 i3s[] =</span><br><span class="line">        {</span><br><span class="line">            {<span class="number">0</span>,  <span class="number">44</span>,<span class="number">30</span>},</span><br><span class="line">            {<span class="number">1</span>,  <span class="number">43</span>,<span class="number">10</span>},</span><br><span class="line">            {<span class="number">2</span>,  <span class="number">43</span>,<span class="number">11</span>},</span><br><span class="line">            {<span class="number">3</span>,  <span class="number">43</span>,<span class="number">12</span>},</span><br><span class="line">            {<span class="number">4</span>,  <span class="number">43</span>,<span class="number">13</span>},</span><br><span class="line">            {<span class="number">5</span>,  <span class="number">43</span>,<span class="number">14</span>},</span><br><span class="line">            {<span class="number">6</span>,  <span class="number">43</span>,<span class="number">15</span>},</span><br><span class="line">            {<span class="number">7</span>,  <span class="number">43</span>,<span class="number">16</span>},</span><br><span class="line">            {<span class="number">8</span>,  <span class="number">43</span>,<span class="number">17</span>},</span><br><span class="line">            {<span class="number">9</span>,  <span class="number">43</span>,<span class="number">18</span>},</span><br><span class="line">            {<span class="number">10</span>,<span class="number">43</span>,  <span class="number">19</span>},</span><br><span class="line">            {<span class="number">11</span>,<span class="number">43</span>,  <span class="number">20</span>},</span><br><span class="line">            {<span class="number">12</span>,<span class="number">43</span>,  <span class="number">21</span>},</span><br><span class="line">            {<span class="number">13</span>,<span class="number">43</span>,  <span class="number">22</span>},</span><br><span class="line">            {<span class="number">14</span>,<span class="number">43</span>,  <span class="number">23</span>},</span><br><span class="line">            {<span class="number">15</span>,<span class="number">43</span>,  <span class="number">24</span>},</span><br><span class="line">            {<span class="number">16</span>,<span class="number">43</span>,  <span class="number">25</span>},</span><br><span class="line">            {<span class="number">17</span>,<span class="number">43</span>,  <span class="number">26</span>},</span><br><span class="line">            {<span class="number">18</span>,<span class="number">43</span>,  <span class="number">27</span>},</span><br><span class="line">            {<span class="number">19</span>,<span class="number">43</span>,  <span class="number">28</span>},</span><br><span class="line">            {<span class="number">20</span>,<span class="number">43</span>,  <span class="number">29</span>},</span><br><span class="line">            {<span class="number">21</span>,<span class="number">43</span>,  <span class="number">30</span>},</span><br><span class="line">            {<span class="number">22</span>,<span class="number">43</span>,  <span class="number">31</span>},</span><br><span class="line">            {<span class="number">23</span>,<span class="number">43</span>,  <span class="number">32</span>},</span><br><span class="line">            {<span class="number">24</span>,<span class="number">43</span>,  <span class="number">33</span>},</span><br><span class="line">            {<span class="number">25</span>,<span class="number">43</span>,  <span class="number">34</span>},</span><br><span class="line">            {<span class="number">26</span>,<span class="number">43</span>,  <span class="number">35</span>},</span><br><span class="line">            {<span class="number">27</span>,<span class="number">44</span>,  <span class="number">10</span>},</span><br><span class="line">            {<span class="number">28</span>,<span class="number">44</span>,  <span class="number">11</span>},</span><br><span class="line">            {<span class="number">29</span>,<span class="number">44</span>,  <span class="number">12</span>},</span><br><span class="line">            {<span class="number">30</span>,<span class="number">44</span>,  <span class="number">13</span>},</span><br><span class="line">            {<span class="number">31</span>,<span class="number">44</span>,  <span class="number">14</span>},</span><br><span class="line">            {<span class="number">32</span>,<span class="number">38</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">33</span>,<span class="number">45</span>,  <span class="number">10</span>},</span><br><span class="line">            {<span class="number">34</span>,<span class="number">45</span>,  <span class="number">11</span>},</span><br><span class="line">            {<span class="number">35</span>,<span class="number">45</span>,  <span class="number">12</span>},</span><br><span class="line">            {<span class="number">36</span>,<span class="number">39</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">37</span>,<span class="number">42</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">38</span>,<span class="number">45</span>,  <span class="number">15</span>},</span><br><span class="line">            {<span class="number">39</span>,<span class="number">45</span>,  <span class="number">16</span>},</span><br><span class="line">            {<span class="number">40</span>,<span class="number">45</span>,  <span class="number">17</span>},</span><br><span class="line">            {<span class="number">41</span>,<span class="number">45</span>,  <span class="number">18</span>},</span><br><span class="line">            {<span class="number">42</span>,<span class="number">45</span>,  <span class="number">19</span>},</span><br><span class="line">            {<span class="number">43</span>,<span class="number">41</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">44</span>,<span class="number">45</span>,  <span class="number">21</span>},</span><br><span class="line">            {<span class="number">45</span>,<span class="number">36</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">46</span>,<span class="number">37</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">47</span>,<span class="number">40</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">48</span>,<span class="number">0</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">49</span>,<span class="number">1</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">50</span>,<span class="number">2</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">51</span>,<span class="number">3</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">52</span>,<span class="number">4</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">53</span>,<span class="number">5</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">54</span>,<span class="number">6</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">55</span>,<span class="number">7</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">56</span>,<span class="number">8</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">57</span>,<span class="number">9</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">58</span>,<span class="number">45</span>,  <span class="number">35</span>},</span><br><span class="line">            {<span class="number">59</span>,<span class="number">44</span>,  <span class="number">15</span>},</span><br><span class="line">            {<span class="number">60</span>,<span class="number">44</span>,  <span class="number">16</span>},</span><br><span class="line">            {<span class="number">61</span>,<span class="number">44</span>,  <span class="number">17</span>},</span><br><span class="line">            {<span class="number">62</span>,<span class="number">44</span>,  <span class="number">18</span>},</span><br><span class="line">            {<span class="number">63</span>,<span class="number">44</span>,  <span class="number">19</span>},</span><br><span class="line">            {<span class="number">64</span>,<span class="number">44</span>,  <span class="number">31</span>},</span><br><span class="line">            {<span class="number">65</span>,<span class="number">10</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">66</span>,<span class="number">11</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">67</span>,<span class="number">12</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">68</span>,<span class="number">13</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">69</span>,<span class="number">14</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">70</span>,<span class="number">15</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">71</span>,<span class="number">16</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">72</span>,<span class="number">17</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">73</span>,<span class="number">18</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">74</span>,<span class="number">19</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">75</span>,<span class="number">20</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">76</span>,<span class="number">21</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">77</span>,<span class="number">22</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">78</span>,<span class="number">23</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">79</span>,<span class="number">24</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">80</span>,<span class="number">25</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">81</span>,<span class="number">26</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">82</span>,<span class="number">27</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">83</span>,<span class="number">28</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">84</span>,<span class="number">29</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">85</span>,<span class="number">30</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">86</span>,<span class="number">31</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">87</span>,<span class="number">32</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">88</span>,<span class="number">33</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">89</span>,<span class="number">34</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">90</span>,<span class="number">35</span>,  <span class="number">-1</span>},</span><br><span class="line">            {<span class="number">91</span>,<span class="number">44</span>,  <span class="number">20</span>},</span><br><span class="line">            {<span class="number">92</span>,<span class="number">44</span>,  <span class="number">21</span>},</span><br><span class="line">            {<span class="number">93</span>,<span class="number">44</span>,  <span class="number">22</span>},</span><br><span class="line">            {<span class="number">94</span>,<span class="number">44</span>,  <span class="number">23</span>},</span><br><span class="line">            {<span class="number">95</span>,<span class="number">44</span>,  <span class="number">24</span>},</span><br><span class="line">            {<span class="number">96</span>,<span class="number">44</span>,  <span class="number">32</span>},</span><br><span class="line">            {<span class="number">97</span>,<span class="number">46</span>,  <span class="number">10</span>},</span><br><span class="line">            {<span class="number">98</span>,<span class="number">46</span>,  <span class="number">11</span>},</span><br><span class="line">            {<span class="number">99</span>,<span class="number">46</span>,  <span class="number">12</span>},</span><br><span class="line">            {<span class="number">100</span>,<span class="number">46</span>,<span class="number">13</span>},</span><br><span class="line">            {<span class="number">101</span>,<span class="number">46</span>,<span class="number">14</span>},</span><br><span class="line">            {<span class="number">102</span>,<span class="number">46</span>,<span class="number">15</span>},</span><br><span class="line">            {<span class="number">103</span>,<span class="number">46</span>,<span class="number">16</span>},</span><br><span class="line">            {<span class="number">104</span>,<span class="number">46</span>,<span class="number">17</span>},</span><br><span class="line">            {<span class="number">105</span>,<span class="number">46</span>,<span class="number">18</span>},</span><br><span class="line">            {<span class="number">106</span>,<span class="number">46</span>,<span class="number">19</span>},</span><br><span class="line">            {<span class="number">107</span>,<span class="number">46</span>,<span class="number">20</span>},</span><br><span class="line">            {<span class="number">108</span>,<span class="number">46</span>,<span class="number">21</span>},</span><br><span class="line">            {<span class="number">109</span>,<span class="number">46</span>,<span class="number">22</span>},</span><br><span class="line">            {<span class="number">110</span>,<span class="number">46</span>,<span class="number">23</span>},</span><br><span class="line">            {<span class="number">111</span>,<span class="number">46</span>,<span class="number">24</span>},</span><br><span class="line">            {<span class="number">112</span>,<span class="number">46</span>,<span class="number">25</span>},</span><br><span class="line">            {<span class="number">113</span>,<span class="number">46</span>,<span class="number">26</span>},</span><br><span class="line">            {<span class="number">114</span>,<span class="number">46</span>,<span class="number">27</span>},</span><br><span class="line">            {<span class="number">115</span>,<span class="number">46</span>,<span class="number">28</span>},</span><br><span class="line">            {<span class="number">116</span>,<span class="number">46</span>,<span class="number">29</span>},</span><br><span class="line">            {<span class="number">117</span>,<span class="number">46</span>,<span class="number">30</span>},</span><br><span class="line">            {<span class="number">118</span>,<span class="number">46</span>,<span class="number">31</span>},</span><br><span class="line">            {<span class="number">119</span>,<span class="number">46</span>,<span class="number">32</span>},</span><br><span class="line">            {<span class="number">120</span>,<span class="number">46</span>,<span class="number">33</span>},</span><br><span class="line">            {<span class="number">121</span>,<span class="number">46</span>,<span class="number">34</span>},</span><br><span class="line">            {<span class="number">122</span>,<span class="number">46</span>,<span class="number">35</span>},</span><br><span class="line">            {<span class="number">123</span>,<span class="number">44</span>,<span class="number">25</span>},</span><br><span class="line">            {<span class="number">124</span>,<span class="number">44</span>,<span class="number">26</span>},</span><br><span class="line">            {<span class="number">125</span>,<span class="number">44</span>,<span class="number">27</span>},</span><br><span class="line">            {<span class="number">126</span>,<span class="number">44</span>,<span class="number">28</span>},</span><br><span class="line">            {<span class="number">127</span>,<span class="number">44</span>,<span class="number">29</span>},</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        I3&amp;i3 = i3s[iValue];</span><br><span class="line">        iFirst = i3.iFirst;</span><br><span class="line">        iSecond = i3.iSecond;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Barcode128</span> :<span class="keyword">public</span> BarcodeBase {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Barcode128</span>() {</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Barcode128</span>() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">Encode128A</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszCode)</span> </span>{ <span class="keyword">return</span> <span class="built_in">P_Encode128</span>((<span class="type">char</span>*)pszCode, SUB::SETA); }</span><br><span class="line">    <span class="function">BOOL <span class="title">Encode128B</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszCode)</span> </span>{ <span class="keyword">return</span> <span class="built_in">P_Encode128</span>((<span class="type">char</span>*)pszCode, SUB::SETB); }</span><br><span class="line">    <span class="function">BOOL <span class="title">Encode128C</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszCode)</span> </span>{ <span class="keyword">return</span> <span class="built_in">P_Encode128</span>((<span class="type">char</span>*)pszCode, SUB::SETC); }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Draw128</span><span class="params">(HDC hDC, <span class="type">int</span> iX, <span class="type">int</span> iY0, <span class="type">int</span> iY1, <span class="type">const</span> COLORREF clrBar, <span class="type">const</span> COLORREF clrSpace, <span class="type">const</span> <span class="type">int</span> iPenW)</span> </span>{</span><br><span class="line">        <span class="built_in">DrawBarcode</span>(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SUB</span> {</span><br><span class="line">        <span class="keyword">enum</span> {</span><br><span class="line">            SETA = <span class="number">0</span>,</span><br><span class="line">            SETB = <span class="number">1</span>,</span><br><span class="line">            SETC = <span class="number">2</span>,</span><br><span class="line">        };</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">P_Encode128</span><span class="params">(<span class="type">char</span>*pszCode, <span class="type">const</span> <span class="type">int</span> iSetIn)</span> </span>{</span><br><span class="line">        <span class="built_in">Clear</span>();</span><br><span class="line">        BYTE*pFst = ia_Buf;</span><br><span class="line">        BYTE*pb = pFst;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iSetIn == SUB::SETA)  pb = <span class="built_in">P_GetBarSpace128</span>(pb, <span class="number">103</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (iSetIn == SUB::SETB)  pb = <span class="built_in">P_GetBarSpace128</span>(pb, <span class="number">104</span>);</span><br><span class="line">            <span class="keyword">else</span>          pb = <span class="built_in">P_GetBarSpace128</span>(pb, <span class="number">105</span>);</span><br><span class="line">            <span class="keyword">if</span> (pb == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> iCheckDigit = <span class="built_in">GetCheckDigit</span>(iSetIn, pszCode);</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> iNum = <span class="built_in">strlen</span>(pszCode);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> iChar, iCharNext;</span><br><span class="line">            <span class="type">int</span> iPosition = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> iSet = iSetIn;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (iPosition &lt; iNum) {</span><br><span class="line">                <span class="keyword">if</span> (iSet == SUB::SETC) {</span><br><span class="line">                    <span class="keyword">if</span> (ga2_Code128[SUB::SETA][pszCode[iPosition]] == <span class="number">101</span>) {</span><br><span class="line">                        pb = <span class="built_in">P_GetBarSpace128</span>(pb, <span class="number">101</span>);</span><br><span class="line">                        iPosition++;</span><br><span class="line">                        iSet = SUB::SETA;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">if</span> (ga2_Code128[SUB::SETA][pszCode[iPosition]] == <span class="number">100</span>) {</span><br><span class="line">                            pb = <span class="built_in">P_GetBarSpace128</span>(pb, <span class="number">100</span>);</span><br><span class="line">                            iPosition++;</span><br><span class="line">                            iSet = SUB::SETB;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (ga2_Code128[SUB::SETA][pszCode[iPosition]] == <span class="number">102</span>) {</span><br><span class="line">                            pb = <span class="built_in">P_GetBarSpace128</span>(pb, <span class="number">100</span>);</span><br><span class="line">                            iPosition++;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span> {</span><br><span class="line">                            <span class="type">char</span> chT = pszCode[iPosition + <span class="number">2</span>];</span><br><span class="line">                            pszCode[iPosition + <span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">                            iChar = <span class="built_in">atoi</span>(&amp;pszCode[iPosition]);</span><br><span class="line">                            pszCode[iPosition + <span class="number">2</span>] = chT;</span><br><span class="line"></span><br><span class="line">                            pb = <span class="built_in">P_GetBarSpace128</span>(pb, iChar);</span><br><span class="line">                            <span class="keyword">if</span> (pb == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                            iPosition += <span class="number">2</span>;</span><br><span class="line">                        }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    <span class="type">int</span> iTemp2 = pszCode[iPosition];</span><br><span class="line">                    <span class="keyword">if</span> (iTemp2 &lt; <span class="number">-1</span>)  iTemp2 = iTemp2 &amp; <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">                    iChar = ga2_Code128[iSet][iTemp2];</span><br><span class="line"></span><br><span class="line">                    pb = <span class="built_in">P_GetBarSpace128</span>(pb, iChar);</span><br><span class="line">                    <span class="keyword">if</span> (pb == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    iPosition++;</span><br><span class="line">                    <span class="keyword">if</span> (iSet == SUB::SETA) {</span><br><span class="line">                        <span class="keyword">if</span> (iChar == <span class="number">100</span>)  iSet = SUB::SETB;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="keyword">if</span> (iChar == <span class="number">99</span>)  iSet = SUB::SETC;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (iSet == SUB::SETB) {</span><br><span class="line">                        <span class="keyword">if</span> (iChar == <span class="number">101</span>)  iSet = SUB::SETA;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="keyword">if</span> (iChar == <span class="number">99</span>)  iSet = SUB::SETC;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">if</span> (iChar == <span class="number">98</span>) {</span><br><span class="line">                            <span class="keyword">if</span> (iSet == SUB::SETA)</span><br><span class="line">                                iCharNext = ga2_Code128[SUB::SETB][pszCode[iPosition]];</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                iCharNext = ga2_Code128[SUB::SETA][pszCode[iPosition]];</span><br><span class="line"></span><br><span class="line">                            pb = <span class="built_in">P_GetBarSpace128</span>(pb, iChar);</span><br><span class="line">                            <span class="keyword">if</span> (pb == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                            iPosition++;</span><br><span class="line">                        }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            pb = <span class="built_in">P_GetBarSpace128</span>(pb, iCheckDigit);</span><br><span class="line">            <span class="keyword">if</span> (pb == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            pb = <span class="built_in">P_GetBarSpace128</span>(pb, <span class="number">106</span>);</span><br><span class="line">            i_LenBuf = pb - pFst;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">BYTE*<span class="title">P_GetBarSpace128</span><span class="params">(BYTE*pb, <span class="type">int</span> iV)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (iV &lt; <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (iV &gt; <span class="number">106</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        IntString infs[] =</span><br><span class="line">        {</span><br><span class="line">            {<span class="number">0</span>,    <span class="string">"bbsbbssbbss"</span>},</span><br><span class="line">            {<span class="number">1</span>,    <span class="string">"bbssbbsbbss"</span>},</span><br><span class="line">            {<span class="number">2</span>,    <span class="string">"bbssbbssbbs"</span>},</span><br><span class="line">            {<span class="number">3</span>,    <span class="string">"bssbssbbsss"</span>},</span><br><span class="line">            {<span class="number">4</span>,    <span class="string">"bssbsssbbss"</span>},</span><br><span class="line">            {<span class="number">5</span>,    <span class="string">"bsssbssbbss"</span>},</span><br><span class="line">            {<span class="number">6</span>,    <span class="string">"bssbbssbsss"</span>},</span><br><span class="line">            {<span class="number">7</span>,    <span class="string">"bssbbsssbss"</span>},</span><br><span class="line">            {<span class="number">8</span>,    <span class="string">"bsssbbssbss"</span>},</span><br><span class="line">            {<span class="number">9</span>,    <span class="string">"bbssbssbsss"</span>},</span><br><span class="line">            {<span class="number">10</span>,  <span class="string">"bbssbsssbss"</span>},</span><br><span class="line">            {<span class="number">11</span>,  <span class="string">"bbsssbssbss"</span>},</span><br><span class="line">            {<span class="number">12</span>,  <span class="string">"bsbbssbbbss"</span>},</span><br><span class="line">            {<span class="number">13</span>,  <span class="string">"bssbbsbbbss"</span>},</span><br><span class="line">            {<span class="number">14</span>,  <span class="string">"bssbbssbbbs"</span>},</span><br><span class="line">            {<span class="number">15</span>,  <span class="string">"bsbbbssbbss"</span>},</span><br><span class="line">            {<span class="number">16</span>,  <span class="string">"bssbbbsbbss"</span>},</span><br><span class="line">            {<span class="number">17</span>,  <span class="string">"bssbbbssbbs"</span>},</span><br><span class="line">            {<span class="number">18</span>,  <span class="string">"bbssbbbssbs"</span>},</span><br><span class="line">            {<span class="number">19</span>,  <span class="string">"bbssbsbbbss"</span>},</span><br><span class="line">            {<span class="number">20</span>,  <span class="string">"bbssbssbbbs"</span>},</span><br><span class="line">            {<span class="number">21</span>,  <span class="string">"bbsbbbssbss"</span>},</span><br><span class="line">            {<span class="number">22</span>,  <span class="string">"bbssbbbsbss"</span>},</span><br><span class="line">            {<span class="number">23</span>,  <span class="string">"bbbsbbsbbbs"</span>},</span><br><span class="line">            {<span class="number">24</span>,  <span class="string">"bbbsbssbbss"</span>},</span><br><span class="line">            {<span class="number">25</span>,  <span class="string">"bbbssbsbbss"</span>},</span><br><span class="line">            {<span class="number">26</span>,  <span class="string">"bbbssbssbbs"</span>},</span><br><span class="line">            {<span class="number">27</span>,  <span class="string">"bbbsbbssbss"</span>},</span><br><span class="line">            {<span class="number">28</span>,  <span class="string">"bbbssbbsbss"</span>},</span><br><span class="line">            {<span class="number">29</span>,  <span class="string">"bbbssbbssbs"</span>},</span><br><span class="line">            {<span class="number">30</span>,  <span class="string">"bbsbbsbbsss"</span>},</span><br><span class="line">            {<span class="number">31</span>,  <span class="string">"bbsbbsssbbs"</span>},</span><br><span class="line">            {<span class="number">32</span>,  <span class="string">"bbsssbbsbbs"</span>},</span><br><span class="line">            {<span class="number">33</span>,  <span class="string">"bsbsssbbsss"</span>},</span><br><span class="line">            {<span class="number">34</span>,  <span class="string">"bsssbsbbsss"</span>},</span><br><span class="line">            {<span class="number">35</span>,  <span class="string">"bsssbsssbbs"</span>},</span><br><span class="line">            {<span class="number">36</span>,  <span class="string">"bsbbsssbsss"</span>},</span><br><span class="line">            {<span class="number">37</span>,  <span class="string">"bsssbbsbsss"</span>},</span><br><span class="line">            {<span class="number">38</span>,  <span class="string">"bsssbbsssbs"</span>},</span><br><span class="line">            {<span class="number">39</span>,  <span class="string">"bbsbsssbsss"</span>},</span><br><span class="line">            {<span class="number">40</span>,  <span class="string">"bbsssbsbsss"</span>},</span><br><span class="line">            {<span class="number">41</span>,  <span class="string">"bbsssbsssbs"</span>},</span><br><span class="line">            {<span class="number">42</span>,  <span class="string">"bsbbsbbbsss"</span>},</span><br><span class="line">            {<span class="number">43</span>,  <span class="string">"bsbbsssbbbs"</span>},</span><br><span class="line">            {<span class="number">44</span>,  <span class="string">"bsssbbsbbbs"</span>},</span><br><span class="line">            {<span class="number">45</span>,  <span class="string">"bsbbbsbbsss"</span>},</span><br><span class="line">            {<span class="number">46</span>,  <span class="string">"bsbbbsssbbs"</span>},</span><br><span class="line">            {<span class="number">47</span>,  <span class="string">"bsssbbbsbbs"</span>},</span><br><span class="line">            {<span class="number">48</span>,  <span class="string">"bbbsbbbsbbs"</span>},</span><br><span class="line">            {<span class="number">49</span>,  <span class="string">"bbsbsssbbbs"</span>},</span><br><span class="line">            {<span class="number">50</span>,  <span class="string">"bbsssbsbbbs"</span>},</span><br><span class="line">            {<span class="number">51</span>,  <span class="string">"bbsbbbsbsss"</span>},</span><br><span class="line">            {<span class="number">52</span>,  <span class="string">"bbsbbbsssbs"</span>},</span><br><span class="line">            {<span class="number">53</span>,  <span class="string">"bbsbbbsbbbs"</span>},</span><br><span class="line">            {<span class="number">54</span>,  <span class="string">"bbbsbsbbsss"</span>},</span><br><span class="line">            {<span class="number">55</span>,  <span class="string">"bbbsbsssbbs"</span>},</span><br><span class="line">            {<span class="number">56</span>,  <span class="string">"bbbsssbsbbs"</span>},</span><br><span class="line">            {<span class="number">57</span>,  <span class="string">"bbbsbbsbsss"</span>},</span><br><span class="line">            {<span class="number">58</span>,  <span class="string">"bbbsbbsssbs"</span>},</span><br><span class="line">            {<span class="number">59</span>,  <span class="string">"bbbsssbbsbs"</span>},</span><br><span class="line">            {<span class="number">60</span>,  <span class="string">"bbbsbbbbsbs"</span>},</span><br><span class="line">            {<span class="number">61</span>,  <span class="string">"bbssbssssbs"</span>},</span><br><span class="line">            {<span class="number">62</span>,  <span class="string">"bbbbsssbsbs"</span>},</span><br><span class="line">            {<span class="number">63</span>,  <span class="string">"bsbssbbssss"</span>},</span><br><span class="line">            {<span class="number">64</span>,  <span class="string">"bsbssssbbss"</span>},</span><br><span class="line">            {<span class="number">65</span>,  <span class="string">"bssbsbbssss"</span>},</span><br><span class="line">            {<span class="number">66</span>,  <span class="string">"bssbssssbbs"</span>},</span><br><span class="line">            {<span class="number">67</span>,  <span class="string">"bssssbsbbss"</span>},</span><br><span class="line">            {<span class="number">68</span>,  <span class="string">"bssssbssbbs"</span>},</span><br><span class="line">            {<span class="number">69</span>,  <span class="string">"bsbbssbssss"</span>},</span><br><span class="line">            {<span class="number">70</span>,  <span class="string">"bsbbssssbss"</span>},</span><br><span class="line">            {<span class="number">71</span>,  <span class="string">"bssbbsbssss"</span>},</span><br><span class="line">            {<span class="number">72</span>,  <span class="string">"bssbbssssbs"</span>},</span><br><span class="line">            {<span class="number">73</span>,  <span class="string">"bssssbbsbss"</span>},</span><br><span class="line">            {<span class="number">74</span>,  <span class="string">"bssssbbssbs"</span>},</span><br><span class="line">            {<span class="number">75</span>,  <span class="string">"bbssssbssbs"</span>},</span><br><span class="line">            {<span class="number">76</span>,  <span class="string">"bbssbsbssss"</span>},</span><br><span class="line">            {<span class="number">77</span>,  <span class="string">"bbbbsbbbsbs"</span>},</span><br><span class="line">            {<span class="number">78</span>,  <span class="string">"bbssssbsbss"</span>},</span><br><span class="line">            {<span class="number">79</span>,  <span class="string">"bsssbbbbsbs"</span>},</span><br><span class="line">            {<span class="number">80</span>,  <span class="string">"bsbssbbbbss"</span>},</span><br><span class="line">            {<span class="number">81</span>,  <span class="string">"bssbsbbbbss"</span>},</span><br><span class="line">            {<span class="number">82</span>,  <span class="string">"bssbssbbbbs"</span>},</span><br><span class="line">            {<span class="number">83</span>,  <span class="string">"bsbbbbssbss"</span>},</span><br><span class="line">            {<span class="number">84</span>,  <span class="string">"bssbbbbsbss"</span>},</span><br><span class="line">            {<span class="number">85</span>,  <span class="string">"bssbbbbssbs"</span>},</span><br><span class="line">            {<span class="number">86</span>,  <span class="string">"bbbbsbssbss"</span>},</span><br><span class="line">            {<span class="number">87</span>,  <span class="string">"bbbbssbsbss"</span>},</span><br><span class="line">            {<span class="number">88</span>,  <span class="string">"bbbbssbssbs"</span>},</span><br><span class="line">            {<span class="number">89</span>,  <span class="string">"bbsbbsbbbbs"</span>},</span><br><span class="line">            {<span class="number">90</span>,  <span class="string">"bbsbbbbsbbs"</span>},</span><br><span class="line">            {<span class="number">91</span>,  <span class="string">"bbbbsbbsbbs"</span>},</span><br><span class="line">            {<span class="number">92</span>,  <span class="string">"bsbsbbbbsss"</span>},</span><br><span class="line">            {<span class="number">93</span>,  <span class="string">"bsbsssbbbbs"</span>},</span><br><span class="line">            {<span class="number">94</span>,  <span class="string">"bsssbsbbbbs"</span>},</span><br><span class="line">            {<span class="number">95</span>,  <span class="string">"bsbbbbsbsss"</span>},</span><br><span class="line">            {<span class="number">96</span>,  <span class="string">"bsbbbbsssbs"</span>},</span><br><span class="line">            {<span class="number">97</span>,  <span class="string">"bbbbsbsbsss"</span>},</span><br><span class="line">            {<span class="number">98</span>,  <span class="string">"bbbbsbsssbs"</span>},</span><br><span class="line">            {<span class="number">99</span>,  <span class="string">"bsbbbsbbbbs"</span>},</span><br><span class="line">            {<span class="number">100</span>,  <span class="string">"bsbbbbsbbbs"</span>},</span><br><span class="line">            {<span class="number">101</span>,  <span class="string">"bbbsbsbbbbs"</span>},</span><br><span class="line">            {<span class="number">102</span>,  <span class="string">"bbbbsbsbbbs"</span>},</span><br><span class="line">            <span class="comment">//      {103,"bbsbsbbbbss"},</span></span><br><span class="line">                        {<span class="number">103</span>,  <span class="string">"bbsbssssbss"</span>},</span><br><span class="line">                        {<span class="number">104</span>,  <span class="string">"bbsbssbssss"</span>},</span><br><span class="line">                        {<span class="number">105</span>,  <span class="string">"bbsbssbbbss"</span>},</span><br><span class="line">                        {<span class="number">106</span>,  <span class="string">"bbsssbbbsbsbb"</span>},</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        IntString&amp;inf = infs[iV];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (inf.psz[i] == <span class="string">'b'</span>)  *pb += <span class="number">1</span>;</span><br><span class="line">            pb++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (iV == <span class="number">106</span>) {</span><br><span class="line">            *pb += <span class="number">1</span>;  pb++;</span><br><span class="line">            *pb += <span class="number">1</span>;  pb++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pb;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetCheckDigit</span><span class="params">(<span class="type">const</span> <span class="type">int</span> iSet, <span class="type">char</span>*pszCode)</span> </span>{</span><br><span class="line">        <span class="type">int</span>  iSum = <span class="number">0</span>, iCurSet = <span class="number">0</span>, iChar128, iCharNext, iWeight, iPosition;</span><br><span class="line"></span><br><span class="line">        iCurSet = iSet;</span><br><span class="line">        <span class="keyword">if</span> (iSet == SUB::SETA) {</span><br><span class="line">            iSum = <span class="number">103</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (iSet == SUB::SETB) {</span><br><span class="line">                iSum = <span class="number">104</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span> (iSet == SUB::SETC) {</span><br><span class="line">                    iSum = <span class="number">105</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">        iPosition = <span class="number">0</span>;</span><br><span class="line">        iWeight = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> iNum = <span class="built_in">strlen</span>(pszCode);</span><br><span class="line">        <span class="keyword">while</span> (iPosition &lt; iNum) {</span><br><span class="line">            <span class="keyword">if</span> (iCurSet == SUB::SETC) {</span><br><span class="line">                <span class="keyword">if</span> (ga2_Code128[SUB::SETA][pszCode[iPosition]] == <span class="number">101</span>) {</span><br><span class="line">                    iChar128 = <span class="number">101</span>;</span><br><span class="line">                    iSum += (iWeight*iChar128);</span><br><span class="line"></span><br><span class="line">                    iPosition++;</span><br><span class="line">                    iWeight++;</span><br><span class="line">                    iCurSet = SUB::SETA;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ga2_Code128[SUB::SETA][pszCode[iPosition]] == <span class="number">100</span>) {</span><br><span class="line">                    iChar128 = <span class="number">100</span>;</span><br><span class="line">                    iSum += (iWeight*iChar128);</span><br><span class="line">                    iPosition++;</span><br><span class="line">                    iWeight++;</span><br><span class="line">                    iCurSet = SUB::SETB;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span> (ga2_Code128[SUB::SETA][pszCode[iPosition]] == <span class="number">102</span>) {</span><br><span class="line">                        iChar128 = <span class="number">102</span>;</span><br><span class="line">                        iSum += (iWeight*iChar128);</span><br><span class="line">                        iPosition++;</span><br><span class="line">                        iWeight++;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        <span class="type">char</span> chT = pszCode[iPosition + <span class="number">2</span>];</span><br><span class="line">                        pszCode[iPosition + <span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">                        iChar128 = <span class="built_in">atol</span>(&amp;pszCode[iPosition]);</span><br><span class="line">                        pszCode[iPosition + <span class="number">2</span>] = chT;</span><br><span class="line"></span><br><span class="line">                        iSum += (iWeight*iChar128);</span><br><span class="line">                        iPosition += <span class="number">2</span>;</span><br><span class="line">                        iWeight++;</span><br><span class="line">                    }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">int</span> iTemp2 = pszCode[iPosition];</span><br><span class="line">                <span class="keyword">if</span> (iTemp2 &lt; <span class="number">-1</span>)  iTemp2 = iTemp2 &amp; <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">                iChar128 = ga2_Code128[iCurSet][iTemp2];</span><br><span class="line"></span><br><span class="line">                iSum += (iWeight*iChar128);</span><br><span class="line"></span><br><span class="line">                iPosition++;</span><br><span class="line">                iWeight++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (iCurSet == SUB::SETA) {</span><br><span class="line">                    <span class="keyword">if</span> (iChar128 == <span class="number">100</span>)</span><br><span class="line">                        iCurSet = SUB::SETB;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (iChar128 == <span class="number">99</span>)</span><br><span class="line">                        iCurSet = SUB::SETC;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span> (iCurSet == SUB::SETB) {</span><br><span class="line">                        <span class="keyword">if</span> (iChar128 == <span class="number">101</span>)    iCurSet = SUB::SETA;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (iChar128 == <span class="number">99</span>)  iCurSet = SUB::SETC;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">if</span> (iChar128 == <span class="number">98</span>) {</span><br><span class="line">                            <span class="keyword">if</span> (iCurSet == SUB::SETA)</span><br><span class="line">                                iCharNext = ga2_Code128[SUB::SETB][pszCode[iPosition]];</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                iCharNext = ga2_Code128[SUB::SETA][pszCode[iPosition]];</span><br><span class="line"></span><br><span class="line">                            iSum += (iWeight*iCharNext);</span><br><span class="line">                            iPosition++;</span><br><span class="line">                            iWeight++;</span><br><span class="line">                        }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> iSum % <span class="number">103</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//=============================================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BarcodeEan13</span> :<span class="keyword">public</span> BarcodeBase {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BarcodeEan13</span>() {</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">BarcodeEan13</span>() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">EncodeEan13</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*pszCodeIn)</span> </span>{</span><br><span class="line">        <span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//only allow 12 characters as input</span></span><br><span class="line">        <span class="type">char</span> szCode[<span class="number">14</span>];</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> iLen = <span class="built_in">strlen</span>(pszCodeIn);</span><br><span class="line">        <span class="keyword">if</span> (iLen &gt; <span class="number">12</span>) {</span><br><span class="line">            <span class="built_in">strncpy</span>(szCode, pszCodeIn, <span class="number">12</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">strcpy</span>(szCode, pszCodeIn);</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">strlen</span>(szCode) &lt; <span class="number">12</span>)  <span class="built_in">strcat</span>(szCode, <span class="string">"0"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        BYTE*pFst = ia_Buf;</span><br><span class="line">        BYTE*pb = pFst;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//"bsb"-long</span></span><br><span class="line">        *pb += <span class="number">5</span>;  pb++;</span><br><span class="line">        *pb += <span class="number">4</span>;  pb++;</span><br><span class="line">        *pb += <span class="number">5</span>;  pb++;</span><br><span class="line"></span><br><span class="line">        BYTE iaCountryCode[<span class="number">6</span>];</span><br><span class="line">        BOOL b = <span class="built_in">P_GetCountryCode</span>(szCode[<span class="number">0</span>], iaCountryCode);</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        pb = <span class="built_in">P_GetLeftOddParity</span>(pb, szCode[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; <span class="number">7</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (iaCountryCode[i - <span class="number">2</span>] == <span class="string">'O'</span>) {</span><br><span class="line">                pb = <span class="built_in">P_GetLeftOddParity</span>(pb, szCode[i]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span> (iaCountryCode[i - <span class="number">2</span>] == <span class="string">'E'</span>) {</span><br><span class="line">                    pb = <span class="built_in">P_GetLeftEvenParity</span>(pb, szCode[i]);</span><br><span class="line">                }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//"sbsbs"-long</span></span><br><span class="line">        *pb += <span class="number">4</span>;  pb++;</span><br><span class="line">        *pb += <span class="number">5</span>;  pb++;</span><br><span class="line">        *pb += <span class="number">4</span>;  pb++;</span><br><span class="line">        *pb += <span class="number">5</span>;  pb++;</span><br><span class="line">        *pb += <span class="number">4</span>;  pb++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">7</span>; i &lt; <span class="number">12</span>; i++) {</span><br><span class="line">            pb = <span class="built_in">P_GetRightPattern</span>(pb, szCode[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        i = <span class="built_in">P_GetCheckSumDigit</span>(szCode);</span><br><span class="line">        pb = <span class="built_in">P_GetRightPattern</span>(pb, (<span class="type">char</span>)i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//"bsb"-long</span></span><br><span class="line">        *pb += <span class="number">5</span>;  pb++;</span><br><span class="line">        *pb += <span class="number">4</span>;  pb++;</span><br><span class="line">        *pb += <span class="number">5</span>;  pb++;</span><br><span class="line"></span><br><span class="line">        i_LenBuf = pb - pFst;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DrawEan13</span><span class="params">(HDC hDC, <span class="type">int</span> iX, <span class="type">int</span> iY0, <span class="type">int</span> iY10, <span class="type">int</span> iY11, <span class="type">const</span> COLORREF clrBar, <span class="type">const</span> COLORREF clrSpace, <span class="type">const</span> <span class="type">int</span> iPenW)</span> </span>{</span><br><span class="line">        <span class="built_in">DrawBarcode</span>(hDC, iX, iY0, iY10, iY11, clrBar, clrSpace, iPenW);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">BOOL <span class="title">P_GetCountryCode</span><span class="params">(<span class="type">char</span> ch, BYTE*pbCountryCode)</span> </span>{</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> iV = ch - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (iV &lt; <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (iV &gt; <span class="number">9</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        IntString infs[] =</span><br><span class="line">        {</span><br><span class="line">            {<span class="number">0</span>,  <span class="string">"OOOOO"</span>},</span><br><span class="line">            {<span class="number">1</span>,  <span class="string">"OEOEE"</span>},</span><br><span class="line">            {<span class="number">2</span>,  <span class="string">"OEEOE"</span>},</span><br><span class="line">            {<span class="number">3</span>,  <span class="string">"OEEEO"</span>},</span><br><span class="line">            {<span class="number">4</span>,  <span class="string">"EOOEE"</span>},</span><br><span class="line">            {<span class="number">5</span>,  <span class="string">"EEOOE"</span>},</span><br><span class="line">            {<span class="number">6</span>,  <span class="string">"EEEOO"</span>},</span><br><span class="line">            {<span class="number">7</span>,  <span class="string">"EOEOE"</span>},</span><br><span class="line">            {<span class="number">8</span>,  <span class="string">"EOEEO"</span>},</span><br><span class="line">            {<span class="number">9</span>,  <span class="string">"EEOEO"</span>},</span><br><span class="line">        };</span><br><span class="line">        <span class="built_in">memcpy</span>(pbCountryCode, infs[iV].psz, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">BYTE*<span class="title">P_GetLeftOddParity</span><span class="params">(BYTE*pb, <span class="type">char</span> ch)</span> </span>{</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> iV = ch - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (iV &lt; <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (iV &gt; <span class="number">9</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        IntString infs[] =</span><br><span class="line">        {</span><br><span class="line">            {<span class="number">0</span>,  <span class="string">"sssbbsb"</span>},</span><br><span class="line">            {<span class="number">1</span>,  <span class="string">"ssbbssb"</span>},</span><br><span class="line">            {<span class="number">2</span>,  <span class="string">"ssbssbb"</span>},</span><br><span class="line">            {<span class="number">3</span>,  <span class="string">"sbbbbsb"</span>},</span><br><span class="line">            {<span class="number">4</span>,  <span class="string">"sbsssbb"</span>},</span><br><span class="line">            {<span class="number">5</span>,  <span class="string">"sbbsssb"</span>},</span><br><span class="line">            {<span class="number">6</span>,  <span class="string">"sbsbbbb"</span>},</span><br><span class="line">            {<span class="number">7</span>,  <span class="string">"sbbbsbb"</span>},</span><br><span class="line">            {<span class="number">8</span>,  <span class="string">"sbbsbbb"</span>},</span><br><span class="line">            {<span class="number">9</span>,  <span class="string">"sssbsbb"</span>},</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        IntString&amp;inf = infs[iV];</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (inf.psz[i] == <span class="string">'b'</span>)  *pb += <span class="number">1</span>;</span><br><span class="line">            pb++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pb;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">BYTE*<span class="title">P_GetLeftEvenParity</span><span class="params">(BYTE*pb, <span class="type">char</span> ch)</span> </span>{</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> iV = ch - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (iV &lt; <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (iV &gt; <span class="number">9</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        IntString infs[] =</span><br><span class="line">        {</span><br><span class="line">            {<span class="number">0</span>,  <span class="string">"sbssbbb"</span>},</span><br><span class="line">            {<span class="number">1</span>,  <span class="string">"sbbssbb"</span>},</span><br><span class="line">            {<span class="number">2</span>,  <span class="string">"ssbbsbb"</span>},</span><br><span class="line">            {<span class="number">3</span>,  <span class="string">"sbssssb"</span>},</span><br><span class="line">            {<span class="number">4</span>,  <span class="string">"ssbbbsb"</span>},</span><br><span class="line">            {<span class="number">5</span>,  <span class="string">"sbbbssb"</span>},</span><br><span class="line">            {<span class="number">6</span>,  <span class="string">"ssssbsb"</span>},</span><br><span class="line">            {<span class="number">7</span>,  <span class="string">"ssbsssb"</span>},</span><br><span class="line">            {<span class="number">8</span>,  <span class="string">"sssbssb"</span>},</span><br><span class="line">            {<span class="number">9</span>,  <span class="string">"ssbsbbb"</span>},</span><br><span class="line">        };</span><br><span class="line">        <span class="type">char</span>*psz = infs[iV].psz;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (psz[i] == <span class="string">'b'</span>)  *pb += <span class="number">1</span>;</span><br><span class="line">            pb++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pb;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">BYTE*<span class="title">P_GetRightPattern</span><span class="params">(BYTE*pb, <span class="type">char</span> ch)</span> </span>{</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> iV = ch - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (iV &lt; <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (iV &gt; <span class="number">9</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        IntString infs[] =</span><br><span class="line">        {</span><br><span class="line">            {<span class="number">0</span>,  <span class="string">"bbbssbs"</span>},</span><br><span class="line">            {<span class="number">1</span>,  <span class="string">"bbssbbs"</span>},</span><br><span class="line">            {<span class="number">2</span>,  <span class="string">"bbsbbss"</span>},</span><br><span class="line">            {<span class="number">3</span>,  <span class="string">"bssssbs"</span>},</span><br><span class="line">            {<span class="number">4</span>,  <span class="string">"bsbbbss"</span>},</span><br><span class="line">            {<span class="number">5</span>,  <span class="string">"bssbbbs"</span>},</span><br><span class="line">            {<span class="number">6</span>,  <span class="string">"bsbssss"</span>},</span><br><span class="line">            {<span class="number">7</span>,  <span class="string">"bsssbss"</span>},</span><br><span class="line">            {<span class="number">8</span>,  <span class="string">"bssbsss"</span>},</span><br><span class="line">            {<span class="number">9</span>,  <span class="string">"bbbsbss"</span>},</span><br><span class="line">        };</span><br><span class="line">        <span class="type">char</span>*psz = infs[iV].psz;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (psz[i] == <span class="string">'b'</span>)  *pb += <span class="number">1</span>;</span><br><span class="line">            pb++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pb;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">P_GetCheckSumDigit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*pszCode)</span> </span>{</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> iLen = <span class="built_in">strlen</span>(pszCode);</span><br><span class="line">        <span class="type">int</span> i, iSum = <span class="number">0</span>, iItem;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = iLen; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">            iItem = i % <span class="number">2</span> ? (pszCode[i - <span class="number">1</span>] - <span class="string">'0'</span>) * <span class="number">1</span> : (pszCode[i - <span class="number">1</span>] - <span class="string">'0'</span>) * <span class="number">3</span>;</span><br><span class="line">            iSum += iItem;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iSum %= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'0'</span> + (<span class="number">10</span> - iSum) % <span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>批处理运行外部程序</title>
      <link href="/post/2372684836.html"/>
      <url>/post/2372684836.html</url>
      
        <content type="html"><![CDATA[<p>本文介绍了批处理中启动外部程序和批处理的几种不同方法，以及如何获取命令返回值，最后还介绍了批处理中命令顺序执行的几种方法的区别。</p><span id="more"></span><h1 id="1-start、call-和直接运行"><a href="#1-start、call-和直接运行" class="headerlink" title="1. start、call 和直接运行"></a>1. start、call 和直接运行</h1><h2 id="1-1-start"><a href="#1-1-start" class="headerlink" title="1.1 start"></a>1.1 start</h2><p>使用 start 命令时，当前批处理不会等待外部程序运行结束，而是继续向下执行。</p><p>使用 start 命令运行其他批处理和 windows 命令行程序时，还会创建一个新的命令行窗口，并将在新的窗口中运行新的程序，如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">echo 1</span><br><span class="line">start ping baidu.com</span><br><span class="line">echo 2</span><br><span class="line">start notepad.exe</span><br><span class="line">echo 3</span><br><span class="line">start other.bat</span><br><span class="line">echo 4</span><br><span class="line">pause</span><br></pre></td></tr></tbody></table></figure><h2 id="1-2-call"><a href="#1-2-call" class="headerlink" title="1.2 call"></a>1.2 call</h2><p>使用 call 命令时，当前批处理会等待外部程序或批处理运行结束，然后才继续向下执行。并且始终在当前命令行窗口中运行其他批处理和命令行程序。</p><h2 id="1-3-直接运行"><a href="#1-3-直接运行" class="headerlink" title="1.3 直接运行"></a>1.3 直接运行</h2><p>直接运行与使用 call 命令一样。但直接运行外部批处理时会破坏当前批处理的运行流程，会导致执行流程无法返回到当前批处理继续执行。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">echo 1</span><br><span class="line">ping baidu.com</span><br><span class="line">echo 2</span><br><span class="line">notepad.exe</span><br><span class="line">echo 3</span><br><span class="line">other.bat</span><br><span class="line">echo 4</span><br><span class="line">pause</span><br></pre></td></tr></tbody></table></figure><p>上述示例，执行<code>other.bat</code>后，无法返回到当前批处理，从而无法执行<code>echo 4</code>及后面语句。</p><h1 id="2-获取命令的返回值"><a href="#2-获取命令的返回值" class="headerlink" title="2. 获取命令的返回值"></a>2. 获取命令的返回值</h1><p>在 Windows 批处理中，<code>%errorlevel%</code>变量保存着上一个命令的执行结果（即<code>main</code>函数的返回值）。一般来说，0 表示执行成功，非 0 则表示执行失败，具体的非 0 值的含义则取决于具体的命令。</p><p>在批处理脚本中，可以根据<code>%errorlevel%</code>的值来进行后续的处理逻辑，例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">REM 执行一个命令</span><br><span class="line">start un-exist.exe</span><br><span class="line"></span><br><span class="line">REM 判断命令执行结果</span><br><span class="line">if %errorlevel% equ 0 (</span><br><span class="line">    echo success</span><br><span class="line">) else (</span><br><span class="line">    echo failed with: %errorlevel%</span><br><span class="line">)</span><br><span class="line">pause</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">系统找不到文件 un-exist.exe。</span><br><span class="line">failed with: 9059</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></tbody></table></figure><p><code>%errorlevel%</code>是上一个命令的执行结果，因此上面例子中的 9059 是 start 命令的结果，而不是 un-exist.exe 返回的结果。</p><h1 id="3-顺序执行"><a href="#3-顺序执行" class="headerlink" title="3. 顺序执行"></a>3. 顺序执行</h1><p>Windows 批处理提供了<code>&amp;</code>、<code>&amp;&amp;</code>、<code>||</code>、<code>|</code>、<code>&gt;</code>、<code>&gt;&gt;</code>等顺序执行方式，它们区别如下（下面说的执行成功指的是命令返回值为 0）：</p><ul><li><code>&amp;</code> 顺序执行多条命令，而不管前面命令是否执行成功。</li><li><code>&amp;&amp;</code> 顺序执行多条命令，当前面命令执行出错，后面的命令将不会执行。</li><li><code>||</code> 顺序执行多条命令，直到遇到执行成功的命令。</li><li><code>|</code> 管道命令，将前一个命令的执行结果输出到后一个命令 如：<code>help|more</code>。</li><li><code>&gt;</code> 文件写入命令，清除原文件中的内容后再写入。</li><li><code>&gt;&gt;</code> 文件追加写入命令</li></ul>]]></content>
      
      
      <categories>
          
          <category> ⑩ 编程基础 </category>
          
          <category> 批处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前后端常用概念扫盲</title>
      <link href="/post/1162897275.html"/>
      <url>/post/1162897275.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍前后端及客户端开发中遇到的一些常用的技术概念，本文不会涉及太深奥的技术细节。</p><span id="more"></span><h2 id="1-浏览器内核"><a href="#1-浏览器内核" class="headerlink" title="1. 浏览器内核"></a>1. 浏览器内核</h2><p>在 Web 大行其道的时代，网民需要上网浏览网页就需要依赖浏览器这个软件，掌握了浏览器就掌握了流量的入口，于是各大软件公司开始研发自己品牌的浏览器，不同品牌的浏览器其实现原理当然是有区别的，这个实现原理就是浏览器的核心，我们称其浏览器内核。</p><p>现在市面上有这么多的浏览器，如 Chrome，QQ 浏览器，搜狗浏览器，这些浏览器厂商是不是都是自己研发浏览器内核了？不是的！</p><p>因为有些公司或者团体将浏览器内核进行了开源，方便其他人基于该内核进行二次开发，常见的开源浏览器内核有 Chromium、WebKit、Gecko。</p><p>正因为有了这些开源内核的存在，我们可以不用自己开发内核也可以开发属于自己品牌的浏览器，比如 QQ 浏览器，搜狗浏览器，360 浏览器都是基于 IE 内核和 Chromium 内核二次封装而成，美其名曰双引擎（双内核）。</p><p>目前市面上流行的拥有自主内核的浏览器：</p><table><thead><tr><th>浏览器</th><th>内核</th></tr></thead><tbody><tr><td>Chrome</td><td>Chromium</td></tr><tr><td>Safari</td><td>WebKit</td></tr><tr><td>Firefox</td><td>Gecko</td></tr><tr><td>IE</td><td>IE 内核</td></tr></tbody></table><h2 id="2-JavaScript-ECMAScript-ES6-TypeScript"><a href="#2-JavaScript-ECMAScript-ES6-TypeScript" class="headerlink" title="2. JavaScript, ECMAScript, ES6, TypeScript"></a>2. JavaScript, ECMAScript, ES6, TypeScript</h2><p><code>JavaScript</code>是一个编程语言的名称，类似 Java，C++，PHP，是由 Netscape 公司开发的一种解释性编程语言，其运行的宿主环境大多是浏览器，但也可以是其他环境，如 Node。</p><p>因为 Netscape 公司希望<code>JavaScript</code>成为一种浏览器脚本语言的标准规范，于是在 1996 年将 JavaScript 提交给标准化组织 ECMA。次年，ECMA 就发布了标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种标准称为 ECMAScript。</p><p>所以说，<code>ECMAScript</code>是一个的浏览器脚本语言的<strong>标准规范</strong>。</p><p>不同的浏览器内核及不同的版本对<code>ECMAScript</code>规范的支持情况不同， 截至 2012 年，所有浏览器都完整的支持<code>ECMAScript 5.1</code>；</p><p>从<code>ECMAScript 6</code>开始，标准制定者决定不再用诸如”3.1, 5.0”这样的版本号来命名，而是每年 6 月发布一个 ECMAScript 的正式版，并且以当年的年份来命名， 如 2015 年 6 月 17 日 ECMA 国际组织发布了 ECMAScript 的第六版，该版本正式名称为<code>ECMAScript 2015</code>。</p><p><code>ES6</code>只是<code>ECMAScript 6</code>版本的简称，我们一般用<code>ECMAScript 6</code>来统称<code>ECMAScript 2015</code>及其以后的版本。</p><p><code>TypeScript</code>是由微软开发的一种开源的编程语言。它是 JavaScript 的一个严格超集，并添加了静态类型及其他特性。<code>TypeScript</code>目前已经支持<code>ECMAScript 2015</code>。</p><h2 id="3-CSS-CSS3"><a href="#3-CSS-CSS3" class="headerlink" title="3. CSS, CSS3"></a>3. CSS, CSS3</h2><p><code>CSS</code>即<code>Cascading Style Sheets</code>层叠样式表的简称，在 Web 开发中用来定义元素样式的一种标记型语言。<br><code>CSS3</code>是 CSS（层叠样式表）的升级版本，2001 年 5 月 23 日 W3C 完成了 CSS3 的工作草案。</p><h2 id="4-V8-Node-Node-js-npm-Yarn"><a href="#4-V8-Node-Node-js-npm-Yarn" class="headerlink" title="4. V8, Node, Node.js, npm, Yarn"></a>4. V8, Node, Node.js, npm, Yarn</h2><p>V8，我们通常叫做 V8 引擎，然而其并不是汽车发动机的 V8 引擎，而是由 Google 开发并开源的一个项目，可以解释和执行 JavaScript，因为其性能非常高，目前得到了广泛的应用，如 Node.js 就是基于该引擎而开发。</p><p>Node.js 和 Node 是一个东西，Node 是 Node.js 的简称。</p><p><code>npm</code>（<code>node package management</code>）是 Node.js 的一个包管理工具，目前已经内置到了 Node.js 中，不需要再单独安装。</p><p><code>yarn</code>也是一个包管理工具，由 Facebook、Google、Exponent 和 Tilde 联合推出，其目的是为了弥补 npm 的一些缺陷。</p><h2 id="5-React-Vue-Angular"><a href="#5-React-Vue-Angular" class="headerlink" title="5. React, Vue, Angular"></a>5. React, Vue, Angular</h2><p>这 3 个说白了都是 Javascript 库。</p><p>我们最初开发 Web 的时候用的是<code>HTML+CSS+JavaScript</code>，后来有人觉得用纯 js 撸太繁琐了，就有了后来的 jQuery 这样的 JavaScript 库，但随着业务的扩增，数据交互越来越复杂，使用 jQuery 也太繁琐了，于时又有了 React, Vue, Angular 这样的库。</p><p>总之，前端生态真繁荣。。。。</p><h2 id="6-Ant-Design-Element-UI"><a href="#6-Ant-Design-Element-UI" class="headerlink" title="6. Ant Design, Element UI"></a>6. Ant Design, Element UI</h2><p>前面说到了 React, Vue, Angular，虽然又了这些库，数据交互方面变得简单了，但页面效果还是需要 CSS 和 JS 一行行代码来实现的，比如要实现一个下拉列表，动态按钮等。于时现在又出现了一些基于 React, Vue 和 Angular 这些库的 UI 组件库，这些 UI 库将常用的组件封装好了，在开发中直接引入使用，改改属性，设置下参数即可。</p><h2 id="7-Scaffold-脚手架"><a href="#7-Scaffold-脚手架" class="headerlink" title="7. Scaffold(脚手架)"></a>7. Scaffold(脚手架)</h2><p>通俗的讲就是将一些重复性的事情整合成一个工具，这个工具就可以叫脚手架。</p><h2 id="8-MySQL-Redis-MongoDB-Oracle-PostgreSQL-NoSQL"><a href="#8-MySQL-Redis-MongoDB-Oracle-PostgreSQL-NoSQL" class="headerlink" title="8. MySQL, Redis, MongoDB, Oracle, PostgreSQL, NoSQL"></a>8. MySQL, Redis, MongoDB, Oracle, PostgreSQL, NoSQL</h2><p>数据库目前分为关系型数据库和非关系型数据（即 NoSQL），不同类型的数据各有其特点。同样，同一类型但不同品牌的数据库也各有其特点和应用领域 。</p><p>不能单纯的评判哪种数据库的好坏，一个项目中可能同时用到多个不同种类的数据库。</p><p>1、关系数据库<br>MySQL、MariaDB、PostgreSQL、Microsoft Access、Microsoft SQL Server、Oracle、Sybase 等等。</p><p>2、非关系型数据库（NoSQL）<br>BigTable（Google）、Cassandra、MongoDB、CouchDB、Redis 等等。</p><h2 id="9-Nginx-Apache"><a href="#9-Nginx-Apache" class="headerlink" title="9. Nginx, Apache"></a>9. Nginx, Apache</h2><p>都是 Web 服务器，不同的团队研发，各有其优缺点。</p><h2 id="10-反向代理"><a href="#10-反向代理" class="headerlink" title="10. 反向代理"></a>10. 反向代理</h2><p><code>反向代理</code>单纯从名字上理解就是<code>正向代理</code>的反方向。</p><p>那什么是正向代理？代理<code>内部网络</code>访问<code>外部网络</code>的代理就是正向代理，比如你需要从公司局域网中的电脑 A 经过代理服务器 B 访问网站 C：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A --&gt; B --&gt; C</span><br></pre></td></tr></tbody></table></figure><p>如果你认为 A 是内部网络，C 是外部网络，那 B 就是正向代理；</p><p>如果你认为 A 是外部网络，C 是内部网络（当然我们一般不这么认为），那么 B 就是反向代理。</p><h2 id="11-RESTful"><a href="#11-RESTful" class="headerlink" title="11. RESTful"></a>11. RESTful</h2><p>一切具有 REST 特性的服务都可以成为 RESTful 服务，那么 REST 特性是什么了？</p><p>REST 是<code>Representational state transfer</code>的缩写，维基百科上的解释为：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Representational State Transfer (REST) is a software architecture style consisting of guidelines and best practices for creating scalable web services. REST is a coordinated set of constraints applied to the design of components in a distributed hypermedia system that can lead to a more performant and maintainable architecture.</span><br></pre></td></tr></tbody></table></figure><p>REST 是一种架构风格, 只有满足这些约束，才能称之为符合 REST 架构风格。REST 的约束大致包括：</p><ol><li>客户端-服务器结构</li><li>无状态</li><li>可缓存</li><li>按需代码（可选）</li><li>统一接口</li></ol><blockquote><p>持续更新中….</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ⑫ Web开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typescript基础语法</title>
      <link href="/post/2248228478.html"/>
      <url>/post/2248228478.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果你还不了解 TypeScript 是什么，或者其与 JavaScript 之前的关系，可以参考：- <a href="/post/1162897275.html" title="前后端常用概念扫盲">前后端常用概念扫盲</a></p></blockquote><p>TypeScript 是 JavaScript 的一个超集，支持 ES6 的语法规范，并在此基础上进行了增强，二者最大的不同在于：TypeScript 是强类型语言，而 JavaScript 是弱类型的语言。</p><span id="more"></span><p>本文将着重介绍二者的不同之处。</p><h1 id="一、变量声明"><a href="#一、变量声明" class="headerlink" title="一、变量声明"></a>一、变量声明</h1><p>TypeScript 支持使用<code>var</code>、<code>let</code>、<code>const</code>进行变量声明，但建议不要使用<code>var</code>。<br>TypeScript 声明变量时，可以强制指定变量类型或者由编译器自动从“值”推导出变量类型，但无论哪种情况，一旦确定了类型，后面不能再次被赋值为其他类型：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a = <span class="string">"x"</span>; ❌</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b : number = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> c : number = <span class="string">"x"</span>; ❌</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">fibonacci</span>: number[] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">fibonacci</span>: number[] = [<span class="number">1</span>, <span class="string">'1'</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];❌</span><br></pre></td></tr></tbody></table></figure><h1 id="二、函数参数"><a href="#二、函数参数" class="headerlink" title="二、函数参数"></a>二、函数参数</h1><p>TypeScript 要求：调用函数时传入的参数必须与函数声明的参数一致（个数及类型），如：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x: number, y: number</span>): number {</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">}</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); ❌</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>);❌</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="string">"x"</span>); ❌</span><br></pre></td></tr></tbody></table></figure><p>TypeScript 要求：可选参数必须在参数列表的最后，如：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName?: string, lastName: string</span>) {❌</span><br><span class="line">    <span class="keyword">if</span> (firstName) {</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="三、枚举"><a href="#三、枚举" class="headerlink" title="三、枚举"></a>三、枚举</h1><p>枚举是 TypeScript 特有的：<br>第一个元素没有赋值，则默认为 0，后面的元素的值依此递增：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="title class_">Days</span> {</span><br><span class="line">    <span class="title class_">Sun</span>,   <span class="comment">// 0</span></span><br><span class="line">    <span class="title class_">Mon</span>,  <span class="comment">// 1</span></span><br><span class="line">    <span class="title class_">Tue</span>,  <span class="comment">// 2</span></span><br><span class="line">    <span class="title class_">Wed</span>,</span><br><span class="line">    <span class="title class_">Thu</span>,</span><br><span class="line">    <span class="title class_">Fri</span>,</span><br><span class="line">    <span class="title class_">Sat</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>也支持：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="title class_">Days</span> {</span><br><span class="line">    <span class="title class_">Sun</span> = <span class="number">1</span>,   <span class="comment">// 1</span></span><br><span class="line">    <span class="title class_">Mon</span>,  <span class="comment">// 2</span></span><br><span class="line">    <span class="title class_">Tue</span>,  <span class="comment">// 3</span></span><br><span class="line">    <span class="title class_">Wed</span> = <span class="number">10</span>,  <span class="comment">// 10</span></span><br><span class="line">    <span class="title class_">Thu</span>,  <span class="comment">// 11</span></span><br><span class="line">    <span class="title class_">Fri</span>,  <span class="comment">// 12</span></span><br><span class="line">    <span class="title class_">Sat</span>   <span class="comment">// 13</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>枚举元素可以是常量值或是可以通过编译期计算得出的值：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="title class_">FileAccess</span> {</span><br><span class="line">    <span class="comment">// 常量值</span></span><br><span class="line">    <span class="title class_">None</span>,   <span class="comment">// 0</span></span><br><span class="line">    <span class="title class_">Read</span>    = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    <span class="title class_">Write</span>   = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    <span class="title class_">ReadWrite</span>  = <span class="title class_">Read</span> | <span class="title class_">Write</span>,</span><br><span class="line">    <span class="comment">// 计算得出的值</span></span><br><span class="line">    G = <span class="string">"123"</span>.<span class="property">length</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="四、类"><a href="#四、类" class="headerlink" title="四、类"></a>四、类</h1><p>相比<code>ES6</code>，<code>TypeScript</code>新增了继承、成员访问控制修饰符。越来越有 Java、C++的味道了。</p><h2 id="4-1-继承、成员访问控制修饰符"><a href="#4-1-继承、成员访问控制修饰符" class="headerlink" title="4.1 继承、成员访问控制修饰符"></a>4.1 继承、成员访问控制修饰符</h2><p>TypeScript 继承需要使用<code>extends</code>关键字，只支持单继承，这点不同于 C++。<br>类继承后，子类可以重写父类的方法。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    private <span class="attr">id</span>: string;  <span class="comment">// 私有的，只能被自身访问</span></span><br><span class="line"></span><br><span class="line">    protected <span class="attr">name</span>: string;  <span class="comment">// 受保护，可以被其自身以及其子类和父类访问</span></span><br><span class="line">    protected <span class="attr">age</span>: number;   <span class="comment">// 公开的</span></span><br><span class="line"></span><br><span class="line">    public <span class="title function_">getId</span>() : string {</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">id</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public <span class="title function_">getName</span>() : string {</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public <span class="title function_">getAge</span>() : number {</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public <span class="title function_">print</span>() : <span class="keyword">void</span> {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"name:"</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">", age:"</span> + <span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> {</span><br><span class="line">    private grade : number;</span><br><span class="line"></span><br><span class="line">    public <span class="title function_">getGrade</span>() : number {</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">grade</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public <span class="title function_">print</span>() : <span class="keyword">void</span> { <span class="comment">// 重写了父类的方法</span></span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">print</span>();  <span class="comment">// 使用super直接调用父类方法</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"grade:"</span> + <span class="variable language_">this</span>.<span class="property">grade</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-2-instanceof"><a href="#4-2-instanceof" class="headerlink" title="4.2 instanceof"></a>4.2 instanceof</h2><p><code>instanceof</code> 运算符用于判断对象是否是指定的类型，如果是返回<code>true</code>，否则返回<code>false</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {}</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="attr">isPerson</span>: boolean = obj <span class="keyword">instanceof</span> <span class="title class_">Person</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="4-3-interface-接口"><a href="#4-3-interface-接口" class="headerlink" title="4.3 interface 接口"></a>4.3 interface 接口</h2><p>TypeScript 新增 interface 接口的概念，这个接口的概念和 Java 中的 interface 类似，即：只有定义没有实现。</p><p>同时，接口也支持继承。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">IPerson</span> {</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IStudent</span> <span class="keyword">extends</span> <span class="title class_">IPerson</span> {</span><br><span class="line">  <span class="comment">// 接口的继承</span></span><br><span class="line">  <span class="attr">grade</span>: number;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> implements <span class="title class_">IStudent</span> {</span><br><span class="line">  <span class="comment">// 实现接口的类</span></span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  <span class="attr">grade</span>: number;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="五、命名空间"><a href="#五、命名空间" class="headerlink" title="五、命名空间"></a>五、命名空间</h1><p>TypeScript 中的命名空间的概念和 C++中的命名空间的概念一样，而且关键字也都是<code>namespace</code>。</p><p>稍有不同的是，C++不需要将命名空间中的内容暴露出来，C++默认就是全部暴露的，而 TypeScript 需要手动添加 export 关键字将命名空间的中的内容暴露出来：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">namespace <span class="variable constant_">XYZ</span> {</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">let</span> name : string;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> interface <span class="title class_">IPerson</span> {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">XYZ</span>.<span class="property">name</span> = <span class="string">"jeff"</span>;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑫ Web开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript6基础语法</title>
      <link href="/post/51642520.html"/>
      <url>/post/51642520.html</url>
      
        <content type="html"><![CDATA[<p>ECMAScript 标准的发展经历了一个漫长的过程，从 1997 年发布的<code>ECMAScript 1.0</code>，到 2011 年的<code>ECMAScript 5.1</code>，再到 2015 年的<code>ECMAScript 2015</code>，以及后面每年都会发布的一个新的 ECMAScript 版本，版本众多，而且每个版本都有新特性的加入。</p><span id="more"></span><p>我们通常用<code>ECMAScript 6</code>来统称<code>ECMAScript 2015</code>及其之后的的版本。</p><p>但<code>ECMAScript 2015</code>可谓是 ECMAScript 标准的分水岭，其从制定到发布前后经历了 15 年。目前绝大多数浏览器都已支持<code>ECMAScript 2015</code>特性，并部分的支持了后面版本的新特性，所以对于需要快速入门的初学者，只需要直接学习<code>ECMAScript 2015</code>标准即可，编写完全遵守<code>ECMAScript 2015</code>标准的代码不仅更加严谨，而且可以节省不少学习时间。</p><p>即便对于那些不支持<code>ECMAScript 6</code>的浏览器（如 IE11），我们也可以使用<a href="https://babeljs.io/">Babel</a>之类的工具将其转换为<code>ECMAScript 5</code>标准的代码。</p><blockquote><p>查看浏览器对 ES 特性的支持情况，可以访问：<a href="https://kangax.github.io/compat-table/es6/">https://kangax.github.io/compat-table/es6/</a></p></blockquote><p><strong>下文讲述的都是支持 ECMAScript 6 标准的 JavaScript 语法</strong></p><h1 id="零"><a href="#零" class="headerlink" title="零"></a>零</h1><ol><li>JavaScript 是大小写敏感的</li><li>在每行只写一条语句时，结尾可以不加分号<code>;</code>，但建议每条语句都以分号结尾</li></ol><h1 id="一、七种基本数据类型"><a href="#一、七种基本数据类型" class="headerlink" title="一、七种基本数据类型"></a>一、七种基本数据类型</h1><p>基本数据类型有以下 7 种：</p><ol><li>undefined</li><li>null</li><li>Boolean</li><li>String</li><li>Number</li><li>Object</li><li>Symbol</li></ol><p>JavaScript 虽然是弱类型的语言，但不代表其没有数据类型，其弱类型指的是在声明变量的时候不需要（<strong>也不能</strong>）指明变量类型，编译器会根据“值”的类型自动将变量转换成合适的类型。</p><p>所以无论是值还是变量终究还是有类型的，对于开发者而言，不需要关注什么类型的值应该赋值给什么类型的变量。</p><p>我们可以使用<code>typeof</code>查看每个变量或值的类型：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">123</span>); <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">"abc"</span>); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) {}); <span class="comment">// function</span></span><br></pre></td></tr></tbody></table></figure><p>值得注意的是<code>undefined</code>的类型是<code>undefined</code>，但<code>null</code>的类型是<code>object</code>，下面的章节会介绍<code>undefined</code>和<code>null</code>的区别。</p><h1 id="二、变量声明方式"><a href="#二、变量声明方式" class="headerlink" title="二、变量声明方式"></a>二、变量声明方式</h1><p>声明变量的方式有 3 种：</p><ol><li>let 用来声明变量</li><li>var 也是用来声明变量的</li><li>const 用来声明常量，必须在声明的时候赋初始值，且以后不能再修改</li></ol><blockquote><p><code>var</code>是<code>ES6</code>之前的，建议不要在代码中使用 var，这样可以避免很多不必要的问题，比如<code>变量提升</code>、<code>暂时性死区</code>等，本文也只讲述<code>let</code>和<code>const</code>，忘记<code>var</code>吧，一起走向新世界。</p></blockquote><h2 id="2-1-变量具有作用域的概念"><a href="#2-1-变量具有作用域的概念" class="headerlink" title="2.1 变量具有作用域的概念"></a>2.1 变量具有作用域的概念</h2><p>用 let 和 const 声明的变量或常量的作用域可以精确到<code>“块级别”</code></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line">}</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 依次输出0~9</span></span><br><span class="line">}</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) {</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">789</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 123</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无论是let还是const都是一样的，在同一个作用域内不能重复声明</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">123</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">456</span>; <span class="comment">// SyntaxError: Identifier 'a' has already been declared</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">123</span>;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">456</span>; <span class="comment">// SyntaxError: Identifier 'a' has already been declared</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2-块级作用域内的-let"><a href="#2-2-块级作用域内的-let" class="headerlink" title="2.2 块级作用域内的 let"></a>2.2 块级作用域内的 let</h2><p>只要“块级作用域内”存在 let 命令，它所声明的变量就“绑定”到这个区域，不再受外部的影响</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) {</span><br><span class="line">  a = <span class="number">456</span>; <span class="comment">// ReferenceError: Cannot access 'a' before initialization</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">789</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 123</span></span><br></pre></td></tr></tbody></table></figure><p>这个和其他语言不太一样，如果是 C/C++这样的语言是不会报错的，只会在<code>let a = 789;</code>给出“局部变量覆盖了全局变量”的警告。</p><p>但在 ES6 中却会报错，我们可以这样理解为“强龙压不过地头蛇”：<br>我用<code>let a = 789;</code>在蓝色区域内声明了变量<code>a</code>，那么在这个蓝色区域的一亩三分地内的都是我说了算，<code>a = 456;</code>敢在我还没声明前都赋值，那我还不给你报个错。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/es6-yufa-1.png"></p><h2 id="2-3-for-循环的变量作用域"><a href="#2-3-for-循环的变量作用域" class="headerlink" title="2.3 for 循环的变量作用域"></a>2.3 for 循环的变量作用域</h2><p>for 循环设置循环变量的部分是一个父作用域，而循环体内部是一个单独的子作用域</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">"abc"</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// abc</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>虽然编译器没有报错，但尽量不要写这样代码，不利于后期维护。</p><h1 id="三、Object-与-Class"><a href="#三、Object-与-Class" class="headerlink" title="三、Object 与 Class"></a>三、Object 与 Class</h1><p>Object（对象）是 ES5 就已经有的概念，Class（类）是 ES6 引入的概念。</p><h2 id="3-1-关于-JavaScript-中类和对象的叫法"><a href="#3-1-关于-JavaScript-中类和对象的叫法" class="headerlink" title="3.1 关于 JavaScript 中类和对象的叫法"></a>3.1 关于 JavaScript 中类和对象的叫法</h2><p>学过任何一个面向对象编程语言的同学都知道，<strong>对象是类的实例</strong>，比如在 Java 中：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br></pre></td></tr></tbody></table></figure><p><code>a</code>为对象，<code>A</code>为类，也就是“对象 a 为类型 A 的实例”。</p><p>而大家可能也发现了很多 JavaScript 教程称<code>Object</code>、<code>Number</code>、<code>String</code>为<strong>对象</strong>，如果根据这个称呼来，下面的代码岂不是“对象 a 为对象 Number 的实例”，很显然在这种叫法很别扭，也不科学：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>);</span><br></pre></td></tr></tbody></table></figure><p>为什么会出现这种蹩脚的叫法了？因为在 ES6 之前，JavaScript 中没有完全引入<code>Class</code>类的概念，其最多只能算是一个伪的面向对象语言，估计也是为了降低学习理解的难度，所以统称为对象吧。</p><p>既然在 ES6 中明确引入了 Class 概念，我们在学习的时候就要明确区分“类”和“对象”的概念了。</p><h2 id="3-2-万物皆对象"><a href="#3-2-万物皆对象" class="headerlink" title="3.2 万物皆对象"></a>3.2 万物皆对象</h2><p>在 JavaScript 中万物皆对象。学过其他面向对象编程语言的同学知道，对象是类的实例，每个类都可以有构造函数、析构函数、属性和方法。</p><p>在 JavaScript 中，每个对象都有构造函数、属性、方法，但没有析构函数，我们可以通过下面的代码来验证“万物皆对象”：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"John"</span>.<span class="property">constructor</span>); <span class="comment">// [Function: String]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">3.14</span>).<span class="property">constructor</span>); <span class="comment">// [Function: Number]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">false</span>.<span class="property">constructor</span>); <span class="comment">// [Function: Boolean]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>({ <span class="attr">name</span>: <span class="string">"John"</span>, <span class="attr">age</span>: <span class="number">34</span> }.<span class="property">constructor</span>); <span class="comment">// [Function: Object]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-1-隐式声明对象"><a href="#3-2-1-隐式声明对象" class="headerlink" title="3.2.1 隐式声明对象"></a>3.2.1 隐式声明对象</h3><p>JavaScript 访问属性和方法的方式和其他面向对象语言类似：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg1 = <span class="string">"Hello World!"</span>; <span class="comment">// msg1为对象，String类的实例</span></span><br><span class="line"><span class="keyword">let</span> x = msg1.<span class="property">length</span>; <span class="comment">// 访问length属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> msg2 = <span class="string">"Hello world!"</span>; <span class="comment">// // msg2为对象，String类的实例</span></span><br><span class="line"><span class="keyword">let</span> y = msg2.<span class="title function_">toUpperCase</span>(); <span class="comment">// 访问toUpperCase方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// HELLO WORLD!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = { <span class="attr">name</span>: <span class="string">"BMW"</span>, <span class="attr">price</span>: <span class="number">123000</span> }; <span class="comment">// car也为对象，{name: "BMW", price: 123000}类的实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car.<span class="property">name</span>); <span class="comment">// BMW</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car.<span class="property">price</span>); <span class="comment">// 123000</span></span><br></pre></td></tr></tbody></table></figure><p>大家可以看到上面的代码中都没有使用<code>new</code>来声明对象，但这些对象确确实实存在了，不然我们也无法访问其“属性”和“方法”，我们可以姑且认为这是 JavaScript 的语法糖吧，或者叫“隐式声明对象”吧。</p><h3 id="3-2-2-显式声明对象"><a href="#3-2-2-显式声明对象" class="headerlink" title="3.2.2 显式声明对象"></a>3.2.2 显式声明对象</h3><p>前面介绍的 8 种基本数据类型中除了<code>null</code>和<code>undefined</code>之外，都可以使用 new 来显示的声明对象：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1); <span class="comment">// [Number: 123]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + a1); <span class="comment">// 124</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> <span class="title class_">Function</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2); <span class="comment">// [Function: anonymous]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a3 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"xyz"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a3); <span class="comment">// [String: 'xyz']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a4 = <span class="keyword">new</span> <span class="title function_">null</span>(); <span class="comment">// TypeError: null is not a constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a5 = <span class="keyword">new</span> <span class="title function_">undefined</span>(); <span class="comment">// TypeError: null is not a constructor</span></span><br></pre></td></tr></tbody></table></figure><h2 id="3-3-使用-Class-定义类"><a href="#3-3-使用-Class-定义类" class="headerlink" title="3.3 使用 Class 定义类"></a>3.3 使用 Class 定义类</h2><p>在 ES6 中可以使用 Class 关键字定义类，且每个类都有默认的 name 属性。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="comment">// constructor方法名称不能修改</span></span><br><span class="line">  <span class="comment">// 通过new命令生成对象实例时，自动调用该方法。</span></span><br><span class="line">  <span class="comment">// 一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">h, w</span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = h;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = w;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Getter</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">area</span>() {</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">calcArea</span>();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Settter</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">setWidth</span>(<span class="params">w</span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = w;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="title function_">calcArea</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">height</span> * <span class="variable language_">this</span>.<span class="property">width</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">printInfo</span>(<span class="params">w, h</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"width:"</span> + w + <span class="string">", height:"</span> + h);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：这个name属性是通过类本身来访问的，而不是类的实例来访问的，是不是有点乱了。。。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Rectangle</span>.<span class="property">name</span>); <span class="comment">// Rectangle</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rect = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rect.<span class="property">area</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="comment">//rect.printInfo(); // TypeError: rect.printInfo is not a function</span></span><br><span class="line"><span class="title class_">Rectangle</span>.<span class="title function_">printInfo</span>(<span class="number">5</span>, <span class="number">6</span>); <span class="comment">// width:5, height:6</span></span><br></pre></td></tr></tbody></table></figure><p><strong>Class 的成员都是公共的，外部都可以访问，目前没有从语法层面规定如何定义一个私有的成员</strong></p><h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><p>一个类表达式是定义一个类的另一种方式。类表达式可以是具名的或匿名的。</p><p>一个具名类表达式的名称是类内的一个局部属性，它可以通过类的 name 属性来获取。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名类</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Rectangle1</span> = <span class="keyword">class</span> {</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">height, width</span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Rectangle1</span>.<span class="property">name</span>); <span class="comment">// Rectangle1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名类</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">RectangleX</span> = <span class="keyword">class</span> <span class="title class_">Rectangle2</span> {</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">height, width</span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RectangleX</span>.<span class="property">name</span>); <span class="comment">// Rectangle2</span></span><br></pre></td></tr></tbody></table></figure><h1 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h1><h2 id="4-1-函数参数是默认声明的变量"><a href="#4-1-函数参数是默认声明的变量" class="headerlink" title="4.1 函数参数是默认声明的变量"></a>4.1 函数参数是默认声明的变量</h2><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo1</span>(<span class="params">x</span>) {</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">0</span>; <span class="comment">// SyntaxError: Identifier 'x' has already been declared</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-2-函数参数可以有默认值"><a href="#4-2-函数参数可以有默认值" class="headerlink" title="4.2 函数参数可以有默认值"></a>4.2 函数参数可以有默认值</h2><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo2</span>(<span class="params">x, y = <span class="number">1</span></span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y);</span><br><span class="line">}</span><br><span class="line"><span class="title function_">foo2</span>(<span class="number">1</span>); <span class="comment">//  2</span></span><br></pre></td></tr></tbody></table></figure><p>与 C++不同，JavaSript 没有要求拥有默认值的参数必须放在参数列表的尾部，所以可以这样写：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo2</span>(<span class="params">x = <span class="number">1</span>, y</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但仔细想一想，这样写并没有什么实际意义。</p><p>另外值得注意的是，函数参数的默认值是每次函数调用时都会动态计算的：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 101</span></span><br></pre></td></tr></tbody></table></figure><h2 id="4-3-箭头函数"><a href="#4-3-箭头函数" class="headerlink" title="4.3 箭头函数"></a>4.3 箭头函数</h2><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, y</span>) {</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">(x, y) =&gt; {</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>如果函数只有一个参数：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) {</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">(x) =&gt; {</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 括号可以省略，等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function">(<span class="params">x</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>如果函数没有返回值大括号可以省略：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"hi"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大括号可以省略，等同于</span></span><br><span class="line"></span><br><span class="line">() =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"hi"</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="4-4-函数的-name，length-属性"><a href="#4-4-函数的-name，length-属性" class="headerlink" title="4.4 函数的 name，length 属性"></a>4.4 函数的 name，length 属性</h2><p><code>name</code>可以返回函数名；<br><code>length</code>可以返回没有指定默认值的参数个数；</p><h1 id="五、数据结构"><a href="#五、数据结构" class="headerlink" title="五、数据结构"></a>五、数据结构</h1><h2 id="5-1-Object"><a href="#5-1-Object" class="headerlink" title="5.1 Object"></a>5.1 Object</h2><p>我们可以向 Object 对象添加任何属性，所以 Object 也是一个容器或集合：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// [String: 'hello']</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">"jeff"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// jeff</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">print</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"I'm object"</span>);</span><br><span class="line">};</span><br><span class="line">obj.<span class="title function_">print</span>(); <span class="comment">// I'm object</span></span><br></pre></td></tr></tbody></table></figure><h2 id="5-2-数组"><a href="#5-2-数组" class="headerlink" title="5.2 数组"></a>5.2 数组</h2><p>JavaScript 中使用 Array 类创建数组对象：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Array类创建数组</span></span><br><span class="line"><span class="keyword">let</span> cars1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">"Saab"</span>, <span class="string">"Volvo"</span>, <span class="string">"BMW"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Array类创建数组</span></span><br><span class="line"><span class="keyword">let</span> cars2 = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">cars2[<span class="number">0</span>] = <span class="string">"Saab"</span>; <span class="comment">// 支持[]方式访问和赋值，下标从0开始</span></span><br><span class="line">cars2[<span class="number">1</span>] = <span class="string">"Volvo"</span>;</span><br><span class="line">cars2[<span class="number">2</span>] = <span class="string">"BMW"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写方式</span></span><br><span class="line"><span class="keyword">let</span> cars3 = [<span class="string">"Saab"</span>, <span class="string">"Volvo"</span>, <span class="string">"BMW"</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cars3.<span class="property">length</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中的元素可以为不同的类型</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="string">"x"</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">1</span>]); <span class="comment">// x</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">5</span>]); <span class="comment">// undefined，访问数组中不存在的元素会返回undefined，不会报错</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">testProp</span> = <span class="string">"xyz"</span>; <span class="comment">// 可以向Array对象添加任意属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">testProp</span>); <span class="comment">// xyz</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">print</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"I'm a"</span>);</span><br><span class="line">};</span><br><span class="line">a.<span class="title function_">print</span>(); <span class="comment">// I'm a</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-1-Array-类完整的属性"><a href="#5-2-1-Array-类完整的属性" class="headerlink" title="5.2.1 Array 类完整的属性"></a>5.2.1 Array 类完整的属性</h3><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>length</td><td><strong>设置</strong>或获取数组元素的个数</td></tr><tr><td>prototype</td><td>允许你向数组对象添加属性或方法</td></tr></tbody></table><h3 id="5-2-2-Array-类完整的方法"><a href="#5-2-2-Array-类完整的方法" class="headerlink" title="5.2.2 Array 类完整的方法"></a>5.2.2 Array 类完整的方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>concat()</td><td>连接两个或更多的数组，并返回结果</td></tr><tr><td>copyWithin()</td><td>从数组的指定位置拷贝元素到数组的另一个指定位置中</td></tr><tr><td>entries()</td><td>返回数组的可迭代对象</td></tr><tr><td>every()</td><td>检测数值元素的每个元素是否都符合条件</td></tr><tr><td>fill()</td><td>使用一个固定值来填充数组</td></tr><tr><td>filter()</td><td>检测数值元素，并返回符合条件所有元素的数组</td></tr><tr><td>find()</td><td>返回符合传入测试（函数）条件的数组元素</td></tr><tr><td>findIndex()</td><td>返回符合传入测试（函数）条件的数组元素索引</td></tr><tr><td>forEach()</td><td>数组每个元素都执行一次回调函数</td></tr><tr><td>from()</td><td>通过给定的对象中创建一个数组</td></tr><tr><td>includes()</td><td>判断一个数组是否包含一个指定的值</td></tr><tr><td>indexOf()</td><td>搜索数组中的元素，并返回它所在的位置</td></tr><tr><td>isArray()</td><td>判断对象是否为数组</td></tr><tr><td>join()</td><td>把数组的所有元素放入一个字符串</td></tr><tr><td>keys()</td><td>返回数组的可迭代对象，包含原始数组的键(key)</td></tr><tr><td>lastIndexOf()</td><td>搜索数组中的元素，并返回它最后出现的位置</td></tr><tr><td>map()</td><td>通过指定函数处理数组的每个元素，并返回处理后的数组</td></tr><tr><td>pop()</td><td>删除数组的最后一个元素并返回删除的元素</td></tr><tr><td>push()</td><td>向数组的末尾添加一个或更多元素，并返回新的长度</td></tr><tr><td>reduce()</td><td>将数组元素计算为一个值（从左到右）</td></tr><tr><td>reduceRight()</td><td>将数组元素计算为一个值（从右到左）</td></tr><tr><td>reverse()</td><td>反转数组的元素顺序</td></tr><tr><td>shift()</td><td>删除并返回数组的第一个元素</td></tr><tr><td>slice()</td><td>选取数组的一部分，并返回一个新数组</td></tr><tr><td>some()</td><td>检测数组元素中是否有元素符合指定条件</td></tr><tr><td>sort()</td><td>对数组的元素进行排序</td></tr><tr><td>splice()</td><td>从数组中添加或删除元素</td></tr><tr><td>toString()</td><td>把数组转换为字符串，并返回结果</td></tr><tr><td>unshift()</td><td>向数组的开头添加一个或更多元素，并返回新的长度</td></tr><tr><td>valueOf()</td><td>返回数组对象的原始值</td></tr></tbody></table><h3 id="5-2-3-数组的复制"><a href="#5-2-3-数组的复制" class="headerlink" title="5.2.3 数组的复制"></a>5.2.3 数组的复制</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = a1;</span><br><span class="line"></span><br><span class="line">a2[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1[<span class="number">1</span>]); <span class="comment">// 4</span></span><br></pre></td></tr></tbody></table></figure><p>从上面的例子中，我们发现改变数组<code>a2[1]</code>的值时，数组<code>a1[1]</code>的值也随着改变了，这说明 a1 和 a2 指向的是同一块内存区域，这个在 C/C++中就是指针的概念，<code>let a2 = a1;</code> 做的是<code>浅拷贝</code>操作。</p><p>如果需要做<code>深拷贝</code>，也就是将数组 a1 的所有元素克隆一份给 a2，可以通过下面的两种方式：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = a1.<span class="title function_">concat</span>();</span><br><span class="line"></span><br><span class="line">a2[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1[<span class="number">1</span>]); <span class="comment">// 2</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = [...a1]; <span class="comment">// 也可以写成 let [...a2] = a1;</span></span><br><span class="line"></span><br><span class="line">a2[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1[<span class="number">1</span>]); <span class="comment">// 2</span></span><br></pre></td></tr></tbody></table></figure><h2 id="5-3-Map"><a href="#5-3-Map" class="headerlink" title="5.3 Map"></a>5.3 Map</h2><p>Map 对象用来存储键值对(key-value)，并且能够记住键的原始<strong>插入顺序</strong>。任何对象都可以作为键或值。<br>在 Map 中 Key 是唯一的。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keyObj = {};</span><br><span class="line"><span class="keyword">let</span> keyFunc = <span class="keyword">function</span> (<span class="params"></span>) {};</span><br><span class="line"><span class="keyword">let</span> keyString = <span class="string">"a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加键</span></span><br><span class="line">myMap.<span class="title function_">set</span>(keyString, <span class="string">"和键'a string'关联的值"</span>);</span><br><span class="line">myMap.<span class="title function_">set</span>(keyObj, <span class="string">"和键keyObj关联的值"</span>);</span><br><span class="line">myMap.<span class="title function_">set</span>(keyFunc, <span class="string">"和键keyFunc关联的值"</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap.<span class="property">size</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap.<span class="title function_">get</span>(keyString)); <span class="comment">// 和键'a string'关联的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap.<span class="title function_">get</span>(<span class="string">"a string"</span>)); <span class="comment">// 和键'a string'关联的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap.<span class="title function_">get</span>(keyObj)); <span class="comment">// 和键keyObj关联的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap.<span class="title function_">get</span>(keyFunc)); <span class="comment">// 和键keyFunc关联的值</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap.<span class="title function_">get</span>({})); <span class="comment">// undefined, 因为keyObj !== {}</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap.<span class="title function_">get</span>(<span class="keyword">function</span> (<span class="params"></span>) {})); <span class="comment">// undefined, 因为keyFunc !== function () {}</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap.<span class="property">size</span>); <span class="comment">// 3，返回有多少个键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和Array一样，可以添加任意属性和方法</span></span><br><span class="line">myMap.<span class="property">test</span> = <span class="string">"a"</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap.<span class="property">test</span>);</span><br><span class="line"></span><br><span class="line">myMap.<span class="property">print</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"I'm map"</span>);</span><br><span class="line">};</span><br><span class="line">myMap.<span class="title function_">print</span>(); <span class="comment">// I'm map</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-3-1-Map-与-Array-相互转换"><a href="#5-3-1-Map-与-Array-相互转换" class="headerlink" title="5.3.1 Map 与 Array 相互转换"></a>5.3.1 Map 与 Array 相互转换</h3><p><strong>Array =&gt; Map</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">"one"</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">"two"</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map); <span class="comment">// Map { 1 =&gt; 'one', 2 =&gt; 'two' }</span></span><br></pre></td></tr></tbody></table></figure><p><strong>Map =&gt; Array</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">"tow"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(map);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// [ [ 1, 'one' ], [ 2, 'two' ] ]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-3-2-Map-的复制"><a href="#5-3-2-Map-的复制" class="headerlink" title="5.3.2 Map 的复制"></a>5.3.2 Map 的复制</h3><p>Map 在直接赋值的时候会遇到和 Array 同样的“浅拷贝”的问题，如：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map1.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map1.<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">"tow"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map2 = map1;</span><br><span class="line"></span><br><span class="line">map2.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">"three"</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map1.<span class="title function_">get</span>(<span class="number">1</span>)); <span class="comment">// three，修改map2会导致map1的值也被修改了</span></span><br></pre></td></tr></tbody></table></figure><p>可以通过下面的方式完成 Map 的深拷贝：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map1.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map1.<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">"tow"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>(map1);</span><br><span class="line"></span><br><span class="line">map2.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">"three"</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map1.<span class="title function_">get</span>(<span class="number">1</span>)); <span class="comment">// one</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map2.<span class="title function_">get</span>(<span class="number">1</span>)); <span class="comment">// three</span></span><br></pre></td></tr></tbody></table></figure><h2 id="5-4-Set"><a href="#5-4-Set" class="headerlink" title="5.4 Set"></a>5.4 Set</h2><p>Map 是键值对的集合，而 Set 则只是键（key）的集合。</p><p>Set 中的每个元素都是唯一的。</p><p>任何对象都可以作为 Set 的元素。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"str"</span>];</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(keys);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动去重了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// Set { 1, 2, 3, 'str' }</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增使用Add</span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">9</span>);</span><br><span class="line">s.<span class="title function_">add</span>(<span class="keyword">function</span> (<span class="params"></span>) {});</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// Set { 1, 2, 3, 'str', 9, [Function] }</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除使用delete</span></span><br><span class="line">s.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// Set { 2, 3, 'str', 9, [Function] }</span></span><br></pre></td></tr></tbody></table></figure><h2 id="5-5-迭代器"><a href="#5-5-迭代器" class="headerlink" title="5.5 迭代器"></a>5.5 迭代器</h2><p>前面介绍 Object、Array、Map、Set 这些容器的时候，都避开了一个话题：遍历。本节主要介绍如何遍历 JavaScript 中的容器或集合。</p><p>迭代器（Iterator）就是一个接口，为各种不同的数据结构提供统一的遍历访问机制。任何数据结构只要实现 Iterator 接口，就可以完成遍历操作。</p><p>在学习如何自定义迭代器之前，我们先学习一下如何遍历 JavaScript 常用的数据集合：</p><h3 id="5-5-1-遍历字符串"><a href="#5-5-1-遍历字符串" class="headerlink" title="5.5.1 遍历字符串"></a>5.5.1 遍历字符串</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> str) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">h</span></span><br><span class="line"><span class="comment">e</span></span><br><span class="line"><span class="comment">l</span></span><br><span class="line"><span class="comment">l</span></span><br><span class="line"><span class="comment">o</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-5-2-遍历数组"><a href="#5-5-2-遍历数组" class="headerlink" title="5.5.2 遍历数组"></a>5.5.2 遍历数组</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="string">"str"</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> arr) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">str</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-5-3-遍历-Map"><a href="#5-5-3-遍历-Map" class="headerlink" title="5.5.3 遍历 Map"></a>5.5.3 遍历 Map</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">"one"</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">"two"</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="keyword">function</span> (<span class="params"></span>) {}],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> map) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(k + <span class="string">":"</span> + v);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1:one</span></span><br><span class="line"><span class="comment">2:two</span></span><br><span class="line"><span class="comment">3:function () { }</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h1 id="六、解构赋值"><a href="#六、解构赋值" class="headerlink" title="六、解构赋值"></a>六、解构赋值</h1><p>解构(Destructuring)赋值分为“数组的解构赋值”和“对象的解构赋值”。</p><h2 id="6-1-数组的解构赋值"><a href="#6-1-数组的解构赋值" class="headerlink" title="6.1 数组的解构赋值"></a>6.1 数组的解构赋值</h2><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];   <span class="comment">// 根据位置依次取值</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="comment">// foo = 1</span></span><br><span class="line"><span class="comment">// bar = 2</span></span><br><span class="line"><span class="comment">// baz = 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br><span class="line"><span class="comment">// third = "baz"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// head = 1</span></span><br><span class="line"><span class="comment">// tail = [2,3,4]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">"a"</span>];</span><br><span class="line"><span class="comment">// x = "a"</span></span><br><span class="line"><span class="comment">// y = undefined</span></span><br><span class="line"><span class="comment">// z = []</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [foo] = [];        <span class="comment">// foo = undefined</span></span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];  <span class="comment">// foo = undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [bar, foo = <span class="literal">true</span>] = [<span class="number">1</span>]; <span class="comment">// 可以赋默认值</span></span><br><span class="line"><span class="comment">// bar = 1</span></span><br><span class="line"><span class="comment">// foo = true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// x = 1</span></span><br><span class="line"><span class="comment">// y = 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// d = 4</span></span><br></pre></td></tr></tbody></table></figure><h2 id="6-2-对象的解构赋值"><a href="#6-2-对象的解构赋值" class="headerlink" title="6.2 对象的解构赋值"></a>6.2 对象的解构赋值</h2><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> { foo, bar } = { <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> }; <span class="comment">// 和顺序没关系，根据属性名来取值</span></span><br><span class="line"><span class="comment">// foo = "aaa"</span></span><br><span class="line"><span class="comment">// bar = "bbb"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> { foo } = { <span class="attr">bar</span>: <span class="string">"baz"</span> };</span><br><span class="line"><span class="comment">// foo = undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量</span></span><br><span class="line"><span class="comment">// 如：console对象有log方法，我们可以这样使用：</span></span><br><span class="line"><span class="keyword">const</span> { log } = <span class="variable language_">console</span>;</span><br><span class="line"><span class="title function_">log</span>(<span class="string">"hello"</span>); <span class="comment">// hello</span></span><br></pre></td></tr></tbody></table></figure><h1 id="七、promise、async、await"><a href="#七、promise、async、await" class="headerlink" title="七、promise、async、await"></a>七、promise、async、await</h1><p>promise、async、await 这三个关键字都和异步编程有关。</p><h2 id="7-1-Promise"><a href="#7-1-Promise" class="headerlink" title="7.1 Promise"></a>7.1 Promise</h2><p>Promise 翻译成中文就是“承诺”的意思，声明一个 Promise 就是立下了一个承诺，无论怎么样，都会给被承诺人一个结果，而且这个结果是板上钉钉的，不会再变。</p><p>Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。</p><p>声明 Promise 对象时需要传入一个函数对象作为参数，这个函数对象的 2 个参数也是函数对象（<code>resolve</code>, <code>reject</code>），<code>resolve</code>和<code>reject</code>不需要开发者定义，Javascript 引擎会自动生成这 2 个函数。</p><p>当 Promise 对象生成后会立即变成<code>pending</code>状态，调用<code>resolve</code>函数会将 Promise 对象标记为<code>fulfilled</code>状态，而调用<code>reject</code>函数则会将当前 Promise 对象标记<code>rejected</code>状态。</p><p><code>resolve</code>和<code>rejected</code>函数，我们只能调用它们中的一个，不能即调用<code>resolve</code>又调用<code>rejected</code>。如果我们先调用了<code>resolve</code>，此时 Promise 状态会标记为<code>fulfilled</code>，然后又调用了<code>rejected</code>函数，此时 Promise 状态并不会再改变，仍然使<code>fulfilled</code>状态，因为承诺的结果是板上钉钉的，不会再变。建议将<code>resolve</code>和<code>reject</code>作为最后一行代码调用，简单起见，可以在这 2 个函数前面加上<code>return</code>, 即<code>return resolve();</code>或<code>return reject();</code></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise的参数为一个函数对象，函数有2个参数resolve, reject</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 做一些耗时的操作，比如网络请求</span></span><br><span class="line">  <span class="comment">// 这里我们使用一个延时器来模拟耗时的网络请求</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="comment">// 延时1000ms之后成功</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">"ok"</span>);</span><br><span class="line">  }, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 成功则调用 resolve();</span></span><br><span class="line">  <span class="comment">// 失败则调用 reject();</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>那么，我想在这个异步操作完成之后，再根据结果（是成功了，还是失败了）来继续做下一件事情，那我们该怎么做了？<br>Promise 对象提供了<code>then</code>方法，该方法接受 2 个函数对象作为参数：<br>第一个回调函数是 Promise 对象的状态变为<code>resolved</code>时调用;<br>第二个回调函数是 Promise 对象的状态变为<code>rejected</code>时调用。<br>其中，第二个函数是可选的，不一定要提供。每个回调函数都可以接受一个参数，这个参数就是上一步调用 resolve 或 reject 时传入的。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面的耗时操作完成之后，我们可能还需要根据结果来继续做一些事情</span></span><br><span class="line"><span class="comment">// 此时就可以使用then，then函数有2个参数，分别为2个函数对象。</span></span><br><span class="line"><span class="comment">// 上一步操作中，如果调用resolve(data)，则then函数第一个函数对象参数会被调用；</span></span><br><span class="line"><span class="comment">// 如果调用reject(data)，则then函数第二个函数对象参数会被调用</span></span><br><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"resolve1: "</span> + data);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">  },</span><br><span class="line">  <span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"reject1: "</span> + data);</span><br><span class="line">  }</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，我在第一个参数中直接通过 return 返回了”hello”字符串，那这个返回值的意义在哪里了？还有其他人可以使用到这个返回值吗？<br>是的，还可以继续使用。因为<code>then</code>的返回值是一个 Promise 对象，虽然我只是使用的<code>return "hello";</code>，并没有<code>new Promise</code>，但 JavaScript 引擎会自动包装成一个 Promise 对象，等同于：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"resolve1: "</span> + data);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="string">"hello"</span>);</span><br><span class="line">    });</span><br><span class="line">  },</span><br><span class="line">  <span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"reject1: "</span> + data);</span><br><span class="line">  }</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>到这儿了，我们知道了<code>then</code>的返回的是一个<code>Promise</code>对象。既然<code>then</code>返回的是<code>Promise</code>对象，那么<code>Promise</code>就可以继续<code>then</code>呀，然后一直<code>then</code>下去….这样我们就可以将一系列异步的操作串联起来了：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// resolve(); 或 reject();</span></span><br><span class="line">})</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  })</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  })</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure><p>但多个异步操作串联执行，还有一点需要注意，我们看下面的例子：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="comment">// 延时1000ms</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">"ok1"</span>);</span><br><span class="line">  }, <span class="number">1000</span>);</span><br><span class="line">})</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"resolve1: "</span> + data);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="comment">// 延时1000ms</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">"ok2"</span>;</span><br><span class="line">    }, <span class="number">1000</span>);</span><br><span class="line">  })</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"resolve2: "</span> + data);</span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure><p>我们期望的输出是：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resolve1</span>: ok1;</span><br><span class="line"><span class="attr">resolve2</span>: ok2;</span><br></pre></td></tr></tbody></table></figure><p>但实际的输出却是：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resolve1</span>: ok1;</span><br><span class="line"><span class="attr">resolve2</span>: <span class="literal">undefined</span>;</span><br></pre></td></tr></tbody></table></figure><p>问题出在第二个 setTimeout 模拟的耗时操作，我们以为程序会等第二个 setTimeout 执行完了再执行第二个 then，但事实上 setTimeout 也是一个异步操作，虽然其延时了一秒执行其回调函数，但 setTimeout 这条语句却马上执行完成了，导致第一个 then 没有任何返回，针对这种情况，我们需要将代码改成下面的：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="comment">// 延时1000ms</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">"ok1"</span>);</span><br><span class="line">  }, <span class="number">1000</span>);</span><br><span class="line">})</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"resolve1: "</span> + data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="comment">// 延时1000ms</span></span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">"ok2"</span>);</span><br><span class="line">      }, <span class="number">1000</span>);</span><br><span class="line">    });</span><br><span class="line">  })</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"resolve2: "</span> + data);</span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure><h2 id="7-2-Promise-异常捕获"><a href="#7-2-Promise-异常捕获" class="headerlink" title="7.2 Promise 异常捕获"></a>7.2 Promise 异常捕获</h2><p>Promise 对象还提供了<code>catch</code>方法，用来捕获异常。在介绍<code>catch</code>前，我们先看看下面的代码：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"an error"</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">"ok"</span>);</span><br><span class="line">}).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"resolve: "</span> + data);</span><br><span class="line">  },</span><br><span class="line">  <span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"reject: "</span> + data);</span><br><span class="line">  }</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// reject: Error: an error</span></span><br></pre></td></tr></tbody></table></figure><p>我们在 Promise 中人为抛出了一个异常，但是程序却还是没有中止，而是运行到了 reject 过程中去了。</p><p>这是因为 Promise 默认会捕获其操作过程中的异常，如果有异常发生，其状态就会自动变成<code>rejected</code>，还记得前面说过 Promise 状态一旦确定就不会再改变了吧，所以即便后面的<code>resolve("ok");</code>执行了，也不会改变 promise 状态（事实上 throw 语句后的代码并没有机会执行）。</p><p>那么，假如我们没有写 reject 回调函数会怎么样了？看看下面的代码：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"an error"</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">"ok"</span>);</span><br><span class="line">}).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"resolve: "</span> + data);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>上面的代码中由于没有指定异常处理函数，所以程序抛出了异常信息，中止执行了。</p><p>另外，<strong>Promise 的异常是会一直向下传递的</strong>，直到最后有人处理，如果始终没人处理，程序就会抛出异常信息，然后中止：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"an error"</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">"ok"</span>);</span><br><span class="line">})</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"resolve1: "</span> + data);</span><br><span class="line">  })</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"resolve2: "</span> + data);</span><br><span class="line">    },</span><br><span class="line">    <span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"reject2: "</span> + data);</span><br><span class="line">    }</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// reject: Error: an error</span></span><br></pre></td></tr></tbody></table></figure><p>上面的代码中，第一个 then 没有处理异常，异常向下传递给第二个 then, 第二个 then 处理了该异常，程序继续运行。</p><p>现在理解<code>Promise.catch()</code>方法就容易多了。<code>catch()</code>方法其实就是<code>.then(null, rejectiion)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><p>我们一般总是建议，Promise 对象后面要跟 catch()方法，这样可以处理 Promise 内部发生的错误。catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then()方法。</p><h2 id="7-3-async-await"><a href="#7-3-async-await" class="headerlink" title="7.3 async, await"></a>7.3 async, await</h2><p>async 是<code>ES7</code>才有的与异步操作有关的关键字，需要和<code>Promise</code>配合使用，<code>async</code>函数返回一个 <code>Promise</code>对象，可以使用<code>then</code>方法添加回调函数：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">helloAsync</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"helloAsync"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">helloAsync</span>());</span><br><span class="line"></span><br><span class="line"><span class="title function_">helloAsync</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Promise { 'helloAsync' }</span></span><br><span class="line"><span class="comment">// helloAsync</span></span><br></pre></td></tr></tbody></table></figure><p><code>await</code>关键字<code>只</code>能用在被<code>async</code>标记的函数体内，<code>async</code>函数执行时，如果遇到<code>await</code>就会先暂停执行，等到触发的异步操作完成后，恢复<code>async</code>函数的执行并返回解析值。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testAwait</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"testAwait"</span>);</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    }, <span class="number">1000</span>);</span><br><span class="line">  });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">helloAsync</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">testAwait</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"helloAsync"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="title function_">helloAsync</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// testAwait</span></span><br><span class="line"><span class="comment">// helloAsync</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑫ Web开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>QSS的几种图片设置方法</title>
      <link href="/post/830332637.html"/>
      <url>/post/830332637.html</url>
      
        <content type="html"><![CDATA[<p>大家在使用 QSS 进行图片设置时，也许被<code>image</code>, <code>border-image</code>, <code>background-image</code>这几个属性的差异困扰过。本文就来讲解一下这个几个属性的异同点。</p><span id="more"></span><h1 id="一、background-image"><a href="#一、background-image" class="headerlink" title="一、background-image"></a>一、background-image</h1><p><code>background-image</code>按图片实际尺寸显示图片，超过控件显示区域的部分会被裁剪掉。</p><p>虽能显示 SVG，但无法对 SVG 进行无损缩放；</p><p>关于<code>background-image</code>的几个附属属性的作用，可以一句话概括为：<br>从<code>background-origin</code>区域的<code>background-position</code>位置开始绘制图像，并以<code>background-repeat</code>方式进行重复；最后将图像<code>background-clip</code>区域以外的范围裁剪掉（即不显示）。</p><h1 id="二、image"><a href="#二、image" class="headerlink" title="二、image"></a>二、image</h1><p><code>image</code>会将图片按<strong>图片原长宽比</strong>进行缩放，并保证填充满控件 content 区域。</p><p><code>image</code>支持 SVG 矢量图显示和无损缩放。</p><p>image 可以使用<code>image-position</code>来指定图片开始显示的位置（参考上面<code>background-position</code>）。</p><h1 id="三、border-image"><a href="#三、border-image" class="headerlink" title="三、border-image"></a>三、border-image</h1><p>按<strong>控件 border 区域的长宽比</strong>来缩放图片，保证填充满控件 border 区域，支持 SVG 矢量图显示和无损缩放;</p><h1 id="四、绘制顺序"><a href="#四、绘制顺序" class="headerlink" title="四、绘制顺序"></a>四、绘制顺序</h1><p>如果在一个控件中同时指定<code>background-image</code>，<code>border-image</code>，<code>image</code>这三个属性，会按照如下的顺序进行绘制：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先绘制 background-image</span><br><span class="line">然后 border-image</span><br><span class="line">最后 image</span><br></pre></td></tr></tbody></table></figure><h1 id="五、示例"><a href="#五、示例" class="headerlink" title="五、示例"></a>五、示例</h1><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-id">#pushButton4</span> {</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">20px</span> solid <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>,<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/QssUsage/Image/头像.png</span>); <span class="comment">/*下图中的圆形头像*/</span></span><br><span class="line">  <span class="attribute">background-origin</span>: margin;</span><br><span class="line">  <span class="attribute">background-position</span>:top left;</span><br><span class="line">  <span class="attribute">background-repeat</span>:repeat-x;</span><br><span class="line">  <span class="attribute">background-clip</span>: margin;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://blog-static.jiangxueqiao.com/blog/img/qss-sztp-1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QSS基本使用方法</title>
      <link href="/post/749849405.html"/>
      <url>/post/749849405.html</url>
      
        <content type="html"><![CDATA[<p>Qt QSS 选择器和 CSS2、CSS3 的选择器类似，建议先学习或者复习<a href="https://www.w3school.com.cn/cssref/css_selectors.asp">CSS 选择器的语法</a>。QSS 来源与 CSS ，但有也稍许不同，而且支持的语法也没 CSS 那么多。</p><span id="more"></span><h1 id="一、选择器类型"><a href="#一、选择器类型" class="headerlink" title="一、选择器类型"></a>一、选择器类型</h1><h2 id="1-1-类选择器"><a href="#1-1-类选择器" class="headerlink" title="1.1 类选择器"></a>1.1 类选择器</h2><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匹配QPushButton的实例及其子类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QPushButton {</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匹配QPushButton的实例，但不包含子类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-class">.QPushButton</span> {</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-2-选择器分组"><a href="#1-2-选择器分组" class="headerlink" title="1.2 选择器分组"></a>1.2 选择器分组</h2><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*同时匹配QPushButton、QLineEdit的实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QPushButton,</span><br><span class="line">QLineEdit {</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-3-ID-选择器"><a href="#1-3-ID-选择器" class="headerlink" title="1.3 ID 选择器"></a>1.3 ID 选择器</h2><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匹配所有objectName为btnOK的实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">*<span class="selector-id">#btnOK</span> {</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">和*#btnOK一样，匹配所有objectName为btnOK的实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-id">#btnOK</span> {</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匹配所有objectName为btnOK的QPushButton实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QPushButton<span class="selector-id">#btnOK</span> {</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-4-属性选择器"><a href="#1-4-属性选择器" class="headerlink" title="1.4 属性选择器"></a>1.4 属性选择器</h2><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匹配包含flat属性的所有实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">*<span class="selector-attr">[flat]</span> {</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匹配包含flat属性的所有QPushButton的实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QPushButton<span class="selector-attr">[flat]</span> {</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匹配flat属性为true的所有QPushButton的实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QPushButton<span class="selector-attr">[flat=<span class="string">"true"</span>]</span> {</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匹配falt属性为true且default属性为false的所有QPushButton的实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QPushButton<span class="selector-attr">[flat=<span class="string">"true"</span>]</span><span class="selector-attr">[default=<span class="string">"false"</span>]</span> {</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-5-后代选择器"><a href="#1-5-后代选择器" class="headerlink" title="1.5 后代选择器"></a>1.5 后代选择器</h2><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匹配属于QDialog后代（孩子，孙子等）的QPushButton所有实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QDialog QPushButton {</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-6-子元素选择器"><a href="#1-6-子元素选择器" class="headerlink" title="1.6 子元素选择器"></a>1.6 子元素选择器</h2><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匹配属于QDialog直接子类的QPushButton所有实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QDialog &gt; QPushButton {</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-7-伪状态"><a href="#1-7-伪状态" class="headerlink" title="1.7 伪状态"></a>1.7 伪状态</h2><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匹配hover状态的所有QPushButton的实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QPushButton<span class="selector-pseudo">:hover</span> {</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匹配同时为hover和enabled状态的所有QPushButton的实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QPushButton<span class="selector-pseudo">:hover</span><span class="selector-pseudo">:enabled</span> {</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匹配不为hover状态的所有QPushButton的实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">qradiobutton: !hover {</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-8-子控件选择器"><a href="#1-8-子控件选择器" class="headerlink" title="1.8 子控件选择器"></a>1.8 子控件选择器</h2><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QRadioButton::indicator::unchecked:disabled {</span><br><span class="line">  image: <span class="built_in">url</span>(<span class="string">:/qss/radiobutton_unchecked_disable.png</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二、选择器优先级"><a href="#二、选择器优先级" class="headerlink" title="二、选择器优先级"></a>二、选择器优先级</h1><p>一句话归纳为：<strong>优先使用更具体的选择器。</strong></p><p>具体实例如下：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">QPushButton#okButton选择器比QPushButton更具体，所以选择QPushButton#okButton</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QPushButton<span class="selector-id">#okButton</span> {</span><br><span class="line">  <span class="attribute">color</span>: gray;</span><br><span class="line">}</span><br><span class="line">QPushButton {</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如下2个规则应用于QPushButton实例时：</span></span><br><span class="line"><span class="comment">因为QPushButton继承QAbstractButton，所以QPushButton比QAbstractButton更具体，选择QPushButton</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QPushButton {</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br><span class="line">QAbstractButton {</span><br><span class="line">  <span class="attribute">color</span>: gray;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">指定伪状态比不指定伪状态的选择器更具体，所以当鼠标悬停时选择QPushButton:hover，否则选择QPushButton</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QPushButton<span class="selector-pseudo">:hover</span> {</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">}</span><br><span class="line">QPushButton {</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如下2个规则应用于处于Enabled状态的QPushButton实例时：</span></span><br><span class="line"><span class="comment">鼠标悬停时，QPushButton:hover更能具体描述当前状态，所以选择QPushButton:hover</span></span><br><span class="line"><span class="comment">其他时候选择QPushButton:enabled</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QPushButton<span class="selector-pseudo">:enabled</span> {</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br><span class="line">QPushButton<span class="selector-pseudo">:hover</span> {</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如下2个规则应用于处于Enabled状态的QPushButton实例时：</span></span><br><span class="line"><span class="comment">鼠标悬停时，QPushButton:enabled:hover更能具体描述当前状态，所以选择QPushButton:enabled:hover</span></span><br><span class="line"><span class="comment">其他时候选择QPushButton:enabled</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QPushButton<span class="selector-pseudo">:enabled</span> {</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br><span class="line">QPushButton<span class="selector-pseudo">:hover</span> {</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">}</span><br><span class="line">QPushButton<span class="selector-pseudo">:enabled</span><span class="selector-pseudo">:hover</span> {</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="三、QSS-支持的类型、属性、伪状态、子控件"><a href="#三、QSS-支持的类型、属性、伪状态、子控件" class="headerlink" title="三、QSS 支持的类型、属性、伪状态、子控件"></a>三、QSS 支持的类型、属性、伪状态、子控件</h1><p>关于 QSS 支持哪些类型、每种类型支持哪些属性、伪状态和子控件，在 Qt 的官方的英文文档中有详细的介绍：<br><a href="https://doc.qt.io/qt-5/stylesheet-reference.html">《Qt Style Sheets Reference》</a></p><p>也可以在Qt Assistant中搜索”Qt Style Sheets Reference”打开帮助文档。</p><h2 id="3-1-伪状态列表"><a href="#3-1-伪状态列表" class="headerlink" title="3.1 伪状态列表"></a>3.1 伪状态列表</h2><p>为了方便查阅，这里列举出QSS目前支持的所有伪状态。</p><blockquote><p>伪状态都是以一个冒号<code>:</code>开头，如<code>:active</code>。</p></blockquote><table><thead><tr><th>伪状态</th><th>描述</th></tr></thead><tbody><tr><td>:active</td><td>此状态在Widget驻留在活动窗口时设置</td></tr><tr><td>:adjoins-item</td><td>此状态在QTreeView的::branch与一个item相邻时设置</td></tr><tr><td>:alternate</td><td>当QAbstractItemView::alternatingRowColors()设置为真时，在绘制QAbstractItemView的行时，为每个交替行设置此状态</td></tr><tr><td>:bottom</td><td>此item位于底部时设置。例如，QTabBar有位于底部的选项卡</td></tr><tr><td>:checked</td><td>此item被选中时设置。例如，QAbstractButton的checked状态</td></tr><tr><td>:closable</td><td>此item可以被关闭时设置。例如，QDockWidget的QDockWidget::DockWidgetClosable特性开启时</td></tr><tr><td>:closed</td><td>此item处于关闭状态时设置。例如，QTreeView中未展开的item</td></tr><tr><td>:default</td><td>此item的默认状态时设置。例如，一个default的QPushButton或QMenu中的一个默认动作</td></tr><tr><td>:disabled</td><td>此item被禁用时设置</td></tr><tr><td>:editable</td><td>如QComboBox是可编辑时设置</td></tr><tr><td>:edit-focus</td><td>此item具有编辑焦点(参考QStyle::State_HasEditFocus)时设置。此状态仅对Qt扩展应用程序可用</td></tr><tr><td>:enabled</td><td>此item已启用时设置</td></tr><tr><td>:exclusive</td><td>此item是属于某个独占组时设置。例如，独占QActionGroup中的菜单项</td></tr><tr><td>:first</td><td>此item是列表中的第一项时设置。例如，QTabBar中的第一个选项卡</td></tr><tr><td>:flat</td><td>此item是扁平时设置。例如，一个扁平的QPushButton</td></tr><tr><td>:floatable</td><td>此item可以浮动时设置。例如，QDockWidget的QDockWidget::DockWidgetFloatable的特性开启时</td></tr><tr><td>:focus</td><td>此item具有输入焦点时设置</td></tr><tr><td>:has-children</td><td>此item具有子对象时设置。例如，QTreeView中具有子项的项</td></tr><tr><td>:has-sibling</td><td>此item具有兄弟对象时设置。例如，QTreeView中与之相邻的项</td></tr><tr><td>:horizontal</td><td>此item处于水平方向时设置</td></tr><tr><td>:hover</td><td>鼠标悬浮在此item上时设置</td></tr><tr><td>:indeterminate</td><td>此item处于不确定状态时设置。例如，QCheckBox或QRadioButton被部分选中</td></tr><tr><td>:last</td><td>此item是列表中的最后一项时设置。例如，QTabBar中的最后一个选项卡</td></tr><tr><td>:left</td><td>此item位于左侧时设置。例如，QTabBar有位于左侧的选项卡</td></tr><tr><td>:maximized</td><td>此item处于最大化状态时设置。例如，一个最大化的QMdiSubWindow</td></tr><tr><td>:middle</td><td>此item是列表中的中间一项时设置。例如，一个不在QTabBar中的开头或结尾的选项卡</td></tr><tr><td>:minimized</td><td>此item处于最小化状态时设置。例如，一个最小化的QMdiSubWindow</td></tr><tr><td>:movable</td><td>此item可以被移动时设置。例如， QDockWidget的QDockWidget::DockWidgetMovable特性开启时</td></tr><tr><td>:no-frame</td><td>此item没有边框时设置。例如，没有边框的QSpinBox或QLineEdit</td></tr><tr><td>:non-exclusive</td><td>此item是属于非独占组时设置。例如，非独占QActionGroup中的菜单项</td></tr><tr><td>:off</td><td>对可以切换的items，这适用于处于off状态的item</td></tr><tr><td>:on</td><td>对可以切换的items，这适用于处于on状态的widget</td></tr><tr><td>:only-one</td><td>此item是列表中的唯一项时设置。例如，一个在QTabBar中单独的选项卡</td></tr><tr><td>:open</td><td>此item处于打开状态时设置。例如，QTreeView中的展开项，或带有菜单的QComboBox或QPushButton</td></tr><tr><td>:next-selected</td><td>此item是列表中的下一个被选中的项时设置。例如，在QTabBar中当前选项卡的下一个要选中的选项卡</td></tr><tr><td>:pressed</td><td>鼠标正在按压在此item上时设置</td></tr><tr><td>:previous-selected</td><td>此item是列表中的上一个被选中的项时设置。例如，在QTabBar中当前选项卡的上一个要选中的选项卡</td></tr><tr><td>:read-only</td><td>此item处于只读或不可编辑状态时设置。例如，一个只读QLineEdit或不可编辑的QComboBox</td></tr><tr><td>:right</td><td>此item位于右侧时设置。例如，QTabBar有位于右侧的选项卡</td></tr><tr><td>:selected</td><td>此item处于选中状态时设置。例如，一个在QTabBar中被选中的选项卡或一个在菜单中被选中的菜单项</td></tr><tr><td>:top</td><td>此item位于顶部时设置。例如，QTabBar有位于顶部的选项卡</td></tr><tr><td>:unchecked</td><td>此item处于未被选中状态时设置</td></tr><tr><td>:vertical</td><td>此item处于垂直方向时设置</td></tr><tr><td>:window</td><td>Widget是一个窗口(例如，一个顶层Widget)时设置</td></tr></tbody></table><h2 id="3-2-子控件列表"><a href="#3-2-子控件列表" class="headerlink" title="3.2 子控件列表"></a>3.2 子控件列表</h2><blockquote><p>伪状态都是以两个冒号<code>::</code>开头，如<code>::item</code>。</p></blockquote><table><thead><tr><th>子控件</th><th>描述</th></tr></thead><tbody><tr><td>::add-line</td><td>在QScrollBar中跳转下一行的按钮</td></tr><tr><td>::add-page</td><td>在QScrollBar中滑动条和add-line之间的区域</td></tr><tr><td>::branch</td><td>在QTreeView中的分支指示器</td></tr><tr><td>::chunk</td><td>在QProgressBar中的进度块</td></tr><tr><td>::close-button</td><td>在QDockWidget或QTabBar选项卡的关闭按钮</td></tr><tr><td>::corner</td><td>在QAbstractScrollArea中两个滚动条之间的角落</td></tr><tr><td>::down-arrow</td><td>在QComboBox、QHeaderView(排序指示器)、QScrollBar或QSpinBox的向下箭头</td></tr><tr><td>::down-button</td><td>在QScrollBar或QSpinBox中的向下按钮</td></tr><tr><td>::drop-down</td><td>在QComboBox中的下拉框</td></tr><tr><td>::float-button</td><td>在QDockWidget中的浮动按钮</td></tr><tr><td>::groove</td><td>在QSlider中的滑动槽</td></tr><tr><td>::indicator</td><td>在QAbstractItemVIew、QCheckBox、QRadioButton、可选中的菜单项或可选中的QGroupBox中的指示器</td></tr><tr><td>::handle</td><td>在QScrollBar、QSplitter和QSlider中的操作条(滑动条)</td></tr><tr><td>::icon</td><td>在QAbstractItemVIew或QMenu中的图标</td></tr><tr><td>::item</td><td>在QAbstractItemVIew、QMenuBar、QMenu或QStatuBar中的一项</td></tr><tr><td>::left-arrow</td><td>在QScrollBar中的向左箭头</td></tr><tr><td>::left-corner</td><td>在QTabWidget中的左上角</td></tr><tr><td>::menu-arrow</td><td>带有菜单的QToolButton中的箭头</td></tr><tr><td>::menu-button</td><td>在QToolButton中的菜单按钮</td></tr><tr><td>::menu-indicator</td><td>在QPushButton中的菜单指示器</td></tr><tr><td>::right-arrow</td><td>在QMenu或QScrollBar中的向右箭头</td></tr><tr><td>::pane</td><td>在QTabWidget中的边或框</td></tr><tr><td>::right-corner</td><td>在QTabWidget中的右上角</td></tr><tr><td>::scroller</td><td>在QMenu或QTabBar中的滚动条</td></tr><tr><td>::section</td><td>在QHeaderView中的区块</td></tr><tr><td>::separator</td><td>在QMenu或QMainWIndow中分隔条</td></tr><tr><td>::sub-line</td><td>在QScrollBar中跳转上一行的按钮</td></tr><tr><td>::sub-page</td><td>在QScrollBar中滑动条和sub-line之间的区域</td></tr><tr><td>::tab</td><td>在QTabBar或QToolBox中选项卡</td></tr><tr><td>::tab-bar</td><td>在QTabWidget中的选项卡栏</td></tr><tr><td>::tear</td><td>在QTabBar中的tear指示器</td></tr><tr><td>::tearoff</td><td>在QMenu中的tear-off指示器</td></tr><tr><td>::text</td><td>在QAbstractItemView中的文本</td></tr><tr><td>::title</td><td>在QGroupBox或QDockWidget中的标题栏</td></tr><tr><td>::up-arrow</td><td>在QComboBox、QHeaderView(排序指示器)、QScrollBar或QSpinBox的向上箭头</td></tr><tr><td>::up-button</td><td>在QScrollBar或QSpinBox中的向上按钮</td></tr></tbody></table><p>使用示例：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-id">#btnTest</span>::menu-indicator {</span><br><span class="line">  image: <span class="built_in">url</span>(<span class="string">indicator.png</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="四、盒子模型"><a href="#四、盒子模型" class="headerlink" title="四、盒子模型"></a>四、盒子模型</h1><p>在使用 QSS 设置样式时，有一个关键的概念需要知晓，那就是“盒子模型”（即<code>Box Model</code>）。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/qss-jbsyff-1.png"></p><p>每个 Widget 都被视为具有 4 个同心矩形的框：<br><code>MARGIN矩形</code>、<code>BORDER矩形</code>、<code>PADDING矩形</code>和<code>CONTENT矩形</code>，上图标注了每个矩形的区域。</p><p>默认情况下<code>MARGIN矩形</code>、<code>BORDER矩形</code>、<code>PADDING矩形</code>的宽度都为 0，这样在默认情况下，4 个矩形就重合为 1 个<code>CONTENT矩形</code>了。</p><p>同样，默认情况下<code>background-image</code>指定的背景，只在 border 内的区域绘制。但我们要也可以使用<code>background-clip</code>或<code>background-origin</code>属性来更改这种默认行为。</p><p><strong>如何实现背景图像随 Widget 大小自动缩放？</strong><br>background-image 指定的背景图像无法随 Widget 大小自动缩放，要提供可以随 Widget 大小缩放的背景图像可以使用<code>border-image</code>和<code>image</code>属性，二者区别如下：</p><ul><li>border-image 属性指定的图像从 border 及其内的区域开始绘制，会导致 border 属性被覆盖。</li><li>image 属性指定的图像从绘制到 content 区域内，image 指定的 url 为 SVG 图像，则支持自动缩放，非 SVG 图像仅支持自动缩小。</li></ul><h1 id="五、动态属性"><a href="#五、动态属性" class="headerlink" title="五、动态属性"></a>五、动态属性</h1><p>通过 setProperty 方法设置 QWidget 对象属性，在 QSS 中可以根据不同的属性值应用不同的样式。</p><p>设置 pushButtonMax 按钮的 isMax 属性，表示当前窗口是否最大化：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pushButtonMax-&gt;<span class="built_in">setProperty</span>(<span class="string">"isMax"</span>, <span class="keyword">this</span>-&gt;<span class="built_in">isMaximized</span>() ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br></pre></td></tr></tbody></table></figure><p>在 QSS 中根据不同的属性值应用不同的样式：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#pushButtonMax</span><span class="selector-attr">[isMax=<span class="string">"false"</span>]</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gray;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#pushButtonMax</span><span class="selector-attr">[isMax=<span class="string">"false"</span>]</span><span class="selector-pseudo">:hover</span> {</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#pushButtonMax</span><span class="selector-attr">[isMax=<span class="string">"true"</span>]</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: transparent;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#pushButtonMax</span><span class="selector-attr">[isMax=<span class="string">"true"</span>]</span><span class="selector-pseudo">:hover</span> {</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="六、Q-PROPERTY"><a href="#六、Q-PROPERTY" class="headerlink" title="六、Q_PROPERTY"></a>六、Q_PROPERTY</h1><p>在 Qt 中可以使用<code>Q_PROPERTY</code>宏为 QObject 对象（含子对象）声明属性，任何被<code>Q_PROPERTY</code>声明的属性都能在 QSS 中使用<code>qproperty-&lt;property name&gt;</code>语法进行设置。</p><p>以 QToolButton 为例，QToolButton 继承至 QAbstractButton，QAbstractButton 拥有以下被 Q_PROPERTY 声明的属性：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Q_WIDGETS_EXPORT</span> QAbstractButton : <span class="keyword">public</span> QWidget</span><br><span class="line">{</span><br><span class="line">    <span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(QString text READ text WRITE setText)</span></span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(QIcon icon READ icon WRITE setIcon)</span></span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(QSize iconSize READ iconSize WRITE setIconSize)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">ifndef</span> QT_NO_SHORTCUT</span></span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(QKeySequence shortcut READ shortcut WRITE setShortcut)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">endif</span></span></span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(<span class="type">bool</span> checkable READ isCheckable WRITE setCheckable)</span></span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(<span class="type">bool</span> checked READ isChecked WRITE setChecked DESIGNABLE isCheckable NOTIFY toggled USER <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(<span class="type">bool</span> autoRepeat READ autoRepeat WRITE setAutoRepeat)</span></span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(<span class="type">bool</span> autoExclusive READ autoExclusive WRITE setAutoExclusive)</span></span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(<span class="type">int</span> autoRepeatDelay READ autoRepeatDelay WRITE setAutoRepeatDelay)</span></span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(<span class="type">int</span> autoRepeatInterval READ autoRepeatInterval WRITE setAutoRepeatInterval)</span></span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(<span class="type">bool</span> down READ isDown WRITE setDown DESIGNABLE <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function">    ....</span></span><br><span class="line"><span class="function">}</span></span><br></pre></td></tr></tbody></table></figure><p>在 QSS 中可以直接对属性赋值，如：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QToolButton {</span><br><span class="line">  qproperty-text: <span class="string">"文本"</span>;</span><br><span class="line">  qproperty-<span class="attribute">icon</span>: <span class="built_in">url</span>(<span class="string">://img/icon.png</span>);</span><br><span class="line">  qproperty-iconsize: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="七、Padding和Margin的使用"><a href="#七、Padding和Margin的使用" class="headerlink" title="七、Padding和Margin的使用"></a>七、Padding和Margin的使用</h1><p>Margin指控件和其他控件的间距，而Padding指控件内的内容与边框的间距。</p><p>二者的语法与CSS中的一样：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin</span>: <span class="number">25px</span> <span class="number">50px</span> <span class="number">75px</span> <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">25px</span> <span class="number">50px</span> <span class="number">75px</span> <span class="number">100px</span>;</span><br></pre></td></tr></tbody></table></figure><p>从左到右依次为：上、右、下、左。</p><p>支持简写形式：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin</span>: <span class="number">25px</span> <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">25px</span> <span class="number">50px</span>;</span><br></pre></td></tr></tbody></table></figure><p>表示：上下间距为25px，左右间距为50px。</p>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++默认构造函数</title>
      <link href="/post/818165951.html"/>
      <url>/post/818165951.html</url>
      
        <content type="html"><![CDATA[<p>本文围绕 3 个问题来理解 C++的默认构造函数：</p><ol><li>什么是默认构造函数？</li><li>默认构造函数什么时候被调用？</li><li>编译器在什么情况下会生成默认构造函数？</li></ol><span id="more"></span><h2 id="一-什么是默认构造函数？"><a href="#一-什么是默认构造函数？" class="headerlink" title="一. 什么是默认构造函数？"></a>一. 什么是默认构造函数？</h2><p>我们一般会认为默认构造函数就是编译器自动生成的那个构造函数，其实这种理解不全面。<br><strong>准确的说，默认构造函数就是在调用时不需要显示地传入实参的构造函数。</strong></p><p>根据这个原则，下面 2 种构造函数都是默认构造函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 默认构造函数。</span></span><br><span class="line">  <span class="built_in">Sample</span>() {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 默认构造函数。虽然有形参，但有默认值，调用的时候可以不显示的传入实参。</span></span><br><span class="line">  <span class="built_in">Sample</span>(<span class="type">int</span> m = <span class="number">10</span>) {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="二-默认构造函数什么时候被调用？"><a href="#二-默认构造函数什么时候被调用？" class="headerlink" title="二. 默认构造函数什么时候被调用？"></a>二. 默认构造函数什么时候被调用？</h2><p>如果定义一个对象时没有使用初始化式，编译器就会使用默认构造函数。如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sample s;</span><br></pre></td></tr></tbody></table></figure><h2 id="三-编译器在什么情况下会生成默认构造函数？"><a href="#三-编译器在什么情况下会生成默认构造函数？" class="headerlink" title="三. 编译器在什么情况下会生成默认构造函数？"></a>三. 编译器在什么情况下会生成默认构造函数？</h2><p>有一句很经典的话可以用来回答这个问题：<strong>惟有默认构造函数被编译器需要的时候，编译器才会生成默认构造函数。</strong></p><p>那我们只需知道什么时候“被编译器需要”，就可以知道什么情况下会生成默认构造函数了。</p><p>下面几种情况下，编译需要生成默认构造函数：</p><ol><li>当该类的<code>类对象数据成员</code>有默认构造函数时。</li><li>当该类的基类有默认构造函数时。</li><li>当该类的基类为虚基类时。</li><li>当该类有虚函数时。</li></ol><h2 id="四-注意事项"><a href="#四-注意事项" class="headerlink" title="四. 注意事项"></a>四. 注意事项</h2><h3 id="4-1-避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在"><a href="#4-1-避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在" class="headerlink" title="4.1 避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在"></a>4.1 避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在</h3><p><code>无参数的默认构造函数</code>和<code>带缺省参数的默认构造函数</code>同时存在时，编译器会产生二义性，从而生成编译错误。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 默认构造函数</span></span><br><span class="line">  <span class="built_in">Sample</span>() {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Sample()"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认构造函数</span></span><br><span class="line">  <span class="built_in">Sample</span>(<span class="type">int</span> m = <span class="number">10</span>) {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Sample(int m = 10)"</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  Sample s; <span class="comment">// error C2668: “Sample::Sample”: 对重载函数的调用不明确</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-2-不应在对象名后面加上括号"><a href="#4-2-不应在对象名后面加上括号" class="headerlink" title="4.2 不应在对象名后面加上括号"></a>4.2 不应在对象名后面加上括号</h3><p>使用无参构造函数创建对象时，不应在对象名后面加上括号，否则会产生编译警告</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?)</span><br></pre></td></tr></tbody></table></figure><p>因为编译器误认为<code>Sample s();</code>语句时要声明返回值为<code>Sample</code>对象的函数<code>s</code>，而又没找到函数<code>s</code>的定义，所以产生了警告。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 默认构造函数</span></span><br><span class="line">  <span class="built_in">Sample</span>() {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Sample()"</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="function">Sample <span class="title">s</span><span class="params">()</span></span>; <span class="comment">// warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++内存池实现</title>
      <link href="/post/581068365.html"/>
      <url>/post/581068365.html</url>
      
        <content type="html"><![CDATA[<p>本文从实际需求出发，介绍了内存池的实现原理，并且提供了具体的实现方案。</p><h1 id="一、为什么需要使用内存池"><a href="#一、为什么需要使用内存池" class="headerlink" title="一、为什么需要使用内存池"></a>一、为什么需要使用内存池</h1><p>在 C/C++中我们通常使用<code>malloc</code>,<code>free</code>或<code>new</code>,<code>delete</code>来动态分配内存。<br>一方面，因为这些函数涉及到了系统调用，所以频繁的调用必然会导致程序性能的损耗；</p><p>另一方面，频繁的分配和释放小块内存会导致大量的内存碎片的产生，当碎片积累到一定的量之后，将无法分配到连续的内存空间，系统不得不进行碎片整理来满足分配到连续的空间，这样不仅会导致系统性能损耗，而且会导致程序对内存的利用率低下。</p><p>当然，如果我们的程序不需要频繁的分配和释放小块内存，那就没有使用内存池的必要，直接使用<code>malloc</code>,<code>free</code>或<code>new</code>,<code>delete</code>函数即可。</p><span id="more"></span><h1 id="二、内存池的实现方案"><a href="#二、内存池的实现方案" class="headerlink" title="二、内存池的实现方案"></a>二、内存池的实现方案</h1><p>内存池的实现原理大致如下：<br>提前申请一块大内存由内存池自己管理，并分成小片供给程序使用。程序使用完之后将内存归还到内存池中（并没有真正的从系统释放），当程序再次从内存池中请求内存时，内存池将池子中的可用内存片返回给程序使用。</p><p>我们在设计内存池的实现方案时，需要考虑到以下问题：</p><ol><li><p>内存池是否可以自动增长？<br>如果内存池的最大空间是固定的（也就是非自动增长），那么当内存池中的内存被请求完之后，程序就无法再次从内存池请求到内存。所以需要根据程序对内存的实际使用情况来确定是否需要自动增长。</p></li><li><p>内存池的总内存占用是否只增不减？<br>如果内存池是自动增长的，就涉及到了“内存池的总内存占用是否是只增不减”这个问题了。试想，程序从一个自动增长的内存池中请求了 1000 个大小为 100KB 的内存片，并在使用完之后全部归还给了内存池，而且假设程序之后的逻辑最多只需要 10 个 100KB 的内存片，该内存池中的 900 个 100KB 的内存片就一直处于闲置状态，程序内存占用就一直降下来。对内存占用大小有要求的程序需要考虑到这一点。</p></li><li><p>内存池中内存片的大小是否固定？<br>如果每次从内存池中的请求的内存片的大小如果不固定，那么内存池中的每个可用内存片的大小就不一致，程序再次请求内存片的时候，内存池就需要在“匹配最佳大小的内存片”和“匹配操作时间”上作出衡量。“最佳大小的内存片”虽然可以减少内存的浪费，但可能会导致“匹配时间”变长。</p></li><li><p>内存池是否是线程安全的？<br>是否允许在多个线程中同时从同一个内存池中请求和归还内存片？这个线程安全可以由内存池来实现，也可以由使用者来保证。</p></li><li><p>内存片分配出去之前和归还到内存池之后，其中的内容是否需要被清除？<br>程序可能出现将内存片归还给内存池之后，仍然使用内存片的地址指针进行内存读写操作，这样就会导致不可预期的结果。将内容清零只能尽量的（也不一定能）将问题抛出来，但并不能解决任何问题，而且将内容清零会消耗一定的 CPU 时间。所以，最终最好还是需要由内存池的使用者来保证这种安全性。</p></li><li><p>是否兼容<code>std::allocator</code>？<br>STL 标准库中的大多类都支持用户提供一个自定义的内存分配器，默认使用的是<code>std::allocator</code>，如<code>std::string</code>：<br><code>typedef basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt; string;</code></p></li></ol><p>如果我们的内存池兼容 std::allocator，那么我们就可以使用我们自己的内存池来替换默认的 std::allocator 分配器，如：<br><code>typedef basic_string&lt;char, char_traits&lt;char&gt;, MemoryPoll&lt;char&gt; &gt; mystring;</code></p><blockquote><p>关于如何兼容<code>std::allocator</code>，可以参考<a href="http://www.cplusplus.com/reference/memory/allocator/">http://www.cplusplus.com/reference/memory/allocator/</a></p></blockquote><h1 id="三、内存池的具体实现"><a href="#三、内存池的具体实现" class="headerlink" title="三、内存池的具体实现"></a>三、内存池的具体实现</h1><p>计划实现一个内存池管理的类<code>MemoryPool</code>，它具有如下特性：</p><ol><li>内存池的总大小自动增长。</li><li>内存池中内存片的大小固定。</li><li>支持线程安全。</li><li>在内存片被归还之后，清除其中的内容。</li><li>兼容<code>std::allocator</code>。</li></ol><p>因为内存池的内存片的大小是固定的，不涉及到需要匹配最合适大小的内存片，由于会频繁的进行插入、移除的操作，但查找比较少，故选用<code>链表</code>数据结构来管理内存池中的内存片。</p><p>MemoryPool 中有 2 个链表，它们都是双向链表（设计成双向链表主要是为了在移除指定元素时，能够快速定位该元素的前后元素，从而在该元素被移除后，将其前后元素连接起来，保证链表的完整性）：</p><ol><li><code>data_element_</code> 记录以及分配出去的内存片。</li><li><code>free_element_</code> 记录未被分配出去的内存片。</li></ol><h2 id="3-1-MemoryPool实现代码"><a href="#3-1-MemoryPool实现代码" class="headerlink" title="3.1 MemoryPool实现代码"></a>3.1 <code>MemoryPool</code>实现代码</h2><p>下面是完整的内存池实现的代码，代码中使用了 std::mutex 等 C++11 才支持的特性，所以需要编译器最低支持 C++11。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MemoryPool.hpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MEMORY_POOL_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMORY_POOL_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize = <span class="number">4096</span>, <span class="type">bool</span> ZeroOnDeallocate = <span class="literal">true</span>&gt;</span><br><span class="line"><span class="keyword">class</span> MemoryPool {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* Member types */</span></span><br><span class="line">    <span class="keyword">typedef</span> T               value_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*              pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;              reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T*        const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T&amp;        const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span>          size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>       difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::false_type propagate_on_container_copy_assignment;</span><br><span class="line">    <span class="keyword">typedef</span> std::true_type  propagate_on_container_move_assignment;</span><br><span class="line">    <span class="keyword">typedef</span> std::true_type  propagate_on_container_swap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">struct</span> <span class="title class_">rebind</span> {</span><br><span class="line">        <span class="keyword">typedef</span> MemoryPool&lt;U&gt; other;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Member functions */</span></span><br><span class="line">    <span class="built_in">MemoryPool</span>() <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="built_in">MemoryPool</span>(<span class="type">const</span> MemoryPool&amp; memoryPool) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="built_in">MemoryPool</span>(MemoryPool&amp;&amp; memoryPool) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="built_in">MemoryPool</span>(<span class="type">const</span> MemoryPool&lt;U&gt;&amp; memoryPool) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MemoryPool</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">    MemoryPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MemoryPool&amp; memoryPool) = <span class="keyword">delete</span>;</span><br><span class="line">    MemoryPool&amp; <span class="keyword">operator</span>=(MemoryPool&amp;&amp; memoryPool) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">pointer <span class="title">address</span><span class="params">(reference x)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function">const_pointer <span class="title">address</span><span class="params">(const_reference x)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can only allocate one object at a time. n and hint are ignored</span></span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n = <span class="number">1</span>, const_pointer hint = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer p, size_type n = <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span>... Args&gt; <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(U* p, Args&amp;&amp;... args)</span></span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(U* p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt; <span class="function">pointer <span class="title">newElement</span><span class="params">(Args&amp;&amp;... args)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteElement</span><span class="params">(pointer p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Element_</span> {</span><br><span class="line">        Element_* pre;</span><br><span class="line">        Element_* next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span>* data_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Element_ element_type;</span><br><span class="line">    <span class="keyword">typedef</span> Element_* element_pointer;</span><br><span class="line"></span><br><span class="line">    element_pointer data_element_;</span><br><span class="line">    element_pointer free_element_;</span><br><span class="line"></span><br><span class="line">    std::recursive_mutex m_;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">padPointer</span><span class="params">(data_pointer p, size_type align)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">allocateBlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static_assert</span>(BlockSize &gt;= <span class="number">2</span> * <span class="built_in">sizeof</span>(element_type), <span class="string">"BlockSize too small."</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize,  <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::size_type</span><br><span class="line">    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::<span class="built_in">padPointer</span>(data_pointer p, size_type align)</span><br><span class="line">    <span class="type">const</span> <span class="keyword">noexcept</span> {</span><br><span class="line">    <span class="type">uintptr_t</span> result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> ((align - result) % align);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize,  <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line">MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::<span class="built_in">MemoryPool</span>()</span><br><span class="line">    <span class="keyword">noexcept</span> {</span><br><span class="line">    data_element_ = <span class="literal">nullptr</span>;</span><br><span class="line">    free_element_ = <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize,  <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line">MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::<span class="built_in">MemoryPool</span>(<span class="type">const</span> MemoryPool&amp; memoryPool)</span><br><span class="line">    <span class="keyword">noexcept</span> :</span><br><span class="line">    <span class="built_in">MemoryPool</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize,  <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line">MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::<span class="built_in">MemoryPool</span>(MemoryPool&amp;&amp; memoryPool)</span><br><span class="line">    <span class="keyword">noexcept</span> {</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line"></span><br><span class="line">    data_element_ = memoryPool.data_element_;</span><br><span class="line">    memoryPool.data_element_ = <span class="literal">nullptr</span>;</span><br><span class="line">    free_element_ = memoryPool.free_element_;</span><br><span class="line">    memoryPool.free_element_ = <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize,  <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::<span class="built_in">MemoryPool</span>(<span class="type">const</span> MemoryPool&lt;U&gt;&amp; memoryPool)</span><br><span class="line">    <span class="keyword">noexcept</span> :</span><br><span class="line">    <span class="built_in">MemoryPool</span>() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize,  <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line">MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;&amp;</span><br><span class="line">    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::<span class="keyword">operator</span>=(MemoryPool&amp;&amp; memoryPool)</span><br><span class="line">    <span class="keyword">noexcept</span> {</span><br><span class="line">    std::lock_guard&lt;std::recursive_mutex&gt; <span class="built_in">lock</span>(m_);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;memoryPool) {</span><br><span class="line">        std::<span class="built_in">swap</span>(data_element_, memoryPool.data_element_);</span><br><span class="line">        std::<span class="built_in">swap</span>(free_element_, memoryPool.free_element_);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize,  <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line">MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::~<span class="built_in">MemoryPool</span>()</span><br><span class="line">    <span class="keyword">noexcept</span> {</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line"></span><br><span class="line">    element_pointer curr = data_element_;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) {</span><br><span class="line">        element_pointer prev = curr-&gt;next;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(curr))</span></span>;</span><br><span class="line">        curr = prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    curr = free_element_;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) {</span><br><span class="line">        element_pointer prev = curr-&gt;next;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(curr))</span></span>;</span><br><span class="line">        curr = prev;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize,  <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::pointer</span><br><span class="line">    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::<span class="built_in">address</span>(reference x)</span><br><span class="line">    <span class="type">const</span> <span class="keyword">noexcept</span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize,  <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::const_pointer</span><br><span class="line">    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::<span class="built_in">address</span>(const_reference x)</span><br><span class="line">    <span class="type">const</span> <span class="keyword">noexcept</span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize,  <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::<span class="built_in">allocateBlock</span>() {</span><br><span class="line">    <span class="comment">// Allocate space for the new block and store a pointer to the previous one</span></span><br><span class="line">    data_pointer new_block = <span class="built_in">reinterpret_cast</span>&lt;data_pointer&gt; (<span class="keyword">operator</span> <span class="built_in">new</span>(BlockSize));</span><br><span class="line">    element_pointer new_ele_pointer = <span class="built_in">reinterpret_cast</span>&lt;element_pointer&gt;(new_block);</span><br><span class="line">    new_ele_pointer-&gt;pre = <span class="literal">nullptr</span>;</span><br><span class="line">    new_ele_pointer-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data_element_) {</span><br><span class="line">        data_element_-&gt;pre = new_ele_pointer;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    new_ele_pointer-&gt;next = data_element_;</span><br><span class="line">    data_element_ = new_ele_pointer;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize,  <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::pointer</span><br><span class="line">    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::<span class="built_in">allocate</span>(size_type n, const_pointer hint) {</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (free_element_ != <span class="literal">nullptr</span>) {</span><br><span class="line">        data_pointer body =</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;data_pointer&gt;(<span class="built_in">reinterpret_cast</span>&lt;data_pointer&gt;(free_element_) + <span class="built_in">sizeof</span>(element_type));</span><br><span class="line"></span><br><span class="line">        size_type bodyPadding = <span class="built_in">padPointer</span>(body, <span class="built_in">alignof</span>(element_type));</span><br><span class="line"></span><br><span class="line">        pointer result = <span class="built_in">reinterpret_cast</span>&lt;pointer&gt;(<span class="built_in">reinterpret_cast</span>&lt;data_pointer&gt;(body + bodyPadding));</span><br><span class="line"></span><br><span class="line">        element_pointer tmp = free_element_;</span><br><span class="line"></span><br><span class="line">        free_element_ = free_element_-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (free_element_)</span><br><span class="line">            free_element_-&gt;pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        tmp-&gt;next = data_element_;</span><br><span class="line">        <span class="keyword">if</span> (data_element_)</span><br><span class="line">            data_element_-&gt;pre = tmp;</span><br><span class="line">        tmp-&gt;pre = <span class="literal">nullptr</span>;</span><br><span class="line">        data_element_ = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">allocateBlock</span>();</span><br><span class="line"></span><br><span class="line">        data_pointer body =</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;data_pointer&gt;(<span class="built_in">reinterpret_cast</span>&lt;data_pointer&gt;(data_element_) + <span class="built_in">sizeof</span>(element_type));</span><br><span class="line"></span><br><span class="line">        size_type bodyPadding = <span class="built_in">padPointer</span>(body, <span class="built_in">alignof</span>(element_type));</span><br><span class="line"></span><br><span class="line">        pointer result = <span class="built_in">reinterpret_cast</span>&lt;pointer&gt;(<span class="built_in">reinterpret_cast</span>&lt;data_pointer&gt;(body + bodyPadding));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize, <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::<span class="built_in">deallocate</span>(pointer p, size_type n) {</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">        element_pointer ele_p =</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;element_pointer&gt;(<span class="built_in">reinterpret_cast</span>&lt;data_pointer&gt;(p) - <span class="built_in">sizeof</span>(element_type));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ZeroOnDeallocate) {</span><br><span class="line">            <span class="built_in">memset</span>(<span class="built_in">reinterpret_cast</span>&lt;data_pointer&gt;(p), <span class="number">0</span>, BlockSize - <span class="built_in">sizeof</span>(element_type));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ele_p-&gt;pre) {</span><br><span class="line">            ele_p-&gt;pre-&gt;next = ele_p-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ele_p-&gt;next) {</span><br><span class="line">            ele_p-&gt;next-&gt;pre = ele_p-&gt;pre;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ele_p-&gt;pre == <span class="literal">nullptr</span>) {</span><br><span class="line">            data_element_ = ele_p-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ele_p-&gt;pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (free_element_) {</span><br><span class="line">            ele_p-&gt;next = free_element_;</span><br><span class="line">            free_element_-&gt;pre = ele_p;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            ele_p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">        free_element_ = ele_p;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize, <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::size_type</span><br><span class="line">    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::<span class="built_in">max_size</span>()</span><br><span class="line">    <span class="type">const</span> <span class="keyword">noexcept</span> {</span><br><span class="line">    size_type maxBlocks = <span class="number">-1</span> / BlockSize;</span><br><span class="line">    <span class="keyword">return</span> (BlockSize - <span class="built_in">sizeof</span>(data_pointer)) / <span class="built_in">sizeof</span>(element_type) * maxBlocks;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize, <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::<span class="built_in">construct</span>(U* p, Args&amp;&amp;... args) {</span><br><span class="line">    <span class="keyword">new</span> (p) <span class="built_in">U</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize, <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::<span class="built_in">destroy</span>(U* p) {</span><br><span class="line">    p-&gt;~<span class="built_in">U</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize, <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::pointer</span><br><span class="line">    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::<span class="built_in">newElement</span>(Args&amp;&amp;... args) {</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">    pointer result = <span class="built_in">allocate</span>();</span><br><span class="line">    <span class="built_in">construct</span>&lt;value_type&gt;(result, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize, <span class="type">bool</span> ZeroOnDeallocate&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::<span class="built_in">deleteElement</span>(pointer p) {</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">        p-&gt;~<span class="built_in">value_type</span>();</span><br><span class="line">        <span class="built_in">deallocate</span>(p);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="3-2-使用示例"><a href="#3-2-使用示例" class="headerlink" title="3.2 使用示例"></a>3.2 使用示例</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MemoryPool.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Apple</span>() {</span><br><span class="line">        id_ = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"Apple()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Apple</span>(<span class="type">int</span> id) {</span><br><span class="line">        id_ = id;</span><br><span class="line">        cout &lt;&lt; <span class="string">"Apple("</span> &lt;&lt; id_ &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Apple</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Apple()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetId</span><span class="params">(<span class="type">int</span> id)</span> </span>{</span><br><span class="line">        id_ = id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetId</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> id_;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id_;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadProc</span><span class="params">(MemoryPool&lt;<span class="type">char</span>&gt; *mp)</span> </span>{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) {</span><br><span class="line">        <span class="type">char</span>* p0 = (<span class="type">char</span>*)mp-&gt;<span class="built_in">allocate</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* p1 = (<span class="type">char</span>*)mp-&gt;<span class="built_in">allocate</span>();</span><br><span class="line"></span><br><span class="line">        mp-&gt;<span class="built_in">deallocate</span>(p0);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* p2 = (<span class="type">char</span>*)mp-&gt;<span class="built_in">allocate</span>();</span><br><span class="line"></span><br><span class="line">        mp-&gt;<span class="built_in">deallocate</span>(p1);</span><br><span class="line"></span><br><span class="line">        mp-&gt;<span class="built_in">deallocate</span>(p2);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    MemoryPool&lt;<span class="type">char</span>&gt; mp;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) {</span><br><span class="line">        <span class="type">char</span>* p0 = (<span class="type">char</span>*)mp.<span class="built_in">allocate</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* p1 = (<span class="type">char</span>*)mp.<span class="built_in">allocate</span>();</span><br><span class="line"></span><br><span class="line">        mp.<span class="built_in">deallocate</span>(p0);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* p2 = (<span class="type">char</span>*)mp.<span class="built_in">allocate</span>();</span><br><span class="line"></span><br><span class="line">        mp.<span class="built_in">deallocate</span>(p1);</span><br><span class="line"></span><br><span class="line">        mp.<span class="built_in">deallocate</span>(p2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">th0</span><span class="params">(ThreadProc, &amp;mp)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">th1</span><span class="params">(ThreadProc, &amp;mp)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">th2</span><span class="params">(ThreadProc, &amp;mp)</span></span>;</span><br><span class="line"></span><br><span class="line">    th0.<span class="built_in">join</span>();</span><br><span class="line">    th1.<span class="built_in">join</span>();</span><br><span class="line">    th2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    Apple* apple = <span class="literal">nullptr</span>;</span><br><span class="line">    MemoryPool&lt;Apple&gt; mp2;</span><br><span class="line">    apple = mp2.<span class="built_in">newElement</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">assert</span>(apple);</span><br><span class="line">    <span class="type">int</span> a = apple-&gt;<span class="built_in">GetId</span>(); <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">assert</span>(a == <span class="number">10</span>);</span><br><span class="line">    apple-&gt;<span class="built_in">SetId</span>(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    mp2.<span class="built_in">deleteElement</span>(apple);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>移除Qt控件虚线框</title>
      <link href="/post/2202762022.html"/>
      <url>/post/2202762022.html</url>
      
        <content type="html"><![CDATA[<h1 id="方式一：使用-StyleSheet"><a href="#方式一：使用-StyleSheet" class="headerlink" title="方式一：使用 StyleSheet"></a>方式一：使用 StyleSheet</h1><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QWidget<span class="selector-pseudo">:focus</span> {</span><br><span class="line">  <span class="attribute">outline</span>: none; <span class="comment">/* 去掉得到焦点时的虚线框 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="方式二：继承-QProxyStyle"><a href="#方式二：继承-QProxyStyle" class="headerlink" title="方式二：继承 QProxyStyle"></a>方式二：继承 QProxyStyle</h1><p>继承 QProxyStyle，PrimitiveElement 为 QStyle::PE_FrameFocusRect 时不绘制虚线框，然后在 main() 函数里调用 QApplication::setStyle() 使用新的样式。</p><span id="more"></span><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名: NoFocusRectStyle.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NOFOCUSRECTSTYLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOFOCUSRECTSTYLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QProxyStyle&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoFocusRectStyle</span> : <span class="keyword">public</span> QProxyStyle</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NoFocusRectStyle</span>(QStyle *baseStyle) : <span class="built_in">QProxyStyle</span>(baseStyle) {}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drawPrimitive</span><span class="params">(PrimitiveElement element,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> QStyleOption *option,</span></span></span><br><span class="line"><span class="params"><span class="function">                       QPainter *painter,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> QWidget *widget = <span class="number">0</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        <span class="keyword">if</span> (element == QStyle::PE_FrameFocusRect)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        QProxyStyle::<span class="built_in">drawPrimitive</span>(element, option, painter, widget);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// NOFOCUSRECTSTYLE_H</span></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名: main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"NoFocusRectStyle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    NoFocusRectStyle *style = <span class="keyword">new</span> <span class="built_in">NoFocusRectStyle</span>(app.<span class="built_in">style</span>());</span><br><span class="line">    app.<span class="built_in">setStyle</span>(style); <span class="comment">// Ownership of the style object is transferred to QApplication</span></span><br><span class="line">    Widget w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windbg基本使用方法</title>
      <link href="/post/2711697202.html"/>
      <url>/post/2711697202.html</url>
      
        <content type="html"><![CDATA[<p>Windbg 是 Microsoft 公司推出的免费的、带 GUI 的调试器，支持 Source 和 Assembly 两种模式的调试。</p><p>Windbg 不仅可以调试应用程序，还可以进行系统内核调试，Windbg 支持的平台包括 X86、IA64、AMD64。</p><span id="more"></span><h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><p>从下面的链接或其他链接下载安装：<br><a href="https://developer.microsoft.com/en-us/windows/hardware/download-windbg">Download Debugging tools for Windows</a></p><h1 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h1><p>常用的配置包含符号文件搜索路径、可执行文件搜索路径、源码文件搜索路径配置。</p><h2 id="2-1-符号文件搜索路径配置"><a href="#2-1-符号文件搜索路径配置" class="headerlink" title="2.1 符号文件搜索路径配置"></a>2.1 符号文件搜索路径配置</h2><p>在菜单项File -&gt; Symbol File Path中设置，如：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\symbol_path;SRV*D:\symbolslocal*http://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></tbody></table></figure><p>意思是先从<code>D:\symbol_path</code>中找符号文件；如果没找到，就去服务器中下载并保存到<code>D:\symbolslocal</code>目录中。</p><p>可以使用<code>.sympath+ </code>命令来添加其他目录到搜索路径中，如<code>.sympath+ D:\other_symbol_dir</code>。 然后使用<code>.reload</code>来根据新的路径重新搜索并加载符号文件。</p><h2 id="2-2-可执行文件路径"><a href="#2-2-可执行文件路径" class="headerlink" title="2.2 可执行文件路径"></a>2.2 可执行文件路径</h2><p>在菜单项File -&gt; Image File Path中设置，此项是在加载 dump 时，设置可执行文件 exe、dll 的路径的。</p><h2 id="2-3-源代码目录配置"><a href="#2-3-源代码目录配置" class="headerlink" title="2.3 源代码目录配置"></a>2.3 源代码目录配置</h2><p>在菜单项File -&gt; Source File Path中设置源代码目录。如果当前指令指针在源代码范围内，就会自动跳出源文件窗口。源文件窗口中的操作和 vs 类似。如果没有跳出，可以单机菜单项 Open Source File 手动选择源文件</p><h2 id="2-4-设置启动产生"><a href="#2-4-设置启动产生" class="headerlink" title="2.4 设置启动产生"></a>2.4 设置启动产生</h2><p>可以通过对 windbg 加入启动参数的方式来指定符号文件路径和源码路径等等。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start "" "%~dp0/Debuggers_x86/windbg.exe" -Q -y "D:\symbolslocal*http://msdl.microsoft.com/download/symbols" -srcpath "srv*C:\CodeCache"</span><br></pre></td></tr></tbody></table></figure><h1 id="三、开始调试"><a href="#三、开始调试" class="headerlink" title="三、开始调试"></a>三、开始调试</h1><p>可以通过菜单项<code>File -&gt; Open Executable</code>来加载本地的一个 exe 来进行调试，也可以通过菜单项<code>File -&gt; Attache to a Process</code>来加载一个已经运行的 exe 来进行调试。</p><p>具体调试指令可以参考：<br><code>Help -&gt; Contents -&gt; Debugging Tools for Windows -&gt; Debuggers -&gt; Debugger Reference</code></p><h1 id="四、工作空间"><a href="#四、工作空间" class="headerlink" title="四、工作空间"></a>四、工作空间</h1><p>Windbg 会保存每个你调试的工程的信息，这些信息包括调试项目的属性、参数、会话状态、调试器设置、及图形界面信息，类似于 ide 的项目文件。</p><p>每个调试的工作空间信息默认保存在<br><code>HKEY_CURRENT_USER\Software\Microsoft\Windbg\Workspaces</code>中，在这个键下一般有 4 个子键 User、Kernel、Dump、Explicit, 他们分别保存用户态调试，内核态调试、转储文件调试、以及手动保存（Save Workspace As）的工作空间信息。</p><h1 id="五、窗口界面介绍"><a href="#五、窗口界面介绍" class="headerlink" title="五、窗口界面介绍"></a>五、窗口界面介绍</h1><table><thead><tr><th>名称</th><th>热键</th><th>用途</th></tr></thead><tbody><tr><td>Command</td><td>Atl+1</td><td>输入命令、显示命令结果和调试信息输出</td></tr><tr><td>Watch</td><td>Atl+2</td><td>观察指令全局变量、局部变量和寄存器的信息</td></tr><tr><td>Locals</td><td>Atl+3</td><td>自动显示当前函数的所有局部变量</td></tr><tr><td>Registers</td><td>Atl+4</td><td>观察和修改寄存器的值</td></tr><tr><td>Memory</td><td>Atl+5</td><td>观察和修改内存数据</td></tr><tr><td>Call Stack</td><td>Atl+6</td><td>栈中记录的函数调用序列</td></tr><tr><td>Disassembly</td><td>Atl+7</td><td>反汇编</td></tr><tr><td>Scratch Pad</td><td>Atl+8</td><td>白板，可以用来做调试笔记等</td></tr><tr><td>Processes and Threads</td><td>Atl+9</td><td>显示所有调试目标的列表，包括进程和线程等</td></tr><tr><td>Command Browser</td><td>Ctrl+N</td><td>执行和浏览命令</td></tr></tbody></table><h1 id="六、常用命令"><a href="#六、常用命令" class="headerlink" title="六、常用命令"></a>六、常用命令</h1><p>windbg 命令分为<code>标准命令</code>，<code>元命令</code>和<code>扩展命令</code>。<br>以<code>.</code>开头的元命令提供标准命令没有提供的功能，也内建在调试引擎中。<br>以<code>!</code>开头的扩展命令用于扩展某一方面的调试功能，实现在动态加载的扩展模块中。</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">tab键       自动完成命令</span><br><span class="line">.hh         查看指定命令的帮助手册</span><br><span class="line">.reload     重新加载符号文件</span><br><span class="line">.restart    重新启动调试目标</span><br><span class="line"></span><br><span class="line">bp $exentry 在程序入口点设置断点，$exentry是一个伪寄存器</span><br><span class="line">bp 0x00401030              在地址0x00401030处设置断点</span><br><span class="line">bp MyTestModule!MyTestFunc 在MyTestModule模块中的MyTestFunc函数处设置断点，前提是该模块符号已经加载</span><br><span class="line">bp MyTestModule!MyTestClass::SetValue        在模块MyTestModule的MyTestClass类成员函数SetValue处设置断点</span><br><span class="line">bp @@C++(MyTestModule!MyTestClass::SetValue) 与上面一样，语法不同，C++语法，上面的为MASM语法</span><br><span class="line">bl 查看设置的断点</span><br><span class="line">be 激活断点</span><br><span class="line">bd 禁用断点</span><br><span class="line">bc 删除某个断点</span><br><span class="line">ba              设置访问断点</span><br><span class="line">ba r 1 0044108c 在内存0044108c的位置开始的下一个字节的读断点</span><br><span class="line">ba w4@@C++(&amp;i)  给变量i地址下4个字节的写断点</span><br><span class="line"></span><br><span class="line">g               运行程序，相当于F5</span><br><span class="line">gu              返回函数调用处，相当于shift+F11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u               查看当前正要执行的代码</span><br><span class="line">k               查看当前调用堆栈</span><br><span class="line">~*kb          显示所有进程调用堆栈</span><br><span class="line"></span><br><span class="line">~           查看调试进程中的线程信息</span><br><span class="line">!teb        线程环境块</span><br><span class="line">~.          当前线程信息</span><br><span class="line">~#          导致当前异常或调试事件的线程信息</span><br><span class="line">~[Number]s  线程切换</span><br><span class="line"></span><br><span class="line">a                                修改当前指令，输入修改的指令按Enter结束</span><br><span class="line">s –a 00400000 L53000 “Wrong”     以ASCII码的形式从00400000处开始往后53000个字节搜索字符串“Wrong”</span><br><span class="line">db 400000       以二进制的方式显示内存地位为400000开始的内容</span><br><span class="line">dd 400000       以DWORD类型查看</span><br><span class="line">d               按上一次的d命令的方式来显示，如果不带参数，则从上一次显示结束的地方继续显示</span><br><span class="line">?i              查看局部变量i的值，会以10进制和16进制同时显示</span><br><span class="line">eb 0012ff78 'a' 'b'      从内存地址0012ff78开始依次写入后面的值</span><br><span class="line">r                        用于查看或者修改寄存器或伪寄存器</span><br><span class="line">r $peb                   $peb是一个伪寄存器，调试器将它定义为当前进程的进程环境块地址</span><br><span class="line">dt                       用于查看结构体内容</span><br><span class="line">!address 400000          查看指定内存地址的信息</span><br><span class="line">dv                       查看当前作用域下局部变量的类型和值</span><br><span class="line"></span><br><span class="line">.ecxr                   当前异常的上下文信息</span><br><span class="line">!analyze -v              详细显示当前异常信息，常用于分析dmp文件</span><br><span class="line"></span><br><span class="line">|             所有进程列表</span><br><span class="line">|.            当前进程信息</span><br><span class="line">|#            导致当前异常或调试事件的进程信息</span><br><span class="line">|[Number]s    进程切换</span><br><span class="line">!peb        进程环境块</span><br><span class="line"></span><br><span class="line">!locks              查看进程中有些锁处于锁定状态</span><br><span class="line">!cs -l              查看处于锁定状态的关键区</span><br><span class="line">!handle 000000c0 f  查看句柄000000c0的信息</span><br></pre></td></tr></tbody></table></figure><h1 id="七、常用调试方法"><a href="#七、常用调试方法" class="headerlink" title="七、常用调试方法"></a>七、常用调试方法</h1><h2 id="7-1、附加进程调试"><a href="#7-1、附加进程调试" class="headerlink" title="7.1、附加进程调试"></a>7.1、附加进程调试</h2><p>使用 File 菜单中的 Attach to a Process 选项来选择要附加调试的进程.</p><h2 id="7-2、启动新进程并调试"><a href="#7-2、启动新进程并调试" class="headerlink" title="7.2、启动新进程并调试"></a>7.2、启动新进程并调试</h2><ol><li>使用菜单<code>File-&gt; Open Executable</code>选项来选择要启动调试的进程。</li><li>启动 windbg 时将待调试的程序的文件路径作为参数传递给 windbg。</li><li>新建注册表项。<br>在“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options”下新建一个以程序名命名的子项，然后在这个子项中新建一个名为<code>Debugger</code>的<code>REG_SZ</code>类型的值，将值设置为 windbg 的全路径，比如：C:\Program Files (x86)\Windows Kits\8.1\Debuggers\x86\windbg.exe。</li></ol><p>这样，再运行待调试的程序时，操作系统就会先启动 windbg，并把要调试程序的路径传递给他。</p><h2 id="7-3、调试转储文件"><a href="#7-3、调试转储文件" class="headerlink" title="7.3、调试转储文件"></a>7.3、调试转储文件</h2><p>使用 File 菜单中的 Open Crash Dump 选项来加载 dump 文件。</p><h2 id="7-4、远程调试"><a href="#7-4、远程调试" class="headerlink" title="7.4、远程调试"></a>7.4、远程调试</h2><p>服务器（被调试程序的机器）和客户端（发出远程请求的机器）都应该安装版本相同的 windbg，应该有网络连接或者串行口连接。</p><ul><li><p>以 tcp 端口方式：<br>以命令行的方式启动服务器中的 windbg，如：windbg.exe -server tcp:port=5005<br>以命令行的方式启动客户端中的 windbg，如：windbg.exe -remote tcp:port=5005,server=192.168.1.180</p></li><li><p>以管道方式：<br>以命令行的方式启动服务器中的 windbg，如：windbg -server npipe:pipe=advdbg （adbdbg 为命名管道名称）。<br>在客户端中以命令行的方式启动 windbg，如：windbg -remote npipe:server=REMOTEHOSTNAME,pipe=advdbg （REMOTEHOSTNAME 为远程主机名，dbvdbg 为远程主机创建的命名管道名，也可以选择 File 菜单中的 Connect to Remote Session,在弹出来的编辑框中输入远程参数 npipe:server=REMOTEHOSTNAME,pipe=advdbg）</p></li></ul><p>成功连接后，命令行信息区会显示类似如下信息：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...(npipe advdbg) connected at Thu Jul 11 14:22:02 2017</span><br></pre></td></tr></tbody></table></figure><p>之后可以在客户端或者服务器的 windbg 中执行各种调试命令，执行结果会同时显示在两个调试器中。</p><p>其它的远程调试方案，可以参考:<br><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/remode-debugging-using-windbg">https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/remode-debugging-using-windbg</a></p>]]></content>
      
      
      <categories>
          
          <category> ⑦ 软件调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《打包狂魔之NSIS教程》</title>
      <link href="/post/4015642655.html"/>
      <url>/post/4015642655.html</url>
      
        <content type="html"><![CDATA[<p>NSIS 是 Windows 平台的安装包制作脚本，越来越多的互联网公司选择使用它来制作安装包，它开源免费且功能强大。该教程提供 NSIS 安装包制作的一站式解决方案。</p><span id="more"></span><p>专栏文章列表：</p><ul><li><a href="/post/409779091.html" title="NSIS教程(1)-基础语法">NSIS教程(1)-基础语法</a></li><li><a href="/post/1923360270.html" title="NSIS教程(2)-完整属性">NSIS教程(2)-完整属性</a></li><li><a href="/post/2673115526.html" title="NSIS教程(3)-完整指令">NSIS教程(3)-完整指令</a></li><li><a href="/post/275632694.html" title="NSIS教程(4)-传统界面示例">NSIS教程(4)-传统界面示例</a></li><li><a href="/post/3798382521.html" title="NSIS教程(5)-现代界面示例">NSIS教程(5)-现代界面示例</a></li><li><a href="/post/4172083706.html" title="NSIS教程(6)-静默安装">NSIS教程(6)-静默安装</a></li><li><a href="/post/3031217406.html" title="NSIS教程(7)-插件使用">NSIS教程(7)-插件使用</a></li><li><a href="/post/1273492093.html" title="NSIS教程(8)-插件开发">NSIS教程(8)-插件开发</a></li><li><a href="/post/100006247.html" title="NSIS教程(9)-使用界面库制作安装界面">NSIS教程(9)-使用界面库制作安装界面</a></li><li><a href="/post/1597634702.html" title="NSIS教程(10)-MUI跳过指定安装步骤">NSIS教程(10)-MUI跳过指定安装步骤</a></li><li><a href="/post/2948643539.html" title="NSIS教程(11)-中文手册">NSIS教程(11)-中文手册</a></li><li><a href="/post/2584392152.html" title="NSIS教程(12)-开源UI插件">NSIS教程(12)-开源UI插件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 打包狂魔之NSIS教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解C++虚函数</title>
      <link href="/post/3162890435.html"/>
      <url>/post/3162890435.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍 C++虚函数的底层实现，虚析构函数的作用，虚函数表的数据结构及存储方式，以及__declspec(novtable)的作用。</p><span id="more"></span><h1 id="一-虚函数介绍"><a href="#一-虚函数介绍" class="headerlink" title="一. 虚函数介绍"></a>一. 虚函数介绍</h1><p>C++中的虚函数主要是用来实现多态（面向对象的三大特性之一）的。<br>下面是一个实现多态的<strong>错误</strong>例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>() {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Call Base::Base()\n"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Base</span>() {</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Name</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Call Base::Name()\n"</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Derive</span>() {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Call Derive::Derive()\n"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Derive</span>() {</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Name</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Call Derive::Name()\n"</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  Base* pBase = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">  pBase-&gt;<span class="built_in">Name</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> pBase;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序输出：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Call Base::Base()</span><br><span class="line">Call Derive::Derive()</span><br><span class="line">Call Base::Name()</span><br></pre></td></tr></tbody></table></figure><p>输出内容的第 3 行为：<code>Call Base::Name()</code>，并不是期望的<code>Call Derive::Name()</code>。<br>因为<code>void Name()</code>函数不是虚函数，所以<code>pBase-&gt;Name()</code>调用的是基类的 Name()函数，并不是我们所期望的派生类 Derive 的 Name()函数。 如果将基类中<code>void Name()</code>改成虚函数<code>virtual void Name()</code>，程序输出就会和我们期望的一样：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>() {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Call Base::Base()\n"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Base</span>() {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Call Base::~Base()\n"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Name</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Call Base::Name()\n"</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h1 id="二、-虚析构函数"><a href="#二、-虚析构函数" class="headerlink" title="二、 虚析构函数"></a>二、 虚析构函数</h1><p><code>virtual</code>不仅可以修饰成员函数，也可以用来修饰析构函数，也就是我们常说的<code>虚析构函数</code>。 下面的例子中的基类的析构函数没有使用 virtual 修饰，我们先执行程序，观察运行结果（类似上面的程序，只是在析构函数中多加入了输出打印语句）。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>() {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Call Base::Base()\n"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Base</span>() {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Call Base::~Base()\n"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Name</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Call Base::Name()\n"</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Derive</span>() {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Call Derive::Derive()\n"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Derive</span>() {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Call Derive::~Derive()\n"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Name</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Call Derive::Name()\n"</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  Base* pBase = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">  pBase-&gt;<span class="built_in">Name</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> pBase;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序输出：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Call Base::Base()</span><br><span class="line">Call Derive::Derive()</span><br><span class="line">Call Derive::Name()</span><br><span class="line">Call Base::~Base()</span><br></pre></td></tr></tbody></table></figure><p>从输出内容的第 4 行可以看到，执行<code>delete pBase</code>语句只有基类 Base 类的析构函数被调用了，而派生类 Derive 的析构函数却没有被调用。如果此时派生类 Derive 中有需要在析构函数执行的代码（如内存释放，句柄关闭等），这些代码将不会执行，有可能就会造成内存泄漏、句柄泄漏、逻辑错误等问题。</p><p>正确的做法是：<strong>使用 virtual 修饰基类的析构函数</strong>，即虚析构函数。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>() {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Call Base::Base()\n"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Call Base::~Base()\n"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Name</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Call Base::Name()\n"</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>此时程序输出为：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Call Base::Base()</span><br><span class="line">Call Derive::Derive()</span><br><span class="line">Call Derive::Name()</span><br><span class="line">Call Derive::~Derive()</span><br><span class="line">Call Base::~Base()</span><br></pre></td></tr></tbody></table></figure><p>调用<code>delete pBase</code>之后，先执行了派生类 Derive 的析构函数，然后执行基类 Base 的析构函数。</p><blockquote><p>在《C++API 设计》一书中有明确的说到：“如果希望一个类可以被继承，那么就应该将它的析构函数使用 virtual 修饰；反过来可以理解为，如果一个类的析构函数不是虚的，那么这个类是被设计为不可继承的。”</p></blockquote><h1 id="三、虚函数的实现原理"><a href="#三、虚函数的实现原理" class="headerlink" title="三、虚函数的实现原理"></a>三、虚函数的实现原理</h1><h2 id="3-1-实现原理"><a href="#3-1-实现原理" class="headerlink" title="3.1 实现原理"></a>3.1 实现原理</h2><p>C++的虚函数是使用虚函数表（即<code>指针数组</code>，也就是<code>指针的指针</code>）来实现的。 只要在类中声明了虚函数，编译器就会在类的对象中自动生成一个虚函数表，但一个<strong>对象</strong>最多只有一个虚函数表，不管这个类声明了多少个虚函数。虚函数表是针对于类的对象的。</p><h2 id="3-2-虚函数表（指针）存储位置"><a href="#3-2-虚函数表（指针）存储位置" class="headerlink" title="3.2 虚函数表（指针）存储位置"></a>3.2 虚函数表（指针）存储位置</h2><p>不同的编译器将自动生成的虚函数表指针存放的位置不同，有的存放在类对象所占内存的起始位置，有的存放在类对象所占内存的末尾。 可以通过如下代码来判断：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值： ture  - 虚函数指针存放在对象内存起始位置</span></span><br><span class="line"><span class="comment">//         false - 虚函数指针存放在对象内存末尾位置</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">VirtualTableAtFirst</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">_C</span> {</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> _i;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _f() {</span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  _C c;</span><br><span class="line">  <span class="type">char</span> * p1 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;c);</span><br><span class="line">  <span class="type">char</span> * p2 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;c._i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p1 != p2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过 MSVC2015 编译运行，返回<code>true</code>, 说明 MSVC 编译器是将虚函数表指针放置在类对象内存的起始位置处。</p><h2 id="3-3-虚函数表存储方式"><a href="#3-3-虚函数表存储方式" class="headerlink" title="3.3 虚函数表存储方式"></a>3.3 虚函数表存储方式</h2><p>既然知道了 C++是使用虚函数表的形式来实现虚函数的，那个虚函数表中的数据是以何种形式来存储的了？ 现在我们根据类的继承方式的不同来分别说明。</p><h3 id="3-3-1-单继承无重载"><a href="#3-3-1-单继承无重载" class="headerlink" title="3.3.1 单继承无重载"></a>3.3.1 单继承无重载</h3><p>类结构如图，Derive 继承于 Base，但 Derive 没有重载 Base 类中的任何函数。</p><blockquote><blockquote><p>需要说明的是，函数 f(), g(), h(), f1(), g1(), h1() 均为虚函数，这个在图上没有明确的写出来，后面的图也是一样。</p></blockquote></blockquote><p><img src="https://blog-static.jiangxueqiao.com/blog/img/cpp-virtual-table-1.jpg"></p><p>这时<code>Base b;</code> 对象 b 的虚函数表为：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/cpp-virtual-table-2.jpg"></p><p><code>Derive d;</code> 对象 d 的虚函数表为：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/cpp-virtual-table-3.jpg"></p><h3 id="3-3-2-单继承有重载"><a href="#3-3-2-单继承有重载" class="headerlink" title="3.3.2 单继承有重载"></a>3.3.2 单继承有重载</h3><p>Derive 重载 Base 类中的 f()函数：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/cpp-virtual-table-4.jpg"></p><p>这时<code>Base b;</code> 对象 b 的虚函数表不变，无论继承于它派生类如何重载，都不会影响基类的虚函数：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/cpp-virtual-table-5.jpg"></p><p><code>Derive d;</code> 对象 d 的虚函数表为：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/cpp-virtual-table-6.jpg"></p><p>派生类中重载基类的 f()函数指针替换了原来基类中虚函数 Base::f()的指针； 派生类中其他的虚函数存放在基类虚函数之后。</p><h3 id="3-3-3-多继承无重载"><a href="#3-3-3-多继承无重载" class="headerlink" title="3.3.3 多继承无重载"></a>3.3.3 多继承无重载</h3><p><img src="https://blog-static.jiangxueqiao.com/blog/img/cpp-virtual-table-7.jpg"></p><p>此时，<code>Derive d;</code> 对象 d 的虚函数表为：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/cpp-virtual-table-8.jpg"></p><p><strong><code>派生类自己的虚函数存放在第一个基类的虚函数表的最后面。</code></strong></p><h3 id="3-3-4-多继承有重载"><a href="#3-3-4-多继承有重载" class="headerlink" title="3.3.4 多继承有重载"></a>3.3.4 多继承有重载</h3><p><img src="https://blog-static.jiangxueqiao.com/blog/img/cpp-virtual-table-9.jpg"></p><p>此时，<code>Derive d;</code> 对象 d 的虚函数表为：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/cpp-virtual-table-10.jpg"></p><h1 id="四、虚函数表的应用"><a href="#四、虚函数表的应用" class="headerlink" title="四、虚函数表的应用"></a>四、虚函数表的应用</h1><p>我们知道在 C++中要调用类的私有方法，我们可以使用友员（<code>friend</code>）的方式。但其实如果我们知道类的定义，完全可以根据该类对象的内存布局来直接调用它的私有函数。</p><p>下面介绍如何使用<code>虚函数表</code>的方式来调用该类的<code>私有虚函数</code>。</p><p>现有如下<code>Test</code>类，提供了一个私有虚函数<code>virtual void Func()</code>：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test</span>() {</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span>~ <span class="built_in">Test</span>() {</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Private Function\n"</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>现在我们使用虚函数表来调用<code>Func</code>成员函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*PFN_Func)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  Test t;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> **VirtualTable = (<span class="type">unsigned</span> <span class="type">long</span> **)(&amp;t);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> FuncAddr = VirtualTable[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  PFN_Func pfnFunc = (PFN_Func)FuncAddr;</span><br><span class="line">  <span class="keyword">if</span> (pfnFunc) {</span><br><span class="line">    <span class="built_in">pfnFunc</span>();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们知道虚函数表其实就是一个二维数组。因为示例中的<code>Test</code>类没有继承于其他类，所以第一维只有一个元素；又因<code>Test</code>类有 2 个虚函数，故第二维有 2 个元素，且<code>Func</code>排在第二个，所以用<code>VirtualTable[0][1]</code>来取<code>Func</code>函数地址。</p><p>因为该示例运行在 MSVC 编译器环境，所以默认认为虚函数表位于类对象内存布局的起始位置，故直接使用了<code>unsigned long **VirtualTable = (unsigned long **)(&amp;t);</code>。<br>严谨的做法应该是先判断虚函数表是否位于对象的内存布局起始位置。</p><h1 id="五、-declspec-novtable"><a href="#五、-declspec-novtable" class="headerlink" title="五、__declspec(novtable)"></a>五、__declspec(novtable)</h1><p>Mircrosoft C++中提供了<code>__declspec(novtable)</code>来修饰类，<code>__declspec(novtable)</code>会阻止编译器为该类生成虚函数表，这样可以减少编译生成代码的大小，同时也约束该类无法被实例化。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// novtable.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__declspec</span>(novtable) X {</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> : <span class="keyword">public</span> X {</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="built_in">printf_s</span>(<span class="string">"In Y\n"</span>);</span><br><span class="line">   }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="comment">// X *pX = new X();</span></span><br><span class="line">   <span class="comment">// pX-&gt;mf();   // 导致运行时访问冲突</span></span><br><span class="line"></span><br><span class="line">   Y *pY = <span class="keyword">new</span> <span class="built_in">Y</span>();</span><br><span class="line">   pY-&gt;<span class="built_in">mf</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《Windows核心编程》</title>
      <link href="/post/1395226543.html"/>
      <url>/post/1395226543.html</url>
      
        <content type="html"><![CDATA[<p>本栏目主要介绍与 Windows 系统编程相关的技术。</p><span id="more"></span><p>文章列表：</p><ul><li><a href="/post/50218900.html" title="了解DPI缩放">了解DPI缩放</a></li><li><a href="/post/782629701.html" title="理解C/C++运行时库">理解C/C++运行时库</a></li><li><a href="/post/2701401097.html" title="Windows用户界面特权隔离(UIPI)">Windows用户界面特权隔离(UIPI)</a></li><li><a href="/post/14744864.html" title="Windows内核对象">Windows内核对象</a></li><li><a href="/post/2648186181.html" title="Windows平台生成Dump文件">Windows平台生成Dump文件</a></li><li><a href="/post/1343547595.html" title="Windows注册URL协议">Windows注册URL协议</a></li><li><a href="/post/3102005562.html" title="Windows程序如何删除自身">Windows程序如何删除自身</a></li><li><a href="/post/3666245140.html" title="C++获取其他Windows进程命令行">C++获取其他Windows进程命令行</a></li><li><a href="/post/434128163.html" title="Windows实现文件强制占用">Windows实现文件强制占用</a></li><li><a href="/post/2236960039.html" title="Windows音频环回录制">Windows音频环回录制</a></li><li><a href="/post/1955778079.html" title="窗口无法接收WM_LBUTTONDBLCLK消息">窗口无法接收WM_LBUTTONDBLCLK消息</a></li><li><a href="/post/3906615635.html" title="由HANDLE返回值不确定性引发的思考">由HANDLE返回值不确定性引发的思考</a></li><li><a href="/post/3832058229.html" title="为什么SetParent会失败">为什么SetParent会失败</a></li><li><a href="/post/2510508225.html" title="Windows API的不同返回状态">Windows API的不同返回状态</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>以管理员权限运行批处理脚本</title>
      <link href="/post/3405299964.html"/>
      <url>/post/3405299964.html</url>
      
        <content type="html"><![CDATA[<p>基本原理：</p><ul><li>根据 系统自带的cacls.exe 是否能够访问”%SystemDrive%\System Volume Information”文件，来判断当前批处理进程是否具有管理员权限。</li><li>创建 vbs 脚本到临时目录，然后使用该脚本提权执行当前 bat 文件。</li></ul><span id="more"></span><p>下面是批处理模板，在最后追加需要执行的脚本即可。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">cd</span> /d <span class="string">"%~dp0"</span></span><br><span class="line">cacls.exe <span class="string">"%SystemDrive%\System Volume Information"</span> &gt;nul 2&gt;nul</span><br><span class="line"><span class="keyword">if</span> %errorlevel%==0 goto Admin</span><br><span class="line"><span class="keyword">if</span> exist <span class="string">"%temp%\getadmin.vbs"</span> del /f /q <span class="string">"%temp%\getadmin.vbs"</span></span><br><span class="line"><span class="built_in">echo</span> Set RequestUAC = CreateObject^(<span class="string">"Shell.Application"</span>^)&gt;<span class="string">"%temp%\getadmin.vbs"</span></span><br><span class="line"><span class="built_in">echo</span> RequestUAC.ShellExecute <span class="string">"%~s0"</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">"runas"</span>,1 &gt;&gt;<span class="string">"%temp%\getadmin.vbs"</span></span><br><span class="line"><span class="built_in">echo</span> WScript.Quit &gt;&gt;<span class="string">"%temp%\getadmin.vbs"</span></span><br><span class="line"><span class="string">"%temp%\getadmin.vbs"</span> /f</span><br><span class="line"><span class="keyword">if</span> exist <span class="string">"%temp%\getadmin.vbs"</span> del /f /q <span class="string">"%temp%\getadmin.vbs"</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">:Admin</span><br><span class="line"></span><br><span class="line">rem ---------- Here is the script to be run ------------</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑩ 编程基础 </category>
          
          <category> 批处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高速文件下载器的实现</title>
      <link href="/post/3157704992.html"/>
      <url>/post/3157704992.html</url>
      
        <content type="html"><![CDATA[<p>我们下载文件时通常会使用浏览器或者迅雷这样的下载工具，这些工具大多具有高速下载（下载速度快）、断点续传（可以暂停之后继续下载）等特性。</p><p>现在我们自己开发的应用软件中也需要支持这些特性，我们该如何设计和实现了？本文主要围绕这一问题进行论述，并在文章最后分享了作者自己开发的高速文件下载库。</p><span id="more"></span><p>一个完善的文件下载库需要具有如下特性：</p><ol><li>多线程分片下载</li><li>断点续传</li><li>磁盘缓存</li><li>最高下载速率限制及实时下载速率反馈（可选）</li><li>多协议支持，跨平台（可选）</li></ol><h1 id="1-多线程分片下载"><a href="#1-多线程分片下载" class="headerlink" title="1. 多线程分片下载"></a>1. 多线程分片下载</h1><p>Chrome 浏览器和迅雷能实现高速下载的核心就是多线程分片下载（这里忽略迅雷的离线加速等技术），以 HTTP 协议为例，HTTP 协议支持在请求头中指明需要请求数据的<code>起始</code>和<code>结束</code>位置。我们可以开启多个线程同时进行不同的 HTTP 请求，这些请求分别请求同一文件的不同位置，我们将每个 HTTP 请求的内容称为<code>“片”</code>，在文件的所有片下载完成之后，我们再进行片的合并。</p><p>libcurl 中可以通过如下方式指定请求文件的某一区域：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">curl_easy_setopt</span>(curl_, CURLOPT_RANGE, <span class="string">"1024-2048"</span>);</span><br></pre></td></tr></tbody></table></figure><p>如何确定分片数量以及每片大小？文件分片有 2 种策略：</p><ol><li>分片数量固定<br>除最后一片外，<code>每片的Size</code> = <code>文件总Size</code> / <code>分片Num</code></li><li>分片尺寸固定<br><code>分片Num</code> = <code>文件总Size</code> / <code>每片的Size</code>，如果不能整除，还需要新建一个分片，将余数放到该分片中</li></ol><p>无论采用哪一种分片策略，在确定分片 Num 和每片 Size 之前，我们都需要先向文件服务器发起一个请求来获取原始文件总 Size。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/file-download-1.png"></p><h1 id="2-断点续传"><a href="#2-断点续传" class="headerlink" title="2. 断点续传"></a>2. 断点续传</h1><p>试想我们正在下载一个 4G 大小的文件，下载到一半的时候，忽然因为某些原因需要中止下载，等可以再次下载的时候，却不能继续上次的下载进度进行下载，那岂不是让人很抓狂。断点续传功能就是来解决这种问题的，虽然目前市场上的下载器都支持这些功能，但我们需要自己开发下载器的话，还是不得不自己来实现这个功能的。</p><p>断点续传原理主要是将已下载的数据信息（偏移、大小等）记录到某个文件中（我们称之为索引文件），下次下载前读取该文件中已下载信息，跳过已下载的内容，直接下载未下载的数据。</p><p>断点续传一般都会和多线程分片下载结合使用。</p><h1 id="3-磁盘缓存"><a href="#3-磁盘缓存" class="headerlink" title="3. 磁盘缓存"></a>3. 磁盘缓存</h1><p>文件下载中涉及的磁盘缓存都是磁盘的写缓存，主要是为了避免频繁的对磁盘进行写操作，降低磁盘 IO 的效率。</p><p>原理：将网络下载数据存入预先分配好的内存缓冲区，待内存缓冲区满之后，再一次性写入磁盘。</p><p>关于内存缓冲区，建议采用双缓冲机制，因为磁盘写入操作是一个相对耗时的操作，在将缓冲区写入磁盘时，该缓冲区是禁止写入的，因而此时网络下载的数据写入缓冲区将被阻塞，从而影响下载速率。</p><h1 id="4-限速及实时速率"><a href="#4-限速及实时速率" class="headerlink" title="4. 限速及实时速率"></a>4. 限速及实时速率</h1><p>最高下载速率限制有助于减少用户电脑带宽占用，而实时下载速率反馈可以让用户看到实时的下载速度。</p><p>因为采用的是多线程下载，假如最高下载速率限制为 N，则每个线程的最大下载速率为: <code>N / 线程Num</code>，但需要注意的是，如果当前活跃的线程数少于初始线程数时（如有的线程已经下载完了），需要重新计算每个线程的最大下载速率，否则总下载速率将会下载，无法达到最高下载速率。</p><h1 id="zoe介绍"><a href="#zoe介绍" class="headerlink" title="zoe介绍"></a>zoe介绍</h1><p><a href="https://github.com/winsoft666/zoe">zoe</a> 是我开发的一个文件下载库，支持如上所有特性的开源库，采用 C++开发。该库已经在多个产品中使用，其稳定性得到了验证。</p><blockquote><p>该库原名为<code>teemo</code>，teemo一词来源于英雄联盟游戏中的迅捷斥候，由于该库被灰产非法使用，导致代码被杀毒软件加入特征库，我闭源了原库，在修改代码后重新开源。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ③ Power By Me </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows平台生成Dump文件</title>
      <link href="/post/2648186181.html"/>
      <url>/post/2648186181.html</url>
      
        <content type="html"><![CDATA[<p>转储文件也就是我们常说的 dump 文件，可以把转储文件看成软件的某个时刻的一个快照，我们一般在软件出现问题时手动生成或者程序自动生成转储文件。</p><span id="more"></span><h1 id="一、工具篇"><a href="#一、工具篇" class="headerlink" title="一、工具篇"></a>一、工具篇</h1><p>下面我们介绍几种借助第三方工具生成转储文件的方法。</p><h2 id="1-1-任务管理器"><a href="#1-1-任务管理器" class="headerlink" title="1.1 任务管理器"></a>1.1 任务管理器</h2><p>任务管理器可以说是最易获取的系统工具，同时它具有生成转储文件的功能。但要注意的是在 64 位操作系统上面，默认启动的是 64 位的任务管理器。使用任务管理器生成转储文件需要遵循一个原则：用 32 位任务管理器给 32 位进程（无论该进程是运行在 32 位还是 64 位系统上面）生成转储文件，用 64 位任务管理器给 64 位进程生成转储文件。</p><p>在 64 位系统上，32 位的任务管理器位于<code>C:\Windows\SysWOW64\taskmgr.exe</code>。</p><p>生成方法：右键进程 –&gt; 创建转储文件–&gt;弹出对话框提示生成成功，以及 dmp 文件位置。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-sc-dump-1.jpg"></p><p>类似的工具还有：Process Explorer，PCHunter 等。</p><h2 id="1-2-注册表"><a href="#1-2-注册表" class="headerlink" title="1.2 注册表"></a>1.2 注册表</h2><p>可以通过在注册表中进行配置，让操作系统在程序崩溃时自动生成 dmp 文件，并放到指定位置。<br>在注册表项 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting\LocalDumps 下面根据进程名（含.exe）新建子项，并配置如下值：<br>名称：DumpCount，类型：REG_DWORD，最大保留 Dump 个数，默认为 10.<br>名称：DumpType，类型：REG_DWORD，Dump 类型(1-Mini dump, 2-Full dump)，默认为 1.<br>名称：DumpFolder，类型：REG_EXPAND_SZ，Dump 文件保存的位置。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-sc-dump-2.jpg"></p><h2 id="1-3-Windbg"><a href="#1-3-Windbg" class="headerlink" title="1.3 Windbg"></a>1.3 Windbg</h2><p>生成方法：File 菜单–&gt;Attach to Process–&gt;输入命令<code>.dump /ma /u d:\test.dmp</code><br>提示成功之后，可以在 D 盘看到生成 dmp 文件到 test_0bf0_2017-08-13_23-46-37-244_11cc.dmp 文件。</p><p>0bf0_2017-08-13_23-46-37-244_11cc 是/u 参数附加上去的，意思是 2017 年 08 月 13 日 23 时 46 分 37 秒 244 毫秒，进程 PID 位 11cc。</p><p>.dump 命令参数比较多，常用的组合就是<code>/ma</code>，/m 表示生成 minidump，/a 表示 dmp 包含所有信息，/u 参数就是上面说的附加时间和 PID 信息到文件名。</p><h2 id="1-4-Windbg-I"><a href="#1-4-Windbg-I" class="headerlink" title="1.4 Windbg -I"></a>1.4 Windbg -I</h2><p>Windbg -I&nbsp; 可以将 Windbg 设置为及时调试器（开启了 UAC 的系统上面，需要以管理员权限运行），也就是我们常说的 JIT 调试器。设置成功之后，如遇到程序崩溃，Windbg 会自动运行并附加到崩溃进程。</p><p>设置成功之后会弹出对话框提示设置成功。如果不想弹出对话框，可以加上 S（slient 首字母）Windbg -IS.</p><p>也可以通过修改注册表项 AeDebug 来实现和 windbg -I 同样的功能。<br>根据 windbg 位数（32/64）和系统的位数（32/64）的不同，修改的注册表项的位置也不同：</p><ul><li>32 位 windbg–32 位系统：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug</li><li>32 位 windbg–64 位系统：HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\AeDebug</li><li>64 位 windbg–64 位系统：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug</li></ul><p>AeDebug 项下面有 2 个值：<br>名称：Auto，类型：REG_SZ，0 表示出现崩溃弹出对话框，让用户选择关闭程序还是调试程序；1 表示自动弹出设置调试器。<br>名称：Debugger，类型：REG_SZ，调试器值。默认为”C:\WINDOWS\system32\vsjitdebugger.exe” -p %ld -e %ld，设置为 windbg 需更改为”C:\Debuggers\WinDbg\x86\windbg.exe” -p %ld -e %ld -g</p><p>看起来挺复杂，其实挺好理解的。</p><h2 id="1-5-Adplus"><a href="#1-5-Adplus" class="headerlink" title="1.5 Adplus"></a>1.5 Adplus</h2><p>adplus 工具位于 windbg 安装目录，最早叫 adplus.vbs，以 VBScript 脚本提供，最新版改成了 adplus.exe。adplus.exe 不仅可以在程序崩溃时手动运行来生成 dmp 文件，也可以在崩溃之前就运行它，当程序崩溃时它会自动生成 dmp 文件；甚至可以在程序没有运行之前就先运行 adplus，当程序崩溃时它会自动生成 dmp 文件。<br>如：adplus -pn powerpnt.exe -pn wincmd32.exe -hang -o c:\test</p><p>Adplus 用法：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADPlus &lt;RunMode&gt; -o &lt;OutputDirectory&gt; [Options]</span><br><span class="line">RunMode：-hang或-crash</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-hang&nbsp;附加到进程，生成dmp，然后解除附加(detach)。多用于程序卡死的情况下。</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-crash&nbsp;附加到进程，直到程序崩溃或者其他事件发生，生成dmp文件，然后解除附加。</span><br></pre></td></tr></tbody></table></figure><p>常用参数：</p><ul><li><p>-o 目录<br>指定生成文件存储目录。</p></li><li><p>-p 进程 ID<br>指定进程 ID，可以同时使用多次-p 来指定多个进程。</p></li><li><p>-pn 进程名<br>指定进程名，支持通配符，也可以同时使用多次-pn 来指定多个进程，但进程名必须存在，不存在则失败。</p></li><li><p>-po 进程名<br>和-pn 类似，但-po 不要求进程名必须存在。可以在进程启动之前就先启动 Adplus.</p></li><li><p>-pmn 进程名<br>pmn 为 Process Monitor 缩写。顾名思义，可以监视进程列表，一旦指定进程运行，则附加上去。只适用于-crash&nbsp; 模式。</p></li></ul><p>​# 二、代码篇<br>使用代码生成dump文件的原理大致是：</p><ol><li>捕获异常，如<code>SetUnhandledExceptionFilter</code>、<code>__try...__except</code>。</li><li>使用MiniDumpWriteDump写入dump到文件。</li></ol><p>为了便于使用，我封装了一个捕获异常并写入dump的辅助，具体如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EasyDump.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cpp4j {</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_EXCEPTION_POINTERS</span> EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> __cdecl <span class="title">RecordExceptionInfo</span><span class="params">(PEXCEPTION_POINTERS pExceptPtrs, <span class="type">const</span> TCHAR *szDumpNamePrefix)</span></span>;</span><br><span class="line">  <span class="function">TCHAR *<span class="title">lstrrchr</span><span class="params">(LPCTSTR string, <span class="type">int</span> ch)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DumpMiniDump</span><span class="params">(HANDLE hFile, PEXCEPTION_POINTERS excpInfo)</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINMAIN_BEGIN(szDumpNamePrefix) \</span></span><br><span class="line"><span class="meta">    int __96A9695E_RUN_WINMAIN_FUNC(HINSTANCE hInstance, LPTSTR lpCmdLine);\</span></span><br><span class="line"><span class="meta">    LONG WINAPI __96A9695E_UnhandledExceptionHandler( _EXCEPTION_POINTERS *pExceptionInfo ) \</span></span><br><span class="line"><span class="meta">    { \</span></span><br><span class="line"><span class="meta">        OutputDebugString(TEXT(<span class="string">"Create a dump file sine an exception occurred in sub-thread.\n"</span>)); \</span></span><br><span class="line"><span class="meta">        int iRet = cpp4j::RecordExceptionInfo(pExceptionInfo, szDumpNamePrefix); \</span></span><br><span class="line"><span class="meta">        return iRet; \</span></span><br><span class="line"><span class="meta">    } \</span></span><br><span class="line"><span class="meta">    int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow) \</span></span><br><span class="line"><span class="meta">    { \</span></span><br><span class="line"><span class="meta">        UNREFERENCED_PARAMETER(hPrevInstance); \</span></span><br><span class="line"><span class="meta">        UNREFERENCED_PARAMETER(nCmdShow); \</span></span><br><span class="line"><span class="meta">        ::SetUnhandledExceptionFilter( __96A9695E_UnhandledExceptionHandler );\</span></span><br><span class="line"><span class="meta">        int ret = 0;\</span></span><br><span class="line"><span class="meta">        __try\</span></span><br><span class="line"><span class="meta">        {\</span></span><br><span class="line"><span class="meta">            ret = __96A9695E_RUN_WINMAIN_FUNC(hInstance, lpCmdLine);\</span></span><br><span class="line"><span class="meta">        }\</span></span><br><span class="line"><span class="meta">        __except(cpp4j::RecordExceptionInfo(GetExceptionInformation(), szDumpNamePrefix))\</span></span><br><span class="line"><span class="meta">        {\</span></span><br><span class="line"><span class="meta">            OutputDebugString(TEXT(<span class="string">"Create a dump file sine an exception occurred in main-thread.\n"</span>)); \</span></span><br><span class="line"><span class="meta">        }\</span></span><br><span class="line"><span class="meta">        return ret;\</span></span><br><span class="line"><span class="meta">    }\</span></span><br><span class="line"><span class="meta">    int __96A9695E_RUN_WINMAIN_FUNC(HINSTANCE hInstance, LPTSTR lpCmdLine) \</span></span><br><span class="line"><span class="meta">    {</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINMAIN_END }</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_BEGIN(szDumpName) \</span></span><br><span class="line"><span class="meta">    int __96A9695E_RUN_MAIN_FUNC(int argc, _TCHAR* argv[]);\</span></span><br><span class="line"><span class="meta">    LONG WINAPI __96A9695E_UnhandledExceptionHandler( _EXCEPTION_POINTERS *pExceptionInfo ) \</span></span><br><span class="line"><span class="meta">    { \</span></span><br><span class="line"><span class="meta">        OutputDebugString(TEXT(<span class="string">"Create a dump file since an exception occurred in sub-thread.\n"</span>)); \</span></span><br><span class="line"><span class="meta">        int iRet = cpp4j::RecordExceptionInfo(pExceptionInfo, szDumpName); \</span></span><br><span class="line"><span class="meta">        return iRet; \</span></span><br><span class="line"><span class="meta">    } \</span></span><br><span class="line"><span class="meta">    int _tmain(int argc, _TCHAR* argv[])\</span></span><br><span class="line"><span class="meta">    { \</span></span><br><span class="line"><span class="meta">        ::SetUnhandledExceptionFilter( __96A9695E_UnhandledExceptionHandler );\</span></span><br><span class="line"><span class="meta">        int ret = 0;\</span></span><br><span class="line"><span class="meta">        __try\</span></span><br><span class="line"><span class="meta">        {\</span></span><br><span class="line"><span class="meta">            ret = __96A9695E_RUN_MAIN_FUNC(argc, argv);\</span></span><br><span class="line"><span class="meta">        }\</span></span><br><span class="line"><span class="meta">        __except(cpp4j::RecordExceptionInfo(GetExceptionInformation(), szDumpName))\</span></span><br><span class="line"><span class="meta">        {\</span></span><br><span class="line"><span class="meta">            OutputDebugString(TEXT(<span class="string">"Create a dump file since an exception occurred in main-thread.\n"</span>)); \</span></span><br><span class="line"><span class="meta">        }\</span></span><br><span class="line"><span class="meta">        return ret;\</span></span><br><span class="line"><span class="meta">    }\</span></span><br><span class="line"><span class="meta">    int __96A9695E_RUN_MAIN_FUNC(int argc, _TCHAR* argv[]) \</span></span><br><span class="line"><span class="meta">    {</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_END }</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EasyDump.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"EasyDump.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;DbgHelp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Dbghelp.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cpp4j {</span><br><span class="line">  <span class="function">TCHAR *<span class="title">lstrrchr</span><span class="params">(LPCTSTR string, <span class="type">int</span> ch)</span> </span>{</span><br><span class="line">    TCHAR *start = (TCHAR *)string;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*string++)</span><br><span class="line">      ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--string != start &amp;&amp; *string != (TCHAR)ch)</span><br><span class="line">      ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*string == (TCHAR)ch)</span><br><span class="line">      <span class="keyword">return</span> (TCHAR *)string;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">DumpMiniDump</span><span class="params">(HANDLE hFile, PEXCEPTION_POINTERS excpInfo)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!excpInfo) {</span><br><span class="line">      <span class="type">static</span> <span class="type">int</span> iTimes = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (iTimes++ &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      __try {</span><br><span class="line">        <span class="built_in">RaiseException</span>(EXCEPTION_BREAKPOINT, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">      }</span><br><span class="line">      __except (<span class="built_in">DumpMiniDump</span>(hFile, <span class="built_in">GetExceptionInformation</span>()),</span><br><span class="line">        EXCEPTION_CONTINUE_EXECUTION) {</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">      MINIDUMP_EXCEPTION_INFORMATION eInfo;</span><br><span class="line">      eInfo.ThreadId = <span class="built_in">GetCurrentThreadId</span>();</span><br><span class="line">      eInfo.ExceptionPointers = excpInfo;</span><br><span class="line">      eInfo.ClientPointers = FALSE;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">MiniDumpWriteDump</span>(</span><br><span class="line">        <span class="built_in">GetCurrentProcess</span>(),</span><br><span class="line">        <span class="built_in">GetCurrentProcessId</span>(),</span><br><span class="line">        hFile,</span><br><span class="line">        MiniDumpNormal,</span><br><span class="line">        excpInfo ? &amp;eInfo : <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> __cdecl <span class="title">RecordExceptionInfo</span><span class="params">(PEXCEPTION_POINTERS pExceptPtrs, <span class="type">const</span> TCHAR *szDumpNamePrefix)</span> </span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> bFirstTime = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bFirstTime)</span><br><span class="line">      <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line"></span><br><span class="line">    bFirstTime = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dmp文件命名：前缀_年月日.时.分.秒.毫秒.dmp</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    TCHAR szLocalTime[<span class="number">50</span>] = { <span class="number">0</span> };</span><br><span class="line">    SYSTEMTIME st;</span><br><span class="line">    <span class="built_in">GetLocalTime</span>(&amp;st);</span><br><span class="line">    <span class="built_in">StringCchPrintf</span>(szLocalTime, <span class="number">50</span>, <span class="built_in">TEXT</span>(<span class="string">"%04d%02d%02d.%02d.%02d.%02d.%04d"</span>), st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);</span><br><span class="line"></span><br><span class="line">    TCHAR szExeDir[MAX_PATH + <span class="number">1</span>] = { <span class="number">0</span> };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>, szExeDir, MAX_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TCHAR *p = <span class="built_in">lstrrchr</span>(szExeDir, <span class="built_in">TEXT</span>(<span class="string">'\\'</span>))) {</span><br><span class="line">      *(p + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    TCHAR szDumpFileName[MAX_PATH + <span class="number">1</span>] = { <span class="number">0</span> };</span><br><span class="line">    _stprintf_s(szDumpFileName, MAX_PATH, <span class="built_in">TEXT</span>(<span class="string">"%s%s_%s.dmp"</span>), szExeDir, szDumpNamePrefix, szLocalTime);</span><br><span class="line"></span><br><span class="line">    HANDLE hMiniDumpFile = <span class="built_in">CreateFile</span>(</span><br><span class="line">      szDumpFileName,</span><br><span class="line">      GENERIC_WRITE,</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      <span class="literal">NULL</span>,</span><br><span class="line">      CREATE_ALWAYS,</span><br><span class="line">      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,</span><br><span class="line">      <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hMiniDumpFile != INVALID_HANDLE_VALUE) {</span><br><span class="line">      <span class="built_in">DumpMiniDump</span>(hMiniDumpFile, pExceptPtrs);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">CloseHandle</span>(hMiniDumpFile);</span><br><span class="line">      hMiniDumpFile = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>MAIN_BEGIN</code>和<code>WINMAIN_BEGIN</code>中的参数为生成的 dump 文件的前缀，dump 文件命名方式: <code>前缀*年月日.时.分.秒.毫秒.dmp</code>。</p><p>使用方法也很简单，使用<code>MAIN_BEGIN</code>替换<code>main</code>，<code>WINMAIN_BEGIN</code>替换<code>WinMain</code>即可：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"EasyDump.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MAIN_BEGIN</span>(<span class="built_in">TEXT</span>(<span class="string">"Test"</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;i;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">*p = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">MAIN_END</span><br></pre></td></tr></tbody></table></figure><p>上面的代码会在程序的当前目录生成一个名为 Test_20171101.14.49.57.0264.dmp 的 dump 文件。</p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一键启动神器之1key.run</title>
      <link href="/post/776574933.html"/>
      <url>/post/776574933.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://1key.run/">1key.run</a>既是产品官网，亦是产品名称。</p><p>顾名思义，主打一键启动，可以一键启动本地应用、网页搜索，并内置了一些实用功能如日历、科学计算、截图、Spy++等。</p><span id="more"></span><h1 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h1><p><img src="https://blog-static.jiangxueqiao.com/blog/img/1keyrun_logo.png"></p><ul><li><p>Github（更新及时）</p><p><a href="https://github.com/winsoft666/1key.run-Setup/releases">https://github.com/winsoft666/1key.run-Setup/releases</a></p></li><li><p>奶牛快传（更新可能延后）</p><p><a href="https://cowtransfer.com/s/cc2dec336b0b43">https://cowtransfer.com/s/cc2dec336b0b43</a></p></li></ul><h1 id="二、产品特色"><a href="#二、产品特色" class="headerlink" title="二、产品特色"></a>二、产品特色</h1><p>产品特色归纳为三个字：轻、快、爽。</p><h2 id="2-1-轻"><a href="#2-1-轻" class="headerlink" title="2.1 轻"></a>2.1 轻</h2><p>“轻”为轻量化。减少系统资源的占用，不采用臃肿的 Electron 或 CEF 等 Web 技术架构，所有功能都采用纯 C++ Native 开发。<br>软件安装包仅有 15MB（事实上还可以更小），运行时仅占用 12MB 内存。</p><h2 id="2-2-快"><a href="#2-2-快" class="headerlink" title="2.2 快"></a>2.2 快</h2><p>“快”为快速运行、快速上手。</p><p><strong>1. 输入本地应用的简写（如拼音首字母）可以快速启动该应用。</strong><br>输入<code>szqm</code>:<br><img src="https://blog-static.jiangxueqiao.com/blog/img/1keyrun-1.jpg"></p><p>默认会选中第一项，也可以使用<code>Alt + 数字</code>快捷键快速定位到其他项。</p><p>按<code>Enter</code>键运行当前项，还可以在右键菜单中可以选择<code>“以管理员权限运行”</code>。</p><p><strong>2. 输入数学表达式，可以快速的计算该表达式的结果。</strong></p><p>输入<code>sin(90)+cos(45)+(2+3)*4</code>：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/1keyrun-2.jpg"></p><p>科学计算器为 1key.run 的内置功能，在表达式计算结果项上按<code>Enter</code>键可以进入该功能详情页：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/1keyrun-3.jpg"></p><p>也可以输入<code>kxjsq</code>启动该功能，按<code>Esc</code>键可以退出当前功能。</p><p><strong>3. 剪切板检测</strong><br>当 1key.run 被唤起时，会自动检查剪切板中的数据是否可以被 1key.run 的某个功能模块所使用。如复制<code>sin(90)+cos(45)+(2+3)*4</code>到剪切板，使用快捷键<code>Alt+空格</code>唤起 1key.run，会自动显示计算结果。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/1keyrun-4.jpg"></p><p><strong>4. 快速上手</strong><br>想到则输入，所输即所得。不用记忆繁琐的快捷键，只需知道三个快捷键即可上手使用：</p><ul><li><code>Alt + 空格</code>唤起 1key.run</li><li><code>Enter</code>为执行当前选择项</li><li><code>Esc</code>为退出当前功能</li></ul><h2 id="2-3-爽"><a href="#2-3-爽" class="headerlink" title="2.3 爽"></a>2.3 爽</h2><p>完全免费，卸载无残留。</p><blockquote><p>免费版本和 Pro 版本仅在更新通道上有区别，Pro 版本可以使用稳定的更新通道。<br>在功能方面，免费版本和 Pro 版本没有任何区别。</p></blockquote><h1 id="三、功能介绍"><a href="#三、功能介绍" class="headerlink" title="三、功能介绍"></a>三、功能介绍</h1><p>1key.run 将功能划分成了不同的功能模块，包含如下功能模块：</p><ul><li>快速启动</li><li>网页搜索</li><li>科学计算器</li><li>颜色拾取</li><li>日历</li><li>截图</li><li>JSON 格式化</li><li>XML 格式化</li></ul><p>可以在 1key.run 主搜索框输入功能模块支持的数据来唤起该功能，如<code>1+2+3</code>为科学计算器支持的数据，<code>{"a":1}</code>为 JSON 格式化支持的数据。</p><p>也可以直接输入功能模块的触发关键字（可以在“设置”中自定义）来启动该功能，如输入<code>qs</code>触发颜色拾取功能等。</p><h2 id="3-1-快速启动"><a href="#3-1-快速启动" class="headerlink" title="3.1 快速启动"></a>3.1 快速启动</h2><p>快速启动可以用来启动本地应用，支持中文拼音简写、分词，如：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有道翻译 -&gt; ydfy</span><br><span class="line">Visual Studio Code -&gt; vsc</span><br><span class="line">WinHex -&gt; wh</span><br></pre></td></tr></tbody></table></figure><p>当搜索结果不足时，会自动添加网页搜索引擎到列表的末尾。</p><p>可以在“设置”中自定义需要检索和监控的文件夹，1key.run 会自动检索该文件夹及子文件夹下的可执行项(如.exe、.bat 文件)，并添加到快速启动中。</p><p>当文件夹中有文件新增或删除时，1key.run 会自动监控到这些改变，添加到启动项或从中移除。</p><p>如果某个目录下文件或子文件夹太多，检索和监控会消耗比较多的系统资源，可以在排除该目录。</p><p>最后，我们也可以添加单个启动项。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/1keyrun-5.jpg"></p><h2 id="3-2-网页搜索"><a href="#3-2-网页搜索" class="headerlink" title="3.2 网页搜索"></a>3.2 网页搜索</h2><p>1key.run 内置了百度、谷歌、必应、百度百科、Microsoft Docs、Github 等主流搜索引擎，输入对的引擎名或简写，可以快速定位到该搜索引擎。</p><p>如输入<code>baidu</code>并回车，定位并选择百度搜索引擎：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/1keyrun-6.jpg"></p><p>输入需要搜索的内容，回车即可搜索。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/1keyrun-7.jpg"></p><p>可以在“设置”中管理搜索引擎：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/1keyrun-8-TinyTu.png"></p><h2 id="3-3-科学计算器"><a href="#3-3-科学计算器" class="headerlink" title="3.3 科学计算器"></a>3.3 科学计算器</h2><p>提供传统科学计算器所拥有的全部功能，并且使用起来更加方便。</p><h2 id="3-4-颜色拾取"><a href="#3-4-颜色拾取" class="headerlink" title="3.4 颜色拾取"></a>3.4 颜色拾取</h2><p>实时提取鼠标位置的颜色值，实时显示 RGB 和十六进制颜色值。</p><p>与其他取色软件不同的是，1key.run 提供的颜色拾取功能支持通过方向键进行像素级的移动。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/1keyrun-9.jpg"></p><h2 id="3-5-日历"><a href="#3-5-日历" class="headerlink" title="3.5 日历"></a>3.5 日历</h2><p>传统日历系统通常只显示阴历的“日”，而不显示“月”，有时为了查看当前阴历的月份不得前后翻阅，非常不便。<br>1key.run 提供的轻量级的日历解决了上述问题，使用起来会更加方便，无需联网即可使用。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/1keyrun-11.jpg"></p><h2 id="3-6-截图"><a href="#3-6-截图" class="headerlink" title="3.6 截图"></a>3.6 截图</h2><p>1key.run 内置的截图功能，支持对窗口、矩形进行截图，实时显示截取区域坐标和尺寸。<br>输入<code>jt</code>可以唤起该功能，也可以在“设置”中自定义全局快捷键。</p><h2 id="3-7-JSON-格式化"><a href="#3-7-JSON-格式化" class="headerlink" title="3.7 JSON 格式化"></a>3.7 JSON 格式化</h2><p><img src="https://blog-static.jiangxueqiao.com/blog/img/1keyrun-12.jpg"></p><h2 id="3-8-XML-格式化"><a href="#3-8-XML-格式化" class="headerlink" title="3.8 XML 格式化"></a>3.8 XML 格式化</h2><p><img src="https://blog-static.jiangxueqiao.com/blog/img/1keyrun-13.jpg"></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>更多功能还在开发和完善中，该文档可能更新不及时。</p>]]></content>
      
      
      <categories>
          
          <category> ③ Power By Me </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从汇编的角度分析函数调用过程</title>
      <link href="/post/4168021185.html"/>
      <url>/post/4168021185.html</url>
      
        <content type="html"><![CDATA[<p>本文从汇编的视角分析了函数的调用方式，掌握该知识对使用 OllyDbg 等动态调试工具会大有裨益。</p><span id="more"></span><h2 id="一、-函数参数传递形式"><a href="#一、-函数参数传递形式" class="headerlink" title="一、 函数参数传递形式"></a>一、 函数参数传递形式</h2><p>函数的参数传递有 2 种方式：</p><ul><li>堆栈方式</li><li>寄存器方式</li></ul><p>如果是堆栈方式传递的，就需要定义函数参数在堆栈中的传递顺序，并约定函数被调用之后，由谁来平衡堆栈；<br>如果是寄存器方式传递的，就需要确定参数存放在哪个寄存器中。<br>每一种方式都有其优缺点，而且与使用的编程语言有关系。</p><p>我们在开发中经常遇到<code>调用约定类型</code>，如<code>__cdecl</code>、<code>stdcall</code>、<code>PASCAL</code>、<code>fastcall</code>，这些调用约定类型就用来指定函数参数的传递方式的。</p><p>上面几种约定类型，除了<code>fastcall</code>是使用寄存器方式传递参数外，其他的都是使用堆栈传递参数的。</p><blockquote><p>Visual Studio 中的 C++工程，可以<code>C++</code> –&gt; <code>高级</code> –&gt; <code>调用约定</code>中进行调用约定的设置：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/hbfxhsdy-1.png"></p></blockquote><h2 id="二、使用堆栈方式传递函数参数"><a href="#二、使用堆栈方式传递函数参数" class="headerlink" title="二、使用堆栈方式传递函数参数"></a>二、使用堆栈方式传递函数参数</h2><p>堆栈是一种“后进先出”的数据结构，<code>ESP</code>寄存器始终指向栈顶。栈中数据地址从底部到顶部依次减小，也就是说，栈底对应高地址，栈顶对应低地址。</p><p>调用函数时，调用者依次把参数压栈，然后调用函数，函数被调用之后，在堆栈中取得参数数据。函数调用结束以后，堆栈需要恢复到函数调用之前的样子，而到底是由调用者来恢复还是由函数自身来恢复，根据不同的调用约定类型采用不同的方式。</p><table><thead><tr><th>约定类型</th><th>__cdecl</th><th>stdcall</th><th>PASCAL</th><th>fastcall</th></tr></thead><tbody><tr><td><strong>参数传递顺序</strong></td><td>从右到左</td><td>从右到左</td><td>从左到右</td><td>使用寄存器</td></tr><tr><td><strong>堆栈平衡者</strong></td><td>调用者</td><td>函数自身</td><td>函数自身</td><td>函数自身</td></tr></tbody></table><p><code>__cdcel</code>是 C/C++/MFC 程序默认的调用约定。<br><code>stdcall</code>是绝大多数 Win32 API 函数的约定方式，也有少部分使用<code>__cdcel</code>约定方式（如 wsprintf 等）。<br>在 Windows C/C++开发中常用的就是<code>__cdecl</code>和<code>stdcall</code>这 2 种调用约定。</p><p>按照不同的<code>调用约定</code>来调用函数<code>int add(int a, int b)</code>。从调用者的视角来看，其汇编代码分别表示如下：</p><p><strong>__cdecl</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push b     ;参数按从右到左传递</span><br><span class="line">push a</span><br><span class="line">call add</span><br><span class="line">add esp, 8 ;调用者在函数外部平衡堆栈</span><br></pre></td></tr></tbody></table></figure><p><strong>stdcall</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push b     ;参数按从右到左传递</span><br><span class="line">push a</span><br><span class="line">call add   ;函数自己内部平衡堆栈，调用者不需要平衡堆栈</span><br></pre></td></tr></tbody></table></figure><p>在函数调用过程中，参数入栈的过程如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/hbfxhsdy-2.png"></p><p>上图中，<code>EBP</code>和<code>函数返回地址ret</code>都是 32 位地址。因为函数调用完之后会将<code>EBP</code>恢复为暂存在堆栈中的原<code>EBP</code>值，所以从调用者角度来看，在函数的一次调用过程中<code>EBP</code>是不会变化的。</p><p>我们可以在函数中通过新的<code>EBP</code>获取函数各个参数的值：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参数a = EBP + 0x8</span><br><span class="line">参数b = EBP + 0xC</span><br></pre></td></tr></tbody></table></figure><h2 id="三、调用过程分析"><a href="#三、调用过程分析" class="headerlink" title="三、调用过程分析"></a>三、调用过程分析</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">  <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  c = a + b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">int</span> r = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们使用<code>Visual Studio 2017</code>编译上面代码，并在在工程配置中将函数调用约定设置为<code>__cdecl</code>。</p><p>在程序调试过程中，可以在<code>Visual Studio</code>的<code>反汇编窗口</code>中看到 C++代码对应的汇编代码，以及<code>寄存器</code>窗口中看到各个寄存器的值。</p><p><code>main</code>函数的反汇编代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="number">00</span>DD1720  push        ebp          <span class="comment">// 参见add函数中关于这一部分的解析</span></span><br><span class="line"><span class="number">00</span>DD1721  mov         ebp,esp</span><br><span class="line"><span class="number">00</span>DD1723  sub         esp,<span class="number">0</span>CCh</span><br><span class="line"><span class="number">00</span>DD1729  push        ebx</span><br><span class="line"><span class="number">00</span>DD172A  push        esi</span><br><span class="line"><span class="number">00</span>DD172B  push        edi</span><br><span class="line"><span class="number">00</span>DD172C  lea         edi,[ebp<span class="number">-0</span>CCh]</span><br><span class="line"><span class="number">00</span>DD1732  mov         ecx,<span class="number">33</span>h</span><br><span class="line"><span class="number">00</span>DD1737  mov         eax,<span class="number">0</span>CCCCCCCCh</span><br><span class="line"><span class="number">00</span>DD173C  rep stos    dword ptr es:[edi]</span><br><span class="line">  <span class="type">int</span> r = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="number">00</span>DD173E  push        <span class="number">2</span>                 <span class="comment">// 参数b入栈</span></span><br><span class="line"><span class="number">00</span>DD1740  push        <span class="number">1</span>                 <span class="comment">// 参数a入栈</span></span><br><span class="line"><span class="number">00</span><span class="function">DD1742  call        <span class="title">add</span> <span class="params">(<span class="number">0</span>DD1276h)</span>    <span class="comment">// 调用add函数。CALL指令相当于执行一条PUSH指令加一条JMP指令，PUSH指令用于压入该指令的下一条指令地址到栈中，用于执行完子函数之后返回来。JMP指令用于跳转到子函数所在位置开始执行子函数。</span></span></span><br><span class="line"><span class="function">00DD1747  add         esp,8            <span class="comment">// 因为是__cdecl，所以由调用者来平衡堆栈.</span></span></span><br><span class="line"><span class="function">00DD174A  mov         dword ptr [r],eax</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> 0</span>;</span><br><span class="line"><span class="number">00</span>DD174D  <span class="keyword">xor</span>         eax,eax</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行进入<code>add</code>函数后，<code>add</code>函数内的汇编代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line"><span class="number">00</span>DD16D0  push        ebp      <span class="comment">// ebp入栈，相当于暂存ebp的值</span></span><br><span class="line"><span class="number">00</span>DD16D1  mov         ebp,esp  <span class="comment">// 将esp赋值给ebp，在该函数之后的执行过程中不会再改变ebp的值。</span></span><br><span class="line"><span class="number">00</span>DD16D3  sub         esp,<span class="number">0</span>CCh <span class="comment">// 在栈上分配0xCC大小的局部变量存储区域</span></span><br><span class="line"><span class="number">00</span>DD16D9  push        ebx      <span class="comment">// 暂存ebx</span></span><br><span class="line"><span class="number">00</span>DD16DA  push        esi      <span class="comment">// 暂存esi</span></span><br><span class="line"><span class="number">00</span>DD16DB  push        edi      <span class="comment">// 暂存edi</span></span><br><span class="line"><span class="number">00</span>DD16DC  lea         edi,[ebp<span class="number">-0</span>CCh]  <span class="comment">//下面4行代码（含该条）实现将0xCC大小的局部变量存储区域全部赋值为0xCC</span></span><br><span class="line"><span class="number">00</span>DD16E2  mov         ecx,<span class="number">33</span>h         <span class="comment">// ecx存储循环次数，结合rep指令使用。为什么是0x33次了？因为是按照4个字节赋值的，0x33 * 0x4 = 0xCC</span></span><br><span class="line"><span class="number">00</span>DD16E7  mov         eax,<span class="number">0</span>CCCCCCCCh</span><br><span class="line"><span class="number">00</span>DD16EC  rep stos    dword ptr es:[edi]  <span class="comment">// 循环赋值</span></span><br><span class="line">  <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="number">00</span>DD16EE  mov         dword ptr [c],<span class="number">0</span>     <span class="comment">// 将局部变量c赋值为0</span></span><br><span class="line"></span><br><span class="line">  c = a + b;</span><br><span class="line"><span class="number">00</span>DD16F5  mov         eax,dword ptr [a]</span><br><span class="line"><span class="number">00</span>DD16F8  add         eax,dword ptr [b]</span><br><span class="line"><span class="number">00</span>DD16FB  mov         dword ptr [c],eax</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line"><span class="number">00</span>DD16FE  mov         eax,dword ptr [c]  <span class="comment">// 将结果存储到eax中。在函数调用中返回结果都是存储在eax中的。</span></span><br><span class="line">}</span><br><span class="line"><span class="number">01191701</span>  pop         edi  <span class="comment">// 将edi的值还原到函数调用前</span></span><br><span class="line"><span class="number">01191702</span>  pop         esi  <span class="comment">// 将esi的值还原到函数调用前</span></span><br><span class="line"><span class="number">01191703</span>  pop         ebx  <span class="comment">// 将ebx的值还原到函数调用前</span></span><br><span class="line"><span class="number">01191704</span>  mov         esp,ebp  <span class="comment">// 移动栈顶到ebp位置，从而跳过了局部变量存储区域</span></span><br><span class="line"><span class="number">01191706</span>  pop         ebp      <span class="comment">// 将ebp的值还原到函数调用前</span></span><br><span class="line"><span class="number">01191707</span>  ret                  <span class="comment">// ret指令等同于：弹出此时栈顶的值给eip，</span></span><br><span class="line">                               <span class="comment">// 因为此时栈顶存储的刚好是函数返回地址，所以相当于将返回地址赋值给eip，从而实现了返回到函数调用的地方。</span></span><br></pre></td></tr></tbody></table></figure><p>在上面代码的注释中已经包含了详细的解释，特别值得注意的几个地方是：</p><ol><li><code>rep stos    dword ptr es:[edi]</code>结合<code>edi</code>, <code>ecx</code>来初始化局部存储区域。</li><li>函数<code>call</code>指令之前的参数压栈顺序。</li><li><code>CALL</code>指令相当于执行一条<code>PUSH</code>指令加一条<code>JMP</code>指令，<code>PUSH</code>指令用于压入该指令的下一条指令地址到栈中，用于执行完子函数之后返回来。<code>JMP</code>指令用于跳转到子函数所在位置开始执行子函数。</li><li>因为是<code>__cdecl</code>，函数调用完之后，调用方使用<code>add         esp,8</code>来平衡堆栈。</li><li><code>ret</code>指令等同于：弹出此时栈顶的值给 eip，巧妙之处在于此时栈顶存储的刚好是函数返回地址。</li></ol>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows程序如何删除自身</title>
      <link href="/post/3102005562.html"/>
      <url>/post/3102005562.html</url>
      
        <content type="html"><![CDATA[<p>本文介绍几种实现在程序退出后，从磁盘删除自身 exe 文件的方式。该技术通常应用于安装包卸载程序中。</p><span id="more"></span><h2 id="一、借用-choice-命令实现"><a href="#一、借用-choice-命令实现" class="headerlink" title="一、借用 choice 命令实现"></a>一、借用 choice 命令实现</h2><p>Windows 提供了 choice 命令，允许用户从选择列表选择一个项目并返回所选项目的索引。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\akx&gt;choice /?</span><br><span class="line"></span><br><span class="line">CHOICE [/C choices] [/N] [/CS] [/T <span class="built_in">timeout</span> /D choice] [/M text]</span><br><span class="line"></span><br><span class="line">描述:</span><br><span class="line">    该工具允许用户从选择列表选择一个项目并返回所选项目的索引。</span><br><span class="line"></span><br><span class="line">参数列表:</span><br><span class="line">   /C    choices       指定要创建的选项列表。默认列表是 <span class="string">"YN"</span>。</span><br><span class="line"></span><br><span class="line">   /N                  在提示符中隐藏选项列表。提示前面的消息得到显示，</span><br><span class="line">                       选项依旧处于启用状态。</span><br><span class="line"></span><br><span class="line">   /CS                 允许选择分大小写的选项。在默认情况下，这个工具</span><br><span class="line">                       是不分大小写的。</span><br><span class="line"></span><br><span class="line">   /T    <span class="built_in">timeout</span>       做出默认选择之前，暂停的秒数。可接受的值是从 0</span><br><span class="line">                       到 9999。如果指定了 0，就不会有暂停，默认选项</span><br><span class="line">                       会得到选择。</span><br><span class="line"></span><br><span class="line">   /D    choice        在 nnnn 秒之后指定默认选项。字符必须在用 /C 选</span><br><span class="line">                       项指定的一组选择中; 同时，必须用 /T 指定 nnnn。</span><br><span class="line"></span><br><span class="line">   /M    text          指定提示之前要显示的消息。如果没有指定，工具只</span><br><span class="line">                       显示提示。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">   CHOICE /?</span><br><span class="line">   CHOICE /C YNC /M <span class="string">"确认请按 Y，否请按 N，或者取消请按 C。"</span></span><br><span class="line">   CHOICE /T 10 /C ync /CS /D y</span><br><span class="line">   CHOICE /C ab /M <span class="string">"选项 1 请选择 a，选项 2 请选择 b。"</span></span><br><span class="line">   CHOICE /C ab /N /M <span class="string">"选项 1 请选择 a，选项 2 请选择 b。"</span></span><br></pre></td></tr></tbody></table></figure><p>实现方式如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> DeleteSelf {</span><br><span class="line">    <span class="type">wchar_t</span> szSystemDir[MAX_PATH] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetSystemDirectoryW</span>(szSystemDir, MAX_PATH) &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">PathAddBackslashW</span>(szSystemDir);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">wchar_t</span> szFullCmd[MAX_PATH] = {<span class="number">0</span>};</span><br><span class="line">    <span class="built_in">StringCchPrintfW</span>(szFullCmd, MAX_PATH, <span class="string">L"%scmd.exe /C choice /C Y /N /D Y /T 4 &amp; rmdir \"%s\" /Q"</span>,</span><br><span class="line">                    szSystemDir, szPath);</span><br><span class="line"></span><br><span class="line">    STARTUPINFOW si = {<span class="built_in">sizeof</span>(STARTUPINFOW)};</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CreateProcessW</span>(<span class="literal">NULL</span>, szFullCmd, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_NO_WINDOW, <span class="literal">NULL</span>, szSystemDir, &amp;si,</span><br><span class="line">                        &amp;pi)) {</span><br><span class="line">        <span class="keyword">if</span> (pi.hThread)</span><br><span class="line">            <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">        <span class="keyword">if</span> (pi.hProcess)</span><br><span class="line">            <span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="type">bool</span> ret = <span class="built_in">DeleteSelf</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二、使用计划任务实现"><a href="#二、使用计划任务实现" class="headerlink" title="二、使用计划任务实现"></a>二、使用计划任务实现</h2><p>在程序退出前添加 Windows 计划任务，计划任务在程序退出几秒后执行删除文件的操作。</p><p><strong>这种实现方式需要程序具有管理员权限。</strong></p><p>此处省略具体的实现方式。</p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++标准库线程的启动与退出</title>
      <link href="/post/2289160283.html"/>
      <url>/post/2289160283.html</url>
      
        <content type="html"><![CDATA[<p>本文简要介绍C++标准库提供的几种线程操作方法，主要介绍如何判断线程是否已经结束运行。</p><span id="more"></span><h1 id="一、std-thread"><a href="#一、std-thread" class="headerlink" title="一、std::thread"></a>一、std::thread</h1><p>std::thread 未提供判断线程是否结束的方法。</p><p>如果线程未进行 detach 且此时该线程处理 joinable 状态，析构该线程对象会触发异常。</p><!-- more --><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">Thread1</span><span class="params">()</span> </span>{</span><br><span class="line">    std::thread t = std::<span class="built_in">thread</span>([]() {</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::thread t1 = <span class="built_in">Thread1</span>();</span><br><span class="line">    t1.<span class="built_in">join</span>(); <span class="comment">//等待线程结束</span></span><br><span class="line"></span><br><span class="line">    std::thread t2 = std::<span class="built_in">thread</span>([]() {</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"thread id:"</span> &lt;&lt; t2.<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"joinable:"</span> &lt;&lt; t2.<span class="built_in">joinable</span>() &lt;&lt; std::endl; <span class="comment">// 1</span></span><br><span class="line">    t2.<span class="built_in">detach</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"joinable:"</span> &lt;&lt; t2.<span class="built_in">joinable</span>() &lt;&lt; std::endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">2000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二、std-async"><a href="#二、std-async" class="headerlink" title="二、std::async"></a>二、std::async</h1><p>通过<code>std::async</code>可以判断线程是否结束运行。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; f = std::<span class="built_in">async</span>(std::launch::async, []() {</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isRunning = f.<span class="built_in">valid</span>() &amp;&amp; f.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">0</span>)) == std::future_status::timeout;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; isRunning &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    f.<span class="built_in">wait</span>();</span><br><span class="line"></span><br><span class="line">    isRunning = f.<span class="built_in">valid</span>() &amp;&amp; f.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">0</span>)) == std::future_status::timeout;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; isRunning &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-1-判断-std-future-是否结束"><a href="#2-1-判断-std-future-是否结束" class="headerlink" title="2.1 判断 std::future 是否结束"></a>2.1 判断 std::future 是否结束</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isRunning = f.<span class="built_in">valid</span>() &amp;&amp;</span><br><span class="line">                 f.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">0</span>)) == std::future_status::timeout;</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2-std-shared-future"><a href="#2-2-std-shared-future" class="headerlink" title="2.2 std::shared_future"></a>2.2 std::shared_future</h2><p><code>std::future</code>不支持赋值构造，需要使用<code>std::shared_future</code>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::shared_future&lt;<span class="type">void</span>&gt; f1 = std::<span class="built_in">async</span>(std::launch::async, []() {</span><br><span class="line">       std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line"> });</span><br><span class="line"></span><br><span class="line">std::shared_future&lt;<span class="type">void</span>&gt; f2 = f1;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在C++中使用Lamada表达式</title>
      <link href="/post/4208014138.html"/>
      <url>/post/4208014138.html</url>
      
        <content type="html"><![CDATA[<p>Lamada 表达式是 C++11 最重要也是最常用的特性之一。Lamada 来源于函数式编程的概念，也是现代编程语言的一个特点。</p><span id="more"></span><h1 id="一、Lamada-表达式定义"><a href="#一、Lamada-表达式定义" class="headerlink" title="一、Lamada 表达式定义"></a>一、Lamada 表达式定义</h1><p>下图展示出了 C++ Lamada 表示的组成部分：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/lambdaexpsyntax-1.png"></p><p>其中：<br>① 指明捕获列表。<br>② 指明参数列表。<br>③ <code>mutable</code>可选项。和常规的 mutable 用法类似，即当 lamada 表达式参数是 const 时，使用<code>mutable</code>可以取消这种 const。<br>④ <code>throw</code>可选项。可以使用<code>noexcept</code>指明/约束表达式内不会抛出异常。<br>⑤ 指定返回类型。<br>⑥ Lamada 函数体。</p><p>根据上图定义一个完整的 lamada 表达式：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> a) <span class="keyword">noexcept</span> -&gt; <span class="type">int</span> { <span class="keyword">return</span> a + <span class="number">1</span>; };</span><br></pre></td></tr></tbody></table></figure><h1 id="二、返回类型"><a href="#二、返回类型" class="headerlink" title="二、返回类型"></a>二、返回类型</h1><p>很多时候 lamada 表达式的返回值类型是非常明显的，编译器可以根据<code>return</code>语句自动推导出返回类型，这个时候我们可以省略表达式的返回值定义：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = [](<span class="type">int</span> a) {<span class="keyword">return</span> a + <span class="number">1</span>};     <span class="comment">// OK: return type is int</span></span><br></pre></td></tr></tbody></table></figure><p>但是，初始化列表不能用于返回值的自动推导：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x2 = [](<span class="type">int</span> a) {<span class="keyword">return</span> {a+<span class="number">1</span>, a+<span class="number">2</span>}; };   <span class="comment">// error: 无法推导出返回值类型</span></span><br></pre></td></tr></tbody></table></figure><h1 id="三、捕获列表"><a href="#三、捕获列表" class="headerlink" title="三、捕获列表"></a>三、捕获列表</h1><p>lamada 表达式可以通过捕获列表捕获一定范围内的变量：</p><ul><li><code>[]</code> 不捕获任何变量。</li><li><code>[&amp;]</code> 按引用捕获：捕获外部作用域中的所有变量，并作为引用在函数体中使用。</li><li><code>[=]</code> 按值捕获：捕获外部作用域中的所有变量，并作为副本在函数体中使用。</li><li><code>[=, &amp;foo]</code> 按值捕获外部作用域中的所有变量，并按引用捕获 foo 变量。</li><li><code>[bar]</code> 按值捕获 bar 变量，同时不捕获其他变量。</li><li><code>[this]</code> 捕获 lamada 所在的当前类中的<code>this</code>指针，让 lamada 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了<code>&amp;</code>或<code>=</code>，就默认添加此选项。捕获 this 的目的是可以在 lamada 中使用当前类的成员函数和成员变量。</li></ul><h1 id="四、异常约束"><a href="#四、异常约束" class="headerlink" title="四、异常约束"></a>四、异常约束</h1><p>可以使用<code>noexcept</code>来指定和约束 Lamada 表达内不会抛出异常，如果抛出异常，编译器会产生编译警告。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// throw_lambda_expression.cpp</span></span><br><span class="line"><span class="comment">// compile with: /W4 /EHsc</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">// 产生编译警告C4297</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   []() <span class="keyword">noexcept</span> { <span class="keyword">throw</span> <span class="number">5</span>; }();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="五、mutable"><a href="#五、mutable" class="headerlink" title="五、mutable"></a>五、mutable</h1><p>正常情况下，按值捕获的变量，其值在 Lamada 表达式内是不能被修改的（遵循<code>const-by-value</code>），如下面的代码编译会报错：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> fuc = [n]() {</span><br><span class="line">    n = <span class="number">2</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// error C3491: “n”: 无法在非可变 lambda 中修改通过复制捕获</span></span><br></pre></td></tr></tbody></table></figure><p>可以使用<code>mutable</code>关键字改变这种行为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> fuc = [n]() <span class="keyword">mutable</span> {</span><br><span class="line">    n = <span class="number">2</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, n); <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><p>虽然在 Lamada 表达式内可以修改<code>n</code>的值，但<code>n</code>仍是按值传递，因此外部<code>n</code>的值没有被改变。</p><blockquote><p>参考：<a href="https://msdn.microsoft.com/en-us/library/dd293608.aspx">https://msdn.microsoft.com/en-us/library/dd293608.aspx</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lamada </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSIS教程(12)-开源UI插件</title>
      <link href="/post/2584392152.html"/>
      <url>/post/2584392152.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、项目介绍"><a href="#一、项目介绍" class="headerlink" title="一、项目介绍"></a>一、项目介绍</h1><p>介绍一个我开发的开源NSIS UI插件NSIS-UI-Plugin，基于NSIS-UI-Plugin插件我们可以快速的制作出NSIS安装包。</p><p>该插件默认使用Qt作为界面库（不需要编译Qt静态库，可以使用Qt动态库），但也可以很方便的切换使用其他界面库，如<a href="https://github.com/winsoft666/duilib2">DuiLib</a>等。</p><p>项目地址：<a href="https://github.com/winsoft666/NSIS-UI-Plugin">https://github.com/winsoft666/NSIS-UI-Plugin</a></p><span id="more"></span><h1 id="二、依赖项"><a href="#二、依赖项" class="headerlink" title="二、依赖项"></a>二、依赖项</h1><p>使用NSIS-UI-Plugin插件需要提前安装如下工具。</p><h2 id="2-1-NSIS"><a href="#2-1-NSIS" class="headerlink" title="2.1 NSIS"></a>2.1 NSIS</h2><p>从<a href="https://nsis.sourceforge.io/Download">https://nsis.sourceforge.io/Download</a> 下载NSIS并安装，新增系统环境变量<code>NSIS_DIR</code>为NSIS安装目录。</p><h2 id="2-2-Python"><a href="#2-2-Python" class="headerlink" title="2.2 Python"></a>2.2 Python</h2><p>之所以需要安装Python，主要是为了执行<code>NsisScriptGenerate.py</code>脚本。</p><p>将<code>Python.exe</code>所在目录添加到<code>Path</code>环境变量。</p><h2 id="2-3-Qt"><a href="#2-3-Qt" class="headerlink" title="2.3 Qt"></a>2.3 Qt</h2><p>因为插件默认使用Qt作为界面库，所以需要安装Qt。</p><p>Qt安装包会默认将安装目录添加<code>QTDIR</code>环境变量，如果没有自动添加，则需要手动添加。</p><h1 id="三、开始使用"><a href="#三、开始使用" class="headerlink" title="三、开始使用"></a>三、开始使用</h1><h2 id="3-1-编译NSIS-UI-Plugin"><a href="#3-1-编译NSIS-UI-Plugin" class="headerlink" title="3.1 编译NSIS-UI-Plugin"></a>3.1 编译NSIS-UI-Plugin</h2><p>安装完上面依赖项之后，编译<code>NSIS-UI-Plugin\NSIS-UI-Plugin.vcxproj</code>工程，Visual Studio的生成后事件会自动将目标文件（Debug版：<code>nsQtPluginD.dll</code>， Release版：<code>nsPlugin.dll</code>）拷贝到NSIS插件目录（<code>NSIS_DIR\Plugins\x86-unicode</code>）。</p><h2 id="3-2-生成安装包"><a href="#3-2-生成安装包" class="headerlink" title="3.2 生成安装包"></a>3.2 生成安装包</h2><p><code>VimeoSetup</code>是一个关于如何在NSIS中使用该插件的示例工程：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">App                -- 放置需要打包到安装包中的文件</span><br><span class="line">VCRuntimeDLL       -- 放置VC++运行时库文件（Debug版和Release版），Qt界面库默认采用MD模式编译，运行时需要依赖VC++运行时库</span><br><span class="line">vimeo-template.nsi -- NSIS模板文件，文件名的`-template`后缀固定的，NsisScriptGenerate.py会根据该模板生成vimeo.nsi</span><br><span class="line">build-setup [debug].bat -- 生成Debug版的安装包，即使用Debug版的Qt和NSIS-UI-Plugin</span><br><span class="line">build-setup [debug].bat -- 生成Release版的安装包</span><br></pre></td></tr></tbody></table></figure><p>将需要打包的文件放置到<code>App</code>目录，然后运行<code>build-setup.bat</code>生成安装包。</p><blockquote><p><code>NsisScriptGenerate.py</code>脚本功能：因为NSIS没有提供获取文件释放进度的功能，所以<code>NsisScriptGenerate.py</code>遍历<code>App</code>目录，采用<code>File</code>命令挨个添加文件，并调用插件接口<code>SetInstallStepDescription</code>通知安装详情。</p></blockquote><h1 id="四、截图"><a href="#四、截图" class="headerlink" title="四、截图"></a>四、截图</h1><p>仅用作示例，你可以使用任意界面库来创建任意的安装/卸载界面。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-ui-plugin-1.png"></p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-ui-plugin-2.png"></p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-ui-plugin-3.png"></p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 打包狂魔之NSIS教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>白酒入门</title>
      <link href="/post/1855436935.html"/>
      <url>/post/1855436935.html</url>
      
        <content type="html"><![CDATA[<p>正值 9 月 9 全球酒水节，各大电商都在做活动，趁机网购了一批酒水。在享受这大自然馈赠的礼物的同时，也说一说自己对白酒的理解。希望在了解了白酒的这些知识后能明明白白喝酒。</p><span id="more"></span><h1 id="1-白酒酿造工艺"><a href="#1-白酒酿造工艺" class="headerlink" title="1. 白酒酿造工艺"></a>1. 白酒酿造工艺</h1><h2 id="1-1-粮食酒与勾兑酒"><a href="#1-1-粮食酒与勾兑酒" class="headerlink" title="1.1 粮食酒与勾兑酒"></a>1.1 粮食酒与勾兑酒</h2><p>首先，所有的白酒都是粮食经过发酵、蒸馏而成的，也就是我们常说的<strong>粮食酒</strong>，这也印证了人们常说的“酒是粮食精，越喝越年轻”这句话。 因为白酒都要经过<strong>蒸馏</strong>这个步骤，所以我们也称白酒为“蒸馏酒”。 但我们常提到的“非粮食酒”指的是用食用酒精（有的甚至用的工业酒精）勾兑而成的酒，<strong>我认为</strong>这种酒严格意义上可以称为<strong>“假酒”</strong>(虽然使用食用酒精勾兑在法律上是被允许的，也就是后面提到的液态发酵酒。法律禁止使用工业酒精勾兑酒)，喝了之后对人体没有任何好处，最多只能麻痹神经（工业酒精勾兑的酒是绝对不能喝的，工业酒精成份是甲醇，少量就会使人失明或者致命）。</p><p>很多人对<strong>“勾兑”</strong>二字很敏感，认为凡是勾兑的酒都不是好酒，这个观点是错误的。 下面介绍白酒的酿造工艺时会说到，粮食等最初经过发酵、蒸馏形成的酒叫<strong>“原浆”</strong>，原浆的酒精度数一般在 70 度左右，是无法直接饮用的，需要降低其度数才能饮用。</p><blockquote><p>如果在市面上看到如“茅台镇粮食原浆酒”等这样的“原浆酒”，但度数低于 70 度(左右)的，都不是真正的原浆酒。这样的商家要么是不诚信，要么就是不专业。</p></blockquote><p>降低度数不是直接往酒里面掺水，这样口感会非常差，而且会使酒体变浑浊。 需要专门的白酒勾兑工艺，白酒勾兑一门很复杂的学科，勾兑主要是将不同的原料、不同窖池、不同环节、<strong>不同年份</strong>的酒进行调配，从而产生具有不同口味、香型的白酒。 标准的白酒勾兑工艺中是不允许添加化学添加剂的，白酒的口味、香型都是自然形成的。</p><p>我们可以认为市面上所有的酒都是“勾兑酒”，只是每种酒勾兑所用的原料、工艺不相同，茅台、五粮液、汾酒等无一例外也是勾兑而成的。好酒采用“酒勾兑酒”的方式，差酒采用“酒精勾兑水”或者“酒精+香精+添加剂勾兑水”的方式。</p><h2 id="1-2-酿造工艺"><a href="#1-2-酿造工艺" class="headerlink" title="1.2 酿造工艺"></a>1.2 酿造工艺</h2><h3 id="1-2-1-纯粮固态发酵、液态发酵"><a href="#1-2-1-纯粮固态发酵、液态发酵" class="headerlink" title="1.2.1 纯粮固态发酵、液态发酵"></a>1.2.1 纯粮固态发酵、液态发酵</h3><p>白酒在酿造工艺上分为<strong>纯粮固态发酵</strong>和<strong>液态发酵</strong> 2 种。</p><ul><li>纯粮固态发酵酒是通过粮食+曲+发酵+陈酿+勾兑等几个环节制成的。</li><li>液态发酵酒是用甘蔗和甜菜渣、薯干、玉米等（这几种植物发酵周期短、出酒率高、酒质差）制造出来的食用酒精为基础酒，加入增香调味物质模拟传统粮食白酒的口感，经调配而成的液态白酒，行话叫“三精一水”，即食用酒精、香精、糖精、水。</li></ul><p>由于纯粮固态发酵工艺所遵循的都是自然的酿造规律，加之曲、老窖中微生物的作用，酒体中除了乙醇外，还蕴含了丰富的己酸、乙酯等营养成分。酸是白酒中的重要呈味物质，它与其他香味物质共同构成白酒所特有的芳香。优质纯粮固态发酵的白酒的酸超过普通液态白酒的两倍。酯也是固态发酵白酒的香味物质，优质白酒的酯类含量比液态白酒高出一倍以上，所以优质白酒香味浓郁，而液态发酵白酒的香味只能靠添加人工合成的香味物质来解决。</p><h3 id="1-2-2-酿造流程"><a href="#1-2-2-酿造流程" class="headerlink" title="1.2.2 酿造流程"></a>1.2.2 酿造流程</h3><p>这里只介绍白酒<strong>纯粮固态酿造</strong>的几大主要的流程，每个酒厂生产酒的特点不一样，具体细节也会有很大差异，但都离不开这几大流程。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/baijiurumen-1.png"></p><p><strong>1. 选料</strong><br>原料主要是粮食和水。粮食以高粱、玉米、小麦、大米、糯米等中的一种或多种为主，每种粮食酿出的酒的口味都不一样，有行业术语叫“高粱香、玉米甜、大米净、小麦糙、糯米绵”。</p><p>水，酿酒对水的要求很高，常言道“水为酒之血，名酒必有佳泉”，这也是为什么只有赤水河的水才能酿出茅台的原因。</p><p><strong>2. 制曲</strong><br>如果说粮食是酒的根本，那么“曲就是酒的骨髓”。曲类似于做馒头的酵母。曲主要有 3 种：</p><ul><li>大曲：由麦子高温制成，发酵周期长、微生物含量丰富，多用于高端白酒。</li><li>小曲：由米制成，发酵周期短、微生物含量低。</li><li>麸曲：由麸皮（小麦的壳，打碎之后叫糠，农村常用于喂猪）制成，发酵周期短，出酒率高，但酒质较差。多用于低端酒，如二锅头等。</li></ul><p><strong>3. 发酵</strong><br>将粮食和曲放入窖池中发酵，利用曲和窖池中的微生物将粮食糖化、发酵成酒精。</p><p>“千年老窖”中含有的微生物丰富，发酵出来的酒口感和味道也不一样。</p><p><strong>4. 蒸馏</strong><br>靠发酵形成的酒的酒精度数很低，需要进行提纯。利用酒精和水的沸点不一样，采用蒸馏法进行提纯。</p><p>蒸馏的过程分为头、中、尾 3 部分，产生的酒称为酒头、中馏酒、酒尾，每种酒在酒厂中都有不同的用处。</p><p><strong>5. 陈酿</strong><br>经过蒸馏产生的高度源酒还只能算半成品，喝起来辛辣，不醇和。需要经过合理的贮存、陈酿，一方面自然的排除杂味，另一方面让酒分子（即乙醇分子）和水分子充分结合，使酒的口感更加醇厚。这一步陈酿的越久，口味就越好，成本就越高，价格也就越贵。</p><p><strong>6. 勾兑</strong><br>经过上面几个步骤产生的酒就可以称为“原浆”了，度数较高、口味单一、香味不纯在。为了统一口味，协调香味、降低度数，需要专门的调酒师对原浆酒进行勾兑。</p><blockquote><p>现在白酒市场越来越来乱，各种混、配，如<code>固态发酵白酒+食用酒精+食用香精+其他添加物</code>等等，认准好酒除了相信一分钱一分货之外，还有**好酒在酿造工艺上需具备这 3 个关键词 <code>纯粮、纯固态、大曲</code>**。瓶身都有配料表，出现“食用酒精”的不要购买。</p></blockquote><h2 id="1-3-年份酒"><a href="#1-3-年份酒" class="headerlink" title="1.3 年份酒"></a>1.3 年份酒</h2><p>我们在市面上经常遇到类似“白云边 12 年”，“白云边 15 年”，“白云边 20 年”这样的年份酒，很多人认为这个“12 年”、“15 年”、“20 年”指的这瓶酒存储的年份。 如果你是这么认为的，那只能说你“太年轻，太简单”了。</p><p>拿“白云边 20 年”为例，它指的是在白酒勾兑过程中掺入了少许 20 年年份的酒，具体的这个“少许”指的是多少就不清楚了，可能是一缸酒:一杯 20 年酒，也可能更少或更多。 现实中由于酒的年份不同，价格差距也巨大，所以调酒时所用的基酒的品质等也会有差别，毕竟白云边 20 年和 15 年喝起来差别还是很大的。</p><h2 id="1-4-白酒收藏"><a href="#1-4-白酒收藏" class="headerlink" title="1.4 白酒收藏"></a>1.4 白酒收藏</h2><p>一般收藏酒的年份指的是这整瓶酒存放的年份。 这个价值不是年份酒所能比拟的。我们经常听说“酒是陈的香”，但白酒是不是存放的越久就一定越好喝了？ 不一定，这个和酒的质量、存放的环境、密封程度等有很大关系。一般存放 3~5 年喝为宜，很多几十年的陈酒已经不适合直接喝了，可以用来作为基酒进行勾调。</p><p>有几种酒不适合陈：</p><ol><li>含添加剂的酒。现在市面上很多低端酒都加入了香精，如果存放时间长了，香精挥发了，口感也会不一样。</li><li>低度酒（43 度以下的酒就算低度酒了）。世界上没有绝对密封的环境（我们可能认为玻璃瓶、陶瓷瓶的瓶壁是绝对封闭的，但从分子的角度来看，仍然会有酒分子的渗漏挥发，更何况还有瓶口的密封等问题），酒或多或少都会有挥发，低度酒度数本来就不高，挥发之后酒的度数就会更低；另外，低度酒杀菌能力较弱，存储不当会导致微生物易在酒体中繁殖。</li></ol><h1 id="2-白酒香型分类"><a href="#2-白酒香型分类" class="headerlink" title="2. 白酒香型分类"></a>2. 白酒香型分类</h1><p>新中国成立之后，为了加强白酒市场的管理，提高白酒质量，通过对白酒香味成分的分析（当然到现在也没弄清楚酱香型白酒的香味成分），提出了按香型对白酒分类的方案。截止到现在，白酒的香型有十几种之多，但<code>酱香型</code>、<code>浓香型</code>、<code>清香型</code>这 3 种香型差不多占据了白酒市场 90%的份额。</p><table><thead><tr><th>香型</th><th>代表酒</th></tr></thead><tbody><tr><td>酱香型</td><td>茅台、郎酒</td></tr><tr><td>浓香型</td><td>五粮液、泸州老窖、剑南春</td></tr><tr><td>清香型</td><td>汾酒、二锅头</td></tr><tr><td>董香型</td><td>董酒</td></tr><tr><td>凤香型</td><td>西凤酒</td></tr><tr><td>兼香型</td><td>白云边</td></tr><tr><td>馥郁香型</td><td>酒鬼酒</td></tr><tr><td>米香型</td><td>三花酒</td></tr></tbody></table><h1 id="3-酱香型白酒"><a href="#3-酱香型白酒" class="headerlink" title="3. 酱香型白酒"></a>3. 酱香型白酒</h1><h2 id="3-1-酱香白酒的优点"><a href="#3-1-酱香白酒的优点" class="headerlink" title="3.1 酱香白酒的优点"></a>3.1 酱香白酒的优点</h2><p>为什么将酱香型白酒单独拿出来说了？一个是因为我自己爱喝，另外一个原因是喝酱香型白酒的确有诸多好处。酱香型白酒主要有以下特点：</p><ol><li>正规酱香型白酒出厂前要经过三年以上的贮存，酒体中的易挥发物质少，对身体的刺激少。茅台酒空杯留香也和这有一定的关系。</li><li>因为易挥发物质少，酱香型的酒更适合存放，越陈越香。</li><li>酱香型白酒的酸度高、含 SOD 等物质，对软化血管，抗氧化等方面有一定的帮助。</li><li>目前还没找到可以产生酱香味的主要香味物质，所以很难通过香精、添加剂造假。</li><li>国家已经出台酱香型白酒国家标准，明确规定酱香型白酒不允许使用食用酒精及非白酒发酵生产的呈香、呈味、呈色物质，必须是使用纯粮食、固态法发酵而成。（<strong>但低端酱香酒因为成本等原有很难达使用大曲发酵</strong>）。</li></ol><blockquote><p>上面列出的酱香型酒的诸多好处都是基于<strong>适量饮酒</strong>的前提。</p></blockquote><h2 id="3-2-坤沙、碎沙、翻沙、串沙"><a href="#3-2-坤沙、碎沙、翻沙、串沙" class="headerlink" title="3.2 坤沙、碎沙、翻沙、串沙"></a>3.2 坤沙、碎沙、翻沙、串沙</h2><p>坤沙、碎沙、翻沙、串沙这些名词是专门用于酱香型白酒的工艺。“沙”指的是高粱，不是沙子。</p><p><strong>坤沙酒</strong><br>“坤”是音译过来的，也叫做“捆”，表示用完整的高粱来酿酒。坤沙酒也叫捆沙酒、坤籽酒，<strong>也就是常说的正宗的酱香型白酒</strong>。严格按照传统的贵州茅台镇工艺进行生产，采用当地产的糯高粱、小麦，生产周期长达一年，出酒率低，但酒质好。需要经过很重要的“回沙“工艺，即 1 年生产、2 次投料、9 次蒸馏、8 次发酵、7 次取酒，也就是常说的 12987 生产工艺，然后还要经过三年以上的陈酿才能够出厂。在生产过程中高粱不能够粉碎，高粱的粉碎率需控制在 20%以内。</p><blockquote><p>坤沙酒生产流程非常复杂，周期长，且出酒率低，这也是茅台飞天等高端酱香型酒价格居高不下的一个原因吧。</p></blockquote><p><strong>碎沙酒</strong><br>碎沙工艺就是指用被完完全全粉碎的高粱来酿酒。碎沙工艺生产周期较短，出酒率高，不要经过像坤沙那么严格的”回沙“工艺，所出酒的酱香味单薄，不如坤沙那样酱香味浓郁。但较好入口，也赢得了一部分人的喜爱。市面上的中低端酱香白酒大多采用此种工艺。</p><p><strong>翻沙酒</strong><br>翻沙就是利用坤沙工艺中最后一次（第 9 次）蒸馏之后废弃的酒糟，再次加入高粱和曲，重新发酵酿出来的酒。翻沙酒生产周期短，出酒率高，但品质差。这样做只是利用酒糟让酒多了一点酱香味。因为生产成本低廉，市场上很多低端酱香型酒多是用的这种方法。</p><p><strong>串沙酒</strong><br>窜沙酒，也叫串香酒，也是利用坤沙工艺中最后一次（第 9 次）蒸馏之后废弃的酒糟，但是它是直接加入食用酒精蒸馏。酒质很差，成本非常低廉。这种酒不符合酱香型的国家标准，不能算酱香型白酒了。</p><h2 id="3-3-茅台及子品牌"><a href="#3-3-茅台及子品牌" class="headerlink" title="3.3 茅台及子品牌"></a>3.3 茅台及子品牌</h2><p>说到酱香就不能不提茅台了，酱香型酒曾经一度也叫“茅香型酒”。“今茅已非彼茅”，茅台今天已经是一个上市公司，大集团，旗下有很多子公司，每个子公司都有自己的品牌。常见的有飞天茅台、五星茅台、茅台王子酒、茅台迎宾酒、汉酱等等，它们有贵的，也有便宜的，这也是茅台集团多品牌战略的核心，以适应各种消费层次的需求。</p><p>下图是茅台集团及其子公司的白酒类品牌：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/baijiurumen-2.png"></p><p>我们常说的<code>高端茅台</code>指的<code>贵州茅台酒股份有限公司</code>生产的<code>飞天茅台</code>、<code>五星茅台</code>、<code>茅台纪念酒</code>、<code>茅台生肖酒</code>、<code>茅台陈年酒</code>，这些高端茅台酒大多有 43 度和 53 度 2 种度数。度数不同，价格差距很大，以飞天茅台市场价为例，43 度的差不多 900 元，53 度的将近 2400 元。</p><h1 id="4-如何喝酒"><a href="#4-如何喝酒" class="headerlink" title="4. 如何喝酒"></a>4. 如何喝酒</h1><p>喝酒当然是用嘴喝，这里说的喝酒一定程度上指的是品酒，但品酒是一个很专业的事情，不是一两句话可以说的清的，需要专业的知识和经验的累积，故这里使用“如何品酒”这个标题。酒是小口小口的品的，绝不是“我干了，你随意”式的喝法。下面列出我的一点喝酒的方法：</p><h2 id="4-1-望"><a href="#4-1-望" class="headerlink" title="4.1 望"></a>4.1 望</h2><p>倒入杯中看是否有酒花，是否挂杯。观察酒的颜色，如酱香型的酒会微微偏黄。</p><h2 id="4-2-闻"><a href="#4-2-闻" class="headerlink" title="4.2 闻"></a>4.2 闻</h2><p>端起酒杯闻酒香，不同的酒有不同的香味，有时候通过香味是否纯在就可以判断一个酒的好坏。喝完之后，可以闻闻是否空杯留香等等。</p><h2 id="4-3-咂"><a href="#4-3-咂" class="headerlink" title="4.3 咂"></a>4.3 咂</h2><p>含在口中，慢慢感受酒的气味，是柔和还是刺激；从舌尖滑到舌根，最后到喉咙；回味是否甘甜。</p>]]></content>
      
      
      <categories>
          
          <category> ⑭ 杂念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 白酒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows用户界面特权隔离(UIPI)</title>
      <link href="/post/2701401097.html"/>
      <url>/post/2701401097.html</url>
      
        <content type="html"><![CDATA[<p>在早期的 Windows 操作系统中，在同一用户下运行的所有进程有着相同的安全等级，拥有相同的权限。此时进程可以自由地发送Windows 消息到其他进程的窗口。</p><p>从 Windows Vista 开始，对于某些 Windows 消息，这一方式再也行不通了，进程（或者其他的对象）开始拥有一个新的属性–特权等级(Privilege Level)。此时一个特权等级较低的进程不再可以向特权等级较高的进程发送消息，即便他们在相同的用户权限下运行也不行，这就是所谓的用户界面特权隔离(<code>User Interface Privilege Isolation</code>, 简称 <code>UIPI</code>)。</p><span id="more"></span><p>引入 UIPI 的目的是为了防止恶意程序发送消息给那些拥有较高权限的窗口，从而利用该进程的高权限达到某种目的等等。</p><h1 id="一、UIPI-的运行机制"><a href="#一、UIPI-的运行机制" class="headerlink" title="一、UIPI 的运行机制"></a>一、UIPI 的运行机制</h1><p>在 Windows 7 中，当 UAC(User Account Control)启用的时候，UIPI 的运行可以得到最明显的体现。在 UAC 中，当一个管理员用户登录系统后，操作系统会创建两个令牌对象(Token Object)：一个是管理员令牌，拥有大多数特权(类似于 Windows Vista 之前的 System 中的用户)，而另一个是经过过滤后的简化版本，只拥有普通用户的权限。</p><p>默认情况下，以普通用户权限启动的进程拥有普通特权等级【UIPI 的等级划分为低等级(low)，普通(normal)，高等级(high)，系统(system)】。同样的，以管理员权限运行的进程（例如用户右键单击选择“以管理员身份运行”或者是通过添加“runas”参数调用 ShellExecute 运行的进程）拥有高(high)特权等级。</p><p>系统中会运行多种不同类型、不同特权等级的进程(当然，从技术上讲这两个进程都是在同一用户下)。我们可以使用<a href="(http://www.microsoft.com/technet/sysinternals)">Windows Sysinternals</a>工具集中的<code>Process Explorer</code>查看各个进程的特权等级。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/UIPI-1-TinyTu.png"></p><p>所以，当发现进程之间 Windows 消息通信发生问题时，不妨使用<code>Process Explorer</code>查看一下两个进程之间是否有合适的特权等级。</p><h1 id="二、UIPI-所带来的限制"><a href="#二、UIPI-所带来的限制" class="headerlink" title="二、UIPI 所带来的限制"></a>二、UIPI 所带来的限制</h1><p>正如我们前文所说，等级的划分，是为了防止以下犯上。所以，有了用户界面特权隔离，一个运行在较低特权等级的应用程序的行为就受到了诸多限制，它<strong>不可以</strong>进行如下操作：</p><ul><li>验证由较高特权等级进程创建的窗口句柄</li><li>通过调用 SendMessage 和 PostMessage 向由较高特权等级进程创建的窗口发送 Windows 消息</li><li>使用线程钩子处理较高特权等级进程</li><li>使用普通钩子(SetWindowsHookEx)监视较高特权等级进程</li><li>向一个较高特权等级进程执行 DLL 注入</li></ul><p>但是，一些特殊 Windows 消息是被容许的，因为这些消息对进程的安全性没有太大影响。这些 Windows 消息包括：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="number">0x000</span> - WM_NULL</span><br><span class="line">　　<span class="number">0x003</span> - WM_MOVE</span><br><span class="line">　　<span class="number">0x005</span> - WM_SIZE</span><br><span class="line">　　<span class="number">0x00D</span> - WM_GETTEXT</span><br><span class="line">　　<span class="number">0x00E</span> - WM_GETTEXTLENGTH</span><br><span class="line">　　<span class="number">0x033</span> - WM_GETHOTKEY</span><br><span class="line">　　<span class="number">0x07F</span> - WM_GETICON</span><br><span class="line">　　<span class="number">0x305</span> - WM_RENDERFORMAT</span><br><span class="line">　　<span class="number">0x308</span> - WM_DRAWCLIPBOARD</span><br><span class="line">　　<span class="number">0x30D</span> - WM_CHANGECBCHAIN</span><br><span class="line">　　<span class="number">0x31A</span> - WM_THEMECHANGED</span><br><span class="line">　　<span class="number">0x313</span>, <span class="number">0x31B</span> (WM_???)</span><br></pre></td></tr></tbody></table></figure><h1 id="三、修复-UIPI-问题"><a href="#三、修复-UIPI-问题" class="headerlink" title="三、修复 UIPI 问题"></a>三、修复 UIPI 问题</h1><p>基于 Windows Vista 之前的操作系统行为所设计的应用程序，可能希望 Windows 消息能够在进程之间自由的传递以完成一些特殊的工作。当这些应用程序在 Windows 7/10/11 上运行时，因为 UIPI 机制的存在，这种消息传递被阻断了，应用程序就会遇到兼容性问题。</p><p>为了解决这个问题，Windows Vista 引入了新的 API 函数<code>ChangeWindowMessageFilter</code>和<code>ChangeWindowMessageFilterEx</code>。在特权等级较高的进程中利用这 2 个函数可以添加或者删除能够通过特权等级隔离的 Windows 消息。这就像拥有较高特权等级的进程设置了一个过滤器，被允许通过的 Windows 消息都将被添加到这个过滤器的白名单，只有在这个白名单上的消息才允许传递进来。</p><p>下面对添加/移除白名单功能进行了简单封装（<code>UIPIMsgFilter</code>函数），该函数可以针对特定的窗体添加、移除消息白名单：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">UIPIMsgFilter</span><span class="params">(HWND hWnd, UINT uMessageID, BOOL bAllow)</span> </span>{</span><br><span class="line">    OSVERSIONINFO VersionTmp;</span><br><span class="line">    VersionTmp.dwOSVersionInfoSize = <span class="built_in">sizeof</span>(OSVERSIONINFO);</span><br><span class="line">    <span class="built_in">GetVersionEx</span>(&amp;VersionTmp);</span><br><span class="line">    BOOL res = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (VersionTmp.dwMajorVersion &gt;= <span class="number">6</span>) { <span class="comment">// vista above.</span></span><br><span class="line">        <span class="built_in">BOOL</span>(WINAPI * pfnChangeMessageFilterEx)(HWND, UINT, DWORD, PCHANGEFILTERSTRUCT);</span><br><span class="line">        <span class="built_in">BOOL</span>(WINAPI * pfnChangeMessageFilter)(UINT, DWORD);</span><br><span class="line"></span><br><span class="line">        CHANGEFILTERSTRUCT filterStatus;</span><br><span class="line">        filterStatus.cbSize = <span class="built_in">sizeof</span>(CHANGEFILTERSTRUCT);</span><br><span class="line"></span><br><span class="line">        HINSTANCE hlib = <span class="built_in">LoadLibrary</span>(_T(<span class="string">"user32.dll"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hlib != <span class="literal">NULL</span>) {</span><br><span class="line">            (FARPROC &amp;)pfnChangeMessageFilterEx = <span class="built_in">GetProcAddress</span>(hlib, <span class="string">"ChangeWindowMessageFilterEx"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pfnChangeMessageFilterEx != <span class="literal">NULL</span> &amp;&amp; hWnd != <span class="literal">NULL</span>) {</span><br><span class="line">                res = <span class="built_in">pfnChangeMessageFilterEx</span>(hWnd, uMessageID, (bAllow ? MSGFLT_ADD : MSGFLT_REMOVE), &amp;filterStatus);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If failed, try again.</span></span><br><span class="line">            <span class="keyword">if</span> (!res) {</span><br><span class="line">                (FARPROC &amp;)pfnChangeMessageFilter = <span class="built_in">GetProcAddress</span>(hlib, <span class="string">"ChangeWindowMessageFilter"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pfnChangeMessageFilter != <span class="literal">NULL</span>) {</span><br><span class="line">                    res = <span class="built_in">pfnChangeMessageFilter</span>(uMessageID, (bAllow ? MSGFLT_ADD : MSGFLT_REMOVE));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hlib != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">FreeLibrary</span>(hlib);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        res = TRUE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows注册URL协议</title>
      <link href="/post/1343547595.html"/>
      <url>/post/1343547595.html</url>
      
        <content type="html"><![CDATA[<p>当电脑安装完 Steam 后，我们在浏览器中访问<code>steam://run/123</code>，浏览器会自动提示打开 Steam 程序。类似的功能在迅雷、QQ 等产品上也都有使用，本文讲述如何实现该功能。</p><span id="more"></span><p><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-zczdyxy-1.jpg"></p><p>实现上述功能只需要在注册表<code>HKEY_CLASSES_ROOT</code>项下添加对应的子项即可，以注册<code>test</code>协议为例：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">indows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\test]</span><br><span class="line">@="URL:test protocol"</span><br><span class="line">"URL Protocol"=""</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\test\DefaultIcon]</span><br><span class="line">@="mytest.exe"</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\test\Shell]</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\test\Shell\Open]</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\test\Shell\Open\Command]</span><br><span class="line">@="\"D:\\sourcecode\\mytest.exe\" -- \"%1\""</span><br></pre></td></tr></tbody></table></figure><p>修改完之后，在浏览器中输入<code>test://start/123</code>就会打开<code>D:\\sourcecode\\mytest.exe</code>，并且传递给<code>mytest.exe</code>的命令行参数为<code>test://start/123</code>。</p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编译器基础概念</title>
      <link href="/post/3064318708.html"/>
      <url>/post/3064318708.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、C-代码编译流程"><a href="#一、C-代码编译流程" class="headerlink" title="一、C++代码编译流程"></a>一、C++代码编译流程</h2><p>以下面 C++代码为例：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译成二进制文件需要经过如下 4 个过程：</p><ul><li><strong>预编译</strong>：将 hello.c 和 stdio.h 预编译为 hello.i</li><li><strong>编译</strong>：将 hello.i 编译为 hello.s</li><li><strong>汇编</strong>：将 hello.s 翻译为机器指令 hello.o（.o 目标文件）</li><li><strong>链接</strong>：链接各种需要的库和其他目标文件（该 hello 程序不需要）得到可执行文件 hello.out（相当于 windows 的.exe）。<span id="more"></span></li></ul><h2 id="二、编译器架构"><a href="#二、编译器架构" class="headerlink" title="二、编译器架构"></a>二、编译器架构</h2><p>编译器通常分为三个部分：</p><ul><li>前端（FrontEnd）</li><li>优化器（Optimizer）</li><li>后端（BackEnd）</li></ul><p>在编译过程中，前端主要负责词法和语法分析，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。</p><h3 id="2-1-GCC"><a href="#2-1-GCC" class="headerlink" title="2.1 GCC"></a>2.1 GCC</h3><p>GCC(GNU Compiler Collection，GNU 编译器集合)是一个完整的编译器，包含 FrontEnd、Optimizer 和 BackEnd。</p><h3 id="2-2-LLVM-架构"><a href="#2-2-LLVM-架构" class="headerlink" title="2.2 LLVM 架构"></a>2.2 LLVM 架构</h3><p><code>Clang</code>是 LLVM 编译器架构的前端，可以用来编译 C，C++，ObjectiveC 等语言；</p><p><code>LLVM</code>是该架构的优化器和后端；</p><p>二者统称为 LLVM 架构。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/bianyiiqijichugailian-1.png"></p><h2 id="三、编译版本选择"><a href="#三、编译版本选择" class="headerlink" title="三、编译版本选择"></a>三、编译版本选择</h2><h3 id="3-1-x86、x86-64、AMD64"><a href="#3-1-x86、x86-64、AMD64" class="headerlink" title="3.1 x86、x86-64、AMD64"></a>3.1 x86、x86-64、AMD64</h3><p>x86 是指 Intel 的开发的一种 32 位指令集，从 386 时代开始，一直沿用至今，所有 Intel 早期的 cpu，以及 amd 早期的 cpu 都支持这种指令集。</p><p>AMD 领先 Intel 制造出兼容 x86 的商用 CPU，AMD 称之为 AMD64，且得到用户的认同。</p><p>Intel 选择设计了一种不兼容 x86 的全新 64 位指令集，称之为 IA-64。由于是全新设计的 CPU，没有编译器、不支持 Windows，后来不得不在时机落后的情况下也开始支持 AMD64 指令集。因此换了个名字叫 x86_64，表示 x86 指令集的 64 位扩展。</p><p>x86_64、x64、AMD64 基本上是一个东西，我们现在用的 intel/amd 的桌面级 CPU 基本上都是 x86_64。</p><h3 id="3-2-i386"><a href="#3-2-i386" class="headerlink" title="3.2 i386"></a>3.2 i386</h3><p>i386 即 Intel 80386。 其实 i386 通常被用来作为对 Intel（英特尔）32 位微处理器的统称。</p><p>但是目前更多的时候，我们公认 i386 为 32 位系统，其实就是 x86。</p><h3 id="3-3-i686"><a href="#3-3-i686" class="headerlink" title="3.3 i686"></a>3.3 i686</h3><p>i686 仍然属于 i386 体系，不过相对于 386 CPU 的特性作了指令优化。</p><h3 id="3-4-MSVC-编译器版本描述"><a href="#3-4-MSVC-编译器版本描述" class="headerlink" title="3.4 MSVC 编译器版本描述"></a>3.4 MSVC 编译器版本描述</h3><ul><li>x86：编译器为 x86 版本，输出文件为 x86。</li><li>amd64_x86：编译器为 amd64 版本，输出文件为 x86。</li><li>amd64：编译器为 amd64 版本，输出文件为 amd64。</li><li>x86_amd64：编译器为 x86 版本，输出文件为 amd64。</li></ul>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>继承自QWidget的控件无法应用QSS样式</title>
      <link href="/post/10890071.html"/>
      <url>/post/10890071.html</url>
      
        <content type="html"><![CDATA[<p>这是一个老生常谈的问题，在使用Qt进行界面开发时，我们经常会继承自QWidget来实现自定义控件，此时我们发现在该自定义控件上应用QSS样式会无效。</p><span id="more"></span><p>导致这个问题的主要原因是QWidget的paintEvent函数实现为空，未做任何绘制（包含样式表的初始化和绘制），其代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解决这个问题也比较简单，在QWidget子类的paintEvent函数中初始化并绘制样式表：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CustomWidget::paintEvent</span><span class="params">(QPaintEvent* e)</span> </span>{</span><br><span class="line">    QStyleOption opt;</span><br><span class="line">    opt.<span class="built_in">init</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="built_in">style</span>()-&gt;<span class="built_in">drawPrimitive</span>(QStyle::PE_Widget, &amp;opt, &amp;p, <span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当然我们也可以采用变通的方法，改为继承自<code>QFrame</code>，因此QFrame默认初始化和绘制了样式表，其代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QFrame::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">QPainter <span class="title">paint</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="built_in">drawFrame</span>(&amp;paint);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \internal</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Used by QLabel and QLCDNumber</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QFrame::drawFrame</span><span class="params">(QPainter *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QStyleOptionFrame opt;</span><br><span class="line">    <span class="built_in">initStyleOption</span>(&amp;opt);</span><br><span class="line">    <span class="built_in">style</span>()-&gt;<span class="built_in">drawControl</span>(QStyle::CE_ShapedFrame, &amp;opt, p, <span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++的API设计规范</title>
      <link href="/post/128186902.html"/>
      <url>/post/128186902.html</url>
      
        <content type="html"><![CDATA[<p>《C++ API 设计》是一本非常不错的书，该书内容远远超过了它标题所指的 C++ API 设计，它不仅仅讲述了与编程语言无关的 API 设计需要遵循的一些规范，同时也介绍了很多 C++开发中需要遵守一些准则，如果在开发中能遵循这些准则，将有利于我们写出高质量的代码。</p><span id="more"></span><p>读罢该书，受益匪浅，本文将该书中我认为比较受用的部分摘录下来。</p><ul><li><p>只有两种编程语言：一种是天天挨骂的，另一种是没人用的。</p></li><li><p>良好的 API 设计的首要目标是：在为客户提供所需功能的前提下，使用新发布的 API 对客户的代码造成的影响应该最小，理想的情况下应该是零影响。</p></li><li><p>C++ 没有包私有的概念，而是使用更加宽泛的友元的概念，以允许指定的类和方法访问某个类的受保护的和私有的成员。虽然友元可以用来加强封装，但是如果使用不当，它会向用户暴露过多的内部细节。</p></li><li><p>类的数据成员应该始终声明为私有的，而不是公有的或受保护的。</p></li><li><p>类只应该定义做什么，而不是怎么做。不要将某一个功能的具体实现步骤暴露出来，即便定义为私有的，也尽量不要这样做。可以使用<code>Pimpl</code>技巧来将所有的私有数据成员和函数隔离到一个.cpp 文件中独立实现的类或结构体内。</p></li><li><p>不要过度承诺。当不确定是否需要某个接口时，就不要提供此接口。谨记奥卡姆（Occam）剃刀原理：若无必要，勿增实体。</p></li><li><p>谨慎添加虚函数，使用虚函数要意识到其潜在的隐患：</p><ol><li>对基类看似无害的修改可能会给客户带来不利的影响。</li><li>客户可能会以你根本无法预料的方式来使用 API。</li><li>客户可能采用不正确的或易于出错的方式来扩展 API。</li><li>重写虚函数可能破坏类的内部原有逻辑的完整性。</li></ol></li><li><p>使用虚函数要注意的方面：</p><ol><li>虚函数的调用必须在运行时查虚函数表才能决定，无法在编译时决定。</li><li>使用虚函数需要维护虚函数表指针，进而增加对象的大小。</li><li>添加、重排或者移除虚函数会破坏二进制兼容性。因为虚函数调用通常用类的虚函数表的整型偏移量来表示，所以改变虚函数的顺序，或者执行可能会引起其他虚函数的顺序发送变化的操作，都需要重新编译现有代码。</li><li>如果类包含了任一虚函数，那么必须将析构函数声明为虚函数。这样子类就可以释放其可能申请的额外资源。</li><li>绝不在构造函数或析构函数中调用虚函数，这些调用不会指向之类。</li></ol></li><li><p>Sutter 建议接口应该是非虚的，同时在适当的情况下使用模板方法设计模式。</p></li><li><p><strong>给出清晰的、描述性强的且恰当的名字是 API 设计中最困难的任务之一。</strong></p></li><li><p>避免编写拥有多个相同类型参数的函数。</p></li><li><p>使用一致的（统一规范）函数命令和参数顺序。</p></li><li><p>API 接口应该是平台独立的。不要将平台相关的<code>#if</code>或<code>#ifdef</code>语句放在公共的 API 中，因为这些语句暴露了实现的细节，并使 API 因平台而异。</p></li><li><p>优秀的 API 表现为松耦合和高内聚。</p></li><li><p>除非确实需要<code>#include</code>类的完整定义，否则应该为类使用前置声明。</p></li><li><p>通常，优秀的软件工程实践的目标是去除冗余，即确保每个重要的知识点或行为有且仅有一次实现。而代码复用意味着耦合，因此略微的增加重复以断绝过分的耦合关系有时是值得的。</p></li></ul><blockquote><p>《C++ API 设计》[美] Martin Reddy 著；刘晓娜，臧秀涛，林健 译</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ⑧ 软件架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核对象</title>
      <link href="/post/14744864.html"/>
      <url>/post/14744864.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是内核对象"><a href="#一、什么是内核对象" class="headerlink" title="一、什么是内核对象"></a>一、什么是内核对象</h2><p>我们在 windows 开发中经常会遇到内核对象，如事件(Event)，管道(Pipe)，互斥量(Mutex)，完成端口(IOCP)，进程(Process)，线程(Thread)等，他们都是内核对象。这些内核对象虽然通过不同的系统 API 来创建，但这些 API 都有一个共同特点，就是都需要传入<code>SECURITY_ATTRIBUTES</code>安全描述符结构体指针，并且返回句柄(HANDLE)。依据这个特点，我们有一个简单方法来判断对象是否是内核对象，就是看创建它的函数是否允许传入<code>SECURITY_ATTRIBUTES</code>安全描述符。</p><span id="more"></span><h2 id="二、内核对象的创建"><a href="#二、内核对象的创建" class="headerlink" title="二、内核对象的创建"></a>二、内核对象的创建</h2><p>大多数创建内核对象的系统 API 函数，如 CreateEvent, CreateMutex, CreateThread, CreateProcess, CreatePipe, CreateNamedPipe 等都会返回一个 HANDLE（无论是以返回值的形式，还是以指针参数的形式返回），创建内核对象成功时 HANDLE 为<code>非NULL</code>，我们可以通过将 HANDLE 的值与 NULL 进行比较，来判断函数是否执行成功。但是有些函数比较例外，如<code>CreateFile</code>，这些函数执行失败时，返回的<code>HANDLE</code>的值为<code>INVALID_HANDLE_VALUIE</code>。</p><p>相关文章：<a href="/post/3906615635.html" title="由HANDLE返回值不确定性引发的思考">由HANDLE返回值不确定性引发的思考</a></p><h2 id="三、内核对象的访问"><a href="#三、内核对象的访问" class="headerlink" title="三、内核对象的访问"></a>三、内核对象的访问</h2><p><strong>虽然内核对象属于系统内核，但创建函数返回的<code>HANDLE</code>句柄却只和当前进程有关，离开了当前进程这个句柄也就失去了意义。</strong><br>内核对象属于系统内核级别，为了系统安全性，Windows 不允许我们直接访问内核对象的内存区域，只允许我们通过 Windows 提供的一系列 API 来访问内核对象，如<code>SetEvent</code>, <code>ResetEvent</code>等等，使用这些函数时我们都会用到<code>HANDLE</code>，windows 头文件中<code>HANDLE</code>的定义如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *HANDLE;</span><br></pre></td></tr></tbody></table></figure><p>虽然定义为<code>void*</code>类型，但很显然这个<code>HANDLE</code>不是指向内核对象的指针。</p><blockquote><p>如何证明 HANDLE 不是指向内核对象的指针？<br>一方面直接执行内核对象毫无安全性可言；<br>另一方面内核对象保存在内核地址空间（32 位系统是<code>0x80000000 到 0xFFFFFFFF</code>，64 位系统是<code>0x00000040 00000000到0xFFFFFFFF FFFFFFFF</code>），我们可以调用类似<code>CreateEvent</code>的函数创建一个内核对象，观察其返回的 HANDLE，明显不在内核地址空间的范围内，且值一般比较小。</p></blockquote><p>那么这个<code>HANDLE句柄</code>是如何与内核对象关联起来的了？答案是：<strong>进程的句柄表。</strong><br>每个进程在初始化的时候，系统都会为它分配一个句柄表(Windows 没有提供官方的文档来介绍句柄表)，参考《Windows 核心编程》得知句柄表的结构，如图：</p><table><thead><tr><th>索引</th><th>指向内核对象内存块的指针</th><th>访问掩码</th><th>标志</th></tr></thead><tbody><tr><td>1</td><td>0x????????</td><td>0x????????</td><td>0x????????</td></tr><tr><td>2</td><td>0x????????</td><td>0x????????</td><td>0x????????</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>如我们调用类似<code>CreateEvent</code>的函数返回的句柄<code>HANDLE</code>就是句柄表中的<code>索引</code>。因为是<code>索引</code>，所以它的值一般比较小。我们向 windows API 函数传入这个<code>索引</code>，API 再通过<code>索引</code>找到对应的<code>内核对象指针</code>。</p><h2 id="四、内核对象的销毁"><a href="#四、内核对象的销毁" class="headerlink" title="四、内核对象的销毁"></a>四、内核对象的销毁</h2><h3 id="4-1-引用计数"><a href="#4-1-引用计数" class="headerlink" title="4.1 引用计数"></a>4.1 引用计数</h3><p><strong>内核对象的所有者是操作系统内核，而不是创建它的进程。</strong></p><p>多个进程可以引用（使用）同一个内核对象，操作系统使用了计数器的方式来管理内核对象（这个和 C++中的<code>std::shared_ptr</code>智能指针类似），一个内核对象其实有两个计数器：一个是给用户态(Ring3)用的句柄计数；另一个是指针计数，也叫引用计数，因为核心态程序(Ring0)也经常用到内核对象，为了使用方便，在核心态的代码用指针直接访问对象，所以内核对象的管理器也维护了这个指针引用计数。只有在内核对象的<code>句柄计数</code>和<code>引用计数</code>都为 0 时，该内核对象才被释放。一般而言，指针引用计数值比句柄计数值大。</p><h3 id="4-2-正确的销毁方式"><a href="#4-2-正确的销毁方式" class="headerlink" title="4.2 正确的销毁方式"></a>4.2 正确的销毁方式</h3><p>当程序不再使用内核对象时，需要调用<code>CloseHandle</code>将内核对象的计数减 1，这样系统内核在该对象计数为 0 时（也就是没有被任何东西引用时）将销毁该对象。 <strong>并且在调用<code>CloseHandle</code>之后，程序还应该将<code>HANDLE</code>置为<code>NULL</code>。</strong></p><p>如果<code>CloseHandle</code>之后不将<code>HANDLE</code>置为<code>NULL</code>，反而再次使用该<code>HANDLE</code>，就会出现 2 种情况：</p><ol><li><p>进程句柄表中该<code>HANDLE</code>所在的索引项的记录已经被清除，且没有别的线程再次在该索引创建记录项，若此时使用这个过期的<code>HANDLE</code>调用 Win32 API 函数，Windows 会返回无效参数错误。这种情况还比较好调试。</p></li><li><p>进程句柄表中该<code>HANDLE</code>所在的索引项的记录同样也已经被清除，但已经有别的线程（该进程中的其他线程）在该<code>索引</code>位置创建了记录项，若此时使用这个过期的<code>HANDLE</code>调用 Win32 API 函数，该<code>HANDLE</code>就会引用到其他线程新建的那个内核对象，从而出现一些难以预料的错误。这种错误很难调试。</p></li></ol><h3 id="4-3-获取内核对象的引用计数"><a href="#4-3-获取内核对象的引用计数" class="headerlink" title="4.3 获取内核对象的引用计数"></a>4.3 获取内核对象的引用计数</h3><p>虽然 windows 没有提供 API 让用户在用户态（Ring3）查询一个内核对象的句柄计数和引用计数，但我们可以从<code>Ntdll.dll</code>导出<code>NtQueryObject</code>函数来实现查询内核对象的当前状态(该函数没有被文档化)。</p><p><code>NtQueryObject</code>函数声明如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值：如果成功则返回0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">NtQueryObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE   handle,       <span class="comment">// 待查询的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">DWORD   nQueryIndex,   <span class="comment">// 0为查询对象的当前状态，包括句柄计数，引用计数等等。</span></span></span></span><br><span class="line"><span class="params"><span class="function">VOID*   pOutBuffer,    <span class="comment">// 存放查询结果</span></span></span></span><br><span class="line"><span class="params"><span class="function">DWORD   cbInBufferSize,   <span class="comment">// pOutBuffer的大小，如果nQueryIndex为0，这里为sizeof(SYSTEM_HANDLE_STATE)</span></span></span></span><br><span class="line"><span class="params"><span class="function">VOID*   cbOutBufferSize   <span class="comment">// 实际大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>将<code>NtQueryObject</code>函数调用的细节封装到<code>GetKernelObjectRefCount</code>函数中，方便使用：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetKernelObjectRefCount</span><span class="params">(HANDLE handle, DWORD &amp;handle_count, DWORD &amp;point_count)</span> </span>{</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_HANDLE_STATE</span> {</span><br><span class="line">    DWORD   r1;</span><br><span class="line">    DWORD   GrantedAccess;</span><br><span class="line">    DWORD   HandleCount;      <span class="comment">// 减1为句柄计数</span></span><br><span class="line">    DWORD   ReferenceCount;   <span class="comment">// 减1为指针引用计数</span></span><br><span class="line">    DWORD   r5;</span><br><span class="line">    DWORD   r6;</span><br><span class="line">    DWORD   r7;</span><br><span class="line">    DWORD   r8;</span><br><span class="line">    DWORD   r9;</span><br><span class="line">    DWORD   r10;</span><br><span class="line">    DWORD   r11;</span><br><span class="line">    DWORD   r12;</span><br><span class="line">    DWORD   r13;</span><br><span class="line">    DWORD   r14;</span><br><span class="line">  }SYSTEM_HANDLE_STATE, *PSYSTEM_HANDLE_STATE;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI *PFN_NtQueryObject)</span><span class="params">(HANDLE handle,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD nQueryIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">    VOID* pOutBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD cbInBufferSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    VOID* cbOutBufferSize)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> PFN_NtQueryObject pfnNtQueryObject = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> {</span><br><span class="line">    <span class="keyword">if</span> (pfnNtQueryObject == <span class="literal">NULL</span>) {</span><br><span class="line">      HMODULE ntdll = <span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">"Ntdll.dll"</span>));</span><br><span class="line">      <span class="keyword">if</span> (ntdll == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      pfnNtQueryObject = (PFN_NtQueryObject)<span class="built_in">GetProcAddress</span>(ntdll, <span class="string">"NtQueryObject"</span>);</span><br><span class="line">      <span class="keyword">if</span> (pfnNtQueryObject == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    SYSTEM_HANDLE_STATE sys_handle_state;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sys_handle_state, <span class="number">0</span>, <span class="built_in">sizeof</span>(SYSTEM_HANDLE_STATE));</span><br><span class="line"></span><br><span class="line">    DWORD out_buf_size = <span class="number">0</span>;</span><br><span class="line">    ret = (<span class="built_in">pfnNtQueryObject</span>(handle, <span class="number">0</span>, &amp;sys_handle_state, <span class="built_in">sizeof</span>(SYSTEM_HANDLE_STATE), &amp;out_buf_size) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) {</span><br><span class="line">      handle_count = sys_handle_state.HandleCount - <span class="number">1</span>;</span><br><span class="line">      point_count = sys_handle_state.ReferenceCount - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="五、内核对象跨进程访问"><a href="#五、内核对象跨进程访问" class="headerlink" title="五、内核对象跨进程访问"></a>五、内核对象跨进程访问</h2><p>虽然内核对象位于独立于进程之外的内核区域，我们在开发中却只能通过调用 Win32 API 传入 HANDLE 参数来操作内核对象（如<code>SetEvent</code>等）。然而<code>HANDLE句柄</code>只对当前进程有效，离开了当前进程该句柄就无效了。所以说，跨进程访问内核对象的关键在于我们怎么跨进程访问<code>句柄HANDLE</code>？</p><p>下面介绍几种方法来实现跨进程共享内核对象。</p><h3 id="5-1-使用句柄继承的方式"><a href="#5-1-使用句柄继承的方式" class="headerlink" title="5.1 使用句柄继承的方式"></a>5.1 使用句柄继承的方式</h3><p>只有进程之间有父子关系时，才可以使用句柄继承的方式。在这种情况下，父进程可以生成一个子进程，并允许子进程访问父进程的内核对象。为了使这种继承生效，父进程必须执行几个步骤：<br>（1）. 父进程在创建一个内核对象时，父进程必须向系统指定它希望这个内核对象的句柄是可以继承的。为了创建一个可继承的内核对象，必须分配并初始化一个<code>SECURITY_ATTRIBUTES</code>结构，如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SECURITY_ATTRIBUTES sa;</span><br><span class="line">sa.nLength = <span class="built_in">sizeof</span>(SECURITY_ATTRIBUTES);</span><br><span class="line">sa.bInheritHandle = TRUE;  <span class="comment">// 可继承的</span></span><br><span class="line">sa.lpSecurityDescriptor = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">HANDLE h = <span class="built_in">CreateEvent</span>(&amp;sa, TRUE, FALSE, <span class="literal">NULL</span>);</span><br></pre></td></tr></tbody></table></figure><p>（2）. 父进程通过 CreateProcess 生成子进程，且指定<code>bInheritHandles</code>为 TRUE，从而允许子进程来继承父进程的那些“可继承的句柄”。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动子进程TestB.exe，将句柄h作为启动参数传给进程TestB</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">TCHAR cmd_buf[MAX_PATH];</span><br><span class="line"><span class="built_in">StringCchPrintf</span>(cmd_buf, MAX_PATH, <span class="built_in">TEXT</span>(<span class="string">"TestB.exe %ld"</span>), (<span class="type">long</span>)h);</span><br><span class="line"></span><br><span class="line">STARTUPINFO si = { <span class="built_in">sizeof</span>(si) };</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line">BOOL ret = <span class="built_in">CreateProcess</span>(</span><br><span class="line">  <span class="literal">NULL</span>,</span><br><span class="line">  cmd_buf,</span><br><span class="line">  <span class="literal">NULL</span>,</span><br><span class="line">  <span class="literal">NULL</span>,</span><br><span class="line">  TRUE,  <span class="comment">// 指定子进程可以继承父进程的“可继承句柄”</span></span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="literal">NULL</span>,</span><br><span class="line">  <span class="literal">NULL</span>,</span><br><span class="line">  &amp;si,</span><br><span class="line">  &amp;pi</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line"><span class="built_in">CloseHandle</span>(pi.hThread);</span><br></pre></td></tr></tbody></table></figure><p>由于我们传给<code>bInheritHandles</code>参数的值是<code>TRUE</code>，所以系统在创建子进程时会多做一件事情：它会遍历父进程的句柄表，对它的每一项进行检查，凡是包含一个有效的“可继承的句柄”的项，都会将该项完整的复制到子进程的句柄表。在子进程的句柄表中，复制项的位置与它在父进程句柄表中的位置完全一样（包含索引），这个就意味着：在父进程和子进程中，对一个内核对象进行标识的句柄值也是完全一样的。所以我们只需要通过某种方式（如上面示例中的启动参数的方式，或者环境变量的方式等任何进程间通讯的方式）将这个值告诉子进程，子进程就可以将该值转成<code>HANDLE</code>，然后使用这个<code>HANDLE</code>来调用系统 API。</p><h3 id="5-2-使用-DuplicateHandle-方式"><a href="#5-2-使用-DuplicateHandle-方式" class="headerlink" title="5.2 使用 DuplicateHandle 方式"></a>5.2 使用 DuplicateHandle 方式</h3><p>DuplicateHandle 函数可以将指定“源进程的句柄表”中的某一项<strong>复制</strong>到“目的进程句柄表”中（除了索引），并且返回该项在目的进程句柄表中的索引（即 HADNLE）。<br>可以在任何时候调用 DuplicateHandle 函数，DuplicateHandle 对源句柄是否是可继承的没有要求。</p><p>函数声明如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DuplicateHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hSourceProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hSourceHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hTargetProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPHANDLE lpTargetHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bInheritHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwOptions</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>DuplicateHandle 详细介绍可以参考 MSDN：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724251(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms724251(v=vs.85).aspx</a></p></blockquote><p>DuplicateHandle 函数不能复制所有类型的句柄，只能复制如下类型的句柄（从 MSDN 复制而来）：</p><table><thead><tr><th>Object</th><th>Description</th></tr></thead><tbody><tr><td>Access token</td><td>The handle is returned by the CreateRestrictedToken, DuplicateToken, DuplicateTokenEx, OpenProcessToken, or OpenThreadToken function.</td></tr><tr><td>Change notification</td><td>The handle is returned by the FindFirstChangeNotification function.</td></tr><tr><td>Communications device</td><td>The handle is returned by the CreateFile function.</td></tr><tr><td>Console input</td><td>The handle is returned by the CreateFile function when CONIN$ is specified, or by the GetStdHandle function when STD_INPUT_HANDLE is specified. Console handles can be duplicated for use only in the same process.</td></tr><tr><td>Console screen buffer</td><td>The handle is returned by the CreateFile function when CONOUT$ is specified, or by the GetStdHandle function when STD_OUTPUT_HANDLE is specified. Console handles can be duplicated for use only in the same process.</td></tr><tr><td>Desktop</td><td>The handle is returned by the GetThreadDesktop function.</td></tr><tr><td>Event</td><td>The handle is returned by the CreateEvent or OpenEvent function.</td></tr><tr><td>File</td><td>The handle is returned by the CreateFile function.</td></tr><tr><td>File mapping</td><td>The handle is returned by the CreateFileMapping function.</td></tr><tr><td>Job</td><td>The handle is returned by the CreateJobObject function.</td></tr><tr><td>Mailslot</td><td>The handle is returned by the CreateMailslot function.</td></tr><tr><td>Mutex</td><td>The handle is returned by the CreateMutex or OpenMutex function.</td></tr><tr><td>Pipe</td><td>A named pipe handle is returned by the CreateNamedPipe or CreateFile function. An anonymous pipe handle is returned by the CreatePipe function.</td></tr><tr><td>Process</td><td>The handle is returned by the CreateProcess, GetCurrentProcess, or OpenProcess function.</td></tr><tr><td>Registry key</td><td>The handle is returned by the RegCreateKey, RegCreateKeyEx, RegOpenKey, or RegOpenKeyEx function. Note that registry key handles returned by the RegConnectRegistry function cannot be used in a call to DuplicateHandle.</td></tr><tr><td>Semaphore</td><td>The handle is returned by the CreateSemaphore or OpenSemaphore function.</td></tr><tr><td>Thread</td><td>The handle is returned by the CreateProcess, CreateThread, CreateRemoteThread, or GetCurrentThread function</td></tr><tr><td>Timer</td><td>The handle is returned by the CreateWaitableTimer or OpenWaitableTimer function.</td></tr><tr><td>Transaction</td><td>The handle is returned by the CreateTransaction function.</td></tr><tr><td>Window station</td><td>The handle is returned by the GetProcessWindowStation function.</td></tr></tbody></table><p>不同的事件类型对应的<code>dwDesiredAccess</code>参数不同，具体参考<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724251(v=vs.85).aspx">MSDN</a>。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>进程 TestA 源码</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>{</span><br><span class="line">  HANDLE h = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, TRUE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动子进程TestB.exe</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  TCHAR cmd_buf[MAX_PATH];</span><br><span class="line">  <span class="built_in">StringCchPrintf</span>(cmd_buf, MAX_PATH, <span class="built_in">TEXT</span>(<span class="string">"D:\\TestB.exe"</span>), (<span class="type">long</span>)h);</span><br><span class="line"></span><br><span class="line">  STARTUPINFO si = { <span class="built_in">sizeof</span>(si) };</span><br><span class="line">  PROCESS_INFORMATION pi;</span><br><span class="line">  BOOL ret = <span class="built_in">CreateProcess</span>(<span class="literal">NULL</span>, cmd_buf, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line">  <span class="built_in">assert</span>(ret);</span><br><span class="line">  <span class="built_in">assert</span>(pi.hProcess);</span><br><span class="line"></span><br><span class="line">  HANDLE duplicated_h = <span class="literal">NULL</span>;</span><br><span class="line">  ret = <span class="built_in">DuplicateHandle</span>(<span class="built_in">GetCurrentProcess</span>(), h, pi.hProcess, &amp;duplicated_h, <span class="number">0</span>, FALSE, DUPLICATE_SAME_ACCESS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">WaitForSingleObject</span>(pi.hProcess, INFINITE);</span><br><span class="line">  <span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">  <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> has_signal = <span class="built_in">WaitForSingleObject</span>(h, <span class="number">0</span>) == WAIT_OBJECT_0;</span><br><span class="line">  <span class="built_in">assert</span>(has_signal == <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>子进程 TestB 源码</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">long</span> l = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Input Handle:"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;l);</span><br><span class="line"></span><br><span class="line">  HANDLE h = (HANDLE)l;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> has_signal = <span class="built_in">WaitForSingleObject</span>(h, <span class="number">0</span>) == WAIT_OBJECT_0;</span><br><span class="line">  <span class="built_in">assert</span>(has_signal == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SetEvent</span>(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在父进程 TestA 中创建一个不可继承的事件 -&gt; 然后启动子进程 TestB -&gt; 调用 DuplicateHandle 复制句柄项到 TestB 进程句柄表 -&gt; 并向 TestB 输入句柄值 -&gt; TestB 访问该事件句柄，将事件置为有信号状态。</p><h3 id="5-3-使用命名的内核对象的方式"><a href="#5-3-使用命名的内核对象的方式" class="headerlink" title="5.3 使用命名的内核对象的方式"></a>5.3 使用命名的内核对象的方式</h3><h4 id="5-3-1-实现原理"><a href="#5-3-1-实现原理" class="headerlink" title="5.3.1 实现原理"></a>5.3.1 实现原理</h4><p>这种方式严格的说已经不是文章开头说到的跨进程访问句柄了，有点类似跨进程直接访问内核对象了。<br>该方式实现起来比较简单，就是在调用创建内核对象的<code>Create***</code>函数时，通过<code>pszName</code>参数为内核对象取一个名字。<br>如创建事件 Event 的函数<code>CreateEvent</code>：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpEventAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bManualReset,</span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bInitialState,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpName  <span class="comment">// 指定名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE h = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, TRUE, FALSE, <span class="built_in">TEXT</span>(<span class="string">"TestA_Obj"</span>));</span><br></pre></td></tr></tbody></table></figure><p>若在其他进程中要访问这个内核对象，只需要使用打开函数<code>Open***</code>打开该内核对象，<strong>系统就会在进程的句柄表中插入一条记录，并返回这条记录的索引，也就是句柄</strong>。需要注意的是，在打开内核对象时需要留意<code>返回值</code>和<code>GetLastError</code>函数的返回值。由于内核对象是有访问权限的，有时候虽然这个名字的内核对象存在，但该进程却不见得有权限可以打开它，这个时候<code>GetLastError</code>函数会返回失败的原因。</p><p>以打开事件的函数<code>OpenEvent</code>为例：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE h = <span class="built_in">OpenEvent</span>(READ_CONTROL, FALSE, <span class="built_in">TEXT</span>(<span class="string">"TestA_Obj"</span>));</span><br><span class="line"><span class="keyword">if</span> (h == <span class="literal">NULL</span>) {</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == ERROR_ACCESS_DENIED) { <span class="comment">// 没有READ_CONTROL权限</span></span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="5-3-2-全局命令空间"><a href="#5-3-2-全局命令空间" class="headerlink" title="5.3.2 全局命令空间"></a>5.3.2 全局命令空间</h4><p>不同的会话（Session）有不同的内核对象命名空间（如 windows 服务程序位于<code>Session 0</code>，而普通的用户进程位于<code>Session 1</code>），要通过名称访问其他会话中的内核对象，需要在名称前面加上<code>Session\&lt;当前会话ID&gt;</code>。Windows 提供了一个全局的内核对象命名空间，处于任何会话中的进程都可以访问该命名空间，将内核对象放入全局命令空间的方式很简单：只需要在内核对象名称前加入<code>Global\</code>即可。</p><p>如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE h = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, TRUE, FALSE, <span class="built_in">TEXT</span>(<span class="string">"Global\\TestA_Obj"</span>));</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++实现编译时断言</title>
      <link href="/post/4155207961.html"/>
      <url>/post/4155207961.html</url>
      
        <content type="html"><![CDATA[<p>C++自 C++11 起支持 static_assert 编译时断言，如：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static_assert ( bool_constexpr , message )    (C++11 起)</span><br><span class="line">static_assert ( bool_constexpr )    (C++17 起)</span><br></pre></td></tr></tbody></table></figure><p>若编译器不支持 C++11（经测试 VS2010 已经支持<code>static_assert</code>），可以使用下面方式来实现编译断言：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COMPILE_ASSERT(expression) switch (0) {case 0: case expression:;}</span></span><br></pre></td></tr></tbody></table></figure><p>使用方法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">COMPILE_ASSERT</span>(<span class="number">1</span> != <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ② C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows注入与拦截(3)--挂载窗口到目标控件</title>
      <link href="/post/2804470458.html"/>
      <url>/post/2804470458.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍如何通过 DLL 注入的方式来实现在指定窗口的控件上挂载一个自定义窗口。</p><blockquote><p>何谓挂载？和舰载机挂载导弹类似，将我们自己的窗口挂到原有程序的窗口之上，可以实现对原有窗口功能的覆盖和扩展。</p></blockquote><span id="more"></span><h1 id="一、挂载的原理"><a href="#一、挂载的原理" class="headerlink" title="一、挂载的原理"></a>一、挂载的原理</h1><p>挂载的实现过程如下：</p><ol><li>通过远程线程的方式（其他方式也可以）将 DLL 注入到指定的进程（当然是被挂载窗口所属的进程）。</li><li>在<code>DllMain</code>的<code>DLL_PROCESS_ATTACH</code>条件分支中创建一个新线程 NewThread，后面的处理逻辑将放到 NewThread 中，防止<code>DllMain</code>阻塞。</li><li>在 NewThread 线程中查找被挂载的<strong>窗口</strong>（注意是窗口不是窗口上的控件）的句柄（查找方式：<code>EnumWindows</code>结合<code>FindWindowEx</code>实现，详见<code>FindProcessWindow</code>函数）。</li><li>使用<code>SetWindowLong</code>修改窗体的默认的消息处理过程（假设将窗口处理过程修改为我们 DLL 中的<code>WndProc_Trampoline</code>函数），然后向窗体发送一个自定义消息，这时<code>WndProc_Trampoline</code>函数就可以获取到该消息通知，我们在收到该消息通知后就可以开始我们的挂载逻辑了。之所以要通过发送一个自定义消息的方式来做，而不是直接在新线程 NewThread 中开始我们的挂载逻辑，是因为这样做可以保证我们的挂载逻辑（如创建窗口）是在主线程中进行的。</li><li>挂载逻辑主要包含：查找需要挂载<strong>控件</strong>的句柄、创建挂载窗口。创建挂载窗口的时候要设置<code>WS_CHILD</code>子窗口属性，并设置父窗体的<code>WS_CLIPCHILDREN</code>属性来裁剪子窗口，防止我们挂载的子窗口闪烁。</li><li>在<code>WndProc_Trampoline</code>函数的最后不要忘记调用之前老的消息处理过程，否则原窗口的消息将无法得到正确的响应。</li></ol><h1 id="二、实例代码"><a href="#二、实例代码" class="headerlink" title="二、实例代码"></a>二、实例代码</h1><h2 id="2-1-DllInjecter-工程"><a href="#2-1-DllInjecter-工程" class="headerlink" title="2.1 DllInjecter 工程"></a>2.1 DllInjecter 工程</h2><p><code>DllInjecter.exe</code>实现将 DLL 注入到指定的进程之中，该 exe 是一个通用的 DLL 注入器。包含了对前面文章介绍的“使用远程线程的方式注入”和“使用钩子方式注入”这两种注入方式的实现。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-zhuru-lanjie-1.jpg"></p><h2 id="2-2-Test-工程"><a href="#2-2-Test-工程" class="headerlink" title="2.2 Test 工程"></a>2.2 Test 工程</h2><p><code>Test.exe</code>是一个模拟的被挂载程序，程序非常简单，只包含一个窗体和大按钮，不包含任何逻辑。本实例主要是将我们的窗口挂载到这个大按钮之上。<br>挂载前如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-zhuru-lanjie-3.jpg"></p><p>挂载后效果如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-zhuru-lanjie-2.jpg"></p><h2 id="2-3-Troy-工程"><a href="#2-3-Troy-工程" class="headerlink" title="2.3 Troy 工程"></a>2.3 Troy 工程</h2><p><code>Troy.dll</code>就是被注入到<code>Test.exe</code>中的 DLL 文件（名称来源于“特洛伊木马”）。挂载的主要逻辑大都在该工程之中。</p><p>在<code>WndProc_Trampoline</code>函数的<code>WUM_CREATE_USER_WINDOW</code>消息处理分支中<code>CreateUserWindowByDuilib</code>函数来创建挂载窗口，<code>CreateUserWindowByDuilib</code>使用<code>duilib</code>界面库来创建挂载窗口。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc_Trampoline</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>{</span><br><span class="line">  <span class="keyword">switch</span> (message) {</span><br><span class="line">  <span class="keyword">case</span> WUM_CREATE_USER_WINDOW:</span><br><span class="line">    <span class="built_in">CreateUserWindowByDuilib</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">CallWindowProc</span>(g_oldProc, hwnd, message, wParam, lParam);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> __stdcall <span class="title">PluginProc</span><span class="params">(LPVOID pArg)</span> </span>{</span><br><span class="line">  <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">"我已经被注入啦"</span>), <span class="built_in">TEXT</span>(<span class="string">"信息"</span>), MB_OK | MB_ICONASTERISK);</span><br><span class="line"></span><br><span class="line">  HWND hMainWindow = InjectHelper::<span class="built_in">FindProcessWindow</span>(<span class="built_in">GetCurrentProcessId</span>(), <span class="built_in">TEXT</span>(<span class="string">"#32770"</span>), <span class="built_in">TEXT</span>(<span class="string">"Test"</span>), TRUE);</span><br><span class="line"></span><br><span class="line">  g_oldProc = (WNDPROC)<span class="built_in">SetWindowLong</span>(hMainWindow, DWL_DLGPROC, (LONG)WndProc_Trampoline);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ::<span class="built_in">PostMessage</span>(hMainWindow, WUM_CREATE_USER_WINDOW, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved)</span> </span>{</span><br><span class="line">  HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(fdwReason) {</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        {</span><br><span class="line">      g_hDllModule = hModule;</span><br><span class="line">      <span class="comment">// 使用注册表方式和CreateRemoteThread方式注入时，一般在此处创建线程</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">      hThread = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, PluginProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">if</span> (hThread) {</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hThread); <span class="comment">// 关闭句柄，防止句柄泄漏</span></span><br><span class="line">      }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>完整的示例代码见：<a href="https://github.com/winsoft666/InjectSample">https://github.com/winsoft666/InjectSample</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows注入与拦截 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>理解C/C++运行时库</title>
      <link href="/post/782629701.html"/>
      <url>/post/782629701.html</url>
      
        <content type="html"><![CDATA[<p>运行时库（Runtime library）通俗的说就是我们的程序运行的时候所依赖的库文件。在 Windows 平台，这些库由微软提供，并以 2 种形式提供：<code>静态库(lib)</code>、<code>动态库(lib+dll)</code>，每个库还分别提供了 Debug 和 Release 两个版本。</p><span id="more"></span><h2 id="一、什么是运行时库"><a href="#一、什么是运行时库" class="headerlink" title="一、什么是运行时库"></a>一、什么是运行时库</h2><p>C/C++运行时库从形式上来讲和我们自己开发的静态库、动态库没什么两样，只是它们由微软开发和维护，并提供了一些常用的功能支持（如<code>malloc</code>,<code> free</code>, <code>printf</code>等等），如果我们的程序需要使用这些功能（事实上，只要是 C/C++程序就一定会用到运行时库提供的功能），就要链接 C/C++运行时库。我们可以自主选择是链接“静态库”还是“动态库”，是链接“debug 版本”的还是“release 版本”的。</p><h2 id="二、如何链接运行时库"><a href="#二、如何链接运行时库" class="headerlink" title="二、如何链接运行时库"></a>二、如何链接运行时库</h2><p>大家可能注意到我们在平时开发中从来没有显式的来链接这些库，这是为什么了？<br>因为我们的编译器为我们提供了便利，我们只需要向编译器指定特定的编译选项（如<code>MT、MD、MTd、MDd</code>），编译器就会自动链接对应的库。</p><p>同时，编译器会根据<code>MT</code>和<code>MD</code>来定义相应的预处理宏：<code>MT</code> 对应 <code>_MT宏</code>，<code>MD</code>对应<code>_MD宏</code>。</p><p>例如，我们通过<code>Visual Studio</code>开发 C/C++程序时，在工程属性中配置“运行库”为<code>MT、MD、MTd、MDd</code>中的一个：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-hxbc-ljynsk-1.jpg"><br>就相当于间接的向编译器指定编译选项和定义相应的宏。</p><h2 id="三、不同版本和形态的运行时库"><a href="#三、不同版本和形态的运行时库" class="headerlink" title="三、不同版本和形态的运行时库"></a>三、不同版本和形态的运行时库</h2><h3 id="3-1-运行时库对应的文件"><a href="#3-1-运行时库对应的文件" class="headerlink" title="3.1 运行时库对应的文件"></a>3.1 运行时库对应的文件</h3><p>下表列出各种编译选项的含义以及对应的库文件：</p><table><thead><tr><th>类型</th><th>全称</th><th>含义</th><th>对应的库文件</th><th>备注</th></tr></thead><tbody><tr><td>ML</td><td>Single-Threaded</td><td>Release 版的单线程静态库</td><td><code>libc.lib</code></td><td>从 VS2005 起被废弃</td></tr><tr><td>MLd</td><td>Single-Threaded Debug</td><td>Debug 版的单线程静态库</td><td><code>libcd.lib</code></td><td>从 VS2005 起被废弃</td></tr><tr><td>MT</td><td>Multi-threaded</td><td>Release 版的多线程静态库</td><td><code>libcmt.lib</code></td><td></td></tr><tr><td>MTd</td><td>Multi-threaded Debug</td><td>Debug 版的多线程静态库</td><td><code>libcmtd.lib</code></td><td></td></tr><tr><td>MD</td><td>Multi-threaded DLL</td><td>Release 版的多线程动态库</td><td><code>msvcrt.lib + msvcrxxx.dll</code> <code>msvcprt.lib+msvcpxxx.dll</code></td><td></td></tr><tr><td>MDd</td><td>Multi-threaded DLL Debug</td><td>Debug 版的多线程动态库</td><td><code>msvcrtd.lib + msvcrxxxd.dll</code> <code>msvcprtd.lib + msvcpxxxd.dll</code></td><td></td></tr></tbody></table><p>如果计算机上安装了多个版本的 VC++运行环境（或者多个版本的 Visual Studio），则相同名称的 lib 或 dll 就会存在多份。如<code>msvcrt.lib</code>文件：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-hxbc-ljynsk-2.jpg"></p><h3 id="3-2-运行时库文件命名规则"><a href="#3-2-运行时库文件命名规则" class="headerlink" title="3.2 运行时库文件命名规则"></a>3.2 运行时库文件命名规则</h3><p><code>msvcr100d.dll</code>为例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ms = Microsoft</span><br><span class="line">v = Visual</span><br><span class="line">c = C Program</span><br><span class="line">r = Run-time</span><br><span class="line">100 = Version</span><br><span class="line">d = Debug   (不带d即为release版本)</span><br></pre></td></tr></tbody></table></figure><p><code>msvcp100d.dll</code>为例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ms = Microsoft</span><br><span class="line">v = Visual</span><br><span class="line">cp = C Plus Plus 即C++</span><br><span class="line">100 = Version</span><br><span class="line">d = Debug   (不带d即为release版本)</span><br></pre></td></tr></tbody></table></figure><h2 id="四、运行时库使用注意事项"><a href="#四、运行时库使用注意事项" class="headerlink" title="四、运行时库使用注意事项"></a>四、运行时库使用注意事项</h2><ul><li>不要混合使用运行时库的<code>静态库版</code>和<code>动态库版</code>。</li><li>不要混合使用运行时库的<code>debug版</code>和<code>release版</code>。</li><li>不要混合使用 Visual Studio 2013 及更早版本的运行时库，但在 Visual Studio 2015 及更高版本中提供的运行时库可以保证二进制兼容。</li></ul><h2 id="五、Visual-Studio-版本之间的-C-二进制兼容性（摘自-MSDN）"><a href="#五、Visual-Studio-版本之间的-C-二进制兼容性（摘自-MSDN）" class="headerlink" title="五、Visual Studio 版本之间的 C++ 二进制兼容性（摘自 MSDN）"></a>五、Visual Studio 版本之间的 C++ 二进制兼容性（摘自 MSDN）</h2><blockquote><p>原文链接：<a href="https://learn.microsoft.com/en-us/cpp/porting/binary-compat-2015-2017?view=msvc-170">binary-compat-2015-2017</a></p></blockquote><p>Visual Studio 2013 及更早版本中的 Microsoft C++ (MSVC) 编译器工具集不保证主版本间的二进制兼容性。 无法链接由这些工具集的不同版本生成的对象文件、静态库、动态库和可执行文件。 ABI、对象格式和运行时库不兼容。</p><p>我们在 Visual Studio 2015 及更高版本中改变了此行为。 由其中任一版本的编译器编译的运行时库和应用具有二进制兼容性。 这反映在 C++ 工具集主版本号中，对于自 Visual Studio 2015 以来的所有版本，<strong>该版本号都以 14 开头</strong>。 （对于 Visual Studio 2015、2017、2019 和 2022，工具集版本分别为 v140、v141、v142 和 v143）。** 假设你具有 Visual Studio 2015 生成的第三方库。 你仍可在 Visual Studio 2017、2019 或 2022 生成的应用程序中使用它们。 无需使用匹配工具集重新编译**。 最新版本的 Microsoft Visual C++ 可再发行程序包（可再发行程序包）适用于所有版本。</p><h3 id="对二进制兼容性的限制"><a href="#对二进制兼容性的限制" class="headerlink" title="对二进制兼容性的限制"></a>对二进制兼容性的限制</h3><p>v140、v141、v142 和 v143 工具集与次要版本号更新之间的二进制兼容性方面存在三个重要限制：</p><ul><li>你可以混合使用由 v140、v141、v142 和 v143 工具集的不同版本生成的二进制文件。 但是，<strong>必须使用至少与应用中最新二进制文件同样新的工具集进行链接</strong>。 下面是一个示例：可以将使用任何 2017 工具集（v141，版本 15.0 到 15.9）编译的应用链接到使用 Visual Studio 2019 版本 16.2 (v142) 编译的静态库。 只是必须使用版本 16.2 或更高版本工具集链接它们。 只要使用 16.4 或更高版本工具集，便可以将版本 16.2 库链接到版本 16.4 应用。</li><li>应用使用的可再发行程序包具有类似的二进制兼容性限制。 混合使用由工具集的不同受支持版本生成的二进制文件时，可再发行程序包版本必须至少与任何应用组件使用的最新工具集一样新。</li><li>使用<a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/gl-whole-program-optimization?view=msvc-170">/GL</a><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/gl-whole-program-optimization?view=msvc-170">（全程序优化）</a>编译器开关编译或是使用 <a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/ltcg-link-time-code-generation?view=msvc-170">/LTCG</a><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/ltcg-link-time-code-generation?view=msvc-170">（链接时间代码生成）</a>链接的静态库或对象文件不在各个版本间二进制兼容（包括次要版本更新）。使用 <code>/GL</code> 和 <code>/LTCG</code> 编译的所有对象文件和库必须将完全相同的工具集用于编译和最终链接。 例如，使用 Visual Studio 2019 版本 16.7 工具集中的 <code>/GL</code>生成的代码无法链接到使用 Visual Studio 2019 版本 16.8 工具集中的 <code>/GL</code>生成的代码。 编译器会发出<a href="https://learn.microsoft.com/zh-cn/cpp/error-messages/compiler-errors-1/fatal-error-c1047?view=msvc-170">错误 C1047</a>。</li></ul><h3 id="从-Visual-Studio-2015-及更高版本升级-Microsoft-Visual-C-可再发行程序包"><a href="#从-Visual-Studio-2015-及更高版本升级-Microsoft-Visual-C-可再发行程序包" class="headerlink" title="从 Visual Studio 2015 及更高版本升级 Microsoft Visual C++ 可再发行程序包"></a>从 Visual Studio 2015 及更高版本升级 Microsoft Visual C++ 可再发行程序包</h3><p>对于 Visual Studio 2015、2017、2019 和 2022，我们使 Microsoft Visual C++ 可再发行程序包主版本号保持相同。 这意味着一次只能安装可再发行程序包的一个实例。 较新版本会覆盖已安装的任何较旧版本。 例如，一个应用可能会从 Visual Studio 2015 安装可再发行程序包。 随后另一个应用从 Visual Studio 2022 安装可再发行程序包。 2022 版本会覆盖较旧版本，但由于它们具有二进制兼容性，早期应用仍可正常工作。 我们确保最新版本的可再发行程序包具有所有最新的功能、安全更新和 bug 修补程序。 这便是为什么我们始终建议升级到最新可用版本。</p><p>同样，已安装了较新版本时，无法安装较旧的可再发行程序包。 如果尝试，则安装程序会报告错误。 如果在已具有 2022 版本的计算机上安装 2017 或 2019 可再发行程序，则会看到如下所示的错误：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x80070666 - Another version of this product is already installed. Installation of this version cannot continue. To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel.</span><br></pre></td></tr></tbody></table></figure><p>此错误是设计使然。 建议保持安装最新版本。 请确保安装程序可以在无提示的情况下从此错误中恢复。</p><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows注入与拦截(2)--DLL注入的方式</title>
      <link href="/post/721636578.html"/>
      <url>/post/721636578.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、使用注册表方式注入"><a href="#一、使用注册表方式注入" class="headerlink" title="一、使用注册表方式注入"></a>一、使用注册表方式注入</h1><h2 id="1-1-注入方法"><a href="#1-1-注入方法" class="headerlink" title="1.1 注入方法"></a>1.1 注入方法</h2><p>如题，通过注册表的方式来实现 DLL 注入，我们只需要针对特定的注册表项进行修改即可，有一点需要注意的是：<strong>如果被注入的进程是 64 位进程，则注入的 DLL 也需要是 64 位的，同理，注入 32 位的进程也需要是 32 位的 DLL。</strong></p><p>另外，根据被注入进程的位数（32 或 64）不同，注册表的位置也不同。</p><span id="more"></span><h3 id="1-1-1-注入-64-位系统上的-32-位进程"><a href="#1-1-1-注入-64-位系统上的-32-位进程" class="headerlink" title="1.1.1 注入 64 位系统上的 32 位进程"></a>1.1.1 注入 64 位系统上的 32 位进程</h3><ol><li>将被注入的 DLL 名称填入到<code>AppInit_DLLs</code>注册表项：</li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs</span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>AppInit_DLLs</code>中的文件名通过逗号或空格来分割，所以我们在文件名中要避免使用空格。另外<code>AppInit_DLLs</code>中的第一个文件可以包含路径，而后面的文件的路径则将被忽略。出于这个原因，我们最好将 DLL 文件放到 Windows 的系统目录中。</p></blockquote><ol start="2"><li>并将<code>LoadAppInit_DLLs</code>注册表项的值修改为<code>1</code>：</li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs</span><br></pre></td></tr></tbody></table></figure><h3 id="1-1-2-注入-64-位进程"><a href="#1-1-2-注入-64-位进程" class="headerlink" title="1.1.2 注入 64 位进程"></a>1.1.2 注入 64 位进程</h3><p>“注入到 64 位进程”和“注入 64 位系统上的 32 位进程”的步骤类似，区别在于：</p><p>1). 注册表位置不一样，注入 64 位进程的注册表分别位于：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs</span><br></pre></td></tr></tbody></table></figure><p>2). 被注入 DLL 需要是 64 位版本。</p><h2 id="1-2-为什么可以这么做？"><a href="#1-2-为什么可以这么做？" class="headerlink" title="1.2 为什么可以这么做？"></a>1.2 为什么可以这么做？</h2><p>当系统的<code>User32.dll</code>被加载到一个新的进程时，会收到<code>DLL_PROCESS_ATTACH</code>通知，<code>User32.dll</code>在该通知处理过程中读取<code>AppInit_DLLs</code>注册表值，并调用<code>LoadLibrary</code>来加载该项中指定的每个 dll。</p><h2 id="1-3-这么做有什么弊端？"><a href="#1-3-这么做有什么弊端？" class="headerlink" title="1.3 这么做有什么弊端？"></a>1.3 这么做有什么弊端？</h2><p>从上面一节我们知道被注入的 DLL 是通过<code>User32.dll</code>加载到目标进程中去的，这也就要求被注入的目标进程必须使用了<code>User32.dll</code>，基于 GUI 的程序都会使用这个 DLL 文件，而命令行程序一般不会加载<code>User32.dll</code>，所以无法通过这种方式被注入。</p><p>系统上所有使用了<code>User32.dll</code>的程序都会被注入，很多时候这也并不是我们想要的。</p><h1 id="二、使用钩子方式注入"><a href="#二、使用钩子方式注入" class="headerlink" title="二、使用钩子方式注入"></a>二、使用钩子方式注入</h1><h2 id="2-1-钩子技术介绍"><a href="#2-1-钩子技术介绍" class="headerlink" title="2.1 钩子技术介绍"></a>2.1 钩子技术介绍</h2><p>Windows 提供了 3 个 API 让我们可以很方便使用钩子技术将 DLL 文件注入到进程之中：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装指定消息类型的钩子到钩子链中</span></span><br><span class="line"><span class="function">HHOOK <span class="title">SetWindowsHookEx</span><span class="params">(<span class="type">int</span> idHook,</span></span></span><br><span class="line"><span class="params"><span class="function">    HOOKPROC lpfn,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hMod,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从钩子链中删除钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnhookWindowsHookEx</span><span class="params">(HHOOK hhk</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将消息转发到钩子链上的下一个钩子</span></span><br><span class="line"><span class="function">LRESULT <span class="title">CallNextHookEx</span><span class="params">(HHOOK hhk,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCode,</span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><code>Hook</code>中文名“钩子”，我们可以把它想象成一个“鱼钩”，用来钩住指定类型的消息。“钩子”可以指定需要钩住哪个线程的消息，可以是当前线程，也可以是所有线程。</p><p>当“指定线程”的“指定消息”被钩住时，系统就会将我们的 DLL（如果钩子的处理过程位于 DLL 中）加载到该线程所属进程的地址空间中，并且在该地址空间中调用我们的 DLL 中的钩子处理过程函数，从而实现了注入功能。</p><p>我们通过<code>SetWindowsHookEx</code>函数来安装一个钩子，操作系统同时也允许开发人员为“同一个线程”的“同一个消息类型”指定多个钩子，这样就形成了一个<code>“钩子链”</code>（<code>Hook Chain</code>）。</p><h3 id="2-1-1-SetWindowsHookEx"><a href="#2-1-1-SetWindowsHookEx" class="headerlink" title="2.1.1 SetWindowsHookEx"></a>2.1.1 SetWindowsHookEx</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HHOOK <span class="title">SetWindowsHookExA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] <span class="type">int</span>       idHook,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HOOKPROC  lpfn,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HINSTANCE hmod,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD     dwThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><code>idHook参数</code>：指定我们需要勾住的消息类型；<br><code>lpfn参数</code>：函数指针。当 idHook 指定的消息触发时，系统将会调用 lpfn 函数指针。<br><code>hMod参数</code>：lpfn 函数指针所在 DLL 的句柄。有 2 种情况下这个参数需要传 NULL：</p><ol><li>lpfn 函数的代码位于本进程内时。</li><li>只需要勾住本进程的消息时，即 dwThreadId 参数指定的线程位于当前进程。</li></ol><p><code>dwThreadId参数</code>：线程 ID，用于指定勾住哪个线程的消息。如果传 0，则表示勾住所有线程的指定消息。</p><blockquote><p>SetWindowsHookEx 详细的参数解释可以参考 MSDN：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644990(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms644990(v=vs.85).aspx</a></p></blockquote><h3 id="2-1-2-CallNextHookEx"><a href="#2-1-2-CallNextHookEx" class="headerlink" title="2.1.2 CallNextHookEx"></a>2.1.2 CallNextHookEx</h3><p>当我们的钩子处理函数将消息处理完之后，我们可以选择将消息丢弃，不让钩子链上的后面的钩子处理；也可以选择将消息继续传递下去，从而让其他钩子有处理的机会。</p><p>如果需要让其他钩子有处理的机会，我们可以在钩子处理函数的最后调用<code>CallNextHookEx</code>函数。</p><h3 id="2-1-3-UnhookWindowsHookEx"><a href="#2-1-3-UnhookWindowsHookEx" class="headerlink" title="2.1.3 UnhookWindowsHookEx"></a>2.1.3 UnhookWindowsHookEx</h3><p><code>UnhookWindowsHookEx</code>函数用于将指定钩子从钩子链中移除。</p><p>即使不调用<code>UnhookWindowsHookEx</code>，在调用<code>SetWindowsHookEx</code>的进程退出后，钩子也将被自动移除。</p><h2 id="2-2-钩子实例"><a href="#2-2-钩子实例" class="headerlink" title="2.2 钩子实例"></a>2.2 钩子实例</h2><p><code>SetWindowsHookEx</code>函数返回一个<code>HHOOK</code>类型的钩子句柄，<code>CallNextHookEx</code>和<code>UnhookWindowsHookEx</code>函数都需要使用这个句柄作为参数。</p><p>如果我们将“注入逻辑”放在独立的 exe 中，将“钩子处理过程”放到独立的 dll 中，那么为了在“钩子处理过程”中调用<code>CallNextHookEx</code>时能够拿到钩子的句柄，我们需要通过其他途径将该句柄从 exe 传递到 dll 中。</p><p>所以为了避免传递“钩子句柄”的麻烦，我们将“注入逻辑”和“钩子处理过程”都写入到一个 DLL 之中。我们只需要调用这个 DLL 的导出函数就可以将这个 DLL 注入到指定线程所属的进程中。</p><p>示例 DLL 名称为<code>InjectDLL</code>，用于勾住指定窗口的<code>WH_GETMESSAGE</code>消息，我们也可以指定其他的消息类型，如键盘消息等。完整的消息类型可以参考 MSDN 上关于<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644990(v=vs.85).aspx">SetWindowsHookEx</a>函数的解释。</p><p><code>InjectDLL</code>的完整代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HHOOK g_hook = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved)</span> </span>{</span><br><span class="line">    <span class="keyword">switch</span>(fdwReason) {</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提权函数</span></span><br><span class="line"><span class="comment">// 参考：https://blog.csdn.net/china_jeffery/article/details/79173417</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">BOOL <span class="title">EnablePrivilege</span><span class="params">(LPCTSTR szPrivilege, BOOL fEnable)</span> </span>{</span><br><span class="line">  BOOL fOk = FALSE;</span><br><span class="line">  HANDLE hToken = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) {</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, szPrivilege, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line">    tp.Privileges-&gt;Attributes = fEnable ? SE_PRIVILEGE_ENABLED : <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tp, <span class="built_in">sizeof</span>(TOKEN_PRIVILEGES), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fOk = (<span class="built_in">GetLastError</span>() == ERROR_SUCCESS);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fOk;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 钩子处理过程</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">HookProc_GetMsg</span><span class="params">(<span class="type">int</span> code, WPARAM wParam, LPARAM lParam)</span> </span>{</span><br><span class="line">  <span class="type">char</span> szMsg[<span class="number">512</span>] = { <span class="number">0</span> };</span><br><span class="line">  <span class="built_in">sprintf_s</span>(szMsg, <span class="number">512</span>, <span class="string">"code: %d, wParam: %d, lParam: %d"</span>, code, wParam, lParam);</span><br><span class="line">  <span class="built_in">OutputDebugStringA</span>(szMsg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">CallNextHookEx</span>(g_hook, code, wParam, lParam);;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出函数，安装钩子</span></span><br><span class="line"><span class="function">HHOOK <span class="title">InjectDllByHook</span><span class="params">(HWND hwnd)</span> </span>{</span><br><span class="line">  DWORD dwThreadId = <span class="number">0</span>;</span><br><span class="line">  HHOOK hHook = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  __try {</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">EnablePrivilege</span>(SE_DEBUG_NAME, TRUE)) {</span><br><span class="line">      __leave;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过窗口句柄获取到窗口所属线程</span></span><br><span class="line">    dwThreadId = <span class="built_in">GetWindowThreadProcessId</span>(hwnd, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (dwThreadId == <span class="number">0</span>) {</span><br><span class="line">      __leave;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取DLL自身的句柄</span></span><br><span class="line">    HMODULE hModule = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">GetModuleHandleExW</span>(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,</span><br><span class="line">      (LPCWSTR)InjectDllByHook, &amp;hModule);</span><br><span class="line"></span><br><span class="line">    hHook = <span class="built_in">SetWindowsHookEx</span>(WH_GETMESSAGE, (HOOKPROC)HookProc_GetMsg, hModule, dwThreadId);</span><br><span class="line">  }</span><br><span class="line">  __finally {</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (hHook);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出函数，卸载钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">EjectDllByHook</span><span class="params">(HHOOK hook)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">UnhookWindowsHookEx</span>(hook);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以直接调用该 DLL 的导出函数<code>InjectDllByHook</code>，实现 Hook 指定窗口（也可以改成线程，因为<code>InjectDllByHook</code>函数内部也是通过窗口查找到对应线程的）的指定消息。当指定的消息类型被勾住时，我们的 DLL 也就被加载到了该窗口所属的进程地址空间了，从而实现了注入。</p><h1 id="三、使用远程线程方式注入"><a href="#三、使用远程线程方式注入" class="headerlink" title="三、使用远程线程方式注入"></a>三、使用远程线程方式注入</h1><h2 id="3-1-远程线程注入原理"><a href="#3-1-远程线程注入原理" class="headerlink" title="3.1 远程线程注入原理"></a>3.1 远程线程注入原理</h2><p>“注册表注入方式”由于不能精确指定需要注入的进程，而且只能注入到 GUI 程序中，灵活性较差；“钩子注入方式”虽然能够精确指定注入的线程，但只能针对特定类型的消息进行 Hook，从而间接的实现注入，对于类似 windows 服务类的程序就束手无策了。</p><p>本节介绍的“远程线程的注入方式”是在实际中使用最为广泛的一种注入方式，它即可以精确指定需要注入的进程，又可以注入到非 GUI 程序中。</p><p>远程线程注入方式使用的关键 API 为<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682437(v=vs.85).aspx">CreateRemoteThread</a>，原型如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  HANDLE                 hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPSECURITY_ATTRIBUTES  lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  SIZE_T                 dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPVOID                 lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  DWORD                  dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_ LPDWORD                lpThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><code>CreateRemoteThread</code>的参数和我们平时创建本地线程使用的<code>CreateThread</code>的参数类似，新增了<code>hProcess</code>句柄参数用于指定在哪个进程创建远程线程，通过<code>OpenProcess</code>可以获取到进程句柄，但需要注意权限问题。</p><p><strong>通过远程线程方式实现 DLL 注入主要是在<code>lpStartAddress</code>和<code>lpParameter</code>这 2 个参数上面做文章。</strong><br><code>lpStartAddress</code>参数和<code>CreateThread</code>函数的一样，都是线程的处理过程函数，函数原型如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>我们知道加载 DLL 使用的 API 是<code>LoadLibraryA</code>或<code>LoadLibraryW</code>，原型如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMODULE WINAPI <span class="title">LoadLibrary</span><span class="params">(LPCTSTR lpFileName)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>对比<code>LoadLibrary</code>和线程处理函数(<code>LPTHREAD_START_ROUTINE</code>)的原型，我们发现两者的函数的原型基本相同。虽然不是完全相同，但都是接收一个指针参数，而且都是返回一个值，并且调用约定也都是<code>WINAPI</code>。</p><p>我们完全可以利用下它们之间的相似性，把线程处理函数的地址设为<code>LoadLibraryA</code>或<code>LoadLibraryW</code>，类似下面这样：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcessRemote,</span><br><span class="line">  <span class="literal">NULL</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  LoadLibraryA,</span><br><span class="line">  <span class="string">"C:\\InjectDll.dll"</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p><strong>当<code>CreateRemoteThread</code>创建的新线程在远程进程地址空间中被创建的时候，就会立即调用<code>LoadLibraryA</code>函数，并传入 DLL 路径的地址作为其参数。</strong></p><h2 id="3-2-注意事项"><a href="#3-2-注意事项" class="headerlink" title="3.2 注意事项"></a>3.2 注意事项</h2><p>按照上面的介绍的方法很容易就能实现远程线程注入，实际上也的确是很容易实现，只是还有 3 个地方需要注意：LoadLibrary 函数地址、DLL 路径字符串地址、取消注入。</p><h3 id="3-2-1-LoadLibrary-函数地址问题"><a href="#3-2-1-LoadLibrary-函数地址问题" class="headerlink" title="3.2.1 LoadLibrary 函数地址问题"></a>3.2.1 LoadLibrary 函数地址问题</h3><p>我们不能向上面的代码那样直接把<code>LoadLibraryA</code>或<code>LoadLibraryW</code>作为第 4 个参数传给<code>CreateRemoteThread</code>函数。这其中涉及模块的导入段等问题，如果在调用<code>CreateRemoteThread</code>时直接引用<code>LoadLibraryA</code>，则该引用会被解析为我们被注入 DLL 的导入段中的<code>LoadLibraryA</code>转换函数的地址，如果把这个转换函数的地址作为远程线程的起始地址传入，其结果很可能是访问违规。</p><p>为了强制代码略过转换函数并直接调用<code>LoadLibraryA</code>函数，我们必须通过 GetProcAddress 来得到<code>LoadLibraryA</code>的确切地址。如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HMODULE hKernel32 = <span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">"kernel32.dll"</span>));</span><br><span class="line">LPVOID pLoadLibraryAAddr = (LPVOID)<span class="built_in">GetProcAddress</span>(hKernel32, <span class="string">"LoadLibraryA"</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-2-DLL-路径字符串地址问题"><a href="#3-2-2-DLL-路径字符串地址问题" class="headerlink" title="3.2.2 DLL 路径字符串地址问题"></a>3.2.2 DLL 路径字符串地址问题</h3><p>DLL 路径字符串<code>"C:\\InjectDll.dll"</code>的内存地址位于调用进程的地址空间中，并不位于被注入的进程的地址空间中。所以当<code>LoadLibraryA</code>用这个地址去被注入进程的地址空间中访问的时候，DLL 路径的字符串并不在那里，这很有可能导致远程线程访问违规。</p><blockquote><p>如果对进程的地址空间不了解，可以参考：- <a href="/post/3219980417.html" title="《Windows内存体系》">《Windows内存体系》</a>系列文章。</p></blockquote><p>为了解决这个问题，我们需要把 DLL 的路径字符串存储到被注入进程的地址空间中。Windows 提供的<code>VirtualAllocEx</code>函数可以实现在其他进程的地址空间中分配内存块。实现过程大致如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hTargeProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwProcessID); <span class="comment">// dwProcessID为被注入目标进程的进程ID</span></span><br><span class="line"><span class="keyword">if</span> (!hTargeProcess) {</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">SIZE_T dllPathSize = <span class="built_in">strlen</span>(pszDllPath); <span class="comment">// pszDllPath存储了DLL的路径</span></span><br><span class="line">pVM4DllPath = <span class="built_in">VirtualAllocEx</span>(hTargeProcess, <span class="literal">NULL</span>, dllPathSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (!pVM4DllPath) {</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hTargeProcess, pVM4DllPath, pszDllPath, dllPathSize, <span class="literal">NULL</span>)) {</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-3-取消注入问题"><a href="#3-2-3-取消注入问题" class="headerlink" title="3.2.3 取消注入问题"></a>3.2.3 取消注入问题</h3><p>取消注入就是将 DLL 从目标进程卸载，卸载 DLL 所用的 API 是<code>FreeLibrary</code>，但我们不能直接调用这个函数，因为直接调用的话是在我们的进程中卸载 DLL，而不是目标进程中卸载，很显然这样达不到卸载的目的。我们需要和加载 DLL 时一样，将<code>FreeLibrary</code>的地址作为第 4 个参数传给<code>CreateRemoteThread</code>函数，但同样需要通过<code>GetProcAddress</code>来得到<code>FreeLibrary</code>的确切地址：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">"Kernel32"</span>)), <span class="string">"FreeLibrary"</span>);</span><br><span class="line"><span class="keyword">if</span>(pfnThreadRtn) {</span><br><span class="line">    hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pfnThreadRtn, me.modBaseAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-3-实例"><a href="#3-3-实例" class="headerlink" title="3.3 实例"></a>3.3 实例</h2><p>本实例中的<code>InjectDllByRemoteThread</code>和<code>EjectDllByRemoteThread</code>两个函数使用远程线程的方式分别实现了注入和取消注入的功能。</p><h3 id="3-3-1-InjectDllByRemoteThread-函数"><a href="#3-3-1-InjectDllByRemoteThread-函数" class="headerlink" title="3.3.1 InjectDllByRemoteThread 函数"></a>3.3.1 InjectDllByRemoteThread 函数</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InjectDllByRemoteThread</span><span class="params">(DWORD dwProcessID, <span class="type">const</span> <span class="type">char</span>* pszDllPath)</span> </span>{</span><br><span class="line">  BOOL bRet = FALSE;</span><br><span class="line">  <span class="type">const</span> DWORD dwThreadSize = <span class="number">50</span> * <span class="number">1024</span>;</span><br><span class="line">  HANDLE hTargeProcess = <span class="literal">NULL</span>;</span><br><span class="line">  HANDLE hRemoteThread = <span class="literal">NULL</span>;</span><br><span class="line">  PVOID pVM4LoadLibrary = <span class="literal">NULL</span>;</span><br><span class="line">  PVOID pVM4DllPath = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  __try {</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">EnablePrivilege</span>(SE_DEBUG_NAME, TRUE)) {</span><br><span class="line">      __leave;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    hTargeProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwProcessID);</span><br><span class="line">    <span class="keyword">if</span> (!hTargeProcess) {</span><br><span class="line">      __leave;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    SIZE_T dllPathSize = <span class="built_in">strlen</span>(pszDllPath);</span><br><span class="line">    pVM4DllPath = <span class="built_in">VirtualAllocEx</span>(hTargeProcess, <span class="literal">NULL</span>, dllPathSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!pVM4DllPath) {</span><br><span class="line">      __leave;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hTargeProcess, pVM4DllPath, pszDllPath, dllPathSize, <span class="literal">NULL</span>)) {</span><br><span class="line">      __leave;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    HMODULE hKernel32 = <span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">"kernel32.dll"</span>));</span><br><span class="line">    LPVOID pLoadLibraryAAddr = (LPVOID)<span class="built_in">GetProcAddress</span>(hKernel32, <span class="string">"LoadLibraryA"</span>);</span><br><span class="line"></span><br><span class="line">    hRemoteThread = <span class="built_in">CreateRemoteThread</span>(hTargeProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (<span class="built_in">DWORD</span>(WINAPI *)(LPVOID))pLoadLibraryAAddr, pVM4DllPath, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hRemoteThread) {</span><br><span class="line">      __leave;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hRemoteThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    DWORD dwExitCode = <span class="number">0</span>;</span><br><span class="line">    BOOL B = <span class="built_in">GetExitCodeThread</span>(hRemoteThread, &amp;dwExitCode);</span><br><span class="line"></span><br><span class="line">    bRet = TRUE;</span><br><span class="line">  }</span><br><span class="line">  __finally {</span><br><span class="line">    <span class="keyword">if</span> (hTargeProcess &amp;&amp; pVM4DllPath) {</span><br><span class="line">      <span class="built_in">VirtualFreeEx</span>(hTargeProcess, pVM4DllPath, dwThreadSize, MEM_RELEASE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hRemoteThread) {</span><br><span class="line">      <span class="built_in">CloseHandle</span>(hRemoteThread);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hTargeProcess) {</span><br><span class="line">      <span class="built_in">CloseHandle</span>(hTargeProcess);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bRet;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-3-2-EjectDllByRemoteThread-函数"><a href="#3-3-2-EjectDllByRemoteThread-函数" class="headerlink" title="3.3.2 EjectDllByRemoteThread 函数"></a>3.3.2 EjectDllByRemoteThread 函数</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EjectDllByRemoteThread</span><span class="params">(DWORD dwProcessID, LPCWSTR pszDllPath)</span> </span>{</span><br><span class="line">    BOOL bOk = FALSE;</span><br><span class="line">    HANDLE hTHSnapshot = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>, hThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    __try {</span><br><span class="line">        hTHSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPMODULE, dwProcessID);</span><br><span class="line">        <span class="keyword">if</span>(hTHSnapshot == INVALID_HANDLE_VALUE) {</span><br><span class="line">            __leave;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        MODULEENTRY32W me = {<span class="built_in">sizeof</span>(me)};</span><br><span class="line">        BOOL bFound = FALSE;</span><br><span class="line">        BOOL bMoreMods = <span class="built_in">Module32FirstW</span>(hTHSnapshot, &amp;me);</span><br><span class="line">        <span class="keyword">for</span>(; bMoreMods; bMoreMods = <span class="built_in">Module32NextW</span>(hTHSnapshot, &amp;me)) {</span><br><span class="line">            bFound = (_wcsicmp(me.szModule, pszDllPath) == <span class="number">0</span>) ||</span><br><span class="line">                (_wcsicmp(me.szExePath, pszDllPath) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(bFound) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!bFound) {</span><br><span class="line">            __leave;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        hProcess = <span class="built_in">OpenProcess</span>(</span><br><span class="line">            PROCESS_QUERY_INFORMATION |</span><br><span class="line">            PROCESS_CREATE_THREAD |</span><br><span class="line">            PROCESS_VM_OPERATION,  <span class="comment">// For CreateRemoteThread</span></span><br><span class="line">            FALSE, dwProcessID);</span><br><span class="line">        <span class="keyword">if</span>(hProcess == <span class="literal">NULL</span>) {</span><br><span class="line">            __leave;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)</span><br><span class="line">            <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">"Kernel32"</span>)), <span class="string">"FreeLibrary"</span>);</span><br><span class="line">        <span class="keyword">if</span>(pfnThreadRtn == <span class="literal">NULL</span>) {</span><br><span class="line">            __leave;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pfnThreadRtn, me.modBaseAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(hThread == <span class="literal">NULL</span>) {</span><br><span class="line">            __leave;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">        bOk = TRUE;</span><br><span class="line">    }</span><br><span class="line">    __finally {</span><br><span class="line">        <span class="keyword">if</span>(hTHSnapshot != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">CloseHandle</span>(hTHSnapshot);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(hThread != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(hProcess != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(bOk);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-3-3-DllMain-函数"><a href="#3-3-3-DllMain-函数" class="headerlink" title="3.3.3 DllMain 函数"></a>3.3.3 DllMain 函数</h3><p>使用远程线程的方式进行 DLL 注入，我们一般在 DllMain 的<code>DLL_PROCESS_ATTACH</code>条件分支开始业务逻辑（通常会另外创建一个子线程，将业务逻辑放到子线程中处理），<code>DLL_PROCESS_DETACH</code>条件分支出结束业务逻辑。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved)</span> </span>{</span><br><span class="line">  HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(fdwReason) {</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        {</span><br><span class="line">      g_hDllModule = hModule;</span><br><span class="line">      <span class="comment">// 使用注册表方式和CreateRemoteThread方式注入时，一般在此处创建线程</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">      hThread = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, PluginProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">if</span> (hThread) {</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hThread); <span class="comment">// 关闭句柄，防止句柄泄漏</span></span><br><span class="line">      }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        {</span><br><span class="line">          <span class="comment">// 结束业务逻辑</span></span><br><span class="line">          <span class="comment">// ......</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows注入与拦截 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows注入与拦截(1)--DLL注入基础</title>
      <link href="/post/1504192511.html"/>
      <url>/post/1504192511.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、DLL-注入技术的用途"><a href="#一、DLL-注入技术的用途" class="headerlink" title="一、DLL 注入技术的用途"></a>一、DLL 注入技术的用途</h2><p>从<a href="/post/2494475058.html" title="Windows内存体系(1)--虚拟地址空间">Windows内存体系(1)--虚拟地址空间</a>文章中我们可以知道，在 Windows 系统中，每个进程都有自己私有的地址空间。当我们用指针来引用内存的时候，指针的值表示的是进程自己的地址空间的一个虚拟的内存地址。<strong>进程不能通过指针来引用其他进程地址空间的内存。</strong>因此，如果一个进程有缺陷会导致其引用和覆盖随机地址处的内存，那么这个缺陷的影响就会不会扩散到其他的进程。</p><p>独立的地址空间有利于系统的稳定性。但很多时候我们还是需要跨越进程的边界来访问另一个进程地址空间，比如：</p><ul><li>我们要从另一个进程创建的窗口来派生子类窗口。比如附着在 windows 资源管理器上的一些小插件等。</li><li>我们需要假借其他进程之名做某些事情。</li><li>我们需要获取其他进程的更多详细信息，如加载了哪些 dll 等。</li><li>我们需要对其他进程的某些操作进程拦截。</li><li>干一些羞羞的事情…</li></ul><p>为了满足上面的这些需求，我们可以使用 DLL 注入的技术，将我们自己开发的 dll 注入到另一个进程的地址空间中，让 dll 中的代码在该进程的地址空间中执行，那么我们就可以在那个中进程为所欲为了。</p><h2 id="二、什么样的-DLL-可以被注入？"><a href="#二、什么样的-DLL-可以被注入？" class="headerlink" title="二、什么样的 DLL 可以被注入？"></a>二、什么样的 DLL 可以被注入？</h2><p>理论上任何 DLL 都可以被注入到其他进程之中，但是大多数情况下，我们注入到其他进程之中是为了实现某些功能、做某些事情的，所以我们需要在我们的 DLL 被注入之后，DLL 中的功能代码能够被调用执行。</p><p>我们知道 DLL 被<strong>首次</strong>载入到进程中时，会收到<code>DLL_PROCESS_ATTACH</code>的通知，即调用<code>DllMain</code>函数，并且参数<code>fdwReason</code>的值被设为<code>DLL_PROCESS_ATTACH</code>。我们可以在收到<code>DLL_PROCESS_ATTACH</code>通知时开始我们的业务逻辑。</p><p>下面是一个最简单的 dll 的源码，在被注入成功后（即收到<code>DLL_PROCESS_ATTACH</code>通知时）弹出消息提示框：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved )</span> </span>{</span><br><span class="line">    <span class="keyword">switch</span>(fdwReason) {</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        {</span><br><span class="line">      <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">"我已经被注入啦"</span>), <span class="built_in">TEXT</span>(<span class="string">"信息"</span>), MB_ICONINFORMATION);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是，如果<code>DLL_PROCESS_ATTACH</code>通知处理过程中的操作被挂起（如消息提示框）或者被阻塞（如用户创建了一个消息循环），这样就会导致目标进程中的<code>LoadLibrary(Ex)</code>函数一直无法返回（dll 都是通过<code>LoadLibrary(Ex)</code>函数来加载的），所以我们一般会在<code>DLL_PROCESS_ATTACH</code>通知处理过程中创建一个子线程，将业务逻辑放置到该子线程中执行，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> __stdcall <span class="title">PluginProc</span><span class="params">(LPVOID pArg)</span> </span>{</span><br><span class="line">  <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">"我已经被注入啦"</span>), <span class="built_in">TEXT</span>(<span class="string">"信息"</span>), MB_OK | MB_ICONASTERISK);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved)</span> </span>{</span><br><span class="line">  HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(fdwReason) {</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        {</span><br><span class="line">      hThread = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, PluginProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (hThread) {</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hThread); <span class="comment">// 关闭句柄，防止句柄泄漏</span></span><br><span class="line">      }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另外，当 DLL 被从目标进程卸载时，DLL 会收到<code>DLL_PROCESS_DETACH</code>通知，我们需要在该通知的处理过程中做好最后的善后工作，防止资源泄漏、程序崩溃等问题出现。</p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows注入与拦截 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>了解DPI缩放</title>
      <link href="/post/50218900.html"/>
      <url>/post/50218900.html</url>
      
        <content type="html"><![CDATA[<p>dpi 是“Dots Per Inch”的缩写，表示每英寸的像素点个数，也就是像素点的密集度。</p><p>dpi不是用来表示屏幕分辨率的，也不是用来表示屏幕物理尺寸的。</p><span id="more"></span><p><code>dpi = 总像素点 / 物理面积</code></p><p>比如一个 32 寸的显示，但分辨率只有<code>1920*1440</code>，而一个 24 寸的显示器，分辨率却达到<code>3840*2160</code>，很明显后面这个显示器的每英寸的像素点的个数多，显示的画面更加细腻。<br>所以：高分辨率不等于高 dpi。</p><p>苹果的视网膜屏幕的核心就是高 dpi：屏幕物理面积小，而分辨率高达 5k，每英寸的像素点（dpi）固然多，画面自然细腻。</p><h1 id="软件显示异常"><a href="#软件显示异常" class="headerlink" title="软件显示异常"></a>软件显示异常</h1><p>为什么高 DPI 显示器会导致某些软件显示异常了？</p><p>随着 2K、4K 显示器的普及，在使用这些高 DPI 显示器时，我们为了使软件界面看起来不至于太小，导致视觉疲劳，一般会在系统中设置缩放比例。</p><p>Windows 操作系统对高 dpi 显示器缩放支持最好的是 windows 10+，建议在使用高 DPI 显示器时搭配 Windows 10+操作系统。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/dpi-1.png"></p><p>假设现有一个软件，其界面宽 950 像素，高 700 像素，该软件在 24 寸、分辨率为<code>1900*1400</code>的显示器上显示正常，但放到高 dpi 显示器（同样是 24 寸，但分辨率为<code>3800*2800</code>）上显示效果会如何？</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/dpi-2.png"></p><p>从上图可以看到，同样尺寸的软件界面，在高 dpi 显示器上会显得非常小，会对使用者会造成严重的视觉疲劳。</p><p>所以我们的软件需要针对高 dpi 进行适配和缩放。</p><h1 id="Windows-10-系统的DPI缩放规则"><a href="#Windows-10-系统的DPI缩放规则" class="headerlink" title="Windows 10+系统的DPI缩放规则"></a>Windows 10+系统的DPI缩放规则</h1><p>Windows 10+操作系统针对 dpi 缩放制定了 3 种规则，每个进程都必须匹配下面的一种规则，默认为<code>PROCESS_DPI_UNAWARE</code>：</p><ol><li>PROCESS_DPI_UNAWARE<br>在软件启动时， 操作系统会自动将软件进行缩放拉伸；在系统 dpi 缩放改变时，系统也会将软件自动进行缩放拉伸，但软件不会收到 WM_DPICHANGED 消息。</li><li>PROCESS_SYSTEM_DPI_AWARE<br>在软件启动时，系统不会将软件进行缩放拉伸；但在系统 dpi 缩放改变时，系统会将软件进行缩放拉伸，但软件仍然不会收到 WM_DPICHANGED 消息。</li><li>PROCESS_PER_MONITOR_DPI_AWARE<br>在软件启动时，系统不会将软件进行缩放拉伸；同样，在系统 dpi 缩放改变时，系统也不会将软件进行缩放拉伸，但软件会收到 WM_DPICHANGED 消息。</li></ol><blockquote><p>详见：<a href="https://docs.microsoft.com/zh-cn/windows/desktop/api/windef/ne-windef-dpi_awareness">dpi_awareness</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《Windows内存体系》</title>
      <link href="/post/3219980417.html"/>
      <url>/post/3219980417.html</url>
      
        <content type="html"><![CDATA[<p>力求全面的介绍在 Ring3 层开发过程中需要了解的 Windows 内存体系方面的知识。</p><span id="more"></span><p>文章列表：</p><ul><li><a href="/post/2494475058.html" title="Windows内存体系(1)--虚拟地址空间">Windows内存体系(1)--虚拟地址空间</a></li><li><a href="/post/595856315.html" title="Windows内存体系(2)--虚拟内存">Windows内存体系(2)--虚拟内存</a></li><li><a href="/post/3938269003.html" title="Windows内存体系(3)--内存映射文件">Windows内存体系(3)--内存映射文件</a></li><li><a href="/post/4245522728.html" title="Windows内存体系(4)--内存对齐">Windows内存体系(4)--内存对齐</a></li><li><a href="/post/3599385732.html" title="Windows内存体系(5)--堆">Windows内存体系(5)--堆</a></li><li><a href="/post/213040252.html" title="Windows内存体系(6)--跨模块内存分配释放">Windows内存体系(6)--跨模块内存分配释放</a></li><li><a href="/post/3937624737.html" title="Windows内存体系(7)--使用std::string跨MT模块传参">Windows内存体系(7)--使用std::string跨MT模块传参</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《网络协议》</title>
      <link href="/post/253039952.html"/>
      <url>/post/253039952.html</url>
      
        <content type="html"><![CDATA[<p>本栏目系统性的介绍了常用的网络协议（如 ARP, IP, TCP, UDP, HTTP 等），并深入剖析协议的原理。让读者不仅可以知其然，而且可以知其所以然。在这其中也覆盖面试中的一些常见问题。</p><span id="more"></span><p>文章列表：</p><ul><li><a href="/post/3886809266.html" title="网络协议(1)--基础概念">网络协议(1)--基础概念</a></li><li><a href="/post/3034381124.html" title="网络协议(2)--ARP和RARP协议">网络协议(2)--ARP和RARP协议</a></li><li><a href="/post/2274025898.html" title="网络协议(3)--IP协议">网络协议(3)--IP协议</a></li><li><a href="/post/349088656.html" title="网络协议(4)--ICMP协议">网络协议(4)--ICMP协议</a></li><li><a href="/post/4190400644.html" title="网络协议(5)--UDP协议">网络协议(5)--UDP协议</a></li><li><a href="/post/1504706832.html" title="网络协议(6)--TCP协议">网络协议(6)--TCP协议</a></li><li><a href="/post/3654006375.html" title="网络协议(7)--HTTP与HTTPS协议">网络协议(7)--HTTP与HTTPS协议</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《拨开字符编码的迷雾》</title>
      <link href="/post/1376508302.html"/>
      <url>/post/1376508302.html</url>
      
        <content type="html"><![CDATA[<p>本专栏从字符编码的基础概念开始，力求帮助读者一步一步地理清在开发过程中遇到的各种字符编码问题，助您告别字符编码和乱码的烦恼。</p><span id="more"></span><p>文章列表：</p><ul><li><a href="/post/2720283852.html" title="拨开字符编码的迷雾(1)--字符编码概述">拨开字符编码的迷雾(1)--字符编码概述</a></li><li><a href="/post/1337290471.html" title="拨开字符编码的迷雾(2)--编译器处理文件编码">拨开字符编码的迷雾(2)--编译器处理文件编码</a></li><li><a href="/post/4126466705.html" title="拨开字符编码的迷雾(3)--字符编码转换">拨开字符编码的迷雾(3)--字符编码转换</a></li><li><a href="/post/1559270845.html" title="拨开字符编码的迷雾(4)--MySQL字符编码">拨开字符编码的迷雾(4)--MySQL字符编码</a></li><li><a href="/post/1204594779.html" title="拨开字符编码的迷雾(5)--Qt字符编码">拨开字符编码的迷雾(5)--Qt字符编码</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图形编程扫盲</title>
      <link href="/post/1919525700.html"/>
      <url>/post/1919525700.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、常见图形编程接口"><a href="#一、常见图形编程接口" class="headerlink" title="一、常见图形编程接口"></a>一、常见图形编程接口</h2><p>我们常见的图形编程接口主要分为如下派系：</p><ol><li>OpenGL</li><li>DirectX</li><li>Vulkan</li><li>Metal</li></ol><p>下图展示了各个派系的分支及特点：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/tuxingbianchenjiekoushaomang-1.png"></p><span id="more"></span><h2 id="二、ANGLE"><a href="#二、ANGLE" class="headerlink" title="二、ANGLE"></a>二、ANGLE</h2><p>ANGLE （全称 <code>Almost Native Graphics Layer Engine</code>）是Google发起的开源项目，主要用在 Chromium 项目里面，Google创建这个项目是为了让WebGL能够间接调用硬件平台支持的图形API，如Windows平台上调用DirectX图形接口。</p><p>目前ANGLE支持Windows, Mac, Linux, iOS和Android平台。</p><p>WebGL基于OpenGL ES开发，而在Windows系统上默认只安装了OpenGL 1.1驱动程序，如果用户没有升级更新的OpenGL驱动，则网页中的WebGL将只能使用软件渲染（即CPU绘制图形），显然这种方式无法利用显卡GPU的优势，图形渲染性能和效果都不好。为了改版这个现状，Google公司开发了ANGLE项目。</p><p>例如在Windows平台，ANGLE项目通过将DirectX接口进行二次封装，封装后的接口与OpenGL ES接口非常类似，这样当程序代码调用ANGLE提供的类OpenGL ES接口时，ANGLE就可以在内部判断是调用OpenGL接口还是调用DirectX接口，从而实现了当用户系统上没用安装OpenGL驱动时，自动使用合适的DirectX绘制接口。</p><blockquote><p>项目地址：<a href="https://github.com/google/angle">https://github.com/google/angle</a></p></blockquote><h2 id="三、EGL"><a href="#三、EGL" class="headerlink" title="三、EGL"></a>三、EGL</h2><p>EGL 是 OpenGL ES 和本地窗口系统（Native Window System）之间的通信接口，OpenGL ES 的平台无关性正是借助 EGL 实现的，EGL 屏蔽了不同平台的差异（Apple 提供了自己的 EGL API 的 iOS 实现，自称 EAGL）。</p><p>我们通常在安装目录看到的<code>libEGL.dll</code>和<code>libGLESv2.dll</code>文件就是EGL在Windows平台的实现。WebGL基于OpenGL ES实现，所以使用了WebGL和OpenGL ES的程序都会带上这2个文件。</p>]]></content>
      
      
      <categories>
          
          <category> ⑩ 编程基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Joplin和WebDAV搭建私有云笔记</title>
      <link href="/post/2173106656.html"/>
      <url>/post/2173106656.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、私有Docker搭建WebDAV服务"><a href="#一、私有Docker搭建WebDAV服务" class="headerlink" title="一、私有Docker搭建WebDAV服务"></a>一、私有Docker搭建WebDAV服务</h1><p>从我的Github上下载WebDAV的Docker配置文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/winsoft666/docker-webdev</span><br></pre></td></tr></tbody></table></figure><p>根据docker-compose.yml.sample文件来新建docker-compose.yml文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> docker-compose.yml.sample docker-compose.yml</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p>修改docker-compose.yml文件中的相应字段：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  webdav:</span><br><span class="line">    build: .</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"9443:443"</span></span><br><span class="line">      - <span class="string">"9080:80"</span></span><br><span class="line">    environment:</span><br><span class="line">      SERVER_NAME: www.xxx.com,xxx.com</span><br><span class="line">      AUTH_TYPE: Basic</span><br><span class="line">      SSL_CERT: selfsigned</span><br><span class="line">    volumes:</span><br><span class="line">      - /webdav-server:/var/lib/dav</span><br><span class="line">      - /root/webdav/user.passwd:/user.passwd</span><br></pre></td></tr></tbody></table></figure><p>字段含义如下：</p><ul><li>ports为容器和宿主机器的端口映射，冒号前面的端口可以自定义；</li><li>SERVER_NAME为服务器绑定的域名，如果没有绑定域名，可以直接写服务器的外网IP。</li><li>Joplin只支持<code>Basic</code>验证模式；</li></ul><p><code>/root/webdav/user.passwd</code>为WebDAV的用户名和密码存储文件，存在在宿主机器上，通过映射的方式映射到容器中，生成步骤如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在CentOS7系统上安装httpd</span></span><br><span class="line">yum -y install httpd</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /root/webdav/</span><br><span class="line"><span class="built_in">touch</span> user.passwd</span><br><span class="line">htpasswd -B user.passwd zhanghua</span><br></pre></td></tr></tbody></table></figure><p>在<code>docker-compose.yml</code>文件所在目录，执行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></tbody></table></figure><p>上面命令会部署并启动WebDAV服务。</p><h1 id="二、测试WebDAV服务"><a href="#二、测试WebDAV服务" class="headerlink" title="二、测试WebDAV服务"></a>二、测试WebDAV服务</h1><p>在浏览器中打开<code>http://xxx.com:9080</code>，会弹出用户名和密码输入框，输入使用<code>htpasswd </code>命令创建的用户和密码，点击登录，如果可以登录进去，说明服务搭建成功。</p><h1 id="三、新建Joplin数据目录"><a href="#三、新建Joplin数据目录" class="headerlink" title="三、新建Joplin数据目录"></a>三、新建Joplin数据目录</h1><p>在宿主机器的<code>/webdav-server/data</code>目录下，新建子目录<code>joplin</code>。因为<code>/webdav-server/</code>目录已经映射到容器中，所以容器可以直接访问。</p><p>重启Docker：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a <span class="comment"># 查看容器ID</span></span><br><span class="line">docker stop XXX</span><br><span class="line">docker start XXX</span><br></pre></td></tr></tbody></table></figure><p>从Joplin官网（<a href="https://joplinapp.org/">https://joplinapp.org/</a>）下载Joplin客户端，在“同步”选项中设置WebDAV，如图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/jopin-webdav-1.png"></p><p>设置完成之后，点击“检查同步配置”，提示“成功”则说明配置正确。</p>]]></content>
      
      
      <categories>
          
          <category> ⑮ 爱折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Joplin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSIS教程(11)-中文手册</title>
      <link href="/post/2948643539.html"/>
      <url>/post/2948643539.html</url>
      
        <content type="html"><![CDATA[<p>这这里分享几个我一直使用的NSIS中文手册：</p><ul><li><p>《NSIS用户手册 中文版》</p><p> NSIS官方英文的手册上的机器翻译版本，有些地方翻译可能不太纯正。</p></li><li><p>《NSIS图文教程集锦 - 轻狂志》</p><p> 里面有很多基于NSIS的安装包示例，大多数与NSIS有关的功能，都可以在这个文档找到线索。</p></li></ul><p>上述文档下载地址：<br><a href="https://github.com/winsoft666/NSIS-Chinese-Doc">https://github.com/winsoft666/NSIS-Chinese-Doc</a></p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 打包狂魔之NSIS教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSIS教程(10)-MUI跳过指定安装步骤</title>
      <link href="/post/1597634702.html"/>
      <url>/post/1597634702.html</url>
      
        <content type="html"><![CDATA[<p>在正常情况下安装包会有“欢迎界面”、“安装目录选择界面”等等，有时我们需要安装包自动跳过这 2 个界面，如安装包通过命令行参数传入“安装目录”（如<code>setup.exe /installdir F:\test</code>），本文讲述如何使安装包跳过指定的界面。</p><span id="more"></span><h1 id="HOW-TO-DO"><a href="#HOW-TO-DO" class="headerlink" title="HOW TO DO?"></a>HOW TO DO?</h1><p>在页面插入宏之前通过<code>MUI_PAGE_CUSTOMFUNCTION_PRE</code>来指定 pre 处理函数，在该函数中来判断是否需要跳过：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装程序欢迎页面</span></span><br><span class="line"><span class="keyword">!define</span> MUI_PAGE_CUSTOMFUNCTION_PRE SkipPage</span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_PAGE_WELCOME</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装程序显示安装目录选择页面</span></span><br><span class="line"><span class="keyword">!define</span> MUI_PAGE_CUSTOMFUNCTION_PRE SkipPage</span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_PAGE_DIRECTORY</span><br></pre></td></tr></tbody></table></figure><p><code>SkipPage</code>函数定义如下：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Function</span> <span class="title function_">SkipPage</span></span><br><span class="line">  <span class="keyword">StrLen</span> <span class="variable">$R1</span> <span class="variable">$paramInstllDir</span></span><br><span class="line">  <span class="variable">${If}</span> <span class="variable">$R1</span> &gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">Abort</span></span><br><span class="line">  <span class="variable">${EndIf}</span></span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br></pre></td></tr></tbody></table></figure><p>获取命令行参数存入<code>$paramInstllDir</code>变量，并解析命令行参数：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">!macro</span> ParseParameters</span><br><span class="line">    <span class="variable">${GetParameters}</span> <span class="variable">$R0</span></span><br><span class="line">    <span class="variable">${GetOptions}</span> <span class="variable">$R0</span> <span class="string">'/installdir'</span> <span class="variable">$R1</span></span><br><span class="line">    <span class="keyword">StrCpy</span> <span class="variable">$paramInstllDir</span> <span class="variable">$R1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">StrLen</span> <span class="variable">$R1</span> <span class="variable">$paramInstllDir</span></span><br><span class="line">    <span class="variable">${If}</span> <span class="variable">$R1</span> &gt; <span class="number">0</span></span><br><span class="line">      <span class="keyword">StrCpy</span> <span class="variable">$INSTDIR</span> <span class="variable">$paramInstllDir</span></span><br><span class="line">  <span class="variable">${EndIf}</span></span><br><span class="line"><span class="keyword">!macro</span>end</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 打包狂魔之NSIS教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSIS教程(9)-使用界面库制作安装界面</title>
      <link href="/post/100006247.html"/>
      <url>/post/100006247.html</url>
      
        <content type="html"><![CDATA[<p>前面的几篇文章介绍了 NSIS 的传统界面的安装包和现代界面的安装包的制作方法，也提到了 NSIS 支持自定义页面（即使用<code>page custom</code>）的特性，自定义页面需要用户自己创建对话框、控件、添加控件响应等等，虽然 NSIS 提供了<code>nsDialogs.nsh</code>来支持这些功能，但使用起来还是不太方便（需要专门了解这个插件诸多用法），而且不够灵活，所以本文介绍一种终极的自定义界面的安装包解决方案，即完全使用第三方界面库来绘制安装包界面。</p><p>该方案是对界面库没有限制的，可以使用其他任何界面库，如 MFC, Qt，WTL 等。通过这种方案可以很轻松的实现类似金山毒霸、QQ、360 安全卫士等软件的安装包界面。</p><span id="more"></span><h2 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h2><p>NSIS 自定义页面的语法：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">page</span> <span class="literal">custom</span> [创建函数] [离开函数] [标题]</span><br></pre></td></tr></tbody></table></figure><p>使用第三方界面库完全定制安装包界面的基本原理就是：新建一个 dll 插件，在<code>page custom</code>的<code>[创建函数]</code>中调用该插件中的函数来显示界面，这时界面上的按钮的响应就不再由 NSIS 控制了，完全由我们的代码控制。</p><h2 id="二、难点问题"><a href="#二、难点问题" class="headerlink" title="二、难点问题"></a>二、难点问题</h2><p>使用我们的插件 dll 完全替代 NSIS 界面之后，有几个问题需要解决：</p><ul><li>如何获取安装和卸载的进度</li><li>如何从 C++回调 NSIS 函数</li></ul><h3 id="2-1-安装和卸载进度"><a href="#2-1-安装和卸载进度" class="headerlink" title="2.1 安装和卸载进度"></a>2.1 安装和卸载进度</h3><p>NSIS 中的安装和卸载进度由<code>!insertmacro MUI_PAGE_INSTFILES</code>或<code>Page instfiles</code>提供。</p><p>在完全使用自己的界面之后，这 2 个 NSIS 界面都不能使用了，这时我们需要自己获取安装（释放）和卸载（删除）的进度。</p><p>以安装进度为例，NSIS 中文件的安装时文件释放功能都是由<code>File</code>命令提供，但该命令没有提供释放进度，所以我们无法获取到实时的释放进度。在这里我们可以使用一个曲折的方法，我们将一个 7z 压缩包放入安装包中：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SetOutPath</span> <span class="variable">$INSTDIR</span></span><br><span class="line"><span class="keyword">File</span> <span class="string">"app\app.7z"</span></span><br></pre></td></tr></tbody></table></figure><p>等安装包释放完这个压缩包之后（这段时间的进度无法显示），再使用 NSIS 官方提供的<code>nsis7z</code>插件来解压缩这个 7z 压缩包，由于 nsis7z 插件可以提供解压缩进度，所以我们可以将这个进度显示在安装进度页面上，解压完之后再删除 7z 压缩包。这个方案的一个弊端就是，7z 压缩包从安装包中释放到本地磁盘的过程需要时间，且这个时间无法准确的显示在进度页面。</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Function</span> <span class="title function_">ExtractFunc</span></span><br><span class="line">    <span class="keyword">SetOutPath</span> <span class="variable">$INSTDIR</span></span><br><span class="line">    <span class="keyword">File</span> <span class="string">"app\app.7z"</span></span><br><span class="line">    <span class="keyword">GetFunctionAddress</span> <span class="variable">$R9</span> ExtractCallback</span><br><span class="line">    <span class="title function_">Nsis7z::ExtractWithCallback</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\app.7z"</span> <span class="variable">$R9</span></span><br><span class="line">    <span class="keyword">Delete</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\app.7z"</span></span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Function</span> <span class="title function_">ExtractCallback</span></span><br><span class="line">    <span class="keyword">Pop</span> <span class="variable">$1</span></span><br><span class="line">    <span class="keyword">Pop</span> <span class="variable">$2</span></span><br><span class="line">    <span class="params">System</span>::Int64Op <span class="variable">$1</span> * <span class="number">100</span></span><br><span class="line">    <span class="keyword">Pop</span> <span class="variable">$3</span></span><br><span class="line">    <span class="params">System</span>::Int64Op <span class="variable">$3</span> / <span class="variable">$2</span></span><br><span class="line">    <span class="keyword">Pop</span> <span class="variable">$0</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">nsDui::SetSliderValue</span> <span class="string">"slrProgress"</span> <span class="variable">$0</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">${If}</span> <span class="variable">$1</span> == <span class="variable">$2</span></span><br><span class="line">        <span class="title function_">nsDui::SetSliderValue</span> <span class="string">"slrProgress"</span> <span class="number">100</span></span><br><span class="line">        <span class="title function_">nsDui::NextPage</span> <span class="string">"wizardTab"</span></span><br><span class="line">    <span class="variable">${EndIf}</span></span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>写这篇文字的时候，发现现在的<a href="http://nsis.sourceforge.net/Nsis7z_plug-in">nsis7z</a>已经太老了，新版的压缩软件生成的 7z 压缩包，该插件已经无法解压。可以使用 7za.exe 命令行工具来生成 7z 压缩文件，7za.exe 从此处下载：<a href="http://download.csdn.net/download/china_jeffery/10214464">http://download.csdn.net/download/china_jeffery/10214464</a>。<br>7za 生成 7z 压缩包语法为：<br><code>7za.exe a app.7z app\*</code></p></blockquote><h3 id="2-2-从-C-回调-NSIS-函数"><a href="#2-2-从-C-回调-NSIS-函数" class="headerlink" title="2.2 从 C++回调 NSIS 函数"></a>2.2 从 C++回调 NSIS 函数</h3><p>比如用户点击了我们自定义界面上的“取消”按钮，这时我们需要调用 NSIS 的<code>Abort</code>函数来取消安装。此时就需要解决如何从 C++环境回调到 NSIS 环境。</p><p>我们可以使用<a href="/post/1273492093.html" title="NSIS教程(8)-插件开发">NSIS教程(8)-插件开发</a>中介绍的<code>PluginCommon.h</code>来实现该功能。</p><p>大致原理是，在 NSIS 脚本中初始化自定义界面的控件与 NSIS 函数指针（整型）的绑定关系（如控件名–函数名），当用户点击控件之后，查找到该控件绑定的 NSIS 函数，然后调用<code>extra_parameters::ExecuteCodeSegment</code>函数（函数第一个参数就是 NSIS 函数指针）。</p><p>以 duilib 界面库为例，对 NSIS 暴露 OnControlBindNSISScript 接口，提供绑定控件与 NSIS 函数指针（整型）的功能：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NSISAPI <span class="title">OnControlBindNSISScript</span><span class="params">(HWND hwndParent, <span class="type">int</span> string_size, <span class="type">char</span> *variables, <span class="type">stack_t</span> **stacktop, extra_parameters *extra)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> controlName[MAX_PATH];</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(controlName, MAX_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">popstring</span>(controlName);</span><br><span class="line">    <span class="type">int</span> callbackID = <span class="built_in">popint</span>();</span><br><span class="line">    g_pMainDlg-&gt;<span class="built_in">SaveToControlCallbackMap</span>( controlName, callbackID );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 NSIS 中调用<code>OnControlBindNSISScript</code>绑定控件与 NSIS 函数：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GetFunctionAddress</span> <span class="variable">$0</span> OnExitDUISetup</span><br><span class="line"><span class="title function_">nsDui::OnControlBindNSISScript</span> <span class="string">"btnFinishedClose"</span> <span class="variable">$0</span></span><br></pre></td></tr></tbody></table></figure><p>在 duilib 的<code>Notify</code>按钮事件响应函数中调用<code>ExecuteCodeSegment</code>执行 NSIS 函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDlgMain::Notify</span><span class="params">( TNotifyUI&amp; msg )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::map&lt;CDuiString, <span class="type">int</span> &gt;::iterator iter = m_controlCallbackMap.<span class="built_in">find</span>( msg.pSender-&gt;<span class="built_in">GetName</span>() );</span><br><span class="line">    <span class="keyword">if</span>( _tcsicmp( msg.sType, _T(<span class="string">"click"</span>) ) == <span class="number">0</span> ){</span><br><span class="line">        <span class="keyword">if</span>( iter != m_controlCallbackMap.<span class="built_in">end</span>() )</span><br><span class="line">            g_pluginParms-&gt;<span class="built_in">ExecuteCodeSegment</span>( iter-&gt;second - <span class="number">1</span>, <span class="number">0</span> );</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( _tcsicmp( msg.sType, _T(<span class="string">"textchanged"</span>) ) == <span class="number">0</span> ){</span><br><span class="line">        <span class="keyword">if</span>( iter != m_controlCallbackMap.<span class="built_in">end</span>() )</span><br><span class="line">            g_pluginParms-&gt;<span class="built_in">ExecuteCodeSegment</span>( iter-&gt;second - <span class="number">1</span>, <span class="number">0</span> );</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        WindowImplBase::<span class="built_in">Notify</span>(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以参考我的<a href="https://github.com/winsoft666/NSIS-UI-Plugin">NSIS-UI-Plugin</a> 项目，基于该项目可以使用任意第三方界面库来定制安装界面。</p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 打包狂魔之NSIS教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSIS教程(8)-插件开发</title>
      <link href="/post/1273492093.html"/>
      <url>/post/1273492093.html</url>
      
        <content type="html"><![CDATA[<p>虽然 NSIS 官方提供了很多插件，也有一些第三方的插件可以下载使用，但在实际开发中难免会遇到已有插件没有提供的功能或者插件不好用的情况，这时我们可以选择自己开发 NSIS 插件。</p><span id="more"></span><h1 id="一、插件开发规范"><a href="#一、插件开发规范" class="headerlink" title="一、插件开发规范"></a>一、插件开发规范</h1><p>NSIS 插件对开发语言没有限制（本文介绍基于 C++开发），只要按照 NSIS 标准所要求的生成一个 dll 文件，该 dll 文件提供<code>纯C规范的</code>、<code>固定格式的</code>导出函数即可。</p><p>总结起来，开发 NSIS 插件的步骤为：</p><ol><li><p>使用 Visual Studio 新建 dll 工程（运行库选择<code>MT</code>或<code>MTD</code>），建议使用的 MT 运行库，不需要额外携带运行时文件。</p></li><li><p>定义插件功能函数，假设函数名为 add，则函数声明格式如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllexport) <span class="function"><span class="type">void</span> __cdecl <span class="title">add</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   HWND hwndParent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   <span class="type">int</span> string_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   <span class="type">char</span> *variables,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   <span class="type">stack_t</span> **stacktop,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   extra_parameters *extra)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>编译生成 dll 文件。</p></li></ol><h1 id="二、参数和返回值"><a href="#二、参数和返回值" class="headerlink" title="二、参数和返回值"></a>二、参数和返回值</h1><p>开发 NSIS 插件的难点在于：获取调用者传入的参数，以及将执行结果返回给调用者。<br>前面的 <a href="/post/3031217406.html" title="NSIS教程(7)-插件使用">NSIS教程(7)-插件使用</a> 说到了，插件函数的调用者传递参数方式有 2 种：</p><ul><li>一种是通过<code>$0~$9 $R0~$R9</code>的形式，这种形式的参数通过<code>char *variables</code>参数来获取。</li><li>一种是通过堆栈的形式，这种形式的参数通过<code>stack_t **stacktop</code>参数来获取。</li></ul><h1 id="三、PluginCommon"><a href="#三、PluginCommon" class="headerlink" title="三、PluginCommon"></a>三、PluginCommon</h1><p>为了方便插件开发中获取用户传入参数、以及执行结果的返回，我对插件开发的常用操作进行了封装。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PluginCommon.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _PLUGIN_COMMON_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PLUGIN_COMMON_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLUGIN_BUF_LEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSISAPI extern <span class="string">"C"</span> __declspec(dllexport) void __cdecl</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXDLL_INIT()           {  \</span></span><br><span class="line"><span class="meta">        g_stringsize=string_size; \</span></span><br><span class="line"><span class="meta">        g_stacktop=stacktop;      \</span></span><br><span class="line"><span class="meta">        g_variables=variables; }</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_stack_t</span> {</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_stack_t</span> *next;</span><br><span class="line">  <span class="type">char</span> text[<span class="number">1</span>];</span><br><span class="line">} <span class="type">stack_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> g_stringsize;</span><br><span class="line"><span class="type">static</span> <span class="type">stack_t</span> **g_stacktop;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *g_variables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">{</span><br><span class="line">  INST_0,         <span class="comment">// $0</span></span><br><span class="line">  INST_1,         <span class="comment">// $1</span></span><br><span class="line">  INST_2,         <span class="comment">// $2</span></span><br><span class="line">  INST_3,         <span class="comment">// $3</span></span><br><span class="line">  INST_4,         <span class="comment">// $4</span></span><br><span class="line">  INST_5,         <span class="comment">// $5</span></span><br><span class="line">  INST_6,         <span class="comment">// $6</span></span><br><span class="line">  INST_7,         <span class="comment">// $7</span></span><br><span class="line">  INST_8,         <span class="comment">// $8</span></span><br><span class="line">  INST_9,         <span class="comment">// $9</span></span><br><span class="line">  INST_R0,        <span class="comment">// $R0</span></span><br><span class="line">  INST_R1,        <span class="comment">// $R1</span></span><br><span class="line">  INST_R2,        <span class="comment">// $R2</span></span><br><span class="line">  INST_R3,        <span class="comment">// $R3</span></span><br><span class="line">  INST_R4,        <span class="comment">// $R4</span></span><br><span class="line">  INST_R5,        <span class="comment">// $R5</span></span><br><span class="line">  INST_R6,        <span class="comment">// $R6</span></span><br><span class="line">  INST_R7,        <span class="comment">// $R7</span></span><br><span class="line">  INST_R8,        <span class="comment">// $R8</span></span><br><span class="line">  INST_R9,        <span class="comment">// $R9</span></span><br><span class="line">  INST_CMDLINE,   <span class="comment">// $CMDLINE</span></span><br><span class="line">  INST_INSTDIR,   <span class="comment">// $INSTDIR</span></span><br><span class="line">  INST_OUTDIR,    <span class="comment">// $OUTDIR</span></span><br><span class="line">  INST_EXEDIR,    <span class="comment">// $EXEDIR</span></span><br><span class="line">  INST_LANG,      <span class="comment">// $LANGUAGE</span></span><br><span class="line">  __INST_LAST</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __stdcall <span class="title">popstring</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">stack_t</span> *th;</span><br><span class="line">  <span class="keyword">if</span> (!g_stacktop || !*g_stacktop) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  th=(*g_stacktop);</span><br><span class="line">  <span class="built_in">lstrcpyA</span>(str,th-&gt;text);</span><br><span class="line">  *g_stacktop = th-&gt;next;</span><br><span class="line">  <span class="built_in">GlobalFree</span>((HGLOBAL)th);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __stdcall <span class="title">pushstring</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">stack_t</span> *th;</span><br><span class="line">  <span class="keyword">if</span> (!g_stacktop) <span class="keyword">return</span>;</span><br><span class="line">  th=(<span class="type">stack_t</span>*)<span class="built_in">GlobalAlloc</span>(GPTR,<span class="built_in">sizeof</span>(<span class="type">stack_t</span>)+g_stringsize);</span><br><span class="line">  <span class="built_in">lstrcpynA</span>(th-&gt;text,str,g_stringsize);</span><br><span class="line">  th-&gt;next=*g_stacktop;</span><br><span class="line">  *g_stacktop=th;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __stdcall <span class="title">popint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="built_in">popstring</span>(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">atoi</span>(buf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __stdcall <span class="title">pushint</span><span class="params">(<span class="type">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="built_in">sprintf_s</span>(buf, <span class="string">"%ld"</span>, value);</span><br><span class="line">    <span class="built_in">pushstring</span>(buf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">char</span> * __stdcall <span class="title">getuservariable</span><span class="params">(<span class="type">int</span> varnum)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">if</span> (varnum &lt; <span class="number">0</span> || varnum &gt;= __INST_LAST) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> g_variables+varnum*g_stringsize;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __stdcall <span class="title">setuservariable</span><span class="params">(<span class="type">int</span> varnum, <span class="type">char</span> *var)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">if</span> (var != <span class="literal">NULL</span> &amp;&amp; varnum &gt;= <span class="number">0</span> &amp;&amp; varnum &lt; __INST_LAST)</span><br><span class="line">    <span class="built_in">lstrcpyA</span>(g_variables + varnum*g_stringsize, var);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">NSPIM</span></span><br><span class="line">{</span><br><span class="line">    NSPIM_UNLOAD,    <span class="comment">// This is the last message a plugin gets, do final cleanup</span></span><br><span class="line">    NSPIM_GUIUNLOAD, <span class="comment">// Called after .onGUIEnd</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">UINT_PTR</span> <span class="params">(*NSISPLUGINCALLBACK)</span><span class="params">(<span class="keyword">enum</span> NSPIM)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// extra_parameters data structures containing other interesting stuff</span></span><br><span class="line"><span class="comment">// but the stack, variables and HWND passed on to plug-ins.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> autoclose;</span><br><span class="line">    <span class="type">int</span> all_user_var;</span><br><span class="line">    <span class="type">int</span> exec_error;</span><br><span class="line">    <span class="type">int</span> abort;</span><br><span class="line">    <span class="type">int</span> exec_reboot; <span class="comment">// NSIS_SUPPORT_REBOOT</span></span><br><span class="line">    <span class="type">int</span> reboot_called; <span class="comment">// NSIS_SUPPORT_REBOOT</span></span><br><span class="line">    <span class="type">int</span> XXX_cur_insttype; <span class="comment">// depreacted</span></span><br><span class="line">    <span class="type">int</span> plugin_api_version; <span class="comment">// see NSISPIAPIVER_CURR</span></span><br><span class="line">    <span class="comment">// used to be XXX_insttype_changed</span></span><br><span class="line">    <span class="type">int</span> silent; <span class="comment">// NSIS_CONFIG_SILENT_SUPPORT</span></span><br><span class="line">    <span class="type">int</span> instdir_error;</span><br><span class="line">    <span class="type">int</span> rtl;</span><br><span class="line">    <span class="type">int</span> errlvl;</span><br><span class="line">    <span class="type">int</span> alter_reg_view;</span><br><span class="line">    <span class="type">int</span> status_update;</span><br><span class="line">} <span class="type">exec_flags_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NSISCALL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSISCALL __stdcall</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</span><br><span class="line">    <span class="type">exec_flags_t</span> *exec_flags;</span><br><span class="line">    <span class="built_in">int</span> (NSISCALL *ExecuteCodeSegment)(<span class="type">int</span>, HWND);</span><br><span class="line">    <span class="built_in">void</span> (NSISCALL *validate_filename)(<span class="type">char</span> *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// returns 0 on success, 1 if already registered and &lt; 0 on errors</span></span><br><span class="line">    <span class="built_in">int</span> (NSISCALL *RegisterPluginCallback)(HMODULE, NSISPLUGINCALLBACK);</span><br><span class="line">} extra_parameters;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//_PLUGIN_COMMON_H_</span></span></span><br></pre></td></tr></tbody></table></figure><p>在开发插件中经常用到的有：<br>4 个堆栈操作函数：<code>pushint</code>,<code>pushstring</code>,<code>popint</code>,<code>popstring</code>。<br>2 个寄存器变量(<code>$R0~$R9</code>,<code>$0~$9</code>)操作函数：<code>getuservariable</code>，<code>setuservariable</code>。</p><h1 id="四、示例"><a href="#四、示例" class="headerlink" title="四、示例"></a>四、示例</h1><p>基于上面的 PluginCommon.h，我们可以将开发插件的步骤流程大大简化。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;commctrl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"PluginCommon.h"</span></span></span><br><span class="line"></span><br><span class="line">HINSTANCE g_hInstance;</span><br><span class="line">HWND g_hwndParent;</span><br><span class="line">extra_parameters *g_pluginParms = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMETHOD_INIT(parent) {\</span></span><br><span class="line"><span class="meta">        g_pluginParms = extra; \</span></span><br><span class="line"><span class="meta">        g_hwndParent = parent; \</span></span><br><span class="line"><span class="meta">        EXDLL_INIT(); }</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HANDLE hInst, ULONG ul_reason_for_call, LPVOID lpReserved)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    g_hInstance = (HINSTANCE)hInst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ul_reason_for_call == DLL_PROCESS_ATTACH) {</span><br><span class="line">        <span class="comment">//do what you want at init time.</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ul_reason_for_call == DLL_THREAD_DETACH || ul_reason_for_call == DLL_PROCESS_DETACH) {</span><br><span class="line">        <span class="comment">//clean up code.</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 以上内容通用，每个插件都可以将上面的内容直接复制过去。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSIS插件导出函数,以add函数为例，若要添加其他函数，则只是函数名需要修改，函数逻辑写在NSMETHOD_INIT(hwndParent);之后的花括号内。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllexport) <span class="function"><span class="type">void</span> __cdecl</span></span><br><span class="line"><span class="function"><span class="title">add</span> <span class="params">( HWND hwndParent, <span class="type">int</span> string_size, <span class="type">char</span> *variables, <span class="type">stack_t</span> **stacktop, extra_parameters *extra)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">NSMETHOD_INIT</span>(hwndParent);</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// == 添加自己代码</span></span><br><span class="line">        <span class="comment">// 假设调用者通过堆栈的形式传递的参数</span></span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">popint</span>();  <span class="comment">// 注意：栈是先进后出</span></span><br><span class="line">        <span class="type">int</span> j = <span class="built_in">popint</span>();</span><br><span class="line">        <span class="type">int</span> k = i + j;</span><br><span class="line">        <span class="built_in">pushint</span>(k); <span class="comment">// 通过plugin-common.h中提供的pushint返回整数，也可以使用pushstring返回字符串</span></span><br><span class="line">        <span class="comment">// ==</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="五、Unicode-支持"><a href="#五、Unicode-支持" class="headerlink" title="五、Unicode 支持"></a>五、Unicode 支持</h1><p>大家可能注意到了上面的示例和<code>PluginCommon.h</code>中使用的都是<code>char</code>，而不是<code>wchar_t</code>。那如果要改成<code>wchar_t</code>需要哪些工作了？</p><ol><li>将插件代码中的<code>char</code>改成<code>wchar_t</code>。</li><li>在 nsi 脚本中加入<code>Unicode True</code>。</li><li>需要将生成的插件 dll 放到 nsis 目录下的<code>Plugins\x86-unicode</code>子目录中。</li></ol>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 打包狂魔之NSIS教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSIS教程(7)-插件使用</title>
      <link href="/post/3031217406.html"/>
      <url>/post/3031217406.html</url>
      
        <content type="html"><![CDATA[<p>NSIS 内置了很多指令，这些指令可以满足我们基本需求，但难免会遇到 NSIS 没有内置的功能，如进程操作，后台运行（即多线程），7z 压缩等等，这个时候我们就需要借助第三方插件来满足我们所需要的功能了。</p><span id="more"></span><h1 id="一、插件获取"><a href="#一、插件获取" class="headerlink" title="一、插件获取"></a>一、插件获取</h1><p>NSIS 官方收录插件的网址是：</p><p><a href="http://nsis.sourceforge.net/Category:Plugins">http://nsis.sourceforge.net/Category:Plugins</a></p><p>我们可以在这个网站上查找和下载我们需要的插件，该网站上针对每个插件都提供了比较完善的示例。</p><h1 id="二、插件使用"><a href="#二、插件使用" class="headerlink" title="二、插件使用"></a>二、插件使用</h1><p>NSIS 插件以 dll 的形式存在，我们以<code>KillProc</code>插件为例（从名字上可以看出该插件提供杀进程的功能），我们下载下来的一般是压缩包，解压之后找到对应插件 dll 文件，如<code>KillProc.dll</code>文件。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-cjsy-1.jpg"></p><p>使用步骤如下：</p><ol><li><p>将 dll 文件拷贝到 NSIS 安装目录下的<code>Plugins\x86-ansi</code>目录（Unicode 插件需要拷贝到<code>Plugins\x86-unicode</code>目录）。</p></li><li><p>在官方文档上找到该插件所提供的函数，以及函数的参数传递形式、返回值形式。<br>NSIS 中插件函数的参数传递形式有 2 种形式：</p><ul><li>使用<code>$0 ~ $9</code>，<code>$R0 ~ $R9</code>来传递。</li><li>使用堆栈来传递。</li></ul></li><li><p>在 NSIS 脚本中按照函数声明的形式来调用，需要在函数名前加上 dll 名称（不需要.dll 后缀），如<code>KillProc::KillProcesses</code>。</p></li></ol><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Section</span></span><br><span class="line">  <span class="keyword">StrCpy</span> <span class="variable">$0</span> <span class="string">"foo.exe"</span>  <span class="comment"># 变量赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">KillProc::KillProcesses</span></span><br><span class="line">  <span class="keyword">StrCmp</span> <span class="variable">$1</span> <span class="string">"-1"</span> wooops</span><br><span class="line"></span><br><span class="line">  wooops:</span><br><span class="line">  <span class="keyword">Abort</span></span><br><span class="line"></span><br><span class="line">  completed:</span><br><span class="line"><span class="keyword">SectionEnd</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 打包狂魔之NSIS教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSIS教程(6)-静默安装</title>
      <link href="/post/4172083706.html"/>
      <url>/post/4172083706.html</url>
      
        <content type="html"><![CDATA[<p>静默安装/卸载是一种安装/卸载形式，用户打开安装包后不显示任何安装界面，直接开始安装，支持使用命令行参数指定安装路径等。</p><span id="more"></span><h1 id="1-静默方式"><a href="#1-静默方式" class="headerlink" title="1. 静默方式"></a>1. 静默方式</h1><p>常用的静默安装有 2 种：</p><ol><li>在脚本中加入 SilentInstall 和 SilentUninstall 命令</li><li>在程序启动参数里加 /S 参数(区分大小写)</li></ol><h1 id="2-当前是否静默运行"><a href="#2-当前是否静默运行" class="headerlink" title="2. 当前是否静默运行"></a>2. 当前是否静默运行</h1><p>在脚本中判断安装、卸载程序是否为静默运行，可以使用 <code>IfSilent</code>：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装操作开始前.</span></span><br><span class="line"><span class="keyword">Function</span> <span class="title function_">.onInit</span></span><br><span class="line">    <span class="keyword">IfSilent</span> +<span class="number">2</span> +<span class="number">1</span></span><br><span class="line">    <span class="keyword">MessageBox</span> <span class="params">MB_ICONQUESTION</span>|<span class="params">MB_OK</span> <span class="string">"欢迎使用"</span></span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br></pre></td></tr></tbody></table></figure><h1 id="3-默认应答"><a href="#3-默认应答" class="headerlink" title="3. 默认应答"></a>3. 默认应答</h1><p>对于有些命令需要为静默安装指定默认的回答，如<code>MessageBox</code>需要加入/SD 开关来指定默认回答。</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载操作开始前.</span></span><br><span class="line"><span class="keyword">Function</span> <span class="title function_">un</span>.onInit</span><br><span class="line">    <span class="keyword">MessageBox</span> <span class="params">MB_ICONQUESTION</span>|<span class="params">MB_YESNO</span> <span class="string">"确定要卸载吗?"</span> /SD <span class="params">IDYES</span> <span class="params">IDYES</span> +<span class="number">2</span> <span class="params">IDNO</span> +<span class="number">1</span></span><br><span class="line">    <span class="keyword">Abort</span></span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br></pre></td></tr></tbody></table></figure><h1 id="4-启动参数解析"><a href="#4-启动参数解析" class="headerlink" title="4. 启动参数解析"></a>4. 启动参数解析</h1><p>如果需要为静默安装指定其他的参数，如用户名等，可以使用程序启动参数指定，并在<code>.onInit</code> 函数里进行解析：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用插件FileFunc中的2个宏</span></span><br><span class="line"><span class="keyword">!include</span> <span class="string">"FileFunc.nsh"</span></span><br><span class="line"><span class="keyword">!insertmacro</span> GetParameters</span><br><span class="line"><span class="keyword">!insertmacro</span> GetOptions</span><br></pre></td></tr></tbody></table></figure><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line"><span class="keyword">Var</span> <span class="variable">paramInstllDir</span>      <span class="comment"># 启动参数-安装目录</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义宏ParseParameters，在.onInit函数中调用即可</span></span><br><span class="line"><span class="keyword">!macro</span> ParseParameters</span><br><span class="line">    <span class="variable">${GetParameters}</span> <span class="variable">$R0</span></span><br><span class="line">    <span class="variable">${GetOptions}</span> <span class="variable">$R0</span> <span class="string">'/installdir'</span> <span class="variable">$R1</span></span><br><span class="line">    <span class="keyword">StrCpy</span> <span class="variable">$paramInstllDir</span> <span class="variable">$R1</span></span><br><span class="line">    <span class="keyword">IfSilent</span> +<span class="number">1</span> +<span class="number">2</span></span><br><span class="line">    <span class="keyword">StrCpy</span> <span class="variable">$INSTDIR</span> <span class="variable">$paramInstllDir</span></span><br><span class="line"><span class="keyword">!macro</span>end</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 打包狂魔之NSIS教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静默安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSIS教程(5)-现代界面示例</title>
      <link href="/post/3798382521.html"/>
      <url>/post/3798382521.html</url>
      
        <content type="html"><![CDATA[<p>NSIS 的现代用户界面(Modern UI)只是相对于传统（丑陋）的界面而言的“现代”而已。它定义在<code>MUI2.nsh</code>中，nsh 文件类似 C++中的头文件，可以被其他模块包含引用。</p><span id="more"></span><blockquote><p>📌 推荐：<a href="https://github.com/winsoft666/NSIS-UI-Plugin">NSIS-UI-Plugin</a> 开源 NSIS UI 插件框架，支持任意第三方界面库。默认使用 Qt 作为界面库的安装包示例。</p></blockquote><p>使用 MUI2 界面需要包含<code>MUI2.nsh</code>：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">!include</span> <span class="string">"MUI2.nsh"</span></span><br></pre></td></tr></tbody></table></figure><p>MUI2 界面和传统界面不同之处在于，传统界面使用的<code>Page</code>(或<code>PageEx</code>)语法来标识显示哪些页面，如：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PageEx</span> <span class="literal">license</span></span><br><span class="line">    <span class="keyword">LicenseData</span> <span class="string">"license.rtf"</span>       <span class="comment">#可以是txt或rtf文件格式</span></span><br><span class="line">PageExEnd</span><br></pre></td></tr></tbody></table></figure><p>而 MUI2 使用的是<code>MUI2.nsh</code>中定义的一系列宏来标识显示哪些页面，如：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">!insertmacro</span> MUI_PAGE_LICENSE <span class="string">"license.rtf"</span></span><br></pre></td></tr></tbody></table></figure><p>和<a href="/post/275632694.html" title="NSIS教程(4)-传统界面示例">NSIS教程(4)-传统界面示例</a>类似，这里提供制作网易云音乐的现代用户界面的安装包示例，脚本代码中包含了详细的注释。</p><h1 id="高仿网易云音乐安装脚本"><a href="#高仿网易云音乐安装脚本" class="headerlink" title="高仿网易云音乐安装脚本"></a>高仿网易云音乐安装脚本</h1><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ====================== 自定义宏 ==============================</span></span><br><span class="line"><span class="keyword">!define</span> PRODUCT_NAME           <span class="string">"网易云音乐"</span></span><br><span class="line"><span class="keyword">!define</span> EXE_NAME               <span class="string">"cloudmusic.exe"</span></span><br><span class="line"><span class="keyword">!define</span> PRODUCT_VERSION        <span class="string">"1.0.0.1"</span></span><br><span class="line"><span class="keyword">!define</span> PRODUCT_PUBLISHER      <span class="string">"NetEase"</span></span><br><span class="line"><span class="keyword">!define</span> PRODUCT_LEGAL          <span class="string">"NetEase 1999-2014"</span></span><br><span class="line"><span class="keyword">!define</span> TEMP_DIR               <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===================== 外部插件以及宏 =============================</span></span><br><span class="line"><span class="keyword">!include</span> <span class="string">"MUI2.nsh"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===================== 安装包版本 =============================</span></span><br><span class="line"><span class="keyword">VIProductVersion</span>                    <span class="string">"<span class="variable">${PRODUCT_VERSION}</span>"</span></span><br><span class="line"><span class="keyword">VIAddVersionKey</span> <span class="string">"ProductVersion"</span>    <span class="string">"<span class="variable">${PRODUCT_VERSION}</span>"</span></span><br><span class="line"><span class="keyword">VIAddVersionKey</span> <span class="string">"ProductName"</span>       <span class="string">"<span class="variable">${PRODUCT_NAME}</span>"</span></span><br><span class="line"><span class="keyword">VIAddVersionKey</span> <span class="string">"CompanyName"</span>       <span class="string">"<span class="variable">${PRODUCT_PUBLISHER}</span>"</span></span><br><span class="line"><span class="keyword">VIAddVersionKey</span> <span class="string">"FileVersion"</span>       <span class="string">"<span class="variable">${PRODUCT_VERSION}</span>"</span></span><br><span class="line"><span class="keyword">VIAddVersionKey</span> <span class="string">"InternalName"</span>      <span class="string">"<span class="variable">${EXE_NAME}</span>"</span></span><br><span class="line"><span class="keyword">VIAddVersionKey</span> <span class="string">"FileDescription"</span>   <span class="string">"<span class="variable">${PRODUCT_NAME}</span>"</span></span><br><span class="line"><span class="keyword">VIAddVersionKey</span> <span class="string">"LegalCopyright"</span>    <span class="string">"<span class="variable">${PRODUCT_LEGAL}</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==================== NSIS属性 ================================</span></span><br><span class="line"><span class="comment"># ZLIB(默认) BZIP2 LZMA</span></span><br><span class="line"><span class="keyword">SetCompressor</span> <span class="literal">lzma</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 安装包名字.</span></span><br><span class="line"><span class="keyword">Name</span> <span class="string">"<span class="variable">${PRODUCT_NAME}</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装程序文件名.</span></span><br><span class="line"><span class="keyword">OutFile</span> <span class="string">"网易云音乐安装0.exe"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认安装位置.</span></span><br><span class="line"><span class="keyword">InstallDir</span> <span class="string">"<span class="variable constant_">$PROGRAMFILES</span>\Netease\CloudMusic"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置是否显示安装详细信息。</span></span><br><span class="line"><span class="keyword">ShowInstDetails</span> <span class="literal">hide</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置是否显示卸载详细信息</span></span><br><span class="line"><span class="keyword">ShowUnInstDetails</span>   <span class="literal">hide</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对Vista和win7 的UAC进行权限请求.</span></span><br><span class="line"><span class="comment"># RequestExecutionLevel none|user|highest|admin</span></span><br><span class="line"><span class="keyword">RequestExecutionLevel</span> <span class="literal">admin</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==================== MUI属性 ==================================</span></span><br><span class="line"><span class="comment"># 安装和卸载程序图标</span></span><br><span class="line"><span class="keyword">!define</span> MUI_ICON              <span class="string">"image\logo.ico"</span></span><br><span class="line"><span class="keyword">!define</span> MUI_UNICON            <span class="string">"image\un_logo.ico"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果未使用MUI，则可直接使用.onGUIInit</span></span><br><span class="line"><span class="keyword">!define</span> MUI_CUSTOMFUNCTION_GUIINIT onGUIInit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装程序欢迎页面</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_PAGE_WELCOME</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装程序软件授权申明页面</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_PAGE_LICENSE <span class="string">"license.rtf"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装程序显示安装目录选择页面</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_PAGE_DIRECTORY</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装程序显示安装组件选择页面</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_PAGE_COMPONENTS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装程序显示进度页面</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_PAGE_INSTFILES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装程序显示安装结束页面</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_PAGE_FINISH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载程序显示进度</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_UNPAGE_INSTFILES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载程序显示安装结束</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_UNPAGE_FINISH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定语言，必须在最后指定</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_LANGUAGE <span class="string">"SimpChinese"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ========================= 安装步骤 ===============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 区段1</span></span><br><span class="line"><span class="comment"># 区段名以一个 ! 开头，那么该区段的显示名称将以粗体字显示.</span></span><br><span class="line"><span class="keyword">Section</span> <span class="string">"!Files"</span> <span class="string">"des_files"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 设置文件的输出路径</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="variable">$INSTDIR</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 放置文件</span></span><br><span class="line">  <span class="keyword">File</span> /r <span class="string">"app\*.*"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SectionEnd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 区段2</span></span><br><span class="line"><span class="keyword">Section</span> <span class="string">"Shortcut"</span> <span class="string">"des_shortcut"</span></span><br><span class="line">  <span class="keyword">SetShellVarContext</span> <span class="literal">all</span></span><br><span class="line">  <span class="keyword">CreateDirectory</span> <span class="string">"<span class="variable constant_">$SMPROGRAMS</span>\<span class="variable">${PRODUCT_NAME}</span>"</span></span><br><span class="line">  <span class="keyword">CreateShortCut</span> <span class="string">"<span class="variable constant_">$SMPROGRAMS</span>\<span class="variable">${PRODUCT_NAME}</span>\<span class="variable">${PRODUCT_NAME}</span>.lnk"</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\<span class="variable">${EXE_NAME}</span>"</span></span><br><span class="line">  <span class="keyword">CreateShortCut</span> <span class="string">"<span class="variable constant_">$SMPROGRAMS</span>\<span class="variable">${PRODUCT_NAME}</span>\卸载<span class="variable">${PRODUCT_NAME}</span>.lnk"</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\uninst.exe"</span></span><br><span class="line">  <span class="keyword">SetShellVarContext</span> <span class="literal">current</span></span><br><span class="line"><span class="keyword">SectionEnd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 区段3</span></span><br><span class="line"><span class="comment"># 区段名为空、遗漏或者以一个 "-" 开头，那么它将是一个隐藏的区段，用户也不能选择禁止它.</span></span><br><span class="line"><span class="keyword">Section</span> <span class="string">"-Necessary"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 生成卸载程序</span></span><br><span class="line">  <span class="keyword">WriteUninstaller</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\uninst.exe"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 添加卸载信息到控制面板</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="params">HKLM</span> <span class="string">"Software\Microsoft\Windows\CurrentVersion\Uninstall\<span class="variable">${PRODUCT_NAME}</span>"</span> <span class="string">"DisplayName"</span> <span class="string">"<span class="variable">${PRODUCT_NAME}</span>"</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="params">HKLM</span> <span class="string">"Software\Microsoft\Windows\CurrentVersion\Uninstall\<span class="variable">${PRODUCT_NAME}</span>"</span> <span class="string">"UninstallString"</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\uninst.exe"</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="params">HKLM</span> <span class="string">"Software\Microsoft\Windows\CurrentVersion\Uninstall\<span class="variable">${PRODUCT_NAME}</span>"</span> <span class="string">"DisplayIcon"</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\<span class="variable">${EXE_NAME}</span>"</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="params">HKLM</span> <span class="string">"Software\Microsoft\Windows\CurrentVersion\Uninstall\<span class="variable">${PRODUCT_NAME}</span>"</span> <span class="string">"Publisher"</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\<span class="variable">${PRODUCT_PUBLISHER}</span>"</span></span><br><span class="line"><span class="keyword">SectionEnd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载区段</span></span><br><span class="line"><span class="keyword">Section</span> <span class="string">"Uninstall"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 删除快捷方式</span></span><br><span class="line">  <span class="keyword">SetShellVarContext</span> <span class="literal">all</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">"<span class="variable constant_">$SMPROGRAMS</span>\<span class="variable">${PRODUCT_NAME}</span>\<span class="variable">${PRODUCT_NAME}</span>.lnk"</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">"<span class="variable constant_">$SMPROGRAMS</span>\<span class="variable">${PRODUCT_NAME}</span>\卸载<span class="variable">${PRODUCT_NAME}</span>.lnk"</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">"<span class="variable constant_">$SMPROGRAMS</span>\<span class="variable">${PRODUCT_NAME}</span>\"</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">"<span class="variable constant_">$DESKTOP</span>\<span class="variable">${PRODUCT_NAME}</span>.lnk"</span></span><br><span class="line">  <span class="keyword">SetShellVarContext</span> <span class="literal">current</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 删除安装的文件</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\*.*"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">"<span class="variable constant_">$DESKTOP</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">RMDir</span> /r <span class="string">"<span class="variable constant_">$INSTDIR</span>"</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SetAutoClose</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">SectionEnd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 区段描述</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_FUNCTION_DESCRIPTION_BEGIN</span><br><span class="line">  <span class="keyword">!insertmacro</span> MUI_DESCRIPTION_TEXT <span class="variable">${des_files}</span>     <span class="string">"主程序文件"</span></span><br><span class="line">  <span class="keyword">!insertmacro</span> MUI_DESCRIPTION_TEXT <span class="variable">${des_shortcut}</span>  <span class="string">"创建开始菜单和桌面快捷方式"</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_FUNCTION_DESCRIPTION_END</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================== 回调函数 ====================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数名以“.”开头的一般作为回调函数保留.</span></span><br><span class="line"><span class="comment"># 函数名以“un.”开头的函数将会被创建在卸载程序里，因此，普通安装区段和函数不能调用卸载函数，而卸载区段和卸载函数也不能调用普通函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Function</span> <span class="title function_">.onInit</span></span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Function</span> <span class="title function_">onGUIInit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装成功以后.</span></span><br><span class="line"><span class="keyword">Function</span> <span class="title function_">.onInstSuccess</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载操作开始前.</span></span><br><span class="line"><span class="keyword">Function</span> <span class="title function_">un</span>.onInit</span><br><span class="line">    <span class="keyword">MessageBox</span> <span class="params">MB_ICONQUESTION</span>|<span class="params">MB_YESNO</span> <span class="string">"你确实要完全删除网易云音乐，及其所有组件吗?"</span> /SD <span class="params">IDYES</span> <span class="params">IDYES</span> +<span class="number">2</span> <span class="params">IDNO</span> +<span class="number">1</span></span><br><span class="line">    <span class="keyword">Abort</span></span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载成功以后.</span></span><br><span class="line"><span class="keyword">Function</span> <span class="title function_">un</span>.onUninstSuccess</span><br><span class="line">    <span class="keyword">MessageBox</span> <span class="params">MB_ICONINFORMATION</span>|<span class="params">MB_OK</span> <span class="string">"<span class="variable">${PRODUCT_NAME}</span> 已成功地从你的计算机移除"</span> /SD <span class="params">IDOK</span></span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br></pre></td></tr></tbody></table></figure><h1 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h1><p><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-xdjm-1.png"><br><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-xdjm-2.png"><br><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-xdjm-3.png"><br><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-xdjm-4.png"><br><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-xdjm-5.png"><br><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-xdjm-6.png"></p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 打包狂魔之NSIS教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSIS教程(4)-传统界面示例</title>
      <link href="/post/275632694.html"/>
      <url>/post/275632694.html</url>
      
        <content type="html"><![CDATA[<p>本文以一个完整的、传统界面的网易云音乐安装包的脚本为示例，来介绍 NSIS 传统用户界面的开发流程。</p><span id="more"></span><h1 id="网易云音乐安装脚本"><a href="#网易云音乐安装脚本" class="headerlink" title="网易云音乐安装脚本"></a>网易云音乐安装脚本</h1><p>完整的示例脚本如下，脚本中包含了详细的注释加以解释说明。请将下面脚本保存为.nsi 文件（需使用 ANSI 编码保存），编译即可生成安装包。</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单行注释用井号"#"或分号";"，跨行注释用可以用C/C++中注释语法。</span></span><br><span class="line"><span class="comment"># 使用!define定义一些常量（如安装包的版本号等）</span></span><br><span class="line"><span class="comment"># 对常量或变量的引用可以使用如${PRODUCT_NAME}格式，也可以使用如$PRODUCT_NAME格式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">!define</span> PRODUCT_NAME           <span class="string">"网易云音乐"</span></span><br><span class="line"><span class="keyword">!define</span> EXE_NAME               <span class="string">"cloudmusic.exe"</span></span><br><span class="line"><span class="keyword">!define</span> PRODUCT_VERSION        <span class="string">"1.0.0.1"</span></span><br><span class="line"><span class="keyword">!define</span> PRODUCT_PUBLISHER      <span class="string">"NetEase"</span></span><br><span class="line"><span class="keyword">!define</span> PRODUCT_LEGAL          <span class="string">"NetEase 1999-2014"</span></span><br><span class="line"><span class="keyword">!define</span> TEMP_DIR               <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NSIS内置了一些常用的变量，如</span></span><br><span class="line"><span class="comment">$INSTDIR 表示用户定义的解压路径；</span></span><br><span class="line"><span class="comment">$DESKTOP 表示Windows桌面目录；</span></span><br><span class="line"><span class="comment">等等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">也可以用 Var 命令来声明自己的变量($VARNAME)。 NSIS的变量都是全局的并且可以在任何区段或函数中使用。</span></span><br><span class="line"><span class="comment">另外堆栈可以用来作为临时存储。 使用 Push 和 Pop 命令来访问堆栈。Push把一个值添加到堆栈，Pop移除一个值并且设置该变量。</span></span><br><span class="line"><span class="comment">且NSIS内置了20个已注册的变量 (如 $0~$9 和 $R0~$R9)。 这些变量不需要声明就可以使用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义安装包可执行文件的版本信息</span></span><br><span class="line"><span class="keyword">VIProductVersion</span>                    <span class="string">"<span class="variable">${PRODUCT_VERSION}</span>"</span></span><br><span class="line"><span class="keyword">VIAddVersionKey</span> <span class="string">"ProductVersion"</span>    <span class="string">"<span class="variable">${PRODUCT_VERSION}</span>"</span></span><br><span class="line"><span class="keyword">VIAddVersionKey</span> <span class="string">"ProductName"</span>       <span class="string">"<span class="variable">${PRODUCT_NAME}</span>"</span></span><br><span class="line"><span class="keyword">VIAddVersionKey</span> <span class="string">"CompanyName"</span>       <span class="string">"<span class="variable">${PRODUCT_PUBLISHER}</span>"</span></span><br><span class="line"><span class="keyword">VIAddVersionKey</span> <span class="string">"FileVersion"</span>       <span class="string">"<span class="variable">${PRODUCT_VERSION}</span>"</span></span><br><span class="line"><span class="keyword">VIAddVersionKey</span> <span class="string">"InternalName"</span>      <span class="string">"<span class="variable">${EXE_NAME}</span>"</span></span><br><span class="line"><span class="keyword">VIAddVersionKey</span> <span class="string">"FileDescription"</span>   <span class="string">"<span class="variable">${PRODUCT_NAME}</span>"</span></span><br><span class="line"><span class="keyword">VIAddVersionKey</span> <span class="string">"LegalCopyright"</span>    <span class="string">"<span class="variable">${PRODUCT_LEGAL}</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==================== NSIS属性 ================================</span></span><br><span class="line"><span class="comment"># 设置安装包的压缩方案，有ZLIB（默认）、BZIP2、LZMA</span></span><br><span class="line"><span class="keyword">SetCompressor</span> <span class="literal">lzma</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 设置安装包名字，显示在安装包标题栏等位置</span></span><br><span class="line"><span class="keyword">Name</span> <span class="string">"<span class="variable">$PRODUCT_NAME</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装包可执行程序文件名</span></span><br><span class="line"><span class="keyword">OutFile</span> <span class="string">"网易云音乐安装-Basic UI.exe"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装包默认安装位置，也就是安装路径的默认值</span></span><br><span class="line"><span class="keyword">InstallDir</span> <span class="string">"<span class="variable constant_">$PROGRAMFILES</span>\Netease\CloudMusic"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置是否显示安装详细信息</span></span><br><span class="line"><span class="keyword">ShowInstDetails</span> <span class="literal">hide</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置是否显示卸载详细信息</span></span><br><span class="line"><span class="keyword">ShowUnInstDetails</span>   <span class="literal">hide</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对Vista和win7+ 的UAC进行权限请求.</span></span><br><span class="line"><span class="comment"># RequestExecutionLevel none|user|highest|admin</span></span><br><span class="line"><span class="keyword">RequestExecutionLevel</span> <span class="literal">admin</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装和卸载程序的图标</span></span><br><span class="line"><span class="keyword">Icon</span>             <span class="string">"image\logo.ico"</span></span><br><span class="line"><span class="keyword">UninstallIcon</span>    <span class="string">"image\un_logo.ico"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">向导页面是NSIS安装程序中最重要的界面元素，在nsis脚本中可以使用NSIS内置页面或者定制界面，</span></span><br><span class="line"><span class="comment">通过脚本可以指定页面的顺序、显示样子和行为。 PageEx指令用来定义安装程序中的页面，也可以使用Page指令，但PageEx提供更多选项；UninstPage用来定义卸载页面。</span></span><br><span class="line"><span class="comment">页面显示的顺序和它在nsis脚本中定义的次序一致。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">安装页面有：license|components|directory|instfiles|</span></span><br><span class="line"><span class="comment">卸载页面有：uninstConfirm</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">每个页面有不同元素和属性。</span></span><br><span class="line"><span class="comment">也可以使用Page custom来自定义页面，这个后面的文章有讲到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">PageEx</span> <span class="literal">license</span></span><br><span class="line">    <span class="keyword">LicenseData</span> <span class="string">"license.rtf"</span>       <span class="comment">#可以是txt或rtf文件格式</span></span><br><span class="line">PageExEnd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在一个普通的安装包里用户需要安装许多东西。例如在NSIS安装包里你可以选择安装源码、附加插件、脚本样例或其他。</span></span><br><span class="line"><span class="comment">里面的每个组件都有它自己的代码块，当用户选择了安装该组件，那么安装程序就会执行对应的代码。</span></span><br><span class="line"><span class="comment">在脚本里，这些代码称为区段，见下面的Section。每个可见的区段都可以作为一个组件给用户选择是否安装。你可以只使用一个区段来构建安装包，但是如果你想要使用组件页来让用户选择可选的组件，那你就需要使用多个区段。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">PageEx</span> <span class="literal">components</span></span><br><span class="line">    <span class="keyword">Caption</span> <span class="string">"组件选择"</span></span><br><span class="line">    <span class="keyword">ComponentText</span> <span class="string">"选择安装组件："</span> <span class="string">"主程序"</span> <span class="string">"快捷方式"</span></span><br><span class="line">PageExEnd</span><br><span class="line"></span><br><span class="line"><span class="keyword">PageEx</span> <span class="literal">directory</span></span><br><span class="line">    <span class="keyword">Caption</span> <span class="string">"安装目录"</span></span><br><span class="line">    <span class="keyword">DirText</span> <span class="string">"请选择安装目录："</span></span><br><span class="line">PageExEnd</span><br><span class="line"></span><br><span class="line"><span class="keyword">PageEx</span> <span class="literal">instfiles</span></span><br><span class="line">PageExEnd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 区段1</span></span><br><span class="line"><span class="comment"># 区段名以一个!开头，那么该区段的显示名称将以粗体字显示.</span></span><br><span class="line"><span class="keyword">Section</span> <span class="string">"!Files"</span> <span class="string">"des_files"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 设置下面指定的文件在安装时默认的解压路径</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="variable">$INSTDIR</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 指明哪些文件需要被压缩进入安装包，"app\*.*"是相对于nsis脚本文件的相对路径</span></span><br><span class="line">  <span class="keyword">File</span> /r <span class="string">"app\*.*"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SectionEnd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 区段2</span></span><br><span class="line"><span class="comment"># 该区段专门用来创建一些快捷方式</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">Section</span> <span class="string">"Shortcut"</span> <span class="string">"des_shortcut"</span></span><br><span class="line">  <span class="keyword">SetShellVarContext</span> <span class="literal">all</span></span><br><span class="line">  <span class="keyword">CreateDirectory</span> <span class="string">"<span class="variable constant_">$SMPROGRAMS</span>\<span class="variable">${PRODUCT_NAME}</span>"</span></span><br><span class="line">  <span class="keyword">CreateShortCut</span> <span class="string">"<span class="variable constant_">$SMPROGRAMS</span>\<span class="variable">${PRODUCT_NAME}</span>\<span class="variable">${PRODUCT_NAME}</span>.lnk"</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\<span class="variable">${EXE_NAME}</span>"</span></span><br><span class="line">  <span class="keyword">CreateShortCut</span> <span class="string">"<span class="variable constant_">$SMPROGRAMS</span>\<span class="variable">${PRODUCT_NAME}</span>\卸载<span class="variable">${PRODUCT_NAME}</span>.lnk"</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\uninst.exe"</span></span><br><span class="line">  <span class="keyword">SetShellVarContext</span> <span class="literal">current</span></span><br><span class="line"><span class="keyword">SectionEnd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 区段3</span></span><br><span class="line"><span class="comment"># 区段名为空、遗漏或者以一个 "-" 开头，那么它将是一个隐藏的区段，用户也不能选择禁止它.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">Section</span> <span class="string">"-Necessary"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 生成卸载程序</span></span><br><span class="line">  <span class="keyword">WriteUninstaller</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\uninst.exe"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 添加卸载信息到控制面板</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="params">HKLM</span> <span class="string">"Software\Microsoft\Windows\CurrentVersion\Uninstall\<span class="variable">${PRODUCT_NAME}</span>"</span> <span class="string">"DisplayName"</span> <span class="string">"<span class="variable">${PRODUCT_NAME}</span>"</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="params">HKLM</span> <span class="string">"Software\Microsoft\Windows\CurrentVersion\Uninstall\<span class="variable">${PRODUCT_NAME}</span>"</span> <span class="string">"UninstallString"</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\uninst.exe"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  在NSIS脚本里每一行都作为一个命令处理，如果这一行太长的话你可以使用“\”来分隔，编译器会自动地把下一行接到上一行来作为完整的一行，而不是看作新的行。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="params">HKLM</span> <span class="string">"Software\Microsoft\Windows\CurrentVersion\Uninstall\<span class="variable">${PRODUCT_NAME}</span>"</span> <span class="string">"DisplayIcon"</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\<span class="variable">${EXE_NAME}</span>"</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="params">HKLM</span> <span class="string">"Software\Microsoft\Windows\CurrentVersion\Uninstall\<span class="variable">${PRODUCT_NAME}</span>"</span> <span class="string">"Publisher"</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\<span class="variable">${PRODUCT_PUBLISHER}</span>"</span></span><br><span class="line"><span class="keyword">SectionEnd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载区段，如果一个区段名为“Uninstall”或以“un.”为前缀，那么它就是一个卸载程序区段。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">Section</span> <span class="string">"Uninstall"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 删除快捷方式，SetShellVarContext 设置操作是针对当前用户还是所有用户</span></span><br><span class="line">  <span class="keyword">SetShellVarContext</span> <span class="literal">all</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">"<span class="variable constant_">$SMPROGRAMS</span>\<span class="variable">${PRODUCT_NAME}</span>\<span class="variable">${PRODUCT_NAME}</span>.lnk"</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">"<span class="variable constant_">$SMPROGRAMS</span>\<span class="variable">${PRODUCT_NAME}</span>\卸载<span class="variable">${PRODUCT_NAME}</span>.lnk"</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">"<span class="variable constant_">$SMPROGRAMS</span>\<span class="variable">${PRODUCT_NAME}</span>\"</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">"<span class="variable constant_">$DESKTOP</span>\<span class="variable">${PRODUCT_NAME}</span>.lnk"</span></span><br><span class="line">  <span class="keyword">SetShellVarContext</span> <span class="literal">current</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 删除安装的文件</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\*.*"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">"<span class="variable constant_">$DESKTOP</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">RMDir</span> /r <span class="string">"<span class="variable constant_">$INSTDIR</span>"</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SetAutoClose</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">SectionEnd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================== 回调函数 ====================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数名以“.”开头的一般作为回调函数保留.</span></span><br><span class="line"><span class="comment"># 函数名以“un.”开头的函数将会被创建在卸载程序里，因此，普通安装区段和函数不能调用卸载函数，而卸载区段和卸载函数也不能调用普通函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Function</span> <span class="title function_">.onInit</span></span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Function</span> <span class="title function_">.onGUIInit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装成功以后.</span></span><br><span class="line"><span class="keyword">Function</span> <span class="title function_">.onInstSuccess</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载操作开始前.</span></span><br><span class="line"><span class="keyword">Function</span> <span class="title function_">un</span>.onInit</span><br><span class="line">    <span class="keyword">MessageBox</span> <span class="params">MB_ICONQUESTION</span>|<span class="params">MB_YESNO</span> <span class="string">"你确实要完全删除网易云音乐，及其所有组件吗?"</span> /SD <span class="params">IDYES</span> <span class="params">IDYES</span> +<span class="number">2</span> <span class="params">IDNO</span> +<span class="number">1</span></span><br><span class="line">    <span class="keyword">Abort</span></span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载成功以后.</span></span><br><span class="line"><span class="keyword">Function</span> <span class="title function_">un</span>.onUninstSuccess</span><br><span class="line">    <span class="keyword">MessageBox</span> <span class="params">MB_ICONINFORMATION</span>|<span class="params">MB_OK</span> <span class="string">"<span class="variable">${PRODUCT_NAME}</span> 已成功地从你的计算机移除"</span> /SD <span class="params">IDOK</span></span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br></pre></td></tr></tbody></table></figure><p>上述脚本会将与脚本相同级别的 app 目录下的全部文件（含子目录）打包进安装包。<code>image\logo.ico</code>和<code>image\un_logo.ico</code>分别是安装包和卸载程序的图标。</p><h1 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h1><p><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-ctjm-1.png"><br><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-ctjm-2.png"><br><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-ctjm-3.png"><br><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-ctjm-4.png"><br><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-ctjm-5.png"></p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 打包狂魔之NSIS教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSIS教程(3)-完整指令</title>
      <link href="/post/2673115526.html"/>
      <url>/post/2673115526.html</url>
      
        <content type="html"><![CDATA[<p>本文列出了 NSIS 支持的完整指令，以供查阅。</p><span id="more"></span><h1 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h1><p>NSIS 用于脚本的这些指令稍微的近似于 PHP 和汇编。他们没有真正的高级语言结构，但是他们的指令(对于绝大部分)却是高级的，并且你可以很容易的掌握(比如你不用担心字串的连接等等)。NSIS 为你提供了 25 个寄存器(20 个常规用途，5 个特殊用途)，和一个堆栈。</p><h2 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[/REBOOTOK] 文件</span><br></pre></td></tr></tbody></table></figure><p>从目标系统删除文件(可以是文件或通配符，但必须指定一个完整的路径)。如果指定了“/REBOOTOK”并且该文件当前不可删除，则会在系统重启时删除该文件 – 如果该文件要在系统重启时删除，你还要设置一个重启的位标计。如果找到的文件不能被删除则会置一个错误位标计。但该错误位标计不是从尝试删除一个不存在的文件设置的。</p><h2 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a>Exec</h2><p>命令执行一个指定的程序并且立即继续安装。注意指定的文件必须存在于目标系统而不是编译的系统。$OUTDIR 用于指定工作路径。如果该命令不能被运行则会置一个错误位标计。注意，如果该命令包含有空格，你要用引号来把他们包括起来。例如：Exec ‘“$INSTDIR\command.exe” 参数’。如果你不用引号括起来则在 Windwos 9X 下不正常或丢失参数。</p><h2 id="ExecShell"><a href="#ExecShell" class="headerlink" title="ExecShell"></a>ExecShell</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动作 命令 [参数] [SW_SHOWNORMAL | SW_SHOWMAXIMIZED | SW_SHOWMINIMIZED]</span><br></pre></td></tr></tbody></table></figure><p>使用 Windows 的外壳关联来执行一个指定的程序。注意“动作”通常为“open”、“print”等等，也可以是一个空字串来使用默认动作。参数和显示类型是可选项。$OUTDIR 用于指定工作路径。如果该处理不能被运行则会置一个错误位标计。</p><h2 id="ExecWait"><a href="#ExecWait" class="headerlink" title="ExecWait"></a>ExecWait</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令 [用户变量(退出代码)]</span><br></pre></td></tr></tbody></table></figure><p>执行一个指定的程序并且等待运行处理结束。更多信息请查看 Exec。如果没有用户输出变量 ExecWait 会置一个错误位标计当程序执行返回一个非零错误代码，或者当产生错误时。如果指定了输出变量，ExecWait 会把变量置为退出代码(并且仅当产生一个错误时置一个错误位标计；如果产生一个错误则该用户变量的内容为未指定)。注意，如果该命令包含有空格，你要用引号来把他们包括起来。例如：Exec ‘“$INSTDIR\command.exe” 参数’。如果你不用引号括起来则在 Windwos 9X 下不正常或丢失参数。</p><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[/nonfatal] [/a] ([/r] (文件|通配符) [...] | /oname=输出路径\文件名 输入路径\文件名)</span><br></pre></td></tr></tbody></table></figure><p>释放文件到当前输出路径($OUTDIR).</p><p>注意输出文件名是 $OUTDIR\文件名。</p><p>如果使用了 /oname=X 开关，则输出名变为 $OUTDIR\X。当使用了 /oname= 开关时只能指定一个文件，且文件名可以使用变量(或完整路径如 $SYSDIR\whatever.dll)。<br>支持通配符。</p><p>如果使用了 /r 开关，文件和目录将会被递归添加。如果没有尾随通配符(如 File /r C:\whatever\mydir)，则整个 mydir 目录树将会被添加到 $OUTDIR。如果要使它放到 $OUTDIR 请使用 File /r C:\whatever\mydir*.*。</p><p>如果使用了 /a 开关，被添加的文件的属性将会被保护。</p><p>如果覆盖模式被设定为 “try” 并且文件未被覆盖，那么 File 命令将会置一个错误位标计，或者如果覆盖模式被设定为 “on” 并且文件未被覆盖并且用户选择了忽略，那么也会被置一个错误位标计。</p><p>如果使用了 /nonfatal 开关，当文件未找到时使用警告来代替错误。</p><h2 id="Rename"><a href="#Rename" class="headerlink" title="Rename"></a>Rename</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[/REBOOTOK] 源文件 目标文件</span><br></pre></td></tr></tbody></table></figure><p>把源文件重命名为目标文件。你可以用它来把用户系统里的任何地方的一个文件移动到用户系统里的任何地方，你也可以在一些驱动器上把一个目录移动到某些地方。目标文件必须为不存在否则移动失败(除非你使用了 /REBOOTOK)。如果指定了 /REBOOTOK，并且文件当时不能移动(比如，目标文件已存在)，则该文件在系统重启后才被移动到目标。如果文件在重启后才被移动，会置一个重启的位标计。当文件不能被重命名时(并且没有使用 /REBOOTOK)或者原文件不存在时，会置一个错误位标计。</p><p>如果没有指定绝对路径则使用当前路径代替。当前路径可以使用 SetOutPath 指令来设置。如果你没有使用 SetOutPath 那么当前路径为 $EXEDIR。</p><h2 id="ReserveFile"><a href="#ReserveFile" class="headerlink" title="ReserveFile"></a>ReserveFile</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[/nonfatal] [/r] 文件 [文件...]</span><br></pre></td></tr></tbody></table></figure><p>保存一个文件在最后使用的数据区块。之所以要把在脚本中使用到的文件，这样添加是因为要在 .onInit 函数里使用，例如使得安装程序载入变慢。这时候这个命令就非常有用了，它可以把文件包含在数据区块的顶端而不是让 NSIS 从已压缩的数据区块从头搜到脚来找这个文件，这样可以加快安装程序载入速度。</p><p>相关参数说明请查看 File。</p><h2 id="RMDir"><a href="#RMDir" class="headerlink" title="RMDir"></a>RMDir</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[/r|/REBOOTOK] 目录名</span><br></pre></td></tr></tbody></table></figure><p>删除指定的目录(完整的路径)。没有 /r 参数时只有在目录为空时才会被删除。如果指定了 /r，则目录会被递归删除，所以在指定目录下的所有文件和目录均被删除。如果指定了 /REBOOTOK，并且目录不能被覆盖，则当系统重启的时候会被删除 —— 如果目录需要在重启时被删除，会设一个重启的位标计。当目录不能被删除时会置一个错误的位标计。</p><h2 id="SetOutPath"><a href="#SetOutPath" class="headerlink" title="SetOutPath"></a>SetOutPath</h2><p>输出路径设置输出路径($OUTDIR)且当路径不存在时创建(需要时递归)。必须为全路径名，通常使用 $INSTDIR。</p><h1 id="注册表、INI-文件指令"><a href="#注册表、INI-文件指令" class="headerlink" title="注册表、INI 文件指令"></a>注册表、INI 文件指令</h1><p>在下面所有的注册表指令里使用一个空字串(“”)来作为某个子健默认项，该默认项在注册表编辑器里显示为“(默认)”。</p><h2 id="DeleteINISec"><a href="#DeleteINISec" class="headerlink" title="DeleteINISec"></a>DeleteINISec</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INI_文件名 区段名</span><br></pre></td></tr></tbody></table></figure><p>从“INI_文件名”里删除整个区段 [区段名]。如果该区段不能被删除，会置一个错误的位标计。但是如果该区段找不到时则不会置错误位标计。</p><h2 id="DeleteINIStr"><a href="#DeleteINIStr" class="headerlink" title="DeleteINIStr"></a>DeleteINIStr</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INI_文件名 区段名 字串名</span><br></pre></td></tr></tbody></table></figure><p>从“INI_文件名”里的 [区段名] 区段删除“字串名”字串。如果该字串不能被删除，会置一个错误的位标计。但是如果该字串找不到时则不会置错误位标计。</p><h2 id="DeleteRegKey"><a href="#DeleteRegKey" class="headerlink" title="DeleteRegKey"></a>DeleteRegKey</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[/ifempty] 根键 子键</span><br></pre></td></tr></tbody></table></figure><p>删除一个注册表键。如果指定了 /ifempty，则该注册表键仅当它无子键时才会被删除(否则，整个注册表键将被删除)。有效的根键值在后面的 WriteRegStr 列出。如果该键不能被删除(或如果它不存在)则会置一个错误的位标计。</p><h2 id="DeleteRegValue"><a href="#DeleteRegValue" class="headerlink" title="DeleteRegValue"></a>DeleteRegValue</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根键 子键 键名</span><br></pre></td></tr></tbody></table></figure><p>删除一个注册表键值。有效的根键值在后面的 WriteRegStr 列出。如果该键值不能被删除(或如果它不存在)则会置一个错误的位标计。</p><h2 id="EnumRegKey"><a href="#EnumRegKey" class="headerlink" title="EnumRegKey"></a>EnumRegKey</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(输出) 根键 子键 索引</span><br></pre></td></tr></tbody></table></figure><p>把用户变量 $x 设为“根键\子键”第“索引”号注册表键名。有效的根键值在后面的 WriteRegStr 列出。当指定的“根键\子键”没有任何键时会返回一个空字串，当产生一个错误时会返回空字串并置一个错误位标计。</p><h2 id="EnumRegValue"><a href="#EnumRegValue" class="headerlink" title="EnumRegValue"></a>EnumRegValue</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(输出) 根键 子键 索引</span><br></pre></td></tr></tbody></table></figure><p>把用户变量 $x 设为“根键\子键”第“索引”号注册表键值。有效的根键值在后面的 WriteRegStr 列出。当指定的“根键\子键”没有任何键值时会返回一个空字串，当产生一个错误时会返回空字串并置一个错误位标计。</p><h2 id="ExpandEnvStrings"><a href="#ExpandEnvStrings" class="headerlink" title="ExpandEnvStrings"></a>ExpandEnvStrings</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(输出) 字串</span><br></pre></td></tr></tbody></table></figure><p>把“字串”里的环境变量扩展到用户变量 $x。如果错误，该变量会被设为空值并置一个错误位标计。</p><h2 id="FlushINI"><a href="#FlushINI" class="headerlink" title="FlushINI"></a>FlushINI</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INI_文件名</span><br></pre></td></tr></tbody></table></figure><p>刷新 INI 文件缓冲。Windows 9x 会保持 INI 文件在内存里。该命令强制更改立即写入磁盘。当你自己编辑一个 INI 文件的时候可以使用它，删除、移动、复制，直到你使用 WriteINIStr、DeleteINISec 或 DeleteINStr 来更改它。</p><h2 id="ReadEnvStr"><a href="#ReadEnvStr" class="headerlink" title="ReadEnvStr"></a>ReadEnvStr</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(输出) 名称</span><br></pre></td></tr></tbody></table></figure><p>从环境字串“名称”读取值并把值赋给用户变量 $x。如果读取字串时有错误发生，该用户变量被设为空，并置一个错误位标计。</p><h2 id="ReadINIStr"><a href="#ReadINIStr" class="headerlink" title="ReadINIStr"></a>ReadINIStr</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(输出) INI_文件名 区段名 项名</span><br></pre></td></tr></tbody></table></figure><p>从“INI_文件名”的 [区段名] 区段读取“项名”的值并把该值赋给用户变量 $x。如果该项未找到时会置一个错误位标计且该用户变量被赋为空值。</p><h2 id="ReadRegDWORD"><a href="#ReadRegDWORD" class="headerlink" title="ReadRegDWORD"></a>ReadRegDWORD</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(输出) 根键 子键 项</span><br></pre></td></tr></tbody></table></figure><p>从注册表读取一个 32 位 DWORD 到用户变量 $x。有效的根键值在后面的 WriteRegStr 列出。如果 DWORD 不存在时会置一个错误位标计并把 $x 设为空字串。如果该值存在但不是 DWORD，则会作为字串类型读取并置一个错误位标计。</p><h2 id="ReadRegStr"><a href="#ReadRegStr" class="headerlink" title="ReadRegStr"></a>ReadRegStr</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(输出) 根键 子键 项</span><br></pre></td></tr></tbody></table></figure><p>从注册表读取一个字串值到用户变量 $x。有效的根键值在后面的 WriteRegStr 列出。如果字串不存在时会置一个错误位标计并把 $x 设为空字串。如果该值存在但是 DWORD，则会转换为字串类型并置一个错误位标计。</p><h2 id="WriteINIStr"><a href="#WriteINIStr" class="headerlink" title="WriteINIStr"></a>WriteINIStr</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INI_文件名 区段名 项名 值</span><br></pre></td></tr></tbody></table></figure><p>把“项名”=“值”写入“INI_文件名”的 [区段名] 区段。如果 INI 文件不能写入则置一个错误的位标计。</p><h2 id="WriteRegBin"><a href="#WriteRegBin" class="headerlink" title="WriteRegBin"></a>WriteRegBin</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根键 子键 项 值数据</span><br></pre></td></tr></tbody></table></figure><p>该命令将会写一个区块的二进制数据到注册表。有效的根键值在后面的 WriteRegStr 列出。值数据为十六进制格式(如 DEADBEEF01223211151)。如果该二进制数据不能写入注册表则置一个错误的位标计。如果注册表键不存在则会自动创建。“值数据”不能使用变量。</p><h2 id="WriteRegDWORD"><a href="#WriteRegDWORD" class="headerlink" title="WriteRegDWORD"></a>WriteRegDWORD</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根键 子键 项 值</span><br></pre></td></tr></tbody></table></figure><p>该命令写一个 DWORD(32 位整数)到注册表(可以使用变量)。有效的根键值在后面的 WriteRegStr 列出。如果该 DWORD 不能写入注册表则置一个错误的位标计。如果注册表键不存在则会自动创建。</p><p>4.9.2.16 WriteRegStr</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根键 子键 项 值</span><br></pre></td></tr></tbody></table></figure><p>把字串写入注册表。详细信息请查看 WriteRegExpandStr。</p><p>4.9.2.17 WriteRegExpandStr</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根键 子键 项 值</span><br></pre></td></tr></tbody></table></figure><p>把字串写入注册表。根键必须为下面列表之一:</p><ul><li>HKCR 或 HKEY_CLASSES_ROOT</li><li>HKLM 或 HKEY_LOCAL_MACHINE</li><li>HKCU 或 HKEY_CURRENT_USER</li><li>HKU 或 HKEY_USERS</li><li>HKCC 或 HKEY_CURRENT_CONFIG</li><li>HKDD 或 HKEY_DYN_DATA</li><li>HKPD 或 HKEY_PERFORMANCE_DATA</li></ul><p>如果字串不能写入注册表则置一个错误的位标计。字串的类型为 REG_SZ 对应 WriteRegStr，或 REG_EXPAND_STR 对应 WriteRegExpandStr。如果注册表键不存在则会自动创建。</p><h1 id="常规用途指令"><a href="#常规用途指令" class="headerlink" title="常规用途指令"></a>常规用途指令</h1><h2 id="CallInstDLL"><a href="#CallInstDLL" class="headerlink" title="CallInstDLL"></a>CallInstDLL</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DLL_文件 [/NOUNLOAD] 函数名</span><br></pre></td></tr></tbody></table></figure><p>从一个 NSIS 扩展动态链接库里调用一个函数名。看 Contrib\ExDLL 的样本可以知道如何来创建。扩展动态链接库可以访问堆栈和变量。使用 /NOUNLOAD 来强制安装程序保持动态链接库载入。注意: 要自动释放并调用 DLL 插件请使用插件命令来替换 CallInstDLL。</p><h2 id="CopyFiles"><a href="#CopyFiles" class="headerlink" title="CopyFiles"></a>CopyFiles</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[/SILENT] [/FILESONLY] 目标系统文件规范 目标路径 [文件大小_单位为_kb]</span><br></pre></td></tr></tbody></table></figure><p>在正在安装的系统中把“目标系统文件规范”复制到“目标路径”。</p><p>如果你想从安装媒体里复制，或从系统的一个地方复制到另一个地方，你可以使用 $EXEDIR 变量来代替安装程序目录。如果复制操作需要很长时间的话你可以看到 Windows 的复制文件窗口(要禁止出现复制文件窗口使用/SILENT)。最后的参数用来指定要复制的文件的大小(单位为 kb)，使安装程序可以估计所需磁盘空间。在出错，或用户退出(仅当忽略了 /SILENT 时)时，会置一个错误位标计。如果指定了 /FILESONLY 则仅复制文件。</p><p>如果没有指定绝对路径则使用当前路径代替。当前路径为最后一个 SetOutPath 指定的路径。如果没有使用任何 SetOutPath 指令则当前路径为 $EXEDIR。</p><h2 id="CreateDirectory"><a href="#CreateDirectory" class="headerlink" title="CreateDirectory"></a>CreateDirectory</h2><p>要创建的路径创建(必要时递归)指定的目录。当目录不能创建时是一个错误位标计。</p><p>你也可以指定一个绝对路径。</p><h2 id="CreateShortCut"><a href="#CreateShortCut" class="headerlink" title="CreateShortCut"></a>CreateShortCut</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快捷文件.lnk 目标文件 [参数 [图标文件 [图标索引号 [启动选项 [键盘快捷键 [描述]]]]]]</span><br></pre></td></tr></tbody></table></figure><p>创建一个指向“目标文件”的快捷方式“快捷文件.lnk”，可以带“参数”参数。</p><p>用于快捷方式的图标为“图标文件,图标索引号”；要使用默认图标的话把“图标文件”和“图标索引号”设为空字串。</p><p>“启动选项”可以是它们之一: SW_SHOWNORMAL, SW_SHOWMAXIMIZED, SW_SHOWMINIMIZED, 或一个空字串。</p><p>“键盘快捷键”应该为“flag|c”格式且 flag 可以联合使用(使用 |): ALT, CONTROL, EXT, 或 SHIFT。c 为要使用的字符(a-z, A-Z, 0-9, F1-F24 等等)。注意在这些字串里不能含有空格。一个典型的例子为 “ALT|CONTROL|F8”。$OUTDIR 被用来作为工作目录。你可以在创建快捷方式之前使用 SetOutPath 来指定或更改。“描述”为快捷方式的描述，或在 XP 下作为注释调用。</p><p>当快捷方式不能创建的时候会置一个错误位标计(例如路径不存在或一些其它错误)。</p><h2 id="GetDLLVersion"><a href="#GetDLLVersion" class="headerlink" title="GetDLLVersion"></a>GetDLLVersion</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件名 用户变量(高位_DWORD_输出) 用户变量(低位_DWORD_输出)</span><br></pre></td></tr></tbody></table></figure><p>从“文件名” DLL(或其他包含版本信息的可执行文件)取得版本信息。成功时把版本信息高位 DWORD 和低位 DWORD 设为用户输出变量；失败时输出为空且置错误位标计。下面的例子演示了读取一个 DLL 版本并可读的版本到 $0:</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GetDllVersion</span> <span class="string">"<span class="variable constant_">$INSTDIR</span>\MyDLL.dll"</span> <span class="variable">$R0</span> <span class="variable">$R1</span></span><br><span class="line"><span class="keyword">IntOp</span> <span class="variable">$R2</span> <span class="variable">$R0</span> / <span class="number">0</span>x00010000</span><br><span class="line"><span class="keyword">IntOp</span> <span class="variable">$R3</span> <span class="variable">$R0</span> &amp; <span class="number">0</span>x0000FFFF</span><br><span class="line"><span class="keyword">IntOp</span> <span class="variable">$R4</span> <span class="variable">$R1</span> / <span class="number">0</span>x00010000</span><br><span class="line"><span class="keyword">IntOp</span> <span class="variable">$R5</span> <span class="variable">$R1</span> &amp; <span class="number">0</span>x0000FFFF</span><br><span class="line"><span class="keyword">StrCpy</span> <span class="variable">$0</span> <span class="string">"<span class="variable">$R2.</span><span class="variable">$R3.</span><span class="variable">$R4.</span><span class="variable">$R5</span>"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="GetDLLVersionLocal"><a href="#GetDLLVersionLocal" class="headerlink" title="GetDLLVersionLocal"></a>GetDLLVersionLocal</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内部文件 用户变量(高位_DWORD_输出) 用户变量(低位_DWORD_输出)</span><br></pre></td></tr></tbody></table></figure><p>类似于 GetDLLVersion，但它仅用于获取安装程序内部文件的信息(它实际上编译为两个 StrCpy 命令)。成功时把内部文件的版本信息高位 DWORD 和低位 DWORD 设为用户输出变量。</p><h2 id="GetFileTime"><a href="#GetFileTime" class="headerlink" title="GetFileTime"></a>GetFileTime</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件名 用户变量(高位_DWORD_输出) 用户变量(低位_DWORD_输出)</span><br></pre></td></tr></tbody></table></figure><p>获取“文件名”的最后写入时间。成功时把时间戳信息高位 DWORD 和低位 DWORD 输出到用户输出变量;失败时输出为空且置一个错误位标计。</p><h2 id="GetFileTimeLocal"><a href="#GetFileTimeLocal" class="headerlink" title="GetFileTimeLocal"></a>GetFileTimeLocal</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内部文件 用户变量(高位_DWORD_输出) 用户变量(低位_DWORD_输出)</span><br></pre></td></tr></tbody></table></figure><p>类似于 GetFileTime，但它仅用于获取安装程序内部文件的信息(它实际上编译为两个 StrCpy 命令)。</p><h2 id="GetFullPathName"><a href="#GetFullPathName" class="headerlink" title="GetFullPathName"></a>GetFullPathName</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[/SHORT] 用户变量(输出) 路经或文件</span><br></pre></td></tr></tbody></table></figure><p>把指定的文件完整路径信息输出到用户变量 $x。如果参数的部分路径未找到，则置一个错误位标记并清空 $x。如果指定了 /SHORT，路经将会被转换为短文件名格式。</p><h2 id="GetTempFileName"><a href="#GetTempFileName" class="headerlink" title="GetTempFileName"></a>GetTempFileName</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(输出) [基本路径]</span><br></pre></td></tr></tbody></table></figure><p>把一个临时文件的名称输出到用户变量 $x。该文件会自动创建，所以你可以随时的覆盖它。该临时文件的名称唯一。如果你希望这个临时文件创建在另一个目录而不是 Windows 临时目录的话指定一个“基本路径”给它。你需要在完成之后手动删除它。</p><h2 id="SearchPath"><a href="#SearchPath" class="headerlink" title="SearchPath"></a>SearchPath</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(输出) 文件名</span><br></pre></td></tr></tbody></table></figure><p>由第二个参数指定的文件名的全路径输出到用户变量 $x。如果该文件不存在则会置一个错误位标记并清空 $x。使用 SearchPath() 来在系统目录里搜索文件。</p><h2 id="SetFileAttributes"><a href="#SetFileAttributes" class="headerlink" title="SetFileAttributes"></a>SetFileAttributes</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件名 属性 1|属性 2|...</span><br></pre></td></tr></tbody></table></figure><p>设置“文件名”的属性。多从属性可用 | 隔开，有效的属性为:</p><ul><li>NORMAL 或 FILE_ATTRIBUTE_NORMAL (你可以把该项缩写为 0)</li><li>ARCHIVE 或 FILE_ATTRIBUTE_ARCHIVE</li><li>HIDDEN 或 FILE_ATTRIBUTE_HIDDEN</li><li>OFFLINE 或 FILE_ATTRIBUTE_OFFLINE</li><li>READONLY 或 FILE_ATTRIBUTE_READONLY</li><li>SYSTEM 或 FILE_ATTRIBUTE_SYSTEM</li><li>TEMPORARY 或 FILE_ATTRIBUTE_TEMPORARY</li></ul><p>如果文件的属性不能被设置则置一个错误的位标计(例如文件不存在，或者你没有足够的权限)。你只能进行属性设置，而不能移除属性，如果你想移除的话请使用 NORMAL。这样所有的属性都会被擦除，该命令不支持通配符。</p><h2 id="RegDLL"><a href="#RegDLL" class="headerlink" title="RegDLL"></a>RegDLL</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DLL_文件 [入口点名称]</span><br></pre></td></tr></tbody></table></figure><p>载入指定的 DLL 并且调用 DllRegisterServer (或入口点名称，当指定之后)。当产生一个错误的时候会置一个错误位标计(例如不能载入 DLL，不能初始化 OLE，不能找到入口点，或者函数返回任何其它错误 ERROR_SUCCESS (=0))。</p><p>当某些要注册的 DLL 要依靠其它的位于同目录或 Windows 目录下的 DLL 时请用 SetOutPath 来设定当前目录。例如，如果 foo.dll 依靠位于 $INSTDIR 的 bar.dll 时:</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SetOutPath</span> <span class="variable">$INSTDIR</span></span><br><span class="line"><span class="keyword">RegDLL</span> <span class="variable">$INSTDIR</span>\foo.dll</span><br></pre></td></tr></tbody></table></figure><h2 id="UnRegDLL"><a href="#UnRegDLL" class="headerlink" title="UnRegDLL"></a>UnRegDLL</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DLL_文件</span><br></pre></td></tr></tbody></table></figure><p>载入指定的 DLL 并且调用 DllUnregisterServer。当产生一个错误的时候会置一个错误位标计(例如不能载入 DLL，不能初始化 OLE，不能找到入口点，或者函数返回任何其它错误 ERROR_SUCCESS (=0))。</p><h1 id="流程控制指令"><a href="#流程控制指令" class="headerlink" title="流程控制指令"></a>流程控制指令</h1><h2 id="Abort"><a href="#Abort" class="headerlink" title="Abort"></a>Abort</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[用户信息]</span><br></pre></td></tr></tbody></table></figure><p>取消安装，停止执行脚本，并且在状态显示里显示用户信息。注意: 你可以用于回调函数来实现一些特殊功能。页面回调也可以用 Abort 来实现特殊目的。</p><h2 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名 | :标记名</span><br></pre></td></tr></tbody></table></figure><p>调用“函数名”函数。如果在 Uninstall 区段，Call 仅能调用以“un.”开头的函数名。如果参数以一个“:”开始则它竟会被认为是一个标记(所以你可以在你的函数里调用一个标记 - 这样大概不会使用太多的时间)。</p><h2 id="ClearErrors"><a href="#ClearErrors" class="headerlink" title="ClearErrors"></a>ClearErrors</h2><p>清除错误位标记。</p><h2 id="GetCurrentAddress"><a href="#GetCurrentAddress" class="headerlink" title="GetCurrentAddress"></a>GetCurrentAddress</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(输出)</span><br></pre></td></tr></tbody></table></figure><p>获取当前指令的地址(GetCurrentAddress)并且把它保存到用户输出变量。该用户变量可以传递到 Call 或 Goto。</p><h2 id="GetFunctionAddress"><a href="#GetFunctionAddress" class="headerlink" title="GetFunctionAddress"></a>GetFunctionAddress</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(输出) 函数名</span><br></pre></td></tr></tbody></table></figure><p>获取函数地址并且把它保存到用户输出变量。该用户变量可以传递到 Call 或 Goto。注意如果你 Goto 一个由 GetFunctionAddress 输出的地址，你的函数将不能返回(当你 Goto 的函数要返回时，你应该立即返回)。</p><h2 id="GetLabelAddress"><a href="#GetLabelAddress" class="headerlink" title="GetLabelAddress"></a>GetLabelAddress</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(输出) 标记</span><br></pre></td></tr></tbody></table></figure><p>获取标记地址并且把它保存到用户输出变量。该用户变量可以传递到 Call 或 Goto。需要注意的是你可能仅能从你的函数里随标记调用该指令，但是你可以从任何地方调用它(可能存在不稳定因素)。需要注意的是如果你调用(Call)了 GetLabelAddress 的输出，那么直到它返回时才会被执行(明确或隐含在一个函数的结尾)，然后你将回到 Call 指令的状态。.</p><h2 id="Goto"><a href="#Goto" class="headerlink" title="Goto"></a>Goto</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要跳转的标记 | +偏移| -偏移| 用户变量(目标)</span><br></pre></td></tr></tbody></table></figure><p>如果指定了标记，则跳转到“要跳转的标记:”。</p><p>如果指定了 +偏移 或 -偏移 ，跳转会根据偏移指令相对的跳转。Goto +1 跳转到下一条指令，Goto -1 跳转到上一条指令，等等。</p><p>如果指定了用户变量，则跳转到绝对地址(通常你可以从一个函数比如 GetLabelAddress 来取得该值)。编译器位标计命令和 SectionIn 不是指令所以跳转对它们无效。</p><h2 id="IfAbort"><a href="#IfAbort" class="headerlink" title="IfAbort"></a>IfAbort</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">退出时要跳转的标记 [不是退出时要跳转的标记]</span><br></pre></td></tr></tbody></table></figure><p>如果调用退出时它将“返回” true。这种情况可能发生在当一个文件不能创建(或覆盖)失败而用户选择退出时或者当用户手动退出时。该函数仅能在 instfiles 页面的离开函数里调用。</p><h2 id="IfErrors"><a href="#IfErrors" class="headerlink" title="IfErrors"></a>IfErrors</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误时跳转 [没有错误时跳转]</span><br></pre></td></tr></tbody></table></figure><p>检测并清除错误位标计，如果设了错误位标计，则跳转到“错误时跳转”，否则跳转到“没有错误时跳转”。错误位标计由其它指令在产生一个错误是设置的(比如试图去删除一个正在使用的文件)。</p><h2 id="IfFileExists"><a href="#IfFileExists" class="headerlink" title="IfFileExists"></a>IfFileExists</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要检测的文件 文件存在时跳转 [文件不存在时跳转]</span><br></pre></td></tr></tbody></table></figure><p>检测“要检测的文件”是否存在(可以用通配符，或目录)，并当文件存在时跳转到“文件存在时跳转”，否则跳转到“文件不存在时跳转”。如果你要检测目标是文件还是目录请使用 IfFileExists 目录<code>*.*</code></p><h2 id="IfRebootFlag"><a href="#IfRebootFlag" class="headerlink" title="IfRebootFlag"></a>IfRebootFlag</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[已设时跳转] [未设时跳转]</span><br></pre></td></tr></tbody></table></figure><p>至少需要一个参数。检测重启位标计，如果设置了重启位标计则跳转到“已设时跳转”，否则跳转到“未设时跳转”。重启位标计可以在 Delete 河 Rename，或手动设定的 SetRebootFlag 指令里设置。</p><h2 id="IfSilent"><a href="#IfSilent" class="headerlink" title="IfSilent"></a>IfSilent</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[静默安装时跳转] [非静默安装时跳转]</span><br></pre></td></tr></tbody></table></figure><p>至少需要一个参数。检测静默安装位标计，如果安装程序是静默安装时跳转到“静默安装时跳转”，否则跳转到“非静默安装时跳转”。静默安装位标计可以由 SilentInstall、SilentUninstall、SetSilent 和用户使用 /S 命令行启动来设置。</p><h2 id="IntCmp"><a href="#IntCmp" class="headerlink" title="IntCmp"></a>IntCmp</h2><p>值 1 值 2 相等时跳转 [值 1 小时跳转] [值 1 大时跳转]<br>比较两个整数 值 1 和 值 2。如果 值 1 和 值 2 相等，则跳转到“相等时跳转”，否则如果 值 1 &lt; 值 2，跳转到“值 1 小时跳转”，否则如果 值 1 &gt; 值 2 ，跳转到“值 1 大时跳转”。</p><h2 id="IntCmpU"><a href="#IntCmpU" class="headerlink" title="IntCmpU"></a>IntCmpU</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">值1 值2 相等时跳转 [值1小时跳转] [值1大时跳转]</span><br></pre></td></tr></tbody></table></figure><p>比较两个无符号整数 值 1 和 值 2。如果 值 1 和 值 2 相等，则跳转到“相等时跳转”，否则如果 值 1 &lt; 值 2，跳转到“值 1 小时跳转”，否则如果 值 1 &gt; 值 2 ，跳转到“值 1 大时跳转”。比较时作为无符号整数来比较。</p><h2 id="MessageBox"><a href="#MessageBox" class="headerlink" title="MessageBox"></a>MessageBox</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消息框选项列表 消息框文本 [/SD 返回] [检测返回值 跳转到] [检测返回值 2 跳转到 2]</span><br></pre></td></tr></tbody></table></figure><p>显示一个包含“消息框文本”的消息框。“消息框选项列表”必须为下面的一个或多个，多个使用 | 来隔开(例如 MB_YESNO|MB_ICONSTOP)。</p><ul><li>MB_OK - 显示 OK 按钮</li><li>MB_OKCANCEL - 显示 OK 和取消按钮</li><li>MB_ABORTRETRYIGNORE - 显示退出、重试、忽略按钮</li><li>MB_RETRYCANCEL - 显示重试和取消按钮</li><li>MB_YESNO - 显示是和否按钮</li><li>MB_YESNOCANCEL - 显示是、否、取消按钮</li><li>MB_ICONEXCLAMATION - 显示惊叹号图标</li><li>MB_ICONINFORMATION - 显示信息图标</li><li>MB_ICONQUESTION - 显示问号图标</li><li>MB_ICONSTOP - 显示终止图标</li><li>MB_TOPMOST - 使消息框在最前端显示</li><li>MB_SETFOREGROUND - 设置前景</li><li>MB_RIGHT - 右对齐文本</li><li>MB_DEFBUTTON1 - 默认为按钮 1</li><li>MB_DEFBUTTON2 - 默认为按钮 2</li><li>MB_DEFBUTTON3 - 默认为按钮 3</li><li>MB_DEFBUTTON4 - 默认为按钮 4</li></ul><p>“检测返回值”可以为 0(或空，或保留关闭)，或下列之一:</p><ul><li>IDABORT - 退出按钮</li><li>IDCANCEL - 取消按钮</li><li>IDIGNORE - 忽略按钮</li><li>IDNO - 否按钮</li><li>IDOK - OK 按钮</li><li>IDRETRY - 重试按钮</li><li>IDYES - 是按钮</li></ul><p>如果消息框的返回值为“检测返回值”，则安装程序执行跳转。</p><p>用 /SD 来指定一个上面列出的返回值当在安装程序静默安装时作为返回值。</p><h2 id="Return"><a href="#Return" class="headerlink" title="Return"></a>Return</h2><p>从一个函数或区段返回。</p><h2 id="Quit"><a href="#Quit" class="headerlink" title="Quit"></a>Quit</h2><p>使得安装程序立即退出。在调用 Quit 后，安装程序将退出(将没有回调函数可以运行)。</p><h2 id="SetErrors"><a href="#SetErrors" class="headerlink" title="SetErrors"></a>SetErrors</h2><p>设置错误位标计。</p><h2 id="StrCmp"><a href="#StrCmp" class="headerlink" title="StrCmp"></a>StrCmp</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字串1 字串2相同时跳转 [不相同时跳转]</span><br></pre></td></tr></tbody></table></figure><p>比较(不区分大小写)“字串 1”和“字串 2”。如果两者相等，跳转到“相同时跳转”，否则跳转到“不相同时跳转”。</p><h1 id="文件指令"><a href="#文件指令" class="headerlink" title="文件指令"></a>文件指令</h1><h2 id="FileClose"><a href="#FileClose" class="headerlink" title="FileClose"></a>FileClose</h2><p>句柄关闭一个由 FileOpen 打开的文件句柄。</p><h2 id="FileOpen"><a href="#FileOpen" class="headerlink" title="FileOpen"></a>FileOpen</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(句柄输出) 文件名 打开模式</span><br></pre></td></tr></tbody></table></figure><p>打开一个“文件名”的文件，并且把句柄设置为句柄输出变量。“打开模式”为“r”(只读)“w”(写入，文件的所有内容将被清空)或“a”(附加，保持文件内容并写入)其中之一。在所有的打开模式里，文件指针都置于文件起始位置。如果文件不能被打开，则句柄输出变量为空，并置一个错误位标计。</p><p>如果没有指定绝对路径则使用当前路径。当前路径由 SetOutPath 设置。如果之前没有使用 SetOutPath 则当前路径为 $EXEDIR。</p><h2 id="FileRead"><a href="#FileRead" class="headerlink" title="FileRead"></a>FileRead</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">句柄 用户变量(输出) [最大长度]</span><br></pre></td></tr></tbody></table></figure><p>读取一个由 FileOpen 打开的文件的字串。该字串一直读取到新的一行为止(或回车新行)。或直到读取到空的字节为止，或者直到读取的字串满足了“最大长度”(如果指定了的话)。字串的最大长度被限定在 1024 字节之内。如果读取到了文件的结尾却没有有效的数据则输出字串被清空，并置一个错误位标计。</p><h2 id="FileReadByte"><a href="#FileReadByte" class="headerlink" title="FileReadByte"></a>FileReadByte</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">句柄 用户变量(输出)</span><br></pre></td></tr></tbody></table></figure><p>读取一个由 FileOpen 打开的文件的字节。读取的字节作为一个整数(0-255)保存在输出变量里。如果读取到了文件的结尾却没有有效的数据则输出字串被清空，并置一个错误位标计。</p><h2 id="FileSeek"><a href="#FileSeek" class="headerlink" title="FileSeek"></a>FileSeek</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">句柄 偏移 [模式] [用户变量(新位置)]</span><br></pre></td></tr></tbody></table></figure><p>定位一个由 FileOpen 打开的文件。</p><p>如果“模式”忽略或指定为“SET”，则文件指针定位到“偏移”。</p><p>如果“模式”指定为“CUR”，则文件指针向后移动“偏移”。</p><p>如果文件指定为“END”，则指针定位到相对于文件结尾 EOF(End of file)处。</p><p>如果指定了最后一个参数“用户变量(新位置)”，则新文件位置将保存在该变量中。</p><h2 id="FileWrite"><a href="#FileWrite" class="headerlink" title="FileWrite"></a>FileWrite</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">句柄 字串</span><br></pre></td></tr></tbody></table></figure><p>写入一个字串到 FileOpen 打开的文件。如果写入时产生了错误，则置一个错误位标计。</p><h2 id="FileWriteByte"><a href="#FileWriteByte" class="headerlink" title="FileWriteByte"></a>FileWriteByte</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">句柄 字串</span><br></pre></td></tr></tbody></table></figure><p>写入“字串”解释为整数的值到 FileOpen 打开的文件。当然你也可以直接输入整数值。下面的代码写入一个“回车/换行” - 输入到文件。</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FileWriteByte</span> 文件句柄 <span class="string">"13"</span></span><br><span class="line"><span class="keyword">FileWriteByte</span> 文件句柄 <span class="string">"10"</span></span><br></pre></td></tr></tbody></table></figure><p>如果写入时产生了错误，则置一个错误位标计。需要注意的是整数仅低字节被使用，例如: 写入 256 和写入 0 一样，等等。</p><h2 id="FindClose"><a href="#FindClose" class="headerlink" title="FindClose"></a>FindClose</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">句柄</span><br></pre></td></tr></tbody></table></figure><p>关闭一个由 FindFirst 打开的搜索。</p><h2 id="FindFirst"><a href="#FindFirst" class="headerlink" title="FindFirst"></a>FindFirst</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(句柄输出) 用户变量(文件输出) 文件匹配格式</span><br></pre></td></tr></tbody></table></figure><p>按“文件匹配格式”执行一个搜索，把第一个查找到的文件放置到“用户变量(文件输出)”。也可以把搜索的句柄放到“用户变量(句柄输出)”。如果未找到任何文件，则输出都被设为空，并且置一个错误位标计。比较好的用法是使用 FindNext 和 FindClose。需要注意的是“用户变量(文件输出)”不带有路径。</p><h2 id="FindNext"><a href="#FindNext" class="headerlink" title="FindNext"></a>FindNext</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">句柄 用户变量(文件输出)</span><br></pre></td></tr></tbody></table></figure><p>继续一个由 FindFirst 开始的搜索。句柄应该为 FindFirst 返回的值。如果搜索已完成(没有更多文件)，“用户变量(文件输出)”将被设为空，并且置一个错误位标计。需要注意的是“用户变量(文件输出)”不带有路径。</p><h1 id="卸载程序指令"><a href="#卸载程序指令" class="headerlink" title="卸载程序指令"></a>卸载程序指令</h1><h2 id="WriteUninstaller"><a href="#WriteUninstaller" class="headerlink" title="WriteUninstaller"></a>WriteUninstaller</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[路径\]可执行文件名.exe</span><br></pre></td></tr></tbody></table></figure><p>由指定的文件名(路径为可选项)写入卸载程序。仅在一个安装区段或函数里有效，并且你的脚本里必须有一个卸载区段。也可以参考卸载配置。你可以调用一次或多次来写入一个或多个卸载程序(副本)。</p><h1 id="混合指令"><a href="#混合指令" class="headerlink" title="混合指令"></a>混合指令</h1><h2 id="GetInstDirError"><a href="#GetInstDirError" class="headerlink" title="GetInstDirError"></a>GetInstDirError</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(错误输出)</span><br></pre></td></tr></tbody></table></figure><p>用于目录选择页面的离开函数。读取位标计设置看“DirVerify leave”是否已使用。可能的值:</p><ul><li>0: 无错误</li><li>1: 无效的安装目录</li><li>2: 目标驱动器没有足够的空间</li></ul><h2 id="InitPluginsDir"><a href="#InitPluginsDir" class="headerlink" title="InitPluginsDir"></a>InitPluginsDir</h2><p>初始化插件目录($PLUGINSDIR)，当之前没有初始化时。</p><h2 id="SetShellVarContext"><a href="#SetShellVarContext" class="headerlink" title="SetShellVarContext"></a>SetShellVarContext</h2><p><strong>current</strong>|all</p><p>设置 $SMPROGRAMS 的内容或其他命令解释程序目录。如果设为“current”(默认值)，则使用当前用户的命令解释程序目录。如果设为“all”，则使用所有用户的命令解释程序目录。所有用户目录可能不能被所有的操作系统支持。如果所有用户的目录找不到则使用当前用户代替。请考虑一个普通用户或游客是否有正确的权限在所有用户目录里操作。仅仅管理员才有完全的权限访问所有用户目录。你可以用 UserInfo 来查看用户身份。详细信息请查看 Contrib\UserInfo\UserInfo.nsi 样例。</p><h2 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h2><p>休眠时间单位为毫秒在安装程序里暂停执行“休眠时间单位为毫秒”时间。“休眠时间单位为毫秒”可以是一个变量，例如 “$0”或一个数字，比如 “666”。</p><h1 id="字串操作指令"><a href="#字串操作指令" class="headerlink" title="字串操作指令"></a>字串操作指令</h1><h2 id="StrCpy"><a href="#StrCpy" class="headerlink" title="StrCpy"></a>StrCpy</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(目标) 字串 [最大长度] [起始偏移]</span><br></pre></td></tr></tbody></table></figure><p>把用户变量 $x 设为“字串”。注意“字串”可以包含另一个变量，或该用户变量会被设置(可以用来连接字串等等)。如果指定了“最大长度”则目标字串的长度为“最大长度”(如果“最大长度”是负数，则会从字串尾部截去“最大长度”的绝对值个字符)。如果指定了起始偏移，则字串偏移到该处作为起始(如果“起始偏移”是负数，则会从尾部开始偏移)。</p><h2 id="StrLen"><a href="#StrLen" class="headerlink" title="StrLen"></a>StrLen</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(长度输出) 字串</span><br></pre></td></tr></tbody></table></figure><p>把用户变量 $x 设为“字串”的长度值。</p><h1 id="堆栈支持"><a href="#堆栈支持" class="headerlink" title="堆栈支持"></a>堆栈支持</h1><h2 id="Exch"><a href="#Exch" class="headerlink" title="Exch"></a>Exch</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[用户变量 | 堆栈索引]</span><br></pre></td></tr></tbody></table></figure><p>当不指定参数时，交换堆栈顶部的两个单元。当指定了一个参数并且是一个用户变量时，交换堆栈顶部的单元和该参数。当指定了一个参数并且是正整数时，Exch 将会交换堆栈顶部那项和根据参数从堆栈顶部偏移到指定的那项。如果堆栈里没有足够的项来完成交换时，会产生一个致命的错误(来帮助你调试你的代码)。</p><h2 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(输出)</span><br></pre></td></tr></tbody></table></figure><p>从堆栈里弹出一个字串到用户变量 $x。如果堆栈是空的，则会置一个错误位标计。</p><h2 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字串</span><br></pre></td></tr></tbody></table></figure><p>把一个字串压入堆栈。该字串可随后从堆栈里弹出。</p><h1 id="整数支持"><a href="#整数支持" class="headerlink" title="整数支持"></a>整数支持</h1><h2 id="IntFmt"><a href="#IntFmt" class="headerlink" title="IntFmt"></a>IntFmt</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(输出) 格式 数字字串</span><br></pre></td></tr></tbody></table></figure><p>用“格式”格式格式化“数字字串”中的数字，并把输出设为用户变量 $x。例如格式化字串包含 “%08X” “%u”</p><h2 id="IntOp"><a href="#IntOp" class="headerlink" title="IntOp"></a>IntOp</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(输出) 值1 操作 [值2]</span><br></pre></td></tr></tbody></table></figure><p>联合值 1 和(取决于操作)值 2 到用户变量 $x。操作定义为下列之一:</p><ul><li><code>+</code> 值 1 加 值 2</li><li><code>-</code> 值 1 减 值 2</li><li><code>*</code>值 1 乘 值 2</li><li><code>/</code> 值 1 除 值 2</li><li><code>%</code> 由 值 2 取 值 1 的模</li><li><code>|</code> 值 1 和 值 2 二进制“或”</li><li><code>&amp;</code> 值 1 和 值 2 二进制“与”</li><li><code>^</code> 值 1 和 值 2 二进制“异或”</li><li><code>~</code> 按位取反 值 1(例如 7 变为 4294917288)</li><li><code>!</code> 逻辑取反 值 1(例如 7 变为 0)</li><li><code>||</code> 值 1 和 值 2 逻辑“或”</li><li><code>&amp;&amp;</code> 值 1 和 值 2 逻辑“与”</li></ul><h1 id="重启指令"><a href="#重启指令" class="headerlink" title="重启指令"></a>重启指令</h1><h2 id="Reboot"><a href="#Reboot" class="headerlink" title="Reboot"></a>Reboot</h2><p>重启电脑。请小心使用该指令。如果重启时产生了错误，该函数会置一个错误位标计并继续。如果重启成功，该指令不返回任何值。</p><h2 id="SetRebootFlag"><a href="#SetRebootFlag" class="headerlink" title="SetRebootFlag"></a>SetRebootFlag</h2><p>true|false<br>设置重启位标计为“true”或“false”。</p><h1 id="安装记录指令"><a href="#安装记录指令" class="headerlink" title="安装记录指令"></a>安装记录指令</h1><h2 id="LogSet"><a href="#LogSet" class="headerlink" title="LogSet"></a>LogSet</h2><p>on|<strong>off</strong><br>设置安装记录到 $INSTDIR\install.log 将会发生。</p><p>在你调用该函数之前， $INSTDIR 必须有一个值，否则该指令将无效。需要注意的是在编译的时候编译配置文件(config.h)必须设置 NSIS_CONFIG_LOG (默认未设置)来支持该指令。关于重新编译 NSIS 的详细信息请查看 编译 NSIS 源代码。</p><h2 id="LogText"><a href="#LogText" class="headerlink" title="LogText"></a>LogText</h2><p>文本如果启用了安装程序记录，插入“文本”文本到记录文件。</p><h1 id="区段管理"><a href="#区段管理" class="headerlink" title="区段管理"></a>区段管理</h1><h2 id="SectionSetFlags"><a href="#SectionSetFlags" class="headerlink" title="SectionSetFlags"></a>SectionSetFlags</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">区段索引 区段位标计</span><br></pre></td></tr></tbody></table></figure><p>设置区段位标计。位标计为 32 位整数。第一位(低位)代表该区段当前是否选中，第二位代表该区段是否是一个子区段(请不要修改这里除非你真的很了解)，第三位代表该区段是否是一个子区段的结尾(同样，请不要修改)，第四位代表该区段文字是否描黑显示，第五位代表该区段是否是只读，第六位代表子区段是否自动展开。如果指定了超出范围的区段则会置一个错误的位标计。</p><h2 id="SectionGetFlags"><a href="#SectionGetFlags" class="headerlink" title="SectionGetFlags"></a>SectionGetFlags</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">区段索引 用户变量(输出)</span><br></pre></td></tr></tbody></table></figure><p>找回该区段的位标计。位标计的描述请看上面。如果指定了超出范围的区段则会置一个错误的位标计。</p><h2 id="SectionSetText"><a href="#SectionSetText" class="headerlink" title="SectionSetText"></a>SectionSetText</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">区段索引 区段文本</span><br></pre></td></tr></tbody></table></figure><p>设置“区段索引”区段的描述。要设置一个子区段的文本，你必须在文本前加 -。如果文本设为 “”则该区段将会隐藏。如果指定了超出范围的区段则会置一个错误的位标计。</p><h2 id="SectionGetText"><a href="#SectionGetText" class="headerlink" title="SectionGetText"></a>SectionGetText</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">区段索引 区段文本</span><br></pre></td></tr></tbody></table></figure><p>把“区段索引”区段的描述保存在输出变量。如果区段为隐藏，则保存的变量为空。如果指定了超出范围的区段则会置一个错误的位标计。</p><h2 id="SectionSetInstTypes"><a href="#SectionSetInstTypes" class="headerlink" title="SectionSetInstTypes"></a>SectionSetInstTypes</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">区段索引 安装类型</span><br></pre></td></tr></tbody></table></figure><p>设置“区段索引”区段在安装类型中的默认启用状态。需要注意的是区段索引从零开始。“安装类型”的每一位都是一个告诉该区段是否属于这个安装类型的位标计。例如，如果你有 3 个安装类型并且你希望第一个区段包含在类型 1 和 3，则命令如下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SectionSetInstTypes 0 5</span><br></pre></td></tr></tbody></table></figure><p>因为 5 的二进制值为 “00000101”。</p><p>如果指定了超出范围的区段则会置一个错误的位标计。</p><h2 id="SectionGetInstTypes"><a href="#SectionGetInstTypes" class="headerlink" title="SectionGetInstTypes"></a>SectionGetInstTypes</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">区段索引 用户变量(输出)</span><br></pre></td></tr></tbody></table></figure><p>找回一个区段的安装类型位标计。如果处理输出的描述请看上面的关于 SectionSetInstTypes 的解释。如果指定了超出范围的区段则会置一个错误的位标计。</p><h2 id="SectionSetSize"><a href="#SectionSetSize" class="headerlink" title="SectionSetSize"></a>SectionSetSize</h2><p>区段索引 新容量设置“区段索引”区段的容量。需要注意的是索引从零开始。容量的单位为 KB 且仅支持整数。</p><h2 id="SectionGetSize"><a href="#SectionGetSize" class="headerlink" title="SectionGetSize"></a>SectionGetSize</h2><p>区段索引 用户变量获得“区段索引”区段的容量并把值保存在指定的用户变量里。需要注意的是索引从零开始。</p><h2 id="SetCurInstType"><a href="#SetCurInstType" class="headerlink" title="SetCurInstType"></a>SetCurInstType</h2><p>安装类型索引设置当前安装类型。如果使用了一个超出范围的安装类型则不会置一个错误位标计。</p><p>SetCurInstType 仅在当前存在组件选择页面时才有效。</p><h2 id="GetCurInstType"><a href="#GetCurInstType" class="headerlink" title="GetCurInstType"></a>GetCurInstType</h2><p>用户变量获取当前的安装类型并保存在指定的用户变量里。${NSIS_MAX_INST_TYPES} (默认为 32)的值意味着选择了自定义安装类型。</p><h2 id="InstTypeSetText"><a href="#InstTypeSetText" class="headerlink" title="InstTypeSetText"></a>InstTypeSetText</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装类型索引 文本</span><br></pre></td></tr></tbody></table></figure><p>设置指定的安装类型的文本。如果设置的文本为空则移除该安装类型。通过使用一个以前未使用的“安装类型索引”序号你可以创建一个新的安装类型。要在新的安装类型里添加、删除区段请看 SectionSetInstTypes。与 SectionIn 不同的是该索引从零开始，这意味着第一个安装类型索引为 0。</p><h2 id="InstTypeGetText"><a href="#InstTypeGetText" class="headerlink" title="InstTypeGetText"></a>InstTypeGetText</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装类型索引 用户变量</span><br></pre></td></tr></tbody></table></figure><p>获取指定的安装类型的文本。</p><h1 id="用户界面指令"><a href="#用户界面指令" class="headerlink" title="用户界面指令"></a>用户界面指令</h1><h2 id="BringToFront"><a href="#BringToFront" class="headerlink" title="BringToFront"></a>BringToFront</h2><p>使安装程序窗口可见并把它带到其他窗口的最前端。如果一个应用程序已经执行且显示在安装程序的前面，BringToFront 将把安装程序带回到焦点。</p><h2 id="CreateFont"><a href="#CreateFont" class="headerlink" title="CreateFont"></a>CreateFont</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(句柄输出) 字体名 [高] [宽] [/ITALIC] [/UNDERLINE] [/STRIKE]</span><br></pre></td></tr></tbody></table></figure><p>创建一个字体并把句柄保存在用户变量里。关于不同参数的更多信息请看 MSDN 页面关于 Win32 API 函数 CreateFont()。</p><h2 id="DetailPrint"><a href="#DetailPrint" class="headerlink" title="DetailPrint"></a>DetailPrint</h2><p>用户信息添加“用户信息”字串到安装程序的安装信息查看窗口。</p><h2 id="EnableWindow"><a href="#EnableWindow" class="headerlink" title="EnableWindow"></a>EnableWindow</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">窗口句柄(HWND) (1|0)</span><br></pre></td></tr></tbody></table></figure><p>对指定的窗口或控件允许或禁止鼠标和键盘输入。可用的状态为 0(禁止) 或 1(允许)。</p><h2 id="FindWindow"><a href="#FindWindow" class="headerlink" title="FindWindow"></a>FindWindow</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(窗口句柄输出) 窗口类 [窗口标题] [windowparent] [childafter]</span><br></pre></td></tr></tbody></table></figure><p>查找一个窗口。类似于 Win32 FindWindowEx()。由窗口类来查找(和/或窗口标题，如果指定的话)。如果指定了 windowparent 或 childafter，则查找会受到限制。如果窗口类或窗口标题指定为 “”，则它们将不能用于查找。如果窗口未找到，用户变量将返回 0 值。要实现旧式 FindWindow 行为，请和 SendMessage 一起使用。</p><h2 id="GetDlgItem"><a href="#GetDlgItem" class="headerlink" title="GetDlgItem"></a>GetDlgItem</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(输出) 窗口句柄 控件ID</span><br></pre></td></tr></tbody></table></figure><p>在指定的对话框上根据控件 ID 获得控件句柄。如果你想获得安装程序内部的控件句柄，请先使用 <code>FindWindow 用户变量(窗口句柄输出) "#32770" "" $HWNDPARENT</code> 来获取窗口句柄。</p><h2 id="HideWindow"><a href="#HideWindow" class="headerlink" title="HideWindow"></a>HideWindow</h2><p>隐藏安装程序。</p><h2 id="IsWindow"><a href="#IsWindow" class="headerlink" title="IsWindow"></a>IsWindow</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">窗口句柄 是窗口时跳转 [不是窗口时跳转]</span><br></pre></td></tr></tbody></table></figure><p>如果“窗口句柄”是一个窗口，则跳转到“是窗口时跳转”，否则跳转到“不是窗口时跳转”(如果指定了的话)。</p><h2 id="SendMessage"><a href="#SendMessage" class="headerlink" title="SendMessage"></a>SendMessage</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">窗口句柄 消息 第一个消息参数 第二个消息参数 [用户变量(返回值)] [/TIMEOUT=毫秒]</span><br></pre></td></tr></tbody></table></figure><p>发送消息到“窗口句柄”。如果指定了一个用户变量 $x 作为最后一个参数(或在 /TIMEOUT 之前的最后一个参数)，SendMessage 的返回值将保存在该变量里。需要注意的是当指定“消息”时你只能用消息的整数值。如果你需要发送字串请使用“STR:字串”作为“第一个消息参数”或“第二个消息参数”。</p><ul><li>WM_CLOSE 16</li><li>WM_COMMAND 273</li><li>WM_USER 1024</li></ul><p>Include WinMessages.nsh 来获得所有 Windows 消息定义。</p><p>要发送一个字串参数的话，在参数前面加入 STR: ，例如: “STR:一些字串” 。</p><p>使用 /TIMEOUT=毫秒 来指定持续时间，单位为毫秒。</p><h2 id="SetAutoClose"><a href="#SetAutoClose" class="headerlink" title="SetAutoClose"></a>SetAutoClose</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true|false</span><br></pre></td></tr></tbody></table></figure><p>取代默认的窗口自动关闭位标计(由 AutoCloseWindow 指定，且对于写在程序为 false)。指定“true”将使得安装程序在安装完成时立即关闭窗口，或者“false”来使它需要手动关闭。</p><h2 id="SetBrandingImage"><a href="#SetBrandingImage" class="headerlink" title="SetBrandingImage"></a>SetBrandingImage</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[/IMGID=对话里的 ID 项] [/RESIZETOFIT] 位图.bmp</span><br></pre></td></tr></tbody></table></figure><p>把当前位图作为标志图像显示。如果没有指定 IMGID 则使用第一个找到的图像控件，或由 AddBrandingImage 建立的图像控件。需要注意的是位图必须预先存在于当前用户的机器上。可以先使用 File 指令把它释放。如果指定了 /RESIZETOFIT 则图像会自动改变尺寸到图像控件的大小。如果你使用了 AddBrandingImage 你可以得到它的大小，通过编译你的脚本并察看 AddBrandingImage 的输出，它会告诉你控件的大小。SetBrandingImage 在 .onInit 或 .onInit 调用的函数里无效。</p><h2 id="SetDetailsView"><a href="#SetDetailsView" class="headerlink" title="SetDetailsView"></a>SetDetailsView</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show|hide</span><br></pre></td></tr></tbody></table></figure><p>显示或隐藏详细信息，取决于你使用什么样的参数。它可以覆盖默认的由 ShowInstDetails 设定的详细信息察看属性。</p><h2 id="SetDetailsPrint"><a href="#SetDetailsPrint" class="headerlink" title="SetDetailsPrint"></a>SetDetailsPrint</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">none|listonly|textonly|both|lastused</span><br></pre></td></tr></tbody></table></figure><p>为命令输出的状态信息设置一个显示模式。None 为不输出，listonly 仅在列表框显示，textonly 仅在状态条显示，both 则两者都显示(默认)。对于释放很多小的文件，推荐使用 textonly(特别在 Win9X 下启用了平滑卷动)。</p><h2 id="SetCtlColors"><a href="#SetCtlColors" class="headerlink" title="SetCtlColors"></a>SetCtlColors</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">句柄 [/BRANDING] [文本颜色] [transparent|背景颜色]</span><br></pre></td></tr></tbody></table></figure><p>对一个静态控件、编辑控件、按钮或一个对话框设置一个背景颜色和文本颜色。使用 GetDlgItem 来获取控件的句柄。如果要使得控件透明你可以指定“transparent”作为背景颜色值。你也可以指定 /BRANDING 并带或不带文本颜色和背景颜色来使得控件完全灰白(或其他你选择的颜色)。在 MUI 里用来显示标志牌。</p><h2 id="SetSilent"><a href="#SetSilent" class="headerlink" title="SetSilent"></a>SetSilent</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">silent | normal</span><br></pre></td></tr></tbody></table></figure><p>设置安装程序为静默模式或普通模式。关于静默安装的详细信息请看 SilentInstall。仅能在 .onInit 里使用。</p><h2 id="ShowWindow"><a href="#ShowWindow" class="headerlink" title="ShowWindow"></a>ShowWindow</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">窗口句柄 显示状态</span><br></pre></td></tr></tbody></table></figure><p>设置一个窗口的显示程度。可能的“显示状态”和 Windows ShowWindow 函数相同。<code>SW_*</code> 常量定义于 Include\WinMessages.nsh。</p><h1 id="多语言指令"><a href="#多语言指令" class="headerlink" title="多语言指令"></a>多语言指令</h1><h2 id="LoadLanguageFile"><a href="#LoadLanguageFile" class="headerlink" title="LoadLanguageFile"></a>LoadLanguageFile</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语言文件.nlf</span><br></pre></td></tr></tbody></table></figure><p>给一个语言表的结构载入一个语言文件。所有的语言文件在 Contrib\Language Files</p><p>在你插入一个语言文件后 ${LANG_langfile} 将会被定义为语言 ID(例如: ${LANG_ENGLISH} 将会被定义为 1033)。你可以把它用于 LangString、LicenseLangString、LangDLL 和 VIAddVersionKey。</p><h2 id="LangString"><a href="#LangString" class="headerlink" title="LangString"></a>LangString</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">名称 语言ID 字串</span><br></pre></td></tr></tbody></table></figure><p>定义一个使用多种语言的字串。这意味着它的值将对于每个语言都不同。这允许你方便的使安装程序多语言化，不需要再脚本里使用大量的开关语句。</p><p>每一个语言字串都有一个特定的名字和一个用于安装程序的分配给每一个语言的值。他们可以在脚本里用于任何运行时字串。要使用一个语言字串你所需要做的就是把 <code>$(LangString_名称)</code> 插入到你想插入字串的地方。</p><p>注意:</p><ul><li>不像定义使用花括号 - {} 一样，语言字串使用圆括号 - ()。</li><li>如果你想在 .onInit 函数里更改语言，需要注意的是在 .onInit 里的语言字串将仍旧使用基于用户的默认 Windows 语言检测到的语言，因为语言的初始化在 .onInit 之后。</li><li>总是在你的脚本里为所有语言设置语言字串。</li><li>如果你把语言 ID 设为 0，则使用 LangString 或 LoadLanguageFile 最后使用的语言。</li></ul><p>使用例子:</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LangString</span> message <span class="variable">${LANG_ENGLISH}</span> <span class="string">"英语信息"</span></span><br><span class="line"><span class="keyword">LangString</span> message <span class="variable">${LANG_FRENCH}</span> <span class="string">"法语信息"</span></span><br><span class="line"><span class="keyword">LangString</span> message <span class="variable">${LANG_KOREAN}</span> <span class="string">"韩文信息"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MessageBox</span> <span class="params">MB_OK</span> <span class="string">"A translated message: <span class="variable">$(message)</span>"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="LicenseLangString"><a href="#LicenseLangString" class="headerlink" title="LicenseLangString"></a>LicenseLangString</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">名称 语言ID 许可文件路径</span><br></pre></td></tr></tbody></table></figure><p>用法和 LangString 一样，但它仅从一个文本、RTF 文件载入字串并且定义一个特别的仅能用于 LicenseData 的 LangString。</p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 打包狂魔之NSIS教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSIS教程(2)-完整属性</title>
      <link href="/post/1923360270.html"/>
      <url>/post/1923360270.html</url>
      
        <content type="html"><![CDATA[<p>本文列举了 NSIS 支持的所有属性，以供查阅。</p><span id="more"></span><blockquote><p><strong>描黑加粗部分的为默认值。</strong></p></blockquote><h1 id="一、常规属性"><a href="#一、常规属性" class="headerlink" title="一、常规属性"></a>一、常规属性</h1><h2 id="AddBrandingImage"><a href="#AddBrandingImage" class="headerlink" title="AddBrandingImage"></a>AddBrandingImage</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(left|right|top|bottom) (width|height) [填充]</span><br></pre></td></tr></tbody></table></figure><p>在安装程序顶部、底部、左边、右边添加一个标志图像。它的大小将由指定的宽/高、安装程序的宽/高和安装程序字体确定。最终的大小不一定就是你需要的，请看输出命令来得到实际大小。因为这取决于安装程序字体，所以你应该在 AddBrandingImage 前使用 SetFont。默认的填充值为 2。</p><h2 id="AllowRootDirInstall"><a href="#AllowRootDirInstall" class="headerlink" title="AllowRootDirInstall"></a>AllowRootDirInstall</h2><p>true|<strong>false</strong><br>控制是否允许安装在驱动器根目录，或者共享网络。把它设为“true”可以改变这个安全行为，此安全行为可以防止用户选择 <code>C:\</code> 或 <code>\\Server\Share</code> 来作为安装(或卸载)目录。对于另外的可定制的目录选择页面。</p><h2 id="AutoCloseWindow"><a href="#AutoCloseWindow" class="headerlink" title="AutoCloseWindow"></a>AutoCloseWindow</h2><p>true|<strong>false</strong><br>设置当安装完成的时候窗口是否自动关闭。该属性可以不理会一个使用了 SetAutoClose 的区段。</p><h2 id="BGGradient"><a href="#BGGradient" class="headerlink" title="BGGradient"></a>BGGradient</h2><p>[<strong>off</strong>|(顶部颜色 底部颜色 [文本颜色|notext])]</p><p>指定是否使用一个渐变的背景窗口。如果为“off”，安装程序将不显示背景窗口，如果无指定参数，则使用默认的黑蓝渐变，或者指定顶部颜色或底部颜色来得到一个渐变的背景。顶部颜色和底部颜色使用 RRGGBB 格式(十六进制，就像 HTML 那样，但略去了 #，因为 # 用于注释)。你也可以指定“文本颜色”，该颜色会显示“Name”指定的名称在左上角，或者你不需要文本时使用“notext”来关闭文本显示。</p><h2 id="BrandingText"><a href="#BrandingText" class="headerlink" title="BrandingText"></a>BrandingText</h2><p>/TRIM(LEFT|RIGHT|CENTER) 文本设置显示在安装窗口底部的文本(默认为“Nullsoft Install System vX.XX”)。如果设为空字串(“”)则使用默认值；设为” “(一个空格)则显示空白。如果你不知道哪个适合你，那就保留默认值吧，这样可以使每个人知道你使用的 NSIS 版本。使用 /TRIMLEFT、/TRIMRIGHT 或 /TRIMCENTER 来裁剪控制大小到字串大小。</p><h2 id="Caption"><a href="#Caption" class="headerlink" title="Caption"></a>Caption</h2><p>标题当使用一个外部的 PageEx 区块:设置安装程序标题条文本。默认为“Name 安装”，当使用了 Name 指令指定了名称时。你可以把它替换为“我的安装程序”或其他。如果你指定为空字串(“”)，则使用默认值(你也可以指定为” “来使用一个空白字串)。</p><p>当使用一个内部的 PageEx 区块:设置当前页面的子标题。</p><h2 id="ChangeUI"><a href="#ChangeUI" class="headerlink" title="ChangeUI"></a>ChangeUI</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对话框 ui_file.exe</span><br></pre></td></tr></tbody></table></figure><p>使用 ui_file.exe 里相同资源 ID 的一个对话框替换对话框(IDD_LICENSE、IDD_DIR、IDD_SELCOM、IDD_INST、IDD_INSTFILES、IDD_UNINST 或 IDD_VERIFY)。你也可以指定“all”作为一个对话框，当你想从同一个 UI 文件里一次载入替换全部 7 个对话框时。一些 UI 的例子请看位于 NSIS 目录下的 Contrib\UIs。</p><ul><li>IDD_LICENSE 必须包含 IDC_EDIT1 (RICHEDIT 控件)。</li><li>IDD_DIR 必须包含 IDC_DIR (编辑框)，IDC_BROWSE (按钮) 和 IDC_CHECK1 (选择框)。</li><li>IDD_SELCOM 必须包含 IDC_TREE1 (SysTreeView32 control)，和 IDC_COMBO1 (组合框)。</li><li>IDD_INST 必须包含 IDC_BACK (按钮)，IDC_CHILDRECT (静态控制其他所有对话大小)，IDC_VERSTR (静态文本框)，IDOK (按钮)，和 IDCANCEL (按钮)。如果该对话框有一个图象控件(静态 SS_BITMAP 样式)，那么它将被用于 SetBrandingImage 作为默认值。</li><li>IDD_INSTFILES 必须包含 IDC_LIST1 (SysListView32 控件), IDC_PROGRESS (msctls_progress32 控件)，和 IDC_SHOWDETAILS (按钮)。</li><li>IDD_UNINST 必须包含 IDC_EDIT1 (编辑框)。</li><li>IDD_VERIFY 必须包含 IDC_STR (静态文本框)。</li></ul><h2 id="CheckBitmap"><a href="#CheckBitmap" class="headerlink" title="CheckBitmap"></a>CheckBitmap</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitmap.bmp</span><br></pre></td></tr></tbody></table></figure><p>指定一个位图为用于组件选择页面树形列表选择框的图像。</p><p>该位图应该为 96x16 像素大小，不能多于 8 位位深(256 色)且包括六个用于不同状态(次序为: 鼠标点击反白边缘、未选时、已选时、子区段未选时、未选且只读、已选且只读)的 16x16 图像。使用粉红色为覆盖颜色(该区域实际时为透明)。</p><h2 id="CompletedText"><a href="#CompletedText" class="headerlink" title="CompletedText"></a>CompletedText</h2><p>文本当指定了参数时替换在安装结束时的默认文本(“完成”)。否则，使用默认值。</p><h2 id="ComponentText"><a href="#ComponentText" class="headerlink" title="ComponentText"></a>ComponentText</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[文本 [子文本] [子文本 2]]</span><br></pre></td></tr></tbody></table></figure><p>用来更改组件选择页面的默认文本。</p><p>文本: 控件上的文本，到安装图标的右边。</p><p>子文本: 安装类型选择控件的文本。</p><p>子文本 2: 安装类型选择控件下面、组件列表左边的文本。</p><p>如果字串为空(“”)则使用默认文本。</p><h2 id="CRCCheck"><a href="#CRCCheck" class="headerlink" title="CRCCheck"></a>CRCCheck</h2><p><strong>on</strong>|off|force<br>指定安装前安装程序是否对自身执行一个 CRC。注意，如果用户使用了 /NCRC 命令行参数，且你没有指定“force”参数时，不会执行 CRC，这样有可能导致用户安装一个损坏的安装程序。</p><h2 id="DetailsButtonText"><a href="#DetailsButtonText" class="headerlink" title="DetailsButtonText"></a>DetailsButtonText</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show details text</span><br></pre></td></tr></tbody></table></figure><p>指定参数时替换默认详细信息按钮文本“显示细节”，未指定参数时使用默认值。</p><h2 id="DirText"><a href="#DirText" class="headerlink" title="DirText"></a>DirText</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[文本] [子文本] [浏览按钮文本] [浏览对话框文本]</span><br></pre></td></tr></tbody></table></figure><p>用来更改目录选择页面的默认文本。</p><p>文本: 控件上面的文本，右延至安装图标。</p><p>子文本: 在目录选择框架上的文本。</p><p>浏览按钮文本: 浏览按钮上的文本。</p><p>浏览对话框文本: 在点击“浏览”按钮后“浏览目录”对话框上的文本。</p><p>如果字串为空(“”)则使用默认文本。</p><h2 id="DirVar"><a href="#DirVar" class="headerlink" title="DirVar"></a>DirVar</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户变量(目录输入输出)</span><br></pre></td></tr></tbody></table></figure><p>指定用哪个变量来保存所选的目录。该变量也会保存默认值。这样可以很方便的建立两个不同的目录选择页面而不需要频繁的读取、写入 $INSTDIR。默认的变量为 $INSTDIR。它只能用于 PageEx 来确定目录变量和 uninstConfirm 页面。</p><h2 id="DirVerify"><a href="#DirVerify" class="headerlink" title="DirVerify"></a>DirVerify</h2><p><strong>auto</strong>|leave<br>如果使用了“DirVerify leave”，则当安装目录无效或磁盘空间不够用时下一步按钮将会被禁止并且你可以在离开函数里使用 GetInstDirError 来读取被设置的位标计。</p><h2 id="FileErrorText"><a href="#FileErrorText" class="headerlink" title="FileErrorText"></a>FileErrorText</h2><p>文件错误文本替换当文件不能写入时显示的默认文本。该文本可以包含一个代表文件名的 $0($0 会被临时更改为该值)。例如: “文件 $0$\r$\n不能写入$\r$\n 祝你下次好运。”。</p><h2 id="Icon"><a href="#Icon" class="headerlink" title="Icon"></a>Icon</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[路径\]图标文件.ico</span><br></pre></td></tr></tbody></table></figure><p>设置安装程序的图标。在图标文件里的每一个图标将会被包含在图标文件里。注意如果你在安装程序和卸载程序里使用了不同的图标，那么它们的文件大小和结构必须匹配否则安装程序的构建将会失败。</p><h2 id="InstallButtonText"><a href="#InstallButtonText" class="headerlink" title="InstallButtonText"></a>InstallButtonText</h2><p>安装按钮文本如果指定了参数，则会把默认的“安装”按钮文本替换为你指定的文本。</p><h2 id="InstallColors"><a href="#InstallColors" class="headerlink" title="InstallColors"></a>InstallColors</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/windows | (前景色 背景色)</span><br></pre></td></tr></tbody></table></figure><p>设置安装信息屏幕颜色(默认为 00FF00 000000)。使用 RRGGBB 格式(十六进制，就像 HTML 那样，但略去了 #，因为 # 用于注释)。注意指定了 “/windows” 作为唯一的参数，将使用默认的 Windows 颜色。</p><h2 id="InstallDir"><a href="#InstallDir" class="headerlink" title="InstallDir"></a>InstallDir</h2><p>默认安装目录设定默认的安装目录。查看变量一段得到可用于该字串的变量(尤其是 $PROGRAMFILES)。注意该字串中最后一个 \ 后面的部分会被保留，当用户在安装时选择“浏览”并取得新的目录字串时，该部分会自动附加在后面(要禁止该行为你需要在目录字串后面添加一个额外的 \ ，但是你要使用引号把目录字串括起来以避免被认为是断行处理)。如果没有起作用的话，还是使用浏览按钮吧。</p><h2 id="InstallDirRegKey"><a href="#InstallDirRegKey" class="headerlink" title="InstallDirRegKey"></a>InstallDirRegKey</h2><p>根键 子键 键名该属性让安装程序去检测一注册表里的一个字串，如果该字串可用那么把它用来作为安装目录。如果预置了该属性，当指定的注册表键可用时它会越过 InstallDir 指定的字串，否则使用默认的 InstallDir 指定值。查询注册表时，该命令将自动截去引号(如“”C:\program files\poop” “%1””，可得“C:\program files\poop”)。如果该字串以“.exe”结尾，它还会自动移去字串里的文件名部分(如“C:\program files\poop\poop.exe”，将得到“C:\program files\poop”)。对于更多高级的安装目录配置，可在 .onInit 函数里设定 $INSTDIR。[译者注: 事实上它还可以自动截取如“”C:\program files\poop\poop.exe” “%1””而得到“C:\program files\poop”，这样你只要知道了某个程序关联的文件类型，就可以直接用它获得该程序的安装目录。比如 InstallDirRegKey HKCR “FlashGet.Document\shell\open\command” “” 即可获得网际快车的安装目录]</p><h2 id="InstProgressFlags"><a href="#InstProgressFlags" class="headerlink" title="InstProgressFlags"></a>InstProgressFlags</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[位标计 [...]]</span><br></pre></td></tr></tbody></table></figure><p>有效的位标计值为“smooth”(平滑进度条)或“colored”(把进度条着色为 InstallColors 设定的颜色)。例如: “InstProgressFlags” (默认老式 Windows 外观)，”InstProgressFlags smooth” (新式平滑外观)，”InstProgressFlags smooth colored” (新式平滑外观并着色)。注意: 当安装程序运行在 Windows XP 且使用了新式主题时“smooth”或“colored”都不能与 XPStyle on 共用。</p><h2 id="InstType"><a href="#InstType" class="headerlink" title="InstType"></a>InstType</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装类型名称 | /NOCUSTOM | /CUSTOMSTRING=字串 | /COMPONENTSONLYONCUSTOM</span><br></pre></td></tr></tbody></table></figure><p>把一个安装类型添加到安装类型列表里，或禁止自定义安装类型。最多可以增加到 32 类，每一个类型都需要指定安装类型名称。如果以“un.”作前缀那么它就是一个卸载程序安装类型。你可以使用在运行时可以处理的用户变量而不是难以改变的代码来作为安装类型名称，这样你可以动态的改变安装类型的名称。另一个在运行时更改 InstType 名称的方法是 InstTypeSetText 命令。所不同的是使用 InstTypeSetText 你可以保留你自己宝贵的用户变量。第一个类型为默认类型(通常为“常规”)。每一个类型都是以编号的，从 1 开始。查看 SectionIn 可以知道这些编号怎么使用。如果指定了 /NOCUSTOM 开关，那么“自定义”类型就会被禁止，那么用户就必须选择一个已经定义的安装类型。作为选择，如果指定了 /CUSTOMSTRING 开关，那么该开关的参数将会替代“自定义”安装类型文本。作为选择，如果指定了 /COMPONENTSONLYONCUSTOM 位标计，那么组件列表仅在选择了“自定义”安装类型的时候才显示。</p><h2 id="LicenseBkColor"><a href="#LicenseBkColor" class="headerlink" title="LicenseBkColor"></a>LicenseBkColor</h2><p>颜色 | <strong>/gray</strong> | /windows<br>设置许可协议数据的背景颜色。颜色使用 RRGGBB 格式(十六进制，就像 HTML 那样，但略去了 #，因为 # 用于注释)。默认为“/gray”。你也可以使用“/windows”来使用 Windows 操作系统定义的颜色。</p><h2 id="LicenseData"><a href="#LicenseData" class="headerlink" title="LicenseData"></a>LicenseData</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">许可文件.(txt|rtf)</span><br></pre></td></tr></tbody></table></figure><p>指定一个用户读取许可协议的文本文件或 RTF 文件。如果没有许可协议需要显示那么可以忽略它。注意该文件必须是 DOS 文本格式(\r\n)。要定义多语言许可协议请使用 LicenseLangString。</p><p>如果你使用 RTF 文件来显示许可协议推荐使用写字板来编辑 RTF 文件而不是使用微软的 Word。使用写字板可以得到更小的文件。</p><h2 id="LicenseForceSelection"><a href="#LicenseForceSelection" class="headerlink" title="LicenseForceSelection"></a>LicenseForceSelection</h2><p>(checkbox [接受文本] | radiobuttons [接受文本] [拒绝文本] | <strong>off</strong>)</p><p>指定显示的许可协议是否必须被接受。可以使用单选框或互斥按钮的形式。默认情况下“下一步”按钮是禁止的并且只能在钩选了单选框选择了正确的互斥按钮后才可以进入下一步。如果指定了 off 则默认情况下“下一步：按钮是可用的。</p><h2 id="LicenseText"><a href="#LicenseText" class="headerlink" title="LicenseText"></a>LicenseText</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[文本 [按钮文本]]</span><br></pre></td></tr></tbody></table></figure><p>用来更改许可协议页面的默认文本。</p><p>文本: 控件上方的文本，右延至安装图标。</p><p>按钮文本: “我同意”按钮上的文本。</p><p>如果字串为空(“”)则使用默认文本。</p><h2 id="MiscButtonText"><a href="#MiscButtonText" class="headerlink" title="MiscButtonText"></a>MiscButtonText</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[上一步文本 [下一步文本] [退出按钮文本] [关闭按钮文本]]</span><br></pre></td></tr></tbody></table></figure><p>替换这四个(上一步、下一步、退出、关闭)按钮的默认文本。如果留空参数，将使用默认值代替。</p><h2 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">名称 [双与名称]</span><br></pre></td></tr></tbody></table></figure><p>设置安装程序的名称。名称通常用来显示产品的名称比如“我的程序”或“蓝色网际的程序”。如果在名称里有一个或多个与符号(&amp;)，把第二个参数设为与第一个相同，有 &amp; 的地方使用两个 &amp; 来表示。例如你的产品名称为“foo &amp; bar2000”，那么使用:</p><p>Name “foo &amp; bar2000” “foo &amp;&amp; bar2000”<br>如果你的安装程序名称里有 &amp; 符号并且对名称使用了一个 LangString，那么你还需要创建另一个含有双 &amp; 字符的名称作为第二个参数。</p><h2 id="OutFile"><a href="#OutFile" class="headerlink" title="OutFile"></a>OutFile</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[路径\]安装程序.exe</span><br></pre></td></tr></tbody></table></figure><p>指定 MakeNSIS 要写入安装程序的输出文件。仅仅是 MakeNSIS 要写入的文件，它不会对安装程序的内容有任何影响。</p><h2 id="SetFont"><a href="#SetFont" class="headerlink" title="SetFont"></a>SetFont</h2><p>字体名 字体大小设置安装程序字体大小。请记住你选择的字体在用户的机器上也要有，不要使用只有你自己有的字体。</p><h2 id="ShowInstDetails"><a href="#ShowInstDetails" class="headerlink" title="ShowInstDetails"></a>ShowInstDetails</h2><p><strong>hide</strong>|show|nevershow</p><p>设置是否显示安装详细信息。你可以设为“hide”来默认隐藏详细信息但用户可以查看，或“show”来默认显示详细信息，或“nevershow”来阻止用户查看任何信息。注意区段里可以使用 SetDetailsView 来越过它的设置。</p><h2 id="ShowUninstDetails"><a href="#ShowUninstDetails" class="headerlink" title="ShowUninstDetails"></a>ShowUninstDetails</h2><p><strong>hide</strong>|show|nevershow<br>设置是否显示卸载详细信息。你可以设为“hide”来默认隐藏详细信息但用户可以查看，或“show”来默认显示详细信息，或“nevershow”来阻止用户查看任何信息。注意区段里可以使用 SetDetailsView 来越过它的设置。</p><h2 id="SilentInstall"><a href="#SilentInstall" class="headerlink" title="SilentInstall"></a>SilentInstall</h2><p><strong>normal</strong>|silent|silentlog</p><p>指定安装程序是否静默安装。如果它为“silent”或“silentlog”，所有位标计为 SF_SELECTED 的区段都会被安装而不做提示(你可以使用 SectionSetFlags 来设定区段的位标计)，安装程序本身没有任何屏幕输出(而脚本仍可以显示某些特定的输出，使用 MessageBox 的 /SD 参数来指定静默安装时默认的返回值)。注意如果设置为“normal”且用户运行时使用了 /S (区分大小写)命令行参数时就相当于 SilentInstall 设置为“silent”一样。注意: 也可以看 LogSet。</p><h2 id="SilentUnInstall"><a href="#SilentUnInstall" class="headerlink" title="SilentUnInstall"></a>SilentUnInstall</h2><p><strong>normal</strong>|silent<br>指定卸载程序是否静默安装。如果它为“silent”，卸载区段会被运行而不做提示，卸载程序本身没有任何屏幕输出(而脚本仍可以显示某些特定的输出，使用 MessageBox 的 /SD 参数来指定静默安装时默认的返回值)。注意如果设置为“normal”且用户运行时使用了 /S (区分大小写)命令行参数时就相当于 SilentUnInstall 设置为“silent”一样。注意: 也可以看 LogSet。</p><h2 id="SpaceTexts"><a href="#SpaceTexts" class="headerlink" title="SpaceTexts"></a>SpaceTexts</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[需要空间文本 [可用空间文本]]</span><br></pre></td></tr></tbody></table></figure><p>如果指定了参数，将会取代所需空间和可用空间文本(默认为“所需空间: ”和“可用空间: ”)。如果指定了“none”则不会显示空间提示文本。</p><h2 id="SubCaption"><a href="#SubCaption" class="headerlink" title="SubCaption"></a>SubCaption</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[页面代号 子标题]</span><br></pre></td></tr></tbody></table></figure><p>取代每一个安装程序页面(0=”: 许可协议”,1=”: 安装选项”,2=”: 安装目录”, 3=”: 正在安装”, 4=”: 安装完成”)的子标题。如果指定了空字串(“”)，将使用默认值(你也可以指定 “ “ 来使用一个空白字串)。</p><p>你也可以在一个 PageEx 区块内部使用 Caption 来设置一个子标题(或取代默认值)。</p><h2 id="UninstallButtonText"><a href="#UninstallButtonText" class="headerlink" title="UninstallButtonText"></a>UninstallButtonText</h2><p>文本替换卸载程序上默认为“卸载”的按钮文本。如果无指定参数，将使用默认的文本。也可以看 WriteUninstaller (替换 UninstallEXEName)。</p><h2 id="UninstallCaption"><a href="#UninstallCaption" class="headerlink" title="UninstallCaption"></a>UninstallCaption</h2><p>标题设置卸载程序标题条上显示的文本。默认情况下，它为由 Name 命令指定的“卸载名称”。你可以取代它为“我的应用程序卸载”或其他。如果指定了空字串(“”)，将使用默认值(你也可以指定 “ “ 来使用一个空白字串)。</p><h2 id="UninstallIcon"><a href="#UninstallIcon" class="headerlink" title="UninstallIcon"></a>UninstallIcon</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[路径\]图标.ico</span><br></pre></td></tr></tbody></table></figure><p>设置卸载程序的图标。这个图标文件必须和安装程序的图标结构一致。</p><h2 id="UninstallSubCaption"><a href="#UninstallSubCaption" class="headerlink" title="UninstallSubCaption"></a>UninstallSubCaption</h2><p>页面代号 子标题取代每一个卸载程序页面(0=”: 卸载确认”,1=”: 正在卸载”,2=”: 卸载完成”)的子标题。如果指定了空字串(“”)，将使用默认值(你也可以指定 “ “ 来使用一个空白字串)。</p><p>你也可以在一个 PageEx 区块内部使用 Caption 来设置一个子标题(或取代默认值)。</p><h2 id="UninstallText"><a href="#UninstallText" class="headerlink" title="UninstallText"></a>UninstallText</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文本 [子文本]</span><br></pre></td></tr></tbody></table></figure><p>指定卸载程序确认页面上的文本。</p><p>文本: 控件上方的文本</p><p>子文本: 下面卸载定位的文本</p><h2 id="WindowIcon"><a href="#WindowIcon" class="headerlink" title="WindowIcon"></a>WindowIcon</h2><p><strong>on</strong>|off<br>设置是否显示安装程序的图标。</p><h2 id="XPStyle"><a href="#XPStyle" class="headerlink" title="XPStyle"></a>XPStyle</h2><p>on|<strong>off</strong><br>设置是否把 XP 外观添加到安装程序里。当运行在 Windows XP 时一个 XP 外观使得安装程序控件使用新的 XP 样式。这个设定也会影响卸载程序。</p><h1 id="二、编译器位标计"><a href="#二、编译器位标计" class="headerlink" title="二、编译器位标计"></a>二、编译器位标计</h1><p>下面的命令可以改变编译器如何去创建代码和压缩数据。这些命令在脚本的任何地方都有效，并且影响着该命令下的每一行(直道被另一个命令取代)。</p><h2 id="AllowSkipFiles"><a href="#AllowSkipFiles" class="headerlink" title="AllowSkipFiles"></a>AllowSkipFiles</h2><p><strong>on</strong>|off<br>该命令指定用户是否可以略过文件。如果 SetOverwrite 设为 on(默认)且当安装程序打开一个文件往里边写入东西失败时一个用户可以选择略过文件。如果使用了 off 则不会显示允许用户略过文件的忽略按钮，这样用户只能选择退出安装程序(退出按钮)或重试打开该文件写入(重试按钮)。如果使用了 on 则用户可以选择跳过文件(同时置一个错误位标计 - 看 SetOverwrite)。</p><h2 id="FileBufSize"><a href="#FileBufSize" class="headerlink" title="FileBufSize"></a>FileBufSize</h2><p>缓冲大小以 MB 为单位该命令设置编译器内部文件缓冲大小。该命令允许你通过限制一个所给的文件一次性读入内存的多少来控制编译器的内存的使用。因为编译器需要输入和输出，所以文件缓冲时需要使用两倍指定的内存大小。该命令不会限制需要另一组内存大小的压缩器缓冲，也不会限制编译器另外的内部缓冲，因为这两个缓冲正常情况下无论如何也不能达到 1MB。指定一个很小的数字可能会降低执行效率。指定过大的数字可能会耗尽系统的资源并迫使编译器退出编译处理。该默认值为 32MB。</p><h2 id="SetCompress"><a href="#SetCompress" class="headerlink" title="SetCompress"></a>SetCompress</h2><p><strong>auto</strong>|force|off</p><p>该命令设置由安装程序使用来决定数据是否应该被压缩的压缩位标计。典型的 SetCompress 位标计将影响它后面的命令，并且脚本文件中的最后一个 SetCompress 命令也决定了是否压缩安装信息区段和卸载数据。如果压缩位标计为“auto”，那么仅当压缩后大小小于未压缩时文件才会被压缩。如果压缩位标计为“force”，则始终使用压缩。如果压缩位标计为“off”，则不使用压缩(这样可以加快编译速度)。</p><p>注意该选项当使用了固实压缩方式后无效，固实压缩方式在使用 BZIP2 和 LZMA 时默认启用。</p><h2 id="SetCompressor"><a href="#SetCompressor" class="headerlink" title="SetCompressor"></a>SetCompressor</h2><p><strong>zlib</strong>|bzip2|lzma<br>该命令设置了安装程序压缩文件、数据使用的压缩算法。</p><p>支持三种压缩方式: ZLIB，BZIP2 和 LZMA。</p><p>ZLIB (默认值) 使用收缩算法，是一个快速简单的方法。默认的压缩级别它消耗大约 300 KB 内存。</p><p>BZIP2 通常比 ZLIB 的压缩率好，但是稍微慢了一点并且内存的使用也多一点。默认的压缩级别它消耗大约 4 MB 内存。</p><p>LZMA 是一个压缩率比较理想的新式压缩方式。它的解压速度非常快(在 2 GHz 的 CPU 上能达到 10-20 MB/s 的速度)，但是压缩速度很慢。解压时内存的使用量是字典的大小加上一些 KB，默认值为 8 MB。</p><h2 id="SetCompressorDictSize"><a href="#SetCompressorDictSize" class="headerlink" title="SetCompressorDictSize"></a>SetCompressorDictSize</h2><p>字典大小以 MB 为单位设置使用 LZMA 压缩器时的字典大小(默认为 8 MB)。</p><h2 id="SetDatablockOptimize"><a href="#SetDatablockOptimize" class="headerlink" title="SetDatablockOptimize"></a>SetDatablockOptimize</h2><p><strong>on</strong>|off<br>该命令决定编译器是否优化数据区块。数据区块的优化首先由编译器检查要添加到数据区块的数据是否已经存在了，如果已存在，只需要简单的作为引用来添加(会保留一小部分大小)。非常强烈的推荐保留该选项为 on。</p><h2 id="SetDateSave"><a href="#SetDateSave" class="headerlink" title="SetDateSave"></a>SetDateSave</h2><p><strong>on</strong>|off<br>该命令设置了由 File 命令使用的保存文件日期、时间位标计来决定是否保留最后上次写入文件的日期和时间，它可以在安装时储存下来。有效的位标计为“on”和“off”。“on”为默认。</p><h2 id="SetOverwrite"><a href="#SetOverwrite" class="headerlink" title="SetOverwrite"></a>SetOverwrite</h2><p><strong>on</strong>|off|try|ifnewer|ifdiff|lastused</p><p>该命令设置了由 File 命令使用的覆盖位标计来决定目标文件已存在时是否覆盖。如果覆盖位标计为“on”，则目标文件被覆盖(这个是默认值)。如果覆盖位标计为“off”,则已存在的文件不会被覆盖。如果覆盖位标计为“try”，文件仅当可以被覆盖时(就是说假如文件不能写入，它会自动略过而不需要用户决定)才会覆盖目标文件。如果覆盖位标计为“ifnewer”，则仅当已存在的文件比新文件旧时才会覆盖目标文件。如果覆盖位标计为“ifdiff”，则仅当已存在的文件比新文件旧或新时才会覆盖目标文件。注意在“ifnewer”或“ifdiff”模式下，目标文件的日期都会被设为新文件的日期，而不管 SetDateSave 是怎么设置的。</p><h2 id="SetPluginUnload"><a href="#SetPluginUnload" class="headerlink" title="SetPluginUnload"></a>SetPluginUnload</h2><p><strong>manual</strong>|alwaysoff</p><p>该命令设置了 CallInstDLL 和插件调用(插件名::函数)的不卸载插件位标计。</p><p>该命令设为“alwaysoff”相当于每个 CallInstDLL 和插件调用都使用了 /NOUNLOAD 参数。该命令设为“manual”则仅当你指定了 /NOUNLOAD 参数时才不卸载。</p><h3 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h3><h3 id="VIAddVersionKey"><a href="#VIAddVersionKey" class="headerlink" title="VIAddVersionKey"></a>VIAddVersionKey</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[/LANG=语言 ID] 键名 值</span><br></pre></td></tr></tbody></table></figure><p>在文件属性的版本表格里添加一个字段。既可以是由系统提供的的一个字段也可以是一个用户定义的字段。随后的这些字段由系统提供:</p><ul><li>ProductName</li><li>Comments</li><li>CompanyName</li><li>LegalCopyright</li><li>FileDescription</li><li>FileVersion</li><li>ProductVersion</li><li>InternalName</li><li>LegalTrademarks</li><li>OriginalFilename</li><li>PrivateBuild</li><li>SpecialBuild</li></ul><p>这些字段名称由目标系统翻译，而用户自定义的字段则无翻译。</p><h3 id="VIProductVersion"><a href="#VIProductVersion" class="headerlink" title="VIProductVersion"></a>VIProductVersion</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[版本字串_X.X.X.X]</span><br></pre></td></tr></tbody></table></figure><p>在文件属性版本表格的顶部添加产品版本号。</p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 打包狂魔之NSIS教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSIS教程(1)-基础语法</title>
      <link href="/post/409779091.html"/>
      <url>/post/409779091.html</url>
      
        <content type="html"><![CDATA[<p>NSIS（Nullsoft Scriptable Install System）是一个开源的 Windows 系统下安装包制作程序。NSIS 通过它定义的脚本语言来描述安装包的行为和逻辑的。</p><span id="more"></span><h1 id="一-环境搭建"><a href="#一-环境搭建" class="headerlink" title="一. 环境搭建"></a>一. 环境搭建</h1><p>从<a href="http://nsis.sourceforge.net/Download">http://nsis.sourceforge.net/Download</a>下载 NSIS 安装进行安装。</p><p>使用 NSIS 生成安装包的大致流程如下：</p><ol><li>使用任意文本编辑器（如 notepad++、Visual Studio Code）开发 NSIS 脚本</li><li>使用安装目录内的<code>makensisw.exe</code>编译 NSIS 脚本生成安装包。</li></ol><blockquote><p>makensisw.exe 只提供编译脚本的功能，不能对脚本进行调试。</p></blockquote><h1 id="二-NSIS-脚本结构"><a href="#二-NSIS-脚本结构" class="headerlink" title="二. NSIS 脚本结构"></a>二. NSIS 脚本结构</h1><p>一个 NSIS 脚本可以包括<code>安装程序属性</code>、<code>页面</code>、<code>区段</code>等。<br>对于一个最简单的 NSIS 脚本，只有<code>OutFile</code>属性和一个区段是必须的，<code>OutFile</code>属性指定 NSIS 编译生成安装包的路径）。</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OutFile</span> <span class="string">"Simple.exe"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Section</span> <span class="string">"Installer Section"</span></span><br><span class="line"><span class="keyword">SectionEnd</span></span><br></pre></td></tr></tbody></table></figure><p>保存上面脚本到*.nsi 文件，并使用<code>makensisw.exe</code>打开编译，如下图表示编译成功，成功之后会在脚本当前目录看到输出的<code>Simple.exe</code>；</p><p>如果编译失败，<code>makensisw.exe</code>会在输出窗口提示失败原因。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-jichuyufa-1.png"></p><blockquote><p>需要注意：<br>如果 NSIS 脚本内包含中文等分 ASCII 字符，需要将脚本保存为 ANSI 编码格式，而不能保存为 UTF8 格式。</p></blockquote><h2 id="2-1-安装程序属性"><a href="#2-1-安装程序属性" class="headerlink" title="2.1 安装程序属性"></a>2.1 安装程序属性</h2><p>安装程序的属性用于控制安装程序的外观，包括哪个页面出现在安装程序里，在每个页面的每个部分显示什么文本，安装程序的名称（如上面脚本中的<code>OutFile</code>），使用什么样的图标，默认安装目录等等。</p><p><strong>安装程序属性可以在除了区段和函数以外的任何地方设置。</strong></p><p><strong>可以理解为安装程序属性是设置给 NSIS 编译器看的，这些属性值在编译时都已经确定了</strong>，所以除了 InstallDir 以外，其他安装程序属性都不允许使用变量（除了<code>$\r</code>和<code>$\n</code>）。</p><h2 id="2-2-完整的安装程序属性"><a href="#2-2-完整的安装程序属性" class="headerlink" title="2.2 完整的安装程序属性"></a>2.2 完整的安装程序属性</h2><p>见 <a href="/post/1923360270.html" title="NSIS教程(2)-完整属性">NSIS教程(2)-完整属性</a></p><h2 id="2-2-页面"><a href="#2-2-页面" class="headerlink" title="2.2 页面"></a>2.2 页面</h2><p>页面分为<code>NSIS内置的向导页面</code>和<code>用户自定义页面</code>。</p><p>一个非静默安装程序需要页面来指导用户运行安装程序，可以通过<code>Page</code>命令或<code>PageEx</code>（PageEx 提供了更多高级的设置）命令来设定哪个页面显示。</p><p>页面实际的显示顺序和它在 NSIS 脚本中定义的顺序是一致的。</p><h3 id="2-2-1-内置向导页面："><a href="#2-2-1-内置向导页面：" class="headerlink" title="2.2.1 内置向导页面："></a>2.2.1 内置向导页面：</h3><p>NSIS 内置的向导页面有：</p><ul><li>license：许可证页面。</li><li>components： 组件选择页面，每个可见的区段都可以作为一个组件给用户选择是否安装。你可以只使用一个区段来构建安装包，但是如果你想要使用组件页来让用户选择可选的组件，那你就需要使用多个区段。</li><li>directory： 安装目录选择页面。</li><li>instfiles： 安装过程页面。</li><li>uninstConfirm： 卸载确认页面。</li></ul><p><strong>不同的页面，有不同的属性。</strong></p><p>内置页面语法如下：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Page</span> (<span class="literal">license</span>|<span class="literal">components</span>|<span class="literal">directory</span>|<span class="literal">instfiles</span>|<span class="literal">uninstConfirm</span>) [预置函数] [显示函数] [离开函数]</span><br></pre></td></tr></tbody></table></figure><p>每个内建的页面都有三个回调函数（预置函数、显示创建函数和离开函数），预置函数在页面被创建之前被直接的调用，显示函数在页面被创建后且在显示之前被直接调用，离开函数在用户按下下一页按钮之后并且在页面离开之前被直接调用。</p><p>如：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PageEx</span> <span class="literal">license</span></span><br><span class="line">    <span class="keyword">LicenseData</span> <span class="string">"license.rtf"</span>       <span class="comment">#可以是txt或rtf文件格式</span></span><br><span class="line">PageExEnd</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-2-自定义页面"><a href="#2-2-2-自定义页面" class="headerlink" title="2.2.2 自定义页面"></a>2.2.2 自定义页面</h3><p>创建自定义页面语法：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">page</span> <span class="literal">custom</span> [创建函数] [离开函数] [标题]</span><br></pre></td></tr></tbody></table></figure><p>自定义页面只有两个回调函数（创建函数和离开函数），创建函数在需要创建页面时被调用，离开函数在用户按下”下一页”按钮之后并且在页面离开之前被直接调用。</p><h3 id="2-2-3-页面回调函数"><a href="#2-2-3-页面回调函数" class="headerlink" title="2.2.3 页面回调函数"></a>2.2.3 页面回调函数</h3><p>每个内建的页面都有三个回调函数：一个预置函数、一个显示创建函数和一个离开函数。</p><p>预置函数在页面被创建之前被直接的调用，显示函数在页面被创建后且在显示之前被直接调用，离开函数在用户按下下一页按钮之后并且在页面离开之前被直接调用。</p><ul><li>预置函数允许使用 Abort 来略过该页面。</li><li>显示函数允许使用 CreateFont、SetCtlColors、SendMessage 和其他来调整页面的用户界面。</li><li>离开函数允许使用 Abort 来强制用户停留在当前页面。</li></ul><p>一个自定义的页面仅有两个回调函数，一个是必须的创建页面，另一个离开函数的作用就和内建页面的离开函数一样。</p><p>例如：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Page</span> <span class="literal">license</span> skipLicense <span class="string">""</span> stayInLicense</span><br><span class="line"><span class="keyword">Page</span> <span class="literal">custom</span> customPage <span class="string">""</span> <span class="string">": 自定义页面"</span></span><br><span class="line"><span class="keyword">Page</span> <span class="literal">instfiles</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Function</span> <span class="title function_">skipLicense</span></span><br><span class="line">  <span class="keyword">MessageBox</span> <span class="params">MB_YESNO</span> <span class="string">"你想略过许可页面吗？"</span> <span class="params">IDNO</span> no</span><br><span class="line">    <span class="keyword">Abort</span></span><br><span class="line">  no:</span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Function</span> <span class="title function_">stayInLicense</span></span><br><span class="line">  <span class="keyword">MessageBox</span> <span class="params">MB_YESNO</span> <span class="string">"你想停留在许可页面吗？"</span> <span class="params">IDNO</span> no</span><br><span class="line">    <span class="keyword">Abort</span></span><br><span class="line">  no:</span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Function</span> <span class="title function_">customPage</span></span><br><span class="line">  <span class="keyword">GetTempFileName</span> <span class="variable">$R0</span></span><br><span class="line">  <span class="keyword">File</span> /oname=<span class="variable">$R0</span> customPage.ini</span><br><span class="line">  <span class="title function_">InstallOptions::dialog</span> <span class="variable">$R0</span></span><br><span class="line">  <span class="keyword">Pop</span> <span class="variable">$R1</span></span><br><span class="line">  <span class="keyword">StrCmp</span> <span class="variable">$R1</span> <span class="string">"cancel"</span> done</span><br><span class="line">  <span class="keyword">StrCmp</span> <span class="variable">$R1</span> <span class="string">"back"</span> done</span><br><span class="line">  <span class="keyword">StrCmp</span> <span class="variable">$R1</span> <span class="string">"success"</span> done</span><br><span class="line">  error: <span class="keyword">MessageBox</span> <span class="params">MB_OK</span>|<span class="params">MB_ICONSTOP</span> <span class="string">"InstallOptions error:<span class="char escape_">$\r</span><span class="char escape_">$\n</span><span class="variable">$R1</span>"</span></span><br><span class="line">  done:</span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-区段（Section）"><a href="#2-3-区段（Section）" class="headerlink" title="2.3 区段（Section）"></a>2.3 区段（Section）</h2><p>在安装程序中用户需要安装许多东西，如安装源码、附加插件、脚本样例或其他。里面的每个安装组件都有它自己的代码块，当用户选择了安装该组件，那么安装程序就会执行对应的代码。</p><p>在 NSIS 脚本里，这些代码称为区段。每个可见的区段都可以作为一个组件给用户选择是否安装（区段也可以设置属性对用户隐藏，默认安装，让用户无法选择是否安装）。</p><p>NSIS 脚本对区段的数量没有限制，你可以只使用一个区段来构建安装包，但是如果你想要使用组件页来让用户选择可选的组件，那你就需要使用多个区段了。</p><p>卸载程序也可以有多个区段，但卸载程序区段名前要加上前缀<code>un.</code>，因为卸载程序是要被编译成是一个单独的 exe 的，所以要对编译器指明哪些内容（如区段）需要被编译进卸载程序，因此需要特殊前缀。</p><p>区段名为空、遗漏或者以一个 “-“ 开头，那么它将是一个隐藏的区段，用户也不能在组件选择页面选择是否禁止。</p><h1 id="三-NSIS-语法"><a href="#三-NSIS-语法" class="headerlink" title="三. NSIS 语法"></a>三. NSIS 语法</h1><h2 id="3-1-语法概述"><a href="#3-1-语法概述" class="headerlink" title="3.1 语法概述"></a>3.1 语法概述</h2><ul><li>单行注释用井号<code>#</code>或分号<code>;</code>，跨行注释用可以用 C/C++中注释语法；</li><li>数字常量可以用十进制、十六进制(0x 为前缀)、八进制(0 为前缀)表示，颜色用类似 html 的中 RGB 表示法，但去井号”#”。</li><li>字符串常量可以用引号引用，特殊的字符可以使用美元符号”$”作前缀来转义。美元符号、换行、回车、制表符都是特殊字符，需要转义，他们在NSIS中可以写成： $$, $\n, $r, $\t</li><li>NSIS 脚本用行尾的反斜杠”"表示下一行和当前行逻辑上是同一行。</li></ul><h2 id="3-2-常量和变量"><a href="#3-2-常量和变量" class="headerlink" title="3.2 常量和变量"></a>3.2 常量和变量</h2><p>NSIS 的变量和常量都是<strong>全局的</strong>，且大小写敏感的，NSIS 中变量和常量都是<strong>弱类型</strong>的。</p><p>常用和变量的引用方式都是<code>${VAR_NAME}</code>或<code>$VAR_NAME</code>。</p><p>使用<code>!define</code>方式定义常量，如：<code>!define PRODUCT_NAME "网易云音乐"</code></p><p>使用<code>Var</code>方式定义变量，如：<code>Var a</code></p><p>NSIS 内置了 20 个已注册的变量：<code>$0</code> ~ <code>$9</code> 和 <code>$R0</code> ~ <code>$R9</code>，这些变量不需要声明就可以使用，一般用于参数传递等。</p><p>另外，NSIS 内置一个堆栈，使用<code>push</code>和<code>pop</code>命令来入栈和出栈，可以使用堆栈来暂存数据。</p><p>关于变量的赋值，NSIS 中不能直接使用<code>=</code>来赋值，需要借助<code>StrCpy</code>来实现，如：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">StrCpy</span> <span class="variable">$0</span> <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">StrCpy</span> <span class="variable">$0</span> <span class="number">123</span></span><br></pre></td></tr></tbody></table></figure><h2 id="3-3-函数"><a href="#3-3-函数" class="headerlink" title="3.3 函数"></a>3.3 函数</h2><h3 id="3-3-1-函数定义"><a href="#3-3-1-函数定义" class="headerlink" title="3.3.1 函数定义"></a>3.3.1 函数定义</h3><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Function</span> 函数名</span><br><span class="line"></span><br><span class="line"><span class="keyword">FunctionEnd</span></span><br></pre></td></tr></tbody></table></figure><p>函数名以“.”开头的(例如 “.Whatever”)一般作为回调函数保留。<br>函数名以“un.”开头的函数将会被创建在卸载程序里。因此，普通安装区段和函数不能调用卸载函数，而卸载区段和卸载函数也不能调用普通函数。<br><strong>NSIS 函数声明中不支持参数定义</strong>，如果需要传递参数，可以使用内置的 20 个变量或者堆栈的方式。</p><h3 id="3-3-2-函数调用"><a href="#3-3-2-函数调用" class="headerlink" title="3.3.2 函数调用"></a>3.3.2 函数调用</h3><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Call</span> 函数名</span><br></pre></td></tr></tbody></table></figure><h2 id="3-4-宏"><a href="#3-4-宏" class="headerlink" title="3.4 宏"></a>3.4 宏</h2><p>除了函数之外，NSIS 还支持定义<code>宏</code>，NSIS 中的宏支持定义参数。</p><h3 id="3-4-1-宏定义"><a href="#3-4-1-宏定义" class="headerlink" title="3.4.1 宏定义"></a>3.4.1 宏定义</h3><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">!macro</span> 宏名 [参数<span class="number">1</span>] [参数n]</span><br><span class="line"></span><br><span class="line"><span class="keyword">!macro</span>end</span><br></pre></td></tr></tbody></table></figure><h3 id="3-4-2-宏调用"><a href="#3-4-2-宏调用" class="headerlink" title="3.4.2 宏调用"></a>3.4.2 宏调用</h3><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">!insertmacro</span> 宏名 [参数<span class="number">1</span>] [参数n]</span><br></pre></td></tr></tbody></table></figure><h2 id="3-5-指令"><a href="#3-5-指令" class="headerlink" title="3.5 指令"></a>3.5 指令</h2><p>NSIS 内置了很多指令，这些指令提供了安装包常用了功能，如果这些指令无法满足需求，用户也可以自己开发插件。</p><p>NSIS 支持的指令列表见：<a href="/post/2673115526.html" title="NSIS教程(3)-完整指令">NSIS教程(3)-完整指令</a></p><p>NSIS 指令使用中比较特别的在于<strong>跳转</strong>，比如执行失败跳转到哪里，成功跳转到哪里。<br>以<code>MessageBox</code>指令为例（<code>[]</code>为可选项）：</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MessageBox</span> 消息框选项列表 消息框文本 [/SD 返回] [检测返回值 跳转到] [检测返回值<span class="number">2</span> 跳转到<span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure><p>下面的用法表示如果 MessageBox 返回 IDYES，则+2，即跳转到该指令的下 2 条执行（+1 该指令的下 1 条，+2 就为该指令的下 2 条），<code>/SD IDYES</code>表示安装包采用静默安装方式时默认用户选择了<code>IDYES</code>:</p><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MessageBox</span> <span class="params">MB_ICONQUESTION</span>|<span class="params">MB_YESNO</span> <span class="string">"你确实要完全删除网易云音乐，及其所有组件吗?"</span> /SD <span class="params">IDYES</span> <span class="params">IDYES</span> +<span class="number">2</span> <span class="params">IDNO</span> +<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h1 id="四-NSIS-界面"><a href="#四-NSIS-界面" class="headerlink" title="四. NSIS 界面"></a>四. NSIS 界面</h1><p>NSIS 提供的界面分为传统界面（Classic UI）、现代界面（Modern UI）。</p><h2 id="4-1-传统界面"><a href="#4-1-传统界面" class="headerlink" title="4.1 传统界面"></a>4.1 传统界面</h2><p><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-jichuyufa-2.png"></p><h2 id="4-2-现代界面"><a href="#4-2-现代界面" class="headerlink" title="4.2 现代界面"></a>4.2 现代界面</h2><p><img src="https://blog-static.jiangxueqiao.com/blog/img/nsis-jichuyufa-3.png"></p><h2 id="4-3-自定义界面"><a href="#4-3-自定义界面" class="headerlink" title="4.3 自定义界面"></a>4.3 自定义界面</h2><p>我们可以使用第三方界面库（如 duilib, Qt）自己绘制安装包的界面，这样灵活度更大，可以开发出类似 QQ 那样的安装界面。<br>在此之前需要掌握 NSIS 的插件开发技巧。</p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 打包狂魔之NSIS教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Janus的编译部署及配置</title>
      <link href="/post/3773107387.html"/>
      <url>/post/3773107387.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-static.jiangxueqiao.com/blog/img/janus-logo.png"></p><p><a href="https://janus.conf.meetecho.com/">Janus</a>是一个开源的 WebRTC SFU 服务器，可以作为 WebRTC 的一个端将其收到的数据进行转发，同时提供了一些的控制能力。Janus 是基于插件架构的，其功能都是通过一个个插件来提供，我们可以为 Janus 开发插件，来扩展其功能。</p><span id="more"></span><h1 id="一、编译部署"><a href="#一、编译部署" class="headerlink" title="一、编译部署"></a>一、编译部署</h1><p>Janus 可以方便的在 Linux 和 MacOS 上面编译部署，暂时不支持 Windows 系统，但可以在 Win10 的<code>Windows Subsystem for Linux</code>上编译部署。</p><h2 id="1-1-安装依赖项"><a href="#1-1-安装依赖项" class="headerlink" title="1.1 安装依赖项"></a>1.1 安装依赖项</h2><p>在编译 Janus 之前，需要安装如下依赖项：</p><ul><li><a href="http://www.digip.org/jansson/">Jansson</a></li><li><a href="https://hyperrealm.github.io/libconfig/">libconfig</a></li><li><a href="http://nice.freedesktop.org/wiki/">libnice</a> (at least v0.1.15 suggested, master recommended)</li><li><a href="http://www.openssl.org/">OpenSSL</a> (at least v1.0.1e)</li><li><a href="https://github.com/cisco/libsrtp">libsrtp</a> (at least v1.5 suggested)</li><li><a href="https://github.com/sctplab/usrsctp">usrsctp</a> (only needed if you are interested in Data Channels)</li><li><a href="http://www.gnu.org/software/libmicrohttpd/">libmicrohttpd</a> (only needed if you are interested in REST support for the Janus API)</li><li><a href="https://libwebsockets.org/">libwebsockets</a> (only needed if you are interested in WebSockets support for the Janus API)</li><li><a href="http://www.cmake.org/">cmake</a> (only needed if you are interested in WebSockets and/or BoringSSL support, as they make use of it)</li><li><a href="https://github.com/alanxz/rabbitmq-c">rabbitmq-c</a> (only needed if you are interested in RabbitMQ support for the Janus API or events)</li><li><a href="https://eclipse.org/paho/clients/c">paho.mqtt.c</a> (only needed if you are interested in MQTT support for the Janus API or events)</li><li><a href="https://nanomsg.org/">nanomsg</a> (only needed if you are interested in Nanomsg support for the Janus API)</li><li><a href="https://curl.haxx.se/libcurl/">libcurl</a> (only needed if you are interested in the TURN REST API support)</li></ul><p>Janus 的某些插件可能还依赖下面的库：</p><ul><li><a href="http://sofia-sip.sourceforge.net/">Sofia-SIP</a> (only needed for the SIP plugin)</li><li><a href="http://opus-codec.org/">libopus</a> (only needed for the bridge plugin)</li><li><a href="http://xiph.org/ogg/">libogg</a> (needed for the voicemail plugin and/or post-processor)</li><li><a href="https://curl.haxx.se/libcurl/">libcurl</a> (only needed if you are interested in RTSP support in the Streaming plugin or in the sample Event Handler plugin)</li><li><a href="https://www.lua.org/download.html">Lua</a> (only needed for the Lua plugin)</li></ul><p>另外，还需要安装如下工具：</p><ul><li><a href="http://library.gnome.org/devel/glib/">GLib</a></li><li><a href="http://www.freedesktop.org/wiki/Software/pkg-config/">pkg-config</a></li><li><a href="http://www.gnu.org/software/gengetopt/">gengetopt</a></li></ul><p>上面的所有库通常在多数 Linux 发行版中都有提供，可以直接安装。以在<code>Fedora</code>中安装为例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install libmicrohttpd-devel jansson-devel \</span><br><span class="line">   openssl-devel libsrtp-devel sofia-sip-devel glib2-devel \</span><br><span class="line">   opus-devel libogg-devel libcurl-devel pkgconfig gengetopt \</span><br><span class="line">   libconfig-devel libtool autoconf automake</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是，如果你尝试在<code>CentOS</code>上面安装这些依赖项，需要先执行<code>yum install epel-release</code> .</p><p>在<code>Ubuntu</code>和<code>Debian</code>系统上，执行如下命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aptitude install libmicrohttpd-dev libjansson-dev \</span><br><span class="line">  libssl-dev libsrtp-dev libsofia-sip-ua-dev libglib2.0-dev \</span><br><span class="line">  libopus-dev libogg-dev libcurl4-openssl-dev liblua5.3-dev \</span><br><span class="line">  libconfig-dev pkg-config gengetopt libtool automake</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在低版本的系统上(如低于<code>Ubuntu 14.04 LTS</code>版本)，可能没有提供的<code>libopus</code>的预编译包，如果遇到这种情况，需要手动编译<a href="http://www.opus-codec.org/">opus</a>.</p></blockquote><h3 id="1-1-1-libnice"><a href="#1-1-1-libnice" class="headerlink" title="1.1.1 libnice"></a>1.1.1 libnice</h3><p><code>libnice</code>虽然在大多数系统上都提供了预编译包，但可能会导致一些问题，所以建议先卸载老版本，然后下载 libnice 的<code>master</code>的版本，手动编译：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitlab.freedesktop.org/libnice/libnice</span><br><span class="line">cd libnice</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure --prefix=/usr</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></tbody></table></figure><blockquote><p>确保已经移除老版本，否则会产生冲突。如果需要保留多个版本的 libnice，可以执行<code>pkg-config --cflags --libs nice</code>确保 Janus 可以找到正确的版本，如果无法找到，可以在编译 Janus 之前设置<code>PKG_CONFIG_PATH</code>环境变量，如<code>export PKG_CONFIG_PATH=/path/to/libnice/lib/pkgconfig</code></p></blockquote><h3 id="1-1-2-libcurl"><a href="#1-1-2-libcurl" class="headerlink" title="1.1.2 libcurl"></a>1.1.2 libcurl</h3><p>如果后期需要编译安装 Janus 的<code>Event Handler</code>插件，还需要安装 libcurl 库的开发版本，在 Fedora/CentOS 上通常为<code>libcurl-devel</code>，在 Ubuntu/Debian 上通常为<code>libcurl4-openssl-dev</code>。</p><h3 id="1-1-3-libsrtp"><a href="#1-1-3-libsrtp" class="headerlink" title="1.1.3 libsrtp"></a>1.1.3 libsrtp</h3><p>假如已经安装了<code>libsrtp</code> 1.5 之前的版本，需要先卸载，然后手动安装<a href="https://github.com/cisco/libsrtp/releases]">1.5x 或 1.6x</a>版本。因为 1.4x 版本会导致 WebRTC 出现一些问题。<br>以安装<code>2.2.0</code>版本为例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/cisco/libsrtp/archive/v2.2.0.tar.gz</span><br><span class="line">tar xfv v2.2.0.tar.gz</span><br><span class="line">cd libsrtp-2.2.0</span><br><span class="line">./configure --prefix=/usr --enable-openssl</span><br><span class="line">make shared_library &amp;&amp; sudo make install</span><br></pre></td></tr></tbody></table></figure><p>Janus 的 configure 脚本可以自动检测到使用的 libsrtp 的版本，如果同时安装了 1.5x 和 2.x 版本，会优先使用 2.x 版本，如果想强制使用 1.5 或者 1.6 版本，可以在 configure 命令传入<code>--disable-libsrtp2</code> 参数。</p><blockquote><p>假如安装的是 x86/x64 版本的 libsrtp，需要在 configure 命令传入<code>--libdir=/usr/lib64</code>参数。</p></blockquote><h3 id="1-1-4-BoringSSL"><a href="#1-1-4-BoringSSL" class="headerlink" title="1.1.4 BoringSSL"></a>1.1.4 BoringSSL</h3><p>如果需要使用<code>BoringSSL</code>代替<code>OpenSSL </code>（因为使用<code>BoringSSL</code>可以使用<code>--enable-dtls-settimeout</code>功能），可以通过如下命令手动安装，并且在 configure 命令传入<code>--enable-boringssl</code>参数：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git clone https://boringssl.googlesource.com/boringssl</span><br><span class="line">cd boringssl</span><br><span class="line"># Don't barf on errors</span><br><span class="line">sed -i s/" -Werror"//g CMakeLists.txt</span><br><span class="line"># Build</span><br><span class="line">mkdir -p build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCMAKE_CXX_FLAGS="-lrt" ..</span><br><span class="line">make</span><br><span class="line">cd ..</span><br><span class="line"># Install</span><br><span class="line">sudo mkdir -p /opt/boringssl</span><br><span class="line">sudo cp -R include /opt/boringssl/</span><br><span class="line">sudo mkdir -p /opt/boringssl/lib</span><br><span class="line">sudo cp build/ssl/libssl.a /opt/boringssl/lib/</span><br><span class="line">sudo cp build/crypto/libcrypto.a /opt/boringssl/lib/</span><br></pre></td></tr></tbody></table></figure><p>Janus 默认 BoringSSL 安装在<code>/opt/boringssl</code>，如果不是，可以通过<code>--enable-boringssl=/path/to/boringssl</code>指定。</p><h3 id="1-1-5-usrcstp"><a href="#1-1-5-usrcstp" class="headerlink" title="1.1.5 usrcstp"></a>1.1.5 usrcstp</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/sctplab/c</span><br><span class="line">cd usrsctp</span><br><span class="line">./bootstrap</span><br><span class="line">./configure --prefix=/usr &amp;&amp; make &amp;&amp; sudo make install</span><br></pre></td></tr></tbody></table></figure><ul><li><em>Note:</em> 假如安装的是 x8/x64 版本的 usrcstp，需要在 configure 命令传入 <code>--libdir=/usr/lib64</code> 参数。</li></ul><h3 id="1-1-6"><a href="#1-1-6" class="headerlink" title="1.1.6"></a>1.1.6</h3><p>如果需要提供 websockets 信令支持，还需要安装 libwebsockets 库：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https://libwebsockets.org/repo/libwebsockets</span><br><span class="line">cd libwebsockets</span><br><span class="line"># If you want the stable version of libwebsockets, uncomment the next line</span><br><span class="line"># git checkout v2.4-stable</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line"># See https://github.com/meetecho/janus-gateway/issues/732 re: LWS_MAX_SMP</span><br><span class="line">cmake -DLWS_MAX_SMP=1 -DCMAKE_INSTALL_PREFIX:PATH=/usr -DCMAKE_C_FLAGS="-fpic" ..</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></tbody></table></figure><ul><li>假如 libwebsockets.org 无法访问, 可以将第一行替换为:<br>git clone <a href="https://github.com/warmcat/libwebsockets.git">https://github.com/warmcat/libwebsockets.git</a></li></ul><h3 id="1-1-7-文档"><a href="#1-1-7-文档" class="headerlink" title="1.1.7 文档"></a>1.1.7 文档</h3><p>如果需要编译 Janus 文档，需要安装如下工具：</p><ul><li><a href="http://www.doxygen.org/">Doxygen</a></li><li><a href="http://www.graphviz.org/">Graphviz</a></li></ul><p>Fedora:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install doxygen graphviz</span><br></pre></td></tr></tbody></table></figure><p>Ubuntu/Debian:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aptitude install doxygen graphviz</span><br></pre></td></tr></tbody></table></figure><h1 id="二、编译"><a href="#二、编译" class="headerlink" title="二、编译"></a>二、编译</h1><p>在安装完依赖项之后，使用下面命令获取 Janus 代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- [ ] git clone https://github.com/meetecho/janus-gateway.git cd</span><br><span class="line">      janus-gateway</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>然后使用<code>sh autogen.sh</code>命令生成 configure 文件。<br>最后，执行 configure 和编译命令开始编译：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/opt/janus --enable-boringssl</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></tbody></table></figure><p>编译完成之后，使用<code>make configs</code>命令生成默认配置文件，配置文件位于<code>/opt/janus/etc/janus/janus.jcfg</code>。需要注意的是，每次执行<code>make configs</code>命令都会将<code>/opt/janus/etc/janus/janus.jcfg</code>文件还原为默认配置。</p><h1 id="三、运行、测试"><a href="#三、运行、测试" class="headerlink" title="三、运行、测试"></a>三、运行、测试</h1><p>我们可以先不修改任何配置，将 Janus 运行起来，然后使用测试 html，测试一下效果。<br>执行如下命令，运行 Janus：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/janus/bin/janus</span><br></pre></td></tr></tbody></table></figure><p>Janus 启动完成之后，我们另寻一台客户机，将 Janus 源码下载下来，修改<code>janus-gateway\html\echotest.js</code>文件中<code>server</code>变量为：<code>"ws://47.93.47.150:8188"</code>，如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var server = null;</span><br><span class="line">if(window.location.protocol === 'http:')</span><br><span class="line">  server = "http://" + window.location.hostname + ":8088/janus";</span><br><span class="line">else</span><br><span class="line">  server = "https://" + window.location.hostname + ":8089/janus";</span><br><span class="line"></span><br><span class="line">server = "ws://47.93.47.150:8188";</span><br></pre></td></tr></tbody></table></figure><p>在浏览器中打开<code>echotest.html</code>，点击“Start”即可看到效果。</p><p>如果无法连接成功，可能是因为<code>iceServers</code>默认使用的是 google 的 turn 服务器，国内无法访问导致，可以参考 <a href="/post/2256138363.html" title="如何搭建WebRTC的TURN服务器">如何搭建WebRTC的TURN服务器</a> 搭建自己的 TURN 服务器。</p>]]></content>
      
      
      <categories>
          
          <category> ⑤ 音视频编程 </category>
          
          <category> WebRTC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebRTC添加选择音频输入输出设备功能</title>
      <link href="/post/2143630083.html"/>
      <url>/post/2143630083.html</url>
      
        <content type="html"><![CDATA[<p>我们先来看看 WebRTC 中提供音频设备输入输出功能的类结构：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/webrtc-ypsrscxz-1.png"></p><span id="more"></span><p>从上图中我们看到：</p><ul><li><p><code>AudioDeviceModule</code>接口类是音频设备模型的基类，该接口类及其子类并不提供任何针对音频的实际操作，实际操作都是由<code>AudioDeviceGeneric</code>接口类的子类来提供。</p></li><li><p><code>AudioDeviceGeneric</code>接口类是音频设备实际操作（如录音、播放、声音控制等）的基类，然后根据平台不同由不同的类来实现具体操作，如 windows 平台由<code>AudioDeviceWindowsCore</code>来负责实现。</p></li></ul><p>通过代码追踪，我们可以发现 WebRTC 默认使用的是计算机上的系统默认音频输入输出设备，以及默认的视频采集设备，这些我们通过<code>adm_helpers.cc::Init</code>函数来验证（笔者这里使用的是<code>m77</code>分支）：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (adm-&gt;<span class="built_in">SetPlayoutDevice</span>(AUDIO_DEVICE_ID) != <span class="number">0</span>) {</span><br><span class="line">  <span class="built_in">RTC_LOG</span>(LS_ERROR) &lt;&lt; <span class="string">"Unable to set playout device."</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (adm-&gt;<span class="built_in">SetRecordingDevice</span>(AUDIO_DEVICE_ID) != <span class="number">0</span>) {</span><br><span class="line">  <span class="built_in">RTC_LOG</span>(LS_ERROR) &lt;&lt; <span class="string">"Unable to set recording device."</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以即便我们调用了<code>SetPlayoutDevice</code>和<code>SetRecordingDevice</code>也无济于事，因为在此处仍然会被覆盖为使用默认设备。<br>因此我们只需要针对此处进行修改即可，如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> playout_index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 先获取设备index，如果能够获取到，表示外部已经设备设备index，放弃使用默认设备</span></span><br><span class="line"><span class="comment">// AudioDeviceModule没有提供Get接口，需要自己添加</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (adm-&gt;<span class="built_in">GetPlayoutDevice</span>(&amp;playout_index) == <span class="number">0</span>) {</span><br><span class="line">  <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">"Playout device index: "</span> &lt;&lt; playout_index;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="keyword">if</span> (adm-&gt;<span class="built_in">SetPlayoutDevice</span>(AUDIO_DEVICE_ID) != <span class="number">0</span>) {</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_ERROR) &lt;&lt; <span class="string">"Unable to set playout device."</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> recording_index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (adm-&gt;<span class="built_in">GetRecordingDevice</span>(&amp;recording_index) == <span class="number">0</span>) {</span><br><span class="line">  <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">"Recording device index: "</span> &lt;&lt; recording_index;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="keyword">if</span> (adm-&gt;<span class="built_in">SetRecordingDevice</span>(AUDIO_DEVICE_ID) != <span class="number">0</span>) {</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_ERROR) &lt;&lt; <span class="string">"Unable to set recording device."</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>细心的读者可能发现，<code>AudioDeviceModule</code>接口类只定义了 Playout/Recoding 设备的<code>Set</code>接口，但没有提供<code>Get</code>接口，因为 WebRTC 默认使用的是系统设备，所以外界不需要知道具体设备 index，故没有提供（笔者使用的是 webrtc <code>m77</code>分支，也许 webrtc 的后续版本会加入该接口）。我们自己也可以很容易的在 AudioDeviceModule 中加入<code>Get</code>接口。</p><p>上面的一切修改完毕之后，我们只需要定义一个 adm，作为参数传入到<code>webrtc::CreatePeerConnectionFactory</code>函数即可：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">m_adm = webrtc::AudioDeviceModule::<span class="built_in">Create</span>(</span><br><span class="line">            webrtc::AudioDeviceModule::kPlatformDefaultAudio, webrtc::<span class="built_in">CreateDefaultTaskQueueFactory</span>().<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> ret = m_adm-&gt;<span class="built_in">Init</span>();</span><br><span class="line"><span class="built_in">Q_ASSERT</span>(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_connParameter.audioInputDeviceIndex == <span class="number">-1</span>) {</span><br><span class="line">    m_adm-&gt;<span class="built_in">SetEnableRecording</span>(<span class="literal">false</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    ret = m_adm-&gt;<span class="built_in">SetRecordingDevice</span>(m_connParameter.audioInputDeviceIndex);</span><br><span class="line">    <span class="built_in">Q_ASSERT</span>(ret == <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_connParameter.audioOutputDeviceIndex == <span class="number">-1</span>) {</span><br><span class="line">    m_adm-&gt;<span class="built_in">SetEnablePlayout</span>(<span class="literal">false</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    ret = m_adm-&gt;<span class="built_in">SetPlayoutDevice</span>(m_connParameter.audioOutputDeviceIndex);</span><br><span class="line">    <span class="built_in">Q_ASSERT</span>(ret == <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑤ 音视频编程 </category>
          
          <category> WebRTC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebRTC在直播领域应用的可行性分析</title>
      <link href="/post/2016855525.html"/>
      <url>/post/2016855525.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、目前流行的直播技术架构"><a href="#一、目前流行的直播技术架构" class="headerlink" title="一、目前流行的直播技术架构"></a>一、目前流行的直播技术架构</h1><p>目前主流的直播方案一般采用<code>RTMP</code>架构，首先客户端采集音视频流（如<code>obs studio</code>客户端），然后通过 RTMP 协议将流推到流媒体服务器，最后流媒体服务器将流处理后分发给各个直播客户端。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/webrtc-zbkxxfx-1.png"></p><span id="more"></span><ul><li><p><strong>优点：</strong><br>良好的 CDN 支持，目前主流的 CDN 厂商都有比较成熟的解决方案，另外也有可用的商用 SDK 方便集成，例如声网等，只要集成对应平台的 SDK 即可。由于有 CDN 的支持，相较于端对端的 webrtc 方式，其并发度高，适合多人直播场景。</p></li><li><p><strong>缺点：</strong></p></li><li><p>由于 RTMP 协议基于是 TCP 的，相对于基于 UDP 协议的 WebRTC 方式延时较大，所以对于某些低延时场景体验较差，这也是为什么现在直播应用中只能通过弹幕的方式与主播互动，不能实时连麦互动了，因为延迟太大，体验太差。</p></li><li><p>浏览器没有集成对 RTMP 协议的支持，所以不支持浏览器推流等，需要主播端安装特定的客户端软件。</p></li></ul><h1 id="二、基于端对端的-WebRTC-直播方案"><a href="#二、基于端对端的-WebRTC-直播方案" class="headerlink" title="二、基于端对端的 WebRTC 直播方案"></a>二、基于端对端的 WebRTC 直播方案</h1><p>严格的讲，基于<code>端对端</code>的 WebRTC 直播方式不属于 WebRTC 常规应用场景，WebRTC 设计之初是用来进行多人实时通信的，所以 WebRTC 代码中集成了很多语音方面的算法，如人声检测等。若将 WebRTC 应用在直播方案中，则主要工作流程如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/webrtc-zbkxxfx-2.png"></p><ul><li><strong>优点：</strong></li></ul><ol><li><p>单纯使用 Javascript 在 Web 端即可实现推流，这对于开发者来说，简化了音视频通信的开发工作，降低了门槛低，不必熟悉流媒体等技术细节；对于主播来说，在浏览器中打开网页即可进行直播，方便快捷。</p></li><li><p>如果点对点连接成功就可以不通过服务器中转，可以节省服务器带宽费用。</p></li><li><p>相对于基于 TCP 的 RTMP 推拉流方式，基于 UDP 的 webrtc 方式延时更低。</p></li></ol><ul><li><strong>缺点：</strong></li><li>PC 端浏览器的性能有局限，如果是 1v1 方式的直播连麦，浏览器尚能支撑；如果同时进行多人直播连麦，则浏览器需要同时给多人推流，这对于浏览器来说恐难支撑。</li><li>虽然目前浏览器提供的 WebRTC Javascript API 越来越多，但一旦现有 API 无法满足需求，则单纯的依靠 JavaScript 恐难为力（可以修改 WebRTC C++源码，另外开发浏览器客户端提供 Javascript 接口，但这就失去了主流浏览器支持 WebRTC 的天然优势）。</li><li>音视频的传输质量难以保障，尤其在跨地区、跨运营商的情况下，即便可以端对端连接成功，但质量也难保障。</li><li>由于端对端连接没有经过服务器，所以无法在服务器端对直播流进行审录制回放等。</li></ul><h1 id="三、基于服务器转发的-WebRTC-直播方案"><a href="#三、基于服务器转发的-WebRTC-直播方案" class="headerlink" title="三、基于服务器转发的 WebRTC 直播方案"></a>三、基于服务器转发的 WebRTC 直播方案</h1><p>基于端对端的 WebRTC 直播方式受限于浏览器性能、连接人数等限制，很难适用于直播场景。为了解决这些问题，从而引入媒体服务器，主播客户端仅传输一路音视频流到媒体服务器，其余客户端通过与媒体服务器建立连接获取音视频流。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/webrtc-zbkxxfx-3.png"></p><p>目前适用于 WebRTC 的媒体服务器有 SFU 和 MUC 两种类型，两种的差别可以参考：</p><a href="/post/2114040426.html" title="WebRTC的三种架构">WebRTC的三种架构</a><p>虽然两种类型的 WebRTC 服务器架构都有开源的解决方案，也存在一些商用的解决方案，但终究没有基于<code>RTMP+CDN</code>方式的直播方案成熟，这也就意味着一旦采用此方案需要投入更大的研发力度。</p><p>基于服务器转发的 WebRTC 直播方案虽然看起来和当前流行的<code>RTMP+CDN</code>方式类似，都经过了服务器的转发，但 WebRTC 基于 UDP 方式延迟可以做到更低，且 WebRTC 内置了很多音视频方面的算法，如 AEC, VAD, VP9 等，并且在网络传输方面做了很多优化工作。</p>]]></content>
      
      
      <categories>
          
          <category> ⑤ 音视频编程 </category>
          
          <category> WebRTC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建WebRTC的TURN服务器</title>
      <link href="/post/2256138363.html"/>
      <url>/post/2256138363.html</url>
      
        <content type="html"><![CDATA[<p>本文讲解如何在 Ubuntu 系统上采用<a href="https://github.com/coturn/coturn">coturn</a>搭建 p2p 打洞服务器，coturn 是一个开源的 stun 和 turn 服务器实现。</p><span id="more"></span><h2 id="1-安装依赖项"><a href="#1-安装依赖项" class="headerlink" title="1. 安装依赖项"></a>1. 安装依赖项</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssl</span><br><span class="line">sudo apt-get install libssl</span><br><span class="line">sudo apt-get install libevent-dev</span><br></pre></td></tr></tbody></table></figure><h2 id="2-下载-coturn-源码编译安装"><a href="#2-下载-coturn-源码编译安装" class="headerlink" title="2. 下载 coturn 源码编译安装"></a>2. 下载 coturn 源码编译安装</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/coturn/coturn.git</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></tbody></table></figure><h2 id="3-编辑配置"><a href="#3-编辑配置" class="headerlink" title="3. 编辑配置"></a>3. 编辑配置</h2><p>安装完之后，编辑<code>\usr\local\etc\turnserver.conf</code>配置文件：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listening-device=eth0</span><br><span class="line">listening-port=3478</span><br><span class="line">external-ip=47.93.42.10     #公网IP</span><br><span class="line">user=jeff:123456                #用户名密码</span><br><span class="line">realm=rtctest</span><br></pre></td></tr></tbody></table></figure><h2 id="4-启动-coturn"><a href="#4-启动-coturn" class="headerlink" title="4. 启动 coturn"></a>4. 启动 coturn</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">turnserver -a -f -v -r rtctest</span><br></pre></td></tr></tbody></table></figure><h2 id="5-客户端连接-coturn-服务器"><a href="#5-客户端连接-coturn-服务器" class="headerlink" title="5. 客户端连接 coturn 服务器"></a>5. 客户端连接 coturn 服务器</h2><p><code>webrtc::PeerConnectionFactoryInterface::CreatePeerConnection</code>函数传入的<code>RTCConfiguration </code>参数如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">webrtc::PeerConnectionInterface::RTCConfiguration config;</span><br><span class="line">config.sdp_semantics = webrtc::SdpSemantics::kUnifiedPlan;</span><br><span class="line">config.enable_dtls_srtp = <span class="literal">true</span>;</span><br><span class="line">webrtc::PeerConnectionInterface::IceServer server;</span><br><span class="line">server.urls.<span class="built_in">push_back</span>(<span class="string">"stun://47.93.42.10:3478"</span>);</span><br><span class="line">server.urls.<span class="built_in">push_back</span>(<span class="string">"turn://47.93.42.10:3478"</span>);</span><br><span class="line">server.username = <span class="string">"jeff"</span>;</span><br><span class="line">server.password = <span class="string">"123456"</span>;</span><br><span class="line">config.servers.<span class="built_in">push_back</span>(server);</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑤ 音视频编程 </category>
          
          <category> WebRTC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebRTC的三种架构</title>
      <link href="/post/2114040426.html"/>
      <url>/post/2114040426.html</url>
      
        <content type="html"><![CDATA[<p>WebRTC 是基于 P2P 的实时通信技术，（如果 P2P 打洞失败，则会使用 TURN 服务器进行数据转发），在有 2 台客户端参与的情况下，网络拓扑结构如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/webrtc-jiagou-1.png"></p><span id="more"></span><h1 id="一、Mesh-架构"><a href="#一、Mesh-架构" class="headerlink" title="一、Mesh 架构"></a>一、Mesh 架构</h1><p>在只有 2 个客户端参与情况下，我们可以使用上图的这种拓扑结构。但假如同时有 3 个客户端参与（如多人视频会议），如果还是按照上面的方式，拓扑结构就会变成：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/webrtc-jiagou-2.png"></p><p>从上图中我们可以看到，在 3 人参与的实时通信中，每个客户端要维持 4 个连接（2 个上行，2 个下行）；同理，如果有 N 个客户端参与，每个客户端就要维持<code>N-1</code>上行，<code>N-1</code>个下行，这样会极大的占用客户端的上行带宽和下行带宽；</p><p>这种每个端之前完全使用 P2P 方式架构称之为 Mesh 架构。</p><h1 id="二、SFU-Selective-Forwarding-Unit-架构"><a href="#二、SFU-Selective-Forwarding-Unit-架构" class="headerlink" title="二、SFU (Selective Forwarding Unit)架构"></a>二、SFU (Selective Forwarding Unit)架构</h1><p><img src="https://blog-static.jiangxueqiao.com/blog/img/webrtc-jiagou-3.png"><br>SFU 架构最核心的特点是把自己 “伪装” 成了一个 WebRTC 的客户端，WebRTC 的其他客户端其实并不知道自己通过 P2P 连接过去的是一台真实的客户端还是一台服务器，我们通常把这种连接称之为 P2S，即：Peer to Server。除了 “伪装” 成一个 WebRTC 的客户端外，SFU 服务器还有一个最重要的能力就是具备<code>one-to-many</code>的能力，即可以将一个客户端的数据转发到其他多个客户端。</p><p>这种网络拓扑结构中，无论多少人同时进行视频通话，每个 WebRTC 的客户端只需要连接一个 SFU 服务器，上行一路数据即可，可以极大的减少多人视频通话场景下 Mesh 模型给客户端带来的上行带宽压力。</p><p>SFU 服务器跟 TURN 服务器最大的不同是，TURN 服务器仅仅是为 WebRTC 客户端提供的一种辅助的数据转发通道，在 P2P 不通的时候进行透明的数据转发。而 SFU 是 “懂业务” 的， 它跟 WebRTC 客户端是平等的关系，甚至 “接管了” WebRTC 客户端的数据转发的申请和控制。</p><h1 id="三、MCU-MultiPoint-Control-Unit-架构"><a href="#三、MCU-MultiPoint-Control-Unit-架构" class="headerlink" title="三、MCU (MultiPoint Control Unit)架构"></a>三、MCU (MultiPoint Control Unit)架构</h1><p>从上述 SFU 的定义可以看到，SFU 这种网络拓扑模型，通过由 SFU Server 来实现 one-to-many ，减轻了多人视频通话场景下每个客户端的上行带宽压力，但是下行依然是多路流，随着通话人数的增大，下行带宽的压力依然会成比例的增大，那能否让下行也只剩一路流呢？—— 可以，通过在服务器端合流后再下发即可解决，如下图所示：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/webrtc-jiagou-4.png"></p><p>目前，随着 5G 技术的推广，可以预见带宽越来越不是问题，所以 SFU 在未来，可能会更有优势。常见的开源 SFU 服务器有：<code>Licode</code>，<code>Janus</code>，<code>Jitsi</code>，<code>mediasoup</code>，<code>Medooze</code> 等等。</p><blockquote><p>文章参考：<br><a href="https://zhuanlan.zhihu.com/p/56428846">WebRTC 开发实践：为什么你需要 SFU 服务器</a> &gt; <a href="https://www.cnblogs.com/yjmyzz/p/webrtc-multiparty-call-architecture.html">webrtc 笔记(3): 多人视频通讯常用架构 Mesh/MCU/SFU</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ⑤ 音视频编程 </category>
          
          <category> WebRTC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>客户端软件日志输出规范</title>
      <link href="/post/449620601.html"/>
      <url>/post/449620601.html</url>
      
        <content type="html"><![CDATA[<p>众所周知，软件日志对问题的排查可以起到至关重要的作用，但在多人协同开发的情况下，可能会导致不同的人使用不同的日志打印风格，导致日志可阅读性不高。纵观各大知名软件的输出日志，无不有着规范的格式，非常利于阅读。</p><p><strong>本日志输出规范仅适用于客户端软件，不适用于服务器端软件。</strong></p><ol><li><p>日志中使用英文。</p></li><li><p>日志文件采用UTF-8编码。</p></li><li><p>每条日志的第一个单词的首字母大写，而且每条日志以回车换行符(<code>\r\n</code>)结束，不需要写句号<code>.</code>，如：</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RTC_LOG会自动在日志结尾添加\r\n</span></span><br><span class="line"><span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">"Forced software decoder fallback enabled"</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>不同语义间使用逗号<code>,</code>分隔，key-value间使用冒号<code>:</code>分隔，如：</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">"DataChannel received DATA message, sid: "</span> &lt;&lt; sid;</span><br><span class="line"><span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">"Session: "</span> &lt;&lt; <span class="built_in">session_id</span>() &lt;&lt; <span class="string">" is destroyed"</span>;</span><br><span class="line"><span class="built_in">RTC_LOG</span>(LS_ERROR) &lt;&lt; <span class="string">"Invalid configuration: "</span> &lt;&lt; config_error.<span class="built_in">message</span>();</span><br></pre></td></tr></tbody></table></figure></li><li><p>每条日志需要包含日志打印的时间（日期+时间+时区，精确到毫秒）、日志级别。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> ⑧ 软件架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>流媒体基础概念</title>
      <link href="/post/737279469.html"/>
      <url>/post/737279469.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、流媒体协议"><a href="#一、流媒体协议" class="headerlink" title="一、流媒体协议"></a>一、流媒体协议</h1><h2 id="1-1-RTP-Real-time-Transport-Protocol"><a href="#1-1-RTP-Real-time-Transport-Protocol" class="headerlink" title="1.1 RTP (Real-time Transport Protocol)"></a>1.1 RTP (Real-time Transport Protocol)</h2><h3 id="1-1-1-RTP-特征"><a href="#1-1-1-RTP-特征" class="headerlink" title="1.1.1 RTP 特征"></a>1.1.1 RTP 特征</h3><p>实时传输协议（Real-time Transport Protocol）是一个<strong>网络传输层</strong>协议，它是由 IETF 的多媒体传输工作小组 1996 年在 RFC 1889 中公布的，它作为因特网标准在 RFC 3550（该文档的旧版本是 RFC 1889）有详细说明，RTP 标准定义了两个子协议：RTP 和 RTCP。</p><p><strong>RTP 协议是建立在 UDP 协议上的。</strong> RTP 协议详细说明了在互联网上传递音频和视频的标准数据包格式。RTP 协议常用于流媒体系统（配合 RTCP 协议）、视频会议和视频电话系统（配合 H.263 或 SIP）。</p><p>RTP 标准由两个紧密链接部分组成：</p><ul><li>RTP —- 传送具有实时属性的数据；</li><li>RTP 控制协议（RTCP）—-监控服务质量并传送正在进行的会话参与者的相关信息。</li></ul><p>RTP 本身并没有提供按时发送机制或其他服务质量（QoS）保证，它依赖于底层服务去实现这一过程。RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。RTP 实行有序传送，RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。</p><h3 id="1-1-2-RTP-报头"><a href="#1-1-2-RTP-报头" class="headerlink" title="1.1.2 RTP 报头"></a>1.1.2 RTP 报头</h3><p>RTP 报头格式如下：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/liumeitijichu-1.jpg"></p><ul><li>V：RTP 协议的版本号，占 2 位，当前协议版本号为 2。</li><li>P：填充标志，占 1 位，如果 P=1，则在该报文的尾部填充一个或多个额外的八位组，它们不是有效载荷的一部分。</li><li>X：扩展标志，占 1 位，如果 X=1，则在 RTP 报头后跟有一个扩展报头。</li><li>CC：CSRC 计数器，占 4 位，指示 CSRC 标识符的个数。</li><li>M: 标记，占 1 位，不同的有效载荷有不同的含义，对于视频，标记一帧的结束；对于音频，标记会话的开始。</li><li>PT: 有效载荷类型，占 7 位，用于说明 RTP 报文中有效载荷的类型，如 GSM 音频、JPEM 图像等。</li><li>序列号：占 16 位，用于标识发送者所发送的 RTP 报文的序列号，每发送一个报文，序列号增 1。接收者通过序列号来检测报文丢失情况，重新排序报文，恢复数据。</li><li>时戳(Timestamp)：占 32 位，时戳反映了该 RTP 报文的第一个八位组的采样时刻。接收者使用时戳来计算延迟和延迟抖动，并进行同步控制。</li><li>同步信源(SSRC)标识符：占 32 位，用于标识同步信源。该标识符是随机选择的，参加同一视频会议的两个同步信源不能有相同的 SSRC。</li><li>特约信源(CSRC)标识符：每个 CSRC 标识符占 32 位，可以有 0 ～ 15 个。每个 CSRC 标识了包含在该 RTP 报文有效载荷中的所有特约信源。</li></ul><p>这里的同步信源是指产生媒体流的信源，它通过 RTP 报头中的一个 32 位数字 SSRC 标识符来标识，而不依赖于网络地址，接收者将根据 SSRC 标识符来区分不同的信源，进行 RTP 报文的分组。特约信源是指当混合器接收到一个或多个同步信源的 RTP 报文后，经过混合处理产生一个新的组合 RTP 报文，并把混合器作为组合 RTP 报文的 SSRC，而将原来所有的 SSRC 都作为 CSRC 传送给接收者，使接收者知道组成组合报文的各个 SSRC。</p><h2 id="1-2-RTCP-Real-time-Transport-Control-Protocol"><a href="#1-2-RTCP-Real-time-Transport-Control-Protocol" class="headerlink" title="1.2 RTCP (Real-time Transport Control Protocol)"></a>1.2 RTCP (Real-time Transport Control Protocol)</h2><p>实时传输控制协议（Real-time Transport Control Protocol,RTCP）是实时传输协议（RTP）的一个姐妹协议。</p><p>RTCP 为 RTP 媒体流提供信道外控制。RTCP 定期在多媒体流会话参加者之间传输控制数据。RTCP 的主要功能是为 RTP 所提供的服务质量提供反馈。</p><p>RTCP 收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，时延抖动，单向和双向网络延迟等等。网络应用程序可以利用 RTCP 所提供的信息试图提高服务质量，比如限制信息流量或改用压缩比较小的编解码器。RTCP 本身不提供数据加密或身份认证，其伴生协议<code>SRTCP（安全实时传输控制协议）</code>则可用于此类用途。</p><blockquote><p>WebRTC 内部采用的是 RTC+RTCP</p></blockquote><h2 id="1-3-SRTP-SRTCP"><a href="#1-3-SRTP-SRTCP" class="headerlink" title="1.3 SRTP &amp; SRTCP"></a>1.3 SRTP &amp; SRTCP</h2><p>SRTP = Secure Real-time Transport Protocol<br>SRTCP = Secure Real-time Transport Control Protocol<br>SRTP 是在实时传输协议 RTP 基础上所定义的一个协议，旨在为单播和多播应用程序中的实时传输协议的数据提供加密、消息认证、完整性保证和重放保护。它是由 David Oran（思科）和 Rolf Blom（爱立信）开发的，并最早由 IETF 于 2004 年 3 月作为 RFC 3711 发布。</p><h2 id="1-4-RTSP-Real-time-Transport-Streaming-Protocol"><a href="#1-4-RTSP-Real-time-Transport-Streaming-Protocol" class="headerlink" title="1.4 RTSP (Real-time Transport Streaming Protocol)"></a>1.4 RTSP (Real-time Transport Streaming Protocol)</h2><p>RTSP（Real Time Streaming Protocol），RFC2326，实时流传输协议。RTSP 在体系结构上位于 RTP 和 RTCP 之上，它使用 TCP 或 UDP 完成数据传输。</p><p>RTSP 是一种基于文本的<strong>应用层协议</strong>，在语法及一些消息参数等方面与 HTTP 协议类似。</p><p>RTSP 被用于建立的控制媒体流的传输，它为多媒体服务扮演“网络远程控制”的角色。尽管有时可以把 RTSP 控制信息和媒体数据流交织在一起传送，但一般情况 RTSP 本身并不用于传送媒体流数据，媒体数据的传送可通过 RTP/RTCP 等协议来完成。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/liumeitijichu-2.jpg"></p><h2 id="1-5-SDP-Session-Description-Protocol"><a href="#1-5-SDP-Session-Description-Protocol" class="headerlink" title="1.5 SDP (Session Description Protocol)"></a>1.5 SDP (Session Description Protocol)</h2><p>会话描述协议（Session Description Protocol 或简写 SDP）描述的是流媒体的初始化参数。此协议由 IETF 发表为 RFC 2327。</p><p>SDP 完全是一种会话描述格式，它不属于传输协议。</p><p>SDP 用于描述多媒体通信会话，包括会话建立、会话请求和参数协商。SDP 不用于传输媒体数据，只能用于两个通信终端的参数协商，包括媒体类型、格式以及所有其他和会话相关的属性。SDP 以字符串的形式描述上述初始化参数。</p><blockquote><p>可以参考 <a href="/post/2172509399.html" title="SDP格式解析">SDP格式解析</a></p></blockquote><h2 id="1-6-SIP-Session-Initiation-Protocol"><a href="#1-6-SIP-Session-Initiation-Protocol" class="headerlink" title="1.6 SIP (Session Initiation Protocol)"></a>1.6 SIP (Session Initiation Protocol)</h2><p>SIP(Session Initiation Protocol)是一个应用层的信令控制协议。</p><p>SIP 用于初始化一个 Session，并负责传输 SDP 包；而 SDP 包中描述了一个 Session 中包含哪些媒体数据，邀请的人等等；当需要被邀请的人都通过各自的终端设备被通知到后，就可以使用 RTSP 来控制特定 Media 的通信，比如 RTSP 控制信息要求开始 Video 的播放，那么就开始使用 RTP（或者 TCP）实时传输数据，在传输过程中，RTCP 要负责 QoS 等。</p><h2 id="1-7-RTMP-Real-Time-Messaging-Protocol"><a href="#1-7-RTMP-Real-Time-Messaging-Protocol" class="headerlink" title="1.7 RTMP (Real Time Messaging Protocol)"></a>1.7 RTMP (Real Time Messaging Protocol)</h2><p>RTMP(Real-Time Messaging Protocol 实时消息传送协议)的缩写，它是 Adobe Systems 公司为 Flash 播放器和服务器之间音频、视频和数据传输开发的一个基于<strong>TCP</strong>的<strong>应用层</strong>传输协议。这是一个标准的、未加密的实时消息传递协议，默认端口是 1935。</p><p>RTMP 是一种有状态协议。</p><p>RTMP 协议有效的保证了媒体传输质量，使用户可以观看到高质量的多媒体。RTMP 采用 TCP 协议作为其在传输层的协议，避免了多媒体数据在广域网传输过程中的丢包对质量造成的损失。此外 RTMP 协议传输的 FLV 封装格式支持的 H．264 视频编码方式可以在很低的码率下显示质量还不错的画面，非常适合网络带宽不足的情况下收看流媒体。</p><p>当然 RTMP 协议也有一些局限，RTMP 基于 TCP 协议，而 TCP 协议实时性不如 UDP，也非常占用带宽。目前基于 UDP 的 RTMFP 协议能很好的解决这些问题。</p><blockquote><p>RTMPT 封装在 HTTP 请求之中，可穿越防火墙;<br>RTMPS 类似 RTMPT，但使用的是 HTTPS 连接;</p></blockquote><h2 id="1-8-RTMFP-Real-Time-Media-Flow-Protocol"><a href="#1-8-RTMFP-Real-Time-Media-Flow-Protocol" class="headerlink" title="1.8 RTMFP (Real Time Media Flow Protocol)"></a>1.8 RTMFP (Real Time Media Flow Protocol)</h2><p>RTMFP 是 Adobe 公司开发的一套新的通信协议。</p><p>RTMFP 是基于 UDP 的，RTMP 是基于 TCP 的。UDP 在传送直播数据方面比 TCP 还是有较多优势的，比如减少延时，对丢包的容忍，虽然在可靠性上有所损失。与 RTMP 不同, RTMFP 支持 Flash Player 直接发送数据给另一个，而不经过 Server。</p><h2 id="1-9-RSVP-Resource-ReSerVation-Protocol"><a href="#1-9-RSVP-Resource-ReSerVation-Protocol" class="headerlink" title="1.9 RSVP (Resource ReSerVation Protocol)"></a>1.9 RSVP (Resource ReSerVation Protocol)</h2><p>使用 RSVP 预留一部分网络资源（即带宽），能在一定程度上为流媒体的传输提供 QoS。通常 RSVP 请求将会引起每个节点数据路径上的资源预留。</p><p>RSVP 只在单方向上进行资源请求，因此，尽管相同的应用程序，同时可能既担当发送者也担当接受者，但 RSVP 对发送者与接受者在逻辑上是有区别的。 RSVP 属于<strong>网络层</strong>协议。 RSVP 不传输应用数据，但支持因特网控制协议，如 ICMP、IGMP 或者路由选择协议。</p><h2 id="1-10-MMS-Microsoft-Media-Server-Protocol"><a href="#1-10-MMS-Microsoft-Media-Server-Protocol" class="headerlink" title="1.10 MMS (Microsoft Media Server Protocol)"></a>1.10 MMS (Microsoft Media Server Protocol)</h2><p>MMS(Microsoft Media Server Protocol)，微软媒体服务器协议，用来访问接收 Windows Media 服务器中 .asf 文件的一种协议。MMS 协议用于访问 Windows Media 发布点上的单播内容。</p><p>MMS 的默认端口是 1755.</p><h2 id="1-11-HLS-HTTP-Live-Streaming"><a href="#1-11-HLS-HTTP-Live-Streaming" class="headerlink" title="1.11 HLS (HTTP Live Streaming)"></a>1.11 HLS (HTTP Live Streaming)</h2><p>HTTP Live Streaming（缩写是 HLS）是一个由苹果公司提出的基于<strong>HTTP</strong>的流媒体网络传输协议。它的工作原理是把整个流分成一个个小的基于 HTTP 的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的 extended M3U (m3u8)playlist 文件，用于寻找可用的媒体流。</p><p>HLS 只请求基本的 HTTP 报文，与实时传输协议（RTP)不同，HLS 可以穿过任何允许 HTTP 数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。</p><p>HLS 协议规定：</p><ul><li>视频的封装格式是 TS。</li><li>视频的编码格式为 H264,音频编码格式为 MP3、AAC 或者 AC-3。</li><li>除了 TS 视频文件本身，还定义了用来控制播放的 m3u8 文件（文本文件）。</li></ul><h1 id="二、封装格式"><a href="#二、封装格式" class="headerlink" title="二、封装格式"></a>二、封装格式</h1><table><thead><tr><th>名称</th><th>推出机构</th><th>流媒体支持</th><th>支持的视频编码</th><th>支持的音频编码</th></tr></thead><tbody><tr><td>AVI</td><td>Microsoft Inc.</td><td>否</td><td>几乎所有格式</td><td>几乎所有格式</td></tr><tr><td>MP4</td><td>MPEG</td><td>是</td><td>MPEG-2, MPEG-4, H.264, H.263 等</td><td>AAC, MPEG-1 Layers I, II, III, AC-3 等</td></tr><tr><td>TS</td><td>MPEG</td><td>是</td><td>MPEG-1, MPEG-2, MPEG-4, H.264</td><td>MPEG-1 Layers I, II, III, AAC</td></tr><tr><td>FLV</td><td>Adobe Inc.</td><td>是</td><td>Sorenson, VP6, H.264</td><td>MP3, ADPCM, Linear PCM, AAC 等</td></tr><tr><td>MKV</td><td>CoreCodec Inc.</td><td>是</td><td>几乎所有格式</td><td>几乎所有格式</td></tr><tr><td>RMVB</td><td>Real Network Inc.</td><td>是</td><td>RealVideo 8, 9, 10</td><td>AAC, Cook Codec, RealAudio Lossless</td></tr></tbody></table><h1 id="三、视频编码格式"><a href="#三、视频编码格式" class="headerlink" title="三、视频编码格式"></a>三、视频编码格式</h1><table><thead><tr><th>名称</th><th>推出机构</th><th>推出时间</th></tr></thead><tbody><tr><td>HEVC(h.265)</td><td>MPEG/ITU-T</td><td>2013</td></tr><tr><td>H.264</td><td>MPEG/ITU-T</td><td>2003</td></tr><tr><td>MPEG4</td><td>MPEG</td><td>2001</td></tr><tr><td>MPEG2</td><td>MPEG</td><td>1994</td></tr><tr><td>VP9</td><td>Google</td><td>2013</td></tr><tr><td>VP8</td><td>Google</td><td>2008</td></tr><tr><td>VC-1</td><td>Microsoft Inc.</td><td>2006</td></tr></tbody></table><h1 id="四、音频编码格式"><a href="#四、音频编码格式" class="headerlink" title="四、音频编码格式"></a>四、音频编码格式</h1><table><thead><tr><th>名称</th><th>推出机构</th><th>推出时间</th></tr></thead><tbody><tr><td>AAC</td><td>MPEG</td><td>1997</td></tr><tr><td>AC-3</td><td>Dolby Inc.</td><td>1992</td></tr><tr><td>MP3</td><td>MPEG</td><td>1993</td></tr><tr><td>WMA</td><td>Microsoft Inc.</td><td>1999</td></tr></tbody></table><br>目前，直播服务普通采用RTMP作为流媒体协议，FLV作为封装格式，H.264作为视频编码格式，AAC作为音频编码格式化。点播服务普通采用HTTP作为流媒体协议，H.264作为视频编码格式，AAC作为音频编码格式，而封装格式有多种，如MP4，FLV，F4V等。]]></content>
      
      
      <categories>
          
          <category> ⑤ 音视频编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows平台编译WebRTC源码</title>
      <link href="/post/2910781705.html"/>
      <url>/post/2910781705.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>写作本文时使用的 webrtc 版本为：<code>branch heads/67</code></p></blockquote><h2 id="一、-准备工作"><a href="#一、-准备工作" class="headerlink" title="一、 准备工作"></a>一、 准备工作</h2><h3 id="1-0-请确保可以访问国外网站"><a href="#1-0-请确保可以访问国外网站" class="headerlink" title="1.0 请确保可以访问国外网站"></a>1.0 请确保可以访问国外网站</h3><h3 id="1-1-系统语言切换到英文"><a href="#1-1-系统语言切换到英文" class="headerlink" title="1.1 系统语言切换到英文"></a>1.1 系统语言切换到英文</h3><p>系统 Windows 7/10 都可以，在“控制面板”–&gt;”区域和语言”–&gt;”管理”–&gt;”更改系统区域设置”中切换到“英语（美国）”，然后重启系统。</p><span id="more"></span><h3 id="1-2-卸载部分软件"><a href="#1-2-卸载部分软件" class="headerlink" title="1.2 卸载部分软件"></a>1.2 卸载部分软件</h3><p>无</p><h3 id="1-3-安装-VS2017"><a href="#1-3-安装-VS2017" class="headerlink" title="1.3 安装 VS2017"></a>1.3 安装 VS2017</h3><p>Visual Studio 2017 现在只提供在线安装包，为了加快在线安装的速度，可以只选择如下几个安装项：</p><ul><li>Desktop development with C++</li><li>MFC and ATL support</li></ul><h3 id="1-4-安装-Windows-10-SDK"><a href="#1-4-安装-Windows-10-SDK" class="headerlink" title="1.4 安装 Windows 10 SDK"></a>1.4 安装 Windows 10 SDK</h3><p>虽然官方指南上面写的是支持 10.0.15063 及以后的版本，但编译选项中<strong>默认</strong>指定的是 10.0.15063 版本，所以建议安装 10.0.15063 版本。如果要使用其他版本的 SDK，可以在<code>三、 生成vs解决方案</code> 这一步中指定<code>--winsdk=&lt;sdk_version&gt;</code>参数。</p><p>10.0.15063 下载地址：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://download.microsoft.com/download/0/1/1/01111605-8CDF-4A88-BB06-C20E97E8B3D5/iso_windowssdk/15063.468.170612-1856.rs2_release_svc_sec_WindowsSDK.iso</span><br></pre></td></tr></tbody></table></figure><h3 id="1-5-安装-DirectX-SDk"><a href="#1-5-安装-DirectX-SDk" class="headerlink" title="1.5 安装 DirectX SDk"></a>1.5 安装 DirectX SDk</h3><p>下载地址：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://download.microsoft.com/download/A/E/7/AE743F1F-632B-4809-87A9-AA1BB3458E31/DXSDK_Jun10.exe</span><br></pre></td></tr></tbody></table></figure><p>安装 DirectX SDK June 2010，安装完成后可能会提示“s1023”这样的错误，这是因为与系统已有的 visual c++ redistributable packages 版本冲突，可以忽略不管。</p><h2 id="二、-源码获取"><a href="#二、-源码获取" class="headerlink" title="二、 源码获取"></a>二、 源码获取</h2><h3 id="2-1-配置-depot-tools"><a href="#2-1-配置-depot-tools" class="headerlink" title="2.1 配置 depot_tools"></a>2.1 配置 depot_tools</h3><p>depot_tools 是 webrtc 或 chromium 使用的源码管理工具，从此处下载：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://storage.googleapis.com/chrome-infra/depot_tools.zip</span><br></pre></td></tr></tbody></table></figure><p>解压到 D:\webrtc\depot_tools 中，添加该目录到到系统环境变量 PATH。</p><blockquote><p>因为 webrtc 或 chromium 使用的编译系统会自动下载与之匹配的 Python 和 Git，为了防止编译系统错误使用原有的版本，需要将<code>D:\webrtc\depot_tools</code>路径放到 PATH 的最前面，至少也要放到 Python 和 Git 的前面。</p></blockquote><h3 id="2-2-环境初始化"><a href="#2-2-环境初始化" class="headerlink" title="2.2 环境初始化"></a>2.2 环境初始化</h3><p>先设置如下环境变量：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEPOT_TOOLS_WIN_TOOLCHAIN = 0</span><br><span class="line">GYP_GENERATORS = ninja,msvs-ninja</span><br></pre></td></tr></tbody></table></figure><p>然后以管理员权限运行系统 cmd 命令行（不要使用其他命令行工具，如 cmder），依次执行下面的命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d:</span><br><span class="line">cd D:\webrtc   # 用来进入webrtc目录，目录名不一样，命令也不一样</span><br><span class="line">gclient        # 需要使用网络代理，耗时较长</span><br></pre></td></tr></tbody></table></figure><h3 id="2-3-下载源码和依赖项"><a href="#2-3-下载源码和依赖项" class="headerlink" title="2.3 下载源码和依赖项"></a>2.3 下载源码和依赖项</h3><p>新建 webrtc-checkout 目录，下载源码到该目录，命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir webrtc-checkout      # 也可以手动新建</span><br><span class="line">cd webrtc-checkout</span><br><span class="line">fetch --nohooks webrtc    # 获取源码</span><br><span class="line">gclient sync              # 更新源码</span><br><span class="line">gclient runhooks          # 获取DEPS文件中指定的依赖项</span><br></pre></td></tr></tbody></table></figure><h2 id="三、-生成-vs-解决方案"><a href="#三、-生成-vs-解决方案" class="headerlink" title="三、 生成 vs 解决方案"></a>三、 生成 vs 解决方案</h2><p>进入 webrtc-checkout\src 目录（2.3 步骤中下载的源码会自动存储到该目录）,执行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn gen --ide=vs out/Debug</span><br></pre></td></tr></tbody></table></figure><p>或者加入详细的配置参数：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn gen out/x64/Debug --ide=vs --args="is_debug=true target_cpu=\"x64\""</span><br></pre></td></tr></tbody></table></figure><p>执行成功之后，在 out/Debug 目录中会生成 all.sln 解决方案文件。</p><p>另外，可以使用<code>gn gen --help</code>查看帮助，节选如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">IDE options</span><br><span class="line"></span><br><span class="line">  GN optionally generates files for IDE. Possibilities for &lt;ide options&gt;</span><br><span class="line"></span><br><span class="line">  --ide=&lt;ide_name&gt;</span><br><span class="line">      Generate files for an IDE. Currently supported values:</span><br><span class="line">      "eclipse" - Eclipse CDT settings file.</span><br><span class="line">      "vs" - Visual Studio project/solution files.</span><br><span class="line">             (default Visual Studio version: 2017)</span><br><span class="line">      "vs2013" - Visual Studio 2013 project/solution files.</span><br><span class="line">      "vs2015" - Visual Studio 2015 project/solution files.</span><br><span class="line">      "vs2017" - Visual Studio 2017 project/solution files.</span><br><span class="line">      "xcode" - Xcode workspace/solution files.</span><br><span class="line">      "qtcreator" - QtCreator project files.</span><br><span class="line">      "json" - JSON file containing target information</span><br><span class="line"></span><br><span class="line">  --filters=&lt;path_prefixes&gt;</span><br><span class="line">      Semicolon-separated list of label patterns used to limit the set of</span><br><span class="line">      generated projects (see "gn help label_pattern"). Only matching targets</span><br><span class="line">      and their dependencies will be included in the solution. Only used for</span><br><span class="line">      Visual Studio, Xcode and JSON.</span><br><span class="line"></span><br><span class="line">Visual Studio Flags</span><br><span class="line"></span><br><span class="line">  --sln=&lt;file_name&gt;</span><br><span class="line">      Override default sln file name ("all"). Solution file is written to the</span><br><span class="line">      root build directory.</span><br><span class="line"></span><br><span class="line">  --no-deps</span><br><span class="line">      Don't include targets dependencies to the solution. Changes the way how</span><br><span class="line">      --filters option works. Only directly matching targets are included.</span><br><span class="line"></span><br><span class="line">  --winsdk=&lt;sdk_version&gt;</span><br><span class="line">      Use the specified Windows 10 SDK version to generate project files.</span><br><span class="line">      As an example, "10.0.15063.0" can be specified to use Creators Update SDK</span><br><span class="line">      instead of the default one.</span><br><span class="line"></span><br><span class="line">  --ninja-extra-args=&lt;string&gt;</span><br><span class="line">      This string is passed without any quoting to the ninja invocation</span><br><span class="line">      command-line. Can be used to configure ninja flags, like "-j".</span><br></pre></td></tr></tbody></table></figure><p>在编译解决方案中的某些工程（如<code>freetype_source</code>, <code>harfbuzz_source</code>）时，可能会遇到诸如下面的错误提示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error C2220: 警告被视为错误 - 没有生成“object”文件</span><br></pre></td></tr></tbody></table></figure><p>这时我们需要调低警告等级，编译对应的 ninja 文件，将其中的<code>/WX</code>改成<code>/W3</code>即可。</p><blockquote><p>参考：<br><a href="https://chromium.googlesource.com/chromium/src/+/master/docs/windows_build_instructions.md">https://chromium.googlesource.com/chromium/src/+/master/docs/windows_build_instructions.md</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ⑤ 音视频编程 </category>
          
          <category> WebRTC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(5)--Qt字符编码</title>
      <link href="/post/1204594779.html"/>
      <url>/post/1204594779.html</url>
      
        <content type="html"><![CDATA[<p>我们以<code>“测试字符串-보고싶다-Test String.”</code>这个字符串来进行讲解，它包含了英文、中文和韩文。<br>因为我使用 Qt 的方式是<code>Visual Studio + Qt库</code>的形式，所以本文以<code>Visual Studio</code>的<code>MSVC编译器</code>为例来进行讲解，但这种方式的原理也适用于其他编译器。</p><p>QString 中使用 QChar 来存储每一个字符，QChar 是 short 类型，占 2 个字节，默认按 Unicode 编码存储。</p><p>首先，为了保证写到代码文件中的测试字符串能被 MSVC 编译器理解，我们需要将源文件保存为<code>Utf8-带签名</code>的格式。具体参考：<a href="/post/1337290471.html" title="拨开字符编码的迷雾(2)--编译器处理文件编码">拨开字符编码的迷雾(2)--编译器处理文件编码</a></p><span id="more"></span><p>解决Qt程序乱码问题的关键在于理解QString中存储字符的编码格式。</p><p><strong>QString 中存储的字符串的编码格式就是“编译器执行字符集编码格式”。</strong> 这一句话很关键。</p><p>在 MSVC 中我们可以使用<code>#pragma execution_character_set("utf-8")</code>来指定该源文件的执行字符集编码格式为 UTF8 格式，这样 QString 中存储的字符串格式就是 utf8 编码了。</p><p>下面是完整的测试用例：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo01::qStringUseCase</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  该源文件使用Utf8-BOM格式保存.</span></span><br><span class="line"><span class="comment">  源字符集为UTF8-BOM.</span></span><br><span class="line"><span class="comment">  可执行字符集为UTF8：#pragma execution_character_set("utf-8") 定义在stdafx.h.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_STR_A <span class="string">"测试字符串-보고싶다-Test String."</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_STR_W <span class="string">L"测试字符串-보고싶다-Test String."</span></span></span><br><span class="line"></span><br><span class="line">  {</span><br><span class="line">    <span class="comment">// 因为可执行字符集是utf8，所以使用OutputDebugStringA需要转换成ANSI</span></span><br><span class="line">    <span class="built_in">OutputDebugStringA</span>(<span class="built_in">Utf8ToAnsi</span>(TEST_STR_A).<span class="built_in">c_str</span>());</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  {</span><br><span class="line">    ui.lblLanguage-&gt;<span class="built_in">setText</span>(TEST_STR_A);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// char* --&gt; QString</span></span><br><span class="line">  {</span><br><span class="line">    QString qstr = TEST_STR_A;</span><br><span class="line">    <span class="built_in">qInfo</span>() &lt;&lt; qstr;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// QString --&gt; char*或std::string</span></span><br><span class="line">  {</span><br><span class="line">    QString qstr = TEST_STR_A;</span><br><span class="line"></span><br><span class="line">    std::string str = qstr.<span class="built_in">toStdString</span>(); <span class="comment">// 不能直接使用qstr.toStdString().c_str()来获取，必须先将qstr.toStdString()存入std::string中</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pStr = str.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QString qstr2 = QString::<span class="built_in">fromUtf8</span>(pStr);</span><br><span class="line">    <span class="built_in">Q_ASSERT</span>(qstr == qstr2);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// QString --&gt; wchar_t*或std::wstring</span></span><br><span class="line">  {</span><br><span class="line">    QString qstr = TEST_STR_A;</span><br><span class="line"></span><br><span class="line">    std::wstring str = qstr.<span class="built_in">toStdWString</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span> * pStr = str.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line">    QString qstr2 = QString::<span class="built_in">fromWCharArray</span>(pStr);</span><br><span class="line">    <span class="built_in">Q_ASSERT</span>(qstr == qstr2);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// std::string --&gt; QString</span></span><br><span class="line">  {</span><br><span class="line">    std::string str = TEST_STR_A;  <span class="comment">// std::string中存储的是UTF-8编码的字符串，因为可执行字符集为UTF8</span></span><br><span class="line">    QString qstr = QString::<span class="built_in">fromStdString</span>(str);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// std::wstring --&gt; QString</span></span><br><span class="line">  {</span><br><span class="line">    std::wstring str = TEST_STR_W;  <span class="comment">// std::wstring中存储的是UTF-8编码的字符串，因为可执行字符集为UTF8</span></span><br><span class="line">    QString qstr = QString::<span class="built_in">fromStdWString</span>(str);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="QString-toLocal8Bit"><a href="#QString-toLocal8Bit" class="headerlink" title="QString::toLocal8Bit"></a>QString::toLocal8Bit</h1><p>QString 有一个名为<code>toLocal8Bit</code>的方法，网上很多介绍如何解决乱码的文章都会提到这个函数。关于这个函数官方的介绍如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Returns the local 8-bit representation of the string as a QByteArray. The returned byte array is undefined if the string contains characters not supported by the local 8-bit encoding.</span><br><span class="line"></span><br><span class="line">QTextCodec::codecForLocale() is used to perform the conversion from Unicode. If the locale encoding could not be determined, this function does the same as toLatin1().</span><br><span class="line"></span><br><span class="line">If this string contains any characters that cannot be encoded in the locale, the returned byte array is undefined. Those characters may be suppressed or replaced by another.</span><br></pre></td></tr></tbody></table></figure><p>简单来说，我们可以理解为这个函数将字符串转换为的 ANSI 编码，通过<a href="/post/2720283852.html" title="拨开字符编码的迷雾(1)--字符编码概述">拨开字符编码的迷雾(1)--字符编码概述</a>介绍，我们应该知道<code>ANSI</code>是和具体的代码页相关联的（在 Windows 中文环境下默认代码页为 936）。Qt 不是根据系统代码页来做判断的，而是通过<code>QTextCodec</code>来做判断的，所以文档中会提到这个函数需要结合<code>QTextCodec::codecForLocale()</code>来使用，<code>toLocal8Bit</code>根据对应的<code>QTextCodec</code>来做相应的转换。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以要想在使用 Qt 时，避免遇到中文乱码问题，只需要在预编译头文件中加入（对于不使用预编译头的项目可以在.cpp文件中添加）：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> execution_character_set(<span class="string">"utf-8"</span>)</span></span><br></pre></td></tr></tbody></table></figure><p>同时由于部分韩文、日文等字符不在 Visual Studio 默认的中文 GB2312 编码中，所以如果遇到 Visual Studio 提示“此文件的某些 Unicode 字符未能保存到当前代码页中”时，这时应该选择”<code>Utf8-带签名</code>“格式来保存。</p><p>综上所述，源文件保存为<code>Utf8-带签名</code>，且设置<code>#pragma execution_character_set("utf-8") </code>就可以解决所有乱码问题。</p><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(7)--使用std::string跨MT模块传参</title>
      <link href="/post/3937624737.html"/>
      <url>/post/3937624737.html</url>
      
        <content type="html"><![CDATA[<p>前面的<a href="/post/213040252.html" title="Windows内存体系(6)--跨模块内存分配释放">Windows内存体系(6)--跨模块内存分配释放</a>文章解释了跨 MT 模块分配的内存相互释放为什么会崩溃的问题，本文介绍如何解决该问题。</p><span id="more"></span><h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>这篇文章主要介绍我们在实际开发中经常遇到的一个问题：针对 MT 模块定义接口函数时，接口参数使用<code>std::string</code>类型，在程序运行时遇到<code>"Debug Assertioni Failed"</code>错误的问题。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-nctx-stdstring-mt-1.jpg"></p><p>上面的错误提示是<code>debug_heap.cpp</code>文件中的一个调试断言（<code>release模式</code>下调用的是<code>heap.cpp</code>中的分配函数），用于判断指针是否指向堆分配的内存块的第一块。在 release 模式下不会弹出这样的断言错误，程序可能会直接崩溃（崩溃相对来说还比较好排查），或者出现其他不可预料的、难以排查的错误。</p><h2 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h2><p>现有<code>DLLUser.exe</code>调用<code>DLL.dll</code>中的<code>TestFun</code>函数，代码量非常小：</p><h4 id="DLL-dll中TestFun函数定义："><a href="#DLL-dll中TestFun函数定义：" class="headerlink" title="DLL.dll中TestFun函数定义："></a><code>DLL.dll</code>中<code>TestFun</code>函数定义：</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DLL_API <span class="type">void</span> <span class="title">TestFun</span><span class="params">( std::string str)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="DLLUser-exe中调用TestFun函数："><a href="#DLLUser-exe中调用TestFun函数：" class="headerlink" title="DLLUser.exe中调用TestFun函数："></a><code>DLLUser.exe</code>中调用<code>TestFun</code>函数：</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">{</span><br><span class="line">  std::string str = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TestFun</span>(str);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>上面的代码运行之后程序就会弹出错误断言。原因是<code>std::string</code>在进行<code>值传参</code>的过程中会执行一次深拷贝，即：在堆上分配内存块，拷贝“test”到内存块中，然后将临时形参<code>std::string</code>对象传递到 dll 中，dll 中的<code>TestFun</code>函数在作用域结束后对临时形参进行释放时就出现了错误，因为尝试在<code>dll的crt堆</code>中释放由在<code>exe的crt堆</code>中分配的内存块。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-nctx-stdstring-mt-2.jpg"></p><h2 id="三、自定义std-allocator"><a href="#三、自定义std-allocator" class="headerlink" title="三、自定义std::allocator"></a>三、自定义<code>std::allocator</code></h2><p>通过上面问题的分析，加上前面几篇文章对 Windows 内存体系的介绍，我们不难想出解决方案，其中一种方案就是：让<code>std::string</code>统一在进程的默认堆上分配内存块，而不是在各个模块的<code>crt堆</code>上分配。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vm_allocator</span> : <span class="keyword">public</span> std::allocator&lt;T&gt; {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> T* const_pointer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">rebind</span> {</span><br><span class="line">    <span class="keyword">typedef</span> vm_allocator&lt;_Tp1&gt; other;</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n, <span class="type">const</span> <span class="type">void</span> *hint = <span class="number">0</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(hint);</span><br><span class="line">    <span class="type">void</span>* pBuffer = <span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), HEAP_ZERO_MEMORY, n * <span class="built_in">sizeof</span>(T));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (pointer)pBuffer;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer p, size_type n)</span> </span>{</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (p) {</span><br><span class="line">      <span class="built_in">HeapFree</span>(<span class="built_in">GetProcessHeap</span>(), <span class="number">0</span>, p);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vm_allocator</span>() <span class="keyword">throw</span>() : std::<span class="built_in">allocator</span>&lt;T&gt;() {</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vm_allocator</span>(<span class="type">const</span> vm_allocator &amp;a) <span class="built_in">throw</span>() : std::<span class="built_in">allocator</span>&lt;T&gt;(a) {</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;</span><br><span class="line">  <span class="built_in">vm_allocator</span>(<span class="type">const</span> vm_allocator&lt;U&gt; &amp;a) <span class="built_in">throw</span>() : std::<span class="built_in">allocator</span>&lt;T&gt;(a) {</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">vm_allocator</span>() <span class="built_in">throw</span>() {</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::basic_string&lt;<span class="type">char</span>, std::char_traits&lt;<span class="type">char</span>&gt;, vm_allocator&lt;<span class="type">char</span>&gt; &gt; mystring;</span><br></pre></td></tr></tbody></table></figure><p>上面的代码使用自定义的内存分配器<code>vm_allocator&lt;char&gt;</code>定义了<code>mystring</code>类，我们只需要将<code>TestFun</code>函数接口中的<code>std::string</code>修改为<code>mystring</code>即可解决崩溃问题。</p><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Wav音频编码</title>
      <link href="/post/3666885372.html"/>
      <url>/post/3666885372.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-WAVE-简介"><a href="#一-WAVE-简介" class="headerlink" title="一. WAVE 简介"></a>一. WAVE 简介</h1><p>WAV格式是微软公司（Microsoft)开发的一种声音文件格式，它符合 RIFF(Resource Interchange File Format)文件规范，用于保存 Windows 平台的音频信息资源，被 Windows 平台及其应用程序所广泛支持。</p><p>WAVE 是录音时用的标准的 WINDOWS 文件格式，文件的扩展名为“WAV”，数据本身的格式为 PCM 或其他压缩数据，属于无损音乐格式的一种。</p><p>所有的 WAV 都有一个文件头，这个文件头记录了音频流的编码参数。<code>WAV文件 = WAV头 + PCM数据</code>。</p><span id="more"></span><h1 id="二-音频编码参数"><a href="#二-音频编码参数" class="headerlink" title="二. 音频编码参数"></a>二. 音频编码参数</h1><p>在介绍 WAVE 文件头之前，需要了解下音频编码的各个参数的含义：</p><ul><li>声道数量(NumChannels)<br>声道数是指支持能不同发声的音响的个数，它是衡量音响设备的重要指标之一。我们戴的耳机因为只有左右 2 个喇叭，所以最多只能支持 2 个声道数量。<br>单声道（mono）的声道数为 1；立体声道（stereo）的声道数默认为 2，即左右声道；四声道即前左、前右，后左、后右供 4 个发音点；目前还有 5.1 声道、7.1 声道。</li></ul><p>对于我们音频编码存储来说，每多一个声道，就要多存储一份数据。</p><ul><li><p>采样率(SampleRate)<br>表示每秒采样的次数，常见的有 8000, 16000, 32000, 44100, 48000。</p></li><li><p>采样精度(BitPerSample)<br>表示每次从每个声道采样的数据的大小，以比特位单位。一般为 16,32。16 即 16 比特，也就是 2 个字节。</p></li><li><p>比特率(ByteRate)<br>表示每秒的音频数据大小，以字节为单位，可以根据上面几个参数求得。<br><code>ByteRate = SampleRate * NumChannels * BitPerSample  / 8</code></p></li></ul><h1 id="三-WAVE-文件头"><a href="#三-WAVE-文件头" class="headerlink" title="三. WAVE 文件头"></a>三. WAVE 文件头</h1><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wav-bm-1.gif"></p><table><thead><tr><th>偏移</th><th>字段字节数</th><th>字段名</th><th>解释</th></tr></thead><tbody><tr><td>0</td><td>4</td><td>ChunkID</td><td>“RIFF”串 十进制大端表示为 0x52494646</td></tr><tr><td>4</td><td>4</td><td>ChunkSize</td><td>整个文件的大小减去 8 字节(<code>ChunkID+ChunkSize</code>)。<code>36 + SubChunk2Size</code>或者 <code>4 + (8 + SubChunk1Size) + (8 + SubChunk2Size)</code></td></tr><tr><td>8</td><td>4</td><td>Format</td><td>“WAVE”串，十六进制大端表示为 0x57415645</td></tr><tr><td>12</td><td>4</td><td>Subchunk1ID</td><td>“fmt “串，十六进制大端表示为 0x666d7420</td></tr><tr><td>16</td><td>4</td><td>Subchunk1Size</td><td>整个 Subchunk1 的大小减去该字段本身所占的 4 字节，对于 PCM 来说固定为 16</td></tr><tr><td>20</td><td>2</td><td>AudioFormat</td><td>PCM 格式为 1，大于 1 表示其他压缩格式</td></tr><tr><td>22</td><td>2</td><td>NumChannels</td><td>声道数量，如 Mono = 1, Stereo = 2</td></tr><tr><td>24</td><td>4</td><td>SampleRate</td><td>采样率，如 8000, 44100 等</td></tr><tr><td>28</td><td>4</td><td>ByteRate</td><td>比特率， 等于<code>SampleRate * NumChannels * BitsPerSample/8</code></td></tr><tr><td>32</td><td>2</td><td>BlockAlign</td><td>每个 Sample 的大小，等于<code>NumChannels * BitsPerSample/8</code></td></tr><tr><td>34</td><td>2</td><td>BitsPerSample</td><td>采样精度，如 8,16,32</td></tr><tr><td>36</td><td>4</td><td>Subchunk2ID</td><td>“data”串，十六进制大端表示为 0x64617461</td></tr><tr><td>40</td><td>4</td><td>Subchunk2Size</td><td>实际音频数据的大小，不包含 Subchunk2ID 和 Subchunk2Size 这 2 个字段的大小</td></tr><tr><td>44</td><td>*</td><td>Data</td><td>实际的音频数据</td></tr></tbody></table><p>下图是以十六进制显示的一个 WAV 文件的前 72 字节：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wav-bm-2.gif"></p><h1 id="四-从其他编码转-WAVE"><a href="#四-从其他编码转-WAVE" class="headerlink" title="四. 从其他编码转 WAVE"></a>四. 从其他编码转 WAVE</h1><p>我们可以使用 ffmpeg.exe 将音频从其他编码转为 wave 编码，命令如下:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg.exe -i input.mp3  output.wav</span><br></pre></td></tr></tbody></table></figure><p>我们还可以指定输出文件的编码格式，如采用率，采样精度，声道数，如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg.exe  -f u16le -ar 44100 -ac 1 -i input.mp3 output.wav</span><br></pre></td></tr></tbody></table></figure><p>ffmpeg 参数解释见：<a href="http://trac.ffmpeg.org/wiki/audio%20types">http://trac.ffmpeg.org/wiki/audio%20types</a></p><p>ffmpeg 生成的 wav 文件的文件头可能和我们上面介绍的不太一样，它可能会包含<code>LIST</code>和<code>INFO</code>数据块，这个时候我就需要通过 2 个步骤来生成不包含<code>LIST</code>和<code>INFO</code>数据块的 WAV 文件了：<br>首先通过 ffmpeg.exe 将音频文件转成 pcm 裸数据文件，然后使用其他工具（如<a href="https://download.csdn.net/download/china_jeffery/10381574">audacity</a>）为该 pcm 裸数据加上 wav 头。</p><p>ffmpeg 将音频转成 pcm 裸数据命令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg.exe -f s16le -c:a pcm_u16le  -i input.mp3 output.raw</span><br></pre></td></tr></tbody></table></figure><h1 id="五、WebRTC-对-Wav-格式支持"><a href="#五、WebRTC-对-Wav-格式支持" class="headerlink" title="五、WebRTC 对 Wav 格式支持"></a>五、WebRTC 对 Wav 格式支持</h1><p>WebRTC 源码<code>src\common_audio</code>目录中的<code>wav_header.h</code>和<code>wav_file.h</code>提供了对 wav 的读写功能。</p>]]></content>
      
      
      <categories>
          
          <category> ⑤ 音视频编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wav </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(6)--跨模块内存分配释放</title>
      <link href="/post/213040252.html"/>
      <url>/post/213040252.html</url>
      
        <content type="html"><![CDATA[<p>在《Windows核心编程 第五版》第19章 DLL基础（511页）中给出了一个建议：</p><p>“当一个 MT 版本的模块如果提供一个内存分配函数的时候，它必须同时提供另一个用来释放内存的函数。”。</p><p>说得更加直白一点就是，“对于 MT 的模块，不要跨模块进行内存释放。”。但是核心编程这本书上面没有具体分析原因，本文就来分析具体的原因。</p><span id="more"></span><h2 id="一、不同堆分配的内存块不能相互释放"><a href="#一、不同堆分配的内存块不能相互释放" class="headerlink" title="一、不同堆分配的内存块不能相互释放"></a>一、不同堆分配的内存块不能相互释放</h2><p>Windows 的<code>堆管理器</code>对每个进程都维护了多个<code>“堆”</code>，我们从每个<code>“堆”</code>中分配处理的内存块的地址都不一样。所以我们不能将从“堆 A”中分配出来的内存块拿到“堆 B”中，让“堆 B”来释放，这样就会导致程序异常。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-nctx-kmkncsf-1.png"></p><p>如上图，通过<code>malloc</code>函数从“堆 A”中分配 100 字节内存块，内存块地址为<code>0x123456</code>；从“堆 B”中分配 100 字节内存块，内存块地址为<code>0x345678</code>.<br>如果将<code>0x123456</code>这个地址拿到“堆 B”中去释放，势必会导致异常，因为“堆 B”中没有这地址。</p><p>那么我们是不是可以使用<code>HeapFree</code>函数来释放<code>hHeap</code>参数指定的“堆”中的任何内存块了。答案是：不能。<br>回忆前面介绍的<code>HeapFree</code>函数，</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">HeapFree</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hHeap,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID lpMem</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>这个函数只要求传入了内存块的起始地址指针，但没有要求传入需要释放的内存块的<code>大小</code>，那么该函数是如何知道起始地址指针指向的内存块的大小了？</p><p>我们可以简单的理解为，<code>HeapAlloc</code>函数每次分配内存块的时候都会额外分配一点空间用于存储一个结构体，该结构体中存储了本次分配的内存块的大小等信息。大致如下图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-nctx-kmkncsf-2.jpg"></p><p>所以，<code>HeapFree</code>函数首先会通过<code>lpMem</code>指针计算出“结构体”的地址，然后从结构体中获取到分配的内存块的具体大小，最后执行释放操作。</p><p>基于上面的原因，我们不能在<code>HeapFree</code>函数的<code>lpMem</code>参数中传入随意的地址，因为该地址处可能没有存储用于存放内存块信息的结构体，所以释放操作就会失败。<code>free</code>函数也一样，因为<code>free</code>函数内部也是调用的<code>HeapFree</code>函数。</p><h2 id="二、MD-模块内存可以相互释放"><a href="#二、MD-模块内存可以相互释放" class="headerlink" title="二、MD 模块内存可以相互释放"></a>二、MD 模块内存可以相互释放</h2><p>为什么 MD模块内存可以相互释放，而MT模块的却不可以了？</p><h3 id="2-1-MT-模块内存相互释放会崩溃"><a href="#2-1-MT-模块内存相互释放会崩溃" class="headerlink" title="2.1 MT 模块内存相互释放会崩溃"></a>2.1 MT 模块内存相互释放会崩溃</h3><p>我们先分析为什么 MT 模块的内存间相互释放会崩溃？</p><p>现在有 2 个模块（<code>A.dll</code>和<code>B.dll</code>）都是使用<code>MT</code>运行时库，即加载的静态库<code>libcmt.lib</code>（可以参考<a href="/post/782629701.html" title="理解C/C++运行时库">理解C/C++运行时库</a>），在<code>A.dll</code>中使用<code>malloc</code>分配 100 字节的内存，<code>malloc</code>返回的内存地址为<code>0x123456</code>。然后将该地址传给<code>B.dll</code>，在<code>B.dll</code>中调用<code>free</code>函数来释放这个内存。如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-nctx-kmkncsf-3.jpg"></p><p>从<a href="/post/3599385732.html" title="Windows内存体系(5)--堆">Windows内存体系(5)--堆</a>我们知道，DLL 在启动代码<code>_DllMainCRTStartup</code>中会建立一个“堆”（堆句柄存放在_crtheap 变量中），所以 A.dll 和 B.dll 中都会有一个 crt 堆。</p><p>为了区分，我们将<code>A.dll</code>中的<code>crt堆</code>称作<code>_crtheap_A</code>，<code>B.dll</code>中的<code>crt堆</code>称作<code>_crtheap_B</code>。</p><p>从上面图可以看到，<code>A.dll</code>中<code>malloc</code>的内存拿到<code>B.dll</code>去中去<code>free</code>，就相当于从堆<code>_crtheap_A</code>中分配的内存拿到另一个堆<code>_crtheap_B</code>中的释放。第一节已经解释了为什么不能这样做了。</p><h3 id="2-2-MD-模块内存相互释放不会崩溃"><a href="#2-2-MD-模块内存相互释放不会崩溃" class="headerlink" title="2.2 MD 模块内存相互释放不会崩溃"></a>2.2 MD 模块内存相互释放不会崩溃</h3><p>现在我们分析为什么 MD 模块的内存间相互释放不会崩溃。</p><p>还是 2 个模块（<code>A.dll</code>和<code>B.dll</code>），但是现在他们都是使用<code>MD</code>运行时库，即加载的动态库<code>msvcr100.dll</code>，程序的代码的过程和上面一样，还是在<code>A.dll</code>中使用<code>malloc</code>分配 100 字节的内存，<code>malloc</code>返回的内存地址为<code>0x123456</code>。然后将该地址传给<code>B.dll</code>，在<code>B.dll</code>中调用<code>free</code>函数来释放这个内存。但是这个时候程序却不会崩溃，通过下面的图我们基本可以明白原因了，如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-nctx-kmkncsf-4.jpg"></p><p>因为 A、B 两个 dll 都是链接的·msvcr100.dll·，同一个 dll 在一个进程只会被加载一次，所以进程中只会有一个 crt 堆（<code>_crtheap</code>），<code>malloc</code>和<code>free</code>都是运行时库提供的函数，所以都会调到运行时库里面去，然后从运行时库里面的<code>_crtheap</code>分配和释放内存块。因为分配和释放都是在同一个堆上，所以不会崩溃。</p><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(5)--堆</title>
      <link href="/post/3599385732.html"/>
      <url>/post/3599385732.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、为什么要使用堆-Heap-？"><a href="#一、为什么要使用堆-Heap-？" class="headerlink" title="一、为什么要使用堆 (Heap)？"></a>一、为什么要使用堆 (Heap)？</h2><p>应用程序虽然可以使用页面粒度的函数（如<code>VirualAlloc</code>）来分配一个最小为<code>4KB</code>或<code>8K</code>的内存块，但是很多时候我们并不需要分配这么大的内存块，我们可能只想分配 1K，2K 的内存块，那么这个时候无论从内存的使用率，还是从性能的角度来看，再分配这么大的一个内存区域显然不是最优的了。</p><p>为了满足这种需求，Windows 提供了一个被称为<code>“堆管理器”</code>的组件，它负责管理大内存区域中的内存分配，这些大内存区域就是通过一些页面粒度的内存分配函数（如<code>VirualAlloc</code>）来预定（<code>reserve</code>）的。</p><p>堆管理器中的分配粒度相对比较小：<code>在32位系统上是8字节，在64位系统上是16字节</code>。</p><p>堆管理器已经被 Windows 系统精心设计，在这些小内存分配的情况下会进行内存使用率和性能两个方面的优化。</p><span id="more"></span><h2 id="二、进程的默认堆"><a href="#二、进程的默认堆" class="headerlink" title="二、进程的默认堆"></a>二、进程的默认堆</h2><p>每个进程至少有一个堆，那就是进程的<code>默认堆</code>。进程的<code>默认堆</code>是在进程启动的时候创建的，而且在进程的生命周期中永远不会被删除。</p><p><code>“默认堆”</code>的默认大小为<code>1MB</code>，但是可以通过<code>/HEAP</code>链接器编译器选项来指定一个更大的起始大小。这个大小值只是初始的保留内存大小，后期根据需要它可以自动扩充。</p><p>应用程序可以调用<code>GetProcessHeap</code>来获取进程的默认堆，也可以通过调用<code>HeapCreate</code>函数来创建额外的私有堆，当一个进程不在需要一个私有堆的时候，它可以调用<code>HeapDestory</code>来释放虚拟地址空间。</p><h2 id="三、crt-堆"><a href="#三、crt-堆" class="headerlink" title="三、crt 堆"></a>三、crt 堆</h2><p>C 语言的<code>malloc,free</code>函数以及 C++的<code>new,delete</code>都是从<code>堆</code>上分配和释放内存的。但是他们所使用的堆不是进程的<code>默认堆</code>，他们使用的是<code>私有堆</code>。可是我们在使用<code>malloc</code>函数之前并有进行任何私有堆的创建操作呀？ 因为<code>malloc</code>函数使用的这个私有堆不需要程序员来创建，而是在 C 或 C++运行时库 DLL 的启动代码<code>_DllMainCRTStartup</code>中自动创建的。下面通过解析<code>malloc</code>函数的调用过程来说明这一点。</p><p><code>malloc</code>函数的定义在<code>malloc.c</code>文件中，调用流程如下：<br>（以<code>Microsoft Visual Studio 10.0</code>为例，<code>malloc.c</code>文件路径为<code>C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\crt\src</code>）</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1). void* __cdecl malloc(size_t const size)</span><br><span class="line">(2). void * __cdecl _malloc_base (size_t size)</span><br><span class="line">(3). void * __cdecl _heap_alloc (size_t size)</span><br></pre></td></tr></tbody></table></figure><p><code>_heap_alloc </code>的定义如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__forceinline <span class="type">void</span> * __cdecl _heap_alloc (<span class="type">size_t</span> size)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (_crtheap == <span class="number">0</span>) {</span><br><span class="line">        _FF_MSGBANNER();    <span class="comment">/* write run-time error banner */</span></span><br><span class="line">        _NMSG_WRITE(_RT_CRT_NOTINIT);  <span class="comment">/* write message */</span></span><br><span class="line">        __crtExitProcess(<span class="number">255</span>);  <span class="comment">/* normally _exit(255) */</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">HeapAlloc</span>(_crtheap, <span class="number">0</span>, size ? size : <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从上面的代码中，我们可以看到分配内存块的时候使用的是<code>_crtheap</code>句柄标记的堆。那么<code>_crtheap</code>堆是何时创建的了？</p><p>我们从<code>heapinit.c</code>文件中的<code>_heap_init</code>函数可以看到<code>_crtheap</code>堆的创建过程：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">HANDLE _crtheap=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">*_heap_init() - Initialize the heap</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*Purpose:</span></span><br><span class="line"><span class="comment">*       Setup the initial C library heap.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*       NOTES:</span></span><br><span class="line"><span class="comment">*       (1) This routine should only be called once!</span></span><br><span class="line"><span class="comment">*       (2) This routine must be called before any other heap requests.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*Entry:</span></span><br><span class="line"><span class="comment">*       &lt;void&gt;</span></span><br><span class="line"><span class="comment">*Exit:</span></span><br><span class="line"><span class="comment">*       Returns 1 if successful, 0 otherwise.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*Exceptions:</span></span><br><span class="line"><span class="comment">*       If heap cannot be initialized, the program will be terminated</span></span><br><span class="line"><span class="comment">*       with a fatal runtime error.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __cdecl _heap_init (<span class="type">void</span>)</span><br><span class="line">{</span><br><span class="line">        ULONG HeapType = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Initialize the "big-block" heap first.</span></span><br><span class="line">        <span class="keyword">if</span> ( (_crtheap = HeapCreate(<span class="number">0</span>, BYTES_PER_PAGE, <span class="number">0</span>)) == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">        <span class="comment">// Enable the Low Fragmentation Heap by default on Windows XP and</span></span><br><span class="line">        <span class="comment">// Windows Server 2003.  It's the 8 byte overhead heap, and has</span></span><br><span class="line">        <span class="comment">// generally better performance charateristics than standard heap,</span></span><br><span class="line">        <span class="comment">// particularly for apps that perform lots of small allocations.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOBYTE(GetVersion()) &lt; <span class="number">6</span>)</span><br><span class="line">        {</span><br><span class="line">            HeapSetInformation(_crtheap, HeapCompatibilityInformation,</span><br><span class="line">                               &amp;HeapType, <span class="keyword">sizeof</span>(HeapType));</span><br><span class="line">        }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* _WIN64 */</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从上面的代码，我们可以看到，创建的<code>私有堆</code>句柄存放在一个<code>全局的_crtheap变量</code>中，后面每次调用<code>malloc</code>函数都是从该堆分配内存块。</p><h2 id="四、Win32-堆函数"><a href="#四、Win32-堆函数" class="headerlink" title="四、Win32 堆函数"></a>四、Win32 堆函数</h2><p>我们最常用的 Windows 堆函数如下：</p><ul><li><code>HeapCreate</code>或<code>HeapDestory</code> — 创建或删除一个私有堆</li><li><code>HeapAlloc</code> — 分配一个堆内存块</li><li><code>HeapFree</code> — 释放一个原先由<code>HeapAlloc</code>分配的内存块</li><li><code>HeapReAlloc</code> — 增长或缩减一个已分配的内存块的大小</li><li><code>HeapLock</code>或<code>HeapUnLock</code> — 控制堆操作的内存访问</li><li><code>HeapWalk</code> — 列举一个堆内部的内存项和区域。</li></ul><h2 id="五、Windows-内存管理-API-分层结构"><a href="#五、Windows-内存管理-API-分层结构" class="headerlink" title="五、Windows 内存管理 API 分层结构"></a>五、Windows 内存管理 API 分层结构</h2><p><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-nctx-dui-1.gif"></p><p>从上图可以看到，虚拟内存机制（<code>Virtual Memory</code>）是 windows 内存体系的基础，无论你是使用<code>堆</code>，还是使用<code>内存映射文件</code>，它们的底层都是基于虚拟内存来实现的。</p><p>从上往下，每一层的 API 在内部会依次调用下一层的 API。下图中列举了每层 API 中经常使用的函数：</p><ul><li><strong>CRT Memory Functions：</strong><code>malloc, free, new, delete</code></li><li><strong>Local, Global Memory API: ** <code>LocalAlloc, GlobalAlloc</code> （</strong>这 2 个函数现在不建议使用，注意是为了兼容以前的老代码才保留下来的**）</li><li><strong>Heap Memory API：</strong><code>HeapCreate, HeapAlloc, HeapDestory</code></li><li><strong>Virtual Memory API：</strong><code>VirtualAlloc, VirtualFree</code></li><li><strong>Memory Mapped File API：</strong><code>CreateFileMapping, MapViewOfFile, MapViewOfFileEx, UnMapViewOfFile</code></li></ul><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(4)--内存对齐</title>
      <link href="/post/4245522728.html"/>
      <url>/post/4245522728.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、内存为什么要对齐"><a href="#一、内存为什么要对齐" class="headerlink" title="一、内存为什么要对齐"></a>一、内存为什么要对齐</h2><p>虽然所有的变量都是保存在特定地址的内存中，但最好还是按照内存对齐的要求来存储。这主要出于两个方面的原因考虑：</p><ol><li>平台原因：<br>不是所有的硬件平台(特别是嵌入式系统中使用的低端处理器)都能访问任意地址上的任意数据，某些硬件平台只能访问对齐的地址，否则会出现硬件异常。</li><li>性能原因：<br>如果数据存放在未对齐的内存空间中，则处理器访问变量时需要进行两次内存访问才能完整读取该变量的值，而对齐的内存访问仅需一次访问。</li></ol><span id="more"></span><h2 id="二、内存对齐的规则"><a href="#二、内存对齐的规则" class="headerlink" title="二、内存对齐的规则"></a>二、内存对齐的规则</h2><ol><li><p>对于结构（或联合）的各个成员，第一个成员位于偏移为 0，以后每个数据成员的偏移量必须是<code>#pragma pack指定的数值和结构体(或联合)中最大数据成员长度 这2个数值中较小的一个</code>的倍数。<br>使用伪代码表示： <code>min(#pragma pack, 结构最大数据成员长度) * N</code></p></li><li><p>在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐也按照<code>#pragma pack指定的数值和结构(或联合)最大数据成员长度这2个数值中较小的一个</code>进行。</p></li></ol><blockquote><p>如果没有使用<code>#pragma pack</code>指令来显式的指定内存对齐的字节数，则按照默认字节数来对齐，各个平台的默认对齐规则如下：<code>32位CPU默认按照4字节对齐；64位CPU默认按照8字节对齐。</code></p></blockquote><h2 id="三、-pragma-pack-命令"><a href="#三、-pragma-pack-命令" class="headerlink" title="三、#pragma pack 命令"></a>三、#pragma pack 命令</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(n) <span class="comment">// 使用自定义n字节对齐  n可以为1，2，4，8，16</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()  <span class="comment">// 使用缺省字节对齐</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(show) <span class="comment">// 在编译输出窗口以警告的形式显示出当前的内存以几个字节对齐</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="四、结构体内存对齐示例"><a href="#四、结构体内存对齐示例" class="headerlink" title="四、结构体内存对齐示例"></a>四、结构体内存对齐示例</h2><p>在 64 位系统上编译下面的测试程序，已知在 64 位系统上各类型占用字节数如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char     1字节</span><br><span class="line">short    2字节</span><br><span class="line">int      4字节</span><br><span class="line">long     4字节</span><br><span class="line">double   8字节</span><br><span class="line">long long 8字节</span><br></pre></td></tr></tbody></table></figure><p>示例代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(8)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">  <span class="type">char</span> s[<span class="number">5</span>];</span><br><span class="line">  <span class="type">short</span> c;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">int</span> i = <span class="built_in">sizeof</span>(A);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>按照第二节所讲的内存对齐规则，分析如下：<br>因为结构体中最大的数据成员长度为 int（即 4 字节），而且<code>#pragma pack(8)</code>指令指定按照 8 字节对齐，所以<code>min(4,8) = 4</code>，故我们可以知道结构体 A 按照 4 字节对齐。</p><p>下图是结构体 A 按照 4 字节对齐的内存布局（需要注意的是“内存不是填充在 s5 后面，而是填充在 c 后面”）：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-nctx-ncdq-1.jpg"></p><p>从图我们很容易知道<code>sizeof(A) = 12</code>.</p><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(3)--内存映射文件</title>
      <link href="/post/3938269003.html"/>
      <url>/post/3938269003.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、为什么需要内存映射"><a href="#一、为什么需要内存映射" class="headerlink" title="一、为什么需要内存映射"></a>一、为什么需要内存映射</h1><p><code>“内存映射文件”</code>可以将硬盘上的文件映射到<code>虚拟地址空间</code>，这样就不需要将所有东西都放入到页交换文件中，比如系统有许多程序同时运行时，如果将这些程序文件都加载到页交换文件中，<code>页交换文件</code>将会变得非常大。事实上，Windows 也并没有将硬盘上的程序文件复制到<code>页交换文件</code>中，因为这样不仅会让<code>页交换文件</code>将会变得非常大，也会浪费很多时间，特别是可执行程序非常大的时候。</p><p>当用户要求执行一个应用程序时，系统会打开该应用程序的<code>.exe</code>文件，并计算出应用程序的代码和数据的大小，然后系统会在进程的虚拟地址空间预定一块地址空间，并注明与该区域相关联的物理存储器就是<code>.exe</code>文件本身。</p><p>当把一个位于硬盘上的文件（可以是<code>.exe</code>，<code>.dll</code>也可以是普通文件）映像用作地址空间区域对应的物理存储器时，我们称这个文件映像为<code>“内存映射文件”</code>。</p><span id="more"></span><p>现在我们可以对<a href="/post/595856315.html" title="Windows内存体系(2)--虚拟内存">Windows内存体系(2)--虚拟内存</a>第 2 节的图进行完善了，加入“内存映射文件”部分：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-nctx-ncys-1.png"></p><h1 id="二、内存映射文件技术介绍"><a href="#二、内存映射文件技术介绍" class="headerlink" title="二、内存映射文件技术介绍"></a>二、内存映射文件技术介绍</h1><p>常用的有 Win32 API 的<code>CreateFile()</code>、<code>WriteFile()</code>、<code>ReadFile()</code>和 MFC 提供的<code>CFile</code>类都可以实现文件的读写操作。一般来说，以上这些函数可以满足大多数场合的要求，但是对于某些特殊应用领域所需要的动辄几十 GB、几百 GB、乃至几 TB 的海量存储，此时在以平常的文件处理方法进行处理显然是行不通的（效率低下，而且内存没那么大）。目前，对于这种大文件的操作一般是以内存映射文件的方式来加以处理的。</p><p>内存映射文件也是 Windows 的一种内存管理方法，提供了一个统一的内存管理特征，使应用程序可以通过内存指针对磁盘上的文件进行访问。通过文件映射将磁盘文件内容（全部或者部分）与进程虚拟地址空间的某个区域建立映射关联，可以直接对被映射的文件进行访问，而不必执行文件 I/O 操作也无需对文件内容进行缓冲处理。内存文件映射的这种特性是非常适合于用来管理大尺寸文件的。</p><h1 id="三、大文件读写实例"><a href="#三、大文件读写实例" class="headerlink" title="三、大文件读写实例"></a>三、大文件读写实例</h1><p>通过 C++调用系统 API 实现文件映射的步骤大致如下：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-nctx-ncys-2.jpg"></p><p>本示例首先在<code>D:\</code>生成一个大小为 1GB 的<code>BigFile.data</code>文件，然后使用内存映射技术将该文件内全部填充字符 A，随后读取其中的<code>第20000~20100字节</code>，并将这些字节修改为字符 B，然后再次读取已验证是否修改成功。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>{</span><br><span class="line">  HANDLE file_ = <span class="built_in">CreateFile</span>(<span class="built_in">TEXT</span>(<span class="string">"D:\\BigFile.data"</span>),</span><br><span class="line">    GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    OPEN_ALWAYS,</span><br><span class="line">    FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">    <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (file_ == INVALID_HANDLE_VALUE) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"CreateFile failed, GLE:%d\n"</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  LARGE_INTEGER filesize;</span><br><span class="line">  filesize.QuadPart = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 1GB</span></span><br><span class="line"></span><br><span class="line">  HANDLE mapping_ = <span class="built_in">CreateFileMapping</span>(file_, <span class="literal">NULL</span>, PAGE_READWRITE, filesize.HighPart, filesize.LowPart, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (mapping_ == <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"CreateFileMapping failed, GLE:%d\n"</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  LARGE_INTEGER offset;</span><br><span class="line">  offset.QuadPart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  LPVOID mapping_addr = <span class="built_in">MapViewOfFile</span>(mapping_, FILE_MAP_WRITE | FILE_MAP_READ, offset.HighPart, offset.LowPart, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (mapping_addr == <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"MapViewOfFile failed, GLE:%d\n"</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向文件中填充1GB的字符'A'</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) {</span><br><span class="line">    buf[i] = <span class="string">'A'</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次填充1024字节，填充1024*1024次</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">long</span> l = <span class="number">0</span>; l &lt; <span class="number">1024</span> * <span class="number">1024</span>; l++) {</span><br><span class="line">    <span class="built_in">memcpy</span>((LPVOID)((<span class="type">long</span>)mapping_addr + l * <span class="number">1024</span>), buf, <span class="number">1024</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 填充完毕</span></span><br><span class="line">  <span class="comment">// 读取第20000~20100字节，共100字节</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">char</span> read_content[<span class="number">101</span>] = { <span class="number">0</span> };</span><br><span class="line">  <span class="built_in">memcpy</span>(read_content, (LPVOID)((<span class="type">long</span>)mapping_addr + <span class="number">20000</span>), <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, read_content);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将第20000~20100字节，共100字节全部修改为字符'B'</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">char</span> write_content[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">    write_content[i] = <span class="string">'B'</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>((LPVOID)((<span class="type">long</span>)mapping_addr + <span class="number">20000</span>), write_content, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再次读取第20000~20100字节，共100字节，验证修改是成功</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="built_in">memcpy</span>(read_content, (LPVOID)((<span class="type">long</span>)mapping_addr + <span class="number">20000</span>), <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, read_content);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">UnmapViewOfFile</span>(mapping_addr);</span><br><span class="line">  <span class="built_in">CloseHandle</span>(mapping_);</span><br><span class="line">  <span class="built_in">CloseHandle</span>(file_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">Test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(2)--虚拟内存</title>
      <link href="/post/595856315.html"/>
      <url>/post/595856315.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、页交换文件"><a href="#一、页交换文件" class="headerlink" title="一、页交换文件"></a>一、页交换文件</h2><p><code>虚拟地址空间</code>只是操作系统为进程“虚拟”出来的一块地址区域，并不代表任何实际的空间。而<code>“页交换文件”</code>却对应了实际的空间，这个空间一般是磁盘上名为<code>“pagefile.sys”</code>的文件。</p><p><code>“页交换文件”</code>的大小和位置可以在系统设置（<code>系统属性 -&gt; 高级 -&gt; 性能 -&gt; 设置 -&gt; 高级</code> ）中进行设置：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-nctx-xnnc-1.jpg"></p><p>从微软的官方文档来看，<code>“虚拟内存”</code>等于<code>“物理内存”+“分页文件”</code>总和。可以把<code>“虚拟内存”</code>理解为 Windows 的一种内存管理机制。</p><span id="more"></span><h2 id="二、虚拟地址空间、页交换文件、物理内存"><a href="#二、虚拟地址空间、页交换文件、物理内存" class="headerlink" title="二、虚拟地址空间、页交换文件、物理内存"></a>二、虚拟地址空间、页交换文件、物理内存</h2><p>虚拟地址空间、页交换文件、物理内存三者的关系如下图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-nctx-xnnc-2.jpg"></p><p>《Windows 核心编程》第 13 章关于“物理存储器和页交换文件”章节中讲到了“页交换文件、物理存储器之间的数据交换过程”，流程如下：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-nctx-xnnc-3.jpg"></p><p>应用程序从进程的虚拟地址空间<code>预定并调拨</code>了一块地址区域时，起初这块区域只是从“页交换文件”中调拨的，这样作有个好处就是：因为还不确定何时才会使用这块区域，如果立即从物理内存调拨，会将占用很多的物理内存。<br>当程序读写该地址区域时，此时就会出现上面图上的页交换文件和物理内存之间的数据交换过程。</p><h2 id="三、将页面锁定在物理内存"><a href="#三、将页面锁定在物理内存" class="headerlink" title="三、将页面锁定在物理内存"></a>三、将页面锁定在物理内存</h2><p>从上面的几节我们知道，当物理内存中没有闲置页面时，系统会将内存中的某些页面的数据写入到交换文件中，从而将该物理内存区域释放出来供后面的程序使用。</p><p>我们可以通过调用<code>VirtualLock</code>方法，将页面锁定在物理内存中，从而防止虚拟内存管理机制将页面交换至页面文件，而引起不必要的硬盘和物理内存之间的低效页面交换。</p><p>也可以通过调用<code>VirtualUnlock</code>方法解锁页面，允许系统对页面进行交换操作。</p><p>需要注意的是，锁定页面时系统会根据当前可用实际物理内存情况，以及进程工作集配额判定当前最大可锁定的页面的实际数量，超过此数量会引起一个错误。我们可以调用<code>SetProcessWorkingSetSize</code>可以改变一个进程工作集大小的配额，从而可以锁定更多的物理页面。</p><h2 id="四、虚拟内存使用实例"><a href="#四、虚拟内存使用实例" class="headerlink" title="四、虚拟内存使用实例"></a>四、虚拟内存使用实例</h2><p>虚拟内存方面的 API 属于页面粒度 API，通过这些 API 分配的内存的最小粒度是<code>64KB</code>。这些 API 分配（调拨）的内存区域最初都是位于<code>“页交换文件”</code>上面，当程序对该区域的某些“页面”（<strong>对虚拟内存的管理以页面为单位进行的</strong>）进行读写时，才会将这些页面交换到物理内存上面。</p><p>从<a href="/post/2494475058.html" title="Windows内存体系(1)--虚拟地址空间">Windows内存体系(1)--虚拟地址空间</a>中我们知道虚拟地址空间要经过<code>预定</code>和<code>调拨</code>2 个步骤之后才能使用，这 2 个步骤都可以通过<code>VirtualAlloc</code>函数实现：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">VirtualAlloc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD flAllocationType,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD flProtect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>当预定或者调拨的空间我们不在需要时，我们需要调用<code>VirtualFree</code>来释放该地址空间：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">VirtualFree</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwFreeType</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>下面是的示例演示了在预定、调拨、使用等操作前后，进程的各项内存的占用情况：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  SIZE_T size = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 1GB</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 预定1GB的空间</span></span><br><span class="line">  <span class="type">char</span> *pVirtualAddress = (<span class="type">char</span> *)<span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, size, MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">  <span class="keyword">if</span> (pVirtualAddress == <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Reserve 1GB failed.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证分配粒度是不是64KB</span></span><br><span class="line">  <span class="type">int</span> n = (<span class="type">long</span>)pVirtualAddress % (<span class="number">64</span>*<span class="number">1024</span>);</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"分配粒度为64K\n"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"已经预定1GB\n"</span>);</span><br><span class="line">  <span class="built_in">getchar</span>(); <span class="comment">// 暂停</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">VirtualAlloc</span>(pVirtualAddress, size, MEM_COMMIT, PAGE_READWRITE) == <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Commit 1GB failed.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"已经调拨1GB\n"</span>);</span><br><span class="line">  <span class="built_in">getchar</span>(); <span class="comment">// 暂停</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 页面大小为4K，访问2560个页面，即2560*4K = 10MB</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2560</span>; i++) {</span><br><span class="line">    <span class="type">char</span> * p = pVirtualAddress + i * (<span class="number">4</span> * <span class="number">1024</span>);</span><br><span class="line">    *p = <span class="string">'A'</span>; <span class="comment">// 只访问每个页面的第一个字节</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"已经使用前10MB\n"</span>);</span><br><span class="line">  <span class="built_in">getchar</span>(); <span class="comment">// 暂停</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在程序运行各个阶段进程的内存情况如下图：（“内存专用工作集”表示占用的物理内存的大小，“提交大小”表示调拨的页交换文件的大小）</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-nctx-xnnc-4.png"></p><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(1)--虚拟地址空间</title>
      <link href="/post/2494475058.html"/>
      <url>/post/2494475058.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、实模式下内存分配机制"><a href="#一、实模式下内存分配机制" class="headerlink" title="一、实模式下内存分配机制"></a>一、实模式下内存分配机制</h2><p>在 8086 或者 80186 以前，程序运行时，操作系统会把程序全都装入内存，程序都是直接运行在物理内存上的。也就是说程序中访问的内存地址都是实际的物理内存地址。当计算机同时运行多个程序时，必须保证这些程序用到的内存总量要小于计算机实际物理内存的大小。</p><p>例如某台计算机总的内存大小是<code>128M</code> ，现在同时运行两个程序 A 和 B ，A 需占用内存<code>10M</code> ， B 需占用内存<code>110M</code> 。计算机在给程序分配内存时会采取这样的方法：先将内存中的前<code>10M</code>分配给程序 A ，接着再从内存中剩余的<code>118M</code>中划分出 <code>110M</code>分配给程序 B 。这种分配方法虽然可以保证程序 A 和程序 B 都能运行，但是这种简单的内存分配策略会导致很多问题：</p><span id="more"></span><ul><li><p>问题 1 ：进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意但有 bug 的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。这种情况对用户来说是无法容忍的，因为用户希望使用计算机的时候，其中一个任务失败了，不能影响其它的任务。</p></li><li><p>问题 2 ：内存使用效率低。在 A 和 B 都运行的情况下，如果用户又运行了程序 C ，而程序 C 需要 20M 大小的内存才能运行，而此时系统只剩下 8M 的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序 C 使用，然后再将程序 C 的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。</p></li><li><p>问题 3 ：程序运行的地址不确定。当内存中的剩余空间可以满足程序 C 的要求后，操作系统会在剩余空间中随机分配一段连续的 20M 大小的空间给程序 C 使用，因为是随机分配的，所以程序运行的地址是不确定的。</p></li></ul><hr><h2 id="二、虚拟地址空间介绍"><a href="#二、虚拟地址空间介绍" class="headerlink" title="二、虚拟地址空间介绍"></a>二、虚拟地址空间介绍</h2><p>操作系统让每个进程都有自己的虚拟地址空间（<code>Virtual Address Space</code>，简称<code>VAS</code>）。以 32 位进程为例，每个进程都有<code>0x00000000 ~ 0xFFFFFFFF</code>(4GB)的虚拟地址空间，所以每个进程都可能分配到<code>0x123456</code>地址的内存，但这个地址不能在进程间相互访问。</p><p>因为这些都是“虚拟”的地址空间，这些“地址”都不能直接使用，CPU 在寻址的时候虽然是按照虚拟地址来寻址的，但是还要通过<code>MMU</code>(内存管理单元)来将虚拟地址转换为物理存储器（如内存等）上的物理地址：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-nctx-1.jpg"></p><p>从图上可以看出，进程 A 和 B 虽然都有地址<code>0x123456</code>，但它们分别对应的物理地址不一样。</p><hr><p>##三、虚拟地址空间分区<br>进程的虚拟地址空间虽然很大，但是它被划分成了很多分区，供 Ring3 层应用程序使用的用户模式分区并不大（一半不到），如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windows-nctx-2.jpg"></p><h3 id="3-1-空指针赋值分区"><a href="#3-1-空指针赋值分区" class="headerlink" title="3.1 空指针赋值分区"></a>3.1 空指针赋值分区</h3><p>这一分区的进程地址空间的范围为：[<code>0x00000000</code>, <code>0x0000FFFF</code>]，总大小为<code>64K</code>，保留该分区的目的是为了帮助应用程序员捕获对空指针的赋值。如<code>malloc</code>分配内存失败，就会返回<code>NULL</code>。</p><p>如果进程中的线程试图访问该分区内的内存地址，就会引发访问违规。</p><h3 id="3-2-用户模式分区"><a href="#3-2-用户模式分区" class="headerlink" title="3.2 用户模式分区"></a>3.2 用户模式分区</h3><p>在 Windows 中，所有的 exe 和动态链接库都载入到这一区域。系统同时会把该进程可以访问的所有内存映射文件（后面会介绍）映射到这一分区。</p><p>进程无法通过指针来读取、写入、访问其他进程的这一分区，因此一个应用程序破坏另一个应用程序的可能性就非常小了，从而使整个系统更加坚固。</p><h3 id="3-3-内核模式分区"><a href="#3-3-内核模式分区" class="headerlink" title="3.3 内核模式分区"></a>3.3 内核模式分区</h3><p>内核模式分区是操作系统代码的驻地。与线程调度、内存管理、文件系统支持、网络支持以及设备驱动程序相关的代码都会载入到这一分区。该分区内的代码和数据被完全的保护起来了，如果一个应用程序试图读取或写入位于这一分区的内存地址，会引发访问违规。</p><p>驻留在这一分区内的代码为所有进程共有。</p><h2 id="四、虚拟地址空间的使用"><a href="#四、虚拟地址空间的使用" class="headerlink" title="四、虚拟地址空间的使用"></a>四、虚拟地址空间的使用</h2><p>虚拟地址空间的使用涉及到 3 个概念：<code>页面大小</code>、<code>分配粒度</code>、<code>预定和调拨</code>。</p><h3 id="4-1-页面大小"><a href="#4-1-页面大小" class="headerlink" title="4.1 页面大小"></a>4.1 页面大小</h3><p>虚拟地址空间被分成以<code>“页面”</code>为单位，因为硬件内存管理单元是以<code>页面</code>为粒度将虚拟地址转译成物理地址的。<code>页面</code>的大小根据不同的 CPU 不而有所不同。x86 和 x64 系统使用的<code>页面</code>大小都是<code>4KB</code>，而 IA-64 系统使用的<code>页面</code>大小是<code>8KB</code>。</p><blockquote><p>IA-64 操作系统只能在 INTEL 安腾系列处理器及 AMD 部分服务器处理器运行，所以主流市场并不常见</p></blockquote><p>当<strong>应用程序</strong>在虚拟地址空间分配空间时，系统需要确保分配区域的大小正好是系统<code>页面</code>大小的整数倍。</p><h3 id="4-2-分配粒度"><a href="#4-2-分配粒度" class="headerlink" title="4.2 分配粒度"></a>4.2 分配粒度</h3><p>当<strong>应用程序</strong>在从虚拟地址空间分配空间时，系统会确保所有分配区域的起始地址都是<code>分配粒度</code>的整数倍。<code>分配粒度</code>的会根据不同的 CPU 平台而有所不同，但目前所有的 CPU 平台的分配粒度都是使用<code>64KB</code>。也就是说，<code>分配的起始地址 = 64 * N</code>。</p><p>通过 Windows 的<code>GetSystemInfo</code>函数也可以获得此分配粒度值。</p><blockquote><p>上面所说的<code>分配粒度</code>和<code>页面大小</code>的限制，只是针对于<code>“应用程序”</code>，系统内核自己不存在这样的限制。</p></blockquote><h3 id="4-3-预定和调拨"><a href="#4-3-预定和调拨" class="headerlink" title="4.3 预定和调拨"></a>4.3 预定和调拨</h3><p>虚拟地址空间的使用分为 2 个步骤：</p><ol><li><p>预定（reserve）：告诉系统我们要从虚拟地址空间<code>预定</code>哪一块区域，系统为我们保留这一块区域。预定的局域的起始地址和大小遵循上面介绍的<code>分配粒度</code>和<code>页面大小</code>的要求。因为预定的只是虚拟地址空间，不占用任何其他物理存储器，所以没有形成实质的开销。</p></li><li><p>调拨（commit）：预定的区域还不能使用，我们还需要为<code>预定</code>的区域从<code>页交换文件</code>中<code>调拨</code>存储器，<code>调拨</code>之后我们才能使用该区域。<br>至于为什么要从<code>页交换文件</code>中调拨存储器？ <code>页交换文件</code>如何与物理内存之间交互？在下一篇文章<a href="/post/595856315.html" title="Windows内存体系(2)--虚拟内存">Windows内存体系(2)--虚拟内存</a>中会详细介绍。</p></li></ol><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初识WebRTC</title>
      <link href="/post/3298681169.html"/>
      <url>/post/3298681169.html</url>
      
        <content type="html"><![CDATA[<p>WebRTC （Web Real-Time Communications） 是一项实时通讯技术，它允许网络应用或者站点在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。</p><p>它并不是单一的协议，包含了媒体、加密、传输层等在内的多个协议标准以及一套基于 JavaScript 的 API。通过简单易用的 JavaScript API ，在不安装任何插件的情况下，让浏览器拥有了 P2P音视频和数据分享的能力。同时WebRTC 并不是一个孤立的协议，它拥有灵活的信令，可以便捷的对接现有的SIP 和电话网络的系统。</p><p>不同技术领域的人都可以从WebRTC中获取到需要的东西。</p><span id="more"></span><h2 id="一-支持的浏览器和平台"><a href="#一-支持的浏览器和平台" class="headerlink" title="一. 支持的浏览器和平台"></a>一. 支持的浏览器和平台</h2><p>目前基本上所有的浏览器都已经支持WebRTC</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/chushi-webrtc-1.png"></p><h2 id="二-WebRTC-内部结构"><a href="#二-WebRTC-内部结构" class="headerlink" title="二. WebRTC 内部结构"></a>二. WebRTC 内部结构</h2><p><img src="https://blog-static.jiangxueqiao.com/blog/img/chushi-webrtc-2.png"></p><p>架构图颜色标识说明：</p><ul><li>紫色部分是Web开发者API层</li><li>蓝色实线部分是面向浏览器厂商的API层</li><li>蓝色虚线部分浏览器厂商可以自定义实现</li></ul><p>WebRTC有三个模块：</p><ul><li><p>Voice Engine（音频引擎）  </p><ul><li>Voice Engine包含iSAC/iLBC Codec（音频编解码器，前者是针对宽带和超宽带，后者是针对窄带）  </li><li>NetEQ for voice（处理网络抖动和语音包丢失）  </li><li>Echo Canceler（回声消除器）/ Noise Reduction（噪声抑制）</li></ul></li><li><p>Video Engine（视频引擎）  </p><ul><li>VP8 Codec（视频图像编解码器）  </li><li>Video jitter buffer（视频抖动缓冲器，处理视频抖动和视频信息包丢失）  </li><li>Image enhancements（图像质量增强）</li></ul></li><li><p>Transport   </p><ul><li>SRTP（安全的实时传输协议，用以音视频流传输）  </li><li>Multiplexing（多路复用）  </li><li>P2P，STUN+TURN+ICE（用于NAT网络和防火墙穿越的）  </li><li>除此之外，安全传输可能还会用到DTLS（数据报安全传输），用于加密传输和密钥协商   </li><li>整个WebRTC通信是基于UDP的</li></ul></li></ul><h2 id="三-WebRTC-的核心组件"><a href="#三-WebRTC-的核心组件" class="headerlink" title="三. WebRTC 的核心组件"></a>三. WebRTC 的核心组件</h2><ul><li><p>音视频引擎：OPUS、VP8 / VP9、H264</p></li><li><p>传输层协议：底层传输协议为 UDP</p></li><li><p>媒体协议：SRTP / SRTCP</p></li><li><p>数据协议：DTLS / SCTP</p></li><li><p>P2P 内网穿透：STUN / TURN / ICE / Trickle ICE</p></li><li><p>信令与 SDP 协商：HTTP / WebSocket / SIP、 Offer / Answer 模型</p></li></ul><h2 id="四-WebRTC-音频和视频引擎"><a href="#四-WebRTC-音频和视频引擎" class="headerlink" title="四. WebRTC 音频和视频引擎"></a>四. WebRTC 音频和视频引擎</h2><p><img src="https://blog-static.jiangxueqiao.com/blog/img/chushi-webrtc-3.png"></p><ul><li><p>最底层是硬件设备，上面是音频捕获模块和视频捕获模块</p></li><li><p>中间部分为音视频引擎。音频引擎负责音频采集和传输，具有降噪、回声消除等功能。视频引擎负责网络抖动优化，互联网传输编解码优化</p></li><li><p>在音视频引擎之上是 一套 C++ API，在 C++ 的 API 之上是提供给浏览器的Javascript API.</p></li></ul><h2 id="五-WebRTC-协议栈"><a href="#五-WebRTC-协议栈" class="headerlink" title="五. WebRTC 协议栈"></a>五. WebRTC 协议栈</h2><p><img src="https://blog-static.jiangxueqiao.com/blog/img/chushi-webrtc-4.png"></p><ul><li><p>WebRTC 核心的协议都是在右侧基于 UDP 基础上搭建起来的。</p></li><li><p>其中，<code>ICE、STUN、TURN</code> 用于内网穿透。</p></li><li><p>DTLS 用于对传输内容进行加密，可以看做是 UDP 版的 TLS。由于 WebRTC 对安全比较重视，所以这一层是必须的。所有WebRTC组件都必须加密，并且其JavaScript API只能用于安全源（HTTPS或本地主机）。信令机制并不是由WebRTC标准定义的，所以您必须确保使用安全协议。  </p></li><li><p>SRTP 与 SRTCP 是对媒体数据的封装与传输控制协议  </p></li><li><p>SCTP 是流控制传输协议，提供类似 TCP 的特性，SCTP 可以基于 UDP 上构建，在 WebRTC 里是在 DTLS 协议之上。</p></li><li><p>RTCPeerConnection 用来建立和维护端到端连接，并提供高效的音视频流传输。</p></li><li><p>RTCDataChannel 用来支持端到端的任意二进制数据传输。</p></li><li><p>WebRTC 协议栈解释  </p><ul><li>ICE，STUN，TURN：用于NAT穿透，参考 <a href="/post/2114040426.html" title="WebRTC的三种架构">WebRTC的三种架构</a></li><li>SDP：会话描述协议（RFC 4566）  </li><li>DTLS：数据报传输层安全性（RFC 6347）  </li><li>SCTP：流控制传输协议（RFC 4960）  </li><li>SRTP：安全实时传输协议（RFC 3711）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> ⑤ 音视频编程 </category>
          
          <category> WebRTC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SDP格式解析</title>
      <link href="/post/2172509399.html"/>
      <url>/post/2172509399.html</url>
      
        <content type="html"><![CDATA[<p>会话描述协议（Session Description Protocol 或简写 SDP）描述的是流媒体的初始化参数。此协议由 IETF 发表为 RFC 2327。</p><p>SDP 完全是一种会话描述格式，它不属于传输协议。</p><p>SDP 用于描述多媒体通信会话，包括会话建立、会话请求和参数协商。SDP 不用于传输媒体数据，只能用于两个通信终端的参数协商，包括媒体类型、格式以及所有其他和会话相关的属性。SDP 以字符串的形式描述上述初始化参数。</p><span id="more"></span><h1 id="一、SDP-组成"><a href="#一、SDP-组成" class="headerlink" title="一、SDP 组成"></a>一、SDP 组成</h1><p>SDP 是由多行文本组成的一个纯文本协议，如果将<code>SDP</code>从语义上分解成不同组件来描述一个多媒体会话信息，那么<code>SDP</code>由以下部分组成：</p><ul><li>会话信息</li><li>网络信息</li><li>媒体信息</li><li>安全信息</li><li>服务质量和分组信息</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                                                +---------------------+</span><br><span class="line">                                                |        v=           |</span><br><span class="line">                                                +---------------------+</span><br><span class="line">                +---------------------+         +---------------------+</span><br><span class="line">        ====    |   Session Metadata  |  =====  |        o=           |</span><br><span class="line">        |       +---------------------+         +----------------------</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |        t=           |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |        c=           |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |       +---------------------+</span><br><span class="line">        ====    | Network Description |   =====</span><br><span class="line">        |       +---------------------+</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |    a=candidate      |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |        m=           |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |        +---------------------+        +---------------------+</span><br><span class="line">        ====     | Stream Description  |  ===== |      a=rtpmap       |</span><br><span class="line">        |        +---------------------+        +----------------------</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |      a=fmtp         |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |      a=sendrecv..   |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">+---------------+</span><br><span class="line">|    SEMANTIC   |</span><br><span class="line">| COMPONENTS OF |</span><br><span class="line">|     SDP       |</span><br><span class="line">+---------------+</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |      a=crypto       |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |         +---------------------+       +---------------------+</span><br><span class="line">        ====      |Security Descriptions|  =====|      a=ice-frag     |</span><br><span class="line">        |         +---------------------+       +----------------------</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |      a=ice-pwd      |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |     a=fingerprint   |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |      a=rtcp-fb      |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |         +---------------------+       +---------------------+</span><br><span class="line">        ====      |   Qos,Grouping      |       |                     |</span><br><span class="line">                  |   Descriptions      |  =====|       a=group       |</span><br><span class="line">                  +---------------------+       +----------------------</span><br><span class="line">                                                +---------------------+</span><br><span class="line">                                                |       a=rtcpmux     |</span><br><span class="line">                                                +---------------------+</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="二、SDP-格式"><a href="#二、SDP-格式" class="headerlink" title="二、SDP 格式"></a>二、SDP 格式</h1><p>SDP 由多行组成，每行的的格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;=&lt;value&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li><code>&lt;type&gt;</code>: 区分大小写，代表特定的属性，例如<code>v</code>代表 SDP 版本。</li><li><code>&lt;value&gt;</code>：UTF8 编码的文本，具体格式与<type>类型有关。</type></li><li><code>=</code>两边不允许存在空格。</li><li><code>=*</code>表示该项是可选的。</li></ul><p>下面是 WebRTC（<strong>branch_76</strong>）的一个真实 SDP 样本:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">// -------------------------------- 【Session Metadata部分】 --------------------------------</span><br><span class="line"></span><br><span class="line">// sdp版本号</span><br><span class="line">v=0</span><br><span class="line"></span><br><span class="line">// o=&lt;username&gt; &lt;sess-id&gt; &lt;sess-version&gt; &lt;nettype&gt; &lt;addrtype&gt; &lt;unicast-address&gt;</span><br><span class="line">// username如何没有使用-代替，3967017503571418851是整个会话的编号，2代表会话版本，如果在会话过程中有改变编码之类的操作，重新生成sdp时,sess-id不变，sess-version加1</span><br><span class="line">o=- 3967017503571418851 2 IN IP4 127.0.0.1</span><br><span class="line"></span><br><span class="line">//会话名</span><br><span class="line">s=-</span><br><span class="line"></span><br><span class="line">// 会话的起始时间和结束时间，0代表没有限制</span><br><span class="line">t=0 0</span><br><span class="line"></span><br><span class="line">// 表示需要共用一个传输通道传输的媒体，通过ssrc进行区分不同的流。如果没有这一行，音视频数据就会分别用单独udp端口来发送.</span><br><span class="line">a=group:BUNDLE audio video</span><br><span class="line"></span><br><span class="line">// WMS是WebRTC Media Stream简称;</span><br><span class="line">// 这一行定义了本客户端支持同时传输多个流，一个流可以包括多个track.</span><br><span class="line">// 一般定义了这个，后面a=ssrc这一行就会有msid,mslabel等属性.</span><br><span class="line">a=msid-semantic: WMS stream_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// -------------------------------- 【Stream Description部分】 --------------------------------</span><br><span class="line"></span><br><span class="line">// ------------ audio部分 -------------</span><br><span class="line"></span><br><span class="line">// m意味着它是一个媒体行.</span><br><span class="line">// m=audio说明本会话包含音频，9代表音频使用端口9来传输，但是在webrtc中现在一般不使用，如果设置为0，代表不传输音频,</span><br><span class="line">// UDP/TLS/RTP/SAVPF是表示用户支持来传输音频的协议，udp,tls,rtp代表使用udp来传输rtp包，并使用tls加密</span><br><span class="line">// SAVPF代表使用srtcp的反馈机制来控制通信过程</span><br><span class="line">// 后面的111 103 104 9 102 0 8 106 105 13 110 112 113 126表示本会话音频支持的编码，后面几行会有详细补充说明.</span><br><span class="line">m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 102 0 8 106 105 13 110 112 113 126</span><br><span class="line"></span><br><span class="line">// 表示你要用来接收或者发送音频使用的IP地址.</span><br><span class="line">// webrtc使用ice传输，不使用这个地址</span><br><span class="line">c=IN IP4 0.0.0.0</span><br><span class="line"></span><br><span class="line">// 用来传输rtcp的地址和端口，webrtc中不使用</span><br><span class="line">a=rtcp:9 IN IP4 0.0.0.0</span><br><span class="line"></span><br><span class="line">// 下面2行是ice协商过程中的安全验证信息</span><br><span class="line">a=ice-ufrag:kSq0</span><br><span class="line">a=ice-pwd:pWLGrCTwFNq6rm249ZEasHPY</span><br><span class="line"></span><br><span class="line">// 通知对端支持trickle，即sdp里面描述媒体信息和ice候选项的信息可以分开传输</span><br><span class="line">a=ice-options:trickle</span><br><span class="line"></span><br><span class="line">// dtls协商过程中需要的认证信息</span><br><span class="line">a=fingerprint:sha-256 A0:D6:B2:63:1B:69:0E:91:01:C3:88:A9:92:6F:E7:EF:5B:36:52:66:08:DF:94:A0:FE:0C:C9:06:BF:2C:38:A2</span><br><span class="line"></span><br><span class="line">// 代表本客户端在dtls协商过程中，可以做客户端也可以做服务端, 参考rfc4145 rfc4572</span><br><span class="line">a=setup:actpass</span><br><span class="line"></span><br><span class="line">// 前面BUNDLE行中用到的媒体标识</span><br><span class="line">a=mid:audio</span><br><span class="line"></span><br><span class="line">// 指出要在rtp头部中加入音量信息，参考 rfc6464</span><br><span class="line">a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level</span><br><span class="line"></span><br><span class="line">// 指出是双向通信，另外几种类型是recvonly,sendonly,inactive</span><br><span class="line">a=sendrecv</span><br><span class="line"></span><br><span class="line">// 指出rtp,rtcp包使用同一个端口来传输</span><br><span class="line">a=rtcp-mux</span><br><span class="line"></span><br><span class="line">// 下面十几行都是对m=audio这一行的媒体编码补充说明，指出了编码采用的编号，采样率，声道等</span><br><span class="line">a=rtpmap:111 opus/48000/2</span><br><span class="line">a=rtcp-fb:111 transport-cc</span><br><span class="line">// 下面一行对opus编码可选的补充说明,minptime代表最小打包时长是10ms，useinbandfec=1代表使用opus编码内置fec特性</span><br><span class="line">a=fmtp:111 minptime=10;useinbandfec=1</span><br><span class="line">a=rtpmap:103 ISAC/16000</span><br><span class="line">a=rtpmap:104 ISAC/32000</span><br><span class="line">a=rtpmap:9 G722/8000</span><br><span class="line">a=rtpmap:102 ILBC/8000</span><br><span class="line">a=rtpmap:0 PCMU/8000</span><br><span class="line">a=rtpmap:8 PCMA/8000</span><br><span class="line">a=rtpmap:106 CN/32000</span><br><span class="line">a=rtpmap:105 CN/16000</span><br><span class="line">a=rtpmap:13 CN/8000</span><br><span class="line">a=rtpmap:110 telephone-event/48000</span><br><span class="line">a=rtpmap:112 telephone-event/32000</span><br><span class="line">a=rtpmap:113 telephone-event/16000</span><br><span class="line">a=rtpmap:126 telephone-event/8000</span><br><span class="line">// cname用来标识一个数据源，ssrc当发生冲突时可能会发生变化，但是cname不会发生变化，也会出现在rtcp包中SDEC中，用于音视频同步</span><br><span class="line">a=ssrc:2603526440 cname:AyMDWB+q6ApWdpfU</span><br><span class="line">a=ssrc:2603526440 msid:stream_id audio_label</span><br><span class="line">a=ssrc:2603526440 mslabel:stream_id</span><br><span class="line">a=ssrc:2603526440 label:audio_label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// ------------ video部分 -------------</span><br><span class="line"></span><br><span class="line">m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 127</span><br><span class="line">c=IN IP4 0.0.0.0</span><br><span class="line">a=rtcp:9 IN IP4 0.0.0.0</span><br><span class="line">a=ice-ufrag:kSq0</span><br><span class="line">a=ice-pwd:pWLGrCTwFNq6rm249ZEasHPY</span><br><span class="line">a=ice-options:trickle</span><br><span class="line">a=fingerprint:sha-256 A0:D6:B2:63:1B:69:0E:91:01:C3:88:A9:92:6F:E7:EF:5B:36:52:66:08:DF:94:A0:FE:0C:C9:06:BF:2C:38:A2</span><br><span class="line">a=setup:actpass</span><br><span class="line">a=mid:video</span><br><span class="line">a=extmap:2 urn:ietf:params:rtp-hdrext:toffset</span><br><span class="line">a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time</span><br><span class="line">a=extmap:4 urn:3gpp:video-orientation</span><br><span class="line">a=extmap:5 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01</span><br><span class="line">a=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/playout-delay</span><br><span class="line">a=extmap:7 http://www.webrtc.org/experiments/rtp-hdrext/video-content-type</span><br><span class="line">a=extmap:8 http://www.webrtc.org/experiments/rtp-hdrext/video-timing</span><br><span class="line">a=sendrecv</span><br><span class="line">a=rtcp-mux</span><br><span class="line">a=rtcp-rsize</span><br><span class="line">a=rtpmap:96 VP8/90000</span><br><span class="line">a=rtcp-fb:96 goog-remb</span><br><span class="line">a=rtcp-fb:96 transport-cc</span><br><span class="line">a=rtcp-fb:96 ccm fir</span><br><span class="line">a=rtcp-fb:96 nack</span><br><span class="line">a=rtcp-fb:96 nack pli</span><br><span class="line">a=rtpmap:97 rtx/90000</span><br><span class="line">a=fmtp:97 apt=96</span><br><span class="line">a=rtpmap:98 VP9/90000</span><br><span class="line">a=rtcp-fb:98 goog-remb</span><br><span class="line">a=rtcp-fb:98 transport-cc</span><br><span class="line">a=rtcp-fb:98 ccm fir</span><br><span class="line">a=rtcp-fb:98 nack</span><br><span class="line">a=rtcp-fb:98 nack pli</span><br><span class="line">a=rtpmap:99 rtx/90000</span><br><span class="line">a=fmtp:99 apt=98</span><br><span class="line">a=rtpmap:100 red/90000</span><br><span class="line">a=rtpmap:101 rtx/90000</span><br><span class="line">a=fmtp:101 apt=100</span><br><span class="line">a=rtpmap:127 ulpfec/90000</span><br><span class="line">a=ssrc-group:FID 1563406656 4103641903</span><br><span class="line">a=ssrc:1563406656 cname:AyMDWB+q6ApWdpfU</span><br><span class="line">a=ssrc:1563406656 msid:stream_id video_label</span><br><span class="line">a=ssrc:1563406656 mslabel:stream_id</span><br><span class="line">a=ssrc:1563406656 label:video_label</span><br><span class="line">a=ssrc:4103641903 cname:AyMDWB+q6ApWdpfU</span><br><span class="line">a=ssrc:4103641903 msid:stream_id video_label</span><br><span class="line">a=ssrc:4103641903 mslabel:stream_id</span><br><span class="line">a=ssrc:4103641903 label:video_label</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-1-协议版本"><a href="#2-1-协议版本" class="headerlink" title="2.1 协议版本"></a>2.1 协议版本</h2><p>第一行<code>v=0</code>定义了 sdp 协议的版本号。</p><h2 id="2-2-会话发起者"><a href="#2-2-会话发起者" class="headerlink" title="2.2 会话发起者"></a>2.2 会话发起者</h2><p>第二行</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o=- 3967017503571418851 2 IN IP4 127.0.0.1</span><br></pre></td></tr></tbody></table></figure><p>定义了会话发起者的信息，格式如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o=&lt;username&gt; &lt;sess-id&gt; &lt;sess-version&gt; &lt;nettype&gt; &lt;addrtype&gt; &lt;unicast-address&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>username：发起者的用户名，不允许存在空格，如果应用不支持用户名，则为<code>-</code>。</li><li>sess-id：会话 id，由应用自行定义，SDP 规范建议使用 NTP(Network Time Protocol)时间戳。</li><li>sess-version：会话版本，用途由应用自行定义，只要会话数据发生变化时（比如编码）sess-version 随着递增即可。SDP 规范建议使用 NTP 时间戳。</li><li>nettype：网络类型，比如 IN 表示 Internet。</li><li>addrtype：地址类型，比如 IP4、IV6</li><li>unicast-address：域名，或者 IP 地址。</li></ul><h2 id="2-3-会话名"><a href="#2-3-会话名" class="headerlink" title="2.3 会话名"></a>2.3 会话名</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=&lt;session name&gt;</span><br></pre></td></tr></tbody></table></figure><p>必选，有且仅有一个<code>s=</code>字段，且不能为空。可以赋一个空格（即<code>s= </code>），或者<code>-</code>。</p><h2 id="2-4-连接信息"><a href="#2-4-连接信息" class="headerlink" title="2.4 连接信息"></a>2.4 连接信息</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=&lt;nettype&gt; &lt;addrtype&gt; &lt;connection-address&gt;</span><br></pre></td></tr></tbody></table></figure><p>每个 SDP 至少需要包含一个<strong>会话级别</strong>的<code>c=</code>字段，或者在每个媒体描述后面各包含一个<code>c=</code>字段，（媒体描述后的<code>c=</code>会覆盖会话级别的<code>c=</code>）。例如，在上面的示例 SDP 样本中，就不存在会话级别的连接信息。</p><ul><li>nettype：网络类型，比如 IN，表示 Internet。</li><li>addrtype：地址类型，比如 IP4、IP6。</li><li>connection-address：如果是广播，则为广播地址组；如果是单播，则为单播地址；</li></ul><h3 id="2-4-1-何为会话级别和媒体级别"><a href="#2-4-1-何为会话级别和媒体级别" class="headerlink" title="2.4.1 何为会话级别和媒体级别"></a>2.4.1 何为会话级别和媒体级别</h3><p>会话级部分以<code>v =</code>行开始，到第一个媒体级部分结束。<br>每个媒体级部分以<code>m =</code>行开始，持续到下一个媒体级（即下一个<code>m=</code>）。</p><h2 id="2-5-媒体描述信息"><a href="#2-5-媒体描述信息" class="headerlink" title="2.5 媒体描述信息"></a>2.5 媒体描述信息</h2><p>SDP 可以同时包含多个媒体描述信息（如音频、视频等），格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m=&lt;media&gt; &lt;port&gt; &lt;proto&gt; &lt;fmt&gt; ...</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 102 0 8 106 105 13 110 112 113 126</span><br><span class="line">c=IN IP4 0.0.0.0</span><br></pre></td></tr></tbody></table></figure><ul><li>media：媒体类型，包括 video、audio、text、application、message 等。</li><li>port：传输媒体流使用的端口，具体含义取决于使用的网络类型（在<code>c=</code>中声明）和使用的传输协议(proto)。</li><li>proto：传输协议，具体含义取决于<code>c=</code>中定义的地址类型，比如<code>c=IP4</code>，那么这里的传输协议运行在 IP4 之上。</li><li>fmt：媒体格式的描述，可能有多个。根据<code>proto</code>的不同，<code>fmt</code>的含义也不同。比如<code>proto</code>为 RTP/SAVP 时，<code>fmt</code> 表示<code> RTP payload</code> 的类型。如果有多个，表示在这次会话中，多种 payload 类型可能会用到，且<strong>第一个为默认的 payload 类型</strong>。<br>数字<code>0~95</code>是静态负载类型；<code>96~127</code>是动态负载类型，需要在后面使用附近属性<code>a = rtpmap:</code>指定具体的格式参数。具体的每个数字代表的负载类型和含义可以参考：<a href="https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml">Real-Time Transport Protocol (RTP) Parameters</a><br>如上例中的 audio 类型的<code>111</code>表示使用 opus 编码。</li></ul><h2 id="2-6-附加属性"><a href="#2-6-附加属性" class="headerlink" title="2.6 附加属性"></a>2.6 附加属性</h2><p>附加属性用于扩展 SDP，有 2 种作用范围：会话级别、媒体级别：</p><ul><li>媒体级别：媒体描述（m=）后面可以跟任意数量的 a= 字段，对媒体描述进行扩展。</li><li>会话级别：在第一个媒体字段(media field)前，添加的 a= 字段是会话级别的。</li></ul><p>有下面 2 种格式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=&lt;attribute&gt;</span><br><span class="line">a=&lt;attribute&gt;:&lt;value&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="2-7-时间"><a href="#2-7-时间" class="headerlink" title="2.7 时间"></a>2.7 时间</h2><p>用于声明会话的开始、结束时间，格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t=&lt;start-time&gt; &lt;stop-time&gt;</span><br></pre></td></tr></tbody></table></figure><p>如果<code>&lt;stop-time&gt;</code>是 0，表示会话没有结束的边界，但是需要在<code>&lt;start-time&gt;</code>之后会话才是活跃(active)的；如果<code>&lt;start-time&gt;</code>是 0，表示会话是永久的。</p><blockquote><p><a href="https://datatracker.ietf.org/doc/draft-nandakumar-rtcweb-sdp/?include_text=1">SDP for the WebRTC</a> &gt; <a href="https://zhuanlan.zhihu.com/p/75492311">WebRTC：会话描述协议 SDP</a> &gt; <a href="https://blog.csdn.net/u011256637/article/details/74421318">WebRTC 中的 SDP 协议</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ⑤ 音视频编程 </category>
          
          <category> WebRTC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(7)--HTTP与HTTPS协议</title>
      <link href="/post/3654006375.html"/>
      <url>/post/3654006375.html</url>
      
        <content type="html"><![CDATA[<p>HTTP 是<code>Hyper Text Transfer Protocol</code>（超文本传输协议）的缩写。HTTP 协议位于 TCP/IP 协议栈的应用层。</p><span id="more"></span><h1 id="一、HTTP-协议介绍"><a href="#一、HTTP-协议介绍" class="headerlink" title="一、HTTP 协议介绍"></a>一、HTTP 协议介绍</h1><h2 id="1-1-什么是-HTTP"><a href="#1-1-什么是-HTTP" class="headerlink" title="1.1 什么是 HTTP"></a>1.1 什么是 HTTP</h2><p>HTTP 是一个客户端和服务器端请求和应答的标准，主要用于从万维网（即<code>WWW</code>，全称 <code>World Wide Web</code>）服务器传输超文本到本地浏览器之间的请求数据和响应数据的协议。客户端通过使用网页浏览器或者其它的工具发起一个 HTTP 请求到服务器上指定端口（默认端口为<code>80</code>），服务器在收到请求之后，返回响应内容（文本、图片等）。</p><p>HTTP 协议是基于 TCP 协议来进行数据传输的。</p><h2 id="1-2-HTTP-的版本"><a href="#1-2-HTTP-的版本" class="headerlink" title="1.2 HTTP 的版本"></a>1.2 HTTP 的版本</h2><p>HTTP 协议已经演化出了很多版本，它们中的大部分都是向下兼容的。客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。现在大多使用的都是<code>1.1</code>版本。</p><ul><li><p><strong>1.0 版本：</strong> HTTP 协议非常老的标准，为了提高系统的效率，HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。正式因为这种特性造成了一些性能上的缺陷。</p></li><li><p><strong>1.1 版本：</strong> 克服了 HTTP 1.0 的缺陷，HTTP 1.1 支持持久连接（HTTP/1.1 的默认模式使用带流水线的持久连接），在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。同时还增加更多的请求头和响应头来改进和扩充 HTTP 1.0 的功能（如 POST 请求头字段等）。</p></li><li><p><strong>2.0 版本：</strong> 2015 年 5 月作为互联网标准正式发布。主要新增如下特性：多路复用，二进制分帧，首部压缩，服务端推送。</p></li></ul><h1 id="二、HTTP-消息请求"><a href="#二、HTTP-消息请求" class="headerlink" title="二、HTTP 消息请求"></a>二、HTTP 消息请求</h1><h2 id="2-1-URI、URL、URN"><a href="#2-1-URI、URL、URN" class="headerlink" title="2.1 URI、URL、URN"></a>2.1 URI、URL、URN</h2><p>通过 HTTP 或者 HTTPS 协议请求的资源由统一资源标识符（<code>Uniform Resource Identifiers</code>，<code>URI</code>）来标识。我们常用的是 URL，那么 URI, URL, URN 之前有什么区别和联系了？</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URI = Uniform Resource Identifier 统一资源标识符</span><br><span class="line">URL = Uniform Resource Locator    统一资源定位符</span><br><span class="line">URN = Universal Resource Name     统一资源名称</span><br></pre></td></tr></tbody></table></figure><p>三者关系如下图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-http-1.png"></p><p><code>URI</code>用来唯一标识符来标识一个资源，是一个通用的概念，<code>URI</code>由<code>URL</code>和<code>URN</code>两个子集组成。</p><p><code>URL</code>通过描述资源的位置来标识资源。</p><p><code>URN</code>通过资源的名字来标识资源，与其所处的位置无关，这样即使资源的位置发生变动，其<code>URN</code>也不会变化。</p><p>HTTP 规范将更通用的概念 URI 作为其资源标识符，但是实际上，HTTP 应用程序处理的只是 URI 的 URL 子集.</p><h2 id="2-2-消息请求格式"><a href="#2-2-消息请求格式" class="headerlink" title="2.2 消息请求格式"></a>2.2 消息请求格式</h2><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-http-2.png"></p><h2 id="2-3-HTTP-常见的请求方法"><a href="#2-3-HTTP-常见的请求方法" class="headerlink" title="2.3 HTTP 常见的请求方法"></a>2.3 HTTP 常见的请求方法</h2><p>HTTP 消息请求的第一个字段就是“请求方法”，HTTP 1.1 中定义的几种常见的请求方法如下（<strong>只列出了常用的</strong>）：</p><ul><li>GET<br>向服务器获取数据。使用 GET 请求方法时，消息 Body 中没有“请求数据”（见上面消息格式的图）部分，所以将需要提交到服务器的数据放在 URL 中，因此能够提交到服务器的数据会受到 URL 长度的限制。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-http-3.png"></li></ul><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 各个浏览器对URL长度的限制如下（这些限制值可能随着浏览器的版本的更新而发生改变，仅供参考）：</span><br><span class="line">1. IE浏览器（Microsoft Internet Explorer） 对URL长度限制是2083（2K+53），超过这个限制，则自动截断（若是form提交则提交按钮不起作用）。</span><br><span class="line">2. Firefox</span><br><span class="line">Firefox（火狐浏览器）对URL长度限制是65536字符，但实际上有效的URL最大长度不少于100,000个字符。</span><br><span class="line">3. Chrome</span><br><span class="line">chrome对URL长度限制是8182个字符。</span><br><span class="line">4. Safari</span><br><span class="line">Safari对URL长度限制是80000字符。</span><br><span class="line">5. Opera</span><br><span class="line">Opera浏览器对URL长度限制是190000 字符。</span><br></pre></td></tr></tbody></table></figure><ul><li>POST<br>向服务器提交数据（例如提交表单或者上传文件）。提交的数据包含在 Body 中。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-http-4.png"></li></ul><h1 id="三、HTTP-消息响应"><a href="#三、HTTP-消息响应" class="headerlink" title="三、HTTP 消息响应"></a>三、HTTP 消息响应</h1><h2 id="3-1-消息响应格式"><a href="#3-1-消息响应格式" class="headerlink" title="3.1 消息响应格式"></a>3.1 消息响应格式</h2><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-http-5.png"></p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-http-6.png"></p><h2 id="3-2-HTTP-状态码"><a href="#3-2-HTTP-状态码" class="headerlink" title="3.2 HTTP 状态码"></a>3.2 HTTP 状态码</h2><p>状态代码由三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx消息—— 请求已被服务器接收，继续处理</span><br><span class="line">2xx成功 —— 请求已成功被服务器接收、理解、并接受</span><br><span class="line">3xx重定向 —— 需要后续操作才能完成这一请求</span><br><span class="line">4xx请求错误 —— 请求含有词法错误或者无法被执行</span><br><span class="line">5xx服务器错误 —— 服务器在处理某个正确请求时发生错误</span><br></pre></td></tr></tbody></table></figure><p>常见的状态码有：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">200 OK                        //客户端请求成功</span><br><span class="line">400 Bad Request               //客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</span><br><span class="line">403 Forbidden                 //服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found                 //请求资源不存在，比如：输入了错误的URL</span><br><span class="line">500 Internal Server Error     //服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable        //由于超载或系统维护，服务器暂时的无法处理客户端的请求</span><br></pre></td></tr></tbody></table></figure><blockquote><p>关于 HTTP 状态码的完整定义见：<a href="https://tools.ietf.org/html/rfc2616#page-39">https://tools.ietf.org/html/rfc2616#page-39</a></p></blockquote><h1 id="四、HTTPS-之密码学基础"><a href="#四、HTTPS-之密码学基础" class="headerlink" title="四、HTTPS 之密码学基础"></a>四、HTTPS 之密码学基础</h1><h2 id="4-1-对称加密算法"><a href="#4-1-对称加密算法" class="headerlink" title="4.1 对称加密算法"></a>4.1 对称加密算法</h2><p>对称加密算法（英文：<code>Symmetric-key algorithm</code>）是指密码学中的一类加密算法，又称为：私钥加密、共享密钥加密。这类算法在加密和解密时使用相同的<strong>密钥</strong>（或者这 2 个密钥可以通过简单的规则相互推算）。<br>“对称加密算法”比“非对称加密算法”速度更快，但对称加密算法的主要缺点在于要求加密和解密的双方获取相同的密钥，这样只要密钥被泄漏，则密文将不再安全。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-http-7.png"></p><p>常见的对称加密算法有：</p><ul><li>DES: <code>Data Encryption Standard</code>, 数据加密标准，速度较快，适用于加密大量数据的场合。</li><li>3DES: <code>Triple DES</code>, 是基于 DES，对一块数据用三个不同的密钥进行三次加密，强度更高。</li><li>AES: <code>Advanced Encryption Standard</code>, 高级加密标准，是下一代的加密算法标准，速度快，安全级别高。</li><li>Blowfish: 一个 64 位分组及可变密钥长度的对称密钥分组密码算法，可用来加密 64 比特长度的字符串。</li><li>IDEA: 在 DES 算法的基础上发展出来的，密钥为 128 位。</li><li>RC5</li><li>RC6</li></ul><h2 id="4-2-非对称加密算法"><a href="#4-2-非对称加密算法" class="headerlink" title="4.2 非对称加密算法"></a>4.2 非对称加密算法</h2><p>“非对称加密算法”又称为“公开密钥加密”（英语：<code>public-key cryptography</code>）。也一种密码学算法类型，在这类加密算法中，需要一个“密钥对”，即“私钥”和“公钥”。这两个密钥是数学相关，用某个密钥对的“私钥”加密的信息，只能用该密钥对的“公钥”才能解密。同样，用“公钥”加密的信息，也只能用该密钥对的“私钥”才能解密。</p><p>“私钥”一般都是自己保留，不透露给他人；而“公钥”可以公开给他人。</p><p>“非对称加密算法”比“对称加密算法”安全性更高，不用担心加密密钥的泄漏，因为“公钥”是公开的，不存在泄漏。但“私钥”还是要保存妥当，不能泄露给他人，因为我们不需要在网络上传输“私钥”，所以“私钥”泄露的可能性会小很多。</p><p>但是“非对称加密算法”比“对称加密算法”的运算速度慢很多，一般在数据量比较少的时候采用“非对称加密算法”。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-http-8.jpg"></p><p>如上图，因为李四的“公钥”是公开的，所以张三要给李四发送信息，可以使用李四的“公钥”来加密信息。李四收到密文信息之后就可以使用自己的“私钥”来解密信息。因为其他人没有李四的“私钥”，所以就算密文信息被他人截获也无法解密。</p><p>常见的非对称加密算法有：</p><ul><li>RSA: 由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的。</li><li>DSA: <code>Digital Signature Algorithm</code>, 数字签名算法，是一种标准的 DSS（数字签名标准）。</li><li>ECC: <code>Elliptic Curves Cryptography</code>, 椭圆曲线密码编码学。</li></ul><blockquote><p>非对称算法虽然安全，但运算速度很慢，而对称算法的速度虽快，但在管理和传输密钥方面会存在安全隐患。在实际的操作过程中，我们通常采用的方式是：采用“非对称加密算法”管理“对称加密算法”的密钥，然后用“对称加密算法”加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。</p></blockquote><p><strong>使用 OpenSSL 生成 RSA 公私钥对</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 生成1024位的私钥</span><br><span class="line">openssl genrsa -out d:\rsa_private.pem 1024</span><br><span class="line"></span><br><span class="line">// 生成私钥对应的公钥</span><br><span class="line">openssl rsa -<span class="keyword">in</span> d:\rsa_private.pem -pubout -out d:\ca_public.pem</span><br></pre></td></tr></tbody></table></figure><p>git 客户端安装文件中的提供的<code>ssh-keygen.exe</code>工具也可以用来生产非对称加密的公私钥对。</p><h2 id="4-3-散列函数"><a href="#4-3-散列函数" class="headerlink" title="4.3 散列函数"></a>4.3 散列函数</h2><p>散列函数（英文：<code>Hash Function</code>）是将任意长度的的输入转化为定长输出的算法。编程中对散列函数使用非常普遍，如<code>MD5</code>,但并不是所有的散列函数都适用于密码学。密码学的散列函数必须同时具有如下几个额外的特性：</p><ul><li>单向性：给定一个散列值，无法反向找到或者构造出生成它的消息。</li><li>抗碰撞性：给定一个消息和它的散列值，无法找到具有相同散列值的不同的消息。</li></ul><p>散列函数最常用的场合是以紧凑的方式来唯一表示大量数据，如“数字签名”中用到散列函数生成摘要信息等。</p><p>常见的散列函数：</p><ul><li><code>MD5：</code>1991 年对 MD4 的改进版本，该算法不可逆。2004 年王小云等人证明了完全碰撞，在理论上说明 MD5 可以被完全攻破，2005 年，Lenstra 等人证明了现实中的碰撞，展示了两张完全不同的证书却拥有同样的 MD5 散列值。所以，目前<code>MD5</code>已经不安全了。</li><li><code> SHA-1：</code>SHA-1 在许多安全协议中广为使用，包括 TLS 和 SSL、PGP、SSH、S/MIME 和 IPsec，曾被视为是 MD5 的后继者，但因为在理论在已经证明 SHA1 可以被破解，但限制于计算机的计算能力所以 SHA-1 被破解还是很困难，所以 SHA-1 的安全性如今被密码学家严重质疑。</li><li><code>SHA-256：</code>SHA-224、SHA-256、SHA-384、SHA-512 一起并称为 SHA-2，至今尚找出对 SHA-2 有效的破解方法。</li></ul><h1 id="五、数字签名与数字证书"><a href="#五、数字签名与数字证书" class="headerlink" title="五、数字签名与数字证书"></a>五、数字签名与数字证书</h1><h2 id="5-1-数字签名"><a href="#5-1-数字签名" class="headerlink" title="5.1 数字签名"></a>5.1 数字签名</h2><p>数字签名（英文：<code>Digital Signature</code>）类似于我们写在纸上的手写签名，它的诞生主要是为了解决如下问题：</p><ol><li>证明该文件（或信息）是由你发送的。</li><li>证明该文件（或信息）没有被他人篡改过。</li></ol><p>其实，我们生活中手写签名的纸质合同也是通过各种形式达到上面 2 个效果（如：合同一式多份，每份合同都有双方签名等）。</p><p>数字签名利用了“非对称加密算法”，签名和验证签名的过程如下图（图中的“认证”部分不是数字签名必须的，在“数字证书”部分会介绍）：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-http-9.jpg"></p><p>假设“李四”要发送一份数据给“张三”：<br>发送者“李四”对数据生成摘要信息（<code>摘要明文A</code>），然后使用<code>“李四”的“私钥”</code>加密摘要信息；接收者“张三”收到加密的摘要信息之后：</p><ol><li><p>使用<code>“李四”的“公钥”</code>对加密的摘要信息进行解密。若能解密则证明签名是由“李四”所签，这是因为只有<code>“李四”的“私钥”</code>加密的数据才能由<code>“李四”的“公钥”</code>解密，而又只有“李四”才有<code>“李四”的“私钥”</code>。</p></li><li><p>并将数据使用相同的摘要算法自己也生成一份摘要信息（<code>摘要明文B</code>），然后比较 A 和 B。若两者相等，则证明了该数据内容没有被他人篡改过。</p></li></ol><p>通过上面的过程我们可以知道：</p><ol><li>数字签名具有合法性的前提条件是用于加密散列值的<code>“私钥”</code>没有被泄露。</li><li>数字签名不负责数据的加密，若要防止数据被他人窥视，则还要结合其他手段，如使用接收者的“公钥”对数据进行加密等。</li></ol><blockquote><p>如何获取签名者的公钥？如何保证获得的公钥就是签名者的，而不是他人的？基于这些问题，数字签名需要结合后面介绍的数字证书来使用（也就是上图中的“认证”文件）。</p></blockquote><h2 id="5-2-数字证书"><a href="#5-2-数字证书" class="headerlink" title="5.2 数字证书"></a>5.2 数字证书</h2><p>有了上面的公开密钥算法（也就是“非对称加密算法”）之后，我们就可以通过他人的公开密钥（公钥）与其安全通信了，但是还有一些悬而未决的问题：</p><ul><li>如何获取那些从未谋面的人的公钥？</li><li>如何存储和吊销这些公钥？</li><li>如何确保获取的公钥就是那个人的？</li></ul><p>公钥基础设施（<code>public key infrastructure</code>, 简称<code>KPI</code>）就是为了解决这个问题而建立的。<code>PKI</code>的目标就是为了实现不同成员在不见面的情况下进行安全通信的，我们当前采用的 PKI 模型是基于可信的第三方机构，也就是“证书颁发机构”（<code>certification authority</code>，简称<code>CA</code>）签发的证书。证书中存储了使用“证书颁发机构”的私钥加密之后的申请者的公钥信息。</p><h2 id="5-2-1-数字证书的申请"><a href="#5-2-1-数字证书的申请" class="headerlink" title="5.2.1 数字证书的申请"></a>5.2.1 数字证书的申请</h2><p>数字证书需要向“证书颁发机构”提交申请，并通过审核之后才能颁发。因为数字证书中存储的是申请者的公钥，所以如果申请者的私钥丢失或泄漏，就需要向“证书颁发机构”申请注销该证书。</p><p><code>Web服务器</code>向<code>CA</code>申请证书的流程大致如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-http-10.jpg"></p><p>“证书”中主要包含了经过<code>“证书颁发机构”的私钥</code>加密过后的<code>申请者的“公钥”</code>、<code>“证书有效期”</code>、<code>“申请者信息（如域名等）”</code>。更详细的信息，可以参考《HTTPS 权威指南》第 3.3.1 章节。</p><h2 id="5-2-2-数字证书的验证"><a href="#5-2-2-数字证书的验证" class="headerlink" title="5.2.2 数字证书的验证"></a>5.2.2 数字证书的验证</h2><p>以“Chrome 浏览器”为例：<br>浏览器会内置各大著名的“证书颁发机构”的<code>“公钥”</code>，当收到 Web 服务器返回的<code>“服务器证书”</code>后，Chrome 会尝试使用内置的该“证书颁发机构”的<code>“公钥”</code>来解密该证书，如果能解密则说明该证书是“证书颁发机构”颁发的，且没有被篡改过的。然后通过解密所得的“域名”、“证书有效期”来校验该证书是否为该网站所有，是否过期等。</p><blockquote><p><strong>本文介绍的只是“数字证书”申请和验证的基本的流程，实际流程比这个复杂很多，关于“数字证书”的信息介绍可以参考《HTTPS 权威指南》</strong></p></blockquote><h1 id="六、HTTPS"><a href="#六、HTTPS" class="headerlink" title="六、HTTPS"></a>六、HTTPS</h1><p>在 HTTP 请求过程中，客户端与服务端之前没有进行身份确认，而且传输的数据都没有加密处理，所以很容易被劫持和篡改。</p><p>基于 HTTP 协议的这些弊端，后面就出现了<code>HTTPS</code>（<strong>严格的说，HTTPS 并不是一个协议，所以前面文章都没有使用“HTTPS 协议”</strong>），HTTPS 是基于<code>SSL/TSL</code>协议的，说白了就是<code>HTTP+SSL/TSL</code>，可以把 HTTPS 大致理解为<code>“HTTP Over SSL”</code>或者<code>“HTTP Over TSL”</code>。</p><p>HTTP, SSL/TSL, HTTPS 的关系如下图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-http-11.jpg"></p><h2 id="6-1-SSL-TSL-协议"><a href="#6-1-SSL-TSL-协议" class="headerlink" title="6.1 SSL/TSL 协议"></a>6.1 SSL/TSL 协议</h2><h3 id="6-1-1-SSL"><a href="#6-1-1-SSL" class="headerlink" title="6.1.1 SSL"></a>6.1.1 SSL</h3><p>SSL（英文：<code>Secure Sockets Layer</code>的缩写）中文叫“安全套接层”。最开始由 NetScape 公司研发，用以保障互联网上数据传输的安全，利用数据加密技术确保数据在网络上之传输过程中不会被截取及窃听。<br>SSL 协议在 TCP/IP 协议栈中位于<code>传输层</code>和<code>应用层</code>之间。以<code>HTTPS</code>为例，SSL 协议就位于 TCP 和 HTTP 之间：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-http-12.gif"></p><h3 id="6-1-2-TLS"><a href="#6-1-2-TLS" class="headerlink" title="6.1.2 TLS"></a>6.1.2 TLS</h3><p>TLS（英文：<code>Transport Layer Security</code>的缩写）中文叫“传输层安全协议”，<code>TLS 1.0</code>是 IETF（Internet Engineering Task Force，Internet 工程任务组）制定的一种新的协议，它建立在<code>SSL 3.0协议</code>规范之上，是<code>SSL 3.0</code>的后续版本，可以理解为 SSL 3.1，它定义在<a href="https://tools.ietf.org/html/rfc5246">RFC5246</a>中。</p><p>因为 TLS 是基于 SSL 3.0 的，所以也可以认为 TLS 是 SSL 的加强版。</p><p><strong>我们一般将二者并称为<code>SSL/TSL协议</code>，因为这二者可以视为同一个产品的不同阶段。</strong></p><h2 id="6-2-SSL-TSL-协议的握手过程"><a href="#6-2-SSL-TSL-协议的握手过程" class="headerlink" title="6.2 SSL/TSL 协议的握手过程"></a>6.2 SSL/TSL 协议的握手过程</h2><blockquote><p>在了解 SSL/TSL 协议的握手过程之前，需要先阅读关于 HTTPS 的前几篇文章，对相关预备知识有所了解。</p></blockquote><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-http-13.jpg"></p><p>参考上面的流程图，握手过程可以分为 4 个步骤：</p><p>1). 客户端发送 Client Hello 请求到服务端，包含如下内容：</p><ul><li><p>SSL 或 TSL 协议的版本</p></li><li><p>客户端生成的随机串<code>Client random</code>；</p></li><li><p>客户端支持的加密算法列表，用于客户端和服务端加密算法的协商；</p></li><li><p>客户端支持的 HASH 算法；</p><p>2). 服务端发送 Sever Hello 响应到客户端，包含如下内容：</p></li><li><p>服务端生成的随机串<code>Server random</code>（第 3 步会用到）；</p></li><li><p>由“CA 证书机构”颁发的证书的<code>Public key</code>部分（<code>Public key</code>和<code>Private Key</code>为一对，用于非对称加密和解密）；</p></li><li><p>会话 ID</p></li><li><p>协商的加密算法（对称加密和非对称加密）和 HASH 算法。</p><p>3). 客户端发送 Client Key 到服务端，包含如下内容或步骤：</p></li><li><p>检查服务端返回的“证书”的有效性，如果无效则在浏览器上显示警告。</p></li><li><p>客户端使用前 2 步生成的<code>Client random</code>和<code>Server random</code>作为随机因子，生成另外一个随机串<code>Premaster</code>。</p></li><li><p>使用<code>Public key</code>（第 2 步服务端返回）非对称加密的随机串<code>Premaster</code>。</p><p>4). 服务端通知客户端握手结束，包含如下内容：</p></li><li><p>通过解密出来的<code>Premaster</code>生成的本次会话的<code>Session key</code>。</p></li><li><p>前面所有握手内容的 HASH 值，供客户端校验。</p></li></ul><blockquote><p>参考：<br><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a> &gt; <a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></p></blockquote><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(6)--TCP协议</title>
      <link href="/post/1504706832.html"/>
      <url>/post/1504706832.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、TCP-特性"><a href="#一、TCP-特性" class="headerlink" title="一、TCP 特性"></a>一、TCP 特性</h1><p>尽管 TCP 和 UDP 都是用 IP 协议作为网络层，但 TCP 却提供和 UDP 完全不同的网络服务。TCP 是<code>面向连接的</code>、<code>稳定可靠</code>的<code>字节流</code>服务。TCP 首部的很多字段都是为了实现这 2 大特性而设计的。</p><span id="more"></span><p>在一个 TCP 连接中，仅有两方能进行彼此通信。所以说广播和多播不适用于 TCP 协议。</p><p>为了通过 IP 数据报实现可靠性传输，需要考虑很多事情，如数据的破坏、丢包、重复以及分片顺序混乱等问题。TCP 通过检验和、序列号、确认序列号、重发控制、连接管理以及窗口控制等机制来实现可靠性传输。</p><h1 id="二、TCP-协议首部"><a href="#二、TCP-协议首部" class="headerlink" title="二、TCP 协议首部"></a>二、TCP 协议首部</h1><p>摘自《TCP/IP 详解卷 1》中的关于 TCP 首部定义的图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-tcp-1.jpg"></p><p><strong>TCP 协议的实现较 UDP 协议复杂太多，它的首部的各个字段的用法也比 UDP 首部字段复杂多，这里先对 TCP 首部字段的功能做个大概的介绍。</strong></p><ul><li>16 位源端口号：表示发送端端口号。传输层使用端口号来标识发送端和接收端的应用程序，而网络层是通过 IP 地址来标识主机，这样使用“IP 地址+端口”就可以精确定位到某一台主机上的某一应用程序。</li><li>16 位目的端口号：表示接收端端口号。</li><li>32 位序列号：序列号用来标识从 TCP 发送端已经发送的字节数。达到最大值$2^{32}-1$之后，再从 0 开始。</li><li>32 位确认序列号：确认序列号用来标识 TCP 接收端期望接收的下一个序列号（反过来想也就是，TCP 接收端已经接受到的字节数为<code>确认序列号减去1</code>）。<strong>只有<code>ACK标志位</code>为 1 时，该字段才有效。</strong>只要 TCP 连接建立，这个字段会一直起作用，也就是说只要 TCP 连接建立，<code>ACK标志位</code>会一直为 1。</li><li>4 位首部长度：和 IP 首部一样，是以<code>4个字节(32 bit)</code>为单位的，所以 TCP 首部最大长度也是<code>15*4=60</code>字节。若没有“选项”字段，长度固定为 20 字节。</li><li>6 位标志位：他们中的多个可以同时被设置为 1。</li></ul><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">URG 标记后面的"16位紧急指针"是否有效。</span><br><span class="line">ACK 标记前面的"32位确认序号"是否有效。</span><br><span class="line">PSH 接收方应该尽快的将这个报文交给上层的网络层。</span><br><span class="line">RST 重建连接。</span><br><span class="line">SYN 标记这个TCP段是用来同步初始序号（ISN）的。</span><br><span class="line">FIN 标记发送端已经完成了发送任务。</span><br></pre></td></tr></tbody></table></figure><ul><li>16 位窗口大小：窗口大小为字节数，用于 TCP 的流量控制，这个值是接收端期望接受的字节数。</li><li>16 位校验和：和 UDP 类似，校验和覆盖首部和数据部分。</li><li>16 位紧急指针：只有前面提到的<code>URG</code>标记位为 1 时，这个字段才有效。</li><li>选项：添加一些附加数据。和 UDP 不同，TCP 的“选项”字段使用的比较多。</li></ul><h1 id="三、三次握手与四次挥手"><a href="#三、三次握手与四次挥手" class="headerlink" title="三、三次握手与四次挥手"></a>三、三次握手与四次挥手</h1><h2 id="3-1-完整的-TCP-会话流程图"><a href="#3-1-完整的-TCP-会话流程图" class="headerlink" title="3.1 完整的 TCP 会话流程图"></a>3.1 完整的 TCP 会话流程图</h2><p>本文通过真实的网络示例来讲解 TCP 的三次握手和四次挥手。读者可以先<a href="https://blog-static.jiangxueqiao.com/misc/tcp.pcapng">下载</a>作者写本文时使用的网络包示例，然后使用 wireshark 打开（当然也可以使用 wireshark 随便抓取一个网络包），选中编号为<code>No.9</code>的包，右键选择“追踪流” –&gt; “TCP 流”：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-tcp-2-TinyTu.png"></p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-tcp-3-TinyTu.png"></p><p>上图是使用 wireshark 抓取的一个 Http 接口请求的过程（不含 DNS 解析等步骤），包含了 TCP 连接建立、Http 请求、Http 响应、TCP 连接断开。现在以这个示例为基础，来画出该 Http 接口请求中涉及的整个 TCP 会话的流程（也是本文最重要的图）：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-tcp-4.png"></p><blockquote><ul><li>箭头上方标出了该 TCP 包<code>SYN、ACK、FIN、PSH</code>等标志位的设置情况（大家可能注意到，除了第一个箭头上没有<code>ACK</code>之外，其他的箭头上都有<code>ACK</code>，这是因为<code>ACK</code>标记位只是用于标记 TCP 首部的<code>32位确认序列号</code>是否有效。在此之后的<code>32位确认序列号</code>一直有效，所以也就一直有<code>ACK</code>标记位。）；箭头下发标出了该 TCP 包的序号和确认序号。</li><li>seq_num：表示 32 位的序号，紧跟其后括号[]中的是相对序号。</li><li>ack_num：表示 32 位的确认序号，紧跟其后括号[]中的是相对确认序号。</li><li>payload_len：表示本次 TCP 携带的数据大小（字节）。</li><li>在三次握手和四次挥手的部分，旁边的红色粗体字表示当前端的 TCP 状态。<strong>在这个示例中是服务端执行主动关闭。</strong></li></ul></blockquote><h2 id="3-2-Wireshark-的相对序号"><a href="#3-2-Wireshark-的相对序号" class="headerlink" title="3.2 Wireshark 的相对序号"></a>3.2 Wireshark 的相对序号</h2><p><code>相对序号</code>是 Wireshark 引出的概念，TCP 协议中没有这个概念。Wireshark 使用相对数值来显示序号和确认序号，这个相对值是相对于初始序号（ISN）而言的。因为人类更加习惯跟踪更小数值，所以 Wireshark 默认用相对数值来展示。如果需要查看真实的序号，可以在 wireshark 中选中该网络包，在最下方的数据窗口查看，如：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-tcp-5-TinyTu.png"></p><h2 id="3-3-Wireshark-的-TCP-流量图"><a href="#3-3-Wireshark-的-TCP-流量图" class="headerlink" title="3.3 Wireshark 的 TCP 流量图"></a>3.3 Wireshark 的 TCP 流量图</h2><p>我们也可以使用 Wireshark 自带的统计功能来查看整个 TCP 会话的过程。通过菜单“统计” –&gt; “流量图”打开流量图窗口，在“显示”选项选择“显示的分组”，“流类型”选项选择“TCP 流”，如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-tcp-6-TinyTu.png"></p><h1 id="四、TIME-WAIT-及-MSL"><a href="#四、TIME-WAIT-及-MSL" class="headerlink" title="四、TIME_WAIT 及 MSL"></a>四、TIME_WAIT 及 MSL</h1><h2 id="4-1-TIME-WAIT-状态为何存在？"><a href="#4-1-TIME-WAIT-状态为何存在？" class="headerlink" title="4.1 TIME_WAIT 状态为何存在？"></a>4.1 TIME_WAIT 状态为何存在？</h2><p>这里我们不使用“客户端”、“服务端”来表示 TCP 连接的 2 端，转而使用“主动断开连接端”、“被动断开连接端”来表示 TCP 通讯的 2 端。因为执行主动断开连接的端可能是服务端也可能是客户端（虽然我们大多数情况下遇到的是客户端执行主动断开）。</p><p>在“主动断开连接端”收到了“被动断开连接端”发来的<code>LAST_ACK</code>之后，会给“被动断开连接端”回复一个<code>ACK</code>确认消息。但这个时候为了确保“被动断开连接端”有足够的时间能够收到该消息，“主动断开连接端”不能马上关闭 socket，需要等待一定的时间来确保“被动断开连接端”可以收到<code>ACK</code>确认消息。“主动断开连接端”在等待的这个时间段内的状态我们称之为<code>TIME_WAIT</code>状态。</p><p>归纳为一句话就是：<strong>TIME_WAIT 状态就是“主动断开的一方”在发送完最后一次 ACK 后进入的等待状态。</strong></p><h2 id="4-2-等待时间"><a href="#4-2-等待时间" class="headerlink" title="4.2 等待时间"></a>4.2 等待时间</h2><p>那么<code>TIME_WAIT</code>状态需要持续多久了，也就是“主动断开连接端”在发送完最后一个 ACK 之后需要等待多久了？<br><a href="http://www.52im.net/topic-tcpipvol1.html">《TCP/IP 详解 卷 1：协议》</a>中提到：默认 TIME_WAIT 的超时时间是 2 倍的 MSL。MSL 是<code>Maximum Segment Lifetime</code>的缩写，表示报文的最大生存时间，这个时间和系统的 TCP 实现有关，每个系统是不一样的。</p><h3 id="4-2-1-windows-系统-MSL"><a href="#4-2-1-windows-系统-MSL" class="headerlink" title="4.2.1 windows 系统 MSL"></a>4.2.1 windows 系统 MSL</h3><p>注册表<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters</code>下的<code>TcpTimedWaitDelay</code>键（如果没有可以新建一个）就对应了<code>2*MSL</code>（2 倍的 MSL）的值。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-tcp-7.jpg"></p><h3 id="4-2-2-Linux-系统-MSL"><a href="#4-2-2-Linux-系统-MSL" class="headerlink" title="4.2.2 Linux 系统 MSL"></a>4.2.2 Linux 系统 MSL</h3><p>以 CentOS 为例（<strong>摘自网络，仅供参考</strong>）：</p><ul><li>查看默认的 MSL 值（60s）：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_fin_timeout</span><br></pre></td></tr></tbody></table></figure><ul><li>修改默认为 120：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 120 &gt; /proc/sys/net/ipv4/tcp_fin_timeout</span><br></pre></td></tr></tbody></table></figure><ul><li>修改完成后，重新加载配置文件：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p /etc/sysctl.conf</span><br></pre></td></tr></tbody></table></figure><ul><li>查看是否已经生效：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a | grep fin</span><br></pre></td></tr></tbody></table></figure><h2 id="4-3-SO-REUSEADDR"><a href="#4-3-SO-REUSEADDR" class="headerlink" title="4.3 SO_REUSEADDR"></a>4.3 SO_REUSEADDR</h2><ul><li><p>如果进程中的某个 TCP 连接处于<code>TIME_WAIT</code>等待状态，因为这个等待时间比较长，在这期间该连接使用的端口将一直被占用。</p></li><li><p>如果一个服务端进程（绑定了某个端口）退出（正常退出或异常退出）后，立即启动一个新的该进程，可能由于 Windows 系统对端口的释放不及时，导致这个端口还没有被释放，不能被再次绑定，从而导致新进程绑定端口失败。</p></li></ul><p>那么遇到上面的问题如何解决了？<br>我们在网络编程中经常设置的<code>SO_REUSEADDR</code>选项就可以解决这个问题，</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(socket, SOL_SOCKET, SO_REUSEADDR, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;flag), <span class="built_in">sizeof</span>(flag));</span><br></pre></td></tr></tbody></table></figure><p><strong><code>SO_REUSEADDR</code>提供如下四个功能：</strong></p><ul><li><p>SO_REUSEADDR 允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在。这通常是重启监听服务器时出现，若不设置此选项，则<code>bind</code>时将出错。</p></li><li><p>SO_REUSEADDR 允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地 IP 地址即可。由于设置该Socket选项不需要任何特殊权限，恶意程序可以轻易使用SO_REUSEADDR强制绑定已用于标准网络协议服务的套接字，从而使这些服务拒绝访问。不用担心，我们可以使用<code>SO_EXCLUSIVEADDRUSE</code>选项解决这个问题。</p></li><li><p>SO_REUSEADDR 允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地 IP 地址即可。这一般不用于 TCP 服务器。</p></li><li><p>SO_REUSEADDR 允许完全重复的捆绑：当一个 IP 地址和端口绑定到某个套接口上时，还允许此 IP 地址和端口捆绑到另一个套接口上。一般来说，这个特性仅在支持多播的系统上才有，而且只对 UDP 套接口而言（TCP 不支持多播）。</p></li></ul><p>其中第一个功能就可以用来解决该问题。</p><blockquote><p>关于SO_REUSEADDR更详细的介绍可以访问微软的官方文档：<br><a href="https://learn.microsoft.com/en-us/windows/win32/winsock/using-so-reuseaddr-and-so-exclusiveaddruse">using-so-reuseaddr-and-so-exclusiveaddruse</a></p></blockquote><h1 id="五、为什么要进行-3-次握手？"><a href="#五、为什么要进行-3-次握手？" class="headerlink" title="五、为什么要进行 3 次握手？"></a>五、为什么要进行 3 次握手？</h1><p>前面的文章介绍了 TCP 的三次握手，那么 TCP 的握手为什么是 3 次了？</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-tcp-8.png"></p><p>本文从 3 个角度来解释为什么要进行 3 次握手？</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>TCP 的握手的目的是让通信双方都确定双方能够正常发送和接收信息。</p><p>第一步，服务端收到客户端发送的 SYN，服务端能够确定如下信息：“客户端的发送功能正常，服务端自己的接受功能正常”。但客户端还什么都不能确定。<br>第二步，客户端收到服务端回复的 SYN+ACK，截至目前，客户端能够确定如下信息：“客户端自己的发送/接收功能都正常，服务端的接收和发送功能都正常”；服务端还是只能确定自己的接受功能正常，还不知道自己的发送功能是否正常，客户端的接受功能是否正常。</p><p>大家可以看到，到第二步完成，客户端和服务端能够确认的信息分别如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">客户端能够确定：</span><br><span class="line">  客户端-发送 正常</span><br><span class="line">  客户端-接收 正常</span><br><span class="line">  服务端-发送 正常</span><br><span class="line">  服务端-接收 正常</span><br><span class="line"></span><br><span class="line">服务端能够确定：</span><br><span class="line">  客户端-发送 正常</span><br><span class="line">  客户端-接收 ？</span><br><span class="line">  服务端-发送 ？</span><br><span class="line">  服务端-接收 正常</span><br></pre></td></tr></tbody></table></figure><p>从上面表可以看到，第二步完成之后，服务端还能不能确定“服务端的发送功能”和“客户端的接收功能”是否正常。所以需要第三步。</p><p>第三步，服务端收到客户端回复的 ACK，服务端能够确定如下信息：客户端的发送功能正常，服务端的接收功能正常。</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>我们可以假设“客户端”和“服务端”是 2 个人，模拟这 2 个人打招呼的形式来理解为什么需要 3 次握手。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：hi，服务端，你能听到我说话吗？</span><br><span class="line">服务端：hi，客户端，我能听到你说的话，你能听到我说的话吗？</span><br><span class="line">客户端：嗯，服务端，我也能听到你说的话。</span><br></pre></td></tr></tbody></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>对照文章开始处 TCP 握手图的前 2 步，现在我们假设 TCP 只有 2 次握手：</p><p>服务端在收到客户端的<code>SYN</code>并且回复<code>SYN+AKC</code>之后，就认为连接已经建立完成了，并为之分配相应的资源。<br>但客户机却因为网络延迟等问题一直没收到服务端回复的<code>SYN+ACK</code>，这样客户端就认为连接没有建立成功，糟糕的是，客户端会因为连接没有成功而不停的重试，这样每次服务端都会认为连接建立成功并分配资源。</p><p>如果按照上面描述的那样，客户端一直没有收到服务端回复的<code>SYN+ACK</code>，且一直这样尝试建立连接，就会造成服务端资源极大的浪费，加重服务端的负担。</p><h1 id="六、为什么要进行-4-次挥手？"><a href="#六、为什么要进行-4-次挥手？" class="headerlink" title="六、为什么要进行 4 次挥手？"></a>六、为什么要进行 4 次挥手？</h1><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-tcp-9.png"></p><p>对比上面的图，我们不难发现：4 次挥手相比 3 次握手多了一次，主要是因为握手的<code>ACK和SYN</code>是合并在一条发送的，而挥手的<code>ACK和FIN</code>是分开发送的，所以挥手比握手多了一次。</p><p><strong>现在我们分析为什么 TCP 挥手的<code>ACK和FIN</code>（分别对应图中的第 2,3 条线）要分开发送？</strong></p><p><code>“被动断开方”</code>之所以叫称之为“被动”是因为 TCP 连接的断开并不是它想的，也不是它主动触发的，是对面的<code>“主动断开方”</code>想要断开的，也许这个时候<code>“被动断开方”</code>还正想发送点数据给<code>“主动断开方”</code>了。</p><p>为了让<code>“被动断开方”</code>有机会将想要发送的数据发送完，主动断开方在发送完<code>FIN</code>并收到了<code>ACK</code>确认信息进入<code>FIN_WAIT_2</code>状态后，只关闭了发送功能了，但仍然保留接收功能。这样<code>“被动断开方”</code>就有机会将没有发送完的数据发送完成，发送完成之后，<code>“被动断开方”</code>也发送一个<code>FIN</code>，相当于告诉<code>“主动断开方”</code>：“我的数据已经发完了呀，以后不会再发数据了，你可以安心的把接收功能关闭了，另外我自己也要关闭了呀”。</p><blockquote><p>《TCP/IP 详解 卷 1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p></blockquote><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(5)--UDP协议</title>
      <link href="/post/4190400644.html"/>
      <url>/post/4190400644.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是-UDP-协议？"><a href="#一、什么是-UDP-协议？" class="headerlink" title="一、什么是 UDP 协议？"></a>一、什么是 UDP 协议？</h2><p>UDP 是 User Datagram Protocol 的简称，中文名是用户数据报协议，是 OSI 参考模型中的传输层协议，它是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p><span id="more"></span><p>UDP 的正式规范是<a href="https://www.ietf.org/rfc/rfc768.txt">IETF RFC768</a>。UDP 在 IP 报文的协议号是 17。</p><blockquote><p>ISO 七层模型：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-udp-1.jpg"></p></blockquote><h2 id="二、UDP-报头"><a href="#二、UDP-报头" class="headerlink" title="二、UDP 报头"></a>二、UDP 报头</h2><p>UDP 报头的结构如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-udp-2.jpg"></p><p>UDP 报头由 4 个部分组成，其中两个是可选的（粉红背景标出部分）：</p><ul><li><p>各 16bit 的<code>来源端口</code>和<code>目的端口</code>用来标记发送和接受的应用进程。因为 UDP 不需要应答，所以来源端口是可选的，如果来源端口不用，那么置为零。</p></li><li><p>在目的端口后面是长度固定的以字节为单位的报文长度域，用来指定 UDP 数据报包括数据部分的长度，长度最小值为 8byte。</p></li><li><p>首部剩下地 16bit 是用来对首部和数据部分一起做<code>校验和</code>（Checksum）的，这部分是可选的，但在实际应用中一般都使用这一功能。</p></li><li><p>UDP 和 TCP 的<code>校验和</code>都覆盖到了他们的首部和数据，而之前介绍的 IP 首部的<code>校验和</code>只覆盖了 IP 首部。</p></li></ul><h2 id="三、TCP-和-UDP-区别"><a href="#三、TCP-和-UDP-区别" class="headerlink" title="三、TCP 和 UDP 区别"></a>三、TCP 和 UDP 区别</h2><table><thead><tr><th>特征点</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接</td><td>面向非连接</td></tr><tr><td>传输可靠性</td><td>可靠</td><td>会丢包，不可靠</td></tr><tr><td>应用场景</td><td>传输数据量大</td><td>传输量小</td></tr><tr><td>速度</td><td>慢</td><td>快</td></tr></tbody></table><p>TCP(传输控制协议)提供的是面向连接、可靠的字节流服务。当客户端和服务器彼此交换数据前，必须先在双方之间建立一个 TCP 连接，之后才能传输数据。TCP 提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。<br>UDP(用户数据报协议)是一个简单的面向数据报的运输层协议。UDP 不提供可靠性，它只是把应用程序传给 IP 层的数据报发送出去，但是并不能保证它们能到达目的地。由于 UDP 在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。</p><p>由于 UDP 缺乏拥塞控制（congestion control），需要基于网络的机制来减少因失控和高速 UDP 流量负荷而导致的拥塞崩溃效应。换句话说，因为 UDP 发送者不能够检测拥塞，所以像使用包队列和丢弃技术的路由器这样的网络基本设备往往就成为降低 UDP 过大通信量的有效工具。数据报拥塞控制协议（DCCP）设计成通过在诸如流媒体类型的高速率 UDP 流中，增加主机拥塞控制，来减小这个潜在的问题。</p><h2 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景"></a>四、应用场景</h2><p>由于缺乏可靠性且属于非连接导向协议，UDP 的应用一般必须允许一定量的丢包、出错和复制粘贴。但有些应用，比如 TFTP，需要可靠性保证，则必须在应用层增加根本的可靠机制。但是绝大多数 UDP 应用都不需要可靠机制，甚至可能因为引入可靠机制而降低性能。流媒体、即时多媒体游戏和 IP 电话（VoIP）就是典型的 UDP 应用。如果某个应用需要很高的可靠性，那么可以用传输控制协议（即 TCP 协议）来代替 UDP。</p><p>使用 UDP 协议的应用有：域名系统（DNS）、简单网络管理协议（SNMP）、动态主机配置协议（DHCP）、路由信息协议（RIP）等等。</p><p>因为 UDP 不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用 UDP 较多，因为它们即使偶尔丢失几个数据包，也不会对接收结果产生太大影响。</p><h2 id="五、单播、多播、广播、组播"><a href="#五、单播、多播、广播、组播" class="headerlink" title="五、单播、多播、广播、组播"></a>五、单播、多播、广播、组播</h2><p>假设 A(all 简写)代表所有的机器，M(multiple 简写)代表 A 中的多个机器，G(group 简写)代表一组机器，1 代表一台机器，那么：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 1 就是单播；</span><br><span class="line">1 -&gt; M 就是多播；</span><br><span class="line">1 -&gt; A 就是广播；</span><br><span class="line">1 -&gt; G 就是组播；</span><br><span class="line"></span><br><span class="line">当M=A时，多播就是广播；</span><br><span class="line">当M=G时，多播就是组播；</span><br></pre></td></tr></tbody></table></figure><p>多播包括组播和广播，组播、广播都是多播的一种表现形式。</p><h3 id="5-1-单播"><a href="#5-1-单播" class="headerlink" title="5.1 单播"></a>5.1 单播</h3><p>单播是主机之间“一对一”的通讯模式。发送方需要指定一个接收方的 IP 和端口，只有这个接收方会收到数据报。不会对子网内的其他机器产生影响。<br>在单播模式下，服务器针对每个客户机都要发送数据流，<code>服务器流量=客户机数量×客户机流量</code>，在客户机数量大、每个客户机流量大的应用（如流媒体）中，服务器将不堪重负。</p><h4 id="5-1-1-单播发送端"><a href="#5-1-1-单播发送端" class="headerlink" title="5.1.1 单播发送端"></a>5.1.1 单播发送端</h4><p>因为 UDP 不是面向连接的，且不可靠的，所以发送端在调用<code>sendto</code>之后，就算<code>sendto</code>返回成功，也不代表接收端一定收到了数据，可能接收端压根都没启动，也是有可能的。不能根据<code>sendto</code>的返回值来确保接收端一定收到了数据。如果需要数据传输的可靠性得到保证，可以使用 TCP 或者通过业务逻辑来保证。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendLogic</span><span class="params">()</span> </span>{</span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  SOCKET socket = ::<span class="built_in">WSASocket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (socket == INVALID_SOCKET) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"WSASocket failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  sockaddr_in addr;</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_port = <span class="built_in">htons</span>(<span class="number">6000</span>);  <span class="comment">// 接收端端口</span></span><br><span class="line">  addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">"127.0.0.1"</span>); <span class="comment">// 接收端IP</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>] = { <span class="string">"hello"</span> };</span><br><span class="line">  <span class="type">int</span> err = <span class="built_in">sendto</span>(socket, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;addr), <span class="built_in">sizeof</span>(addr));</span><br><span class="line">  <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sendto failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[SEND] %s OK\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">SendLogic</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="5-1-2-单播接收端"><a href="#5-1-2-单播接收端" class="headerlink" title="5.1.2 单播接收端"></a>5.1.2 单播接收端</h4><p>因为 UDP 不是面向连接的，所以接收端不用 listen，也不用 accept，只需要绑定到指定的端口和地址即可。<br><code>recvfrom</code>是同步的，会阻塞住等待数据的到来。如果要使用异步方式，可以使用<code>WSARecvFrom</code>结合 ICOP 的方式来实现。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RecvLogic</span><span class="params">()</span> </span>{</span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  SOCKET socket = ::<span class="built_in">WSASocket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (socket == INVALID_SOCKET) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"WSASocket failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  sockaddr_in addr;</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_port = <span class="built_in">htons</span>(<span class="number">6000</span>);  <span class="comment">// 端口</span></span><br><span class="line">  addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 任意IP地址</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> err = <span class="built_in">bind</span>(socket, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;addr), <span class="built_in">sizeof</span>(addr));</span><br><span class="line">  <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bind failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) { <span class="comment">// TODO：未考虑退出的情况</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>] = { <span class="number">0</span> };</span><br><span class="line">    <span class="type">int</span> fromlen = <span class="built_in">sizeof</span>(addr);</span><br><span class="line">    err = <span class="built_in">recvfrom</span>(socket, buf, <span class="number">100</span>, <span class="number">0</span>, <span class="built_in">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;addr), &amp;fromlen);</span><br><span class="line">    <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"recvfrom failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[RECV] %s\n"</span>, buf);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">RecvLogic</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-广播"><a href="#5-2-广播" class="headerlink" title="5.2 广播"></a>5.2 广播</h3><p>广播是主机之间“一对所有”的通讯模式。子网的一台主机作为发送发广播一条信息，该子网中的所有主机都可以接收到该信息（不管你是否需要该信息）。<br>在广播模式下，由于服务器不用向每个客户机单独发送数据，所以服务器流量负载极低。<br>无法在广域网上进行广播，而且广播消息不会被路由转发，所以只能在一个子网中进行广播。因为如果路由器转发了广播信息，那么势必会引起网络瘫痪。这也是为什么 IP 协议的设计者故意没有定义互联网范围的广播机制。</p><p>主机发送广播消息时，需要指定目的 IP 地址为<code>255.255.255.255</code>和接受者的端口号。</p><p>UDP 的广播和单播的不同在于发送端（接收端的实现和单播方式没有区别）的实现上：</p><ol><li>发送端将套接字配置为发送广播消息，使用<code>setsockopt</code>函数。</li><li>发送地址更改为受限的广播地址<code>255.255.255.255</code>。</li></ol><blockquote><p>需要说明的是广播地址不仅仅只有<code>255.255.255.255</code>一个。广播地址分为受限的广播、指向网络的广播、指向子网的广播、指向所有子网的网广播。<code>255.255.255.255</code>只是受限的广播地址。</p></blockquote><h4 id="5-2-1-广播发送端"><a href="#5-2-1-广播发送端" class="headerlink" title="5.2.1 广播发送端"></a>5.2.1 广播发送端</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendLogic</span><span class="params">()</span> </span>{</span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  SOCKET socket = ::<span class="built_in">WSASocket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (socket == INVALID_SOCKET) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"WSASocket failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将套接字配置为发送广播消息</span></span><br><span class="line">  <span class="type">int</span> broadcast = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> err = <span class="built_in">setsockopt</span>(socket, SOL_SOCKET, SO_BROADCAST, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;broadcast), <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  sockaddr_in addr;</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_port = <span class="built_in">htons</span>(<span class="number">6000</span>);</span><br><span class="line">  addr.sin_addr.s_addr = INADDR_BROADCAST; <span class="comment">// 也可以换成inet_addr("255.255.255.255")</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>] = { <span class="string">"hello"</span> };</span><br><span class="line">  err = <span class="built_in">sendto</span>(socket, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;addr), <span class="built_in">sizeof</span>(addr));</span><br><span class="line">  <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sendto failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[BROADCAST] %s OK\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">SendLogic</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="5-2-2-广播接收端-和单播一样"><a href="#5-2-2-广播接收端-和单播一样" class="headerlink" title="5.2.2 广播接收端(和单播一样)"></a>5.2.2 广播接收端(和单播一样)</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RecvLogic</span><span class="params">()</span> </span>{</span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  SOCKET socket = ::<span class="built_in">WSASocket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (socket == INVALID_SOCKET) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"WSASocket failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  sockaddr_in addr;</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_port = <span class="built_in">htons</span>(<span class="number">6000</span>);</span><br><span class="line">  addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> err = <span class="built_in">bind</span>(socket, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;addr), <span class="built_in">sizeof</span>(addr));</span><br><span class="line">  <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bind failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>] = { <span class="number">0</span> };</span><br><span class="line">    <span class="type">int</span> fromlen = <span class="built_in">sizeof</span>(addr);</span><br><span class="line">    err = <span class="built_in">recvfrom</span>(socket, buf, <span class="number">100</span>, <span class="number">0</span>, <span class="built_in">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;addr), &amp;fromlen);</span><br><span class="line">    <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"recvfrom failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[RECV] %s\n"</span>, buf);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">RecvLogic</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="5-3-组播"><a href="#5-3-组播" class="headerlink" title="5.3 组播"></a>5.3 组播</h3><p>组播是主机之间“一对多”的通讯模式。一台主机加入一个组播 IP 后，之后向该组播 IP 发送的数据报都会发送到该主机。<br>专门为组播划出了一个地址范围，在 IPv4 中为 D 类地址，范围是<code>224.0.0.0 ~ 239.255.255.255</code>，并将 D 类地址划分为局部链接组播地址、预留组播地址、管理权限组播地址如下：<br>局部链接地址：<code>224.0.0.0～224.0.0.255</code>，用于局域网，路由器不转发属于此范围的 IP 包。</p><p>预留组播地址：<code>224.0.1.0～238.255.255.255</code>，用于全球范围或网络协议。</p><p>管理权限地址：<code>239.0.0.0～239.255.255.255</code>，组织内部使用，用于限制组播范围。</p><p>组播就是将数据发送到一组主机。接收端如果要接收消息，则需要加入到该分组，分组是用 IP 来标识的。<br>从<a href="/post/2274025898.html" title="网络协议(3)--IP协议">网络协议(3)--IP协议</a>可以知道，适用于分组的 IP 有<code>224.0.0.0 ~ 239.255.255.255</code>。<br>同样，发送端就需要将数据发送到该分组 IP。</p><h4 id="5-3-1-组播发送端"><a href="#5-3-1-组播发送端" class="headerlink" title="5.3.1 组播发送端"></a>5.3.1 组播发送端</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendLogic</span><span class="params">()</span> </span>{</span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  SOCKET socket = ::<span class="built_in">WSASocket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (socket == INVALID_SOCKET) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"WSASocket failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将套接字配置为发送广播消息</span></span><br><span class="line">  <span class="type">int</span> broadcast = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> err = <span class="built_in">setsockopt</span>(socket, SOL_SOCKET, SO_BROADCAST, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;broadcast), <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  sockaddr_in addr;</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_port = <span class="built_in">htons</span>(<span class="number">6000</span>);</span><br><span class="line">  addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">"225.0.0.37"</span>); <span class="comment">// 向指定广播组发送消息</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>] = { <span class="string">"hello"</span> };</span><br><span class="line">  err = <span class="built_in">sendto</span>(socket, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;addr), <span class="built_in">sizeof</span>(addr));</span><br><span class="line">  <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sendto failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[BROADCAST] %s OK\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">SendLogic</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="5-3-2-组播接收端"><a href="#5-3-2-组播接收端" class="headerlink" title="5.3.2 组播接收端"></a>5.3.2 组播接收端</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ws2ipdef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RecvLogic</span><span class="params">()</span> </span>{</span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  SOCKET socket = ::<span class="built_in">WSASocket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (socket == INVALID_SOCKET) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"WSASocket failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  sockaddr_in addr;</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_port = <span class="built_in">htons</span>(<span class="number">6000</span>);</span><br><span class="line">  addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> err = <span class="built_in">bind</span>(socket, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;addr), <span class="built_in">sizeof</span>(addr));</span><br><span class="line">  <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bind failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将SOCKET加入广播组</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ip_mreq</span> mreq; <span class="comment">// 引入头文件&lt;Ws2ipdef.h&gt;</span></span><br><span class="line">  mreq.imr_multiaddr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">"225.0.0.37"</span>);  <span class="comment">// 广播组地址</span></span><br><span class="line">  mreq.imr_interface.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注：使用IP_DROP_MEMBERSHIP可以离开广播组</span></span><br><span class="line">  err = <span class="built_in">setsockopt</span>(socket, IPPROTO_IP, IP_ADD_MEMBERSHIP, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;mreq), <span class="built_in">sizeof</span>(ip_mreq));</span><br><span class="line">  <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>] = { <span class="number">0</span> };</span><br><span class="line">    <span class="type">int</span> fromlen = <span class="built_in">sizeof</span>(addr);</span><br><span class="line">    err = <span class="built_in">recvfrom</span>(socket, buf, <span class="number">100</span>, <span class="number">0</span>, <span class="built_in">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;addr), &amp;fromlen);</span><br><span class="line">    <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"recvfrom failed, error=%d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[RECV] %s\n"</span>, buf);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">RecvLogic</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>《TCP/IP 详解 卷 1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p></blockquote><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(4)--ICMP协议</title>
      <link href="/post/349088656.html"/>
      <url>/post/349088656.html</url>
      
        <content type="html"><![CDATA[<p>互联网控制消息协议（英文：<code>Internet Control Message Protocol</code>，ICMP）是互联网协议族的核心协议之一。定义在 RFC 792 文档中。<br>ICMP 的消息大致可以分为两类：一类是差错报文，即通知出错原因的错误消息（如<code>traceroute</code>），另一类是查询报文，即用于诊断的查询消息（如<code>ping</code>）。<br>使用 ICMP 协议的典型应用有<code>ping</code>和<code>traceroute</code>（windows 上叫<code>tracert</code>）。</p><span id="more"></span><p><strong>ICMP 是在 IP 数据报的内部被传输的，紧跟着 IP 报文的首部（如果 IP 首部有可选部分，则紧跟着可选部分）</strong>：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-icmp-1.jpg"><br><strong>图上的 IP 首部 20 字节是在 IP 报文首部不含可选部分的情况下，若 IP 首部含可选部分，则大于 20 字节。</strong></p><h1 id="一、-ICMP-报文格式"><a href="#一、-ICMP-报文格式" class="headerlink" title="一、 ICMP 报文格式"></a>一、 ICMP 报文格式</h1><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-icmp-2.jpg"><br><strong>所有 ICMP 报文的前 4 个字节都是一样的，但剩下的其他字节则根据报文类型的不同而不同。</strong></p><ul><li><p><code>8位类型字段</code>和<code>8位代码字段</code>共同决定一种 ICMP 报文的类型。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-icmp-3.jpg"></p></li><li><p>校验和的计算方法和 IP 首部校验和的计算方式相同，但 ICMP 校验和覆盖整个 ICMP 报文。</p><blockquote><p>IP 首部校验和的计算方式和原理参考：<a href="/post/2274025898.html" title="网络协议(3)--IP协议">网络协议(3)--IP协议</a><br>UDP 和 TCP 的校验和同样也都覆盖到了他们的首部和数据。</p></blockquote></li></ul><blockquote><p>《TCP/IP 详解 卷 1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p></blockquote><h1 id="二、实际应用"><a href="#二、实际应用" class="headerlink" title="二、实际应用"></a>二、实际应用</h1><h2 id="2-1-Ping"><a href="#2-1-Ping" class="headerlink" title="2.1 Ping"></a>2.1 Ping</h2><h3 id="2-1-1-Ping-程序原理"><a href="#2-1-1-Ping-程序原理" class="headerlink" title="2.1.1 Ping 程序原理"></a>2.1.1 Ping 程序原理</h3><p>大多数系统都已经在内核中内置了 ping 服务器的功能，所以不需要单独的其他进程来接收主机的 ping 请求。</p><p>windows 系统下，输入<code>ping /?</code>命令查看 ping 的用法如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">用法: ping [-t] [-a] [-n count] [-l size] [-f] [-i TTL] [-v TOS]</span><br><span class="line">           [-r count] [-s count] [[-j host-list] | [-k host-list]]</span><br><span class="line">           [-w timeout] [-R] [-S srcaddr] [-4] [-6] target_name</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line">    -t             Ping 指定的主机，直到停止。</span><br><span class="line">                   若要查看统计信息并继续操作 - 请键入 Control-Break；</span><br><span class="line">                   若要停止 - 请键入 Control-C。</span><br><span class="line">    -a             将地址解析成主机名。</span><br><span class="line">    -n count       要发送的回显请求数。</span><br><span class="line">    -l size        发送缓冲区大小。</span><br><span class="line">    -f             在数据包中设置“不分段”标志(仅适用于 IPv4)。</span><br><span class="line">    -i TTL         生存时间。</span><br><span class="line">    -v TOS         服务类型(仅适用于 IPv4。该设置已不赞成使用，且</span><br><span class="line">                   对 IP 标头中的服务字段类型没有任何影响)。</span><br><span class="line">    -r count       记录计数跃点的路由(仅适用于 IPv4)。</span><br><span class="line">    -s count       计数跃点的时间戳(仅适用于 IPv4)。</span><br><span class="line">    -j host-list   与主机列表一起的松散源路由(仅适用于 IPv4)。</span><br><span class="line">    -k host-list   与主机列表一起的严格源路由(仅适用于 IPv4)。</span><br><span class="line">    -w timeout     等待每次回复的超时时间(毫秒)。</span><br><span class="line">    -R             同样使用路由标头测试反向路由(仅适用于 IPv6)。</span><br><span class="line">    -S srcaddr     要使用的源地址。</span><br><span class="line">    -4             强制使用 IPv4。</span><br><span class="line">    -6             强制使用 IPv6。</span><br></pre></td></tr></tbody></table></figure><p>其中<code>-r</code>参数用于记录跃点路由，类似 tracert 的功能，但他们的实现方式不一样，ping 是通过在 IP 头部“选项”字段记录经过的每个路由的 IP 来实现记录路由功能的，这种实现有个限制，就是 IP 首部“选项”字段的最大字节数为 40 字节，所以最多只能记录 10 个 IP。</p><p>ping 功能通过 ICMP 的回显请求和回显应答来实现，也就是说 ping 是基于 ICMP 协议实现的。</p><p>ICMP 回显请求和回显应答的报文格式如下：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-icmp-4.jpg"></p><ul><li>标识符：在实现中，一般将该字段设置为当前进程 ID。这样即使在同一台主机上同时运行了多个 ping 程序实例， ping 程序也可以识别出返回的信息属于哪个进程。</li><li>序号：序号一般从 0 开始（没有强制性，从任何数字开始都可以），每发送一次新的回显请求就加 1。因为 ICMP 是在 IP 数据报内部被传输的，而 IP 协议又是不可靠、无连接的，所以 ping 程序打印出返回的每个分组的序列号，方便我们查看是否有分组丢失、失序或重复。</li><li>选项：在“选项”字段中，我们一般放入发送时间戳，这样在收到回应的时候可以用来计算本次 ping 的耗时。我们经常会指定 ping 包的大小，所以也会在“选项”字段中填充一些废数据来让包达到一定大小，在下面的<code>FillPingPacket</code>函数就有这样的实现。</li></ul><h3 id="2-1-2-C-代码实现"><a href="#2-1-2-C-代码实现" class="headerlink" title="2.1.2 C++代码实现"></a>2.1.2 C++代码实现</h3><h4 id="定义-ICMP、ping-首部"><a href="#定义-ICMP、ping-首部" class="headerlink" title="定义 ICMP、ping 首部"></a>定义 ICMP、ping 首部</h4><p><code>networkprotocolheader.h</code>头文件中定义了 IP 协议、ICMP 协议等协议的首部结构体。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __u8 unsigned char</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __u16 unsigned short</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __u32 unsigned long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">icmp_common_hdr</span> {</span><br><span class="line">  __u8 type;</span><br><span class="line">  __u8 code;</span><br><span class="line">  __u16 check;</span><br><span class="line">  <span class="comment">/*Other content start here. */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ping_header</span> {</span><br><span class="line">  icmp_common_hdr common_hdr;</span><br><span class="line">  __u16 id;</span><br><span class="line">  __u16 seq;</span><br><span class="line">  __u32 timestamp;</span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br></pre></td></tr></tbody></table></figure><h4 id="程序执行参数"><a href="#程序执行参数" class="headerlink" title="程序执行参数"></a>程序执行参数</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DECLARE_bool</span>(h); <span class="comment">// 帮助</span></span><br><span class="line"><span class="built_in">DECLARE_bool</span>(t); <span class="comment">// ping指定的主机直到停止</span></span><br><span class="line"><span class="built_in">DECLARE_int</span>(w);  <span class="comment">// 等待每次回复的超时时间(毫秒)</span></span><br><span class="line"><span class="built_in">DECLARE_int</span>(s);  <span class="comment">// 发送ping包超时时间(毫秒)</span></span><br><span class="line"><span class="built_in">DECLARE_int</span>(l);  <span class="comment">// 发送缓冲区大小</span></span><br><span class="line"><span class="built_in">DECLARE_int</span>(i);  <span class="comment">// TTL</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_bool</span>(h, <span class="literal">false</span>, <span class="string">"帮助"</span>);</span><br><span class="line"><span class="built_in">DEFINE_bool</span>(t, <span class="literal">false</span>, <span class="string">"ping指定的主机直到停止"</span>);</span><br><span class="line"><span class="built_in">DEFINE_int</span>(w, <span class="number">3000</span>, <span class="string">"等待每次回复的超时时间(毫秒)"</span>);</span><br><span class="line"><span class="built_in">DEFINE_int</span>(s, <span class="number">3000</span>, <span class="string">"发送ping包超时时间(毫秒)"</span>);</span><br><span class="line"><span class="built_in">DEFINE_int</span>(l, <span class="number">32</span>, <span class="string">"发送缓冲区大小"</span>);</span><br><span class="line"><span class="built_in">DEFINE_int</span>(i, <span class="number">128</span>, <span class="string">"TTL"</span>);</span><br></pre></td></tr></tbody></table></figure><p>ping 程序的执行参数的定义和解析由 webrtc 的<code>"rtc_base/flags.h"</code>支持。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>代码中的某些功能，如参数解析、断言、时间戳等基于 webrtc 的<code>rtc_base</code>实现，这些功能也可以很方便的自己实现。</p><p>另外，使用原始套接字需要管理员权限，如果需要绕开管理员权限，可以使用 windows 提供的<code>IcmpSendEcho</code>系列函数。</p><p><strong>在发送 ping 请求的时候，我们只封装了一个 ICMP 报文，并没有自己手动添加 IP 头，封装 IP 报文。因为内核会自动添加 IP 头，如果想自己添加 IP 头，可以调用<code>setsockopt</code>设置<code>IP_HDRINCL</code>选项，告诉内核由我们自己来封装 IP 头。</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2spi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtc_base/networkprotocolheader.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtc_base/checks.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtc_base/flags.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtc_base/timeutils.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DECLARE_bool</span>(h); <span class="comment">// 帮助</span></span><br><span class="line"><span class="built_in">DECLARE_bool</span>(t); <span class="comment">// ping指定的主机直到停止</span></span><br><span class="line"><span class="built_in">DECLARE_int</span>(w);  <span class="comment">// 等待每次回复的超时时间(毫秒)</span></span><br><span class="line"><span class="built_in">DECLARE_int</span>(s);  <span class="comment">// 发送ping包超时时间(毫秒)</span></span><br><span class="line"><span class="built_in">DECLARE_int</span>(l);  <span class="comment">// 发送缓冲区大小</span></span><br><span class="line"><span class="built_in">DECLARE_int</span>(i);  <span class="comment">// TTL</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_bool</span>(h, <span class="literal">false</span>, <span class="string">"帮助"</span>);</span><br><span class="line"><span class="built_in">DEFINE_bool</span>(t, <span class="literal">false</span>, <span class="string">"ping指定的主机直到停止"</span>);</span><br><span class="line"><span class="built_in">DEFINE_int</span>(w, <span class="number">3000</span>, <span class="string">"等待每次回复的超时时间(毫秒)"</span>);</span><br><span class="line"><span class="built_in">DEFINE_int</span>(s, <span class="number">3000</span>, <span class="string">"发送ping包超时时间(毫秒)"</span>);</span><br><span class="line"><span class="built_in">DEFINE_int</span>(l, <span class="number">32</span>, <span class="string">"发送数据大小"</span>);</span><br><span class="line"><span class="built_in">DEFINE_int</span>(i, <span class="number">128</span>, <span class="string">"TTL"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FillPingPacket</span><span class="params">(__u8* icmp_packet, __u16 seq, __u16 icmp_packet_size)</span> </span>{</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(icmp_packet);</span><br><span class="line">  ping_hdr* pping_hdr = <span class="built_in">reinterpret_cast</span>&lt;ping_hdr*&gt;(icmp_packet);</span><br><span class="line">  pping_hdr-&gt;common_hdr.type = <span class="number">8</span>;</span><br><span class="line">  pping_hdr-&gt;common_hdr.code = <span class="number">0</span>;</span><br><span class="line">  pping_hdr-&gt;id = (__u16)<span class="built_in">GetCurrentProcessId</span>();</span><br><span class="line">  pping_hdr-&gt;seq = seq;</span><br><span class="line">  __u32 now = rtc::<span class="built_in">Time32</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>((icmp_packet + <span class="built_in">sizeof</span>(ping_hdr)), &amp;now, <span class="built_in">sizeof</span>(__u32));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fill some junk in the buffer.</span></span><br><span class="line">  <span class="type">int</span> junk_data_size = FLAG_l - <span class="built_in">sizeof</span>(__u32); <span class="comment">// timestamp</span></span><br><span class="line">  <span class="type">int</span> junk_offset = icmp_packet_size - junk_data_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(junk_data_size &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">memset</span>((icmp_packet + junk_offset), <span class="string">'E'</span>, junk_data_size);</span><br><span class="line"></span><br><span class="line">  pping_hdr-&gt;common_hdr.check = <span class="number">0</span>;</span><br><span class="line">  pping_hdr-&gt;common_hdr.check = rtc::<span class="built_in">GetCheckSum</span>(<span class="built_in">reinterpret_cast</span>&lt;__u16*&gt;(icmp_packet), icmp_packet_size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DecodeIPPacket</span><span class="params">(__u8* ip_packet, __u16 packet_size)</span> </span>{</span><br><span class="line">  iphdr* ip_hdr = <span class="built_in">reinterpret_cast</span>&lt;iphdr*&gt;(ip_packet);</span><br><span class="line">  __u32 now = rtc::<span class="built_in">Time32</span>();</span><br><span class="line"></span><br><span class="line">  __u16 ip_hdr_len = ip_hdr-&gt;ihl * <span class="number">4</span>; <span class="comment">// bytes</span></span><br><span class="line"></span><br><span class="line">  ping_hdr *pping_hdr = <span class="built_in">reinterpret_cast</span>&lt;ping_hdr*&gt;(ip_packet + ip_hdr_len);</span><br><span class="line">  <span class="keyword">if</span> (pping_hdr-&gt;common_hdr.type != <span class="number">0</span> || pping_hdr-&gt;common_hdr.code != <span class="number">0</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"non-echo response, type=%d, code=%d\n"</span>, pping_hdr-&gt;common_hdr.type, pping_hdr-&gt;common_hdr.code);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pping_hdr-&gt;id != (__u16)<span class="built_in">GetCurrentProcessId</span>()) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"other process ping response packet, pid=%d\n"</span>, <span class="built_in">GetCurrentProcessId</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  __u32 timestamp = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;timestamp, <span class="built_in">reinterpret_cast</span>&lt;__u32*&gt;((__u8*)pping_hdr + <span class="built_in">sizeof</span>(ping_hdr)), <span class="built_in">sizeof</span>(__u32));</span><br><span class="line"></span><br><span class="line">  in_addr from;</span><br><span class="line">  from.s_addr = ip_hdr-&gt;saddr;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d bytes from %s, time &lt; %d ms, icmp_seq = %d, TTL = %d \n"</span>,</span><br><span class="line">    packet_size - ip_hdr_len - <span class="built_in">sizeof</span>(ping_hdr),</span><br><span class="line">    <span class="built_in">inet_ntoa</span>(from),</span><br><span class="line">    now - timestamp,</span><br><span class="line">    pping_hdr-&gt;seq,</span><br><span class="line">    ip_hdr-&gt;ttl</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>**argv)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  rtc::FlagList::<span class="built_in">SetFlagsFromCommandLine</span>(&amp;argc, argv, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (FLAG_h) {</span><br><span class="line">    rtc::FlagList::<span class="built_in">Print</span>(<span class="literal">NULL</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *hostname = argv[argc - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (!hostname || <span class="built_in">strlen</span>(hostname) == <span class="number">0</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Invalid host name\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FLAG_l &lt;= <span class="number">4</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  sockaddr_in from;</span><br><span class="line">  <span class="type">int</span> from_len = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line"></span><br><span class="line">  sockaddr_in dest;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;dest, <span class="number">0</span>, <span class="built_in">sizeof</span>(sockaddr_in));</span><br><span class="line">  dest.sin_family = AF_INET;</span><br><span class="line">  dest.sin_addr.s_addr = <span class="built_in">inet_addr</span>(hostname);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve host name</span></span><br><span class="line">  <span class="keyword">if</span> (dest.sin_addr.s_addr == INADDR_NONE) {</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> begin_time = rtc::<span class="built_in">Time32</span>();</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span>* result = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span> hints = { <span class="number">0</span> };</span><br><span class="line">    hints.ai_family = AF_UNSPEC;</span><br><span class="line"></span><br><span class="line">    hints.ai_flags = AI_ADDRCONFIG;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">getaddrinfo</span>(hostname, <span class="literal">nullptr</span>, &amp;hints, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Resolve host name failed, error code = %d\n"</span>, ret);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> end_time = rtc::<span class="built_in">Time32</span>();</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span>* cursor = result;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------------------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Resolve [time &lt; %d ms]: \n"</span>, end_time - begin_time);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (; cursor; cursor = cursor-&gt;ai_next) {</span><br><span class="line">      sockaddr_in *paddr_in = <span class="built_in">reinterpret_cast</span>&lt;sockaddr_in *&gt;(cursor-&gt;ai_addr);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="built_in">inet_ntoa</span>(paddr_in-&gt;sin_addr));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!flag) {</span><br><span class="line">        dest.sin_addr = paddr_in-&gt;sin_addr;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">freeaddrinfo</span>(result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-------------------------------\n"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Ping %s [TTL %d]: \n"</span>, <span class="built_in">inet_ntoa</span>(dest.sin_addr), FLAG_i);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// socket函数需要管理员权限</span></span><br><span class="line">  <span class="comment">// 需要绕开管理员权限，可以使用IcmpSendEcho系列函数</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  SOCKET s = <span class="built_in">socket</span>(AF_INET, SOCK_RAW, IPPROTO_ICMP);</span><br><span class="line">  <span class="keyword">if</span> (s == INVALID_SOCKET) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create socket failed, error code = %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> err = <span class="built_in">setsockopt</span>(s, SOL_SOCKET, SO_SNDTIMEO, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;FLAG_s), <span class="built_in">sizeof</span>(FLAG_s));</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(err != SOCKET_ERROR);</span><br><span class="line">  <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt for SO_SNDTIMEO failed, error code = %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="built_in">closesocket</span>(s);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  err = <span class="built_in">setsockopt</span>(s, SOL_SOCKET, SO_RCVTIMEO, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;FLAG_w), <span class="built_in">sizeof</span>(FLAG_w));</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(err != SOCKET_ERROR);</span><br><span class="line">  <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt for SO_RCVTIMEO failed, error code = %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="built_in">closesocket</span>(s);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  err = <span class="built_in">setsockopt</span>(s, IPPROTO_IP, IP_TTL, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;FLAG_i), <span class="built_in">sizeof</span>(FLAG_i));</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(err != SOCKET_ERROR);</span><br><span class="line">  <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt for IP_TTL failed, error code = %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="built_in">closesocket</span>(s);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ping request</span></span><br><span class="line">  <span class="type">int</span> icmp_packet_size = <span class="built_in">sizeof</span>(ping_hdr)</span><br><span class="line">    + FLAG_l; <span class="comment">// data</span></span><br><span class="line"></span><br><span class="line">  __u8 *icmp_packet = <span class="keyword">new</span> __u8[icmp_packet_size];</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(icmp_packet);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ping response</span></span><br><span class="line">  __u16 ip_packet_size = icmp_packet_size + <span class="number">20</span>; <span class="comment">// 20 bytes ip header, no option.</span></span><br><span class="line">  __u8 *ip_packet = <span class="keyword">new</span> __u8[ip_packet_size];</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(ip_packet);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!icmp_packet || !ip_packet) {</span><br><span class="line">    <span class="built_in">closesocket</span>(s);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  __u16 i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0xFFFF</span>)</span><br><span class="line">      i = <span class="number">0</span>;</span><br><span class="line">    i++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!FLAG_t) {</span><br><span class="line">      <span class="keyword">if</span>(i &gt; <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FillPingPacket</span>(icmp_packet, i, icmp_packet_size);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sent = <span class="built_in">sendto</span>(s,</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(icmp_packet),</span><br><span class="line">      icmp_packet_size,</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;dest),</span><br><span class="line">      <span class="built_in">sizeof</span>(sockaddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sent == SOCKET_ERROR) {</span><br><span class="line">      <span class="type">int</span> gle = <span class="built_in">WSAGetLastError</span>();</span><br><span class="line">      <span class="keyword">if</span> (gle == WSAETIMEDOUT) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"request timeout\n"</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ping %s failed, error code = %d\n"</span>, <span class="built_in">inet_ntoa</span>(dest.sin_addr), gle);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sent &lt; FLAG_l) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"warning, sent %d bytes\n"</span>, sent);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bread = <span class="built_in">recvfrom</span>(s,</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ip_packet),</span><br><span class="line">      ip_packet_size,</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;from),</span><br><span class="line">      &amp;from_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bread == SOCKET_ERROR) {</span><br><span class="line">      <span class="type">int</span> gle = <span class="built_in">WSAGetLastError</span>();</span><br><span class="line">      <span class="keyword">if</span> (gle == WSAETIMEDOUT) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"receive timeout\n"</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ping %s failed, error code = %d\n"</span>, <span class="built_in">inet_ntoa</span>(dest.sin_addr), gle);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bread &lt; ip_packet_size) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"too few bytes from %s\n"</span>, <span class="built_in">inet_ntoa</span>(from.sin_addr));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DecodeIPPacket</span>(<span class="built_in">reinterpret_cast</span>&lt;__u8*&gt;(ip_packet), ip_packet_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> [] icmp_packet;</span><br><span class="line">  <span class="keyword">delete</span> [] ip_packet;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s != INVALID_SOCKET) {</span><br><span class="line">    <span class="built_in">closesocket</span>(s);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h4><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-icmp-5.jpg"></p><h2 id="2-2-Tracert"><a href="#2-2-Tracert" class="headerlink" title="2.2 Tracert"></a>2.2 Tracert</h2><p>Tracert 是 windows 系统提供的一个工具，使用该程序可以让我们看到 IP 数据报从一台主机到另一台主机所经过的路由器。Linux 系统也提供了类似的工具，叫 traceroute，功能和 Tracert 一样。</p><h3 id="2-2-1-Tracert-原理"><a href="#2-2-1-Tracert-原理" class="headerlink" title="2.2.1 Tracert 原理"></a>2.2.1 Tracert 原理</h3><p>在介绍 Tracert 的原理之前，需要先弄清楚 IP 首部 TTL 字段的含义，IP 报文每经过一个路由器，路由器都会将该 IP 报文首部的 TTL 字段减 1，<br>当路由器收到一份 IP 数据报的 TTL 是 0 或 1 时，路由器此时不会转发该数据报，而会丢弃该数据报，并且给 IP 数据报首部中的源地址发送一份 ICMP 超时报文。</p><blockquote><p>IP 首部的定义见：<a href="/post/2274025898.html" title="网络协议(3)--IP协议">网络协议(3)--IP协议</a></p></blockquote><p>Tracert 利用了路由器会丢弃 TTL 为 1 或 0 的数据报且返回 ICMP 超时报文的特性，来实现侦测路由的功能。Tracert 程序先发送 TTL 值为 1 的 IP 数据报，处理这份数据报的第一个路由器将 TTL 减 1，丢弃该数据报并返回 ICMP 超时报文，这样程序就得到了第一个路由器的地址，以此方式，递增 IP 数据报 TTL 的值，直到数据报最终到达目标主机。</p><p><strong>那么怎么判断数据报到达了最终的目标主机呢？</strong><br>我们不能单纯的通过未收到路由器返回的 ICMP 差错报文的方式来判断数据报到达目的地了，因为有可能我们由于接收 ICMP 差错报文超时等原因导致我们收不到 ICMP 差错报文（这也是为什么我们后面会介绍每一个 TTL 跃点会发送 3 次或多次请求的原因）。windows 平台的 tracert 与 linux 平台的 traceroute 的实现原理稍有不同，判断数据报到达目标主机的方式也有不同。<br>tracert 是通过发送 ping 包，因为 windows 系统内核都实现了 ping 功能，所以如果目的主机收到了 ping 请求就会回复相应的 ping 包，tracert 就是通过这种方式来判断数据报是否到达了目标主机。而 traceroute 是通过发送 UDP 包（UDP 端口选择一个不可能使用的 UDP 端口，比如大于 30000 的端口），因为目的主机没有监听该端口，所以不会响应接收到的该 UDP 请求，因此当 UDP 包到达时，目标主机会返回“端口不可达”的错误，traceroute 就是通过该错误来判断 UDP 包到达了目的主机。</p><p>从实现方式来看，traceroute 通过 UDP 的方式来实现更加稳定可靠，因为大多数主机的防火墙会组织 ICMP 报文，而不会阻止 UDP 报文。</p><p>下图使用 wireshark 抓取的<code>tracert 192.168.3.76</code>命令的数据包，从图中可以看到 tracert 是通过发送 ping 包来实现的，以及每个 ping 包的 TTL 递增过程：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-icmp-6.jpg"></p><h3 id="2-2-2-ICMP-差错报文格式"><a href="#2-2-2-ICMP-差错报文格式" class="headerlink" title="2.2.2 ICMP 差错报文格式"></a>2.2.2 ICMP 差错报文格式</h3><p>路由器在丢弃 TTL 为 0 或 1 的数据报时，会发送一个一份 ICMP 差错报文，该 ICMP 的差错报文的 type 为 11, code 为 0.</p><p>type 为 11 的报文格式如下（code 有 0 和 1 两种，格式一样）：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-icmp-7.jpg"></p><h3 id="2-2-3-实现"><a href="#2-2-3-实现" class="headerlink" title="2.2.3 实现"></a>2.2.3 实现</h3><p>该示例和之前的 Ping 程序的示例有所不同，该示例设置了<code>IP_HDRINCL</code>选项来自己构造 IP 头部。</p><p>程序的启动参数使用 webrtc 的<code>"rtc_base/flags.h"</code>实现。</p><p>代码中的其他某些功能，如断言、时间戳等基于 webrtc 的<code>rtc_base</code>实现，这些功能也可以很方便的自己实现。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2spi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtc_base/networkprotocolheader.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtc_base/checks.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtc_base/flags.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"rtc_base/timeutils.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DECLARE_bool</span>(h); <span class="comment">// 帮助</span></span><br><span class="line"><span class="built_in">DECLARE_int</span>(m);  <span class="comment">// 最大跃点数</span></span><br><span class="line"><span class="built_in">DECLARE_int</span>(w);  <span class="comment">// 等待每次回复的超时时间(毫秒)</span></span><br><span class="line"><span class="built_in">DECLARE_int</span>(s);  <span class="comment">// 发送ICMP包超时时间(毫秒)</span></span><br><span class="line"><span class="built_in">DECLARE_int</span>(n);  <span class="comment">// 每个跃点发送的请求数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_bool</span>(h, <span class="literal">false</span>, <span class="string">"帮助"</span>);</span><br><span class="line"><span class="built_in">DEFINE_int</span>(m, <span class="number">30</span>, <span class="string">"最大跃点数"</span>);</span><br><span class="line"><span class="built_in">DEFINE_int</span>(w, <span class="number">3000</span>, <span class="string">"等待每次回复的超时时间(毫秒)"</span>);</span><br><span class="line"><span class="built_in">DEFINE_int</span>(s, <span class="number">3000</span>, <span class="string">"发送ICMP包超时时间(毫秒)"</span>);</span><br><span class="line"><span class="built_in">DEFINE_int</span>(n, <span class="number">3</span>, <span class="string">"每个跃点发送的请求数"</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kPingDataSize = <span class="number">36</span>;</span><br><span class="line">__u32 kLocalIP = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">__u32 <span class="title">GetLocalIPv4Address</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">inet_addr</span>(<span class="string">"192.168.42.26"</span>);</span><br><span class="line">  <span class="type">char</span> hostname[MAX_PATH] = { <span class="number">0</span> };</span><br><span class="line">  <span class="built_in">gethostname</span>(hostname, MAX_PATH);</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">hostent</span> FAR* lpHostEnt = <span class="built_in">gethostbyname</span>(hostname);</span><br><span class="line">  <span class="keyword">if</span> (lpHostEnt == <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">htonl</span>(<span class="number">0x7f000001</span>); <span class="comment">//127.0.0.1</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  LPSTR lpAddr = lpHostEnt-&gt;h_addr_list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">in_addr</span> addr;</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;addr, lpAddr, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> addr.s_addr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">IPv4ToString</span><span class="params">(__u32 ip)</span> </span>{</span><br><span class="line">  in_addr addr;</span><br><span class="line">  addr.s_addr = ip;</span><br><span class="line">  <span class="type">char</span> *p= <span class="built_in">inet_ntoa</span>(addr);</span><br><span class="line">  <span class="keyword">if</span> (p)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">GetPrintString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* fmt, ...)</span> </span>{</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  va_list arglist;</span><br><span class="line">  <span class="built_in">va_start</span>(arglist, fmt);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">StringCchVPrintfA</span>(buf, <span class="number">100</span>, fmt, arglist);</span><br><span class="line">  <span class="built_in">va_end</span>(arglist);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">print_ip</span><span class="params">(__u32* ips, <span class="type">int</span> count, __u32 dest_ip)</span> </span>{</span><br><span class="line">  <span class="type">bool</span> has_ip = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">bool</span> trace_end = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">    <span class="keyword">if</span> (ips[i] != <span class="number">0</span>) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"  %s"</span>, <span class="built_in">IPv4ToString</span>(ips[i]).<span class="built_in">c_str</span>());</span><br><span class="line">      has_ip = <span class="literal">true</span>;</span><br><span class="line">      trace_end = (ips[i] == dest_ip);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (!has_ip)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  timeout"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trace_end)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Trace Complete\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> trace_end;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FillRequestIPPacket</span><span class="params">(__u8* ip_packet, __u16 ip_packet_size, __u16 seq, __u8 ttl, __u32 dest_addr)</span> </span>{</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(ip_packet);</span><br><span class="line"></span><br><span class="line">  iphdr* p_iphdr = <span class="built_in">reinterpret_cast</span>&lt;iphdr*&gt;(ip_packet);</span><br><span class="line">  <span class="built_in">memset</span>(p_iphdr, <span class="number">0</span>, <span class="built_in">sizeof</span>(iphdr));</span><br><span class="line">  p_iphdr-&gt;version = <span class="number">4</span>;</span><br><span class="line">  p_iphdr-&gt;ihl = <span class="built_in">sizeof</span>(iphdr)/<span class="number">4</span>; <span class="comment">// no option</span></span><br><span class="line">  p_iphdr-&gt;tos = <span class="number">0</span>;</span><br><span class="line">  p_iphdr-&gt;frag_off = <span class="number">0</span>;</span><br><span class="line">  p_iphdr-&gt;id = (__u16)rtc::<span class="built_in">Time32</span>();</span><br><span class="line">  p_iphdr-&gt;ttl = ttl;</span><br><span class="line">  p_iphdr-&gt;protocol = IPPROTO_ICMP;</span><br><span class="line">  p_iphdr-&gt;tot_len = ip_packet_size;</span><br><span class="line">  p_iphdr-&gt;daddr = dest_addr;</span><br><span class="line">  p_iphdr-&gt;saddr = kLocalIP;</span><br><span class="line">  p_iphdr-&gt;check = rtc::<span class="built_in">GetCheckSum</span>(<span class="built_in">reinterpret_cast</span>&lt;__u16*&gt;(p_iphdr), p_iphdr-&gt;ihl*<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  ping_hdr* p_ping_hdr = <span class="built_in">reinterpret_cast</span>&lt;ping_hdr*&gt;(ip_packet + p_iphdr-&gt;ihl*<span class="number">4</span>);</span><br><span class="line">  p_ping_hdr-&gt;common_hdr.type = <span class="number">8</span>;</span><br><span class="line">  p_ping_hdr-&gt;common_hdr.code = <span class="number">0</span>;</span><br><span class="line">  p_ping_hdr-&gt;id = (__u16)<span class="built_in">GetCurrentProcessId</span>();</span><br><span class="line">  p_ping_hdr-&gt;seq = seq;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fill some junk in the buffer.</span></span><br><span class="line">  <span class="keyword">if</span> (kPingDataSize &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span>*)((__u8*)p_ping_hdr+<span class="built_in">sizeof</span>(ping_hdr)), <span class="string">'E'</span>, kPingDataSize);</span><br><span class="line"></span><br><span class="line">  p_ping_hdr-&gt;common_hdr.check = <span class="number">0</span>;</span><br><span class="line">  p_ping_hdr-&gt;common_hdr.check = rtc::<span class="built_in">GetCheckSum</span>(<span class="built_in">reinterpret_cast</span>&lt;__u16*&gt;(p_ping_hdr), ip_packet_size - p_iphdr-&gt;ihl*<span class="number">4</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// return source ip address</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DecodeIPPacket</span><span class="params">(<span class="type">const</span> __u8* ip_packet, __u16 ip_packet_size, __u32 send_time, __u32* src_addr)</span> </span>{</span><br><span class="line">  <span class="type">const</span> iphdr* ip_hdr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> iphdr*&gt;(ip_packet);</span><br><span class="line">  __u32 use_time = rtc::<span class="built_in">Time32</span>() - send_time;</span><br><span class="line"></span><br><span class="line">  __u16 ip_hdr_len = ip_hdr-&gt;ihl * <span class="number">4</span>; <span class="comment">// bytes</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> icmp_common_hdr *icmp_hdr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> icmp_common_hdr*&gt;(ip_packet + ip_hdr_len);</span><br><span class="line">  <span class="keyword">if</span> (icmp_hdr-&gt;type == <span class="number">0</span> &amp;&amp; icmp_hdr-&gt;code == <span class="number">0</span>) { <span class="comment">// 回显应答</span></span><br><span class="line">    <span class="type">const</span> ping_hdr *p_ping_hdr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> ping_hdr*&gt;(icmp_hdr);</span><br><span class="line">    <span class="keyword">if</span> (p_ping_hdr-&gt;id != (__u16)<span class="built_in">GetCurrentProcessId</span>()) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"other process ping response packet, pid=%d\n"</span>, <span class="built_in">GetCurrentProcessId</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-10s"</span>, <span class="built_in">GetPrintString</span>(<span class="string">"&lt;%d ms"</span>, use_time == <span class="number">0</span> ? <span class="number">1</span> : use_time).<span class="built_in">c_str</span>());</span><br><span class="line">    *src_addr = ip_hdr-&gt;saddr;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (icmp_hdr-&gt;type == <span class="number">11</span> &amp;&amp; icmp_hdr-&gt;code == <span class="number">0</span>) { <span class="comment">// cause by ttl == 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-10s"</span>, <span class="built_in">GetPrintString</span>(<span class="string">"&lt;%d ms"</span>, use_time == <span class="number">0</span> ? <span class="number">1</span> : use_time).<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    *src_addr = ip_hdr-&gt;saddr;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"unexpected response, type=%d, code=%d\n"</span>, icmp_hdr-&gt;type, icmp_hdr-&gt;code);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAFE_RELEASE \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (req_ip_packet) { \</span></span><br><span class="line"><span class="meta">delete[] req_ip_packet; \</span></span><br><span class="line"><span class="meta">  req_ip_packet = NULL;\</span></span><br><span class="line"><span class="meta">}\</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (rsp_ip_packet) { \</span></span><br><span class="line"><span class="meta">delete[] rsp_ip_packet; \</span></span><br><span class="line"><span class="meta">  rsp_ip_packet = NULL;\</span></span><br><span class="line"><span class="meta">}\</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (s != INVALID_SOCKET) {\</span></span><br><span class="line"><span class="meta">  closesocket(s);\</span></span><br><span class="line"><span class="meta">  s = INVALID_SOCKET;\</span></span><br><span class="line"><span class="meta">}\</span></span><br><span class="line"><span class="meta">WSACleanup();</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>**argv)</span> </span>{</span><br><span class="line">  rtc::FlagList::<span class="built_in">SetFlagsFromCommandLine</span>(&amp;argc, argv, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (FLAG_h) {</span><br><span class="line">    rtc::FlagList::<span class="built_in">Print</span>(<span class="literal">NULL</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *hostname = argv[argc - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (!hostname || <span class="built_in">strlen</span>(hostname) == <span class="number">0</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Invalid host name\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Trace %s\n"</span>, hostname);</span><br><span class="line"></span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  sockaddr_in from;</span><br><span class="line">  <span class="type">int</span> from_len = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line"></span><br><span class="line">  kLocalIP = <span class="built_in">GetLocalIPv4Address</span>();</span><br><span class="line"></span><br><span class="line">  sockaddr_in dest;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;dest, <span class="number">0</span>, <span class="built_in">sizeof</span>(sockaddr_in));</span><br><span class="line">  dest.sin_family = AF_INET;</span><br><span class="line">  dest.sin_addr.s_addr = <span class="built_in">inet_addr</span>(hostname);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve host name</span></span><br><span class="line">  <span class="keyword">if</span> (dest.sin_addr.s_addr == INADDR_NONE) {</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> begin_time = rtc::<span class="built_in">Time32</span>();</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span>* result = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span> hints = { <span class="number">0</span> };</span><br><span class="line">    hints.ai_family = AF_UNSPEC;</span><br><span class="line"></span><br><span class="line">    hints.ai_flags = AI_ADDRCONFIG;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">getaddrinfo</span>(hostname, <span class="literal">nullptr</span>, &amp;hints, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Resolve host name failed, error code = %d\n"</span>, ret);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> end_time = rtc::<span class="built_in">Time32</span>();</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span>* cursor = result;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------------------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Resolve [time &lt; %d ms]: \n"</span>, end_time - begin_time);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (; cursor; cursor = cursor-&gt;ai_next) {</span><br><span class="line">      sockaddr_in *paddr_in = <span class="built_in">reinterpret_cast</span>&lt;sockaddr_in *&gt;(cursor-&gt;ai_addr);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="built_in">inet_ntoa</span>(paddr_in-&gt;sin_addr));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!flag) {</span><br><span class="line">        dest.sin_addr = paddr_in-&gt;sin_addr;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">freeaddrinfo</span>(result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-------------------------------\n"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Tracing %s [%d max hops]: \n"</span>, <span class="built_in">inet_ntoa</span>(dest.sin_addr), FLAG_m);</span><br><span class="line"></span><br><span class="line">  SOCKET s = <span class="built_in">socket</span>(AF_INET, SOCK_RAW, IPPROTO_ICMP);</span><br><span class="line">  <span class="keyword">if</span> (s == INVALID_SOCKET) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create socket failed, error code = %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> err = <span class="built_in">setsockopt</span>(s, SOL_SOCKET, SO_SNDTIMEO, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;FLAG_s), <span class="built_in">sizeof</span>(FLAG_s));</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(err != SOCKET_ERROR);</span><br><span class="line">  <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt for SO_SNDTIMEO failed, error code = %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="built_in">closesocket</span>(s);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  err = <span class="built_in">setsockopt</span>(s, SOL_SOCKET, SO_RCVTIMEO, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;FLAG_w), <span class="built_in">sizeof</span>(FLAG_w));</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(err != SOCKET_ERROR);</span><br><span class="line">  <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt for SO_RCVTIMEO failed, error code = %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="built_in">closesocket</span>(s);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">  err = <span class="built_in">setsockopt</span>(s, IPPROTO_IP, IP_HDRINCL, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;opt), <span class="built_in">sizeof</span>(opt));</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(err != SOCKET_ERROR);</span><br><span class="line">  <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt for IP_HDRINCL failed, error code = %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="built_in">closesocket</span>(s);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ip packet for ping request.</span></span><br><span class="line">  __u16 req_ip_packet_size = <span class="built_in">sizeof</span>(iphdr) + <span class="built_in">sizeof</span>(ping_hdr) + kPingDataSize;</span><br><span class="line">  __u8 *req_ip_packet = <span class="keyword">new</span> __u8[req_ip_packet_size];</span><br><span class="line">  <span class="built_in">memset</span>(req_ip_packet, <span class="number">0</span>, req_ip_packet_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ip packet for icmp response or ping echo.</span></span><br><span class="line">  __u16 rsp_ip_packet_size = <span class="comment">// ICMP差错报文的大小</span></span><br><span class="line">    <span class="built_in">sizeof</span>(iphdr)</span><br><span class="line">    + <span class="built_in">sizeof</span>(icmp_common_hdr)  <span class="comment">// ICMP(type=11,code=0或1)差错报文</span></span><br><span class="line">    + <span class="number">4</span> <span class="comment">// unused</span></span><br><span class="line">    + <span class="built_in">sizeof</span>(iphdr) + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//取ping包大小和ICMP差错报文大小的最大值，保证无论返回哪种报文缓冲区都够用，</span></span><br><span class="line">  <span class="comment">//也可以直接分配一个足够大的缓冲区，如1024</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  rsp_ip_packet_size = std::<span class="built_in">max</span>(rsp_ip_packet_size, req_ip_packet_size);</span><br><span class="line"></span><br><span class="line">  __u8 *rsp_ip_packet = <span class="keyword">new</span> __u8[rsp_ip_packet_size];</span><br><span class="line">  <span class="built_in">memset</span>(rsp_ip_packet, <span class="number">0</span>, rsp_ip_packet_size);</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(rsp_ip_packet);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ttl = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> seq = <span class="number">0</span>;</span><br><span class="line">  __u32 *ips = <span class="keyword">new</span> __u32[FLAG_n];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> hop = <span class="number">1</span>; hop &lt;= FLAG_m; hop++) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %-4d"</span>, hop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; FLAG_n; i++) {</span><br><span class="line">      ips[i] = <span class="number">0</span>;</span><br><span class="line">      seq++;</span><br><span class="line">      <span class="built_in">FillRequestIPPacket</span>(req_ip_packet, req_ip_packet_size, seq, ttl, dest.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">      __u32 send_time = rtc::<span class="built_in">Time32</span>();</span><br><span class="line">      <span class="type">int</span> sent = <span class="built_in">sendto</span>(s,</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(req_ip_packet),</span><br><span class="line">        req_ip_packet_size,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;dest),</span><br><span class="line">        <span class="built_in">sizeof</span>(sockaddr));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sent == SOCKET_ERROR) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%-10s"</span>, <span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == FLAG_n - <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">print_ip</span>(ips, FLAG_n, dest.sin_addr.s_addr)) {</span><br><span class="line">            SAFE_RELEASE;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          }</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> bread = <span class="built_in">recvfrom</span>(s,</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(rsp_ip_packet),</span><br><span class="line">        rsp_ip_packet_size,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;from),</span><br><span class="line">        &amp;from_len);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (bread == SOCKET_ERROR) {</span><br><span class="line">        <span class="type">int</span> gle = <span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%-10s"</span>, <span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == FLAG_n - <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">print_ip</span>(ips, FLAG_n, dest.sin_addr.s_addr)) {</span><br><span class="line">            SAFE_RELEASE;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          }</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      __u32 dest_ip = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">DecodeIPPacket</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> __u8*&gt;(rsp_ip_packet), rsp_ip_packet_size, send_time, &amp;dest_ip);</span><br><span class="line">      ips[i] = dest_ip;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i == FLAG_n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">print_ip</span>(ips, FLAG_n, dest.sin_addr.s_addr)) {</span><br><span class="line">          SAFE_RELEASE;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ttl++;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  SAFE_RELEASE;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-4-运行效果："><a href="#2-2-4-运行效果：" class="headerlink" title="2.2.4 运行效果："></a>2.2.4 运行效果：</h3><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-icmp-8.jpg"></p><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(3)--IP协议</title>
      <link href="/post/2274025898.html"/>
      <url>/post/2274025898.html</url>
      
        <content type="html"><![CDATA[<p>IP 协议是 TCP/IP 协议族中最核心的协议。所有的 TCP、UDP、ICMP、IGMP 数据都以 IP 数据报的格式传输。</p><span id="more"></span><p>IP 协议是不可靠、无连接的：</p><ul><li><p><code>不可靠</code>表示 IP 协议不能保证 IP 数据报能成功的到达目的地。IP 仅提供传输服务，任何可靠性的要求都必须由上层来提供（如 TCP）。如果传输过程发生错误，IP 协议简单的丢弃该数据报，然后发送 ICMP 消息给发送端。</p></li><li><p><code>无连接</code>表示 IP 协议不维护任何关于后续数据报的状态信息，每个数据报都是相互独立的。这也说明，IP 数据报可能不是按照发送顺序被接收到的，很有可能后发送的数据被先收到。</p></li></ul><h2 id="一、IP-首部"><a href="#一、IP-首部" class="headerlink" title="一、IP 首部"></a>一、IP 首部</h2><p>IP 数据报的格式如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-ip-1.jpg"></p><ul><li><p>4 位版本：标识目前采用的 IP 协议的版本号。IPv4 为 0100, IPv6 为 0110</p></li><li><p>4 位首部长度：用于标识首部的长度，单位为<strong>4 字节</strong>，所以首部的最大长度为<code>15*4字节=60字节</code>。</p></li><li><p>8 位服务类型：包括 3bit 的优先权字段（已被忽略），4bit 的 TOS 字段，1bit 的始终为 0 的未使用位。</p></li><li><p>16 位总长度(字节数)：整个 IP 数据报的长度。数据报中<code>数据内容的长度=总长度 - 首部长度</code></p></li><li><p>16 位标识：唯一地标识主机发送的每一份数据报。IP 数据报的最大长度可达 65535 字节，但大多数链路层都会对它进行分片。由于 TCP 本身会把用户数据分成若干片，因此这个字段一般来说不会影响到 TCP。</p></li><li><p>3 位标志：用于 IP 数据报分片。该字段第 1bit 不使用，第 2bit 是 DF(<code>Don't Fragment</code>)位，DF 位设为 1 时表明 IP 不对该数据包分片。第 3bit 是 MF(<code>More Fragments</code>)位，当对数据包分片时，除了最后一片外，其他每个组成数据报的片都要把此位设为 1。</p></li><li><p>13 位偏移：用于 IP 数据报分片。单位为 8 字节。表示该片相对于原始数据报开始处的位置，能表示的最大偏移为$2^{13}$*8=65536 字节。</p></li></ul><blockquote><p>另外，数据报被分片之后，每个片的总长度要更改为该片的长度值。IP 层分片是透明的，但是即使只丢失一片数据也要重传整个数据报，因为 IP 层本身没有超时重传的机制。</p></blockquote><ul><li><p>8 位生存时间(TTL)：设置数据报可以经过的最多路由器数量，每经过一个路由器，该值就减去 1。当该值为 0 时，数据报就被丢弃。通常初始值为 32 或 64.</p></li><li><p>8 位协议：表示上层传输层所用的协议类型。1 表示 ICMP 协议，2 表示 IGMP 协议，6 表示 TCP 协议，17 表示 UDP 协议。</p></li><li><p>16 位首部校验和：用于对 IP 首部的正确性进行校验，但不包括数据部分，这点不同于 TCP 和 UDP 的首部校验和。</p></li><li><p>32 位源 IP 地址：发送端的 32bit 的 IP 地址。</p></li><li><p>32 位目的 IP 地址：接收端的 32bit 的 IP 地址。</p></li><li><p>选项：可变长度的可选信息。如果首部不含“选项字段”，则 IP 首部长度为 20 字节。</p></li></ul><h2 id="二、IP-首部校验和"><a href="#二、IP-首部校验和" class="headerlink" title="二、IP 首部校验和"></a>二、IP 首部校验和</h2><ul><li>发送端对 IP 数据报的校验和的计算步骤：</li></ul><ol><li>把 IP 数据报的校验和字段置为 0；</li><li>把首部看成以 16 位为单位的数字组成，依次进行二进制反码求和；</li><li>把求和得到的结果取反。</li><li>将第 2、3 步得到的 2 个字节数据存入首部校验和。</li></ol><ul><li>接收端对 IP 数据报的校验和的校验步骤：</li></ul><ol><li>把首部看成以 16 位为单位的数字组成，依次进行二进制反码求和；</li><li>把求和得到的结果取反码。</li><li>如果结果为 0，则表示检验和校验通过，IP 报文没有被修改过。</li></ol><h2 id="三、使用代码计算校验和"><a href="#三、使用代码计算校验和" class="headerlink" title="三、使用代码计算校验和"></a>三、使用代码计算校验和</h2><p>通过 wireshark 抓取一帧数据报，如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-ip-2.jpg"></p><p>以该数据报的 IP 首部为基础，使用 C++代码来验证 IP 首部校验和的计算步骤和校验步骤：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// GetChecksum函数用于实现上面所说的计算步骤中的第2步、第3步：</span></span><br><span class="line"><span class="comment">// 把首部看成以16位（2字节）为单位的数字组成，依次进行二进制反码求和，</span></span><br><span class="line"><span class="comment">// 但实际的算法实现上需要考虑取和溢出时的改进计算方法（见函数内部注释）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">GetChecksum</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>* ip_header, <span class="type">int</span> size)</span> </span>{</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span>) == <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为什么使用unsigned long（4字节）？</span></span><br><span class="line">  <span class="comment">// 因为虽然首部校验和只占16位（2个字节），但执行“以16位（2字节）为单位的二进制反码数据”求和操作得到的checksum可能会超过16位（2字节），</span></span><br><span class="line">  <span class="comment">// 所以这里用4个字节的unsigned long来接收相加得到的结果，后面再进行处理。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (size &gt; <span class="number">1</span>) {</span><br><span class="line">    checksum += *ip_header; <span class="comment">// 因为都是正数，所以反码与原码相同；故直接相加求和</span></span><br><span class="line">    ip_header++; <span class="comment">// ip_header为unsigned short类型的指针每次按2个字节相加</span></span><br><span class="line"></span><br><span class="line">    size -= <span class="number">2</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 执行到这：checksum = 0x2850c</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// IP首部如果不包含“选项”字段，则为20字节，偶数；如果包含了“选项”，则字节数就可能为奇数了，</span></span><br><span class="line">  <span class="comment">// 这里针对字节数为奇数的情况进行处理。</span></span><br><span class="line">  <span class="comment">// 注：示例main函数中构造的ip_header不含有“选项”</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">1</span>) {</span><br><span class="line">    checksum += *(<span class="type">unsigned</span> <span class="type">char</span>*)ip_header;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为上面相加之后的结果大于2个字节，所以执行额外的处理步骤：</span></span><br><span class="line">  <span class="comment">// checksum &gt;&gt; 16 右移16位</span></span><br><span class="line">  <span class="comment">// 即除以2的16次方（0xffff），就是去除右边的2个字节，如：0x2850c &gt;&gt; 16 = 0x2</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// checksum &amp; 0xffff 位运算，得到后2个字节</span></span><br><span class="line">  <span class="comment">// 如：0x2850c &amp; 0xffff = 0x850c</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// checksum = 0x2 + 0x850c = 0x850e</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  checksum = (checksum &gt;&gt; <span class="number">16</span>) + (checksum &amp; <span class="number">0xffff</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假如还大于2个字节，再次将多余的字节和checksum相加。</span></span><br><span class="line">  checksum += (checksum &gt;&gt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求和得到的结果的取反</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">short</span>)(~checksum);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// 将上面wirkshark抓的数据包的IP头部，使用char数组，按字节构造出来</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> ip_header[<span class="number">20</span>] = {</span><br><span class="line">    <span class="number">0x45</span>, <span class="comment">// 4位版本+4位首部长度</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="comment">// 8位服务类型（TOS）</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x1c</span>,  <span class="comment">// 16位总长度（字节数）</span></span><br><span class="line">    <span class="number">0x50</span>, <span class="number">0xaa</span>,  <span class="comment">// 16位标识</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>,  <span class="comment">// 3位标志+13位片偏移</span></span><br><span class="line">    <span class="number">0xff</span>, <span class="comment">// 8位生存时间（TTL）</span></span><br><span class="line">    <span class="number">0x01</span>, <span class="comment">// 8位协议</span></span><br><span class="line">    <span class="number">0xf1</span>, <span class="number">0x7a</span>, <span class="comment">// 16位首部校验和</span></span><br><span class="line">    <span class="number">0xc0</span>, <span class="number">0xa8</span>, <span class="number">0x2e</span>, <span class="number">0x55</span>, <span class="comment">// 32位源IP地址</span></span><br><span class="line">    <span class="number">0xee</span>, <span class="number">0x73</span>, <span class="number">0x9c</span>, <span class="number">0x4a</span>  <span class="comment">// 32位目的IP地址</span></span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第1步：把IP数据包的校验和字段置为0；</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  ip_header[<span class="number">10</span>] = <span class="number">0x00</span>;</span><br><span class="line">  ip_header[<span class="number">11</span>] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第2、3步计算校验和</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> checksum = <span class="built_in">GetChecksum</span>((<span class="type">unsigned</span> <span class="type">short</span>*)ip_header, <span class="built_in">sizeof</span>(ip_header));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%02hhx %02hhx\n"</span>, *(<span class="type">char</span>*)(&amp;checksum), *((<span class="type">char</span>*)(&amp;checksum) + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第4步：将第2、3步得到的2个字节数据存入首部校验和</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  ip_header[<span class="number">10</span>] = *(<span class="type">char</span>*)(&amp;checksum);</span><br><span class="line">  ip_header[<span class="number">11</span>] = *((<span class="type">char</span>*)(&amp;checksum) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟接收到IP包之后，对IP首部的校验和进行校验</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> checksum_check = <span class="built_in">GetChecksum</span>((<span class="type">unsigned</span> <span class="type">short</span>*)ip_header, <span class="built_in">sizeof</span>(ip_header));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (checksum_check == <span class="number">0</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"checksum check successful!\n"</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"checksum check failed!\n"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="四、IP-校验和的设计原理"><a href="#四、IP-校验和的设计原理" class="headerlink" title="四、IP 校验和的设计原理"></a>四、IP 校验和的设计原理</h2><p>我们将 IP 首部进行简化来讲解 IP 校验和的设计原理，假设 IP 首部只有 6 个字节，第 5,6 字节存放校验和：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-ip-3.jpg"></p><p>计算校验和时第 5,6 字节置为 0，校验和等于：A+B+0，然后取反，即：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-ip-4.jpg"></p><p>接收端收到之后校验步骤为：求校验和（不同的是：校验和位不置 0），若此时求得校验和为 0，则校验通过。即：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-ip-5.jpg"></p><h2 id="五、IP-地址相关操作"><a href="#五、IP-地址相关操作" class="headerlink" title="五、IP 地址相关操作"></a>五、IP 地址相关操作</h2><p>本节介绍在网络编程中涉及到的与 IP 地址相关的操作</p><h3 id="struct-in-addr"><a href="#struct-in-addr" class="headerlink" title="struct in_addr"></a>struct in_addr</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeof(in_addr) == sizeof(ULONG) == 4</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">in_addr</span> {</span><br><span class="line">        <span class="keyword">union</span> {</span><br><span class="line">                <span class="keyword">struct</span> { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b;</span><br><span class="line">                <span class="keyword">struct</span> { USHORT s_w1,s_w2; } S_un_w;</span><br><span class="line">                ULONG S_addr;   <span class="comment">// 4个字节，按网络字节序列存储</span></span><br><span class="line">                        <span class="comment">// 可以使用inet_addr函数将IP格式字符串转为网络字节序列的整数。</span></span><br><span class="line">        } S_un;</span><br><span class="line"><span class="comment">// 定义的一些宏，方便访问结构体成员</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s_addr  S_un.S_addr <span class="comment">/* can be used for most tcp &amp; ip code */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s_host  S_un.S_un_b.s_b2    <span class="comment">// host on imp</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s_net   S_un.S_un_b.s_b1    <span class="comment">// network</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s_imp   S_un.S_un_w.s_w2    <span class="comment">// imp</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s_impno S_un.S_un_b.s_b4    <span class="comment">// imp #</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s_lh    S_un.S_un_b.s_b3    <span class="comment">// logical host</span></span></span><br><span class="line">} IN_ADDR, *PIN_ADDR, FAR *LPIN_ADDR;</span><br></pre></td></tr></tbody></table></figure><h3 id="struct-sockaddr-in"><a href="#struct-sockaddr-in" class="headerlink" title="struct sockaddr_in"></a>struct sockaddr_in</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeof(sockaddr_in) == 16</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> {</span><br><span class="line">        <span class="type">short</span>   sin_family;</span><br><span class="line">        u_short sin_port;</span><br><span class="line">        <span class="keyword">struct</span>  <span class="title class_">in_addr</span> sin_addr;</span><br><span class="line">        <span class="type">char</span>    sin_zero[<span class="number">8</span>];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="struct-sockaddr"><a href="#struct-sockaddr" class="headerlink" title="struct sockaddr"></a>struct sockaddr</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeof(sockaddr) == 16</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> {</span><br><span class="line">        u_short sa_family;              <span class="comment">/* address family */</span></span><br><span class="line">        <span class="type">char</span>    sa_data[<span class="number">14</span>];            <span class="comment">/* up to 14 bytes of direct address */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="5-1-转换函数"><a href="#5-1-转换函数" class="headerlink" title="5.1 转换函数"></a>5.1 转换函数</h3><blockquote><p>webrtc 中的<code>IPAddress</code>类和<code>SocketAddress</code>类，对网络地址的操作进行了很好的封装，值得参考。</p></blockquote><h4 id="5-1-1-IP-字符串-整数"><a href="#5-1-1-IP-字符串-整数" class="headerlink" title="5.1.1 IP 字符串 -> 整数"></a>5.1.1 IP 字符串 -&gt; 整数</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">inet_addr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ <span class="type">const</span> <span class="type">char</span> *cp</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>将类似<code>127.0.0.1</code>这样的 IP 字符串转换为网络字节序列的整数</p><h4 id="5-1-2-整数-IP-字符串"><a href="#5-1-2-整数-IP-字符串" class="headerlink" title="5.1.2 整数 -> IP 字符串"></a>5.1.2 整数 -&gt; IP 字符串</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* FAR <span class="title">inet_ntoa</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ <span class="keyword">struct</span>   in_addr in</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>将 in_addr（也可以理解为网络字节序列整数）转换为 IP 字符串。</p><h3 id="5-2-字节序列转换"><a href="#5-2-字节序列转换" class="headerlink" title="5.2 字节序列转换"></a>5.2 字节序列转换</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">htons</span><br><span class="line">htonl</span><br><span class="line">ntohs</span><br><span class="line">ntohl</span><br><span class="line">htonll</span><br><span class="line">ntohll</span><br></pre></td></tr></tbody></table></figure><p>对整数（short、long、longlong）进行网络字节序列和主机字节序列间的转换操作。<br>以 htons 为例：<br><code>h</code>是 host 的首字母，表示主机字节序列；<br><code>n</code>是 network 的首字母，表示网络字节序列；<br><code>s</code>代表 short；<br>所以 htons 的功能是，将 short 从主机字节序列转为网络字节序列。</p><blockquote><p>字节序列可以参考：<a href="http://blog.csdn.net/china_jeffery/article/details/78401731">http://blog.csdn.net/china_jeffery/article/details/78401731</a></p></blockquote><h3 id="5-3-获取本机-IP-地址"><a href="#5-3-获取本机-IP-地址" class="headerlink" title="5.3 获取本机 IP 地址"></a>5.3 获取本机 IP 地址</h3><h4 id="5-3-1-使用-gethostbyname"><a href="#5-3-1-使用-gethostbyname" class="headerlink" title="5.3.1 使用 gethostbyname"></a>5.3.1 使用 gethostbyname</h4><p>这种方式有一个弊端：只能获取一个网卡的 IP 地址。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">GetLocalIPv4Address</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">char</span> hostname[MAX_PATH] = { <span class="number">0</span> };</span><br><span class="line">  <span class="built_in">gethostname</span>(hostname, MAX_PATH);</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">hostent</span> FAR* lpHostEnt = <span class="built_in">gethostbyname</span>(hostname);</span><br><span class="line">  <span class="keyword">if</span> (lpHostEnt == <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">htonl</span>(<span class="number">0x7f000001</span>); <span class="comment">//127.0.0.1</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  LPSTR lpAddr = lpHostEnt-&gt;h_addr_list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">in_addr</span> addr;</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;addr, lpAddr, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> addr.s_addr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="5-3-2-使用-GetAdaptersInfo"><a href="#5-3-2-使用-GetAdaptersInfo" class="headerlink" title="5.3.2 使用 GetAdaptersInfo"></a>5.3.2 使用 GetAdaptersInfo</h4><p>该方式可以获取本机多块网卡的信息（不限于 IP 地址）。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Iphlpapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">"Iphlpapi.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetLocalAddress</span><span class="params">(std::vector&lt;std::string&gt; &amp;ip_list)</span> </span>{</span><br><span class="line">  PIP_ADAPTER_INFO pIpAdapterInfo = <span class="keyword">new</span> <span class="built_in">IP_ADAPTER_INFO</span>();</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> stSize = <span class="built_in">sizeof</span>(IP_ADAPTER_INFO);</span><br><span class="line">  <span class="type">int</span> nRet = <span class="built_in">GetAdaptersInfo</span>(pIpAdapterInfo, &amp;stSize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ERROR_BUFFER_OVERFLOW == nRet) {</span><br><span class="line">    <span class="keyword">delete</span> pIpAdapterInfo;</span><br><span class="line">    pIpAdapterInfo = (PIP_ADAPTER_INFO)<span class="keyword">new</span> BYTE[stSize];</span><br><span class="line">    nRet = <span class="built_in">GetAdaptersInfo</span>(pIpAdapterInfo, &amp;stSize);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ERROR_SUCCESS != nRet) {</span><br><span class="line">    <span class="keyword">if</span> (pIpAdapterInfo) {</span><br><span class="line">      <span class="keyword">delete</span> pIpAdapterInfo;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (pIpAdapterInfo) {</span><br><span class="line">    IP_ADDR_STRING *pIpAddrString = &amp;(pIpAdapterInfo-&gt;IpAddressList);</span><br><span class="line">    <span class="keyword">switch</span> (pIpAdapterInfo-&gt;Type) {</span><br><span class="line">      <span class="keyword">case</span> MIB_IF_TYPE_OTHER:</span><br><span class="line">      <span class="keyword">case</span> MIB_IF_TYPE_ETHERNET:</span><br><span class="line">      <span class="keyword">case</span> MIB_IF_TYPE_TOKENRING:</span><br><span class="line">      <span class="keyword">case</span> MIB_IF_TYPE_FDDI:</span><br><span class="line">      <span class="keyword">case</span> MIB_IF_TYPE_PPP:</span><br><span class="line">      <span class="keyword">case</span> MIB_IF_TYPE_LOOPBACK:</span><br><span class="line">      <span class="keyword">case</span> MIB_IF_TYPE_SLIP: {</span><br><span class="line">        std::string address = pIpAddrString-&gt;IpAddress.String;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"0.0.0.0"</span> == address)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        ip_list.<span class="built_in">push_back</span>(address);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    pIpAdapterInfo = pIpAdapterInfo-&gt;Next;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pIpAdapterInfo) {</span><br><span class="line">    <span class="keyword">delete</span> pIpAdapterInfo;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>《TCP/IP 详解 卷 1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p></blockquote><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(2)--ARP和RARP协议</title>
      <link href="/post/3034381124.html"/>
      <url>/post/3034381124.html</url>
      
        <content type="html"><![CDATA[<p><code>ARP</code>(<code>Address Resolution Protocol</code>)地址解析协议，位于 TCP/IP 协议栈中的链路层。当局域网内主机间（或者是主机与网关间）需要通信时，通过使用<code>ARP协议</code>获取<code>目标IP地址</code>对应的<code>硬件MAC地址</code>，然后主机间通过该<code>硬件MAC地址</code>完成数据包发送和接收。</p><span id="more"></span><h1 id="一、ARP-协议"><a href="#一、ARP-协议" class="headerlink" title="一、ARP 协议"></a>一、ARP 协议</h1><h2 id="1-1-ARP-协议介绍"><a href="#1-1-ARP-协议介绍" class="headerlink" title="1.1 ARP 协议介绍"></a>1.1 ARP 协议介绍</h2><p>通过使用<code>ARP协议</code>获取<code>目标IP地址</code>对应<code>硬件MAC地址</code>的具体过程如下：</p><ol><li>本地主机在局域网中<code>广播</code>ARP 请求，ARP 请求数据帧中包含目的主机的 IP 地址。意思是“如果你是这个 IP 地址的拥有者，请回答你的硬件 MAC 地址”。</li><li>目的主机的 ARP 层解析这份<code>广播</code>报文，识别出是询问其硬件地址。于是发送（<code>单播</code>）ARP 应答包，里面包含 IP 地址及其对应的硬件地址。</li><li>本地主机收到 ARP 应答后，知道了目的地址的硬件地址，之后的数据报就可以传送了。</li></ol><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-arp-1.jpg"></p><h2 id="1-2-ARP-缓存"><a href="#1-2-ARP-缓存" class="headerlink" title="1.2 ARP 缓存"></a>1.2 ARP 缓存</h2><p>如果像上面说的那样，每次发包之前都要发送 ARP 请求硬件地址会不会太慢，但是实际上 ARP 的运行是非常高效的。那是因为每一个主机上都有一个 ARP 高速缓存，我们可以通过命令<code>arp -a</code>获取本机 ARP 高速缓存的所有内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">λ arp -a</span><br><span class="line"></span><br><span class="line">接口: 192.168.42.26 --- 0xb</span><br><span class="line">  Internet 地址         物理地址              类型</span><br><span class="line">  192.168.1.1           00-00-00-00-00-ff     静态</span><br><span class="line">  192.168.40.1          f8-75-88-c2-df-c1     动态</span><br><span class="line">  192.168.40.74         c8-5b-76-86-c6-06     动态</span><br><span class="line">  192.168.40.245        38-d5-47-e1-8a-2f     动态</span><br><span class="line">  192.168.42.131        60-a4-4c-65-9f-68     动态</span><br><span class="line">  224.14.51.28          01-00-5e-0e-33-1c     静态</span><br><span class="line">  224.19.133.150        01-00-5e-13-85-96     静态</span><br><span class="line">  224.49.6.212          01-00-5e-31-06-d4     静态</span><br><span class="line">  224.50.134.225        01-00-5e-32-86-e1     静态</span><br><span class="line">  224.68.111.100        01-00-5e-44-6f-64     静态</span><br><span class="line">  224.80.154.130        01-00-5e-50-9a-82     静态</span><br><span class="line">  224.88.174.75         01-00-5e-58-ae-4b     静态</span><br></pre></td></tr></tbody></table></figure><p>通过命令<code>arp -d</code>清除 arp 缓存内容。</p><h2 id="1-3-ARP-缓存生存周期"><a href="#1-3-ARP-缓存生存周期" class="headerlink" title="1.3 ARP 缓存生存周期"></a>1.3 ARP 缓存生存周期</h2><p>在默认情况下，Windows Server 2003 家族和 Windows XP 中，ARP 缓存中的表项仅存储 2 分钟。如果一个 ARP 缓存表项在 2 分钟内被用到，则其期限再延长 2 分钟，直到最大生命期限 10 分钟为止。超过 10 分钟的最大期限后，ARP 缓存表项将被移出，并且通过另外一个 ARP 请求来获得新的对应关系。</p><p>ARP 缓存表项的存放时间可以通过改变<code>ArpCacheLife</code>和<code>ArpCacheMinReferencedLife</code>的注册表值来重新设置。</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Tcpip/Parameters</span><br><span class="line"></span><br><span class="line">键值：</span><br><span class="line">ArpCacheLife，设置未被使用的ARP缓存表项可以被保持的时间，类型为Dword，单位为秒，默认值为120。</span><br><span class="line">ArpCacheMinReferencedLife，设置被重复使用的表项可以在ARP缓存中存放的时间，类型为Dword，单位为秒，默认值为600。</span><br><span class="line"></span><br><span class="line">ArpCacheMinReferencedLife和ArpCacheLife的值的使用方法如下：</span><br><span class="line">如果ArpCacheLife &gt;= ArpCacheMinReferencedLife，则被使用和未被使用的ARP缓存表项可存储的时间都是ArpCacheLife。</span><br><span class="line">如果ArpCacheLife &lt; ArpCacheMinReferencedLife，则未被使用的ARP缓存表项在ArpCacheLife秒的时间后就过期了，被使用的表项的生存期为ArpCacheMinReferencedLife秒。</span><br><span class="line"></span><br><span class="line">注意：这些键值默认是不存在的，如果你想修改，必须自行创建；修改后重启计算机后生效</span><br></pre></td></tr></tbody></table></figure><h2 id="1-3-ARP-帧格式"><a href="#1-3-ARP-帧格式" class="headerlink" title="1.3 ARP 帧格式"></a>1.3 ARP 帧格式</h2><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-arp-2.jpg"></p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">以太网目的地址：目的主机的硬件地址。目的地址全为1的特殊地址是广播地址。</span><br><span class="line">以太网源地址：源主机的硬件地址。</span><br><span class="line">帧类型：对于ARP协议，该字段为0x0806。对于RARP协议，该字段为0x8035。</span><br><span class="line"></span><br><span class="line">硬件类型：表示硬件地址的类型。值为1时表示以太网地址。ARP协议不仅仅应用于以太网协议，还可以支持别的链路层协议。</span><br><span class="line">协议类型：表示要映射的协议地址类型。值为0x0800时表示IP协议。</span><br><span class="line">硬件地址长度：与硬件类型对应的硬件地址的长度，以字节为单位。如果是以太网，则是6字节（MAC长度）。</span><br><span class="line">协议地址长度：与协议类型对应的协议地址长度，以字节为单位。如果是IP协议，则是4字节（IP地址长度）。</span><br><span class="line">操作类型（op）：四种操作类型。ARP请求（1），ARP应答（2），RARP请求（3），RARP应答（4）。</span><br><span class="line">发送端硬件地址：如果是以太网，则是源主机以太网地址，此处和以太网头中的源地址对应。</span><br><span class="line">发送端协议地址：如果是IP协议，则表示源主机的IP地址。</span><br><span class="line">目的端硬件地址：如果是以太网，则是目的以太网地址，和以太网头中的目的地址对应。</span><br><span class="line">目的端协议地址：如果是IP协议，则表示源主机要请求硬件地址的IP地址。</span><br><span class="line"></span><br><span class="line">对应ARP请求包来说，目的端的硬件地址字段无须填充，其他字段都需要填充。对于ARP回复包来说，所有字段都需要填充。</span><br></pre></td></tr></tbody></table></figure><h2 id="1-4-ARP-欺骗"><a href="#1-4-ARP-欺骗" class="headerlink" title="1.4 ARP 欺骗"></a>1.4 ARP 欺骗</h2><p>ARP 欺骗一般目的是通过某种方式把自己伪装成网关，从而欺骗目标机器，使本应发送到真实网关的数据包发送到欺骗者的机器。</p><p>现有如下网络：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-arp-3.jpg"></p><h4 id="1-4-1-如何伪装成网关？"><a href="#1-4-1-如何伪装成网关？" class="headerlink" title="1.4.1 如何伪装成网关？"></a>1.4.1 如何伪装成网关？</h4><p>我们以主机 A 请求<code>www.csdn.net</code>网站为例，涉及到 ARP 的主要流程如下：</p><ol><li><p>主机 A 通过浏览器打开<code>www.csdn.net</code>（假设通过 DNS 得到的 IP 是<code>47.95.163.175</code>），然后组装需要发送 http 请求包。</p></li><li><p>主机 A 准备根据默认路由（网关）将数据包发送给<code>192.168.0.1</code>, 但是最开始的时候主机 A 不知道 <code>192.168.0.1</code> 的 MAC 地址, 所以主机 A 广播一条 ARP 请求, 询问 <code>192.168.0.1</code> 的 MAC 地址。</p></li><li><p>路由器（网关）收到该 ARP 请求, 发现自己是 192.168.0.1 于是向主机 A 回复一条 ARP 应答包, 告诉主机 A 192.168.0.1 的 MAC 地址是 xxxGW.</p></li><li><p>主机 A 收到该 ARP 响应包, 并向该响应包中的 MAC 地址发送一个 Http 请求包。</p></li><li><p>路由器（网关）收到该 Http 请求包, 发现目标 IP 是公网 IP, 便将该包放送到公网, 公网返回 Http 应答包给路由器（网关）。</p></li><li><p>路由器（网关）准备将 Http 响应包发送给<code>192.168.0.100</code>, 但是同第 2 步, 路由器最开始的时候也不知道 <code>192.168.0.100</code> 的 MAC 地址是多少, 所以路由器会广播一条 ARP 请求, 询问 192.168.0.100 的 MAC 地址是多少。</p></li><li><p>主机 A 收到 ARP 请求, 发现自己是<code>192.168.0.100</code>, 于是向路由器回复一个 ARP 应答包, 告诉路由器<code>192.168.0.100</code> 的 MAC 地址是 xxxA.</p></li><li><p>路由器（网关）收到 ARP 应答包, 并使用该 APR 应答包中的 MAC 地址将第 5 步收到 Http 响应包发送出去。</p></li></ol><p>试想，如果现在主机 B 做了如下 2 件事情会有什么后果：</p><ol><li>主机 B 不停的向主机 A 发送 ARP 应答包, 告诉路由器（网关）192.168.0.1 的 MAC 地址是 xxxB, 会发生什么?</li><li>主机 B 不停的向路由器（网关）发送 ARP 应答包, 告诉主机 A 192.168.0.100 的 MAC 是 xxxB, 会发生什么?</li></ol><p>如果主机 B 做了上面说的两件事的, 那么主机 A 访问网络的所有数据都会先经过主机 B, 并且从网关发送到主机 A 的数据也都会经过 B, 至此, 整个 ARP 欺骗完成。</p><p>但是，如果欺骗者机器不对这些数据包作处理，当被欺骗数据包到达后就会被本机丢弃（因为自己到底不是网关，还不知道如何处理这类数据包），这当然是不允许的。这时开启 IP 转发功能可以解决该问题，IP 转发负责把该类数据包再转发给真正的网关处理，开启 IP 转发的方法：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.ip_forward=1</span><br></pre></td></tr></tbody></table></figure><h4 id="1-4-2-arpspoof-使用"><a href="#1-4-2-arpspoof-使用" class="headerlink" title="1.4.2 arpspoof 使用"></a>1.4.2 arpspoof 使用</h4><p>在 Ubuntu 或 Kali 等系统上有<code>arpspoof</code>工具可以轻松实现 ARP 欺骗的整个流程。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-i 指定用攻击机的哪个网络接口，可以使用ifconfig命令查看攻击机接口列表。</span><br><span class="line"></span><br><span class="line">-c own|host|both</span><br><span class="line"></span><br><span class="line">-t 指定arp攻击的目标。如果不指定，则目标为该局域网内的所有机器。可以指定多个目标，如：</span><br><span class="line">arpspoof -i etho -t 192.168.32.100 -t 192.168.32.101</span><br><span class="line"></span><br><span class="line">-r host</span><br><span class="line">希望拦截攻击机和哪个host之间的通信，一般都是网关。</span><br></pre></td></tr></tbody></table></figure><h1 id="二、RARP-协议"><a href="#二、RARP-协议" class="headerlink" title="二、RARP 协议"></a>二、RARP 协议</h1><p>RARP 协议（Reverse Address Resolution Protocol），反向地址转换协议，也叫逆地址解析协议，主要被那些没有磁盘驱动器的系统使用，如无盘工作站等。</p><p>具有本地磁盘的系统引导时，一般是从磁盘中的配置文件读取 IP 地址。但是无盘机，如无盘工作站，则需要采用其他方法获取 ip 地址。<br>网络上的每个系统都具有唯一的硬件地址，它是由网络接口生产厂家配置的。无盘系统的 RARP 实现过程是从网卡上读取唯一的硬件地址，然后发送 RARP 请求到 RARP 服务器，请求该主机在无盘系统的 IP 地址。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-arp-4.jpg"></p><blockquote><p>文章参考：<a href="https://segmentfault.com/a/1190000009562333">https://segmentfault.com/a/1190000009562333</a></p></blockquote><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(1)--基础概念</title>
      <link href="/post/3886809266.html"/>
      <url>/post/3886809266.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、TCP-IP-协议栈"><a href="#一、TCP-IP-协议栈" class="headerlink" title="一、TCP/IP 协议栈"></a>一、TCP/IP 协议栈</h1><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-jichugailian-1.jpg"></p><h1 id="二、IP-地址、子网掩码、网关"><a href="#二、IP-地址、子网掩码、网关" class="headerlink" title="二、IP 地址、子网掩码、网关"></a>二、IP 地址、子网掩码、网关</h1><h2 id="2-1-IP-地址及分类"><a href="#2-1-IP-地址及分类" class="headerlink" title="2.1 IP 地址及分类"></a>2.1 IP 地址及分类</h2><p>IP 地址相当于互联网上的门牌号，计算机在启动的时候可以从磁盘（无盘系统例外）上读取该主机的 IP 配置。</p><p>IP 地址由 4 个字节（也就是 32 位）的二进制码组成，包含了<code>网络号( net-id )</code>和<code>主机号( host-id )</code>。但现实中，我们经常还需要再继续划分<code>“子网”</code>，这时就需要借用主机号的一部分充任子网号，这样 IP 地址也就可以看成由<code>标准网络号、子网号、主机号</code>3 部分组成的，即<code>IP地址=标准网络号+子网号+主机号</code>。</p><blockquote><p>网络号、子网号、主机号三者间的关系，形象的描述如下：假设你的住址 IP 是<code>武汉市文治街16号</code>，那么，<br>IP 地址 = 武汉市文治街 16 号<br>网络号 = 武汉市<br>子网号 = 文治街<br>主机号 = 16 号</p></blockquote><table><thead><tr><th>IP 地址种类</th><th>二进制组成(前缀位+网络位+主机位)</th><th>IP 范围</th><th>网络数</th><th>主机数/网络</th></tr></thead><tbody><tr><td>A 类地址</td><td><code>0</code>+7 位网络号+24 位主机号</td><td>1.0.0.0 - 127.255.255.255</td><td>$2^7-2$</td><td>$2^{24}-2$</td></tr><tr><td>B 类地址</td><td><code>10</code>+14 位网络号+16 位主机号</td><td>128.0.0.0 - 191.255.255.255</td><td>$2^{14}-1$</td><td>$2^{16}-2$</td></tr><tr><td>C 类地址</td><td><code>110</code>+21 位网络号+8 位主机号</td><td>192.0.0.0 - 223.255.255.255</td><td>$2^{21}-1$</td><td>$2^8-2$</td></tr><tr><td>D 类地址</td><td><code>1110</code>+多播地址(用于多播)</td><td>224.0.0.0 - 239.255.255.255</td><td>-</td><td>-</td></tr><tr><td>E 类地址</td><td><code>1111</code>+保留位(不开放, 保留使用)</td><td>240.0.0.0-249.255.255.255</td><td>-</td><td>-</td></tr></tbody></table><p>从表中可以看出，A 类 IP 的第 1 位（二进制位）必须是 0，所以 A 类 IP 的第一个整数的范围是<code>0000 0000 ~ 01111 11111</code>，转换为十进制就是<code>0 ~ 127</code>，以此类推。</p><h3 id="关于网络数的解释"><a href="#关于网络数的解释" class="headerlink" title="关于网络数的解释"></a>关于网络数的解释</h3><p>网络数就是一种网络的子网数, 比如 A 类地址, 可以分为多少个子网。看表格可以推出网络数的计算公式为: $2^{网络号位数}$。<br>规定网络地址全为<code>0</code>的 IP 地址是保留地址，意思是“本网络”。</p><ul><li>在 A 类地址中，实际上 <code>0.0.0.0</code> 是不指派的，而可以指派的最小网络是 <code>1.0.0.0</code>；网络地址为 <code>127</code> 的 A 类 IP 地址保留作为本地软件环回测试本主机的进程之间的通信(比如常用的 <code>127.0.0.1</code>，<strong>但实际上网络地址为<code>127</code>的都可以用作本地环回地址</strong>)。所以 A 类地址网络数为 $2^7-2$。</li><li>在 B 类地址中，实际上 <code>128.0.0.0</code> 是不指派的，而可以指派的最小网络是 `128.1.0.0，所以 B 类地址网络数是 $2^{14} - 1$。</li><li>在 C 类地址中，实际上 <code>192.0.0.0</code> 是不指派的，而可以指派的最小网络是 192.0.1.0，所以 C 类地址网络数是 $2^{21}-1$。</li></ul><h3 id="关于主机数的解释"><a href="#关于主机数的解释" class="headerlink" title="关于主机数的解释"></a>关于主机数的解释</h3><p>主机数就是一个子网里面可以容纳多少台主机。看表格可以推出主机数的计算公式为: <code>2^主机号位数-2</code>。主机号全为 0 表示该网络，而主机号全为 1 表示广播地址，所以要排除掉这两个。比如 A 类地址 <code>1.0.0.0</code> 表示主机所在的网段的网络地址, <code>1.255.255.255</code> 为该网段的广播地址。</p><h2 id="2-2-私有-IP-地址"><a href="#2-2-私有-IP-地址" class="headerlink" title="2.2 私有 IP 地址"></a>2.2 私有 IP 地址</h2><p>经常可以看到<code>192.168.1.101</code>这类的 IP 地址, 这些是私有 IP 地址, 专用地址, 也就是局域网内使用的的 IP 地址。<br>公网 IP 地址是需要向有关部门申请备案的，私有 IP 地址不用申请, 但是仅限内网使用, 也节约公网 IP。</p><table><thead><tr><th>IP 地址种类</th><th>私有 IP 范围</th></tr></thead><tbody><tr><td>A 类地址</td><td>10.0.0.0 - 10.255.255.255</td></tr><tr><td>B 类地址</td><td>172.16.0.0 - 172.31.255.255</td></tr><tr><td>C 类地址</td><td>192.168.0.0 - 192.168.255.255</td></tr></tbody></table><p>路由器看到专用地址就不转发，所以说专用地址作为目的地址是不可能在因特网上传送的。专用 IP 地址也可叫做可重用地址。那好，问题来了，如果配置了这些专用地址的主机想和因特网上的主机通信，怎么办呢？NAT(network address translation: 网络地址转换)在这种情况下就应运而生了。NAT 就是将这种地址转换成有效的外部全球 IP 地址，使得整个专用网只需要一个全球 IP 地址就可以与因特网联通。</p><h2 id="2-3-子网掩码"><a href="#2-3-子网掩码" class="headerlink" title="2.3 子网掩码"></a>2.3 子网掩码</h2><p><code>IP地址=标准网络号+子网号+主机号</code>。从 IP 分类可以很容易确定“标准网络号”，<code>32bit</code>的 IP 地址除去前面的“标准网络号”之后，剩下的就是“子网号”和“主机号”，那么怎么确定“子网号”和“主机号”了？ 这就需要借助<code>“子网掩码”</code>了。子网掩码也是一个 32bit(<code>xxx.xxx.xxx.xxx</code>)的值，其中值为 1 的 bit 留给“标准网络号”和“子网号”，为 0 的 bit 留给“主机号”。我们可以将子网掩码和 IP 地址进行二进制<code>“与运算”</code>，通过得到的结果来确定“子网号”。</p><p>以 C 类 IP 地址为例，对于规范的 C 类 IP 地址来说，规范子网掩码为<code>255.255.255.0</code>，即用 32 比特 IP 地址的前 24 比特标识网络号，后 8 比特标识主机号。因而，每个 C 类网络下共可容纳 254 台主机($2^8-2$)。 如今，我们先思索借用 2 比特的主机号来充任子网络号的情形。</p><p>C 类网络地址<code>210.31.233.0</code>，我们借用 2bit 的主机号来充当子网号，子网的数目为$2^2-2$(子网号无法全为 0 或 1，所以减 2).</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-jichugailian-2.jpg"></p><p>为了借用原来 8 位主机号中的前 2 位充任子网络号，采用了新的非规范子网掩 255.255.255.192。<br>采用了新的子网掩码后，借用的 2 位子网号可以用来标识两个子网：01 子网和 10 子网(子网号无法全为 0 或 1，因而 00、11 子网无法用)。</p><p><strong>对于上图的 01 子网来说</strong>，其网络号的点分十进制的方式为：<code>210.31.233.64</code>，该子网的最小 IP 地址为：<code>210.31.233.65</code>，最大 IP 地址为：<code>210.31.233.126</code>（主机号全为 1 位广播地址），共可容纳 62 台主机。对该子网的直接广播地址为：<code>210.31.233.127</code>（主机号全为 1）。</p><blockquote><p>经常见到像<code>192.168.1.0/24</code>这样的写法，它的意思是网络号为<code>192.168.1.0</code>；子网掩码为 24 位，即<code>111111111 111111111 111111111 00000000</code>，转为点分十进制就为<code>255.255.255.0</code>，没有借用主机号来充当子网号，可以拥有的主机数为$2^8$-2.</p></blockquote><h2 id="2-3-网关的作用"><a href="#2-3-网关的作用" class="headerlink" title="2.3 网关的作用"></a>2.3 网关的作用</h2><p>你的住址 IP 是<code>武汉市洪山区文治街16号</code>，你的父母只允许你和文治街的小朋友（同一个子网）一起玩耍，如果你想要去和别的街道（别的子网）的小朋友玩耍，你就需要经过你的父母的同意，由你的父母带你过去，这时候你的父母就充当了<strong>网关</strong>的角色，没有你的父母，你就不能和其他街道（其他子网）的小朋友玩耍。</p><h1 id="三、包的封装与解封装"><a href="#三、包的封装与解封装" class="headerlink" title="三、包的封装与解封装"></a>三、包的封装与解封装</h1><blockquote><p>封装英文：Encapsulation<br>解封装英文：Demultiplexing</p></blockquote><p>当应用程序使用网络传送数据时，数据按照协议栈从上到下的顺序，逐次通过每一层。其中每一层对收到的数据都要增加一些首部信息（有时还增加尾部信息）。最终生成一串比特流通过以太网来传输，我们称这串比特流叫帧。<br>如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-jichugailian-3.jpg"></p><p><strong>当数据报到达链路层时</strong>，链路层也要对 IP 数据包封装进行包装。链路层也要对 IP 数据包封装的方式主要有<code>以太网IP数据包封装</code>（RFC894）、<code>IEEE 802 IP数据报封装</code>（RFC1042）两种，最常使用的封装格式是以太网 IP 数据包封装（RFC894）。下图显示了这两种不同形式的封装格式：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-jichugailian-4.jpg"><br>从图中可以看到<code>以太网封装</code>限制了数据帧的最大长度为 1500 字节，这个限制叫做 MTU，最大传输单元（详见第四节）。</p><p>接收端收到帧之后，按照和上面相反的顺序（协议栈从下到上）来解包，依次解析每一层加入的头部（或尾部），最终将原始数据传给最上层应用程序。<br>如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-jichugailian-5.jpg"></p><p>因为传输层的 TCP、UDP、ICMP 等都有可能向网络层 IP 协议传送数据，这样在 IP 协议层解包的时候，需要知道这个包对应的上层协议是哪一个，因此 IP 协议必须在生成的 IP 首部加入某种标识，以表明数据的上一层的具体协议。为此，IP 在首部中存入了一个长度为 8bit 的数值，称作协议域。常见的 IP 协议号有：<br>1 表示 ICMP 协议，2 表示 IGMP 协议，6 表示 TCP 协议，17 表示 UDP 协议。</p><blockquote><p>完整的 IP 协议号见：<a href="https://zh.wikipedia.org/wiki/IP%E5%8D%8F%E8%AE%AE%E5%8F%B7%E5%88%97%E8%A1%A8">IP 协议号列表</a></p></blockquote><h1 id="四、MTU"><a href="#四、MTU" class="headerlink" title="四、MTU"></a>四、MTU</h1><p>前面第三节提到了以太网封装限制了数据帧的长度为 1500 字节，这个限制是在链路层封装 IP 数据报时作的。如果 IP 层的数据报比链路层的这个 MTU 值大，那么 IP 层就需要分片（英文：fragmentation），把数据报分成若干片，保证每一片的大小都小于 MTU 值。</p><h3 id="windows-系统修改-MTU-值"><a href="#windows-系统修改-MTU-值" class="headerlink" title="windows 系统修改 MTU 值"></a>windows 系统修改 MTU 值</h3><ul><li>查询当前 MTU 值</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface ipv4 show subinterfaces</span><br></pre></td></tr></tbody></table></figure><p><img src="https://blog-static.jiangxueqiao.com/blog/img/wangluoxieyi-jichugailian-6.jpg"></p><ul><li>修改 MTU 值</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface ipv4 set subinterface "本地连接" mtu=1480 store=persistent</span><br></pre></td></tr></tbody></table></figure><blockquote><p>文章参考：<br><a href="https://m.vipcn.com/a/360973/">https://m.vipcn.com/a/360973/</a> &gt; <a href="https://ahaochan.github.io/posts/IP_address,_subnet_mask,_gateway_Introduction.html">https://ahaochan.github.io/posts/IP_address,_subnet_mask,_gateway_Introduction.html</a> &gt; <a href="https://www.zhihu.com/question/20717354">https://www.zhihu.com/question/20717354</a></p></blockquote><p>《TCP/IP 详解 卷 1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用WinDbg查看调用堆栈</title>
      <link href="/post/2414867920.html"/>
      <url>/post/2414867920.html</url>
      
        <content type="html"><![CDATA[<h2 id="一-显示堆栈信息"><a href="#一-显示堆栈信息" class="headerlink" title="一. 显示堆栈信息"></a>一. 显示堆栈信息</h2><p><strong><code>k*</code>命令</strong></p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] [FrameCount]</span><br><span class="line">[~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] = BasePtr [FrameCount]</span><br><span class="line">[~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] = BasePtr StackPtr InstructionPtr</span><br><span class="line">[~Thread] kd [WordCount]</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p><strong>参数：</strong><br><em>Thread：</em> &nbsp;指定显示哪个线程的调用堆栈。如果省略该参数，则显示当前线程的调用堆栈。<em>显示所有线程的调用堆栈。<br><em>b：</em> &nbsp;显示每个函数的前3个参数。<br><em>p：</em> &nbsp;显示每个函数的所有参数。参数列表包括每个参数的类型、名称、值。<br><em>P：</em> &nbsp;类似于</em>p*。不同之处在于，每个参数显示在单独的行上面。<br><em>n：</em> &nbsp;显示调用堆栈中每帧的序号（一般称栈帧，如栈帧3）。<br><em>FrameCount：</em> &nbsp;指定显示调用堆栈的帧数，即调用堆栈的深度。默认为16进制格式。默认帧数为0x14=20</p><h2 id="二-切换到指定帧信息"><a href="#二-切换到指定帧信息" class="headerlink" title="二. 切换到指定帧信息"></a>二. 切换到指定帧信息</h2><p>调用堆栈显示出来之后，如果想知道调用某帧时的相关信息，可以使用<code>.frame</code>来切换到指定的帧，然后就可以使用如<code>dv</code>命令显示局部变量等。</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.frame [/c] [/r] [FrameNumber] </span><br></pre></td></tr></tbody></table></figure><p><em>/r：</em> &nbsp;显示执行该帧时寄存器的值。</p><p><em>FrameNumber：</em> &nbsp;指定要切换到的帧号。</p>]]></content>
      
      
      <categories>
          
          <category> ⑦ 软件调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的DECLARE...HANDLER使用</title>
      <link href="/post/3457369310.html"/>
      <url>/post/3457369310.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、-功能"><a href="#一、-功能" class="headerlink" title="一、 功能"></a>一、 功能</h2><p><code>DECLARE...HANDLER</code>语法如下：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> handler_action HANDLER</span><br><span class="line">    <span class="keyword">FOR</span> condition_value [, condition_value] ...</span><br><span class="line">    statement</span><br></pre></td></tr></tbody></table></figure><p>功能概括起来就是：<br>在一个或者多个<code>condition_value</code>条件满足时，先执行<code>statement语句</code>，然后执行<code>handler_action动作</code>。</p><span id="more"></span><h2 id="二、-参数解释"><a href="#二、-参数解释" class="headerlink" title="二、 参数解释"></a>二、 参数解释</h2><h3 id="2-1-statement"><a href="#2-1-statement" class="headerlink" title="2.1 statement"></a>2.1 statement</h3><p><code>statement</code>语句可以是一行简单的SQL语句，如<code>SET var_name = value</code>，也可以是多行复杂的的SQL语句，但多行SQL语句需要使用<code>BEGIN</code>和<code>END</code>包围。</p><p>简单statement：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="number">1051</span> <span class="keyword">SET</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><p>复杂的statement：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="number">1051</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="comment">-- body of handler</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-handler-action"><a href="#2-2-handler-action" class="headerlink" title="2.2 handler_action"></a>2.2 handler_action</h3><p><code>handler_action</code>的取值如下：</p><ol><li><code>CONTINUE</code>：表示继续执行当前SQL脚本。</li><li><code>EXIT</code>：表示终止执行当前SQL脚本。即使<code>condition_value</code>（见2.3）由<code>statement</code>语句的<code>BEGIN...AND</code>语句块引发，也是一样会终止执行。</li></ol><h3 id="2-3-condition-value"><a href="#2-3-condition-value" class="headerlink" title="2.3 condition_value"></a>2.3 condition_value</h3><p><code>condition_value</code>的取值可以为如下几种：</p><p>● <em>mysql_error_code</em>：MySQL的错误码，整数类型。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="number">1051</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="comment">-- body of handler</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>MySQL错误码取值见:<a href="https://dev.mysql.com/doc/refman/5.7/en/error-messages-server.html">https://dev.mysql.com/doc/refman/5.7/en/error-messages-server.html</a></p></blockquote><p>● <code>SQLSTATE</code> ：用5个字符表示的SQLSTATE值。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">'42S02'</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- body of handler</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>以<code>'00'</code>开始的值表示成功。<br><code>SQLSTATE</code>的完整取值列表见:<a href="https://dev.mysql.com/doc/refman/5.7/en/error-messages-server.html">https://dev.mysql.com/doc/refman/5.7/en/error-messages-server.html</a></p></blockquote><p>● <em>condition_name</em>：使用<code>DECLARE ... CONDITION</code>定义的条件的名称。</p><blockquote><p>如何使用<code>DECLARE ... CONDITION</code>定义条件，见：<a href="https://dev.mysql.com/doc/refman/5.7/en/declare-condition.html">https://dev.mysql.com/doc/refman/5.7/en/declare-condition.html</a></p></blockquote><p>● <code>SQLWARNING</code>：相当于值从<code>'01'</code>开始的<code>SQLSTATE</code> 。<br>● <code>NOT FOUND</code>：相当于值从<code>'02'</code>开始的<code>SQLSTATE</code> 。<br>● <code>SQLEXCEPTION</code>：相当于值不为<code>'00','01','02'</code>的所有 <code>SQLSTATE</code>。</p><blockquote><p>参考文档: <a href="https://dev.mysql.com/doc/refman/5.7/en/declare-handler.html">https://dev.mysql.com/doc/refman/5.7/en/declare-handler.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ⑨ 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用WinDbg调试关键区死锁</title>
      <link href="/post/3177767322.html"/>
      <url>/post/3177767322.html</url>
      
        <content type="html"><![CDATA[<p>本文通过一个实例来讲解如何使用WinDbg来调试Windows CriticalSection死锁的问题。</p><h1 id="一-演示示例"><a href="#一-演示示例" class="headerlink" title="一. 演示示例"></a>一. 演示示例</h1><p>这里有一个关键区锁死问题的程序，运行之后依次点击“CS锁死”按钮、右上角退出按钮，程序就会卡死。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/windbg-debug-cs-1.png"></p><p>对于眼下的这个问题，界面完全失去响应，这说明负责消息处理的UI线程阻塞了。</p><p>对于几乎所有的windows GUI程序，编号为0的初始线程就是UI线程，windows发现该界面一段时间没有消息响应之后就会在标题后面加上“（未响应）”。</p><span id="more"></span><h1 id="二-WinDbg调试"><a href="#二-WinDbg调试" class="headerlink" title="二. WinDbg调试"></a>二. WinDbg调试</h1><p>启动Windbg，附加到执行进程（F6）。</p><p><code>~*knv3</code>查看各个线程的调用堆栈，数字3表示显示的堆栈深度，省略即显示完整堆栈。</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/windbg-debug-cs-2.png"></p><p>#0号线的栈帧0表示线程程阻塞在<code>NtWaitForSingleObject</code>函数，MSDN得知该函数原型为：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI <span class="title function_">NtWaitForSingleObject</span><span class="params">(</span></span><br><span class="line"><span class="params"> _In_ HANDLE         Handle, </span></span><br><span class="line"><span class="params">  _In_ BOOLEAN        Alertable,</span></span><br><span class="line"><span class="params">  _In_ PLARGE_INTEGER Timeout</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure><p>第一个参数Handle为其等待的句柄，第三个参数TimeOut为超时时间。<br>同样从栈帧0得知NtWaitForSingleObject正在等待句柄000000c4，超时时间为0（即没信号就一直等待）。</p><p><code>!handle 000000c4 f</code> 命令查看000000c4句柄的信息：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/windbg-debug-cs-3.png"></p><p>现在我们知道c4句柄就是线程ID:20d0的句柄，主线程在退出的时候等待该线程退出，而该线程一直没有退出，所以主线程卡死了。</p><p>根据图3得知20d0线程就是#1线程，<code>~1kvn</code>查看该线程完整堆栈：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/windbg-debug-cs-4.png"></p><p>栈帧00 <code>NtWaitForSingleObject</code>表示线程在等待000000c0句柄。</p><h3 id="handle"><a href="#handle" class="headerlink" title="!handle"></a>!handle</h3><p><code>!handle 000000c0 f</code>查看句柄信息，得知c0句柄为事件句柄：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; !handle c0 f</span><br><span class="line">Handle c0</span><br><span class="line">  Type           Event</span><br><span class="line">  Attributes     0</span><br><span class="line">  GrantedAccess  0x100003:</span><br><span class="line">         Synch</span><br><span class="line">         QueryState,ModifyState</span><br><span class="line">  HandleCount    2</span><br><span class="line">  PointerCount   4</span><br><span class="line">  Name           &lt;none&gt;</span><br><span class="line">  Object Specific Information</span><br><span class="line">    Event Type Auto Reset</span><br><span class="line">    Event is Waiting</span><br></pre></td></tr></tbody></table></figure><h3 id="locks"><a href="#locks" class="headerlink" title="!locks"></a>!locks</h3><p><code>!locks</code>查看进程中哪些锁处于锁定状态：</p><p><img src="https://blog-static.jiangxueqiao.com/blog/img/windbg-debug-cs-6.png"></p><p>从第一行结果可以得知是gcsName临界区（需要有pdb才会显示具体变量名）处于锁定状态。</p><blockquote><p>其实，我们从栈帧02 <code>RtlEnterCriticalSection</code>也可以很快的知道该线程一直在等待进入关键区。</p></blockquote><p>经过分析，知道程序无法退出的原因了：线程#1中的关键区gcsName处于锁定状态（也就是一直等待进入关键区），导致线程#1阻塞无法执行。又因主线程在退出的时候执行了WaitForSingleObject等待#1线程，从而导致主线程卡死。</p><h3 id="RTL-CRITICAL-SECTION结构"><a href="#RTL-CRITICAL-SECTION结构" class="headerlink" title="RTL_CRITICAL_SECTION结构"></a>RTL_CRITICAL_SECTION结构</h3><p>关键区机制主要是通过下面这样的RTL_CRITICAL_SECTION结构来实现的，可以通过<code>dt</code>命令查看该结构定义：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; dt RTL_CRITICAL_SECTION</span><br><span class="line">Test1!RTL_CRITICAL_SECTION</span><br><span class="line">   +0x000 DebugInfo        : Ptr32 _RTL_CRITICAL_SECTION_DEBUG</span><br><span class="line">   +0x004 LockCount        : Int4B</span><br><span class="line">   +0x008 RecursionCount   : Int4B</span><br><span class="line">   +0x00c OwningThread     : Ptr32 Void</span><br><span class="line">   +0x010 LockSemaphore    : Ptr32 Void</span><br><span class="line">   +0x014 SpinCount        : Uint4B</span><br></pre></td></tr></tbody></table></figure><p>其中，LockCount字段用来标识关键区的锁状态，RecursionCount字段用来记录递归次数，用来支持同一个线程多次进入关键区，OwningThread字段用来记录进入（拥有）关键区的线程ID，LockSemaphore用来记录这个关键区对应的事件对象，当有线程需要等待这个关键区时，便是通过等待这个事件来做到的，这个事件对象是按需创建的，如果LockSemaphore为NULL表示这个关键区从来没有线程在此等待过。</p><p>通过图6中的OwningThread=738得知，关键区被线程ID为738的线程所拥有，即Enter之后一直没有Leave。</p><p>知道了是哪个线程获取了关键区但没有释放，就可以很容易的在代码中定位问题了。</p><h3 id="cs-l"><a href="#cs-l" class="headerlink" title="!cs -l"></a>!cs -l</h3><p><code>!locks</code>没有显示LockSemaphore字段，我们可以通过<code>!cs -l</code>命令获取更为全面的关键区信息：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windbg-debug-cs-5.png"></p><p>从上图可以看到LockSemaphore=0xC0，正好是#1线程NtWaitForSingleObject的事件对象。</p><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ⑦ 软件调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windbg </tag>
            
            <tag> Deadlock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用WinDbg调试互斥体死锁</title>
      <link href="/post/1092140776.html"/>
      <url>/post/1092140776.html</url>
      
        <content type="html"><![CDATA[<p>本文通过一个实例来讲解如何使用WinDbg来调试Windows Mutex死锁的问题。</p><span id="more"></span><h2 id="一-演示用例"><a href="#一-演示用例" class="headerlink" title="一. 演示用例"></a>一. 演示用例</h2><p>下面是一个会导致Mutex死锁的程序。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE hMutexA = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE hMutexB = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> __stdcall <span class="title">ThreadProc1</span><span class="params">(<span class="type">void</span> * pArg)</span> </span>{</span><br><span class="line">  <span class="built_in">WaitForSingleObject</span>(hMutexA, INFINITE);</span><br><span class="line">  <span class="built_in">Sleep</span>(<span class="number">500</span>);</span><br><span class="line">  <span class="built_in">WaitForSingleObject</span>(hMutexB, INFINITE);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"+++\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ReleaseMutex</span>(hMutexB);</span><br><span class="line">  <span class="built_in">ReleaseMutex</span>(hMutexA);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> __stdcall <span class="title">ThreadProc2</span><span class="params">(<span class="type">void</span> * pArg)</span> </span>{</span><br><span class="line">  <span class="built_in">WaitForSingleObject</span>(hMutexB, INFINITE);</span><br><span class="line">  <span class="built_in">Sleep</span>(<span class="number">500</span>);</span><br><span class="line">  <span class="built_in">WaitForSingleObject</span>(hMutexA, INFINITE);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"...\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ReleaseMutex</span>(hMutexA);</span><br><span class="line">  <span class="built_in">ReleaseMutex</span>(hMutexB);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  hMutexA = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, FALSE, <span class="built_in">TEXT</span>(<span class="string">"MutexA"</span>));</span><br><span class="line">  hMutexB = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, FALSE, <span class="built_in">TEXT</span>(<span class="string">"MutexB"</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动线程</span></span><br><span class="line">  HANDLE hThread1 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc1, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  HANDLE hThread2 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc2, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待线程退出并关闭句柄</span></span><br><span class="line">  <span class="keyword">if</span> (hThread1) {</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread1, INFINITE);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread1);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hThread2) {</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread2, INFINITE);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread2);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭句柄</span></span><br><span class="line">  <span class="keyword">if</span>(hMutexA)</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hMutexA);</span><br><span class="line">  <span class="keyword">if</span>(hMutexB)</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hMutexB);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二-死锁原因"><a href="#二-死锁原因" class="headerlink" title="二. 死锁原因"></a>二. 死锁原因</h2><p>程序生成了2个线程（线程1、线程2）和2个互斥体MutexA和MutexB。<br>观察线程执行代码可知，这是一个典型的死锁用例，2个线程相互等待。</p><p><em><strong>线程1：</strong></em> 拥有MutexA  –&gt; 过一段时间(sleep) —&gt; 想拥有MutexB</p><p> <em><strong>线程2：</strong></em> 拥有MutexB  –&gt; 过一段时间(sleep) —&gt; 想拥有MutexA</p><p>线程1想拥有属于线程2的MutexB，而线程2却想拥有属于线程1的MutexA，互不松手，就只能都等着了。</p><h2 id="三-Windbg调试"><a href="#三-Windbg调试" class="headerlink" title="三. Windbg调试"></a>三. Windbg调试</h2><p><code>~*kvn</code>查看所有线程调用堆栈：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windbg-debug-mutext-1.png"></p><p>从线程#1栈帧03可以看到其正在等待句柄00000038。<br>从线程#2栈帧03可以看到其正在等待句柄00000034。<br>即：<br>线程#1（ID：22f4）—&gt;等待句柄38<br>线程#2（ID：33bc）—&gt; 等待句柄34</p><p>使用<code>!handle</code>命令查看句柄00000034和00000038是什么类型：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/windbg-debug-mutext-2.png"></p><p>从图中可以看到：<br>句柄00000034为名为MutexA的互斥体，被线程ID：2264 拥有。<br>句柄00000038为名为MutexB的互斥体，被线程ID：33bc 拥有。</p><p>即：<br>线程#1（ID：22f4）等待00000038（互斥体MutexA ），拥有00000034（互斥体MutexB)<br>线程#2（ID：33bc）等待句柄00000034（互斥体MutexB ），拥有00000038（互斥体MutexA)</p><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ⑦ 软件调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windbg </tag>
            
            <tag> Deadlock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个MySQL存储过程模板</title>
      <link href="/post/254517042.html"/>
      <url>/post/254517042.html</url>
      
        <content type="html"><![CDATA[<p>在进行数据库开发时，我们可能需要写很多存储过程，本文提供一个存储过程的模板，通过该模板可以简化存储过程的开发。</p><span id="more"></span><p>MySQL存储过程的范例模板，带返回值和异常处理的功能。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> sp_sample;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> sp_sample(<span class="keyword">OUT</span> errno <span class="type">INT</span>)</span><br><span class="line">root:<span class="keyword">BEGIN</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    功能：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    IN参数：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    OUT参数：</span></span><br><span class="line"><span class="comment">           errno 存储过程异常标志(0-成功, 1-异常)           </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLEXCEPTION</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">ROLLBACK</span>;</span><br><span class="line">        <span class="keyword">SET</span> errno <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line">    <span class="keyword">SET</span> errno <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">    <span class="comment">-- do what you want to do.</span></span><br><span class="line">    <span class="comment">-- ...</span></span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></tbody></table></figure><p>其中，存储过程的异常捕获和回滚使用<code>DECLARE...HANDLER</code>实现：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLEXCEPTION</span></span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">       <span class="keyword">ROLLBACK</span>;</span><br><span class="line">       <span class="keyword">SET</span> errno <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">END</span>;</span><br></pre></td></tr></tbody></table></figure><p>关于<code>DECLARE...HANDLER</code>的用法见： <a href="/post/3457369310.html" title="MySQL的DECLARE...HANDLER使用">MySQL的DECLARE...HANDLER使用</a></p>]]></content>
      
      
      <categories>
          
          <category> ⑨ 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows套接字I/O模型(5)-完成端口模型</title>
      <link href="/post/326824759.html"/>
      <url>/post/326824759.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>前面的文章已经介绍了套接字I/O的同步模型、WSAAsyncSelect模型、WSAEventSelect模型，到目前为止套接字I/O还剩下2个模型没有介绍：<code>重叠模型</code>，<code>完成端口模型</code>。 </p><p>如果程序对性能和并发要求不高，可以使用前面介绍的WSAEventSelect模型；如果对性能和并发有要求，可以使用本文介绍的完成端口模型。<br>因为完成端口模型是基于重叠模型的，且在易用性、可伸缩性等方面都高于重叠模型，在一般选择重叠模型的场合，都可以用完成端口模型来替代，强烈建议使用完成端口模型。</p><p><code>完成端口模型</code>是windows系统上面套接字I/O的终极模型，可以用它代替前面的所有模型。如果对完成端口模型有一个好的封装，基本上可以“一招鲜，吃遍天”，免去重复造轮子的麻烦。所以这里对完成端口的模型的介绍和比前面的几篇篇幅更长，示例代码也更加复杂和全面。</p><h1 id="Reactor和Proactor"><a href="#Reactor和Proactor" class="headerlink" title="Reactor和Proactor"></a>Reactor和Proactor</h1><p>在网络编程中，我们常听到的2种I/O多路复用的模式：reactor和proactor。<br>对于这2种模式的区别通俗来说就是：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reactor： 能收了你跟我说一声。</span><br><span class="line">Proactor: 你帮我最多收十个字节，收好了跟我说一声。</span><br></pre></td></tr></tbody></table></figure><p>windows提供的<code>完成端口模型</code>就是Proactor模式；而Linux上面由于没有操作系统的支持，只能使用Reactor模式，如epoll等。</p><h1 id="二、完成端口模型介绍"><a href="#二、完成端口模型介绍" class="headerlink" title="二、完成端口模型介绍"></a>二、完成端口模型介绍</h1><p>完成端口模型说白了就是，您要做什么事情（如接收连接AcceptEx、发送数据WSASend、接收数据WSARecv、连接服务端ConnectEx），您告诉我，我做完了通知您。这里的“我”指的是操作系统，“您”指的是应用程序。<br>如应用程序需要接收其他端发来的数据，可以调用WSARecv，并指定接收数据的缓冲区及大小，等其他端发来数据时，操作系统自动将数据放入到应用程序指定的缓冲区中，然后通知应用程序数据来啦。 这个和<code>WSAEventSelect模型</code>最大的不同就是，<code>WSAEventSelect模型</code>只是通知程序数据来了，并没有将数据接收，还需要程序调用recv来接收数据。</p><h2 id="2-1-完成端口创建和绑定"><a href="#2-1-完成端口创建和绑定" class="headerlink" title="2.1 完成端口创建和绑定"></a>2.1 完成端口创建和绑定</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateIoCompletionPort</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_     HANDLE    FileHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_opt_ HANDLE    ExistingCompletionPort,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_     ULONG_PTR CompletionKey,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_     DWORD     NumberOfConcurrentThreads</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>CreateIoCompletionPort这个函数比较特殊，根据传入的参数不同，它可以实现2个功能：创建一个完成端口；将完成端口和设备（套接字）相绑定。一般对该函数进行如下封装来实现这2个功能：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateNewCompletionPort</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">CreateIoCompletionPort</span>(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">AssociateDeviceWithCompletionPort</span><span class="params">(HANDLE completion_port, HANDLE device, DWORD completion_key)</span> </span>{</span><br><span class="line">  HANDLE h = <span class="built_in">CreateIoCompletionPort</span>(device, completion_port, completion_key, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (h == completion_port);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2-线程池"><a href="#2-2-线程池" class="headerlink" title="2.2 线程池"></a>2.2 线程池</h2><p>前面说到了，<code>完成端口模型</code>就是应用程序等着操作系统把事情做完了通知它。那既然是<code>等</code>，<code>等</code>的操作肯定是<code>阻塞</code>住了的，所以不能在主线程中<code>等</code>，我们需要启动子线程去等。可是启动多个子线程去<code>等</code>了，一个连接一个线程吗？我们知道，线程越多，占用的系统资源也就越多，而且线程的切换也是消耗CPU时间的。所以线程不是越多越好，这里有一个经验法则就是：<code>线程数量 = CPU数量 * 2</code>。</p><p>线程数量和CPU数量相同是最理想的环境，这样免去了CPU在各个线程之间切换，但现实情况下，难免某些线程执行某些任务耗时较长，导致CPU将时间片从该线程分拨出去。所以这里用CPU数量乘以2，最大限度的利用CPU资源。这也是完成端口的目标，即最大限度的利用CPU资源。</p><p>获取CPU数量的方式：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNumberOfProcesser</span><span class="params">()</span> </span>{</span><br><span class="line">  SYSTEM_INFO si;</span><br><span class="line">  <span class="built_in">GetSystemInfo</span>(&amp;si);</span><br><span class="line">  <span class="keyword">return</span> si.dwNumberOfProcessors;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-AcceptEx等"><a href="#2-3-AcceptEx等" class="headerlink" title="2.3 AcceptEx等"></a>2.3 AcceptEx等</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">AcceptEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  SOCKET       sListenSocket,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  SOCKET       sAcceptSocket,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  PVOID        lpOutputBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  DWORD        dwReceiveDataLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  DWORD        dwLocalAddressLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  DWORD        dwRemoteAddressLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_ LPDWORD      lpdwBytesReceived,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>AcceptEx和WSARecv、WSASend、ConnectEx等函数类似，最后一个参数都是LPOVERLAPPED，需要调用者提供一个重叠结构。<br>但这个AcceptEx、ConnectEx等函数比较特别，他们是微软专门在Windows操作系统里面提供的扩展函数，不是在Winsock2标准里面提供的，是微软为了方便使用重叠I/O机制，额外提供的一些函数。</p><p>以AcceptEx为例，微软的实现是通过mswsock.dll中提供的，所以我们可以通过静态链接mswsock.lib来直接调用AcceptEx。但不推荐使用这种方式，因为每次直接调用AcceptEx时，Service Provider都得要通过WSAIoctl()获取一次该函数指针，这样效率比较低。所以我们一般都是在直接代码中先获取到这个函数指针，并保存下来，后面直接使用这个函数指针就好了。</p><p>获取AcceptEx等函数的指针的方式：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPFN_ACCEPTEX <span class="title">GetAcceptExFnPointer</span><span class="params">(SOCKET s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  LPFN_ACCEPTEX fn = <span class="literal">NULL</span>; </span><br><span class="line">  GUID GuidAcceptEx = WSAID_ACCEPTEX;</span><br><span class="line">  DWORD bytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">WSAIoctl</span>(</span><br><span class="line">    s,</span><br><span class="line">    SIO_GET_EXTENSION_FUNCTION_POINTER,</span><br><span class="line">    &amp;GuidAcceptEx,</span><br><span class="line">    <span class="built_in">sizeof</span>(GuidAcceptEx),</span><br><span class="line">    &amp;fn,</span><br><span class="line">    <span class="built_in">sizeof</span>(fn),</span><br><span class="line">    &amp;bytes,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">LPFN_CONNECTEX <span class="title">GetConnectExFnPointer</span><span class="params">(SOCKET s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  LPFN_CONNECTEX fn = <span class="literal">NULL</span>;</span><br><span class="line">  GUID GuidConnectEx = WSAID_CONNECTEX;</span><br><span class="line">  DWORD bytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">WSAIoctl</span>(</span><br><span class="line">    s,</span><br><span class="line">    SIO_GET_EXTENSION_FUNCTION_POINTER,</span><br><span class="line">    &amp;GuidConnectEx,</span><br><span class="line">    <span class="built_in">sizeof</span>(GuidConnectEx),</span><br><span class="line">    &amp;fn,</span><br><span class="line">    <span class="built_in">sizeof</span>(fn),</span><br><span class="line">    &amp;bytes,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">LPFN_GETACCEPTEXSOCKADDRS <span class="title">GetAcceptExSockAddrsFnPointer</span><span class="params">(SOCKET s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  LPFN_GETACCEPTEXSOCKADDRS fn = <span class="literal">NULL</span>;</span><br><span class="line">  GUID GuidGetAcceptExSockAddrs = WSAID_GETACCEPTEXSOCKADDRS;</span><br><span class="line">  DWORD bytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">WSAIoctl</span>(</span><br><span class="line">    s,</span><br><span class="line">    SIO_GET_EXTENSION_FUNCTION_POINTER,</span><br><span class="line">    &amp;GuidGetAcceptExSockAddrs,</span><br><span class="line">    <span class="built_in">sizeof</span>(GuidGetAcceptExSockAddrs),</span><br><span class="line">    &amp;fn,</span><br><span class="line">    <span class="built_in">sizeof</span>(fn),</span><br><span class="line">    &amp;bytes,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-4-GetQueuedCompletionStatus"><a href="#2-4-GetQueuedCompletionStatus" class="headerlink" title="2.4 GetQueuedCompletionStatus"></a>2.4 GetQueuedCompletionStatus</h2><p>函数原型如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetQueuedCompletionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  HANDLE       CompletionPort,</span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_ LPDWORD      lpNumberOfBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_ PULONG_PTR   lpCompletionKey,</span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_ LPOVERLAPPED *lpOverlapped,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  DWORD        dwMilliseconds</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>前面说到了，完成端口模型需要在子线程中等待操作系统做完事情之后的通知。而<code>GetQueuedCompletionStatus</code>函数就是用来等待这个通知的。通过该函数可以获取的本次传输的字节数<code>lpNumberOfBytes</code>、一个用户绑定在套接字上的自定义整数<code>lpCompletionKey</code>、用户调用WSASend等函数时指定的OVERLAPPED结构的指针<code>lpOverlapped</code>。</p><p>我们比较关注的是lpCompletionKey、lpOverlapped这2个参数：<br><code>lpCompletionKey</code>是调用CreateIoCompletionPort函数绑定完成端口和套接字时指定的，每个套接字(SOCKET)对应一个lpCompletionKey。lpCompletionKey可以是包括指针在内的任何整数。</p><p><code>lpOverlapped</code>是每次调用WSASend等函数时指定的，每一次操作（也就是每一次调用，如WSASend, WSARecv, AcceptEx, ConnectEx）对应的lpOverlapped都不一样，所以一次操作对应一个lpOverlapped。一个SOCKET可以有多次操作，多以对应多个lpOverlapped。</p><p>对应关系如下：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+-----------+           +--------------------+</span><br><span class="line">|           |  1 --&gt; 1  |                    |</span><br><span class="line">| SOCKET    +-----------&gt; lpCompletionKey    |</span><br><span class="line">|           |           |                    |</span><br><span class="line">+-----+-----+           +--------------------+</span><br><span class="line">      |</span><br><span class="line">      |1 --&gt; n</span><br><span class="line">      |</span><br><span class="line">+-----v------------------+</span><br><span class="line">|                        |</span><br><span class="line">| Send,Recv,Accept...    |</span><br><span class="line">|                        |</span><br><span class="line">+-----+------------------+</span><br><span class="line">      |</span><br><span class="line">      |1 --&gt; 1</span><br><span class="line">      |</span><br><span class="line">+-----v------------------+</span><br><span class="line">|                        |</span><br><span class="line">| lpOverlapped           |</span><br><span class="line">|                        |</span><br><span class="line">+------------------------+</span><br></pre></td></tr></tbody></table></figure><p>注：示例代码中的PER_SOCKET_CONTEXT结构对应图中的SOCKET，PER_IO_CONTEXT结构对应图中的lpOverlapped。知道这个对理解示例代码会有很大的帮助。</p><p>Windows还提供了一个辅助宏<code>CONTAINING_RECORD</code>，该宏可以根据结构体中的某成员的地址来推算出该结构体整体的地址。<br>知道了这个功能，我们就可以在<code>lpOverlapped</code>参数上做文章了（扩展），具体见示例。</p><blockquote><p>上面对完成端口模型只做了一个简单的介绍，关于完成端口的详细介绍可以参考《windows核心编程 第5版》 10.3节。</p></blockquote><h2 id="2-5-CONTAINING-RECORD宏的实现原理"><a href="#2-5-CONTAINING-RECORD宏的实现原理" class="headerlink" title="2.5 CONTAINING_RECORD宏的实现原理"></a>2.5 CONTAINING_RECORD宏的实现原理</h2><p>该宏的作用就是：根据结构体中的某成员的地址来推算出该结构体整体的地址，相当于一个万能公式。</p><p>下面代码的注释中，讲解了该宏的实现原理。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">T</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">    };</span><br><span class="line">    <span class="comment">//CONTAINING_RECORD宏的作用就是根据结构体中的某成员的地址来推算出该结构体整体的地址。</span></span><br><span class="line">    T t = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };</span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设我们知道T结构体中b的地址和名称，求t的指针</span></span><br><span class="line">    T *pT = <span class="built_in">CONTAINING_RECORD</span>(&amp;t.b, T, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d b:%d c:%d\n"</span>, pT-&gt;a, pT-&gt;b, pT-&gt;c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CONTAINING_RECORD的定义:</span></span><br><span class="line">    <span class="comment">//((type *)( (PCHAR)(address) - (ULONG_PTR)(&amp;((type *)0)-&gt;field)))</span></span><br><span class="line">    <span class="comment">//最后一部分(&amp;((type *)0)-&gt;field) 将0(空指针)转成type，再取地址。</span></span><br><span class="line">    <span class="comment">//在本例中就是将空指针转成T*, 然后指向b这个变量, 然后再取地址。</span></span><br><span class="line">    <span class="comment">//这个操作的作用就是：假设T开始在0x000000内存位置上分配内存，在此基础上求b的内存地址,</span></span><br><span class="line">    <span class="comment">//这样等同于求得b的内存结构体对齐偏移量, 求得b的地址我们转成ULONG_PTR类型,</span></span><br><span class="line">    <span class="comment">//然后用实际b的内存地址减去b的结构体偏移量求得结构体首地址。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//分解开来就是：</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种情况是允许的。</span></span><br><span class="line">    <span class="comment">//这个大前提很重要！！！</span></span><br><span class="line">    T *pTemp = (T*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求b的内存地址,在结构体首地址为0的情况下b的内存地址其实就是自身的对齐大小偏移量！！！</span></span><br><span class="line">    <span class="comment">//CONTAINING_RECORD宏的核心！！！</span></span><br><span class="line">    <span class="type">int</span> *pB = &amp;pTemp-&gt;b;</span><br><span class="line"></span><br><span class="line">    ULONG_PTR Offset = (ULONG_PTR)pB; <span class="comment">//转成数字, 就是b的偏移量。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b的偏移量:%d\n"</span>, Offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为各个成员的地址是递增的，最后用实际b的地址减b的偏移量的到结构体首地址</span></span><br><span class="line">    T *pFinal = (T*)(((<span class="type">char</span>*)&amp;t.b) - Offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"T中a:%d b:%d c:%d\n"</span>, pFinal-&gt;a, pFinal-&gt;b, pFinal-&gt;c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h1><p>示例代码实现如下功能：</p><ol><li>服务端和客户端都使用完成端口模型来实现。</li><li>服务端和客户端之间通过发送消息来模拟TCP的三次握手机制。</li></ol><h2 id="3-1-辅助函数"><a href="#3-1-辅助函数" class="headerlink" title="3.1 辅助函数"></a>3.1 辅助函数</h2><p>iocp.h和iocp.cpp中实现了IOCP相关的结构体定义和一些通用的辅助函数：<br><strong>iocp.h</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iocp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> IOCP_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;MSWSock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFFER_LEN        8192  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_CODE        0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IOCP {</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_OPERATION_TYPE</span></span><br><span class="line">  {</span><br><span class="line">    ACCEPT_POSTED,</span><br><span class="line">    CONNECT_POSTED,</span><br><span class="line">    SEND_POSTED,</span><br><span class="line">    RECV_POSTED,</span><br><span class="line">    NULL_POSTED</span><br><span class="line">  }OPERATION_TYPE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PER_IO_CONTEXT</span></span><br><span class="line">  {</span><br><span class="line">    OVERLAPPED     overlapped;            </span><br><span class="line">    SOCKET         socket;</span><br><span class="line">    WSABUF         wsa_buffer;</span><br><span class="line">    <span class="type">char</span>           buffer[MAX_BUFFER_LEN];</span><br><span class="line">    OPERATION_TYPE operation_type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    _PER_IO_CONTEXT() {</span><br><span class="line">      <span class="built_in">ZeroMemory</span>(&amp;overlapped, <span class="built_in">sizeof</span>(overlapped));</span><br><span class="line">      <span class="built_in">ZeroMemory</span>(buffer, MAX_BUFFER_LEN);</span><br><span class="line">      socket = INVALID_SOCKET;</span><br><span class="line">      wsa_buffer.buf = buffer;</span><br><span class="line">      wsa_buffer.len = MAX_BUFFER_LEN;</span><br><span class="line">      operation_type = NULL_POSTED;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~_PER_IO_CONTEXT() {</span><br><span class="line">      <span class="keyword">if</span> (socket != INVALID_SOCKET) {</span><br><span class="line">        <span class="built_in">closesocket</span>(socket);</span><br><span class="line">        socket = INVALID_SOCKET;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ResetBuffer</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="built_in">ZeroMemory</span>(buffer, MAX_BUFFER_LEN);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  } PER_IO_CONTEXT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PER_SOCKET_CONTEXT</span> {</span><br><span class="line">    SOCKET      socket; </span><br><span class="line">    SOCKADDR_IN client_addr;</span><br><span class="line">    std::vector&lt;_PER_IO_CONTEXT*&gt; io_ctx_array;</span><br><span class="line"></span><br><span class="line">    _PER_SOCKET_CONTEXT() {</span><br><span class="line">      socket = INVALID_SOCKET;</span><br><span class="line">      <span class="built_in">memset</span>(&amp;client_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(client_addr));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~_PER_SOCKET_CONTEXT()</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span> (socket != INVALID_SOCKET) {</span><br><span class="line">        <span class="built_in">closesocket</span>(socket);</span><br><span class="line">        socket = INVALID_SOCKET;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; io_ctx_array.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        <span class="keyword">delete</span> io_ctx_array[i];</span><br><span class="line">      }</span><br><span class="line">      io_ctx_array.<span class="built_in">clear</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">_PER_IO_CONTEXT* <span class="title">GetNewIoContext</span><span class="params">()</span> </span>{</span><br><span class="line">      _PER_IO_CONTEXT* p = <span class="keyword">new</span> _PER_IO_CONTEXT;</span><br><span class="line"></span><br><span class="line">      io_ctx_array.<span class="built_in">push_back</span>(p);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveContext</span><span class="params">(_PER_IO_CONTEXT* pContext)</span> </span>{</span><br><span class="line">      <span class="keyword">for</span> (std::vector&lt;_PER_IO_CONTEXT*&gt;::iterator it = io_ctx_array.<span class="built_in">begin</span>(); </span><br><span class="line">        it != io_ctx_array.<span class="built_in">end</span>(); it++) {</span><br><span class="line">        <span class="keyword">if</span> (pContext == *it) {</span><br><span class="line">          <span class="keyword">delete</span> pContext;</span><br><span class="line">          pContext = <span class="literal">NULL</span>;</span><br><span class="line">          io_ctx_array.<span class="built_in">erase</span>(it);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  } PER_SOCKET_CONTEXT;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">GetNumberOfProcesser</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">HANDLE <span class="title">CreateNewCompletionPort</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">BOOL <span class="title">AssociateDeviceWithCompletionPort</span><span class="params">(HANDLE completion_port, HANDLE device, DWORD completion_key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">LPFN_ACCEPTEX <span class="title">GetAcceptExFnPointer</span><span class="params">(SOCKET s)</span></span>;</span><br><span class="line">  <span class="function">LPFN_CONNECTEX <span class="title">GetConnectExFnPointer</span><span class="params">(SOCKET s)</span></span>;</span><br><span class="line">  <span class="function">LPFN_GETACCEPTEXSOCKADDRS <span class="title">GetAcceptExSockAddrsFnPointer</span><span class="params">(SOCKET s)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// IOCP_H_</span></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>iocp.cpp</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iocp.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"iocp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IOCP {</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">GetNumberOfProcesser</span><span class="params">()</span> </span>{</span><br><span class="line">    SYSTEM_INFO si;</span><br><span class="line">    <span class="built_in">GetSystemInfo</span>(&amp;si);</span><br><span class="line">    <span class="keyword">return</span> si.dwNumberOfProcessors;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function">HANDLE <span class="title">CreateNewCompletionPort</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CreateIoCompletionPort</span>(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function">BOOL <span class="title">AssociateDeviceWithCompletionPort</span><span class="params">(HANDLE completion_port, HANDLE device, DWORD completion_key)</span> </span>{</span><br><span class="line">    HANDLE h = <span class="built_in">CreateIoCompletionPort</span>(device, completion_port, completion_key, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (h == completion_port);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function">LPFN_ACCEPTEX <span class="title">GetAcceptExFnPointer</span><span class="params">(SOCKET s)</span> </span>{</span><br><span class="line">    LPFN_ACCEPTEX fn = <span class="literal">NULL</span>; </span><br><span class="line">    GUID GuidAcceptEx = WSAID_ACCEPTEX;</span><br><span class="line">    DWORD bytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">WSAIoctl</span>(</span><br><span class="line">      s,</span><br><span class="line">      SIO_GET_EXTENSION_FUNCTION_POINTER,</span><br><span class="line">      &amp;GuidAcceptEx,</span><br><span class="line">      <span class="built_in">sizeof</span>(GuidAcceptEx),</span><br><span class="line">      &amp;fn,</span><br><span class="line">      <span class="built_in">sizeof</span>(fn),</span><br><span class="line">      &amp;bytes,</span><br><span class="line">      <span class="literal">NULL</span>,</span><br><span class="line">      <span class="literal">NULL</span>)) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function">LPFN_CONNECTEX <span class="title">GetConnectExFnPointer</span><span class="params">(SOCKET s)</span> </span>{</span><br><span class="line">    LPFN_CONNECTEX fn = <span class="literal">NULL</span>;</span><br><span class="line">    GUID GuidConnectEx = WSAID_CONNECTEX;</span><br><span class="line">    DWORD bytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">WSAIoctl</span>(</span><br><span class="line">      s,</span><br><span class="line">      SIO_GET_EXTENSION_FUNCTION_POINTER,</span><br><span class="line">      &amp;GuidConnectEx,</span><br><span class="line">      <span class="built_in">sizeof</span>(GuidConnectEx),</span><br><span class="line">      &amp;fn,</span><br><span class="line">      <span class="built_in">sizeof</span>(fn),</span><br><span class="line">      &amp;bytes,</span><br><span class="line">      <span class="literal">NULL</span>,</span><br><span class="line">      <span class="literal">NULL</span>)) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function">LPFN_GETACCEPTEXSOCKADDRS <span class="title">GetAcceptExSockAddrsFnPointer</span><span class="params">(SOCKET s)</span> </span>{</span><br><span class="line">    LPFN_GETACCEPTEXSOCKADDRS fn = <span class="literal">NULL</span>;</span><br><span class="line">    GUID GuidGetAcceptExSockAddrs = WSAID_GETACCEPTEXSOCKADDRS;</span><br><span class="line">    DWORD bytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">WSAIoctl</span>(</span><br><span class="line">      s,</span><br><span class="line">      SIO_GET_EXTENSION_FUNCTION_POINTER,</span><br><span class="line">      &amp;GuidGetAcceptExSockAddrs,</span><br><span class="line">      <span class="built_in">sizeof</span>(GuidGetAcceptExSockAddrs),</span><br><span class="line">      &amp;fn,</span><br><span class="line">      <span class="built_in">sizeof</span>(fn),</span><br><span class="line">      &amp;bytes,</span><br><span class="line">      <span class="literal">NULL</span>,</span><br><span class="line">      <span class="literal">NULL</span>)) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-1-服务端"><a href="#3-1-服务端" class="headerlink" title="3.1 服务端"></a>3.1 服务端</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"iocp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> u_short kPort = <span class="number">10001</span>;</span><br><span class="line"><span class="type">const</span> std::string kSYN = <span class="string">"(SYN) hello server, I'm client. Can you hear me?"</span>;</span><br><span class="line"><span class="type">const</span> std::string kSYN_ACK = <span class="string">"(SYN+ACK) hello client, I'm server. I can hear you, can you hear me?"</span>;</span><br><span class="line"><span class="type">const</span> std::string kACK = <span class="string">"(ACK) hello server, I'm client. I can hear you!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line">HANDLE g_IOCP = INVALID_HANDLE_VALUE;</span><br><span class="line">HANDLE g_exit = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_work_thread_num = <span class="number">0</span>;</span><br><span class="line">HANDLE *g_work_threads = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">IOCP::PER_SOCKET_CONTEXT *g_listen_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">CRITICAL_SECTION g_cs_socket_ctx_array;</span><br><span class="line">std::vector&lt;IOCP::PER_SOCKET_CONTEXT*&gt; g_socket_ctx_array;</span><br><span class="line"></span><br><span class="line">LPFN_ACCEPTEX g_AcceptExFn = <span class="literal">NULL</span>;</span><br><span class="line">LPFN_GETACCEPTEXSOCKADDRS g_AcceptExSockAddrsFn = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理g_socket_ctx_array</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddSocketContext</span><span class="params">(IOCP::PER_SOCKET_CONTEXT *socket_ctx)</span> </span>{</span><br><span class="line">  <span class="built_in">EnterCriticalSection</span>(&amp;g_cs_socket_ctx_array);</span><br><span class="line">  g_socket_ctx_array.<span class="built_in">push_back</span>(socket_ctx);</span><br><span class="line">  <span class="built_in">LeaveCriticalSection</span>(&amp;g_cs_socket_ctx_array);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveSocketContext</span><span class="params">(IOCP::PER_SOCKET_CONTEXT *socket_ctx)</span> </span>{</span><br><span class="line">  <span class="built_in">EnterCriticalSection</span>(&amp;g_cs_socket_ctx_array);</span><br><span class="line">  <span class="keyword">for</span> (std::vector&lt;IOCP::PER_SOCKET_CONTEXT*&gt;::iterator it = g_socket_ctx_array.<span class="built_in">begin</span>(); it != g_socket_ctx_array.<span class="built_in">end</span>(); it++) {</span><br><span class="line">    <span class="keyword">if</span> (*it == socket_ctx) {</span><br><span class="line">      <span class="keyword">delete</span> *it;</span><br><span class="line">      g_socket_ctx_array.<span class="built_in">erase</span>(it);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">LeaveCriticalSection</span>(&amp;g_cs_socket_ctx_array);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearSocketContextArray</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="built_in">EnterCriticalSection</span>(&amp;g_cs_socket_ctx_array);</span><br><span class="line">  <span class="keyword">for</span> (std::vector&lt;IOCP::PER_SOCKET_CONTEXT*&gt;::iterator it = g_socket_ctx_array.<span class="built_in">begin</span>(); it != g_socket_ctx_array.<span class="built_in">end</span>(); it++) {</span><br><span class="line">    <span class="built_in">closesocket</span>((*it)-&gt;socket);</span><br><span class="line">    <span class="keyword">delete</span> *it;</span><br><span class="line">  }</span><br><span class="line">  g_socket_ctx_array.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">LeaveCriticalSection</span>(&amp;g_cs_socket_ctx_array);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送Accept、Recv、Send请求</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PostAccept</span><span class="params">(IOCP::PER_IO_CONTEXT* io_ctx)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (io_ctx == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  io_ctx-&gt;operation_type = IOCP::ACCEPT_POSTED;</span><br><span class="line">  io_ctx-&gt;<span class="built_in">ResetBuffer</span>();</span><br><span class="line">  io_ctx-&gt;socket = <span class="built_in">WSASocket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (io_ctx-&gt;socket == INVALID_SOCKET) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"WSASocket failed with code: %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  DWORD bytes = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">g_AcceptExFn</span>(g_listen_ctx-&gt;socket,</span><br><span class="line">    io_ctx-&gt;socket,</span><br><span class="line">    io_ctx-&gt;wsa_buffer.buf,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">sizeof</span>(SOCKADDR_IN) + <span class="number">16</span>,</span><br><span class="line">    <span class="built_in">sizeof</span>(SOCKADDR_IN) + <span class="number">16</span>,</span><br><span class="line">    &amp;bytes,</span><br><span class="line">    &amp;io_ctx-&gt;overlapped) == FALSE) {</span><br><span class="line">    <span class="type">int</span> gle = <span class="built_in">WSAGetLastError</span>();</span><br><span class="line">    <span class="keyword">if</span> (gle != WSA_IO_PENDING) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"AcceptEx failed with code: %d\n"</span>, gle);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PostRecv</span><span class="params">(IOCP::PER_IO_CONTEXT* io_ctx)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (io_ctx == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  io_ctx-&gt;operation_type = IOCP::RECV_POSTED;</span><br><span class="line">  io_ctx-&gt;<span class="built_in">ResetBuffer</span>();</span><br><span class="line"></span><br><span class="line">  DWORD recv_bytes = <span class="number">0</span>;</span><br><span class="line">  DWORD flags = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> ret = <span class="built_in">WSARecv</span>(io_ctx-&gt;socket, &amp;io_ctx-&gt;wsa_buffer, <span class="number">1</span>, &amp;recv_bytes, &amp;flags, &amp;io_ctx-&gt;overlapped, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret == SOCKET_ERROR &amp;&amp; <span class="built_in">WSAGetLastError</span>() != WSA_IO_PENDING) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PostSend</span><span class="params">(IOCP::PER_IO_CONTEXT* io_ctx, <span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> msg_len)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (io_ctx == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  io_ctx-&gt;operation_type = IOCP::SEND_POSTED;</span><br><span class="line">  <span class="built_in">memcpy</span>(io_ctx-&gt;wsa_buffer.buf, msg, msg_len);</span><br><span class="line">  io_ctx-&gt;wsa_buffer.len = msg_len;</span><br><span class="line"></span><br><span class="line">  DWORD sent_bytes = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> ret = <span class="built_in">WSASend</span>(io_ctx-&gt;socket, &amp;io_ctx-&gt;wsa_buffer, <span class="number">1</span>, &amp;sent_bytes, <span class="number">0</span>, &amp;io_ctx-&gt;overlapped, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret == SOCKET_ERROR &amp;&amp; <span class="built_in">WSAGetLastError</span>() != WSA_IO_PENDING) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理Accept、Recv、Send完成之后的通知</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DoAccept</span><span class="params">(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx)</span> </span>{</span><br><span class="line">  SOCKADDR_IN* ClientAddr = <span class="literal">NULL</span>;</span><br><span class="line">  SOCKADDR_IN* LocalAddr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> remoteLen = <span class="built_in">sizeof</span>(SOCKADDR_IN);</span><br><span class="line">  <span class="type">int</span> localLen = <span class="built_in">sizeof</span>(SOCKADDR_IN);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_AcceptExSockAddrsFn</span>(io_ctx-&gt;wsa_buffer.buf, io_ctx-&gt;wsa_buffer.len - ((<span class="built_in">sizeof</span>(SOCKADDR_IN) + <span class="number">16</span>) * <span class="number">2</span>),</span><br><span class="line">    <span class="built_in">sizeof</span>(SOCKADDR_IN) + <span class="number">16</span>, <span class="built_in">sizeof</span>(SOCKADDR_IN) + <span class="number">16</span>, (LPSOCKADDR*)&amp;LocalAddr, &amp;localLen, (LPSOCKADDR*)&amp;ClientAddr, &amp;remoteLen);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"* new connection(%s:%d): %s\n"</span>, <span class="built_in">inet_ntoa</span>(ClientAddr-&gt;sin_addr), <span class="built_in">ntohs</span>(ClientAddr-&gt;sin_port), io_ctx-&gt;wsa_buffer.buf);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此次创建一个新的PER_SOCKET_CONTEXT，之前老的PER_SOCKET_CONTEXT继续用作接收客户端连接</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  IOCP::PER_SOCKET_CONTEXT *new_socket_ctx = <span class="keyword">new</span> IOCP::<span class="built_in">PER_SOCKET_CONTEXT</span>();</span><br><span class="line">  new_socket_ctx-&gt;socket = io_ctx-&gt;socket;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!IOCP::<span class="built_in">AssociateDeviceWithCompletionPort</span>(g_IOCP, (HANDLE)new_socket_ctx-&gt;socket, (DWORD)new_socket_ctx)) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"AssociateDeviceWithCompletionPort failed\n"</span>);</span><br><span class="line">    <span class="keyword">delete</span> new_socket_ctx;</span><br><span class="line">    new_socket_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">AddSocketContext</span>(new_socket_ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// post recv</span></span><br><span class="line">  IOCP::PER_IO_CONTEXT *new_io_ctx = new_socket_ctx-&gt;<span class="built_in">GetNewIoContext</span>();</span><br><span class="line">  new_io_ctx-&gt;socket = new_socket_ctx-&gt;socket;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">PostRecv</span>(new_io_ctx)) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PostRecv failed\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// post new accept</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">PostAccept</span>(io_ctx)) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PostAccept failed\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DoRecv</span><span class="params">(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx)</span> </span>{</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"recv: %s\n"</span>, io_ctx-&gt;wsa_buffer.buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(io_ctx-&gt;wsa_buffer.buf, kSYN.<span class="built_in">c_str</span>()) == <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">// SYN+ACK</span></span><br><span class="line">    IOCP::PER_IO_CONTEXT * new_io_ctx = socket_ctx-&gt;<span class="built_in">GetNewIoContext</span>();</span><br><span class="line">    new_io_ctx-&gt;socket = socket_ctx-&gt;socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PostSend</span>(new_io_ctx, kSYN_ACK.<span class="built_in">c_str</span>(), kSYN_ACK.<span class="built_in">length</span>())) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"PostSend failed\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// post new recv</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">PostRecv</span>(io_ctx)) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PostRecv failed\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DoSend</span><span class="params">(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx)</span> </span>{</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"send: %s\n"</span>, io_ctx-&gt;wsa_buffer.buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作线程</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> __stdcall <span class="title">WorkThreadProc</span><span class="params">(<span class="type">void</span> *arg)</span> </span>{</span><br><span class="line">  DWORD transferred_bytes = <span class="number">0</span>;</span><br><span class="line">  IOCP::PER_SOCKET_CONTEXT *socket_ctx = <span class="literal">NULL</span>;</span><br><span class="line">  OVERLAPPED *overlapped = <span class="literal">NULL</span>;</span><br><span class="line">  DWORD gle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">WaitForSingleObject</span>(g_exit, <span class="number">0</span>) != WAIT_OBJECT_0) {</span><br><span class="line">    BOOL ret = <span class="built_in">GetQueuedCompletionStatus</span>(g_IOCP, &amp;transferred_bytes, (PULONG_PTR)&amp;socket_ctx, &amp;overlapped, INFINITE);</span><br><span class="line">    gle = <span class="built_in">GetLastError</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (socket_ctx == EXIT_CODE) {</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == FALSE) {</span><br><span class="line">      <span class="keyword">if</span> (gle == WAIT_TIMEOUT) {</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (gle == ERROR_NETNAME_DELETED) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client exit\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">RemoveSocketContext</span>(socket_ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">RemoveSocketContext</span>(socket_ctx);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// http://blog.csdn.net/china_jeffery/article/details/78801331</span></span><br><span class="line">      IOCP::PER_IO_CONTEXT *io_ctx = <span class="built_in">CONTAINING_RECORD</span>(overlapped, IOCP::PER_IO_CONTEXT, overlapped);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((transferred_bytes == <span class="number">0</span>) &amp;&amp; (io_ctx-&gt;operation_type == IOCP::RECV_POSTED || io_ctx-&gt;operation_type == IOCP::SEND_POSTED)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client disconnect\n"</span>);</span><br><span class="line">        <span class="built_in">RemoveSocketContext</span>(socket_ctx);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (io_ctx-&gt;operation_type)</span><br><span class="line">      {</span><br><span class="line">      <span class="keyword">case</span> IOCP::ACCEPT_POSTED:</span><br><span class="line">        <span class="built_in">DoAccept</span>(socket_ctx, io_ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> IOCP::RECV_POSTED:</span><br><span class="line">        <span class="built_in">DoRecv</span>(socket_ctx, io_ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> IOCP::SEND_POSTED:</span><br><span class="line">        <span class="built_in">DoSend</span>(socket_ctx, io_ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> </span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">InitializeCriticalSection</span>(&amp;g_cs_socket_ctx_array);</span><br><span class="line">    g_IOCP = IOCP::<span class="built_in">CreateNewCompletionPort</span>();</span><br><span class="line">    g_exit = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    g_work_thread_num = IOCP::<span class="built_in">GetNumberOfProcesser</span>() * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    g_work_threads = <span class="keyword">new</span> HANDLE[g_work_thread_num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g_work_thread_num; i++) {</span><br><span class="line">      g_work_threads[i] = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, WorkThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    g_listen_ctx = <span class="keyword">new</span> IOCP::PER_SOCKET_CONTEXT;</span><br><span class="line">    g_listen_ctx-&gt;socket = <span class="built_in">WSASocket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IOCP::<span class="built_in">AssociateDeviceWithCompletionPort</span>(g_IOCP, (HANDLE)g_listen_ctx-&gt;socket, (DWORD)g_listen_ctx)) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"AssociateDeviceWithCompletionPort failed with code: %d\n"</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr = { <span class="number">0</span> };</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(kPort);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(g_listen_ctx-&gt;socket, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;addr), <span class="built_in">sizeof</span>(addr)) == SOCKET_ERROR) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"bind failed with code: %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(g_listen_ctx-&gt;socket, SOMAXCONN) == SOCKET_ERROR) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"listen failed with code: %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    g_AcceptExFn = IOCP::<span class="built_in">GetAcceptExFnPointer</span>(g_listen_ctx-&gt;socket);</span><br><span class="line">    <span class="keyword">if</span> (g_AcceptExFn == <span class="literal">NULL</span>) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"GetAcceptExFnPointer failed\n"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    g_AcceptExSockAddrsFn = IOCP::<span class="built_in">GetAcceptExSockAddrsFnPointer</span>(g_listen_ctx-&gt;socket);</span><br><span class="line">    <span class="keyword">if</span> (g_AcceptExSockAddrsFn == <span class="literal">NULL</span>) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"GetAcceptExSockAddrsFnPointer failed\n"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">      IOCP::PER_IO_CONTEXT *io_ctx = g_listen_ctx-&gt;<span class="built_in">GetNewIoContext</span>();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">PostAccept</span>(io_ctx) == FALSE) {</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i != <span class="number">10</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  } <span class="keyword">while</span> (FALSE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\npress any ket to stop server...\n"</span>);</span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SetEvent</span>(g_exit);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g_work_thread_num; i++) {</span><br><span class="line">    <span class="built_in">PostQueuedCompletionStatus</span>(g_IOCP, <span class="number">0</span>, (DWORD)EXIT_CODE, <span class="literal">NULL</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">WaitForMultipleObjects</span>(g_work_thread_num, g_work_threads, TRUE, INFINITE);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ClearSocketContextArray</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\npress any ket to exit...\n"</span>);</span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DeleteCriticalSection</span>(&amp;g_cs_socket_ctx_array);</span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-2-客户端"><a href="#3-2-客户端" class="headerlink" title="3.2 客户端"></a>3.2 客户端</h2><p>客户端代码和服务端类似，唯一需要注意的是ConnectEx函数调用之前，需要将SOCKET进行bind操作。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"iocp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::string kIP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="type">const</span> u_short kPort = <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::string kSYN = <span class="string">"(SYN) hello server, I'm client. Can you hear me?"</span>;</span><br><span class="line"><span class="type">const</span> std::string kSYN_ACK = <span class="string">"(SYN+ACK) hello client, I'm server. I can hear you, can you hear me?"</span>;</span><br><span class="line"><span class="type">const</span> std::string kACK = <span class="string">"(ACK) hello server, I'm client. I can hear you!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line">HANDLE g_IOCP = INVALID_HANDLE_VALUE;</span><br><span class="line">HANDLE g_exit = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_work_thread_num = <span class="number">0</span>;</span><br><span class="line">HANDLE *g_work_threads = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">IOCP::PER_SOCKET_CONTEXT *g_client_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LPFN_CONNECTEX g_ConnectExFn = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PostConnect</span><span class="params">(IOCP::PER_IO_CONTEXT* io_ctx, <span class="type">const</span> std::string &amp;ip, <span class="type">int</span> port)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (io_ctx == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  io_ctx-&gt;operation_type = IOCP::CONNECT_POSTED;</span><br><span class="line">  io_ctx-&gt;<span class="built_in">ResetBuffer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ConnectEx requires the socket to be initially bound.</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr0 = { <span class="number">0</span> };</span><br><span class="line">  addr0.sin_family = AF_INET;</span><br><span class="line">  addr0.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">  addr0.sin_port = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> ret = <span class="built_in">bind</span>(io_ctx-&gt;socket, (SOCKADDR*)&amp;addr0, <span class="built_in">sizeof</span>(addr0));</span><br><span class="line">  <span class="keyword">if</span> (ret != <span class="number">0</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bind failed: %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr1 = { <span class="number">0</span> };</span><br><span class="line">  addr1.sin_family = AF_INET;</span><br><span class="line">  addr1.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip.<span class="built_in">c_str</span>());</span><br><span class="line">  addr1.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">  ret = <span class="built_in">g_ConnectExFn</span>(io_ctx-&gt;socket,</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;addr1),</span><br><span class="line">    <span class="built_in">sizeof</span>(addr1),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    &amp;io_ctx-&gt;overlapped);</span><br><span class="line">  <span class="type">int</span> gle = <span class="built_in">WSAGetLastError</span>();</span><br><span class="line">  <span class="keyword">if</span> (ret == SOCKET_ERROR &amp;&amp; gle != WSA_IO_PENDING) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PostRecv</span><span class="params">(IOCP::PER_IO_CONTEXT* io_ctx)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (io_ctx == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  io_ctx-&gt;operation_type = IOCP::RECV_POSTED;</span><br><span class="line">  io_ctx-&gt;<span class="built_in">ResetBuffer</span>();</span><br><span class="line"></span><br><span class="line">  DWORD recv_bytes = <span class="number">0</span>;</span><br><span class="line">  DWORD flags = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> ret = <span class="built_in">WSARecv</span>(io_ctx-&gt;socket, &amp;io_ctx-&gt;wsa_buffer, <span class="number">1</span>, &amp;recv_bytes, &amp;flags, &amp;io_ctx-&gt;overlapped, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret == SOCKET_ERROR &amp;&amp; <span class="built_in">WSAGetLastError</span>() != WSA_IO_PENDING) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PostSend</span><span class="params">(IOCP::PER_IO_CONTEXT* io_ctx, <span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> msg_len)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (io_ctx == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  io_ctx-&gt;operation_type = IOCP::SEND_POSTED;</span><br><span class="line">  <span class="built_in">memcpy</span>(io_ctx-&gt;wsa_buffer.buf, msg, msg_len);</span><br><span class="line">  io_ctx-&gt;wsa_buffer.len = msg_len;</span><br><span class="line"></span><br><span class="line">  DWORD sent_bytes = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> ret = <span class="built_in">WSASend</span>(io_ctx-&gt;socket, &amp;io_ctx-&gt;wsa_buffer, <span class="number">1</span>, &amp;sent_bytes, <span class="number">0</span>, &amp;io_ctx-&gt;overlapped, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="type">int</span> gle = <span class="built_in">WSAGetLastError</span>();</span><br><span class="line">  <span class="keyword">if</span> (ret == SOCKET_ERROR &amp;&amp; gle != WSA_IO_PENDING) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"WSASend failed with code: %d\n"</span>, gle);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DoConnect</span><span class="params">(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx)</span> </span>{</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"connect to server\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">PostRecv</span>(io_ctx)) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PostRecv failed\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  IOCP::PER_IO_CONTEXT* new_io_ctx = socket_ctx-&gt;<span class="built_in">GetNewIoContext</span>();</span><br><span class="line">  new_io_ctx-&gt;socket = socket_ctx-&gt;socket;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">PostSend</span>(new_io_ctx, kSYN.<span class="built_in">c_str</span>(), kSYN.<span class="built_in">length</span>())) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PostSend failed\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DoRecv</span><span class="params">(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx)</span> </span>{</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"recv: %s\n"</span>, io_ctx-&gt;wsa_buffer.buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(io_ctx-&gt;wsa_buffer.buf, kSYN_ACK.<span class="built_in">c_str</span>()) == <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">// ACK</span></span><br><span class="line">    IOCP::PER_IO_CONTEXT * new_io_ctx = socket_ctx-&gt;<span class="built_in">GetNewIoContext</span>();</span><br><span class="line">    new_io_ctx-&gt;socket = socket_ctx-&gt;socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PostSend</span>(new_io_ctx, kACK.<span class="built_in">c_str</span>(), kACK.<span class="built_in">length</span>())) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"PostSend failed\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// post new recv</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">PostRecv</span>(io_ctx)) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PostRecv failed\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DoSend</span><span class="params">(IOCP::PER_SOCKET_CONTEXT *socket_ctx, IOCP::PER_IO_CONTEXT *io_ctx)</span> </span>{</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"send: %s\n"</span>, io_ctx-&gt;wsa_buffer.buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> __stdcall <span class="title">WorkThreadProc</span><span class="params">(<span class="type">void</span> *arg)</span> </span>{</span><br><span class="line">  DWORD transferred_bytes = <span class="number">0</span>;</span><br><span class="line">  IOCP::PER_SOCKET_CONTEXT *socket_ctx = <span class="literal">NULL</span>;</span><br><span class="line">  OVERLAPPED *overlapped = <span class="literal">NULL</span>;</span><br><span class="line">  DWORD gle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">WaitForSingleObject</span>(g_exit, <span class="number">0</span>) != WAIT_OBJECT_0) {</span><br><span class="line">    BOOL ret = <span class="built_in">GetQueuedCompletionStatus</span>(g_IOCP, &amp;transferred_bytes, (PULONG_PTR)&amp;socket_ctx, &amp;overlapped, INFINITE);</span><br><span class="line">    gle = <span class="built_in">GetLastError</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (socket_ctx == EXIT_CODE) {</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == FALSE) {</span><br><span class="line">      <span class="keyword">if</span> (gle == WAIT_TIMEOUT) {</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (gle == ERROR_NETNAME_DELETED) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server exit\n"</span>);</span><br><span class="line">        <span class="built_in">closesocket</span>(socket_ctx-&gt;socket);</span><br><span class="line">        socket_ctx-&gt;socket = INVALID_SOCKET;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">closesocket</span>(socket_ctx-&gt;socket);</span><br><span class="line">        socket_ctx-&gt;socket = INVALID_SOCKET;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">      IOCP::PER_IO_CONTEXT *io_ctx = <span class="built_in">CONTAINING_RECORD</span>(overlapped, IOCP::PER_IO_CONTEXT, overlapped);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (io_ctx-&gt;operation_type)</span><br><span class="line">      {</span><br><span class="line">      <span class="keyword">case</span> IOCP::CONNECT_POSTED:</span><br><span class="line">        <span class="built_in">DoConnect</span>(socket_ctx, io_ctx);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> IOCP::RECV_POSTED:</span><br><span class="line">        <span class="built_in">DoRecv</span>(socket_ctx, io_ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> IOCP::SEND_POSTED:</span><br><span class="line">        <span class="built_in">DoSend</span>(socket_ctx, io_ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  {</span><br><span class="line">    g_IOCP = IOCP::<span class="built_in">CreateNewCompletionPort</span>();</span><br><span class="line">    g_exit = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    g_work_thread_num = IOCP::<span class="built_in">GetNumberOfProcesser</span>() * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    g_work_threads = <span class="keyword">new</span> HANDLE[g_work_thread_num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g_work_thread_num; i++) {</span><br><span class="line">      g_work_threads[i] = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, WorkThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    g_client_ctx = <span class="keyword">new</span> IOCP::PER_SOCKET_CONTEXT;</span><br><span class="line">    g_client_ctx-&gt;socket = <span class="built_in">WSASocket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IOCP::<span class="built_in">AssociateDeviceWithCompletionPort</span>(g_IOCP, (HANDLE)g_client_ctx-&gt;socket, (DWORD)g_client_ctx)) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"AssociateDeviceWithCompletionPort failed with code: %d\n"</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    g_ConnectExFn = IOCP::<span class="built_in">GetConnectExFnPointer</span>(g_client_ctx-&gt;socket);</span><br><span class="line">    <span class="keyword">if</span> (g_ConnectExFn == <span class="literal">NULL</span>) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"GetConnectExFnPointer failed\n"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    IOCP::PER_IO_CONTEXT* io_ctx = g_client_ctx-&gt;<span class="built_in">GetNewIoContext</span>();</span><br><span class="line">    io_ctx-&gt;socket = g_client_ctx-&gt;socket;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PostConnect</span>(io_ctx, kIP, kPort)) {</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"PostConnect failed\n"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  } <span class="keyword">while</span> (FALSE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"press any key to exit client...\n"</span>);</span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SetEvent</span>(g_exit);</span><br><span class="line">  <span class="built_in">closesocket</span>(g_client_ctx-&gt;socket);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>完整工程下载地址：<a href="https://github.com/winsoft666/CodeSnippet/tree/main/CompletionPort-Sample">https://github.com/winsoft666/CodeSnippet/tree/main/CompletionPort-Sample</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows套接字I/O模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>由字符串格式化函数引起的崩溃</title>
      <link href="/post/432875265.html"/>
      <url>/post/432875265.html</url>
      
        <content type="html"><![CDATA[<p>本文记录一个由错误使用StringCchVPrintf等格式化函数所导致的崩溃问题。</p><span id="more"></span><h1 id="一-问题描述"><a href="#一-问题描述" class="headerlink" title="一. 问题描述"></a>一. 问题描述</h1><p>我们常用的格式化字符串函数有：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HRESULT <span class="title function_">StringCchVPrintf</span><span class="params">(</span></span><br><span class="line"><span class="params">  _Out_ LPTSTR  pszDest,</span></span><br><span class="line"><span class="params">  _In_  <span class="type">size_t</span>  cchDest,</span></span><br><span class="line"><span class="params">  _In_  LPCTSTR pszFormat,</span></span><br><span class="line"><span class="params">  _In_  va_list argList</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * format, ... )</span>;</span><br></pre></td></tr></tbody></table></figure><p>对于如下的调用：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">100</span>] = {<span class="number">0</span>};</span><br><span class="line"><span class="built_in">StringCchVPrintf</span>(buf, <span class="number">100</span>, <span class="string">"select * from member where name like '%sjj%';"</span>);</span><br></pre></td></tr></tbody></table></figure><p>此时<code>buf</code>中存储的并不是期望的<code>select * from member where name like '%sjj%';</code>字符串。不出意外，<code>%sjj%</code>处的<code>%s</code>会变成乱码。</p><p>因为函数将<code>%sjj%</code>中的<code>%s</code>当做了字符串格式化串了，而我们又没有给最后一个参数（即可变参数）传值，根据可变参数的原理，默认会根据format参数的地址来取一个地址让<code>%s</code>进行输出。</p><p>具体计算方式参考<code>va_start</code>宏定义:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> va_start _crt_va_start</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _crt_va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )</span></span><br></pre></td></tr></tbody></table></figure><p>这个地址的内容是未知的，所以就可能出现乱码或崩溃。</p><h1 id="二-解决方案"><a href="#二-解决方案" class="headerlink" title="二. 解决方案"></a>二. 解决方案</h1><p>要解决这个问题，我们只需要做到一点，在调用<code>StringCchVPrintf、vsprintf、vswprintf、_vstprintf、printf</code>等函数时，<em><strong>一定不要将固定字符串传入到<code>pszFormat</code>参数</strong></em>，如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StringCchVPrintf</span>(szBuf, <span class="number">512</span>, <span class="string">"我想输出单纯的%s，我是错误的格式示范"</span>);  <span class="comment">// 错误的</span></span><br></pre></td></tr></tbody></table></figure><p>这个时候，<code>单纯的%s</code>中的<code>%s</code>已经不在单纯。</p><p>正确的做法是：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StringCchVPrintf</span>(szBuf, <span class="number">512</span>, <span class="string">"%s"</span>, <span class="string">"我想输出单纯的%s，我是正确的格式示范"</span>); </span><br></pre></td></tr></tbody></table></figure><p>同理，下面的调用方式也是错误的、危险的：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string strInfo = <span class="built_in">GetInfo</span>();</span><br><span class="line"><span class="built_in">printf</span>(strInfo.<span class="built_in">c_str</span>());</span><br></pre></td></tr></tbody></table></figure><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ⑦ 软件调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows套接字I/O模型(4)-WSAEventSelect模型</title>
      <link href="/post/547434843.html"/>
      <url>/post/547434843.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、WSAEventSelect模型介绍"><a href="#一、WSAEventSelect模型介绍" class="headerlink" title="一、WSAEventSelect模型介绍"></a>一、WSAEventSelect模型介绍</h1><p>WSAEventSelect模型和WSAAsyncSelect模型类似，但WSAEventSelect模型允许应用程序在一个或多个套接字上面接收以<strong>事件</strong>为基础的网络事件通知。该模型和WSAAsyncSelect模型的最主要的区别在于网络事件是由事件对象句柄完成的，而不是通过窗口消息完成的。</p><span id="more"></span><p>该模型要求应用程序针对打算使用的每一个套接字都创建一个事件对象。创建方法是就是调用<code>WSACreateEvent</code>函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WSAEVENT <span class="title function_">WSACreateEvent</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></tbody></table></figure><p><code>WSACreateEvent</code>函数返回一个人工控制(manual)、无信号的事件对象句柄。得到事件句柄之后，可以通过调用<code>WSAEventSelect</code>函数，将它和套接字相关联，同时注册感兴趣的网络事件。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">WSAEventSelect</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_ SOCKET   s,</span></span><br><span class="line"><span class="params">  _In_ WSAEVENT hEventObject,</span></span><br><span class="line"><span class="params">  _In_ <span class="type">long</span>     lNetworkEvents</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure><p>具体的参数解释可以参考MSDN：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms741576(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms741576(v=vs.85).aspx</a></p><p>和<code>CreateEvent</code>创建的事件类型，windows提供了类似的API来重置事件信号、关闭事件等，如<code>WSAResetEvent</code>, <code>WSACloseEvent</code>等。</p><p>同样提供了和<code>WaitForMultipleObjects</code>类似的函数<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms741576(v=vs.85).aspx">WSAWaitForMultipleEvents</a>来等待多个事件信号，其参数也和<code>WaitForMultipleObjects</code>类似。</p><p>需要注意的是，<code>WSAWaitForMultipleEvents</code>最多只支持同时等待64个事件，如果需要等待超过64个事件，需要使用多个线程调用多次<code>WSAWaitForMultipleEvents</code>函数来实现，这也是WSAEventSelect模型的一大弊端。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">WSAEnumNetworkEvents</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_  SOCKET             s,</span></span><br><span class="line"><span class="params">  _In_  WSAEVENT           hEventObject,</span></span><br><span class="line"><span class="params">  _Out_ LPWSANETWORKEVENTS lpNetworkEvents</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure><p><code>WSAEnumNetworkEvents</code>函数用于获取指定SOCKET上发送了哪些事件（是FD_READ，还是FD_WRITE，或者说还是FD_ACCEPT等），<code>hEventObject</code>参数传入事件句柄，函数会自动将事件置为无信号状态，不需要再次调用<code>WSAResetEvent</code>来重置信号。</p><p>具体的用法可以参考下面“示例程序”。</p><h1 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h1><p>服务端和客户端着重在列出WSAEventSelect模型的基本用法，并未实现复杂的逻辑。<br>服务端在有新的客户端连接上时，给客户端发送“hello, I’m server.”消息，并且在服务端退出时会关闭所有客户端连接。<br>客户端连接上服务端之后，不间断接收服务端的消息。</p><p>示例程序只使用了一个线程（主线程）来等待最多64个事件（也就是最多只支持64-1=63个客户端连接），如果需要支持更多的客户端连接，可以开启多个线程来等待。</p><h2 id="2-1-服务端"><a href="#2-1-服务端" class="headerlink" title="2.1 服务端"></a>2.1 服务端</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> u_short kPort = <span class="number">10001</span>;</span><br><span class="line"><span class="type">const</span> std::string kHelloServer = <span class="string">"hello, I'm server."</span>;</span><br><span class="line"></span><br><span class="line">HANDLE g_event_array[WSA_MAXIMUM_WAIT_EVENTS];</span><br><span class="line">SOCKET g_socket_array[WSA_MAXIMUM_WAIT_EVENTS];</span><br><span class="line"><span class="type">int</span> g_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveArrayIndex</span><span class="params">(T arr[], <span class="type">int</span> total, <span class="type">int</span> index)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (index &gt; total)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; (total - <span class="number">1</span>); i++) {</span><br><span class="line">    arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  {</span><br><span class="line">    <span class="comment">// (1)</span></span><br><span class="line">    g_socket_array[g_index] = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_socket_array[<span class="number">0</span>] == INVALID_SOCKET) {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"create socket failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr = { <span class="number">0</span> };</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(kPort);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(g_socket_array[g_index], <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;addr), <span class="built_in">sizeof</span>(addr)) == SOCKET_ERROR) {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"bind failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (3)</span></span><br><span class="line">    g_event_array[g_index] = <span class="built_in">WSACreateEvent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WSAEventSelect</span>(g_socket_array[g_index], g_event_array[g_index], FD_ACCEPT | FD_READ | FD_WRITE | FD_CLOSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (4)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(g_socket_array[g_index], <span class="number">5</span>) == SOCKET_ERROR) {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"listen failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"listen on port: "</span> &lt;&lt; kPort &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (5)</span></span><br><span class="line">    <span class="comment">// 该循环可以放到子线程中</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">      DWORD ret = <span class="built_in">WSAWaitForMultipleEvents</span>(g_index + <span class="number">1</span>, g_event_array, FALSE, WSA_INFINITE, FALSE);</span><br><span class="line">      <span class="keyword">if</span>(ret == WSA_WAIT_FAILED || ret == WSA_WAIT_TIMEOUT)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 忽略上面WSAWaitForMultipleEvents返回值所表示的index。遍历每个socket，查看是否有信号。</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= g_index; i++) {</span><br><span class="line">        ret = <span class="built_in">WSAWaitForMultipleEvents</span>(<span class="number">1</span>, &amp;g_event_array[i], FALSE, <span class="number">0</span>, FALSE);</span><br><span class="line">        <span class="keyword">if</span> (ret == WSA_WAIT_FAILED || ret == WSA_WAIT_TIMEOUT) {</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        WSANETWORKEVENTS network_events;</span><br><span class="line">        <span class="comment">// WSAEnumNetworkEvent函数会将事件重置为无信号状态</span></span><br><span class="line">        <span class="built_in">WSAEnumNetworkEvents</span>(g_socket_array[i], g_event_array[i], &amp;network_events);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (network_events.lNetworkEvents &amp; FD_ACCEPT) {</span><br><span class="line">          <span class="keyword">if</span> (network_events.iErrorCode[FD_ACCEPT_BIT] != <span class="number">0</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"FD_ACCEPT failed with code: "</span> &lt;&lt; network_events.iErrorCode[FD_ACCEPT_BIT] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          SOCKET s = <span class="built_in">accept</span>(g_socket_array[i], <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">          <span class="keyword">if</span> (s == SOCKET_ERROR) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"accept failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (g_index &gt;= WSA_MAXIMUM_WAIT_EVENTS - <span class="number">1</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"too many connection\n"</span>;</span><br><span class="line">            <span class="built_in">closesocket</span>(s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          }</span><br><span class="line">          </span><br><span class="line">          g_index++;</span><br><span class="line"></span><br><span class="line">          g_event_array[g_index] = <span class="built_in">WSACreateEvent</span>();</span><br><span class="line">          g_socket_array[g_index] = s;</span><br><span class="line"></span><br><span class="line">          std::cout &lt;&lt; <span class="string">"new connection\n"</span>;</span><br><span class="line"></span><br><span class="line">          <span class="type">int</span> err = <span class="built_in">send</span>(s, (<span class="type">const</span> <span class="type">char</span>*)kHelloServer.<span class="built_in">c_str</span>(), kHelloServer.<span class="built_in">length</span>(), <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"send failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (network_events.lNetworkEvents &amp; FD_READ) {</span><br><span class="line">          <span class="keyword">if</span> (network_events.iErrorCode[FD_READ_BIT] != <span class="number">0</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"FD_READ failed with code: "</span> &lt;&lt; network_events.iErrorCode[FD_READ_BIT] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="type">char</span> buf[<span class="number">100</span>] = { <span class="number">0</span> };</span><br><span class="line">          <span class="type">int</span> err = <span class="built_in">recv</span>(g_socket_array[i], buf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (err &gt; <span class="number">0</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"recv: "</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (err == <span class="number">0</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"connection closed."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">closesocket</span>(g_socket_array[i]);</span><br><span class="line">            <span class="built_in">WSACloseEvent</span>(g_event_array[i]);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">RemoveArrayIndex</span>(g_socket_array, g_index, i);</span><br><span class="line">            <span class="built_in">RemoveArrayIndex</span>(g_event_array, g_index, i);</span><br><span class="line"></span><br><span class="line">            g_index--;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">else</span> {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"recv failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">closesocket</span>(g_socket_array[i]);</span><br><span class="line">            <span class="built_in">WSACloseEvent</span>(g_event_array[i]);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">RemoveArrayIndex</span>(g_socket_array, g_index, i);</span><br><span class="line">            <span class="built_in">RemoveArrayIndex</span>(g_event_array, g_index, i);</span><br><span class="line"></span><br><span class="line">            g_index--;</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (network_events.lNetworkEvents &amp; FD_WRITE) {</span><br><span class="line">          <span class="keyword">if</span> (network_events.iErrorCode[FD_WRITE_BIT] != <span class="number">0</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"FD_WRITE failed with code: "</span> &lt;&lt; network_events.iErrorCode[FD_WRITE_BIT] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (network_events.lNetworkEvents &amp; FD_CLOSE) {</span><br><span class="line">          <span class="keyword">if</span> (network_events.iErrorCode[FD_CLOSE_BIT] != <span class="number">0</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"FD_CLOSE failed with code: "</span> &lt;&lt; network_events.iErrorCode[FD_CLOSE_BIT] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="built_in">closesocket</span>(g_socket_array[i]);</span><br><span class="line">          <span class="built_in">WSACloseEvent</span>(g_event_array[i]);</span><br><span class="line"></span><br><span class="line">          <span class="built_in">RemoveArrayIndex</span>(g_socket_array, g_index, i);</span><br><span class="line">          <span class="built_in">RemoveArrayIndex</span>(g_event_array, g_index, i);</span><br><span class="line"></span><br><span class="line">          g_index--;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    } <span class="comment">// while</span></span><br><span class="line">  } <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (6)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= g_index; i++) {</span><br><span class="line">    <span class="built_in">closesocket</span>(g_socket_array[i]);</span><br><span class="line">    <span class="built_in">WSACloseEvent</span>(g_event_array[i]);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2.2 客户端"></a>2.2 客户端</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::string kIP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="type">const</span> u_short kPort = <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line">HANDLE g_event;</span><br><span class="line">SOCKET g_socket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  {</span><br><span class="line">    <span class="comment">// (1)</span></span><br><span class="line">    g_socket = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_socket == INVALID_SOCKET) {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"create socket failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (2)</span></span><br><span class="line">    g_event = <span class="built_in">WSACreateEvent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WSAEventSelect</span>(g_socket, g_event, FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr = { <span class="number">0</span> };</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(kIP.<span class="built_in">c_str</span>());</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(kPort);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(g_socket, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;addr), <span class="built_in">sizeof</span>(addr)) == SOCKET_ERROR) {</span><br><span class="line">      <span class="type">int</span> gle_err = <span class="built_in">WSAGetLastError</span>();</span><br><span class="line">      <span class="keyword">if</span> (gle_err != WSAEWOULDBLOCK) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"connect failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (4)</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">      DWORD ret = <span class="built_in">WSAWaitForMultipleEvents</span>(<span class="number">1</span>, &amp;g_event, FALSE, WSA_INFINITE, FALSE);</span><br><span class="line">      <span class="keyword">if</span> (ret == WSA_WAIT_FAILED || ret == WSA_WAIT_TIMEOUT) {</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      WSANETWORKEVENTS network_events;</span><br><span class="line">      <span class="comment">// WSAEnumNetworkEvent函数会将事件重置为无信号状态</span></span><br><span class="line">      <span class="built_in">WSAEnumNetworkEvents</span>(g_socket, g_event, &amp;network_events);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (network_events.lNetworkEvents &amp; FD_CONNECT) {</span><br><span class="line">        <span class="keyword">if</span> (network_events.iErrorCode[FD_CONNECT_BIT] != <span class="number">0</span>) {</span><br><span class="line">          std::cout &lt;&lt; <span class="string">"FD_CONNECT failed with code: "</span> &lt;&lt; network_events.iErrorCode[FD_CONNECT_BIT] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"connect to server\n"</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (network_events.lNetworkEvents &amp; FD_READ) {</span><br><span class="line">        <span class="keyword">if</span> (network_events.iErrorCode[FD_READ_BIT] != <span class="number">0</span>) {</span><br><span class="line">          std::cout &lt;&lt; <span class="string">"FD_READ failed with code: "</span> &lt;&lt; network_events.iErrorCode[FD_READ_BIT] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">100</span>] = { <span class="number">0</span> };</span><br><span class="line">        <span class="type">int</span> err = <span class="built_in">recv</span>(g_socket, buf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (err &gt; <span class="number">0</span>) {</span><br><span class="line">          std::cout &lt;&lt; <span class="string">"recv: "</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (err == <span class="number">0</span>) {</span><br><span class="line">          std::cout &lt;&lt; <span class="string">"connection closed."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">closesocket</span>(g_socket);</span><br><span class="line">          <span class="built_in">WSACloseEvent</span>(g_event);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">          std::cout &lt;&lt; <span class="string">"recv failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">closesocket</span>(g_socket);</span><br><span class="line">          <span class="built_in">WSACloseEvent</span>(g_event);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (network_events.lNetworkEvents &amp; FD_WRITE) {</span><br><span class="line">        <span class="keyword">if</span> (network_events.iErrorCode[FD_WRITE_BIT] != <span class="number">0</span>) {</span><br><span class="line">          std::cout &lt;&lt; <span class="string">"FD_WRITE failed with code: "</span> &lt;&lt; network_events.iErrorCode[FD_WRITE_BIT] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (network_events.lNetworkEvents &amp; FD_CLOSE) {</span><br><span class="line">        <span class="keyword">if</span> (network_events.iErrorCode[FD_CLOSE_BIT] != <span class="number">0</span>) {</span><br><span class="line">          std::cout &lt;&lt; <span class="string">"FD_CLOSE failed with code: "</span> &lt;&lt; network_events.iErrorCode[FD_CLOSE_BIT] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">closesocket</span>(g_socket);</span><br><span class="line">        <span class="built_in">WSACloseEvent</span>(g_event);</span><br><span class="line">      }</span><br><span class="line">    } <span class="comment">// while</span></span><br><span class="line">  } <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (5)</span></span><br><span class="line">  <span class="built_in">closesocket</span>(g_socket);</span><br><span class="line">  <span class="built_in">WSACloseEvent</span>(g_event);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows套接字I/O模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows套接字I/O模型(3)-WSAAsyncSelect模型</title>
      <link href="/post/2544551173.html"/>
      <url>/post/2544551173.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、WSAAsyncSelect模型介绍"><a href="#一、WSAAsyncSelect模型介绍" class="headerlink" title="一、WSAAsyncSelect模型介绍"></a>一、WSAAsyncSelect模型介绍</h1><p>利用WSAAsyncSelect模型结合windows窗口消息循环，应用程序可以在一个套接字上接收以Windows消息为基础的网络事件通知。要想使用WSAAsyncSelect模型，首先必须创建一个Windows窗口，并为该窗口提供一个窗口过程支持函数。</p><span id="more"></span><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAAsyncSelect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ SOCKET       s,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ HWND         hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ <span class="type">unsigned</span> <span class="type">int</span> wMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ <span class="type">long</span>         lEvent</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><code>s</code>       指定我们感兴趣的套接字。<br><code>hWnd</code>    指定一个窗口句柄，它表示网络事件发生之后，收到消息通知的那个窗口。<br><code>wMsg</code>    表示在网络事件发生时，窗口收到的消息。<br><code>lEvent</code>  代表一个掩码，指定应用程序感兴趣的网络事件的组合。事件类型包括：FD_READ，FD_WRITE，FD_CLOSE，FD_CONNECT，FD_ACCEPT。对于FD_CONNECT，FD_ACCEPT，服务端一般使用FD_ACCEPT，客户端一般使用FD_CONNECT。若将<code>lEvent</code>设置为0，则表示停止接收该套接字上的所有网络事件通知。</p><p>一旦调用WSAAsyncSelect在套接字上启用了事件通知，除非明确调用closesocket，或者再次调用WSAAsyncSelect重新设置网络事件类型，否则，事件通知总是有效的。</p><blockquote><p>WSAAsyncSelect模型需要结合windows窗口来使用，不适用于没有界面的服务程序。建议使用WSAEventSelect模型来代替。</p></blockquote><h1 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h1><p>因为重点不在界面编程上面，所以示例中使用<code>TraceMsgA</code>打印信息到visual studio的输出窗口或debugview。<br><code>InitWindow</code>函数用于创建一个简单的、空白的窗口，将句柄存储在全局变量<code>g_hwnd</code>中。<br><code>WndProc</code>为窗口的处理过程函数。</p><p>服务端在有新的客户端连接上时，给客户端发送“hello, I’m server.”消息，在服务端退出时，关闭所有客户端连接。<br>客户端连接上服务端之后，接收服务端的消息。</p><h2 id="2-1-服务端"><a href="#2-1-服务端" class="headerlink" title="2.1 服务端"></a>2.1 服务端</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> u_short kPort = <span class="number">10001</span>;</span><br><span class="line"><span class="type">const</span> std::string kHelloServer = <span class="string">"hello, I'm server."</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WUM_SOCKET (WM_USER+1)</span></span><br><span class="line"></span><br><span class="line">HWND g_hwnd;</span><br><span class="line"></span><br><span class="line">SOCKET socket_srv = INVALID_SOCKET;</span><br><span class="line">std::vector&lt;SOCKET&gt; clients;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraceMsgA</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *lpFormat, ...)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (!lpFormat)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *pMsgBuffer = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> iMsgBufCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  va_list arglist;</span><br><span class="line">  <span class="built_in">va_start</span>(arglist, lpFormat);</span><br><span class="line">  HRESULT hr = STRSAFE_E_INSUFFICIENT_BUFFER;</span><br><span class="line">  <span class="keyword">while</span> (hr == STRSAFE_E_INSUFFICIENT_BUFFER) {</span><br><span class="line">    iMsgBufCount += <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">if</span> (pMsgBuffer) {</span><br><span class="line">      <span class="built_in">free</span>(pMsgBuffer);</span><br><span class="line">      pMsgBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    pMsgBuffer = (<span class="type">char</span>*)<span class="built_in">malloc</span>(iMsgBufCount * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="keyword">if</span> (!pMsgBuffer) {</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    hr = <span class="built_in">StringCchVPrintfA</span>(pMsgBuffer, iMsgBufCount, lpFormat, arglist);</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">va_end</span>(arglist);</span><br><span class="line">  <span class="keyword">if</span> (hr == S_OK) {</span><br><span class="line">    <span class="built_in">OutputDebugStringA</span>(pMsgBuffer);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pMsgBuffer) {</span><br><span class="line">    <span class="built_in">free</span>(pMsgBuffer);</span><br><span class="line">    pMsgBuffer = <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line">  SOCKET s;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>] = { <span class="number">0</span> };</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (message) {</span><br><span class="line">  <span class="comment">// (5)</span></span><br><span class="line">  <span class="keyword">case</span> WUM_SOCKET:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAGETSELECTERROR</span>(lParam)) {</span><br><span class="line">      <span class="built_in">closesocket</span>((SOCKET)wParam);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">WSAGETSELECTEVENT</span>(lParam))</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> FD_ACCEPT:</span><br><span class="line">      s = <span class="built_in">accept</span>((SOCKET)wParam, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      clients.<span class="built_in">push_back</span>(s);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">WSAAsyncSelect</span>(s, g_hwnd, WUM_SOCKET, FD_READ | FD_WRITE | FD_CLOSE);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">TraceMsgA</span>(<span class="string">"new connection\n"</span>);</span><br><span class="line"></span><br><span class="line">      err = <span class="built_in">send</span>(s, (<span class="type">const</span> <span class="type">char</span>*)kHelloServer.<span class="built_in">c_str</span>(), kHelloServer.<span class="built_in">length</span>(), <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">        <span class="built_in">TraceMsgA</span>(<span class="string">"send failed, GLE: %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FD_READ:</span><br><span class="line">      err = <span class="built_in">recv</span>((SOCKET)wParam, buf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (err &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">TraceMsgA</span>(<span class="string">"recv: %s\n"</span>, buf);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (err == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">TraceMsgA</span>(<span class="string">"connection closed\n"</span>);</span><br><span class="line">        <span class="built_in">closesocket</span>((SOCKET)wParam);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">TraceMsgA</span>(<span class="string">"recv failed, GLE: %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">        <span class="built_in">closesocket</span>((SOCKET)wParam);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FD_WRITE:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FD_CLOSE:</span><br><span class="line">      <span class="built_in">closesocket</span>((SOCKET)wParam);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (std::vector&lt;SOCKET&gt;::iterator it = clients.<span class="built_in">begin</span>(); it != clients.<span class="built_in">end</span>(); it++) {</span><br><span class="line">        <span class="keyword">if</span> (*it == (SOCKET)wParam) {</span><br><span class="line">          clients.<span class="built_in">erase</span>(it);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">    <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, message, wParam, lParam);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitWindow</span><span class="params">(HINSTANCE hInstance)</span> </span>{</span><br><span class="line">  WCHAR szWindowClass[<span class="number">100</span>] = <span class="string">L"Test"</span>;</span><br><span class="line"></span><br><span class="line">  WNDCLASSEX wcex = { <span class="built_in">sizeof</span>(WNDCLASSEX) };</span><br><span class="line"></span><br><span class="line">  wcex.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">  wcex.lpfnWndProc = WndProc;</span><br><span class="line">  wcex.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">  wcex.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">  wcex.hInstance = hInstance;</span><br><span class="line">  wcex.lpszClassName = szWindowClass;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RegisterClassExW</span>(&amp;wcex);</span><br><span class="line"></span><br><span class="line">  g_hwnd = <span class="built_in">CreateWindowW</span>(szWindowClass, <span class="string">L"server"</span>, WS_OVERLAPPEDWINDOW,</span><br><span class="line">    CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInstance, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (g_hwnd) {</span><br><span class="line">    <span class="built_in">ShowWindow</span>(g_hwnd, SW_SHOW);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(g_hwnd);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">                     _In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">                     _In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">                     _In_ <span class="type">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(hPrevInstance);</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(lpCmdLine);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">InitWindow</span>(hInstance);</span><br><span class="line"></span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  {</span><br><span class="line">    <span class="comment">// (1)</span></span><br><span class="line">    socket_srv = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_srv == INVALID_SOCKET) {</span><br><span class="line">      <span class="built_in">TraceMsgA</span>(<span class="string">"create socket failed, GLE: %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr = { <span class="number">0</span> };</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(kPort);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(socket_srv, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;addr), <span class="built_in">sizeof</span>(addr)) == SOCKET_ERROR) {</span><br><span class="line">      <span class="built_in">TraceMsgA</span>(<span class="string">"bind failed, GLE: %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (3)</span></span><br><span class="line">    <span class="built_in">WSAAsyncSelect</span>(socket_srv, g_hwnd, WUM_SOCKET, FD_ACCEPT | FD_READ | FD_WRITE | FD_CLOSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (4)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(socket_srv, <span class="number">5</span>) == SOCKET_ERROR) {</span><br><span class="line">      <span class="built_in">TraceMsgA</span>(<span class="string">"listen failed, GLE: %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">TraceMsgA</span>(<span class="string">"listen on port: %d\n"</span>, kPort);</span><br><span class="line"></span><br><span class="line">  } <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) {</span><br><span class="line">    <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">    <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::vector&lt;SOCKET&gt;::iterator it = clients.<span class="built_in">begin</span>(); it != clients.<span class="built_in">end</span>(); it++) {</span><br><span class="line">    <span class="built_in">closesocket</span>(*it);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (6)</span></span><br><span class="line">  <span class="built_in">closesocket</span>(socket_srv);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2.2 客户端"></a>2.2 客户端</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::string kIP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="type">const</span> u_short kPort = <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WUM_SOCKET (WM_USER+1)</span></span><br><span class="line"></span><br><span class="line">HWND g_hwnd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraceMsgA</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *lpFormat, ...)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (!lpFormat)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *pMsgBuffer = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> iMsgBufCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  va_list arglist;</span><br><span class="line">  <span class="built_in">va_start</span>(arglist, lpFormat);</span><br><span class="line">  HRESULT hr = STRSAFE_E_INSUFFICIENT_BUFFER;</span><br><span class="line">  <span class="keyword">while</span> (hr == STRSAFE_E_INSUFFICIENT_BUFFER) {</span><br><span class="line">    iMsgBufCount += <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">if</span> (pMsgBuffer) {</span><br><span class="line">      <span class="built_in">free</span>(pMsgBuffer);</span><br><span class="line">      pMsgBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    pMsgBuffer = (<span class="type">char</span>*)<span class="built_in">malloc</span>(iMsgBufCount * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="keyword">if</span> (!pMsgBuffer) {</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    hr = <span class="built_in">StringCchVPrintfA</span>(pMsgBuffer, iMsgBufCount, lpFormat, arglist);</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">va_end</span>(arglist);</span><br><span class="line">  <span class="keyword">if</span> (hr == S_OK) {</span><br><span class="line">    <span class="built_in">OutputDebugStringA</span>(pMsgBuffer);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pMsgBuffer) {</span><br><span class="line">    <span class="built_in">free</span>(pMsgBuffer);</span><br><span class="line">    pMsgBuffer = <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line">  SOCKET s;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>] = { <span class="number">0</span> };</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (message) {</span><br><span class="line">  <span class="comment">// (4)</span></span><br><span class="line">  <span class="keyword">case</span> WUM_SOCKET:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAGETSELECTERROR</span>(lParam)) {</span><br><span class="line">      <span class="built_in">closesocket</span>((SOCKET)wParam);</span><br><span class="line">      <span class="built_in">TraceMsgA</span>(<span class="string">"connect failed, %d\n"</span>, <span class="built_in">WSAGETSELECTERROR</span>(lParam));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">WSAGETSELECTEVENT</span>(lParam))</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> FD_CONNECT:</span><br><span class="line">      <span class="built_in">TraceMsgA</span>(<span class="string">"connection to server\n"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FD_READ:</span><br><span class="line">      err = <span class="built_in">recv</span>((SOCKET)wParam, buf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (err &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">TraceMsgA</span>(<span class="string">"recv: %s\n"</span>, buf);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (err == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">closesocket</span>((SOCKET)wParam);</span><br><span class="line">        <span class="built_in">TraceMsgA</span>(<span class="string">"connection closed\n"</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">closesocket</span>((SOCKET)wParam);</span><br><span class="line">        <span class="built_in">TraceMsgA</span>(<span class="string">"recv failed, GLE: %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FD_WRITE:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FD_CLOSE:</span><br><span class="line">      <span class="built_in">closesocket</span>((SOCKET)wParam);</span><br><span class="line">      <span class="built_in">TraceMsgA</span>(<span class="string">"connection closed\n"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">    <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, message, wParam, lParam);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitWindow</span><span class="params">(HINSTANCE hInstance)</span> </span>{</span><br><span class="line">  WCHAR szWindowClass[<span class="number">100</span>] = <span class="string">L"Test"</span>;</span><br><span class="line"></span><br><span class="line">  WNDCLASSEX wcex = { <span class="built_in">sizeof</span>(WNDCLASSEX) };</span><br><span class="line"></span><br><span class="line">  wcex.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">  wcex.lpfnWndProc = WndProc;</span><br><span class="line">  wcex.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">  wcex.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">  wcex.hInstance = hInstance;</span><br><span class="line">  wcex.lpszClassName = szWindowClass;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RegisterClassExW</span>(&amp;wcex);</span><br><span class="line"></span><br><span class="line">  g_hwnd = <span class="built_in">CreateWindowW</span>(szWindowClass, <span class="string">L"client"</span>, WS_OVERLAPPEDWINDOW,</span><br><span class="line">    CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInstance, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (g_hwnd) {</span><br><span class="line">    <span class="built_in">ShowWindow</span>(g_hwnd, SW_SHOW);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(g_hwnd);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ <span class="type">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">UNREFERENCED_PARAMETER</span>(hPrevInstance);</span><br><span class="line">  <span class="built_in">UNREFERENCED_PARAMETER</span>(lpCmdLine);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">InitWindow</span>(hInstance);</span><br><span class="line"></span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  SOCKET socket_ = INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  {</span><br><span class="line">    <span class="comment">// (1)</span></span><br><span class="line">    socket_ = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_ == INVALID_SOCKET) {</span><br><span class="line">      <span class="built_in">TraceMsgA</span>(<span class="string">"create socket failed, GLE: %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (2)</span></span><br><span class="line">    <span class="built_in">WSAAsyncSelect</span>(socket_, g_hwnd, WUM_SOCKET, FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr = { <span class="number">0</span> };</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(kIP.<span class="built_in">c_str</span>());</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(kPort);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(socket_, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;addr), <span class="built_in">sizeof</span>(addr)) == SOCKET_ERROR) {</span><br><span class="line">      <span class="type">int</span> gle_err = <span class="built_in">WSAGetLastError</span>();</span><br><span class="line">      <span class="keyword">if</span> (gle_err != WSAEWOULDBLOCK) {</span><br><span class="line">        <span class="built_in">TraceMsgA</span>(<span class="string">"connect failed, GLE: %d\n"</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  MSG msg;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) {</span><br><span class="line">    <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">    <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (5)</span></span><br><span class="line">  <span class="built_in">closesocket</span>(socket_);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>代码下载地址: <a href="https://github.com/winsoft666/CodeSnippet/tree/main/WSAAsyncSelect-Sample">https://github.com/winsoft666/CodeSnippet/tree/main/WSAAsyncSelect-Sample</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows套接字I/O模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows套接字I/O模型(2)-Select模型</title>
      <link href="/post/640627104.html"/>
      <url>/post/640627104.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、Select模型介绍"><a href="#一、Select模型介绍" class="headerlink" title="一、Select模型介绍"></a>一、Select模型介绍</h1><p>套接字Select模型的中心思想是利用select函数实现对I/O的管理。利用select函数来判断套接字（一个或多个）上是否存在数据，或者能否向套接字写入数据。它也是同步的，也会阻塞。但和阻塞模型不同的是，Select模型可以同时管理多个Socket。</p><span id="more"></span><p>select函数原型：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span> <span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span> nfds,                           </span></span><br><span class="line"><span class="params">  fd_set FAR * readfds,               </span></span><br><span class="line"><span class="params">  fd_set FAR * writefds,              </span></span><br><span class="line"><span class="params">  fd_set FAR * exceptfds,             </span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="keyword">struct</span> timeval FAR * timeout  </span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure><p>第一个参数nfds会被忽略。之所以仍然要提供这个参数，只是为了保持与早期的Berkeley套接字应用程序的兼容。</p><p>三个fd_set参数：一个用于检查可读性（readfds），一个用于检查可写性（writefds），另一个用于例外数据（ excepfds）。</p><p>从根本上说，fdset数据类型代表着一系列特定套接字的集合。<br><em><strong>其中，readfds集合包括符合下述任何一个条件的套接字：</strong></em></p><ul><li>有数据可以读入。</li><li>连接已经关闭、重设或中止。(可以用来判断客户端或服务端程序是否退出了)</li><li>假如已调用了listen，而且一个连接正在建立，那么accept函数调用会成功。</li></ul><p><em><strong>writefds集合包括符合下述任何一个条件的套接字：</strong></em></p><ul><li>有数据可以发出。</li><li>如果已完成了对一个非锁定连接调用的处理，连接就会成功。</li></ul><p><em><strong>最后，exceptfds集合包括符合下述任何一个条件的套接字：</strong></em></p><ul><li>假如已完成了对一个非锁定连接调用的处理，连接尝试就会失败。</li><li>有带外（out-of-band，OOB）数据可供读取。</li></ul><p>例如，假定我们想测试一个套接字是否“可读”，必须将自己的套接字增添到readfds集合，再等待select函数完成。select完成之后，必须判断自己的套接字是否仍为readfds集合的一部分。若答案是肯定的，便表明该套接字“可读”，可立即着手从它上面读取数据。在三个参数中（readfds、writedfss和exceptfds），任何两个都可以是空值（NULL）；但是，至少有一个不能为空值！在任何不为空的集合中，必须包含至少一个套接字句柄；否则，select函数便没有任何东西可以等待。</p><p>最后一个参数timeout对应的是一个指针，它指向一个timeval结构，用于决定select最多等待I/O操作完成多久的时间。如timeout是一个空指针，那么select调用会无限期地“锁定”或停顿下去，直到至少有一个描述符符合指定的条件后结束。对timeval结构的定义如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> {</span></span><br><span class="line">  <span class="type">long</span> tv_sec;</span><br><span class="line">  <span class="type">long</span> tv_usec;</span><br><span class="line">} ;</span><br></pre></td></tr></tbody></table></figure><p>若将超时值设置为(0,0)，表明select会立即返回，允许应用程序对select操作进行“轮询”。出于对性能方面的考虑，应避免这样的设置。<br>select成功完成后，会在fd_set结构中，返回刚好有未完成的I/O操作的所有套接字句柄的总量。<br>若超过timeval设定的时间，便会返回0。<br>不管由于什么原因，假如select调用失败，都会返回SOCKET_ERROR。<br>用select对套接字进行监视之前，在自己的应用程序中，必须将套接字句柄分配给一个集合，设置好一个或全部读、写以及例外fd_set结构。将一个套接字分配给任何一个集合后，再来调用select，便可知道一个套接字上是否正在发生上述的I/O活动。</p><p><strong>Winsock提供了下列宏操作，对fd_set进行处理与检查：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD_CLR(s, *<span class="built_in">set</span>);      从<span class="built_in">set</span>中删除套接字s。</span><br><span class="line">FD_ISSET(s, *<span class="built_in">set</span>);    检查s是否<span class="built_in">set</span>集合的一名成员；返回TRUE或FALSE。</span><br><span class="line">FD_SET(s, *<span class="built_in">set</span>);      将套接字s加入集合<span class="built_in">set</span>。</span><br><span class="line">FD_ZERO(*<span class="built_in">set</span>);        将<span class="built_in">set</span>初始化成空集合。</span><br></pre></td></tr></tbody></table></figure><h1 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h1><h2 id="2-1-服务端"><a href="#2-1-服务端" class="headerlink" title="2.1 服务端"></a>2.1 服务端</h2><p>服务端代码比之前介绍的“套接字I/O 阻塞模型”中的示例稍微复杂一点。可以管理多个客户端的连接，对每个新的客户端发送“Hello，I’m server”问候信息，在客户端程序退出时自动关闭连接等功能。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> u_short kPort = <span class="number">10001</span>;</span><br><span class="line"><span class="type">const</span> std::string kHelloServer = <span class="string">"hello, I'm server."</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  SOCKET socket_ = INVALID_SOCKET;</span><br><span class="line">  std::vector&lt;SOCKET&gt; clients;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  {</span><br><span class="line">    <span class="comment">// (1)</span></span><br><span class="line">    socket_ = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_ == INVALID_SOCKET) {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"create socket failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr = { <span class="number">0</span> };</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(kPort);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(socket_, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;addr), <span class="built_in">sizeof</span>(addr)) == SOCKET_ERROR) {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"bind failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(socket_, <span class="number">5</span>) == SOCKET_ERROR) {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"listen failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"listen on port: "</span> &lt;&lt; kPort &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fd_set fd_read;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">// TODO 未处理何时退出的问题</span></span><br><span class="line">    {</span><br><span class="line">      <span class="comment">// (4)</span></span><br><span class="line">      <span class="built_in">FD_ZERO</span>(&amp;fd_read);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">FD_SET</span>(socket_, &amp;fd_read);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (std::vector&lt;SOCKET&gt;::iterator it = clients.<span class="built_in">begin</span>(); it != clients.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        <span class="built_in">FD_SET</span>(*it, &amp;fd_read);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// (5)</span></span><br><span class="line">      timeval timeout = { <span class="number">3</span>, <span class="number">0</span> };</span><br><span class="line">      <span class="type">int</span> ret = <span class="built_in">select</span>(<span class="number">0</span>, &amp;fd_read, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">      <span class="keyword">if</span> (ret == SOCKET_ERROR) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"select failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// (6.1)</span></span><br><span class="line">      <span class="comment">// 检查服务端的监听socket，是否有新的连接被搁置</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(socket_, &amp;fd_read)) {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (7.1)</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr_c = { <span class="number">0</span> };</span><br><span class="line">        <span class="type">int</span> addr_len = <span class="built_in">sizeof</span>(addr_c);</span><br><span class="line">        SOCKET s = <span class="built_in">accept</span>(socket_, <span class="built_in">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;addr_c), &amp;addr_len);</span><br><span class="line">        <span class="keyword">if</span> (s == SOCKET_ERROR) {</span><br><span class="line">          std::cout &lt;&lt; <span class="string">"accept failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">          clients.<span class="built_in">push_back</span>(s);</span><br><span class="line">          std::cout &lt;&lt; <span class="string">"new connection"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">          <span class="type">int</span> left = kHelloServer.<span class="built_in">length</span>();</span><br><span class="line">          <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (left &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> err = <span class="built_in">send</span>(s, (<span class="type">const</span> <span class="type">char</span>*)(kHelloServer.<span class="built_in">c_str</span>() + idx), left, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">              std::cout &lt;&lt; <span class="string">"send failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            left -= err;</span><br><span class="line">            idx += err;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"bytes sent: "</span> &lt;&lt; err &lt;&lt; std::endl;</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// (6.2)</span></span><br><span class="line">      <span class="comment">// 检查与客户端连接的socket，是否有数据可以读入</span></span><br><span class="line">      <span class="keyword">for</span> (std::vector&lt;SOCKET&gt;::iterator it = clients.<span class="built_in">begin</span>(); it != clients.<span class="built_in">end</span>(); ) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(*it, &amp;fd_read)) {</span><br><span class="line"></span><br><span class="line">          <span class="comment">// (7.2)</span></span><br><span class="line">          <span class="type">char</span> buf[<span class="number">100</span>] = { <span class="number">0</span> };</span><br><span class="line">          <span class="type">int</span> err = <span class="built_in">recv</span>(*it, buf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (err &gt; <span class="number">0</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"recv: "</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            ++it;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (err == <span class="number">0</span>) {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"connection closed."</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">closesocket</span>(*it);</span><br><span class="line"></span><br><span class="line">            it = clients.<span class="built_in">erase</span>(it);</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">else</span> {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"recv failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">closesocket</span>(*it);</span><br><span class="line"></span><br><span class="line">            it = clients.<span class="built_in">erase</span>(it);</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">          ++it;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    } <span class="comment">// while</span></span><br><span class="line">  } <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (8)</span></span><br><span class="line">  <span class="keyword">for</span> (std::vector&lt;SOCKET&gt;::iterator it = clients.<span class="built_in">begin</span>(); it != clients.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">    <span class="built_in">closesocket</span>(*it);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (9)</span></span><br><span class="line">  <span class="built_in">closesocket</span>(socket_);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2.2 客户端"></a>2.2 客户端</h2><p>客户端在连接上服务端之后，便可以不间断的接收服务端的消息。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::string kIP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="type">const</span> u_short kPort = <span class="number">10001</span>;</span><br><span class="line"><span class="type">const</span> std::string kHelloClient = <span class="string">"hello, I'm client."</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  SOCKET socket_ = INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  {</span><br><span class="line">    <span class="comment">// (1)</span></span><br><span class="line">    socket_ = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_ == INVALID_SOCKET) {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"create socket failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr = { <span class="number">0</span> };</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(kIP.<span class="built_in">c_str</span>());</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(kPort);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(socket_, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;addr), <span class="built_in">sizeof</span>(addr)) == SOCKET_ERROR) {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"connect failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fd_set fd_read;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)  <span class="comment">// TODO 未处理何时退出的问题</span></span><br><span class="line">    {</span><br><span class="line">      <span class="comment">// (3)</span></span><br><span class="line">      <span class="built_in">FD_ZERO</span>(&amp;fd_read);</span><br><span class="line">      <span class="built_in">FD_SET</span>(socket_, &amp;fd_read);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// (4)</span></span><br><span class="line">      timeval timeout = { <span class="number">3</span>, <span class="number">0</span> };</span><br><span class="line">      <span class="type">int</span> ret = <span class="built_in">select</span>(<span class="number">0</span>, &amp;fd_read, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">      <span class="keyword">if</span> (ret == SOCKET_ERROR) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"select failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// (5)</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(socket_, &amp;fd_read)) {</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">100</span>] = { <span class="number">0</span> };</span><br><span class="line">        <span class="type">int</span> err = <span class="built_in">recv</span>(socket_, buf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (err &gt; <span class="number">0</span>) {</span><br><span class="line">          std::cout &lt;&lt; <span class="string">"recv: "</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (err == <span class="number">0</span>) {</span><br><span class="line">          std::cout &lt;&lt; <span class="string">"connection closed."</span> &lt;&lt; std::endl;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">          std::cout &lt;&lt; <span class="string">"recv failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    } <span class="comment">// while</span></span><br><span class="line">  } <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// (6)</span></span><br><span class="line">  <span class="built_in">closesocket</span>(socket_);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows套接字I/O模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows套接字I/O模型(1)-阻塞模型</title>
      <link href="/post/2937580891.html"/>
      <url>/post/2937580891.html</url>
      
        <content type="html"><![CDATA[<p>套接字I/O的阻塞模型是最常见的网络模型，也是在Socket编程时通常最早接触的一个模型。因为它是阻塞的，所以我们一般都会结合线程一起使用（如将<code>accept</code>，<code>recv</code>等放到单独的线程），防止程序主线程被阻塞。</p><span id="more"></span><p>下面的示例为了演示了阻塞模型使用的基本流程没有请其放到独立的线程中执行。</p><h1 id="一、服务端"><a href="#一、服务端" class="headerlink" title="一、服务端"></a>一、服务端</h1><p>服务端大致流程:</p><ol><li>创建Socket</li><li>Bind端口</li><li>开始Listen</li><li>accept客户端连接（一般在子线程中不间断accept）</li><li>send数据到客户端（也可以recv）</li><li>close socket</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> u_short kPort = <span class="number">10001</span>;</span><br><span class="line"><span class="type">const</span> std::string kHelloServer = <span class="string">"hello, I'm server."</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  SOCKET socket_ = INVALID_SOCKET;</span><br><span class="line">  SOCKET s_ = INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> </span><br><span class="line">  {</span><br><span class="line">    <span class="comment">// (1)</span></span><br><span class="line">    socket_ = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_ == INVALID_SOCKET) {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"create socket failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr = { <span class="number">0</span> };</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(kPort);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(socket_, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;addr), <span class="built_in">sizeof</span>(addr)) == SOCKET_ERROR) {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"bind failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(socket_, <span class="number">5</span>) == SOCKET_ERROR) {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"listen failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"listen on port: "</span> &lt;&lt; kPort &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (4)</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr_c = { <span class="number">0</span> };</span><br><span class="line">      <span class="type">int</span> addr_len = <span class="built_in">sizeof</span>(addr_c);</span><br><span class="line">      SOCKET s = <span class="built_in">accept</span>(socket_, <span class="built_in">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;addr_c), &amp;addr_len);</span><br><span class="line">      <span class="keyword">if</span> (s == SOCKET_ERROR) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"accept failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"new connection"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// (5)</span></span><br><span class="line">      <span class="comment">// 此处使用while循环send，详见 三、流协议</span></span><br><span class="line">      <span class="type">int</span> left = kHelloServer.<span class="built_in">length</span>();</span><br><span class="line">      <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (left &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="type">int</span> err = <span class="built_in">send</span>(s, (<span class="type">const</span> <span class="type">char</span>*)(kHelloServer.<span class="built_in">c_str</span>() + idx), left, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">          std::cout &lt;&lt; <span class="string">"send failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        left -= err;</span><br><span class="line">        idx += err;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"bytes sent: "</span> &lt;&lt; err &lt;&lt; std::endl;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// (6)</span></span><br><span class="line">  <span class="built_in">closesocket</span>(socket_);</span><br><span class="line">  <span class="built_in">closesocket</span>(s_);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="二、客户端"><a href="#二、客户端" class="headerlink" title="二、客户端"></a>二、客户端</h1><p>客户端大致流程：</p><ol><li>创建Socket</li><li>connect服务端</li><li>recv接收数据从服务端(也可以send)</li><li>close socket</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::string kIP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="type">const</span> u_short kPort = <span class="number">10001</span>;</span><br><span class="line"><span class="type">const</span> std::string kHelloClient = <span class="string">"hello, I'm client."</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  WSADATA wsaData;</span><br><span class="line">  WORD wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  SOCKET socket_ = INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> </span><br><span class="line">  {</span><br><span class="line">    <span class="comment">// (1)</span></span><br><span class="line">    socket_ = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_ == INVALID_SOCKET) {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"create socket failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr = { <span class="number">0</span> };</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(kIP.<span class="built_in">c_str</span>());</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(kPort);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(socket_, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;addr), <span class="built_in">sizeof</span>(addr)) == SOCKET_ERROR) {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"connect failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (3)</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>] = { <span class="number">0</span> };</span><br><span class="line">    <span class="type">int</span> err = <span class="built_in">recv</span>(socket_, buf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (err &gt; <span class="number">0</span>) {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"recv: "</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (err == <span class="number">0</span>) {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"connection closed."</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"recv failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// (4)</span></span><br><span class="line">  <span class="built_in">closesocket</span>(socket_);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WSACleanup</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="三、流协议"><a href="#三、流协议" class="headerlink" title="三、流协议"></a>三、流协议</h1><p>由于大多数面向连接的协议（如TCP）也是流协议。在流协议中，发送者和接收者可以将数据分解成小块数据，或将数据合并成大块数据。对于流套接字上收发数据所有用的函数（如send, recv），需要知道的是：<strong>它们不能保证要求进行读取或写入的数据量</strong>。比如用send发送一个有1024字节的字符缓冲区时，send函数可能返回的已发出的字节数少于1024。因为对每个收发数据的套接字来说，系统都为它们分配了充足的缓冲区空间，所以send的返回值将被设为已经发送的字节数。</p><p>针对这种情况，要保证缓冲区所有数据都被发送出去，可以采用下面的代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = kHelloServer.<span class="built_in">length</span>();</span><br><span class="line"><span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (left &gt; <span class="number">0</span>) {</span><br><span class="line">  <span class="type">int</span> err = <span class="built_in">send</span>(s, (<span class="type">const</span> <span class="type">char</span>*)(kHelloServer.<span class="built_in">c_str</span>() + idx), left, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (err == SOCKET_ERROR) {</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"send failed, GLE: "</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  left -= err;</span><br><span class="line">  idx += err;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"bytes sent: "</span> &lt;&lt; err &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于接收数据来说，也可以采用上面的方式，但意义不大，因为我们一般都是循环的、不间断的接收数据，很少有上面的例子中的，只接收一次的情况。</p>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> Windows套接字I/O模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux GDB调试命令</title>
      <link href="/post/2824175441.html"/>
      <url>/post/2824175441.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、启动GDB"><a href="#一、启动GDB" class="headerlink" title="一、启动GDB"></a>一、启动GDB</h2><p>gdb -tui：分屏显示源代码<br>gdb -q：不显示开始的提示信息</p><p>可以在.bashrc中加入别名：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> gdb=<span class="string">"gdb -q -tui"</span></span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h2 id="二、开始调试"><a href="#二、开始调试" class="headerlink" title="二、开始调试"></a>二、开始调试</h2><p>执行run（需要提前设置断点），也可以在调试过程中重新运行调试的程序，run后可以跟随发给该程序的任何参数。</p><h2 id="三、常用命令"><a href="#三、常用命令" class="headerlink" title="三、常用命令"></a>三、常用命令</h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>list（简写l）</td><td>显示当前行前面和后面的10行代码</td></tr><tr><td>list n1 n2</td><td>显示n1到行和n2行之间的代码</td></tr><tr><td>list main</td><td>显示main函数代码</td></tr><tr><td>info functions regex</td><td>列出符合正则表达式的函数名称</td></tr><tr><td>info breakpoints（简写info b）</td><td>查看当前所有的断点信息（断点号，断点类型，断点位置）</td></tr><tr><td>break func</td><td>在当前文件的func函数处设置断点</td></tr><tr><td>break fileName:N</td><td>在某文件的第N行处设置断点，当前文件第N行设置断点可以忽略fileName</td></tr><tr><td>break func(或fileName:N) if exp</td><td>条件断点，exp成立则断点</td></tr><tr><td>delete N</td><td>删除第N号断点</td></tr><tr><td>delete</td><td>删除所有断点</td></tr><tr><td>clear N</td><td>清除第N行上的断点</td></tr><tr><td>watch exp</td><td>exp成立程序停住</td></tr><tr><td>next（简写n）</td><td>单步执行，遇到函数会跳过</td></tr><tr><td>next N</td><td>执行N次单步执行</td></tr><tr><td>step（简写s)</td><td>单步执行，遇到函数会进入</td></tr><tr><td>finish</td><td>执行完当前函数，返回到调用它的位置</td></tr><tr><td>continue</td><td>运行到下一个断点处</td></tr><tr><td>until（简写u）</td><td>鼠标放到代码行，运行到该代码行停止</td></tr><tr><td>jump N</td><td>跳转到第N行开始执行，不会主动在N行停住</td></tr><tr><td>run</td><td>重新运行调试的程序，可以带参数</td></tr><tr><td>[Enter]</td><td>直接回车执行上次执行的命令</td></tr><tr><td>print var（简写p）</td><td>查看变量var的值</td></tr><tr><td>print /x var</td><td>按16进制格式显示变量值</td></tr><tr><td>ptype var</td><td>查看变量var的结构或类型</td></tr><tr><td>backtrach</td><td>查看调用堆栈</td></tr></tbody></table><h2 id="四、多进程调试"><a href="#四、多进程调试" class="headerlink" title="四、多进程调试"></a>四、多进程调试</h2><p>在调试多进程程序时GDB默认只会调试主进程，但是GDB（&gt;V7.0）支持对多进程分别或同时调试。换句话说，GDB可以同时调试多个程序。只需要设置follow-fork-mode(默认值：parent)和detach-on-fork（默认值：on）即可。</p><table><thead><tr><th>follow-fork-mode</th><th>detach-on-fork</th><th>说明</th></tr></thead><tbody><tr><td>parent</td><td>on</td><td>只调试主进程（GDB默认）</td></tr><tr><td>child</td><td>on</td><td>只调试子进程</td></tr><tr><td>parent</td><td>off</td><td>同时调试两个进程，gdb跟主进程，子进程block在fork位置</td></tr><tr><td>child</td><td>off</td><td>同时调试两个进程，gdb跟子进程，主进程block在fork位置</td></tr></tbody></table><p>   设置方法：set follow-fork-mode [parent|child]   set detach-on-fork [on|off]</p><blockquote><p>查询正在调试的进程：info inferiors<br>   切换调试的进程： inferior <infer number=""><br>   添加新的调试进程： add-inferior [-copies n] [-exec executable] ,可以用file executable来分配给inferior可执行文件。<br>   其他：remove-inferiors infno， detach inferior</infer></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ⑦ 软件调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(4)--MySQL字符编码</title>
      <link href="/post/1559270845.html"/>
      <url>/post/1559270845.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-MySQL-字符集和校对规则"><a href="#一-MySQL-字符集和校对规则" class="headerlink" title="一. MySQL 字符集和校对规则"></a>一. MySQL 字符集和校对规则</h1><p>MySQL 的字符集是用来定义 MySQL 存储字符串的方式，校对规则（有的软件叫排序规则）则是用来定义了比较字符串的方式。字符集和校对规则是一对多的关系。每种字符集都有一个默认校对规则。</p><p><strong>查看数据库支持的字符集:</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 方法<span class="number">1</span>：</span><br><span class="line"><span class="keyword">SHOW</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span>;</span><br><span class="line"></span><br><span class="line"># 方法<span class="number">2</span>：</span><br><span class="line">USE information_schema;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> CHARACTER_SETS;</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p><strong>查看数据库支持的校对规则：</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 方法<span class="number">1</span>：</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLLATION</span>;</span><br><span class="line"></span><br><span class="line"># 方法<span class="number">2</span>：</span><br><span class="line">USE information_schema;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> collations;</span><br></pre></td></tr></tbody></table></figure><h1 id="二-MySQL-各个级别字符集"><a href="#二-MySQL-各个级别字符集" class="headerlink" title="二. MySQL 各个级别字符集"></a>二. MySQL 各个级别字符集</h1><p>MySQL 可以对如下字符集进行设置：</p><ul><li>服务器级字符集（CHARACTER_SET_SERVER）</li><li>数据库级字符集（CHARACTER_SET_DATABASE）</li><li>表级字符集</li><li>字段级字符集</li><li>连接字符集（CHARACTER_SET_CONNECTION），客户端连接数据库所用的字符集。</li><li>结果字符集（CHARACTER_SET_RESULTS），存储查询结果（含错误信息）所用的字符集。</li><li>客户端字符集（CHARACTER_SET_CLIENT），客户端发送给 MySQL 服务器的查询语句字符集。</li><li>系统字符集（CHARACTER_SET_SYSTEM），用于存储我们新建的或自带的数据库的表、列的名称，默认是 UTF-8</li></ul><p><code>服务器级、数据库级、表级、字段级</code> 这 4 个字符集设置影响到数据库中存储数据的编码。 这 4 个级别的字符集继承关系为：<code>服务器级 --&gt; 数据库级 --&gt; 表级 --&gt; 字段级</code>, 从左到右，一级继承一级，和 C++、Java 中的类的继承类似，如果某一级未显式的指定字符集，那么将继承上一级的字符集设置。</p><h2 id="2-1-服务器级别字符集设置"><a href="#2-1-服务器级别字符集设置" class="headerlink" title="2.1 服务器级别字符集设置"></a>2.1 服务器级别字符集设置</h2><p>服务器级别的字符集可以从下面几个地方指定，从上到下优先级依次增加：</p><ul><li>编译 MySQL 时指定的字符集</li><li>my.cnf 配置文件设置 character-set-server</li><li>mysqld 服务启动命令行中指定字符集</li></ul><p>影响数据存储的字符集之间的关系：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/mysql-zfbm-1.jpg"></p><p><strong>查看当前数据库的字符集设置：</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 方法<span class="number">1</span>：</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">'%character%'</span>;</span><br><span class="line"></span><br><span class="line"># 方法<span class="number">2</span>：</span><br><span class="line">USE information_schema;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> GLOBAL_VARIABLES <span class="keyword">WHERE</span> VARIABLE_NAME <span class="keyword">LIKE</span> <span class="string">'%character%'</span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="3-utf8-与-utf8mb4-区别"><a href="#3-utf8-与-utf8mb4-区别" class="headerlink" title="3. utf8 与 utf8mb4 区别"></a>3. utf8 与 utf8mb4 区别</h1><p>UTF-8 是多字节编码方案，采用 1~4 个字节来存储一个字符，但在 MySQL 设计之初，一个字符最多采用 3 个字节的就可以存储，所以 Mysql 的设计者将 MySQL 中的 UTF-8 字符集（UTF-8 其实不是字符集，是字符编码方案，但在 MySQL 中一直这么叫）设计成了最大长度只能为 3. 如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/mysql-zfbm-2.jpg"></p><p>但随着 Unicode 字符集的扩张，出现了需要 4 个字节才能存储的字符，如果这时仍然使用 utf-8（指 mysql 中的 3 字节 utf-8）来存储这些字符就会出现错误，<br>如执行<code>INSERT INTO member(memberName)VALUES('𤭢')</code>报错如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Warning Code : 1366</span><br><span class="line">Incorrect string value: '\xF0\xA4\xAD\xA2' for column 'memberName' at row 1</span><br></pre></td></tr></tbody></table></figure><p>于是 MySQL 后来新增了 utf8mb4 字符集，最大长度为 4，兼容之前的 utf8，但为了之前的数据库不报错，仍然保留了之前的 utf8 字符集。 所以 MySQL 中的 UTF-8 字符集是伪 UTF-8，现在需要使用 utf8mb4。</p><h1 id="4-完全避免字符乱码"><a href="#4-完全避免字符乱码" class="headerlink" title="4. 完全避免字符乱码"></a>4. 完全避免字符乱码</h1><p>要完全避免字符乱码，最简单也是最好的方法就是将各个字符集保持一致，可以都设置为 utf8mb4。Mysql 数据存储涉及到的 4 个字符集的设置可以使用第 2 节的方法进行设置，客户端字符集、连接字符集，结果字符集关系到数据显示的正确性，可以使用如下语句统一设置为 utf8mb4，但这个设置只针对当前连接有效：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set names utf8mb4;</span><br></pre></td></tr></tbody></table></figure><p>编程开发中，一般使用 MySQL API 进行数据连接、查询等操作，可以使用<code>mysql_set_character_set</code>对每个连接进行设置，这个 API 会将客户端字符集、连接字符集，结果字符集都设置为指定字符集，代码大致如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MYSQL* pMysql = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">mysql_real_connect</span>(pMysql, szHost, szUser, szPwd, szDatabase, iPort, <span class="literal">NULL</span>, CLIENT_MULTI_STATEMENTS);</span><br><span class="line"><span class="built_in">mysql_set_character_set</span>(pMysql, <span class="string">"utf8mb4"</span>);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(2)--编译器处理文件编码</title>
      <link href="/post/1337290471.html"/>
      <url>/post/1337290471.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍微软 MSVC 编译器如何加载和处理 C++代码文件。</p><span id="more"></span><h1 id="一-Visual-Studio-字符集"><a href="#一-Visual-Studio-字符集" class="headerlink" title="一. Visual Studio 字符集"></a>一. Visual Studio 字符集</h1><p>使用 Visual Studio 创建的 C++工程可以在工程属性<code>配置属性--&gt;常规</code>中配置字符集：<code>使用Unicode字符集</code>（默认）、<code>使用多字节字符集</code>。<br>如图：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/byqrhclzfbm-1.jpg"></p><p>但<strong>这个设置项不会对编译器处理字符编码产生直接的影响</strong>（注意这里的“直接”二字，第 3 节会说到），只会在工程属性<code>配置属性--&gt;C/C++--&gt;预处理器</code>加入相应的宏：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用Unicode字符集 --&gt; _UNICODE和UNICODE宏</span><br><span class="line">使用多字节字符集   --&gt; _MBCS宏</span><br></pre></td></tr></tbody></table></figure><p>这几个宏一般用来判断是使用 char 还是 wchar_t，在系统 API 中使用比较多，如 MessegeBox 通过是否定义了 UNICODE 宏来决定是使用 LPCSTR 还是 LPCWSTR（LPCSTR 即 const char*, LPCWSTR 即 const wchar_t*）：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MessageBox  MessageBoxW</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MessageBox  MessageBoxA</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !UNICODE</span></span></span><br></pre></td></tr></tbody></table></figure><h1 id="二-char-和-wchar-t"><a href="#二-char-和-wchar-t" class="headerlink" title="二. char 和 wchar_t"></a>二. char 和 wchar_t</h1><p>上面提到了，定义 API 时通过UNICODE 宏来决定是使用 char 还是 wchar_t类型，那么 char 和 wchar_t 有什么不同了？</p><p>char 和 wchar_t 是标准 C/C++字符类型，并不是 Windows 特有的。 char 固定占 1 个字节，wchar_t 固定占 2 个字节，从内存的角度来看，char、wchar_t 和其他数据类型一样，只是代表一段内存块，用来存储固定长度的二进制 0 或 1。 在编程时，我们一般习惯于将字符串储到 char 或 wchar_t 定义的内存空间中，将整形存储在 int 定义的内存空间中。</p><p>所以，用 char 还是 wchar_t 来存储字符，只是内存分配和数据存储上面的事情，<strong>它们本身也是与字符编码无直接关系的</strong>（ 同样注意这里的“直接”二字，第 3 节会说到）。</p><h1 id="三-编译器如何处理硬编码字符"><a href="#三-编译器如何处理硬编码字符" class="headerlink" title="三. 编译器如何处理硬编码字符"></a>三. 编译器如何处理硬编码字符</h1><p>VC++编译器编译源代码的步骤中，涉及编码处理的步骤主要有 2 个：<br>第 1 步：预处理</p><p>1.1) 读取源文件，判断源文件采用的字符编码类型。(<strong>这一步不会改变文件内容</strong>)</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">编译器判断源文件编码类型的步骤为：</span><br><span class="line">1. 若文件开始处有BOM(EF BB BF)，则判定为UTF-8编码；</span><br><span class="line">2. 若没有BOM，则试图从文件的前8个字节来判断文件是否像UTF-16编码，如果像，则就判断为UTF-16编码。</span><br><span class="line">3. 如果既没BOM，也不是UTF-16编码，则使用系统当前的代码页（简体中文操作系统为CP936）。</span><br></pre></td></tr></tbody></table></figure><p>1.2) 将源文件内容转成<code>源字符集</code>(Source Character Set)，默认为 UTF-8 编码。</p><p>第 2 步：链接</p><p>2.1) 将 1.2 中得到的 UTF-8 转为<code>执行字符集</code>(Execution Character Set)：</p><ul><li>对于宽字符串（即 C/C++中以<code>L</code>标记的串，如<code>L"abc"</code>, <code>L'中'</code>），<code>执行字符集</code>为 UTF-16 编码。</li><li>对于窄字符串（和宽字符串对应，即不以<code>L</code>标记的串），<code>执行字符集</code>为系统当前的代码页。</li></ul><p><img src="https://blog-static.jiangxueqiao.com/blog/img/byqrhclzfbm-2.jpg"></p><p>现在我们就可以说清楚 Visual Studio 字符集设置、char、wchar*t 是如何***间接_**影响到编译器对字符编码的处理了：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Visual Studio字符集设置</span><br><span class="line">      |</span><br><span class="line">决定声明哪一个宏（UNICODE还是_MBCS宏）</span><br><span class="line">      |</span><br><span class="line">宏又决定了API参数使用char还是wchar_t</span><br><span class="line">      |</span><br><span class="line">编译器在进行【执行字符集】编码时对char和wchar_采用不同的处理方式，从而对字符编码产生了影响。</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在 Visual Studio 2010（含）之后，支持使用<code>#pragma execution_character_set</code>来设置执行字符集。</p></blockquote><h1 id="四-实例分析"><a href="#四-实例分析" class="headerlink" title="四. 实例分析"></a>四. 实例分析</h1><ul><li>已知汉字“中”的各种编码如下：</li></ul><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GBK        D6 D0</span><br><span class="line">Unicode    2D 4E</span><br><span class="line">UTF-8      E4 B8 AD</span><br></pre></td></tr></tbody></table></figure><ul><li>函数<code>DumpCharacterCode</code>用于按字节打印内存中的数据：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DumpCharacterCode</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pChar, <span class="type">int</span> iSize)</span> </span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; iSize; i++) {</span><br><span class="line">    <span class="type">char</span> a = *pChar++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02X "</span>, a &amp; <span class="number">0xff</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>设置系统代码页的方法：<br>“控制面板” –&gt; “区域和语言” –&gt; “管理” –&gt; “非 Unicode 程序的语言” –&gt; “更改系统区域设置”</p></li><li><p>Visual Studio 保存文件到指定编码方法：<br>“文件” –&gt; “高级保存选项”</p></li></ul><h2 id="4-1-测试编译器处理窄字符编码"><a href="#4-1-测试编译器处理窄字符编码" class="headerlink" title="4.1 测试编译器处理窄字符编码"></a>4.1 测试编译器处理窄字符编码</h2><p>测试代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">{</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>] = {<span class="string">"中"</span>};   <span class="comment">// char</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">DumpCharacterCode</span>(buf, <span class="number">2</span>);  <span class="comment">// 也可以打印4个字节</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>针对不同的系统代码页和源文件编码，打印出的汉字“中”的编码分别为：</p><table><thead><tr><th>测试用例</th><th>系统代码页</th><th>保存源文件编码</th><th>编译器判断文件采用的编码</th><th>源字符集(Source Character Set)</th><th>执行字符集(Execution Character Set)</th><th>打印输出</th></tr></thead><tbody><tr><td>用例 1</td><td>简体中文 CP936</td><td>简体中文 CP936</td><td>简体中文 CP936</td><td>UTF-8</td><td>简体中文 CP936</td><td>D6 D0</td></tr><tr><td>用例 2</td><td>简体中文 CP936</td><td>UTF-8 BOM</td><td>UTF-8 BOM</td><td>UTF-8</td><td>简体中文 CP936</td><td>D6 D0</td></tr><tr><td>用例 3</td><td>简体中文 CP936</td><td>UTF-8</td><td>简体中文 CP936</td><td>UTF-8</td><td>简体中文 CP936</td><td>编译错误(C2146)</td></tr><tr><td>用例 4</td><td>西欧 CP1252</td><td>简体中文 CP936</td><td>西欧 CP1252</td><td>UTF-8</td><td>西欧 CP1252</td><td>D6 D0</td></tr><tr><td>用例 5</td><td>西欧 CP1252</td><td>UTF-8 BOM</td><td>UTF-8 BOM</td><td>UTF-8</td><td>西欧 CP1252</td><td>3F 00</td></tr></tbody></table><p>表格中列 4~6 依次对应编译处理源文件的几个步骤。<br><code>3F</code>对应的 ASCII 字符为<code>?</code>，编译器遇到不能识别的字符时，就会用<code>?</code>来替代。 出现<code>?</code>的情况会伴随着编译警告<code>C4566</code>。<br>上面出现了 1 次<code>3F</code>（用例 5），导致乱码的原因是<code>UTF-8 --&gt; 西欧 CP1252</code>. <code>西欧 CP1252</code>也就是 ASCII 的扩展，不支持汉字，所以用<code>3F</code>替代。</p><h4 id="用例-3-为什么会编译错误？"><a href="#用例-3-为什么会编译错误？" class="headerlink" title="用例 3 为什么会编译错误？"></a>用例 3 为什么会编译错误？</h4><p>微软的编译器只能识别带 BOM 的 UTF-8，用例 3 的 UTF-8 没带 BOM，编译器会判定源文件编码为系统当前代码页 CP936。“中”的 UTF-8 编码为<code>E4 B8 AD</code>，列 5 执行从 CP936 到 UTF-8 转换之后变成了<code>E6 B6 93 3F</code>，列 6 再要将<code>E6 B6 93 3F</code>转换为 CP936 肯定是转换不回去的，相当于 UTF-8（1） –&gt; UTF-8 （2），再将 UTF-8（2）转换回 CP936，这时肯定得到的字符不是原来的字符了。</p><h4 id="用例-4-为什么输出的D6-D0，而不是3F？"><a href="#用例-4-为什么输出的D6-D0，而不是3F？" class="headerlink" title="用例 4 为什么输出的D6 D0，而不是3F？"></a>用例 4 为什么输出的<code>D6 D0</code>，而不是<code>3F</code>？</h4><p>对着用例 4 的各个顺序来看，源文件通过 CP936 保存着，但编译器通过 CP1252 来读取的，CP1252 就是 ASCII 扩展，单字节的，虽然此时显示为乱码，但各字节仍然是 D6 D0；然后将读取到的文件内容从 CP1252 转成 UTF-8 编码，转码后为 C3 96 C3 90；然后再将 UTF-8 编码转回为 CP1251，转码就又变成了 D6 D0。 但这个<code>D6 D0</code>在 CP1252 中是无法显示的，如果我们在用例 4 加入<code>MessageBoxA(NULL, "中", "test", MB_OK);</code> 会发现弹出的对话框中显示仍然是乱码。<br>可以使用下面的代码进行测试：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">{</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">3</span>] = { <span class="number">0</span> };    <span class="comment">// 模拟CP936编码的“中”</span></span><br><span class="line">  buf[<span class="number">0</span>] = <span class="number">0xD6</span>;</span><br><span class="line">  buf[<span class="number">1</span>] = <span class="number">0xD0</span>;</span><br><span class="line"></span><br><span class="line">  std::string strUTF8 = <span class="built_in">ANSIToUTF8</span>(buf, <span class="number">1252</span>);</span><br><span class="line">  <span class="type">char</span> *p = (<span class="type">char</span>*)strUTF8.<span class="built_in">c_str</span>();  <span class="comment">// 通过visual studio查看指针p处内存为： C3 96 C3 90</span></span><br><span class="line"></span><br><span class="line">  std::string str = <span class="built_in">UTF8ToANSI</span>(strUTF8, <span class="number">1252</span>);</span><br><span class="line">  p = (<span class="type">char</span>*)str.<span class="built_in">c_str</span>();   <span class="comment">// 通过visual studio查看指针p处内存为： D6 D0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-2-测试编译器处理宽字符编码"><a href="#4-2-测试编译器处理宽字符编码" class="headerlink" title="4.2 测试编译器处理宽字符编码"></a>4.2 测试编译器处理宽字符编码</h2><p>测试代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">{</span><br><span class="line">  <span class="type">wchar_t</span> buf[<span class="number">100</span>] = {<span class="string">L"中"</span>};   <span class="comment">// wchar_t</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">DumpCharacterCode</span>((<span class="type">char</span>*)buf, <span class="number">4</span>); <span class="comment">// 打印4个字节</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同样，针对不同的系统代码页和源文件编码，打印出的汉字“中”的编码分别为：</p><table><thead><tr><th>测试用例</th><th>系统代码页</th><th>保存源文件编码</th><th>编译器判断文件采用的编码</th><th>源字符集(Source Character Set)</th><th>执行字符集(Execution Character Set)</th><th>打印输出</th></tr></thead><tbody><tr><td>用例 1</td><td>简体中文 CP936</td><td>简体中文 CP936</td><td>简体中文 CP936</td><td>UTF-8</td><td>UTF-16</td><td>2D 4E 00 00</td></tr><tr><td>用例 2</td><td>简体中文 CP936</td><td>UTF-8 BOM</td><td>UTF-8 BOM</td><td>UTF-8</td><td>UTF-16</td><td>2D 4E 00 00</td></tr><tr><td>用例 3</td><td>简体中文 CP936</td><td>UTF-8</td><td>简体中文 CP936</td><td>UTF-8</td><td>UTF-16</td><td>编译错误(C2146)</td></tr><tr><td>用例 4</td><td>西欧 CP1252</td><td>简体中文 CP936</td><td>西欧 CP1252</td><td>UTF-8</td><td>UTF-16</td><td>D6 00 D0 00 <strong>大小端</strong></td></tr><tr><td>用例 5</td><td>西欧 CP1252</td><td>UTF-8 BOM</td><td>UTF-8 BOM</td><td>UTF-8</td><td>UTF-16</td><td>2D 4E 00 00</td></tr></tbody></table><h1 id="五-彻底避免硬编码字符乱码"><a href="#五-彻底避免硬编码字符乱码" class="headerlink" title="五. 彻底避免硬编码字符乱码"></a>五. 彻底避免硬编码字符乱码</h1><p>通过第 3 节的说明，很容易知道，要开发支持多语言，在任意语言（系统代码页）的 windows 环境下都正常编译，且运行起来没有乱码的程序，需要遵循如下原则：</p><ol><li>代码文件采用 UTF-8 with BOM 编码。</li><li>Visual Studio 字符集设置为 Unicode 字符集。</li><li>使用 wchar_t。</li></ol><p>做到上面 3 步，你的代码被别人从 github 上 clone 下来编译，不会因为你代码中含有中文等字符，产生类似<code>error C2015</code>这样的编译错误，更不会产生乱码。</p><blockquote><p>本文介绍的方法只用来解决硬编码字符乱码的问题，至于数据传输中的乱码，需要统一字符编码来解决。</p></blockquote><blockquote><p>参考: <a href="https://blogs.msdn.microsoft.com/vcblog/2016/02/22/new-options-for-managing-character-sets-in-the-microsoft-cc-compiler">https://blogs.msdn.microsoft.com/vcblog/2016/02/22/new-options-for-managing-character-sets-in-the-microsoft-cc-compiler</a></p></blockquote><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(3)--字符编码转换</title>
      <link href="/post/4126466705.html"/>
      <url>/post/4126466705.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍如何使用系统 API 进行字符编码的转换。</p><span id="more"></span><h1 id="1-Windows-API-介绍"><a href="#1-Windows-API-介绍" class="headerlink" title="1. Windows API 介绍"></a>1. Windows API 介绍</h1><p>本文介绍使用 Windows API 进行字符编码的转换，涉及<code>WideCharToMultiByte</code>和<code>MultiByteToWideChar</code>2 个 API，<br>API 接口名中的<code>MultiByte</code>对应着多字节编码，如 ASCII、UTF-8 等都是多字节编码，而<code>WideChar</code>字面意思是宽字符，在 windows 内部宽字符特指 UTF-16 编码。</p><p>原型如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WideCharToMultiByte</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  UINT CodePage,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR lpWideCharStr,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span> cchWideChar,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSTR lpMultiByteStr,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span> cbMultiByte,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpDefaultChar,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPBOOL lpUsedDefaultChar</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MultiByteToWideChar</span><span class="params">(</span></span><br><span class="line"><span class="params">  UINT CodePage,</span></span><br><span class="line"><span class="params">  DWORD dwFlags,</span></span><br><span class="line"><span class="params">  LPCSTR lpMultiByteStr,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> cbMultiByte,</span></span><br><span class="line"><span class="params">  LPWSTR lpWideCharStr,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> cchWideChar</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="2-API-封装"><a href="#2-API-封装" class="headerlink" title="2. API 封装"></a>2. API 封装</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">UnicodeToANSI</span><span class="params">(<span class="type">const</span> std::wstring &amp;str, UINT iCodePage = CP_ACP)</span> </span>{</span><br><span class="line">  std::string strRes;</span><br><span class="line">  <span class="type">int</span> iSize = ::<span class="built_in">WideCharToMultiByte</span>(iCodePage, <span class="number">0</span>, str.<span class="built_in">c_str</span>(), <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iSize == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> strRes;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *szBuf = <span class="built_in">new</span> (std::nothrow) <span class="type">char</span>[iSize];</span><br><span class="line">  <span class="keyword">if</span> (!szBuf)</span><br><span class="line">    <span class="keyword">return</span> strRes;</span><br><span class="line">  <span class="built_in">memset</span>(szBuf, <span class="number">0</span>, iSize);</span><br><span class="line"></span><br><span class="line">  ::<span class="built_in">WideCharToMultiByte</span>(iCodePage, <span class="number">0</span>, str.<span class="built_in">c_str</span>(), <span class="number">-1</span>, szBuf, iSize, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  strRes = szBuf;</span><br><span class="line">  <span class="keyword">delete</span>[] szBuf;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> strRes;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::wstring <span class="title">ANSIToUnicode</span><span class="params">(<span class="type">const</span> std::string &amp;str, UINT iCodePage = CP_ACP)</span> </span>{</span><br><span class="line">  std::wstring strRes;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> iSize = ::<span class="built_in">MultiByteToWideChar</span>(iCodePage, <span class="number">0</span>, str.<span class="built_in">c_str</span>(), <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iSize == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> strRes;</span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> *szBuf = <span class="built_in">new</span> (std::nothrow) <span class="type">wchar_t</span>[iSize];</span><br><span class="line">  <span class="keyword">if</span> (!szBuf)</span><br><span class="line">    <span class="keyword">return</span> strRes;</span><br><span class="line">  <span class="built_in">memset</span>(szBuf, <span class="number">0</span>, iSize * <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>));</span><br><span class="line"></span><br><span class="line">  ::<span class="built_in">MultiByteToWideChar</span>(iCodePage, <span class="number">0</span>, str.<span class="built_in">c_str</span>(), <span class="number">-1</span>, szBuf, iSize);</span><br><span class="line"></span><br><span class="line">  strRes = szBuf;</span><br><span class="line">  <span class="keyword">delete</span>[] szBuf;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> strRes;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">UnicodeToUTF8</span><span class="params">(<span class="type">const</span> std::wstring &amp;str)</span> </span>{</span><br><span class="line">  std::string strRes;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> iSize = ::<span class="built_in">WideCharToMultiByte</span>(CP_UTF8, <span class="number">0</span>, str.<span class="built_in">c_str</span>(), <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iSize == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> strRes;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *szBuf = <span class="built_in">new</span> (std::nothrow) <span class="type">char</span>[iSize];</span><br><span class="line">  <span class="keyword">if</span> (!szBuf)</span><br><span class="line">    <span class="keyword">return</span> strRes;</span><br><span class="line">  <span class="built_in">memset</span>(szBuf, <span class="number">0</span>, iSize);</span><br><span class="line"></span><br><span class="line">  ::<span class="built_in">WideCharToMultiByte</span>(CP_UTF8, <span class="number">0</span>, str.<span class="built_in">c_str</span>(), <span class="number">-1</span>, szBuf, iSize, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  strRes = szBuf;</span><br><span class="line">  <span class="keyword">delete</span>[] szBuf;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> strRes;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">UnicodeToUTF8BOM</span><span class="params">(<span class="type">const</span> std::wstring &amp;str)</span> </span>{</span><br><span class="line">  std::string strRes;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> iSize = ::<span class="built_in">WideCharToMultiByte</span>(CP_UTF8, <span class="number">0</span>, str.<span class="built_in">c_str</span>(), <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iSize == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> strRes;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *szBuf = <span class="built_in">new</span> (std::nothrow) <span class="type">unsigned</span> <span class="type">char</span>[iSize + <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">if</span> (!szBuf)</span><br><span class="line">    <span class="keyword">return</span> strRes;</span><br><span class="line">  <span class="built_in">memset</span>(szBuf, <span class="number">0</span>, iSize + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (::<span class="built_in">WideCharToMultiByte</span>(CP_UTF8, <span class="number">0</span>, str.<span class="built_in">c_str</span>(), <span class="number">-1</span>, (LPSTR)(szBuf + <span class="number">3</span>), iSize, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &gt; <span class="number">0</span>) {</span><br><span class="line">    szBuf[<span class="number">0</span>] = <span class="number">0xEF</span>;</span><br><span class="line">    szBuf[<span class="number">1</span>] = <span class="number">0xBB</span>;</span><br><span class="line">    szBuf[<span class="number">2</span>] = <span class="number">0xBF</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  strRes = (<span class="type">char</span>*)szBuf;</span><br><span class="line">  <span class="keyword">delete</span>[] szBuf;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> strRes;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::wstring <span class="title">UTF8ToUnicode</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>{</span><br><span class="line">  std::wstring strRes;</span><br><span class="line">  <span class="type">int</span> iSize = ::<span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, str.<span class="built_in">c_str</span>(), <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iSize == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> strRes;</span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> *szBuf = <span class="built_in">new</span> (std::nothrow) <span class="type">wchar_t</span>[iSize];</span><br><span class="line">  <span class="keyword">if</span> (!szBuf)</span><br><span class="line">    <span class="keyword">return</span> strRes;</span><br><span class="line">  <span class="built_in">memset</span>(szBuf, <span class="number">0</span>, iSize * <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>));</span><br><span class="line">  ::<span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, str.<span class="built_in">c_str</span>(), <span class="number">-1</span>, szBuf, iSize);</span><br><span class="line"></span><br><span class="line">  strRes = szBuf;</span><br><span class="line">  <span class="keyword">delete</span>[] szBuf;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> strRes;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">ANSIToUTF8</span><span class="params">(<span class="type">const</span> std::string &amp;str, UINT iCodePage = CP_ACP)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">UnicodeToUTF8</span>(<span class="built_in">ANSIToUnicode</span>(str, iCodePage));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">ANSIToUTF8BOM</span><span class="params">(<span class="type">const</span> std::string &amp;str, UINT iCodePage = CP_ACP)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">UnicodeToUTF8BOM</span>(<span class="built_in">ANSIToUnicode</span>(str, iCodePage));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">UTF8ToANSI</span><span class="params">(<span class="type">const</span> std::string &amp;str, UINT iCodePage = CP_ACP)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">UnicodeToANSI</span>(<span class="built_in">UTF8ToUnicode</span>(str), iCodePage);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>对于只支持简体中文（部分韩文、日文）的系统，<code>iCodePage</code>可以使用 CP_ACP，这时 API 会使用系统当前的代码页（简体中文系统为 CP936，即 GBK 字符集）来进行编码转换。 但遇到如下情况就需要手动指定代码页：</p><ol><li>需要转换的字符串中的文字是系统当前代码页不支持的。如字符串中含有中文，而当前系统代码页确是英文的；</li><li>GBK 字符集中只包含了一部分韩文和日文，部分韩文和日文的转换可以正常转换，若遇到不能转换的情况也需要将指定 iCodePage 为特定的支持韩文或日文的代码页了，特别是中文和韩文、日文等混合的情况下。如韩文“탉”不包含在 GBK 中，若这时仍然使用 CP_ACP 就会得到错误的转换结果<code>?</code>，十六进制<code>3F</code>。但 GB18030（代码页为 54936）支持“탉”，可以手动指定 iCodePage 为 54936。</li></ol><blockquote><p>如果代码中含有 GBK 不支持的字符，如“탉”、“𤭢”（念 suì）等，Visual Studio 会弹出如下提示：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA1MTI5ODIz"><br>选择“以其他编码保存”，选择“Unicode（UTF-8 带签名）- 代码页 65001”保存。<br>虽然“简体中文（GB18030) - 代码页 54936”也支持这些字符，但不能选择该选项进行保存，具体原因在<a href="/post/1337290471.html" title="拨开字符编码的迷雾(2)--编译器处理文件编码">拨开字符编码的迷雾(2)--编译器处理文件编码</a>中有详细的介绍。</p></blockquote><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(1)--字符编码概述</title>
      <link href="/post/2720283852.html"/>
      <url>/post/2720283852.html</url>
      
        <content type="html"><![CDATA[<p>为什么这样的字符串<code>{"data":"颸颸"}</code>，JSON 库（如<code>jsoncpp</code>）会解析失败？</p><p>为什么软件界面上的韩文会显示乱码？</p><p>ASCII 和 ANSI 有什么区别？</p><p>相信不少人在字符编码上面摔过跟头，这篇文章针对开发中需要了解的字符编码知识进行了简要的讲解，希望能够对大家有所帮助。</p><span id="more"></span><h1 id="1-ASCII-及其扩展"><a href="#1-ASCII-及其扩展" class="headerlink" title="1. ASCII 及其扩展"></a>1. ASCII 及其扩展</h1><h2 id="1-1-什么是-ASCII-字符集"><a href="#1-1-什么是-ASCII-字符集" class="headerlink" title="1.1 什么是 ASCII 字符集"></a>1.1 什么是 ASCII 字符集</h2><p>字符集就是一系列用于显示的字符的集合。</p><p>ASCII 字符集由美国国家标准协会（American National Standard Institute)于 1968 年制定一个字符映射集合。</p><p>ASCII 使用 7 位二进制位来表示一个字符，总共可以表示 128 个字符（即<code>2^7</code>，二进制<code>000 0000 ～ 111 1111</code>，十进制<code>0～127</code>）。</p><p>ASCII 字符集中每个数字对应一个唯一的字符，如下表：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA0OTUyMDA5"></p><p>因为其对应关系非常简单，不需要特殊的编码规则，所以严格来讲 ASCII 不能算字符编码，因为它没有规定编码规则。我们只是习惯性的将 ASCII 字符集称之为 ASCII 码、ASCII 编码。</p><h2 id="1-2-ASCII-的扩展"><a href="#1-2-ASCII-的扩展" class="headerlink" title="1.2 ASCII 的扩展"></a>1.2 ASCII 的扩展</h2><h3 id="1-2-1-最高位扩展-ISO-IEC-8859"><a href="#1-2-1-最高位扩展-ISO-IEC-8859" class="headerlink" title="1.2.1 最高位扩展 - ISO/IEC 8859"></a>1.2.1 最高位扩展 - ISO/IEC 8859</h3><p>ASCII 字符集是美国人发明的，其中的字符完全是为其自己量身定制的。随着计算机技术普及到欧洲（如法国、德国）各国，欧洲很多国家使用的字符除了 ASCII 表中的 128 个字符之外，还有一些各国特有的字符，此时欧洲人民发现 ASCII 字符集不能完全表达他们所要表达的内容。怎么办了？他们发现 ASCII 只使用了一个字节（8 位）之中的低 7 位，于是欧洲各国开始各显神通，打起了那 1 个最高位（第 0 位）的主意，将最高位利用了起来，这样又多了 128 个字符，从而满足了欧洲人民的需要。</p><p>但因为每个国家的需求不一样，各国都设计了不同的方案。为了结束这种混乱的局面，国际标准化组织(ISO)及国际电工委员会(IEC)联合制定了<strong>一系列 8 位字符集</strong>的标准，统称为 ISO 8859（全称 ISO/IEC 8859）。注意，这是一系列字符集的统称，如 ISO/IEC 8859-1（也就是常听到的 Latin-1）支持西欧语言，ISO/IEC 8859-4（Latin-4）支持北欧语言等。</p><p>完整列表如下（摘自百度百科）：<br>ISO/IEC 8859-1 (Latin-1) - 西欧语言<br>ISO/IEC 8859-2 (Latin-2) - 中欧语言<br>ISO/IEC 8859-3 (Latin-3) - 南欧语言，世界语也可用此字符集显示。<br>ISO/IEC 8859-4 (Latin-4) - 北欧语言<br>ISO/IEC 8859-5 (Cyrillic) - 斯拉夫语言<br>ISO/IEC 8859-6 (Arabic) - 阿拉伯语<br>ISO/IEC 8859-7 (Greek) - 希腊语<br>ISO/IEC 8859-8 (Hebrew) - 希伯来语(视觉顺序)<br>ISO 8859-8-I - 希伯来语(逻辑顺序)<br>ISO/IEC 8859-9 (Latin-5 或 Turkish) - 它把 Latin-1 的冰岛语字母换走，加入土耳其语字母。<br>ISO/IEC 8859-10 (Latin-6 或 Nordic) - 北日耳曼语支，用来代替 Latin-4。<br>ISO/IEC 8859-11 (Thai) - 泰语，从泰国的 TIS620 标准字集演化而来。<br>ISO/IEC 8859-13 (Latin-7 或 Baltic Rim) - 波罗的语族<br>ISO/IEC 8859-14 (Latin-8 或 Celtic) - 凯尔特语族<br>ISO/IEC 8859-15 (Latin-9) - 西欧语言，加入 Latin-1 欠缺的芬兰语字母和大写法语重音字母，以及欧元符号。<br>ISO/IEC 8859-16 (Latin-10) - 东南欧语言。主要供罗马尼亚语使用，并加入欧元符号。</p><blockquote><p>我们在数据库中常见到的 Latin-1、2、5、7 其实就是上面提到的针对特定语言的 ASCII 扩展字符集。<br><img src="https://blog-static.jiangxueqiao.com/blog/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA1MDA0NTIy"></p></blockquote><h3 id="1-2-2-多字节扩展-GB-系列"><a href="#1-2-2-多字节扩展-GB-系列" class="headerlink" title="1.2.2 多字节扩展 - GB 系列"></a>1.2.2 多字节扩展 - GB 系列</h3><p>前面讲到了，欧洲各国有效利用闲置的最高位对 ASCII 字符集进行了扩展。可是欧洲人民没有想到在大洋彼岸有着一个拥有五千年历史的伟大民族，她拥有着成千上万的汉字，1 个字节显然不够表达如此深厚的文化底蕴。</p><p>于是当计算机引入到中国之初，国家技术监督局就设计了 GB 系列编码方案（GB 为 guo biao 的简称)。<br><strong>GB 编码方案使用 2 个字节来表达一个汉字。同时为了兼容 ASCII 编码，规定各个字节的最高位（首位）必须为 1，从而避免了和最高位为 0 的 ASCII 字符集的冲突。</strong></p><p>GB 系列字符集经历下面的几个发展过程：</p><table><thead><tr><th>编码名称</th><th>发布时间</th><th>字节数</th><th>汉字范围</th></tr></thead><tbody><tr><td>GB2312</td><td>1980 年</td><td>变字节（ASCII 1 字节，汉字 2 个字节）</td><td>6763 个汉字</td></tr><tr><td>GB13000</td><td>1993 年第一版</td><td>变字节（ASCII 1 字节，汉字 2 个字节）</td><td>20902 个汉字</td></tr><tr><td>GBK</td><td>Windows95 中</td><td>2 个字节</td><td>21886 个汉字和图形符号（含 GB2312，BIG5 中所有字符）</td></tr><tr><td>GB18030</td><td>2000 年第一版</td><td>变字节（ASCII 1 字节，汉字 2 个或 4 个字节）</td><td>27484 个汉字</td></tr></tbody></table><p>每一次迭代，支持的字符数量都会增加，而且每一次迭代都会保留之前版本支持的编码，所以做到了向上兼容。</p><h3 id="1-2-3-全角与半角"><a href="#1-2-3-全角与半角" class="headerlink" title="1.2.3 全角与半角"></a>1.2.3 全角与半角</h3><p>因为汉字在显示器上的显示宽度要比英文字符的宽度要宽一倍，在一起排版显示时不太美观。所以 GB 编码不仅仅加入了汉字字符，而且包括了 ASCII 字符集中本来就有的数字、标点符号、字母等字符。这些被编入 GB 编码的数字、标点、字母在显示器上的显示宽度比 ASCII 字符集中的宽度宽一倍，所以前者称为全角字符，后者称为半角字符。</p><h1 id="2-ANSI"><a href="#2-ANSI" class="headerlink" title="2. ANSI"></a>2. ANSI</h1><h2 id="2-1-ANSI-与代码页"><a href="#2-1-ANSI-与代码页" class="headerlink" title="2.1 ANSI 与代码页"></a>2.1 ANSI 与代码页</h2><p>前面说到了世界各国针对 ASCII 的扩展方案（如欧洲的 ISO/IEC 8859，中国的 GB 系列等），这些 ASCII 扩展编码方案的特点是：他们都兼容 ASCII 编码，但他们彼此之间是不兼容的。微软将这些编码方案统称为 ANSI 编码。故 ANSI 并不是特指某一种编码方案，只有知道了在哪个国家，哪个语言环境下，才知道它具体表示哪个编码方案。</p><p>在 Windows 操作系统上，默认使用 ANSI 来保存文件（从Windows 10开始默认使用UTF8编码）。操作系统是如何知道 ANSI 到底应该表示哪种编码了，是 GBK还是 ASCII，或者还是 EUC-KR 了？ Windows 通过一个叫”Code Page”（翻译为中文叫代码页）的东西来判断系统的默认编码。</p><p>简体中文操作系统默认的代码页是 936，它表示 ANSI 使用的是 GBK 编码。<br>GB18030 编码对应的 windows 代码页为 CP54936。</p><p>可以使用命令<code>chcp</code>来查看系统默认的代码页.</p><p>汉字“𤭢”（念 suì）只包含在 GB18030 中，GB2312、GB13000、GBK 中均不包含。默认情况下，在 Visual Studio 中输入该汉字，visual studio 会使用 CP936（即 GBK）来保存代码文件，但如果在代码文件中输入该汉字，visual studio 弹出如下提示要求用户选择代码页：<br><img src="https://blog-static.jiangxueqiao.com/blog/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA1MTI5ODIz"><br><img src="https://blog-static.jiangxueqiao.com/blog/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA1MTM4NTUx"></p><h2 id="2-2-更改默认代码页"><a href="#2-2-更改默认代码页" class="headerlink" title="2.2 更改默认代码页"></a>2.2 更改默认代码页</h2><h3 id="2-2-1-chcp-命令"><a href="#2-2-1-chcp-命令" class="headerlink" title="2.2.1 chcp 命令"></a>2.2.1 chcp 命令</h3><p>可以使用<code>chcp</code>命令来更改默认代码页，如<code>chcp 437</code>将默认代码页更改为 437（美国）。</p><h3 id="2-2-2-控制面板"><a href="#2-2-2-控制面板" class="headerlink" title="2.2.2 控制面板"></a>2.2.2 控制面板</h3><p>在“控制面板”–&gt;“区域和语言”–&gt; “更改系统区域设置”中更改系统默认的代码页为“中文（简体，中国）”。</p><h3 id="2-2-3-代码修改"><a href="#2-2-3-代码修改" class="headerlink" title="2.2.3 代码修改"></a>2.2.3 代码修改</h3><p>也可以通过代码更改默认的代码页：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">setlocale</span><span class="params">(</span></span><br><span class="line"><span class="params">   <span class="type">int</span> category,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="type">char</span> *locale</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="3-Unicode"><a href="#3-Unicode" class="headerlink" title="3. Unicode"></a>3. Unicode</h1><h2 id="3-1-Unicode-产生背景"><a href="#3-1-Unicode-产生背景" class="headerlink" title="3.1 Unicode 产生背景"></a>3.1 Unicode 产生背景</h2><p>各个国家使用不同的编码规则，虽然他们都是兼容 ASCII 的，但它们相互却是不兼容的。</p><p>试想法国人 Jack 写了一封名为”love_you.txt”的信，传给了他的德国朋友 Rose，Rose 想要在 windows 系统上打开这个文件，她需要知道德国使用的字符编码是 Latin-1，然后还要确保她的计算机上安装了该编码，才能顺利的打开这个文件。<br>如果上面这些还能忍受，那么随着网络的发展，你从互联网上获取的文件，你很有可能不知道它来自哪个国家，使用的哪种编码。这也就是 Email 刚诞生时常常出现乱码的原因，发信人和收信人使用的编码可能是不一样的。</p><p>于是<code>The Unicode Standard</code>（统一码标准）横空出世，它由 The Unicode Consortium 于 1991 年发布，我们习惯称它为 Unicode 字符集。</p><p>Unicode 字符集和 ASCII 字符集一样，也只是一个字符集合，标记着字符和数字之间的映射关系，它不包含任何编码规则和方案。和 ASCII 不一样的是，Unicode 字符集支持的字符数量是没有限制的（具体可以参考 Unicode 规范）。</p><blockquote><p>我们通常认为的 Unicode 字符固定占用 2 个字节的观点是错误的。如“𤭢”（念 suì）Unicode 码为<code>D852 DF62</code>。</p></blockquote><p>那么 Unicode 字符是怎样被编码成内存中的字节的了？它是通过 UTF(Unicode Transformation Formats)实现的，比较常见得有 UTF-8，UTF-16。</p><blockquote><p>在 windows 系统上汉字默认使用 CP936（即 GBK 编码），占 2 个字节。而大多数 Unicode 字符的 Unicode 码值也占 2 个字节，所以大多数人误以为汉字字符串在内存中的值就是 Unicode 值，这是错误的。<br>可以从 <a href="http://tool.chinaz.com/tools/unicode.aspx" title="站长工具">站长工具-Unicode</a> 查询汉字的 Unicode 码值。</p></blockquote><h2 id="3-3-字符集与字符编码的区别"><a href="#3-3-字符集与字符编码的区别" class="headerlink" title="3.3 字符集与字符编码的区别"></a>3.3 字符集与字符编码的区别</h2><p>从 ASCII、GB2312、GBK、GB18030、Big5（繁体中文）、Latin-1 等采用的方案来看，它们都只是定义了单个字符与二进制数据的映射关系，一个字符在一个方案中只会存在一种表示方式，所以我们说 GB2312 是字符集还是字符编码方式都无所谓了。但是 Unicode 不一样，Unicode 作为一个字符集可以采用多种编码方式，如 UTF-8, UTF-16, UTF-32 等。<strong>所以自 Unicode 出现之后，字符集与字符编码需要明确区分开来。</strong></p><h2 id="3-4-UTF-16-编码的缺点"><a href="#3-4-UTF-16-编码的缺点" class="headerlink" title="3.4 UTF-16 编码的缺点"></a>3.4 UTF-16 编码的缺点</h2><p>UTF-16 编码方式规定用两个或四个字节来表示所有的字符。对于 ASCII 字符保持不变，只是将原来的 7 位扩展到了 16 位，其高 9 位永远是 0。如字符’A’：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ASCII: 100 0001</span><br><span class="line">UTF-16: 0000 0000 0100 0001</span><br></pre></td></tr></tbody></table></figure><p>可以看到对于 ASCII 字符，UTF-16 的存储空间扩大了一倍，UTF-16 并不是完全兼容 ASCII 字符集。这对于那些 ASCII 字符集已经满足需求的西方国家来说完全是没必要的，而且 ASCII 字符经过 UTF-16 编码之后高字节始终是 0，导致很多 C 语言函数（如<code>strcpy</code>,<code>strlen</code>)会将此字节视为字符串的结束符<code>'\0'</code>，从而出现错误的计算结果。<br>而且，UTF-16 还存在大小端的问题，“𤭢”（念 suì）Unicode 码在大端系统上为<code>D852 DF62</code>，小端系统上为<code>52D8 62DF</code>。<br>因此，UTF-16 一开始推出的时候就遭到很多西方国家的抵制，影响了 Unicode 的推行。于是后来又设计了 UTF-8 编码方式，才解决了这些问题。</p><h2 id="3-5-Unicode-字符集常用编码方式：UTF-8"><a href="#3-5-Unicode-字符集常用编码方式：UTF-8" class="headerlink" title="3.5. Unicode 字符集常用编码方式：UTF-8"></a>3.5. Unicode 字符集常用编码方式：UTF-8</h2><h3 id="3-5-1-UTF-8-概述"><a href="#3-5-1-UTF-8-概述" class="headerlink" title="3.5.1 UTF-8 概述"></a>3.5.1 UTF-8 概述</h3><p>UTF-8 是互联网上使用最广泛的 Unicode 字符集编码方式。UTF-8 编码的最小单位由 8 位（1 个字节）组成，UTF-8 使用一个至四个字节来表示 Unicode 字符。另外，UTF-8 是完美兼容 ASCII 字符集的，这一点可以通过下面的 UTF-8 的编码规则得到证明。</p><h3 id="3-5-2-UTF-8-编码规则"><a href="#3-5-2-UTF-8-编码规则" class="headerlink" title="3.5.2 UTF-8 编码规则"></a>3.5.2 UTF-8 编码规则</h3><p>UTF-8 编码规则很简单：<br>（1）对于 ASCII（单字节字符）字符，采用和 ASCII 相同的编码方式，即只使用一个字节表示，且该字节第一位为 0.<br>（2）对于多字节（2~4 字节）字符，假设字节数为 n（1 &lt; n &lt;= 4），第一个字节：前 n 位都设为 1，第 n+1 位设为 0；后面的 n-1 个字节的前两位一律设为 10。所有字节中的没有提及的其他二进制位，全部为这个符号的 unicode 码。</p><table><thead><tr><th>Unicode 符号范围(十六进制)</th><th>UTF-8 编码方式(二进制)</th></tr></thead><tbody><tr><td>单字节:00000000-0000 007F</td><td>0xxxxxxx</td></tr><tr><td>双字节:00000080-0000 07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>三字节:00000800-0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>四字节:0001 0000-0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><h3 id="3-5-2-UTF-8-BOM"><a href="#3-5-2-UTF-8-BOM" class="headerlink" title="3.5.2 UTF-8 BOM"></a>3.5.2 UTF-8 BOM</h3><p>BOM（byte order mark）从字面意义来看是标记字节顺序的。最早出现的原因是因为 UTF-16 和 UTF-32 编码采用 2 个或 4 个字节表示一个字符，面临大小端的问题。为了区分是使用的大端(Big Endian，简称 BE)还是小端(Little Endian，简称 LE)，采用了在串的前面加入指定的字节加以区分，UTF-16 大端加入<code>FE FF</code>，小端加入<code>FF FE</code>. 比如， 字符串“ABC”的 UTF-16 编码为 <code>00 41 00 42 00 43</code>，对应的各种的字节序列如下：</p><table><thead><tr><th>序列</th><th>数据</th></tr></thead><tbody><tr><td>UTF-16BE(withoutBOM)</td><td>00 41 00 42 00 43</td></tr><tr><td>UTF-16LE(withoutBOM)</td><td>41 00 42 00 43 00</td></tr><tr><td>UTF-16BE(with BOM)</td><td>FE FF 00 41 00 42 00 43</td></tr><tr><td>UTF-16LE(with BOM)</td><td>FF FE 41 00 42 00 43 00</td></tr></tbody></table><p>因为 UTF-8 和 ASCII 都是单字节序列，二者不好区分，微软采用在 UTF-8 编码的字符串前也加入 BOM（3 个字节<code>EF BB BF</code>）来标记 UTF-8 编码的串。UTF-8 BOM 这一规范大多在 windows 下被使用，在其他平台下用的很少使用，如：Linux 全部采用 UTF-8 编码，不存在要区分的情况；HTTP 协议中可以包含<code>Content-Type:text/html; charset=utf-8</code>这样的说明，也不需要区分。</p><blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN 博客</a>中，因此图片被 CSDN 自动添加了水印。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ① 专栏集锦 </category>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL批量添加更新和删除</title>
      <link href="/post/2842059394.html"/>
      <url>/post/2842059394.html</url>
      
        <content type="html"><![CDATA[<h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users(name, age) <span class="keyword">VALUES</span>(<span class="string">'姚明'</span>, <span class="number">25</span>), (<span class="string">'比尔.盖茨'</span>, <span class="number">50</span>), (<span class="string">'火星人'</span>, <span class="number">600</span>);</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h2 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">member</span> <span class="keyword">SET</span> descipt <span class="operator">=</span> "默认" <span class="keyword">WHERE</span> usertypeid <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">member</span></span><br><span class="line"> <span class="keyword">SET</span> descipt <span class="operator">=</span> <span class="keyword">CASE</span> id</span><br><span class="line"> <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">'默认'</span></span><br><span class="line"> <span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">'黄铜'</span></span><br><span class="line"> <span class="keyword">WHEN</span> <span class="number">3</span> <span class="keyword">THEN</span> <span class="string">'黄金'</span></span><br><span class="line"> <span class="keyword">END</span></span><br><span class="line"> <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑨ 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2P及NAT穿透技术介绍</title>
      <link href="/post/2441416675.html"/>
      <url>/post/2441416675.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、-P2P（peer-to-peer）"><a href="#一、-P2P（peer-to-peer）" class="headerlink" title="一、 P2P（peer to peer）"></a>一、 P2P（peer to peer）</h1><p>P2P 是一个“点对点传输技术”，也就是 2 台计算机之间不需要第三台机器作为服务端就能实现数据的传输。每台计算机即是客户端又是服务端。如果每台计算机都有自己的独立的公网 IP，那么 P2P 技术就比较好实现了，但是现实中由于 NAT 的存在，使得 P2P 技术最大的难点就在于穿越 NAT 的限制，俗称“打洞”。</p><span id="more"></span><h1 id="二、-NAT（Network-Address-Translation）"><a href="#二、-NAT（Network-Address-Translation）" class="headerlink" title="二、 NAT（Network Address Translation）"></a>二、 NAT（Network Address Translation）</h1><h2 id="2-1-NAT-的产生背景"><a href="#2-1-NAT-的产生背景" class="headerlink" title="2.1 NAT 的产生背景"></a>2.1 NAT 的产生背景</h2><p>IPv4 即网际网协议第 4 版——Internet Protocol Version 4 的缩写。<br>如果我们把 Internet 比作一个邮政系统，那么 IP 地址的作用就等同于包含城市、街区、门牌编号在内的完整地址，可以准确的定位到某一台计算机。IPv4 使用 32bits 整数表达一个地址，地址最大范围就是 232 约为 43 亿。以 IP 创始时期可被联网的设备来看，这样的一个空间已经很大，很难被短时间用完。然而，事实远远超出人们的设想，计算机网络在此后的几十年里迅速壮大，网络终端数量也呈爆炸性增长。</p><p>更为糟糕的是，为了路由和管理方便，43 亿的地址空间被按照不同前缀长度划分为 A,B,C,D 类地址网络和保留地址。IANA 向超大型企业/组织分配 A 类网络地址，一次一段。向中型企业或教育机构分配 B 类网络地址，一次一段。这样一种分配策略使得 IP 地址浪费很严重，很多被分配出去的地址没有真实被利用，地址消耗很快。以至于二十世纪 90 年代初，网络专家们意识到，这样大手大脚下去，IPv4 地址很快就要耗光了。于是，人们开始考虑 IPv4 的替代方案，同时采取一系列的措施来减缓 IPv4 地址的消耗。正是在这样一个背景之下，NAT 应运而生。</p><h2 id="2-2-NAT"><a href="#2-2-NAT" class="headerlink" title="2.2 NAT"></a>2.2 NAT</h2><p>NAT（Network Address Translation）网络地址转换，就是在内网 IP 和公网 IP 之前相互转换。NAT 通常部署在一个组织的网络出口位置。</p><h3 id="2-2-1-什么是内部网络地址（内网-IP）？"><a href="#2-2-1-什么是内部网络地址（内网-IP）？" class="headerlink" title="2.2.1 什么是内部网络地址（内网 IP）？"></a>2.2.1 什么是内部网络地址（内网 IP）？</h3><p>RFC1918 规定了三个保留地址段落，这三个范围分别处于 A,B,C 类的地址段，不向特定的用户分配，被 IANA 作为私有地址保留。这些地址可以在任何组织或企业内部使用。和其他 IPv4 地址的区别就是，仅能在内部使用，不能作为全球路由地址。这就是说，出了组织的管理范围这些地址就不再有意义，无论是作为源地址，还是目的地址。对于一个封闭的组织，如果其网络不连接到外部 Internet，就可以使用这些地址而不用向 IANA 提出申请，而在内部的路由管理和报文传递方式与其他网络没有差异。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.0-10.255.255.255</span><br><span class="line">172.16.0.0-172.31.255.255</span><br><span class="line">192.168.0.0-192.168.255.255</span><br></pre></td></tr></tbody></table></figure><p>对于有 Internet 访问需求而内部又使用私有地址的网络，就要在组织的出口位置部署 NAT 网关，在报文离开私网进入 Internet 时，将源 IP 替换为公网地址，通常是出口设备的接口地址。一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应内容由 Internet 发回到出口网关。出口网关再将目的地址替换为私网的源主机地址，发回内部。这样一次由私网主机向公网服务端的请求和响应就在通信两端均无感知的情况下完成了。依据这种模型，数量庞大的内网主机就不再需要公有 IP 地址了。</p><h3 id="2-2-2-NAT-分类"><a href="#2-2-2-NAT-分类" class="headerlink" title="2.2.2 NAT 分类"></a>2.2.2 NAT 分类</h3><ul><li><p>全锥形 NAT（Full Cone NAT）<br>一旦内部<code>主机端口对</code>(iAddr:iPort)被 NAT 网关映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；<strong>任何一个外部主机</strong>发送到(eAddr:ePort)的报文将会被转换后发到(iAddr:iPort)。</p></li><li><p>限制锥形 NAT（Restricted Cone NAT）<br>一旦内部<code>主机端口对</code>(iAddr:iPort)被映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；只有 (iAddr:iPort)向特定的外部主机 hAddr 发送过数据，<strong>主机 hAddr 从任意端口</strong>发送到(eAddr:ePort)的报文将会被转发到(iAddr:iPort)。</p></li><li><p>端口限制锥形 NAT（Port Restricted Cone NAT）<br>一旦内部<code>主机端口对</code>(iAddr:iPort)被映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；只有(iAddr:iPort)向特定的外部<code>主机端口对</code>(hAddr:hPort)发送过数据，由 (hAddr:hPort)发送到(eAddr:ePort)的报文将会被转发到(iAddr:iPort)。</p></li><li><p>对称型 NAT（Symmetric NAT）<br>NAT 网关会把内部主机“地址端口对”和外部主机“地址端口对”完全相同的报文看作一个连接，在 NAT 网关上创建一个公网“地址端口对”映射进行转换，只有收到报文的外部主机从对应的端口对发送回应的报文，才能被转换。即使内部主机使用之前用过的地址端口对去连接不同外部主机(或端口)时，NAT 网关也会建立新的映射关系。</p></li></ul><h1 id="三、-NAT-穿越技术"><a href="#三、-NAT-穿越技术" class="headerlink" title="三、 NAT 穿越技术"></a>三、 NAT 穿越技术</h1><p>常见的 NAT 穿越技术有：STUN、TURN、ICE。</p><h2 id="3-1-STUN（Session-Traversal-Utileties-for-NAT）"><a href="#3-1-STUN（Session-Traversal-Utileties-for-NAT）" class="headerlink" title="3.1 STUN（Session Traversal Utileties for NAT）"></a>3.1 STUN（Session Traversal Utileties for NAT）</h2><p>在<a href="https://www.ietf.org/rfc/rfc3489.txt">RFC3489</a>和<a href="https://tools.ietf.org/rfc/rfc5389.txt">RFC5389</a>中的名称都是 STUN，但其全称是不同的。在 RFC3489 里，STUN 的全称是 Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)， 即穿越 NAT 的简单 UDP 传输，是一个轻量级的协议，允许应用程序发现自己和公网之间的中间件类型，同时也能允许应用程序发现自己被 NAT 分配的公网 IP。这个协议在 2003 年 3 月被提出，目前已经被 STUN/RFC5389 所替代。</p><p>但在 RFC5389 中，STUN 的全称变为 Session Traversal Utilities for NAT，即 NAT 环境下的会话传输工具，是一种处理 NAT 传输的协议，但主要作为一个工具来服务于其他协议。和 STUN/RFC3489 类似，可以被终端用来发现其公网 IP 和端口，同时可以检测端点间的连接性，也可以作为一种保活（keep-alive）协议来维持 NAT 的绑定。和 RFC3489 最大的不同点在于，STUN 本身不再是一个 完整的 NAT 传输解决方案，而是在 NAT 传输环境中作为一个辅助的解决方法，同时也增加了 TCP 的支持。RFC5389 废弃了 RFC3489，因此后者通常称为 classic STUN，但依旧是后向兼容的。STUN 是一种 Client/Server 的协议，也是一种 Request/Response 的协议，默认端口号是 3478。</p><p>STUN 完整的定义参考：<a href="https://tools.ietf.org/rfc/rfc5389.txt">RFC5398</a></p><h2 id="3-2-TURN（Traversal-Using-Relay-NAT）"><a href="#3-2-TURN（Traversal-Using-Relay-NAT）" class="headerlink" title="3.2 TURN（Traversal Using Relay NAT）"></a>3.2 TURN（Traversal Using Relay NAT）</h2><p>Traversal Using Relay NAT 即使用中继穿透 NAT，STUN 的中继扩展。简单的说，TURN 与 STUN 的共同点都是通过修改应用层中的私网地址达到 NAT 穿透的效果，异同点是 TURN 是通过两方通讯的“中间人”方式实现穿透。</p><p>TURN 完整的定义参考：<a href="https://tools.ietf.org/rfc/rfc5766.txt">RFC5766</a></p><h2 id="3-3-ICE（Interactive-Connectivity-Establishment）"><a href="#3-3-ICE（Interactive-Connectivity-Establishment）" class="headerlink" title="3.3 ICE（Interactive Connectivity Establishment）"></a>3.3 ICE（Interactive Connectivity Establishment）</h2><p>Interactive Connectivity Establishment 即互动式连接建立，由 IETF 的 MMUSIC 工作组开发出来的，它所提供的是一种框架，使各种 NAT 穿透技术可以实现统一。ICE 跟 STUN 和 TURN 不一样，ICE 不是一种协议，而是一个框架（Framework），它整合了 STUN 和 TURN。</p><p>ICE 完整的定义参考：<a href="https://tools.ietf.org/rfc/rfc5245.txt">RFC5245</a></p><blockquote><p>参考：<br><a href="http://www.52im.net/thread-50-1-1.html">P2P 技术详解(一)：NAT 详解——详细原理、P2P 简介</a> &gt; <a href="http://www.52im.net/thread-542-1-1.html">P2P 技术详解(二)：P2P 中的 NAT 穿越(打洞)方案详解</a> &gt; <a href="http://www.52im.net/thread-557-1-1.html">P2P 技术详解(三)：P2P 技术之 STUN、TURN、ICE 详解</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ⑤ 音视频编程 </category>
          
          <category> WebRTC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL获取时间和日期</title>
      <link href="/post/3556253141.html"/>
      <url>/post/3556253141.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、-时间、日期获取"><a href="#一、-时间、日期获取" class="headerlink" title="一、 时间、日期获取"></a>一、 时间、日期获取</h1><h2 id="1-1-获取当前本地的日期和时间"><a href="#1-1-获取当前本地的日期和时间" class="headerlink" title="1.1 获取当前本地的日期和时间"></a>1.1 获取当前本地的日期和时间</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  NOW(), </span><br><span class="line">  <span class="built_in">CURRENT_TIMESTAMP</span>(), </span><br><span class="line">  <span class="built_in">LOCALTIME</span>(), </span><br><span class="line">  <span class="built_in">LOCALTIMESTAMP</span>(),</span><br><span class="line">  SYSDATE();</span><br></pre></td></tr></tbody></table></figure><p>上面5个函数都可以获取当前本地时间，但SYSDATE有所不同。</p><span id="more"></span><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NOW(), SLEEP(<span class="number">3</span>), NOW();</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NOW()                 sleep(3)    NOW()</span><br><span class="line">2017-11-09 17:21:09     0        2017-11-09 17:21:09</span><br></pre></td></tr></tbody></table></figure><p>虽然sleep了3秒，但NOW()前后2次获取到时间是一样的，也就是说NOW()函数获取的时间是在整个SQL语句开始执行时的时间，无论SQL语句中有多少个NOW()函数，获取到的时间都是一样的。<br><code>CURRENT_TIMESTAMP()</code>, <code>LOCALTIME()</code>, <code>LOCALTIMESTAMP()</code>和NOW()函数一样。</p><p>但<code>SYSDATE</code>不同，它获取到的是SYSDATE()函数执行时的实时时间：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SYSDATE(), SLEEP(<span class="number">3</span>), SYSDATE();</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SYSDATE()           sleep(3)SYSDATE()</span><br><span class="line">2017-11-09 17:25:05   0        2017-11-09 17:25:08</span><br></pre></td></tr></tbody></table></figure><h2 id="1-2-获取当前本地的日期"><a href="#1-2-获取当前本地的日期" class="headerlink" title="1.2 获取当前本地的日期"></a>1.2 获取当前本地的日期</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  CURDATE(), </span><br><span class="line">  <span class="built_in">CURRENT_DATE</span>();</span><br></pre></td></tr></tbody></table></figure><h2 id="1-3-获取当前本地的时间"><a href="#1-3-获取当前本地的时间" class="headerlink" title="1.3 获取当前本地的时间"></a>1.3 获取当前本地的时间</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  CURTIME(), </span><br><span class="line">  <span class="built_in">CURRENT_TIME</span>();</span><br></pre></td></tr></tbody></table></figure><h2 id="1-4-获取当前UTC日期和时间"><a href="#1-4-获取当前UTC日期和时间" class="headerlink" title="1.4 获取当前UTC日期和时间"></a>1.4 获取当前UTC日期和时间</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  UTC_TIMESTAMP();</span><br></pre></td></tr></tbody></table></figure><h2 id="1-5-获取当前UTC日期"><a href="#1-5-获取当前UTC日期" class="headerlink" title="1.5 获取当前UTC日期"></a>1.5 获取当前UTC日期</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  UTC_DATE();</span><br></pre></td></tr></tbody></table></figure><h2 id="1-6-获取当前UTC时间"><a href="#1-6-获取当前UTC时间" class="headerlink" title="1.6 获取当前UTC时间"></a>1.6 获取当前UTC时间</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  UTC_TIME();</span><br></pre></td></tr></tbody></table></figure><h2 id="1-7-获取时间戳（自1970年经过的秒）"><a href="#1-7-获取时间戳（自1970年经过的秒）" class="headerlink" title="1.7 获取时间戳（自1970年经过的秒）"></a>1.7 获取时间戳（自1970年经过的秒）</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UNIX_TIMESTAMP();  <span class="comment">-- 当前时间时间戳</span></span><br><span class="line"><span class="keyword">SELECT</span> UNIX_TIMESTAMP(<span class="string">'2017-11-09 12:30:00'</span>);  <span class="comment">-- 自1970年到2017-11-09 12:30:00经过的秒数</span></span><br></pre></td></tr></tbody></table></figure><h1 id="二、-时间操作"><a href="#二、-时间操作" class="headerlink" title="二、 时间操作"></a>二、 时间操作</h1><h2 id="2-1-从字符串提取时间和日期"><a href="#2-1-从字符串提取时间和日期" class="headerlink" title="2.1 从字符串提取时间和日期"></a>2.1 从字符串提取时间和日期</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@dt</span> <span class="operator">=</span> <span class="string">'2008-09-10 07:15:30.123456'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">DATE</span>(<span class="variable">@dt</span>);        <span class="comment">-- 2008-09-10</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">TIME</span>(<span class="variable">@dt</span>);        <span class="comment">-- 07:15:30.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(<span class="variable">@dt</span>);        <span class="comment">-- 2008</span></span><br><span class="line"><span class="keyword">SELECT</span> QUARTER(<span class="variable">@dt</span>);     <span class="comment">-- 3</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(<span class="variable">@dt</span>);       <span class="comment">-- 9</span></span><br><span class="line"><span class="keyword">SELECT</span> WEEK(<span class="variable">@dt</span>);        <span class="comment">-- 36</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DAY</span>(<span class="variable">@dt</span>);         <span class="comment">-- 10</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">HOUR</span>(<span class="variable">@dt</span>);        <span class="comment">-- 7</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MINUTE</span>(<span class="variable">@dt</span>);      <span class="comment">-- 15</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SECOND</span>(<span class="variable">@dt</span>);      <span class="comment">-- 30</span></span><br><span class="line"><span class="keyword">SELECT</span> MICROSECOND(<span class="variable">@dt</span>); <span class="comment">-- 123456</span></span><br></pre></td></tr></tbody></table></figure><h2 id="2-2-获取某天在周、月、年中所处位置"><a href="#2-2-获取某天在周、月、年中所处位置" class="headerlink" title="2.2 获取某天在周、月、年中所处位置"></a>2.2 获取某天在周、月、年中所处位置</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@dt</span> <span class="operator">=</span> <span class="string">'2017-11-09'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> DAYOFWEEK(<span class="variable">@dt</span>);   <span class="comment">-- 5       星期日为0，5代表星期四</span></span><br><span class="line"><span class="keyword">SELECT</span> DAYOFMONTH(<span class="variable">@dt</span>);  <span class="comment">-- 9       一个月的第9天</span></span><br><span class="line"><span class="keyword">SELECT</span> DAYOFYEAR(<span class="variable">@dt</span>);   <span class="comment">-- 313     2017年的第313天</span></span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-获取指定日期的最后一天"><a href="#2-3-获取指定日期的最后一天" class="headerlink" title="2.3 获取指定日期的最后一天"></a>2.3 获取指定日期的最后一天</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LAST_DAY(<span class="string">'2017-02-05'</span>);   <span class="comment">-- 2017-02-28</span></span><br></pre></td></tr></tbody></table></figure><h2 id="2-4-时间加减"><a href="#2-4-时间加减" class="headerlink" title="2.4 时间加减"></a>2.4 时间加减</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@dt</span> <span class="operator">=</span> "2017-11-09 17:10:20.0000001";</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="variable">@dt</span>, <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>);        <span class="comment">-- 加1天</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="variable">@dt</span>, <span class="type">INTERVAL</span> <span class="number">2</span> <span class="keyword">HOUR</span>);       <span class="comment">-- 加2小时</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="variable">@dt</span>, <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MINUTE</span>);     <span class="comment">-- 加1分钟</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="variable">@dt</span>, <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">SECOND</span>);</span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="variable">@dt</span>, <span class="type">INTERVAL</span> <span class="number">1</span> MICROSECOND); <span class="comment">-- 加1微妙</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="variable">@dt</span>, <span class="type">INTERVAL</span> <span class="number">1</span> WEEK);        <span class="comment">-- 加1周</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="variable">@dt</span>, <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span>);</span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="variable">@dt</span>, <span class="type">INTERVAL</span> <span class="number">1</span> QUARTER);     <span class="comment">-- 加1个季度</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="variable">@dt</span>, <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">YEAR</span>);</span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="variable">@dt</span>, <span class="type">INTERVAL</span> <span class="number">-1</span> <span class="keyword">DAY</span>);       <span class="comment">-- 减1天</span></span><br></pre></td></tr></tbody></table></figure><h2 id="2-5-两个日期、时间加减"><a href="#2-5-两个日期、时间加减" class="headerlink" title="2.5 两个日期、时间加减"></a>2.5 两个日期、时间加减</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATEDIFF(<span class="string">'2008-08-08'</span>, <span class="string">'2008-08-01'</span>);  <span class="comment">-- 7</span></span><br><span class="line"><span class="keyword">SELECT</span> DATEDIFF(<span class="string">'2008-08-01'</span>, <span class="string">'2008-08-08'</span>);  <span class="comment">-- -7  第一个参数减去第二个参数</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TIMEDIFF(<span class="string">'2008-08-08 08:08:08'</span>, <span class="string">'2008-08-08 00:00:00'</span>);  <span class="comment">-- 08:08:08</span></span><br><span class="line"><span class="keyword">SELECT</span> TIMEDIFF(<span class="string">'00:00:00'</span>, <span class="string">'08:08:08'</span>);                        <span class="comment">-- -08:08:08</span></span><br></pre></td></tr></tbody></table></figure><h2 id="2-6-时间格式化"><a href="#2-6-时间格式化" class="headerlink" title="2.6 时间格式化"></a>2.6 时间格式化</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(<span class="string">'2008-08-08 22:23:00'</span>, <span class="string">'%W %M %Y'</span>);      <span class="comment">-- Friday August 2008</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(<span class="string">'2008-08-08 22:23:01'</span>, <span class="string">'%Y%m%d%H%i%s'</span>);  <span class="comment">-- 20080808222301</span></span><br><span class="line"><span class="keyword">SELECT</span> TIME_FORMAT(<span class="string">'22:23:01'</span>, <span class="string">'%H.%i.%s'</span>);                 <span class="comment">-- 22.23.01</span></span><br></pre></td></tr></tbody></table></figure><h1 id="2-7-秒计算"><a href="#2-7-秒计算" class="headerlink" title="2.7 秒计算"></a>2.7 秒计算</h1><p>计算指定时间折合多少秒，如00:01:00表示1分钟，等于60秒。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TIME_TO_SEC(<span class="string">'01:00:05'</span>);  <span class="comment">-- 3605</span></span><br><span class="line"><span class="keyword">SELECT</span> SEC_TO_TIME(<span class="number">3605</span>);        <span class="comment">-- '01:00:05'</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑨ 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL获取字符串长度的几种方式</title>
      <link href="/post/1446858454.html"/>
      <url>/post/1446858454.html</url>
      
        <content type="html"><![CDATA[<p>常用函数有<code>char_length</code>、<code>length</code>、<code>bit_length</code>，它们针对不同的字符编码处理方式不一样。<br>总的来说：<br><code>char_length</code>字符显示的个数；<br><code>length</code> 字符在当前编码下存储，所占的字节数。<br><code>bit_length</code> 字符在当前编码下存储，所占的bit，也就是<code>length</code>*8</p><span id="more"></span><h2 id="GBK-编码"><a href="#GBK-编码" class="headerlink" title="GBK 编码"></a>GBK 编码</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">char_length</span>(<span class="string">'中国'</span>);  <span class="comment">-- 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> length(<span class="string">'中国'</span>);  <span class="comment">-- 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> length(<span class="string">'china'</span>);  <span class="comment">-- 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> bit_length(<span class="string">'中国'</span>);  <span class="comment">--32</span></span><br></pre></td></tr></tbody></table></figure><h2 id="UTF-8-编码"><a href="#UTF-8-编码" class="headerlink" title="UTF-8 编码"></a>UTF-8 编码</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">char_length</span>(<span class="string">'中国'</span>); <span class="comment">-- 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> length(<span class="string">'中国'</span>);   <span class="comment">-- 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> length(<span class="string">'china'</span>);   <span class="comment">-- 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> bit_length(<span class="string">'中国'</span>);  <span class="comment">-- 48</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⑨ 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
