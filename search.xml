<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Windows注入与拦截(1)--DLL注入基础</title>
      <link href="/2023/06/25/windows-zhu-ru-yu-lan-jie-1-dll-zhu-ru-ji-chu/"/>
      <url>/2023/06/25/windows-zhu-ru-yu-lan-jie-1-dll-zhu-ru-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="一-DLL注入技术的用途"><a href="#一-DLL注入技术的用途" class="headerlink" title="一. DLL注入技术的用途"></a>一. DLL注入技术的用途</h2><p>从<a href="/2023/06/20/windows-nei-cun-ti-xi-1-xu-ni-di-zhi-kong-jian/" title="Windows内存体系(1)--虚拟地址空间">Windows内存体系(1)--虚拟地址空间</a>文章中我们可以知道，在Windows系统中，每个进程都有自己私有的地址空间。当我们用指针来引用内存的时候，指针的值表示的是进程自己的地址空间的一个虚拟的内存地址。<strong>进程不能通过指针来引用其他进程地址空间的内存。</strong>因此，如果一个进程有缺陷会导致其引用和覆盖随机地址处的内存，那么这个缺陷的影响就会不会扩散到其他的进程。</p><p>独立的地址空间有利于系统的稳定性。但很多时候我们还是需要跨越进程的边界来访问另一个进程地址空间，比如：</p><ul><li>我们要从另一个进程创建的窗口来派生子类窗口。比如附着在windows资源管理器上的一些小插件等。</li><li>我们需要假借其他进程之名做某些事情。</li><li>我们需要获取其他进程的更多详细信息，如加载了哪些dll等。</li><li>我们需要对其他进程的某些操作进程拦截。</li><li>干一些羞羞的事情…</li></ul><p>为了满足上面的这些需求，我们可以使用DLL注入的技术，将我们自己开发的dll注入到另一个进程的地址空间中，让dll中的代码在该进程的地址空间中执行，那么我们就可以在那个中进程为所欲为了。</p><h2 id="二-什么样的DLL可以被注入？"><a href="#二-什么样的DLL可以被注入？" class="headerlink" title="二. 什么样的DLL可以被注入？"></a>二. 什么样的DLL可以被注入？</h2><p>理论上任何DLL都可以被注入到其他进程之中，但是大多数情况下，我们注入到其他进程之中是为了实现某些功能、做某些事情的，所以我们需要在我们的DLL被注入之后，DLL中的功能代码能够被调用执行。</p><p>我们知道DLL被<strong>首次</strong>载入到进程中时，会收到<code>DLL_PROCESS_ATTACH</code>的通知，即调用<code>DllMain</code>函数，并且参数<code>fdwReason</code>的值被设为<code>DLL_PROCESS_ATTACH</code>。我们可以在收到<code>DLL_PROCESS_ATTACH</code>通知时开始我们的业务逻辑。</p><p>下面是一个最简单的dll的源码，在被注入成功后（即收到<code>DLL_PROCESS_ATTACH</code>通知时）弹出消息提示框：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved ) {    switch(fdwReason) {        case DLL_PROCESS_ATTACH:        {MessageBox(NULL, TEXT("我已经被注入啦"), TEXT("信息"), MB_ICONINFORMATION);            break;        }        case DLL_THREAD_ATTACH:        {            break;        }        case DLL_THREAD_DETACH:        {            break;        }        case DLL_PROCESS_DETACH:        {            break;        }    }    return TRUE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，如果<code>DLL_PROCESS_ATTACH</code>通知处理过程中的操作被挂起（如消息提示框）或者被阻塞（如用户创建了一个消息循环），这样就会导致目标进程中的<code>LoadLibrary(Ex)</code>函数一直无法返回（dll都是通过<code>LoadLibrary(Ex)</code>函数来加载的），所以我们一般会在<code>DLL_PROCESS_ATTACH</code>通知处理过程中创建一个子线程，将业务逻辑放置到该子线程中执行，代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;process.h&gt;unsigned int __stdcall PluginProc(LPVOID pArg) {MessageBox(NULL, TEXT("我已经被注入啦"), TEXT("信息"), MB_OK | MB_ICONASTERISK);return 0;}BOOL APIENTRY DllMain(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved) {HANDLE hThread = NULL;    switch(fdwReason) {        case DLL_PROCESS_ATTACH:        {hThread = (HANDLE)_beginthreadex(NULL, 0, PluginProc, NULL, 0, NULL);if (hThread) {CloseHandle(hThread); // 关闭句柄，防止句柄泄漏}            break;        }        case DLL_THREAD_ATTACH:        {            break;        }        case DLL_THREAD_DETACH:        {            break;        }        case DLL_PROCESS_DETACH:        {            break;        }    }    return TRUE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，当DLL被从目标进程卸载时，DLL会收到<code>DLL_PROCESS_DETACH</code>通知，我们需要在该通知的处理过程中做好最后的善后工作，防止资源泄漏、程序崩溃等问题出现。</p>]]></content>
      
      
      <categories>
          
          <category> Windows注入与拦截 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DLL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存池实现</title>
      <link href="/2023/06/25/c-nei-cun-chi-shi-xian/"/>
      <url>/2023/06/25/c-nei-cun-chi-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="一、为什么需要使用内存池"><a href="#一、为什么需要使用内存池" class="headerlink" title="一、为什么需要使用内存池"></a>一、为什么需要使用内存池</h1><p>在C/C++中我们通常使用<code>malloc</code>,<code>free</code>或<code>new</code>,<code>delete</code>来动态分配内存。<br>一方面，因为这些函数涉及到了系统调用，所以频繁的调用必然会导致程序性能的损耗；</p><p>另一方面，频繁的分配和释放小块内存会导致大量的内存碎片的产生，当碎片积累到一定的量之后，将无法分配到连续的内存空间，系统不得不进行碎片整理来满足分配到连续的空间，这样不仅会导致系统性能损耗，而且会导致程序对内存的利用率低下。</p><p>当然，如果我们的程序不需要频繁的分配和释放小块内存，那就没有使用内存池的必要，直接使用<code>malloc</code>,<code>free</code>或<code>new</code>,<code>delete</code>函数即可。</p><h1 id="二、内存池的实现方案"><a href="#二、内存池的实现方案" class="headerlink" title="二、内存池的实现方案"></a>二、内存池的实现方案</h1><p>内存池的实现原理大致如下：<br>提前申请一块大内存由内存池自己管理，并分成小片供给程序使用。程序使用完之后将内存归还到内存池中（并没有真正的从系统释放），当程序再次从内存池中请求内存时，内存池将池子中的可用内存片返回给程序使用。</p><p>我们在设计内存池的实现方案时，需要考虑到以下问题：</p><ol><li><p>内存池是否可以自动增长？<br>如果内存池的最大空间是固定的（也就是非自动增长），那么当内存池中的内存被请求完之后，程序就无法再次从内存池请求到内存。所以需要根据程序对内存的实际使用情况来确定是否需要自动增长。</p></li><li><p>内存池的总内存占用是否只增不减？<br>如果内存池是自动增长的，就涉及到了“内存池的总内存占用是否是只增不减”这个问题了。试想，程序从一个自动增长的内存池中请求了1000个大小为100KB的内存片，并在使用完之后全部归还给了内存池，而且假设程序之后的逻辑最多只需要10个100KB的内存片，该内存池中的900个100KB的内存片就一直处于闲置状态，程序内存占用就一直降下来。对内存占用大小有要求的程序需要考虑到这一点。</p></li><li><p>内存池中内存片的大小是否固定？<br>如果每次从内存池中的请求的内存片的大小如果不固定，那么内存池中的每个可用内存片的大小就不一致，程序再次请求内存片的时候，内存池就需要在“匹配最佳大小的内存片”和“匹配操作时间”上作出衡量。“最佳大小的内存片”虽然可以减少内存的浪费，但可能会导致“匹配时间”变长。</p></li><li><p>内存池是否是线程安全的？<br>是否允许在多个线程中同时从同一个内存池中请求和归还内存片？这个线程安全可以由内存池来实现，也可以由使用者来保证。</p></li><li><p>内存片分配出去之前和归还到内存池之后，其中的内容是否需要被清除？<br>程序可能出现将内存片归还给内存池之后，仍然使用内存片的地址指针进行内存读写操作，这样就会导致不可预期的结果。将内容清零只能尽量的（也不一定能）将问题抛出来，但并不能解决任何问题，而且将内容清零会消耗一定的CPU时间。所以，最终最好还是需要由内存池的使用者来保证这种安全性。</p></li><li><p>是否兼容<code>std::allocator</code>？<br>STL标准库中的大多类都支持用户提供一个自定义的内存分配器，默认使用的是<code>std::allocator</code>，如<code>std::string</code>：<br><code>typedef basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt; string;</code></p></li></ol><p>如果我们的内存池兼容std::allocator，那么我们就可以使用我们自己的内存池来替换默认的std::allocator分配器，如：<br><code>typedef basic_string&lt;char, char_traits&lt;char&gt;, MemoryPoll&lt;char&gt; &gt; mystring;</code></p><blockquote><p>关于如何兼容<code>std::allocator</code>，可以参考<a href="http://www.cplusplus.com/reference/memory/allocator/">http://www.cplusplus.com/reference/memory/allocator/</a></p></blockquote><h1 id="三、内存池的具体实现"><a href="#三、内存池的具体实现" class="headerlink" title="三、内存池的具体实现"></a>三、内存池的具体实现</h1><p>计划实现一个内存池管理的类<code>MemoryPool</code>，它具有如下特性：</p><ol><li>内存池的总大小自动增长。</li><li>内存池中内存片的大小固定。</li><li>支持线程安全。</li><li>在内存片被归还之后，清除其中的内容。</li><li>兼容<code>std::allocator</code>。</li></ol><p>因为内存池的内存片的大小是固定的，不涉及到需要匹配最合适大小的内存片，由于会频繁的进行插入、移除的操作，但查找比较少，故选用<code>链表</code>数据结构来管理内存池中的内存片。</p><p>MemoryPool中有2个链表，它们都是双向链表（设计成双向链表主要是为了在移除指定元素时，能够快速定位该元素的前后元素，从而在该元素被移除后，将其前后元素连接起来，保证链表的完整性）：</p><ol><li><code>data_element_</code> 记录以及分配出去的内存片。</li><li><code>free_element_</code> 记录未被分配出去的内存片。</li></ol><h2 id="3-1-MemoryPool实现代码"><a href="#3-1-MemoryPool实现代码" class="headerlink" title="3.1 MemoryPool实现代码"></a>3.1 <code>MemoryPool</code>实现代码</h2><p>下面是完整的内存池实现的代码，代码中使用了std::mutex等C++11才支持的特性，所以需要编译器最低支持C++11。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">/* MemoryPool.hpp */#ifndef MEMORY_POOL_H_#define MEMORY_POOL_H_#include &lt;climits&gt;#include &lt;cstddef&gt;#include &lt;mutex&gt;template &lt;typename T, size_t BlockSize = 4096, bool ZeroOnDeallocate = true&gt;class MemoryPool {public:    /* Member types */    typedef T               value_type;    typedef T*              pointer;    typedef T&amp;              reference;    typedef const T*        const_pointer;    typedef const T&amp;        const_reference;    typedef size_t          size_type;    typedef ptrdiff_t       difference_type;    typedef std::false_type propagate_on_container_copy_assignment;    typedef std::true_type  propagate_on_container_move_assignment;    typedef std::true_type  propagate_on_container_swap;    template &lt;typename U&gt; struct rebind {        typedef MemoryPool&lt;U&gt; other;    };    /* Member functions */    MemoryPool() noexcept;    MemoryPool(const MemoryPool&amp; memoryPool) noexcept;    MemoryPool(MemoryPool&amp;&amp; memoryPool) noexcept;    template &lt;class U&gt; MemoryPool(const MemoryPool&lt;U&gt;&amp; memoryPool) noexcept;    ~MemoryPool() noexcept;    MemoryPool&amp; operator=(const MemoryPool&amp; memoryPool) = delete;    MemoryPool&amp; operator=(MemoryPool&amp;&amp; memoryPool) noexcept;    pointer address(reference x) const noexcept;    const_pointer address(const_reference x) const noexcept;    // Can only allocate one object at a time. n and hint are ignored    pointer allocate(size_type n = 1, const_pointer hint = 0);    void deallocate(pointer p, size_type n = 1);    size_type max_size() const noexcept;    template &lt;class U, class... Args&gt; void construct(U* p, Args&amp;&amp;... args);    template &lt;class U&gt; void destroy(U* p);    template &lt;class... Args&gt; pointer newElement(Args&amp;&amp;... args);    void deleteElement(pointer p);private:    struct Element_ {        Element_* pre;        Element_* next;    };    typedef char* data_pointer;    typedef Element_ element_type;    typedef Element_* element_pointer;    element_pointer data_element_;    element_pointer free_element_;    std::recursive_mutex m_;    size_type padPointer(data_pointer p, size_type align) const noexcept;    void allocateBlock();    static_assert(BlockSize &gt;= 2 * sizeof(element_type), "BlockSize too small.");};template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::size_type    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::padPointer(data_pointer p, size_type align)    const noexcept {    uintptr_t result = reinterpret_cast&lt;uintptr_t&gt;(p);    return ((align - result) % align);}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::MemoryPool()    noexcept {    data_element_ = nullptr;    free_element_ = nullptr;}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::MemoryPool(const MemoryPool&amp; memoryPool)    noexcept :    MemoryPool() {}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::MemoryPool(MemoryPool&amp;&amp; memoryPool)    noexcept {    std::lock_guard&lt;std::recursive_mutex&gt; lock(m_);    data_element_ = memoryPool.data_element_;    memoryPool.data_element_ = nullptr;    free_element_ = memoryPool.free_element_;    memoryPool.free_element_ = nullptr;}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;template&lt;class U&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::MemoryPool(const MemoryPool&lt;U&gt;&amp; memoryPool)    noexcept :    MemoryPool() {}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;&amp;    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::operator=(MemoryPool&amp;&amp; memoryPool)    noexcept {    std::lock_guard&lt;std::recursive_mutex&gt; lock(m_);    if (this != &amp;memoryPool) {        std::swap(data_element_, memoryPool.data_element_);        std::swap(free_element_, memoryPool.free_element_);    }    return *this;}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::~MemoryPool()    noexcept {    std::lock_guard&lt;std::recursive_mutex&gt; lock(m_);    element_pointer curr = data_element_;    while (curr != nullptr) {        element_pointer prev = curr-&gt;next;        operator delete(reinterpret_cast&lt;void*&gt;(curr));        curr = prev;    }    curr = free_element_;    while (curr != nullptr) {        element_pointer prev = curr-&gt;next;        operator delete(reinterpret_cast&lt;void*&gt;(curr));        curr = prev;    }}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::pointer    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::address(reference x)    const noexcept {    return &amp;x;}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::const_pointer    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::address(const_reference x)    const noexcept {    return &amp;x;}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;void    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::allocateBlock() {    // Allocate space for the new block and store a pointer to the previous one    data_pointer new_block = reinterpret_cast&lt;data_pointer&gt; (operator new(BlockSize));    element_pointer new_ele_pointer = reinterpret_cast&lt;element_pointer&gt;(new_block);    new_ele_pointer-&gt;pre = nullptr;    new_ele_pointer-&gt;next = nullptr;    if (data_element_) {        data_element_-&gt;pre = new_ele_pointer;    }    new_ele_pointer-&gt;next = data_element_;    data_element_ = new_ele_pointer;}template &lt;typename T, size_t BlockSize,  bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::pointer    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::allocate(size_type n, const_pointer hint) {    std::lock_guard&lt;std::recursive_mutex&gt; lock(m_);    if (free_element_ != nullptr) {        data_pointer body =            reinterpret_cast&lt;data_pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(free_element_) + sizeof(element_type));        size_type bodyPadding = padPointer(body, alignof(element_type));        pointer result = reinterpret_cast&lt;pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(body + bodyPadding));        element_pointer tmp = free_element_;        free_element_ = free_element_-&gt;next;        if (free_element_)            free_element_-&gt;pre = nullptr;        tmp-&gt;next = data_element_;        if (data_element_)            data_element_-&gt;pre = tmp;        tmp-&gt;pre = nullptr;        data_element_ = tmp;        return result;    }    else {        allocateBlock();        data_pointer body =            reinterpret_cast&lt;data_pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(data_element_) + sizeof(element_type));        size_type bodyPadding = padPointer(body, alignof(element_type));        pointer result = reinterpret_cast&lt;pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(body + bodyPadding));        return result;    }}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline void    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::deallocate(pointer p, size_type n) {    std::lock_guard&lt;std::recursive_mutex&gt; lock(m_);    if (p != nullptr) {        element_pointer ele_p =            reinterpret_cast&lt;element_pointer&gt;(reinterpret_cast&lt;data_pointer&gt;(p) - sizeof(element_type));        if (ZeroOnDeallocate) {            memset(reinterpret_cast&lt;data_pointer&gt;(p), 0, BlockSize - sizeof(element_type));        }        if (ele_p-&gt;pre) {            ele_p-&gt;pre-&gt;next = ele_p-&gt;next;        }        if (ele_p-&gt;next) {            ele_p-&gt;next-&gt;pre = ele_p-&gt;pre;        }        if (ele_p-&gt;pre == nullptr) {            data_element_ = ele_p-&gt;next;        }        ele_p-&gt;pre = nullptr;        if (free_element_) {            ele_p-&gt;next = free_element_;            free_element_-&gt;pre = ele_p;        }        else {            ele_p-&gt;next = nullptr;        }        free_element_ = ele_p;    }}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::size_type    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::max_size()    const noexcept {    size_type maxBlocks = -1 / BlockSize;    return (BlockSize - sizeof(data_pointer)) / sizeof(element_type) * maxBlocks;}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;template &lt;class U, class... Args&gt;inline void    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::construct(U* p, Args&amp;&amp;... args) {    new (p) U(std::forward&lt;Args&gt;(args)...);}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;template &lt;class U&gt;inline void    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::destroy(U* p) {    p-&gt;~U();}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;template &lt;class... Args&gt;inline typename MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::pointer    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::newElement(Args&amp;&amp;... args) {    std::lock_guard&lt;std::recursive_mutex&gt; lock(m_);    pointer result = allocate();    construct&lt;value_type&gt;(result, std::forward&lt;Args&gt;(args)...);    return result;}template &lt;typename T, size_t BlockSize, bool ZeroOnDeallocate&gt;inline void    MemoryPool&lt;T, BlockSize, ZeroOnDeallocate&gt;::deleteElement(pointer p) {    std::lock_guard&lt;std::recursive_mutex&gt; lock(m_);    if (p != nullptr) {        p-&gt;~value_type();        deallocate(p);    }}#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-使用示例"><a href="#3-2-使用示例" class="headerlink" title="3.2 使用示例"></a>3.2 使用示例</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include "MemoryPool.hpp"#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;assert.h&gt;using namespace std;class Apple {public:    Apple() {        id_ = 0;        cout &lt;&lt; "Apple()" &lt;&lt; endl;    }    Apple(int id) {        id_ = id;        cout &lt;&lt; "Apple(" &lt;&lt; id_ &lt;&lt; ")" &lt;&lt; endl;    }    ~Apple() {        cout &lt;&lt; "~Apple()" &lt;&lt; endl;    }    void SetId(int id) {        id_ = id;    }    int GetId() {        return id_;    }private:    int id_;};void ThreadProc(MemoryPool&lt;char&gt; *mp) {    int i = 0;    while (i++ &lt; 100000) {        char* p0 = (char*)mp-&gt;allocate();        char* p1 = (char*)mp-&gt;allocate();        mp-&gt;deallocate(p0);        char* p2 = (char*)mp-&gt;allocate();        mp-&gt;deallocate(p1);                mp-&gt;deallocate(p2);    }}int main(){    MemoryPool&lt;char&gt; mp;    int i = 0;    while (i++ &lt; 100000) {        char* p0 = (char*)mp.allocate();        char* p1 = (char*)mp.allocate();        mp.deallocate(p0);        char* p2 = (char*)mp.allocate();        mp.deallocate(p1);        mp.deallocate(p2);    }    std::thread th0(ThreadProc, &amp;mp);    std::thread th1(ThreadProc, &amp;mp);    std::thread th2(ThreadProc, &amp;mp);    th0.join();    th1.join();    th2.join();    Apple* apple = nullptr;    MemoryPool&lt;Apple&gt; mp2;    apple = mp2.newElement(10);    assert(apple);    int a = apple-&gt;GetId(); // 10    assert(a == 10);    apple-&gt;SetId(12);    mp2.deleteElement(apple);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++生成条形码</title>
      <link href="/2023/06/25/c-sheng-cheng-tiao-xing-ma/"/>
      <url>/2023/06/25/c-sheng-cheng-tiao-xing-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="一、条形码介绍"><a href="#一、条形码介绍" class="headerlink" title="一、条形码介绍"></a>一、条形码介绍</h1><p>条形码(<code>barcode</code>)是将宽度不等的多个黑条和空白，按照一定的编码规则排列，用以表达一组信息的图形标识符。常见的条形码是由反射率相差很大的黑条（简称条）和白条（简称空）排成的平行线图案。</p><p><strong>条码种类很多，常见的大概有二十多种码制，其中包括：</strong><br>Code39码（标准39码）、Codabar码（库德巴码）、Code25码（标准25码）、ITF25码（交叉25码）、Matrix25码（矩阵25码）、UPC-A码、UPC-E码、EAN-13码（EAN-13国际商品条码）、EAN-8码（EAN-8国际商品条码）、中国邮政码（矩阵25码的一种变体）、Code-B码、MSI码、Code11码、Code93码、ISBN码、ISSN码、Code128码（Code128码，包括EAN128码）、Code39EMS（EMS专用的39码）等一维条码和PDF417等二维条码。</p><p><strong>目前，国际广泛使用的条码种类有：</strong></p><ul><li>EAN码 —— 国际物品编码协会制定的一种商品用条码，通用于全世界。EAN码符号有标准版（EAN-13）和缩短版（EAN-8）两种，我国的通用商品条码与其等效，日常购买的商品包装上所印的条码一般就是EAN码。</li><li>UPC码 —— UPC码是美国统一代码委员会制定的一种商品用条码，主要用于美国和加拿大地区，我们在美国进口的商品上可以看到。</li><li>Code39码 —— 因其可采用数字与字母共同组成的方式而在各行业内部管理上被广泛使用。</li><li>Code93码 —— Code 93码与39码具有相同的字符集，但它的密度要比39码高，所以在面积不足的情况下，可以用93码代替39码</li><li>Codebar码 —— 可表示数字0 - 9，字符$、+、 -、还有只能用作起始/终止符的a,b,c d四个字符，可变长度，没有校验位，多用于血库,图书馆和照像馆的业务中。</li><li>Code128码 —— 128可表示ASCII 0 到 ASCII 127 共计128个ASCII字符。</li><li>CodeI2of5码 —— 只能表示数字0 -9 可变长度，连续性条形码，所有条与空都表示代码，第一个数字由条开始，第二个数字由空组成，空白区比窄条宽10倍，应用于商品批发、仓库、机场、生产/包装识别、工业中，条形码的识读率高，可适用于固定扫描器可靠扫描，在所有一维条形码中的密度最高。</li></ul><h1 id="二、C-方式实现"><a href="#二、C-方式实现" class="headerlink" title="二、C++方式实现"></a>二、C++方式实现</h1><p><strong><code>barcode.h</code></strong> 中实现了Code39、Code93、Code128、CodeI2of5等4种格式的条形码的生成。<br>具体使用方法：调用对应类的<code>DrawBarcode</code>函数将条形码绘制到HDC上，绘制到HDC上之后可以保存为图片或者显示到界面。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef BARCODE_H_#define BARCODE_H_#pragma onceclass Barcode39;class Barcode93;class BarcodeIof5;class Barcode128;static const int ga2_Code128[2][207] ={    {        64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,        80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,        0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,        16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,        32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,        48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106,    },    {        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,        16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,        32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,        48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,        64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,        80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,        -1,  -1,  -1,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106,    },};class BarcodeBase {public:    BarcodeBase() {        Clear();        i_Ratio = 3;    }    void operator=(const BarcodeBase&amp;bc) {        i_LenBuf = bc.i_LenBuf;        i_Ratio = bc.i_Ratio;        memcpy(ia_Buf, bc.ia_Buf, sizeof(ia_Buf));    }    void Clear() {        memset(ia_Buf, 0, sizeof(ia_Buf));        i_LenBuf = 0;    }    int GetEncodeLength()const {        BYTE*pb = (BYTE*)ia_Buf;        int i, iLen = 0;        for (i = 0; i &lt; i_LenBuf; i++) {            //wide is 3            if (*pb &amp; 2)iLen += (i_Ratio - 1);            pb++;        }        return iLen + i_LenBuf;    }    int GetBufferLength()const {        return i_LenBuf;    }    const BYTE&amp;GetAt(int i)const {        return ia_Buf[i];    }    int GetRatio()const {        return i_Ratio;    }    int SetRatio(int iRatio) {        i_Ratio = iRatio;        if (i_Ratio &lt;= 0)i_Ratio = 1;    }    void DrawBarcode(HDC hDC, int iX, int iY0, int iY10, int iY11, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) {        HPEN hPenBar = ::CreatePen(PS_SOLID, iPenW, clrBar);        HPEN hPenSpace = ::CreatePen(PS_SOLID, iPenW, clrSpace);        HPEN hPenOld = (HPEN)::SelectObject(hDC, hPenBar);        BYTE*pb = ia_Buf;        int i0, iNum0 = i_LenBuf;        BYTE bBar;        int i1, iNum1;        int iY;        for (i0 = 0; i0 &lt; iNum0; i0++) {            bBar = *pb &amp; 0x01;            iNum1 = (*pb &amp; 0x02) ? i_Ratio : 1;            iY = (*pb &amp; 0x04) ? iY11 : iY10;            for (i1 = 0; i1 &lt; iNum1; i1++) {                if (bBar)::SelectObject(hDC, hPenBar);                else::SelectObject(hDC, hPenSpace);                ::MoveToEx(hDC, iX, iY0, 0);                ::LineTo(hDC, iX, iY);                iX += iPenW;            }            pb++;        }        ::SelectObject(hDC, hPenOld);        ::DeleteObject(hPenBar);        ::DeleteObject(hPenSpace);    }protected:    BYTEia_Buf[4096];    inti_LenBuf;    inti_Ratio;    struct IntString {        int ch;        char*psz;    };};class Barcode39 : public BarcodeBase {    //[n/a][n/a][n/a][n/a][n/a][n/a][w-n][b-s]public:    Barcode39() {    }    ~Barcode39() {    }    BOOL Encode39(const char*pszCodeIn) {        int iLen = strlen(pszCodeIn);        char*pszCode = new char[iLen + 3];        sprintf(pszCode, "*%s*", pszCodeIn);        strupr(pszCode);        BYTE*pFst = ia_Buf;        BYTE*p0 = pFst, *p1;        iLen += 2;        int i;        for (i = 0; i &lt; iLen; i++) {            p1 = P_GetNarrowWideBarSpace39(pszCode[i], p0);            if (p1 == 0)return 0;            p0 = p1;        }        i_LenBuf = p1 - pFst;        delete[]pszCode;        return 1;    }    void Draw39(HDC hDC, int iX, int iY0, int iY1, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) {        DrawBarcode(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW);    }private:    BYTE*P_GetNarrowWideBarSpace39(char ch, BYTE*pb) {        IntString infs[] =        {            {'1',"wnnwnnnnwn"},            {'2',"nnwwnnnnwn"},            {'3',"wnwwnnnnnn"},            {'4',"nnnwwnnnwn"},            {'5',"wnnwwnnnnn"},            {'6',"nnwwwnnnnn"},            {'7',"nnnwnnwnwn"},            {'8',"wnnwnnwnnn"},            {'9',"nnwwnnwnnn"},            {'0',"nnnwwnwnnn"},            {'A',"wnnnnwnnwn"},            {'B',"nnwnnwnnwn"},            {'C',"wnwnnwnnnn"},            {'D',"nnnnwwnnwn"},            {'E',"wnnnwwnnnn"},            {'F',"nnwnwwnnnn"},            {'G',"nnnnnwwnwn"},            {'H',"wnnnnwwnnn"},            {'I',"nnwnnwwnnn"},            {'J',"nnnnwwwnnn"},            {'K',"wnnnnnnwwn"},            {'L',"nnwnnnnwwn"},            {'M',"wnwnnnnwnn"},            {'N',"nnnnwnnwwn"},            {'O',"wnnnwnnwnn"},            {'P',"nnwnwnnwnn"},            {'Q',"nnnnnnwwwn"},            {'R',"wnnnnnwwnn"},            {'S',"nnwnnnwwnn"},            {'T',"nnnnwnwwnn"},            {'U',"wwnnnnnnwn"},            {'V',"nwwnnnnnwn"},            {'W',"wwwnnnnnnn"},            {'X',"nwnnwnnnwn"},            {'Y',"wwnnwnnnnn"},            {'Z',"nwwnwnnnnn"},            {'-',"nwnnnnwnwn"},            {'.',"wwnnnnwnnn"},            {' ',"nwwnnnwnnn"},            {'*',"nwnnwnwnnn"},            {'$',"nwnwnwnnnn"},            {'/',"nwnwnnnwnn"},            {'+',"nwnnnwnwnn"},            {'%',"nnnwnwnwnn"},        };        int i0, iNum0 = sizeof(infs) / sizeof(infs[0]);        int i1;        for (i0 = 0; i0 &lt; iNum0; i0++) {            IntString&amp;inf = infs[i0];            if (inf.ch == ch) {                for (i1 = 0; i1 &lt; 10; i1++) {                    if (inf.psz[i1] == 'w')*pb += 2;                    if (i1 % 2 == 0)*pb += 1;                    pb++;                }                return pb;            }        }        return 0;    }};class BarcodeI2of5 :public BarcodeBase {    //[n/a][n/a][n/a][n/a][n/a][n/a][w-n][b-s]public:    BarcodeI2of5() {    }    ~BarcodeI2of5() {    }    BOOL EncodeI2of5(const char*pszCode) {        Clear();        BYTE*pFst = ia_Buf;        BYTE*pb = pFst;        const int iNum = strlen(pszCode);        int i;        //"nnnn"        for (i = 0; i &lt; 4; i++) {            if (i % 2 == 0)*pb += 1;            pb++;        }        int iV;        for (i = 0; i &lt; iNum; i += 2) {            iV = pszCode[i] - '0';            iV = iV * 10;            iV += pszCode[i + 1] - '0';            pb = P_GetNarrorWideBarSpaceI2of5(pb, iV);            if (pb == 0)return 0;        }        //"wnn"        *pb += 3;pb++;        *pb += 0;pb++;        *pb += 1;pb++;        i_LenBuf = pb - pFst;        return 1;    }    void DrawI2of5(HDC hDC, int iX, int iY0, int iY1, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) {        DrawBarcode(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW);    }private:    BYTE*P_GetNarrorWideBarSpaceI2of5(BYTE*pb, int ch) {        if (ch &lt; 0)return 0;        if (ch &gt; 99)return 0;        IntString infs[] =        {            {0,"nnnnwwwwnn"},            {1,"nwnnwnwnnw"},            {2,"nnnwwnwnnw"},            {3,"nwnwwnwnnn"},            {4,"nnnnwwwnnw"},            {5,"nwnnwwwnnn"},            {6,"nnnwwwwnnn"},            {7,"nnnnwnwwnw"},            {8,"nwnnwnwwnn"},            {9,"nnnwwnwwnn"},            {10,"wnnnnwnwwn"},            {11,"wwnnnnnnww"},            {12,"wnnwnnnnww"},            {13,"wwnwnnnnwn"},            {14,"wnnnnwnnww"},            {15,"wwnnnwnnwn"},            {16,"wnnwnwnnwn"},            {17,"wnnnnnnwww"},            {18,"wwnnnnnwwn"},            {19,"wnnwnnnwwn"},            {20,"nnwnnwnwwn"},            {21,"nwwnnnnnww"},            {22,"nnwwnnnnww"},            {23,"nwwwnnnnwn"},            {24,"nnwnnwnnww"},            {25,"nwwnnwnnwn"},            {26,"nnwwnwnnwn"},            {27,"nnwnnnnwww"},            {28,"nwwnnnnwwn"},            {29,"nnwwnnnwwn"},            {30,"wnwnnwnwnn"},            {31,"wwwnnnnnnw"},            {32,"wnwwnnnnnw"},            {33,"wwwwnnnnnn"},            {34,"wnwnnwnnnw"},            {35,"wwwnnwnnnn"},            {36,"wnwwnwnnnn"},            {37,"wnwnnnnwnw"},            {38,"wwwnnnnwnn"},            {39,"wnwwnnnwnn"},            {40,"nnnnwwnwwn"},            {41,"nwnnwnnnww"},            {42,"nnnwwnnnww"},            {43,"nwnwwnnnwn"},            {44,"nnnnwwnnww"},            {45,"nwnnwwnnwn"},            {46,"nnnwwwnnwn"},            {47,"nnnnwnnwww"},            {48,"nwnnwnnwwn"},            {49,"nnnwwnnwwn"},            {50,"wnnnwwnwnn"},            {51,"wwnnwnnnnw"},            {52,"wnnwwnnnnw"},            {53,"wwnwwnnnnn"},            {54,"wnnnwwnnnw"},            {55,"wwnnwwnnnn"},            {56,"wnnwwwnnnn"},            {57,"wnnnwnnwnw"},            {58,"wwnnwnnwnn"},            {59,"wnnwwnnwnn"},            {60,"nnwnwwnwnn"},            {61,"nwwnwnnnnw"},            {62,"nnwwwnnnnw"},            {63,"nwwwwnnnnn"},            {64,"nnwnwwnnnw"},            {65,"nwwnwwnnnn"},            {66,"nnwwwwnnnn"},            {67,"nnwnwnnwnw"},            {68,"nwwnwnnwnn"},            {69,"nnwwwnnwnn"},            {70,"nnnnnwwwwn"},            {71,"nwnnnnwnww"},            {72,"nnnwnnwnww"},            {73,"nwnwnnwnwn"},            {74,"nnnnnwwnww"},            {75,"nwnnnwwnwn"},            {76,"nnnwnwwnwn"},            {77,"nnnnnnwwww"},            {78,"nwnnnnwwwn"},            {79,"nnnwnnwwwn"},            {80,"wnnnnwwwnn"},            {81,"wwnnnnwnnw"},            {82,"wnnwnnwnnw"},            {83,"wwnwnnwnnn"},            {84,"wnnnnwwnnw"},            {85,"wwnnnwwnnn"},            {86,"wnnwnwwnnn"},            {87,"wnnnnnwwnw"},            {88,"wwnnnnwwnn"},            {89,"wnnwnnwwnn"},            {90,"nnwnnwwwnn"},            {91,"nwwnnnwnnw"},            {92,"nnwwnnwnnw"},            {93,"nwwwnnwnnn"},            {94,"nnwnnwwnnw"},            {95,"nwwnnwwnnn"},            {96,"nnwwnwwnnn"},            {97,"nnwnnnwwnw"},            {98,"nwwnnnwwnn"},            {99,"nnwwnnwwnn"},        };        IntString&amp;inf = infs[ch];        int i;        for (i = 0; i &lt; 10; i++) {            if (inf.psz[i] == 'w')*pb += 2;            if (i % 2 == 0)*pb += 1;            pb++;        }        return pb;    }};class Barcode93 :public BarcodeBase {    //[n/a][n/a][n/a][n/a][n/a][n/a][n/a][b-s]public:    Barcode93() {    }    ~Barcode93() {    }    BOOL Encode93(const char* pszCode) {        Clear();        const int iNum = strlen(pszCode);        BYTE*pFst = ia_Buf;        BYTE*pb = pFst;        pb = P_GetBarSpace93(pb, 47);        if (pb == 0)return 0;        BOOL b;        int i, iFirst, iSecond;        for (i = 0; i &lt; iNum; i++) {            b = P_AscIItoCode93Sequence((int)pszCode[i], iFirst, iSecond);            if (b == 0)return 0;            pb = P_GetBarSpace93(pb, iFirst);            if (pb == 0)return 0;            if (iSecond != -1) {                pb = P_GetBarSpace93(pb, iSecond);                if (pb == 0)return 0;            }        }        pb = P_GetCheckDigits(pb, pszCode);        if (pb == 0)return 0;        pb = P_GetBarSpace93(pb, 48);        if (pb == 0)return 0;        i_LenBuf = pb - pFst;        return 1;    }    void Draw93(HDC hDC, int iX, int iY0, int iY1, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) {        DrawBarcode(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW);    }private:    BYTE*P_GetBarSpace93(BYTE*pb, int ch) {        if (ch &lt; 0)return 0;        if (ch &gt; 48)return 0;        IntString infs[] =        {            {0,"bsssbsbss"},            {1,"bsbssbsss"},            {2,"bsbsssbss"},            {3,"bsbssssbs"},            {4,"bssbsbsss"},            {5,"bssbssbss"},            {6,"bssbsssbs"},            {7,"bsbsbssss"},            {8,"bsssbssbs"},            {9,"bssssbsbs"},            {10,"bbsbsbsss"},            {11,"bbsbssbss"},            {12,"bbsbsssbs"},            {13,"bbssbsbss"},            {14,"bbssbssbs"},            {15,"bbsssbsbs"},            {16,"bsbbsbsss"},            {17,"bsbbssbss"},            {18,"bsbbsssbs"},            {19,"bssbbsbss"},            {20,"bsssbbsbs"},            {21,"bsbsbbsss"},            {22,"bsbssbbss"},            {23,"bsbsssbbs"},            {24,"bssbsbbss"},            {25,"bsssbsbbs"},            {26,"bbsbbsbss"},            {27,"bbsbbssbs"},            {28,"bbsbsbbss"},            {29,"bbsbssbbs"},            {30,"bbssbsbbs"},            {31,"bbssbbsbs"},            {32,"bsbbsbbss"},            {33,"bsbbssbbs"},            {34,"bssbbsbbs"},            {35,"bssbbbsbs"},            {36,"bssbsbbbs"},            {37,"bbbsbsbss"},            {38,"bbbsbssbs"},            {39,"bbbssbsbs"},            {40,"bsbbsbbbs"},            {41,"bsbbbsbbs"},            {42,"bbsbsbbbs"},            {43,"bssbssbbs"},            {44,"bbbsbbsbs"},            {45,"bbbsbsbbs"},            {46,"bssbbssbs"},            {47,"bsbsbbbbs"},            {48,"bsbsbbbbsb"},        };        IntString&amp;inf = infs[ch];        int i;        for (i = 0; i &lt; 9; i++) {            if (inf.psz[i] == 'b')*pb += 1;            pb++;        }        if (ch == 48) {            *pb += 1;            pb++;        }        return pb;    }private:    BYTE*P_GetCheckDigits(BYTE*pb, const char*&amp;pszCode) {        int i, iSum, iWeight, iFirst, iSecond;        // "C" check digit character        iWeight = 1;        iSum = 0;        const int iNum = strlen(pszCode);        for (i = iNum - 1; i &gt; -1; i--) {            P_AscIItoCode93Sequence((int)pszCode[i], iFirst, iSecond);            iSum += (iWeight*iFirst);            iWeight++;            if (iWeight &gt; 20)iWeight = 1;            if (iSecond != -1) {                iSum += (iWeight*iSecond);                iWeight++;                if (iWeight &gt; 20)iWeight = 1;            }        }        pb = P_GetBarSpace93(pb, iSum % 47);        if (pb == 0)return 0;        iWeight = 2;        iSum = iSum % 47;        for (i = iNum - 1; i &gt; -1; i--) {            P_AscIItoCode93Sequence((int)pszCode[i], iFirst, iSecond);            iSum += (iWeight * iFirst);            iWeight++;            if (iWeight &gt; 15)iWeight = 1;            if (iSecond != -1) {                iSum += (iWeight * iSecond);                iWeight++;                if (iWeight &gt; 15)iWeight = 1;            }        }        pb = P_GetBarSpace93(pb, iSum % 47);        if (pb == 0)return 0;        return pb;    }    BOOL P_AscIItoCode93Sequence(int iValue, int&amp;iFirst, int&amp;iSecond) {        if (iValue &lt; 0)return 0;        if (iValue &gt; 127)return 0;        structI3 { int iV, iFirst, iSecond; };        I3 i3s[] =        {            {0,44,30},            {1,43,10},            {2,43,11},            {3,43,12},            {4,43,13},            {5,43,14},            {6,43,15},            {7,43,16},            {8,43,17},            {9,43,18},            {10,43,19},            {11,43,20},            {12,43,21},            {13,43,22},            {14,43,23},            {15,43,24},            {16,43,25},            {17,43,26},            {18,43,27},            {19,43,28},            {20,43,29},            {21,43,30},            {22,43,31},            {23,43,32},            {24,43,33},            {25,43,34},            {26,43,35},            {27,44,10},            {28,44,11},            {29,44,12},            {30,44,13},            {31,44,14},            {32,38,-1},            {33,45,10},            {34,45,11},            {35,45,12},            {36,39,-1},            {37,42,-1},            {38,45,15},            {39,45,16},            {40,45,17},            {41,45,18},            {42,45,19},            {43,41,-1},            {44,45,21},            {45,36,-1},            {46,37,-1},            {47,40,-1},            {48,0,-1},            {49,1,-1},            {50,2,-1},            {51,3,-1},            {52,4,-1},            {53,5,-1},            {54,6,-1},            {55,7,-1},            {56,8,-1},            {57,9,-1},            {58,45,35},            {59,44,15},            {60,44,16},            {61,44,17},            {62,44,18},            {63,44,19},            {64,44,31},            {65,10,-1},            {66,11,-1},            {67,12,-1},            {68,13,-1},            {69,14,-1},            {70,15,-1},            {71,16,-1},            {72,17,-1},            {73,18,-1},            {74,19,-1},            {75,20,-1},            {76,21,-1},            {77,22,-1},            {78,23,-1},            {79,24,-1},            {80,25,-1},            {81,26,-1},            {82,27,-1},            {83,28,-1},            {84,29,-1},            {85,30,-1},            {86,31,-1},            {87,32,-1},            {88,33,-1},            {89,34,-1},            {90,35,-1},            {91,44,20},            {92,44,21},            {93,44,22},            {94,44,23},            {95,44,24},            {96,44,32},            {97,46,10},            {98,46,11},            {99,46,12},            {100,46,13},            {101,46,14},            {102,46,15},            {103,46,16},            {104,46,17},            {105,46,18},            {106,46,19},            {107,46,20},            {108,46,21},            {109,46,22},            {110,46,23},            {111,46,24},            {112,46,25},            {113,46,26},            {114,46,27},            {115,46,28},            {116,46,29},            {117,46,30},            {118,46,31},            {119,46,32},            {120,46,33},            {121,46,34},            {122,46,35},            {123,44,25},            {124,44,26},            {125,44,27},            {126,44,28},            {127,44,29},        };        I3&amp;i3 = i3s[iValue];        iFirst = i3.iFirst;        iSecond = i3.iSecond;        return 1;    }};class Barcode128 :public BarcodeBase {public:    Barcode128() {    }    ~Barcode128() {    }    BOOL Encode128A(const char* pszCode) { return P_Encode128((char*)pszCode, SUB::SETA); }    BOOL Encode128B(const char* pszCode) { return P_Encode128((char*)pszCode, SUB::SETB); }    BOOL Encode128C(const char* pszCode) { return P_Encode128((char*)pszCode, SUB::SETC); }    void Draw128(HDC hDC, int iX, int iY0, int iY1, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) {        DrawBarcode(hDC, iX, iY0, iY1, iY1, clrBar, clrSpace, iPenW);    }private:    struct SUB {        enum {            SETA = 0,            SETB = 1,            SETC = 2,        };    };    BOOL P_Encode128(char*pszCode, const int iSetIn) {        Clear();        BYTE*pFst = ia_Buf;        BYTE*pb = pFst;        if (iSetIn == SUB::SETA)pb = P_GetBarSpace128(pb, 103);        else            if (iSetIn == SUB::SETB)pb = P_GetBarSpace128(pb, 104);            elsepb = P_GetBarSpace128(pb, 105);            if (pb == 0)return 0;            const int iCheckDigit = GetCheckDigit(iSetIn, pszCode);            const int iNum = strlen(pszCode);            int iChar, iCharNext;            int iPosition = 0;            int iSet = iSetIn;            while (iPosition &lt; iNum) {                if (iSet == SUB::SETC) {                    if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 101) {                        pb = P_GetBarSpace128(pb, 101);                        iPosition++;                        iSet = SUB::SETA;                    }                    else                        if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 100) {                            pb = P_GetBarSpace128(pb, 100);                            iPosition++;                            iSet = SUB::SETB;                        }                        else if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 102) {                            pb = P_GetBarSpace128(pb, 100);                            iPosition++;                        }                        else {                            char chT = pszCode[iPosition + 2];                            pszCode[iPosition + 2] = 0;                            iChar = atoi(&amp;pszCode[iPosition]);                            pszCode[iPosition + 2] = chT;                            pb = P_GetBarSpace128(pb, iChar);                            if (pb == 0)return 0;                            iPosition += 2;                        }                }                else {                    int iTemp2 = pszCode[iPosition];                    if (iTemp2 &lt; -1)iTemp2 = iTemp2 &amp; 255;                    iChar = ga2_Code128[iSet][iTemp2];                    pb = P_GetBarSpace128(pb, iChar);                    if (pb == 0)return 0;                    iPosition++;                    if (iSet == SUB::SETA) {                        if (iChar == 100)iSet = SUB::SETB;                        else                            if (iChar == 99)iSet = SUB::SETC;                    }                    else if (iSet == SUB::SETB) {                        if (iChar == 101)iSet = SUB::SETA;                        else                            if (iChar == 99)iSet = SUB::SETC;                    }                    else                        if (iChar == 98) {                            if (iSet == SUB::SETA)                                iCharNext = ga2_Code128[SUB::SETB][pszCode[iPosition]];                            else                                iCharNext = ga2_Code128[SUB::SETA][pszCode[iPosition]];                            pb = P_GetBarSpace128(pb, iChar);                            if (pb == 0)return 0;                            iPosition++;                        }                }            }            pb = P_GetBarSpace128(pb, iCheckDigit);            if (pb == 0)return 0;            pb = P_GetBarSpace128(pb, 106);            i_LenBuf = pb - pFst;            return 1;    }    BYTE*P_GetBarSpace128(BYTE*pb, int iV) {        if (iV &lt; 0)return 0;        if (iV &gt; 106)return 0;        IntString infs[] =        {            {0,"bbsbbssbbss"},            {1,"bbssbbsbbss"},            {2,"bbssbbssbbs"},            {3,"bssbssbbsss"},            {4,"bssbsssbbss"},            {5,"bsssbssbbss"},            {6,"bssbbssbsss"},            {7,"bssbbsssbss"},            {8,"bsssbbssbss"},            {9,"bbssbssbsss"},            {10,"bbssbsssbss"},            {11,"bbsssbssbss"},            {12,"bsbbssbbbss"},            {13,"bssbbsbbbss"},            {14,"bssbbssbbbs"},            {15,"bsbbbssbbss"},            {16,"bssbbbsbbss"},            {17,"bssbbbssbbs"},            {18,"bbssbbbssbs"},            {19,"bbssbsbbbss"},            {20,"bbssbssbbbs"},            {21,"bbsbbbssbss"},            {22,"bbssbbbsbss"},            {23,"bbbsbbsbbbs"},            {24,"bbbsbssbbss"},            {25,"bbbssbsbbss"},            {26,"bbbssbssbbs"},            {27,"bbbsbbssbss"},            {28,"bbbssbbsbss"},            {29,"bbbssbbssbs"},            {30,"bbsbbsbbsss"},            {31,"bbsbbsssbbs"},            {32,"bbsssbbsbbs"},            {33,"bsbsssbbsss"},            {34,"bsssbsbbsss"},            {35,"bsssbsssbbs"},            {36,"bsbbsssbsss"},            {37,"bsssbbsbsss"},            {38,"bsssbbsssbs"},            {39,"bbsbsssbsss"},            {40,"bbsssbsbsss"},            {41,"bbsssbsssbs"},            {42,"bsbbsbbbsss"},            {43,"bsbbsssbbbs"},            {44,"bsssbbsbbbs"},            {45,"bsbbbsbbsss"},            {46,"bsbbbsssbbs"},            {47,"bsssbbbsbbs"},            {48,"bbbsbbbsbbs"},            {49,"bbsbsssbbbs"},            {50,"bbsssbsbbbs"},            {51,"bbsbbbsbsss"},            {52,"bbsbbbsssbs"},            {53,"bbsbbbsbbbs"},            {54,"bbbsbsbbsss"},            {55,"bbbsbsssbbs"},            {56,"bbbsssbsbbs"},            {57,"bbbsbbsbsss"},            {58,"bbbsbbsssbs"},            {59,"bbbsssbbsbs"},            {60,"bbbsbbbbsbs"},            {61,"bbssbssssbs"},            {62,"bbbbsssbsbs"},            {63,"bsbssbbssss"},            {64,"bsbssssbbss"},            {65,"bssbsbbssss"},            {66,"bssbssssbbs"},            {67,"bssssbsbbss"},            {68,"bssssbssbbs"},            {69,"bsbbssbssss"},            {70,"bsbbssssbss"},            {71,"bssbbsbssss"},            {72,"bssbbssssbs"},            {73,"bssssbbsbss"},            {74,"bssssbbssbs"},            {75,"bbssssbssbs"},            {76,"bbssbsbssss"},            {77,"bbbbsbbbsbs"},            {78,"bbssssbsbss"},            {79,"bsssbbbbsbs"},            {80,"bsbssbbbbss"},            {81,"bssbsbbbbss"},            {82,"bssbssbbbbs"},            {83,"bsbbbbssbss"},            {84,"bssbbbbsbss"},            {85,"bssbbbbssbs"},            {86,"bbbbsbssbss"},            {87,"bbbbssbsbss"},            {88,"bbbbssbssbs"},            {89,"bbsbbsbbbbs"},            {90,"bbsbbbbsbbs"},            {91,"bbbbsbbsbbs"},            {92,"bsbsbbbbsss"},            {93,"bsbsssbbbbs"},            {94,"bsssbsbbbbs"},            {95,"bsbbbbsbsss"},            {96,"bsbbbbsssbs"},            {97,"bbbbsbsbsss"},            {98,"bbbbsbsssbs"},            {99,"bsbbbsbbbbs"},            {100,"bsbbbbsbbbs"},            {101,"bbbsbsbbbbs"},            {102,"bbbbsbsbbbs"},            //{103,"bbsbsbbbbss"},                        {103,"bbsbssssbss"},                        {104,"bbsbssbssss"},                        {105,"bbsbssbbbss"},                        {106,"bbsssbbbsbsbb"},        };        int i;        IntString&amp;inf = infs[iV];        for (i = 0; i &lt; 11; i++) {            if (inf.psz[i] == 'b')*pb += 1;            pb++;        }        if (iV == 106) {            *pb += 1;pb++;            *pb += 1;pb++;        }        return pb;    }private:    int GetCheckDigit(const int iSet, char*pszCode) {        intiSum = 0, iCurSet = 0, iChar128, iCharNext, iWeight, iPosition;        iCurSet = iSet;        if (iSet == SUB::SETA) {            iSum = 103;        }        else            if (iSet == SUB::SETB) {                iSum = 104;            }            else                if (iSet == SUB::SETC) {                    iSum = 105;                }        iPosition = 0;        iWeight = 1;        const int iNum = strlen(pszCode);        while (iPosition &lt; iNum) {            if (iCurSet == SUB::SETC) {                if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 101) {                    iChar128 = 101;                    iSum += (iWeight*iChar128);                    iPosition++;                    iWeight++;                    iCurSet = SUB::SETA;                }                else if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 100) {                    iChar128 = 100;                    iSum += (iWeight*iChar128);                    iPosition++;                    iWeight++;                    iCurSet = SUB::SETB;                }                else                    if (ga2_Code128[SUB::SETA][pszCode[iPosition]] == 102) {                        iChar128 = 102;                        iSum += (iWeight*iChar128);                        iPosition++;                        iWeight++;                    }                    else {                        char chT = pszCode[iPosition + 2];                        pszCode[iPosition + 2] = 0;                        iChar128 = atol(&amp;pszCode[iPosition]);                        pszCode[iPosition + 2] = chT;                        iSum += (iWeight*iChar128);                        iPosition += 2;                        iWeight++;                    }            }            else {                int iTemp2 = pszCode[iPosition];                if (iTemp2 &lt; -1)iTemp2 = iTemp2 &amp; 255;                iChar128 = ga2_Code128[iCurSet][iTemp2];                iSum += (iWeight*iChar128);                iPosition++;                iWeight++;                if (iCurSet == SUB::SETA) {                    if (iChar128 == 100)                        iCurSet = SUB::SETB;                    else if (iChar128 == 99)                        iCurSet = SUB::SETC;                }                else                    if (iCurSet == SUB::SETB) {                        if (iChar128 == 101)iCurSet = SUB::SETA;                        else if (iChar128 == 99)iCurSet = SUB::SETC;                    }                    else                        if (iChar128 == 98) {                            if (iCurSet == SUB::SETA)                                iCharNext = ga2_Code128[SUB::SETB][pszCode[iPosition]];                            else                                iCharNext = ga2_Code128[SUB::SETA][pszCode[iPosition]];                            iSum += (iWeight*iCharNext);                            iPosition++;                            iWeight++;                        }            }        }        return iSum % 103;    }};//=============================================class BarcodeEan13 :public BarcodeBase {public:    BarcodeEan13() {    }    ~BarcodeEan13() {    }    BOOL EncodeEan13(const char*pszCodeIn) {        Clear();        //only allow 12 characters as input        char szCode[14];        const int iLen = strlen(pszCodeIn);        if (iLen &gt; 12) {            strncpy(szCode, pszCodeIn, 12);        }        else {            strcpy(szCode, pszCodeIn);            while (strlen(szCode) &lt; 12)strcat(szCode, "0");        }        BYTE*pFst = ia_Buf;        BYTE*pb = pFst;        //"bsb"-long        *pb += 5;pb++;        *pb += 4;pb++;        *pb += 5;pb++;        BYTE iaCountryCode[6];        BOOL b = P_GetCountryCode(szCode[0], iaCountryCode);        if (b == 0)return 0;        pb = P_GetLeftOddParity(pb, szCode[1]);        int i;        for (i = 2; i &lt; 7; i++) {            if (iaCountryCode[i - 2] == 'O') {                pb = P_GetLeftOddParity(pb, szCode[i]);            }            else                if (iaCountryCode[i - 2] == 'E') {                    pb = P_GetLeftEvenParity(pb, szCode[i]);                }        }        //"sbsbs"-long        *pb += 4;pb++;        *pb += 5;pb++;        *pb += 4;pb++;        *pb += 5;pb++;        *pb += 4;pb++;        for (i = 7; i &lt; 12; i++) {            pb = P_GetRightPattern(pb, szCode[i]);        }        i = P_GetCheckSumDigit(szCode);        pb = P_GetRightPattern(pb, (char)i);        //"bsb"-long        *pb += 5;pb++;        *pb += 4;pb++;        *pb += 5;pb++;        i_LenBuf = pb - pFst;        return 1;    }    void DrawEan13(HDC hDC, int iX, int iY0, int iY10, int iY11, const COLORREF clrBar, const COLORREF clrSpace, const int iPenW) {        DrawBarcode(hDC, iX, iY0, iY10, iY11, clrBar, clrSpace, iPenW);    }private:    BOOL P_GetCountryCode(char ch, BYTE*pbCountryCode) {        const int iV = ch - '0';        if (iV &lt; 0)return 0;        if (iV &gt; 9)return 0;        IntString infs[] =        {            {0,"OOOOO"},            {1,"OEOEE"},            {2,"OEEOE"},            {3,"OEEEO"},            {4,"EOOEE"},            {5,"EEOOE"},            {6,"EEEOO"},            {7,"EOEOE"},            {8,"EOEEO"},            {9,"EEOEO"},        };        memcpy(pbCountryCode, infs[iV].psz, 5);        return 1;    }    BYTE*P_GetLeftOddParity(BYTE*pb, char ch) {        const int iV = ch - '0';        if (iV &lt; 0)return 0;        if (iV &gt; 9)return 0;        IntString infs[] =        {            {0,"sssbbsb"},            {1,"ssbbssb"},            {2,"ssbssbb"},            {3,"sbbbbsb"},            {4,"sbsssbb"},            {5,"sbbsssb"},            {6,"sbsbbbb"},            {7,"sbbbsbb"},            {8,"sbbsbbb"},            {9,"sssbsbb"},        };        IntString&amp;inf = infs[iV];        int i;        for (i = 0; i &lt; 7; i++) {            if (inf.psz[i] == 'b')*pb += 1;            pb++;        }        return pb;    }    BYTE*P_GetLeftEvenParity(BYTE*pb, char ch) {        const int iV = ch - '0';        if (iV &lt; 0)return 0;        if (iV &gt; 9)return 0;        IntString infs[] =        {            {0,"sbssbbb"},            {1,"sbbssbb"},            {2,"ssbbsbb"},            {3,"sbssssb"},            {4,"ssbbbsb"},            {5,"sbbbssb"},            {6,"ssssbsb"},            {7,"ssbsssb"},            {8,"sssbssb"},            {9,"ssbsbbb"},        };        char*psz = infs[iV].psz;        int i;        for (i = 0; i &lt; 7; i++) {            if (psz[i] == 'b')*pb += 1;            pb++;        }        return pb;    }    BYTE*P_GetRightPattern(BYTE*pb, char ch) {        const int iV = ch - '0';        if (iV &lt; 0)return 0;        if (iV &gt; 9)return 0;        IntString infs[] =        {            {0,"bbbssbs"},            {1,"bbssbbs"},            {2,"bbsbbss"},            {3,"bssssbs"},            {4,"bsbbbss"},            {5,"bssbbbs"},            {6,"bsbssss"},            {7,"bsssbss"},            {8,"bssbsss"},            {9,"bbbsbss"},        };        char*psz = infs[iV].psz;        int i;        for (i = 0; i &lt; 7; i++) {            if (psz[i] == 'b')*pb += 1;            pb++;        }        return pb;    }    char P_GetCheckSumDigit(const char*pszCode) {        const int iLen = strlen(pszCode);        int i, iSum = 0, iItem;        for (i = iLen; i &gt;= 1; i--) {            iItem = i % 2 ? (pszCode[i - 1] - '0') * 1 : (pszCode[i - 1] - '0') * 3;            iSum += iItem;        }        iSum %= 10;        return '0' + (10 - iSum) % 10;    }};#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 条形码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows注册URL协议</title>
      <link href="/2023/06/25/windows-zhu-ce-url-xie-yi/"/>
      <url>/2023/06/25/windows-zhu-ce-url-xie-yi/</url>
      
        <content type="html"><![CDATA[<p>当电脑安装完Steam后，在浏览器中输入<code>steam://run/123</code>链接，浏览器会自动提示打开Steam程序。<br><img src="https://static.1key.run/blog/img/windows-zczdyxy-1.jpg"></p><p>类似的功能在迅雷、QQ等产品上都有使用。</p><p>实现上述功能只需要在注册表<code>HKEY_CLASSES_ROOT</code>项下添加对应的子项即可，以注册<code>test</code>协议为例：</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">indows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\test]@="URL:test protocol""URL Protocol"=""[HKEY_CLASSES_ROOT\test\DefaultIcon]@="mytest.exe"[HKEY_CLASSES_ROOT\test\Shell][HKEY_CLASSES_ROOT\test\Shell\Open][HKEY_CLASSES_ROOT\test\Shell\Open\Command]@="\"D:\\sourcecode\\mytest.exe\" -- \"%1\""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改完之后，在浏览器中输入<code>test://start/123</code>就会打开<code>D:\\sourcecode\\mytest.exe</code>，并且传递给<code>mytest.exe</code>的命令行参数为<code>test://start/123</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> URL协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个Dockerfile同时运行多个进程</title>
      <link href="/2023/06/25/yi-ge-dockerfile-tong-shi-yun-xing-duo-ge-jin-cheng/"/>
      <url>/2023/06/25/yi-ge-dockerfile-tong-shi-yun-xing-duo-ge-jin-cheng/</url>
      
        <content type="html"><![CDATA[<p>Docker容器的哲学是一个Docker容器只运行一个进程。</p><p>但如果需要在一个容器内运行多个进程或服务，可以采取将入口文件设置为Bash Shell脚本，在脚本内运行多个程序的方式。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">#!/bin/bash # start 1start1  &gt; /var/log/start1.log 2&gt;&amp;1 &amp;# start 2start2 &gt; /var/log/start2.log 2&gt;&amp;1 &amp; # just keep this script runningwhile [[ true ]]; do    sleep 1done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Dockerfile的入口中运行run.sh：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">FROM ubuntu:latest...COPY ./run.sh /ENTRYPOINT  ["run.sh"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dockerfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以管理员权限运行批处理脚本</title>
      <link href="/2023/06/25/yi-guan-li-yuan-quan-xian-yun-xing-pi-chu-li-jiao-ben/"/>
      <url>/2023/06/25/yi-guan-li-yuan-quan-xian-yun-xing-pi-chu-li-jiao-ben/</url>
      
        <content type="html"><![CDATA[<p>基本原理：</p><ul><li>根据cacls.exe能够访问”%SystemDrive%\System Volume Information”文件，来判断当前批处理进程是否具有管理员权限。</li><li>创建vbs脚本到临时目录，并运用该脚本提权执行当前bat文件。</li></ul><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">@echo offcd /d "%~dp0"cacls.exe "%SystemDrive%\System Volume Information" &gt;nul 2&gt;nulif %errorlevel%==0 goto Adminif exist "%temp%\getadmin.vbs" del /f /q "%temp%\getadmin.vbs"echo Set RequestUAC = CreateObject^("Shell.Application"^)&gt;"%temp%\getadmin.vbs"echo RequestUAC.ShellExecute "%~s0","","","runas",1 &gt;&gt;"%temp%\getadmin.vbs"echo WScript.Quit &gt;&gt;"%temp%\getadmin.vbs""%temp%\getadmin.vbs" /fif exist "%temp%\getadmin.vbs" del /f /q "%temp%\getadmin.vbs"exit:Adminrem ---------- Here is the script to be run ------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 批处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 管理员权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NPM和Yarn设置国内源</title>
      <link href="/2023/06/25/npm-he-yarn-she-zhi-guo-nei-yuan/"/>
      <url>/2023/06/25/npm-he-yarn-she-zhi-guo-nei-yuan/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Yarn设置"><a href="#1-Yarn设置" class="headerlink" title="1. Yarn设置"></a>1. Yarn设置</h1><p>查看当前使用的镜像源：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">yarn config get registry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>全局修改：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">yarn config set registry https://registry.npm.taobao.org -gyarn config set disturl https://npm.taobao.org/dist -gyarn config set electron_mirror https://npm.taobao.org/mirrors/electron/ -gyarn config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ -gyarn config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/ -gyarn config set chromedriver_cdnurl https://cdn.npm.taobao.org/dist/chromedriver -gyarn config set operadriver_cdnurl https://cdn.npm.taobao.org/dist/operadriver -gyarn config set fse_binary_host_mirror https://npm.taobao.org/mirrors/fsevents -g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>临时修改：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">yarn save 软件名 --registry https://registry.npm.taobao.org/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="2-NPM设置"><a href="#2-NPM设置" class="headerlink" title="2. NPM设置"></a>2. NPM设置</h1><p>查看当前使用的镜像源：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">npm get registry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>全局设置：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/distnpm config set electron_mirror https://npm.taobao.org/mirrors/electron/npm config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/npm config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>npm v9版本会报错：<code>ELECTRON_MIRROR</code> is not a valid npm option。<br>需要切换为npm v8版本：<code>npm install -g npm@^8</code></p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NPM </tag>
            
            <tag> Yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除Qt控件虚线框</title>
      <link href="/2023/06/25/yi-chu-qt-kong-jian-xu-xian-kuang/"/>
      <url>/2023/06/25/yi-chu-qt-kong-jian-xu-xian-kuang/</url>
      
        <content type="html"><![CDATA[<h1 id="方式一：使用-StyleSheet"><a href="#方式一：使用-StyleSheet" class="headerlink" title="方式一：使用 StyleSheet"></a>方式一：使用 StyleSheet</h1><pre class="line-numbers language-CSS" data-language="CSS"><code class="language-CSS">QWidget:focus {   outline: none; /* 去掉得到焦点时的虚线框 */ }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="方式二：继承-QProxyStyle"><a href="#方式二：继承-QProxyStyle" class="headerlink" title="方式二：继承 QProxyStyle"></a>方式二：继承 QProxyStyle</h1><p>继承 QProxyStyle，PrimitiveElement为QStyle::PE_FrameFocusRect 时不绘制虚线框，然后在main() 函数里调用 QApplication::setStyle() 使用新的样式。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">// 文件名: NoFocusRectStyle.h#ifndef NOFOCUSRECTSTYLE_H#define NOFOCUSRECTSTYLE_H#include &lt;QProxyStyle&gt;class NoFocusRectStyle : public QProxyStyle{public:    NoFocusRectStyle(QStyle *baseStyle) : QProxyStyle(baseStyle) {}    void drawPrimitive(PrimitiveElement element,                       const QStyleOption *option,                       QPainter *painter,                       const QWidget *widget = 0) const{        if (element == QStyle::PE_FrameFocusRect)        {            return;        }        QProxyStyle::drawPrimitive(element, option, painter, widget);    }};#endif // NOFOCUSRECTSTYLE_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">// 文件名: main.cpp#include "Widget.h"#include "NoFocusRectStyle.h"#include &lt;QApplication&gt;int main(int argc, char *argv[]){    QApplication app(argc, argv);    NoFocusRectStyle *style = new NoFocusRectStyle(app.style());    app.setStyle(style); // Ownership of the style object is transferred to QApplication    Widget w;    w.show();    return app.exec();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QProxyStyle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QSS基本使用方法</title>
      <link href="/2023/06/25/qss-ji-ben-shi-yong-fang-fa/"/>
      <url>/2023/06/25/qss-ji-ben-shi-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="一、选择器类型"><a href="#一、选择器类型" class="headerlink" title="一、选择器类型"></a>一、选择器类型</h1><p>Qt QSS选择器和CSS2、CSS3的选择器类似，建议先学习或者复习<a href="https://www.w3school.com.cn/cssref/css_selectors.asp">CSS选择器的语法</a>。QSS虽然和CSS类型，但有也稍许不同，而且支持的语法也没那么多，具体如下。</p><h2 id="1-1-类选择器"><a href="#1-1-类选择器" class="headerlink" title="1.1 类选择器"></a>1.1 类选择器</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*匹配QPushButton的实例及其子类*/</span><span class="token selector">QPushButton</span> <span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*匹配QPushButton的实例，但不包含子类*/</span><span class="token selector">.QPushButton</span> <span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-选择器分组"><a href="#1-2-选择器分组" class="headerlink" title="1.2 选择器分组"></a>1.2 选择器分组</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*同时匹配QPushButton、QLineEdit的实例*/</span><span class="token selector">QPushButton, QLineEdit</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>blue<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="1-3-ID选择器"><a href="#1-3-ID选择器" class="headerlink" title="1.3 ID选择器"></a>1.3 ID选择器</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*匹配所有objectName为btnOK的实例*/</span><span class="token selector">*#btnOK</span> <span class="token punctuation">{</span><span class="token property">font-weight</span><span class="token punctuation">:</span>bold<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*和*#btnOK一样，匹配所有objectName为btnOK的实例*/</span><span class="token selector">#btnOK</span> <span class="token punctuation">{</span><span class="token property">font-weight</span><span class="token punctuation">:</span>bold<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*匹配所有objectName为btnOK的QPushButton实例*/</span><span class="token selector">QPushButton#btnOK</span> <span class="token punctuation">{</span><span class="token property">font-weight</span><span class="token punctuation">:</span>bold<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4-属性选择器"><a href="#1-4-属性选择器" class="headerlink" title="1.4 属性选择器"></a>1.4 属性选择器</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*匹配包含flat属性的所有实例*/</span><span class="token selector">*[flat]</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*匹配包含flat属性的所有QPushButton的实例*/</span><span class="token selector">QPushButton[flat]</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*匹配flat属性为true的所有QPushButton的实例*/</span><span class="token selector">QPushButton[flat="true"]</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*匹配falt属性为true且default属性为false的所有QPushButton的实例*/</span><span class="token selector">QPushButton[flat="true"][default="false"]</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-5-后代选择器"><a href="#1-5-后代选择器" class="headerlink" title="1.5 后代选择器"></a>1.5 后代选择器</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*匹配属于QDialog后代（孩子，孙子等）的QPushButton所有实例*/</span><span class="token selector">QDialog QPushButton</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-6-子元素选择器"><a href="#1-6-子元素选择器" class="headerlink" title="1.6 子元素选择器"></a>1.6 子元素选择器</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*匹配属于QDialog直接子类的QPushButton所有实例*/</span><span class="token selector">QDialog &gt; QPushButton</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-7-伪状态"><a href="#1-7-伪状态" class="headerlink" title="1.7 伪状态"></a>1.7 伪状态</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*匹配hover状态的所有QPushButton的实例*/</span><span class="token selector">QPushButton:hover</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> white <span class="token punctuation">}</span><span class="token comment">/*匹配同时为hover和enabled状态的所有QPushButton的实例*/</span><span class="token selector">QPushButton:hover:enabled</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> white <span class="token punctuation">}</span><span class="token comment">/*匹配不为hover状态的所有QPushButton的实例*/</span><span class="token selector">QRadioButton:!hover</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> red <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-8-子控件选择器"><a href="#1-8-子控件选择器" class="headerlink" title="1.8 子控件选择器"></a>1.8 子控件选择器</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">QRadioButton::indicator::unchecked:disabled</span> <span class="token punctuation">{</span>    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>:/qss/radiobutton_unchecked_disable.png<span class="token punctuation">)</span></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="二、选择器优先级"><a href="#二、选择器优先级" class="headerlink" title="二、选择器优先级"></a>二、选择器优先级</h1><p>一句话归纳为：<strong>优先使用更具体的选择器。</strong></p><p>具体实例如下：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*QPushButton#okButton选择器比QPushButton更具体，所以选择QPushButton#okButton*/</span><span class="token selector">QPushButton#okButton</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> gray <span class="token punctuation">}</span><span class="token selector">QPushButton</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> red <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*如下2个规则应用于QPushButton实例时：因为QPushButton继承QAbstractButton，所以QPushButton比QAbstractButton更具体，选择QPushButton*/</span><span class="token selector">QPushButton</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> red <span class="token punctuation">}</span><span class="token selector">QAbstractButton</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> gray <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*指定伪状态比不指定伪状态的选择器更具体，所以当鼠标悬停时选择QPushButton:hover，否则选择QPushButton*/</span><span class="token selector">QPushButton:hover</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> white <span class="token punctuation">}</span><span class="token selector">QPushButton</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> red <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*如下2个规则应用于处于Enabled状态的QPushButton实例时：鼠标悬停时，QPushButton:hover更能具体描述当前状态，所以选择QPushButton:hover其他时候选择QPushButton:enabled*/</span><span class="token selector">QPushButton:enabled</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">}</span><span class="token selector">QPushButton:hover</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*如下2个规则应用于处于Enabled状态的QPushButton实例时：鼠标悬停时，QPushButton:enabled:hover更能具体描述当前状态，所以选择QPushButton:enabled:hover其他时候选择QPushButton:enabled*/</span><span class="token selector">QPushButton:enabled</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">}</span><span class="token selector">QPushButton:hover</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">}</span><span class="token selector">QPushButton:enabled:hover</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、QSS支持的类型、属性、伪状态、子控件"><a href="#三、QSS支持的类型、属性、伪状态、子控件" class="headerlink" title="三、QSS支持的类型、属性、伪状态、子控件"></a>三、QSS支持的类型、属性、伪状态、子控件</h1><p>关于QSS支持哪些类型、每种类型支持哪些属性、伪状态和子控件，在Qt的官方的英文文档中有详细的介绍：<br><a href="https://doc.qt.io/qt-5/stylesheet-reference.html">《Qt Style Sheets Reference》</a></p><h1 id="四、盒子模型"><a href="#四、盒子模型" class="headerlink" title="四、盒子模型"></a>四、盒子模型</h1><p>在使用QSS设置样式时，有一个关键的概念需要知晓，那就是“盒子模型”（即<code>Box Model</code>）。<br><img src="https://static.1key.run/blog/img/qss-jbsyff-1.png"></p><p>每个Widget都被视为具有4个同心矩形的框：<br><code>MARGIN矩形</code>、<code>BORDER矩形</code>、<code>PADDING矩形</code>和<code>CONTENT矩形</code>，上图标注了每个矩形的区域。</p><p>默认情况下<code>MARGIN矩形</code>、<code>BORDER矩形</code>、<code>PADDING矩形</code>的宽度都为0，这样在默认情况下，4个矩形就重合为1个<code>CONTENT矩形</code>了。</p><p>同样，默认情况下<code>background-image</code>指定的背景，只在border内的区域绘制。但我们要也可以使用<code>background-clip</code>或<code>background-origin</code>属性来更改这种默认行为。</p><p><strong>如何实现背景图像随Widget大小自动缩放？</strong><br>background-image指定的背景图像无法随Widget大小自动缩放，要提供可以随Widget大小缩放的背景图像可以使用<code>border-image</code>和<code>image</code>属性，二者区别如下：</p><ul><li>border-image属性指定的图像从border及其内的区域开始绘制，会导致border属性被覆盖。</li><li>image属性指定的图像从绘制到content区域内，image指定的url为SVG图像，则支持自动缩放，非SVG图像仅支持自动缩小。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QSS的几种图片设置方法</title>
      <link href="/2023/06/25/qss-de-ji-chong-tu-pian-she-zhi-fang-fa/"/>
      <url>/2023/06/25/qss-de-ji-chong-tu-pian-she-zhi-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>大家在使用QSS进行图片设置时，也许被<code>image</code>, <code>border-image</code>, <code>background-image</code>这几个属性困扰过。比如他们之间有什么区别，什么时候该用哪个属性来设置等等。本文就来讲解一下这个几个属性的异同点。</p><h1 id="一、background-image"><a href="#一、background-image" class="headerlink" title="一、background-image"></a>一、background-image</h1><p><code>background-image</code>按图片实际尺寸显示图片，超过控件显示区域的部分会被裁剪掉，虽能显示SVG，但无法对SVG进行无损缩放；</p><p>关于<code>background-image</code>的几个附属属性的作用，可以一句话概括为：<br><strong>从</strong>**<code>background-origin</code><strong><strong>区域的</strong></strong><code>background-position</code><strong><strong>位置开始绘制图像，并以</strong></strong><code>background-repeat</code><strong><strong>方式进行重复；最后将图像</strong></strong><code>background-clip</code>**<strong>区域以外的范围裁剪掉（即不显示）。</strong></p><h1 id="二、image"><a href="#二、image" class="headerlink" title="二、image"></a>二、image</h1><p>按<strong>图片原长宽比</strong>来缩放图片，保证填充满控件content区域，支持SVG矢量图显示和无损缩放;</p><p>image可以使用<code>image-position</code>来指定图片开始显示的位置（参考上面<code>background-position</code>）。</p><h1 id="三、border-image"><a href="#三、border-image" class="headerlink" title="三、border-image"></a>三、border-image</h1><p>按<strong>控件border区域的长宽比</strong>来缩放图片，保证填充满控件border区域，支持SVG矢量图显示和无损缩放;</p><h1 id="四、绘制顺序"><a href="#四、绘制顺序" class="headerlink" title="四、绘制顺序"></a>四、绘制顺序</h1><p>如果在一个控件中同时指定<code>background-image</code>，<code>border-image</code>，<code>image</code>这三个属性，会按照如下的顺序进行绘制：</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">先绘制 background-image然后 border-image最后 image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="五、示例"><a href="#五、示例" class="headerlink" title="五、示例"></a>五、示例</h1><pre class="line-numbers language-CSS" data-language="CSS"><code class="language-CSS">QPushButton#pushButton4 {  border: 20px solid rgba(0,0,255,0.5);  padding: 20px;  margin: 20px;  background-image: url(:/QssUsage/Image/头像.png); /*下图中的圆形头像*/  background-origin: margin;  background-position:top left;  background-repeat:repeat-x;  background-clip: margin;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://static.1key.run/blog/img/qss-sztp-1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Windows内存体系》专栏</title>
      <link href="/2023/06/25/windows-nei-cun-ti-xi-zhuan-lan/"/>
      <url>/2023/06/25/windows-nei-cun-ti-xi-zhuan-lan/</url>
      
        <content type="html"><![CDATA[<p>力求全面的介绍在Ring3层开发过程中需要了解的Windows内存体系方面的知识。</p><p>文章列表：</p><ul><li><a href="/2023/06/20/windows-nei-cun-ti-xi-1-xu-ni-di-zhi-kong-jian/" title="Windows内存体系(1)--虚拟地址空间">Windows内存体系(1)--虚拟地址空间</a></li><li><a href="/2023/06/20/windows-nei-cun-ti-xi-2-xu-ni-nei-cun/" title="Windows内存体系(2)--虚拟内存">Windows内存体系(2)--虚拟内存</a></li><li><a href="/2023/06/20/windows-nei-cun-ti-xi-3-nei-cun-ying-she-wen-jian/" title="Windows内存体系(3)--内存映射文件">Windows内存体系(3)--内存映射文件</a></li><li><a href="/2023/06/20/windows-nei-cun-ti-xi-4-nei-cun-dui-qi/" title="Windows内存体系(4)--内存对齐">Windows内存体系(4)--内存对齐</a></li><li><a href="/2023/06/20/windows-nei-cun-ti-xi-5-dui/" title="Windows内存体系(5)--堆">Windows内存体系(5)--堆</a></li><li><a href="/2023/06/20/windows-nei-cun-ti-xi-6-kua-mo-kuai-nei-cun-fen-pei-shi-fang/" title="Windows内存体系(6)--跨模块内存分配释放">Windows内存体系(6)--跨模块内存分配释放</a></li><li><a href="/2023/06/20/windows-nei-cun-ti-xi-7-shi-yong-std-string-kua-mt-mo-kuai-chuan-can/" title="Windows内存体系(7)--使用std::string跨MT模块传参">Windows内存体系(7)--使用std::string跨MT模块传参</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟内存 </tag>
            
            <tag> 内存对齐 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++实现编译时断言</title>
      <link href="/2023/06/21/c-shi-xian-bian-yi-shi-duan-yan/"/>
      <url>/2023/06/21/c-shi-xian-bian-yi-shi-duan-yan/</url>
      
        <content type="html"><![CDATA[<p>C++自C++11起支持static_assert编译时断言，如：</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">static_assert ( bool_constexpr , message )(C++11 起)static_assert ( bool_constexpr )(C++17 起)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>若编译器不支持C++11（经测试VS2010已经支持<code>static_assert</code>），可以使用下面方式来实现编译断言：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define COMPILE_ASSERT(expression) switch (0) {case 0: case expression:;}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用方法：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">COMPILE_ASSERT(1 != 1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译断言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++默认构造函数</title>
      <link href="/2023/06/21/c-mo-ren-gou-zao-han-shu/"/>
      <url>/2023/06/21/c-mo-ren-gou-zao-han-shu/</url>
      
        <content type="html"><![CDATA[<p>本文围绕3个问题来理解C++的默认构造函数：</p><ol><li>什么是默认构造函数？</li><li>默认构造函数什么时候被调用？</li><li>编译器在什么情况下会生成默认构造函数？</li></ol><h2 id="一-什么是默认构造函数？"><a href="#一-什么是默认构造函数？" class="headerlink" title="一. 什么是默认构造函数？"></a>一. 什么是默认构造函数？</h2><p>我们一般会认为默认构造函数就是编译器自动生成的那个构造函数，其实这种理解不全面。<br><strong>准确的说，默认构造函数就是在调用时不需要显示地传入实参的构造函数。</strong></p><p>根据这个原则，下面2种构造函数都是默认构造函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Sample {public:// 默认构造函数。Sample() {// do something}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Sample {public:// 默认构造函数。虽然有形参，但有默认值，调用的时候可以不显示的传入实参。Sample(int m = 10) {// do something}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二-默认构造函数什么时候被调用？"><a href="#二-默认构造函数什么时候被调用？" class="headerlink" title="二. 默认构造函数什么时候被调用？"></a>二. 默认构造函数什么时候被调用？</h2><p>如果定义一个对象时没有使用初始化式，编译器就会使用默认构造函数。如：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Sample s;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三-编译器在什么情况下会生成默认构造函数？"><a href="#三-编译器在什么情况下会生成默认构造函数？" class="headerlink" title="三. 编译器在什么情况下会生成默认构造函数？"></a>三. 编译器在什么情况下会生成默认构造函数？</h2><p>有一句很经典的话可以用来回答这个问题：<strong>惟有默认构造函数被编译器需要的时候，编译器才会生成默认构造函数。</strong></p><p>那我们只需知道什么时候“被编译器需要”，就可以知道什么情况下会生成默认构造函数了。</p><p>下面几种情况下，编译需要生成默认构造函数：</p><ol><li>当该类的<code>类对象数据成员</code>有默认构造函数时。</li><li>当该类的基类有默认构造函数时。</li><li>当该类的基类为虚基类时。</li><li>当该类有虚函数时。</li></ol><h2 id="四-注意事项"><a href="#四-注意事项" class="headerlink" title="四. 注意事项"></a>四. 注意事项</h2><h3 id="4-1-避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在"><a href="#4-1-避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在" class="headerlink" title="4.1 避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在"></a>4.1 避免“无参数的默认构造函数”和“带缺省参数的默认构造函数”同时存在</h3><p><code>无参数的默认构造函数</code>和<code>带缺省参数的默认构造函数</code>同时存在时，编译器会产生二义性，从而生成编译错误。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Sample {public:// 默认构造函数Sample() {// do somethingprintf("Sample()");}// 默认构造函数Sample(int m = 10) {// do somethingprintf("Sample(int m = 10)");}};int main(){Sample s; // error C2668: “Sample::Sample”: 对重载函数的调用不明确    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-不应在对象名后面加上括号"><a href="#4-2-不应在对象名后面加上括号" class="headerlink" title="4.2 不应在对象名后面加上括号"></a>4.2 不应在对象名后面加上括号</h3><p>使用无参构造函数创建对象时，不应在对象名后面加上括号，否则会产生编译警告</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为编译器误认为<code>Sample s();</code>语句时要声明返回值为<code>Sample</code>对象的函数<code>s</code>，而又没找到函数<code>s</code>的定义，所以产生了警告。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Sample {public:// 默认构造函数Sample() {// do somethingprintf("Sample()");}};int main(){Sample s(); // warning C4930: “Sample s(void)”: 未调用原型函数(是否是有意用变量定义的?)    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从汇编的角度分析函数调用过程</title>
      <link href="/2023/06/21/cong-hui-bian-de-jiao-du-fen-xi-han-shu-diao-yong-guo-cheng/"/>
      <url>/2023/06/21/cong-hui-bian-de-jiao-du-fen-xi-han-shu-diao-yong-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-函数参数传递形式"><a href="#一、-函数参数传递形式" class="headerlink" title="一、 函数参数传递形式"></a>一、 函数参数传递形式</h2><p>函数的参数传递有2种方式：</p><ul><li>堆栈方式</li><li>寄存器方式</li></ul><p>如果是堆栈方式传递的，就需要定义函数参数在堆栈中的传递顺序，并约定函数被调用之后，由谁来平衡堆栈；<br>如果是寄存器方式传递的，就需要确定参数存放在哪个寄存器中。<br>每一种方式都有其优缺点，而且与使用的编程语言有关系，不存在哪种方式好与坏。</p><p>我们在开发中经常遇到<code>调用约定类型</code>，如<code>__cdecl</code>、<code>stdcall</code>、<code>PASCAL</code>、<code>fastcall</code>。这些调用约定类型就用来指定函数参数的传递方式的。上面几种约定类型，除了<code>fastcall</code>是使用寄存器方式传递参数外，其他的都是使用堆栈传递参数的。</p><blockquote><p>Visual Studio中的C++工程，可以<code>C++</code> –&gt; <code>高级</code> –&gt; <code>调用约定</code>中进行调用约定的设置：<br><img src="https://static.1key.run/blog/img/hbfxhsdy-1.png"></p></blockquote><h2 id="二、使用堆栈方式传递函数参数"><a href="#二、使用堆栈方式传递函数参数" class="headerlink" title="二、使用堆栈方式传递函数参数"></a>二、使用堆栈方式传递函数参数</h2><p>堆栈是一种“后进先出”的数据结构，<code>ESP</code>寄存器始终指向栈顶。栈中数据地址从底部到顶部依次减小，也就是说，栈底对应高地址，栈顶对应低地址。</p><p>调用函数时，调用者依次把参数压栈，然后调用函数，函数被调用之后，在堆栈中取得参数数据。函数调用结束以后，堆栈需要恢复到函数调用之前的样子，而到底是由调用者来恢复还是由函数自身来恢复，根据不同的调用约定类型采用不同的方式。</p><table><thead><tr><th>约定类型</th><th>__cdecl</th><th>stdcall</th><th>PASCAL</th><th>fastcall</th></tr></thead><tbody><tr><td><strong>参数传递顺序</strong></td><td>从右到左</td><td>从右到左</td><td>从左到右</td><td>使用寄存器</td></tr><tr><td><strong>堆栈平衡者</strong></td><td>调用者</td><td>函数自身</td><td>函数自身</td><td>函数自身</td></tr></tbody></table><p><code>__cdcel</code>是C/C++/MFC程序默认的调用约定。<br><code>stdcall</code>是绝大多数Win32 API函数的约定方式，也有少部分使用<code>__cdcel</code>约定方式（如wsprintf等）。<br>在Windows C/C++开发中常用的就是<code>__cdecl</code>和<code>stdcall</code>这2种调用约定。</p><p>按照不同的<code>调用约定</code>来调用函数<code>int add(int a, int b)</code>。从调用者的视角来看，其汇编代码分别表示如下：</p><p><strong>__cdecl</strong></p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">push b     ;参数按从右到左传递push acall addadd esp, 8 ;调用者在函数外部平衡堆栈<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>stdcall</strong></p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">push b     ;参数按从右到左传递push acall add   ;函数自己内部平衡堆栈，调用者不需要平衡堆栈<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在函数调用过程中，参数入栈的过程如图：<br><img src="https://static.1key.run/blog/img/hbfxhsdy-2.png"></p><p>上图中，<code>EBP</code>和<code>函数返回地址ret</code>都是32位地址。因为函数调用完之后会将<code>EBP</code>恢复为暂存在堆栈中的原<code>EBP</code>值，所以从调用者角度来看，在函数的一次调用过程中<code>EBP</code>是不会变化的。</p><p>我们可以在函数中通过新的<code>EBP</code>获取函数各个参数的值：</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">参数a = EBP + 0x8参数b = EBP + 0xC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="三、调用过程分析"><a href="#三、调用过程分析" class="headerlink" title="三、调用过程分析"></a>三、调用过程分析</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;stdio.h&gt;int add(int a, int b) {int c = 0;c = a + b;return c;}int main(){int r = add(1, 2);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用<code>Visual Studio 2017</code>编译上面代码，并在在工程配置中将函数调用约定设置为<code>__cdecl</code>。</p><p>在程序调试过程中，可以在<code>Visual Studio</code>的<code>反汇编窗口</code>中看到C++代码对应的汇编代码，以及<code>寄存器</code>窗口中看到各个寄存器的值。</p><p><code>main</code>函数的反汇编代码如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main(){00DD1720  push        ebp          // 参见add函数中关于这一部分的解析00DD1721  mov         ebp,esp  00DD1723  sub         esp,0CCh00DD1729  push        ebx  00DD172A  push        esi  00DD172B  push        edi  00DD172C  lea         edi,[ebp-0CCh]  00DD1732  mov         ecx,33h  00DD1737  mov         eax,0CCCCCCCCh  00DD173C  rep stos    dword ptr es:[edi]  int r = add(1, 2);        00DD173E  push        2                 // 参数b入栈00DD1740  push        1                 // 参数a入栈00DD1742  call        add (0DD1276h)    // 调用add函数。CALL指令相当于执行一条PUSH指令加一条JMP指令，PUSH指令用于压入该指令的下一条指令地址到栈中，用于执行完子函数之后返回来。JMP指令用于跳转到子函数所在位置开始执行子函数。00DD1747  add         esp,8            // 因为是__cdecl，所以由调用者来平衡堆栈.00DD174A  mov         dword ptr [r],eax      return 0;00DD174D  xor         eax,eax  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行进入<code>add</code>函数后，<code>add</code>函数内的汇编代码如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int add(int a, int b) {00DD16D0  push        ebp      // ebp入栈，相当于暂存ebp的值00DD16D1  mov         ebp,esp  // 将esp赋值给ebp，在该函数之后的执行过程中不会再改变ebp的值。00DD16D3  sub         esp,0CCh // 在栈上分配0xCC大小的局部变量存储区域00DD16D9  push        ebx      // 暂存ebx00DD16DA  push        esi      // 暂存esi00DD16DB  push        edi      // 暂存edi00DD16DC  lea         edi,[ebp-0CCh]  //下面4行代码（含该条）实现将0xCC大小的局部变量存储区域全部赋值为0xCC00DD16E2  mov         ecx,33h         // ecx存储循环次数，结合rep指令使用。为什么是0x33次了？因为是按照4个字节赋值的，0x33 * 0x4 = 0xCC00DD16E7  mov         eax,0CCCCCCCCh00DD16EC  rep stos    dword ptr es:[edi]  // 循环赋值int c = 0;00DD16EE  mov         dword ptr [c],0     // 将局部变量c赋值为0c = a + b;00DD16F5  mov         eax,dword ptr [a]  00DD16F8  add         eax,dword ptr [b]  00DD16FB  mov         dword ptr [c],eax  return c;00DD16FE  mov         eax,dword ptr [c]  // 将结果存储到eax中。在函数调用中返回结果都是存储在eax中的。}01191701  pop         edi  // 将edi的值还原到函数调用前01191702  pop         esi  // 将esi的值还原到函数调用前01191703  pop         ebx  // 将ebx的值还原到函数调用前01191704  mov         esp,ebp  // 移动栈顶到ebp位置，从而跳过了局部变量存储区域01191706  pop         ebp      // 将ebp的值还原到函数调用前01191707  ret                  // ret指令等同于：弹出此时栈顶的值给eip，                               // 因为此时栈顶存储的刚好是函数返回地址，所以相当于将返回地址赋值给eip，从而实现了返回到函数调用的地方。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面代码的注释中已经包含了详细的解释，特别值得注意的几个地方是：</p><ol><li><code>rep stos    dword ptr es:[edi]</code>结合<code>edi</code>, <code>ecx</code>来初始化局部存储区域。</li><li>函数<code>call</code>指令之前的参数压栈顺序。</li><li><code>CALL</code>指令相当于执行一条<code>PUSH</code>指令加一条<code>JMP</code>指令，<code>PUSH</code>指令用于压入该指令的下一条指令地址到栈中，用于执行完子函数之后返回来。<code>JMP</code>指令用于跳转到子函数所在位置开始执行子函数。</li><li>因为是<code>__cdecl</code>，函数调用完之后，调用方使用<code>add         esp,8</code>来平衡堆栈。</li><li><code>ret</code>指令等同于：弹出此时栈顶的值给eip，巧妙之处在于此时栈顶存储的刚好是函数返回地址。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows程序如何删除自身</title>
      <link href="/2023/06/21/windows-cheng-xu-ru-he-shan-chu-zi-shen/"/>
      <url>/2023/06/21/windows-cheng-xu-ru-he-shan-chu-zi-shen/</url>
      
        <content type="html"><![CDATA[<p>本文介绍几种实现在程序退出后，从磁盘删除自身exe文件的方式。该技术通常应用于安装包卸载程序中。</p><h2 id="一、借用choice命令实现"><a href="#一、借用choice命令实现" class="headerlink" title="一、借用choice命令实现"></a>一、借用choice命令实现</h2><p>Windows提供了choice命令，允许用户从选择列表选择一个项目并返回所选项目的索引。</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">C:\Users\akx&gt;choice /?CHOICE [/C choices] [/N] [/CS] [/T timeout /D choice] [/M text]描述:    该工具允许用户从选择列表选择一个项目并返回所选项目的索引。参数列表:   /C    choices       指定要创建的选项列表。默认列表是 "YN"。   /N                  在提示符中隐藏选项列表。提示前面的消息得到显示，                       选项依旧处于启用状态。   /CS                 允许选择分大小写的选项。在默认情况下，这个工具                       是不分大小写的。   /T    timeout       做出默认选择之前，暂停的秒数。可接受的值是从 0                       到 9999。如果指定了 0，就不会有暂停，默认选项                       会得到选择。   /D    choice        在 nnnn 秒之后指定默认选项。字符必须在用 /C 选                       项指定的一组选择中; 同时，必须用 /T 指定 nnnn。   /M    text          指定提示之前要显示的消息。如果没有指定，工具只                       显示提示。示例:   CHOICE /?   CHOICE /C YNC /M "确认请按 Y，否请按 N，或者取消请按 C。"   CHOICE /T 10 /C ync /CS /D y   CHOICE /C ab /M "选项 1 请选择 a，选项 2 请选择 b。"   CHOICE /C ab /N /M "选项 1 请选择 a，选项 2 请选择 b。"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现方式如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool DeleteSelf {    wchar_t szSystemDir[MAX_PATH] = {0};    if (GetSystemDirectoryW(szSystemDir, MAX_PATH) &gt; 0) {        PathAddBackslashW(szSystemDir);    }    wchar_t szFullCmd[MAX_PATH] = {0};    StringCchPrintfW(szFullCmd, MAX_PATH, L"%scmd.exe /C choice /C Y /N /D Y /T 4 &amp; rmdir \"%s\" /Q",                    szSystemDir, szPath);    STARTUPINFOW si = {sizeof(STARTUPINFOW)};    PROCESS_INFORMATION pi;    if (CreateProcessW(NULL, szFullCmd, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, szSystemDir, &amp;si,                        &amp;pi)) {        if (pi.hThread)            CloseHandle(pi.hThread);        if (pi.hProcess)            CloseHandle(pi.hProcess);        return true;    }    return false;}int main() {   bool ret = DeleteSelf();   return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、使用计划任务实现"><a href="#二、使用计划任务实现" class="headerlink" title="二、使用计划任务实现"></a>二、使用计划任务实现</h2><p>在程序退出前添加Windows计划任务，计划任务在程序退出几秒后执行删除文件的操作。</p><p><strong>这种实现方式需要程序具有管理员权限。</strong></p><p>此处省略具体的实现方式。</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
          <category> C++ </category>
          
          <category> 计划任务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++标准库线程的启动与退出</title>
      <link href="/2023/06/21/c-biao-zhun-ku-xian-cheng-de-qi-dong-yu-tui-chu/"/>
      <url>/2023/06/21/c-biao-zhun-ku-xian-cheng-de-qi-dong-yu-tui-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="一、std-thread"><a href="#一、std-thread" class="headerlink" title="一、std::thread"></a>一、std::thread</h1><p>std::thread未提供判断线程是否结束的方法。</p><p>如果线程未进行detach且此时该线程处理joinable状态，析构该线程对象会触发异常。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;thread&gt;std::thread Thread1() {    std::thread t = std::thread([]() {        std::this_thread::sleep_for(std::chrono::milliseconds(1000));    });    return t;}int main(){    std::thread t1 = Thread1();    t1.join(); //等待线程结束    std::thread t2 = std::thread([]() {        std::this_thread::sleep_for(std::chrono::milliseconds(1000));    });    std::cout &lt;&lt; "thread id:" &lt;&lt; t2.get_id() &lt;&lt; std::endl;    std::cout &lt;&lt; "joinable:" &lt;&lt; t2.joinable() &lt;&lt; std::endl; // 1    t2.detach();    std::cout &lt;&lt; "joinable:" &lt;&lt; t2.joinable() &lt;&lt; std::endl; // 0    std::this_thread::sleep_for(std::chrono::milliseconds(2000));        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、std-async"><a href="#二、std-async" class="headerlink" title="二、std::async"></a>二、std::async</h1><p>通过<code>std::async</code>可以判断线程是否结束运行。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;future&gt;int main(){    std::future&lt;void&gt; f = std::async(std::launch::async, []() {        std::this_thread::sleep_for(std::chrono::milliseconds(1000));    });    bool isRunning = f.valid() &amp;&amp; f.wait_for(std::chrono::milliseconds(0)) == std::future_status::timeout;    std::cout &lt;&lt; isRunning &lt;&lt; std::endl;    f.wait();    isRunning = f.valid() &amp;&amp; f.wait_for(std::chrono::milliseconds(0)) == std::future_status::timeout;    std::cout &lt;&lt; isRunning &lt;&lt; std::endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-1-判断std-future是否结束"><a href="#2-1-判断std-future是否结束" class="headerlink" title="2.1 判断std::future是否结束"></a>2.1 判断std::future是否结束</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool isRunning = f.valid() &amp;&amp;                  f.wait_for(std::chrono::milliseconds(0)) == std::future_status::timeout;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-2-std-shared-future"><a href="#2-2-std-shared-future" class="headerlink" title="2.2 std::shared_future"></a>2.2 std::shared_future</h2><p><code>std::future</code>不支持赋值构造，需要使用<code>std::shared_future</code>。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">std::shared_future&lt;void&gt; f1 = std::async(std::launch::async, []() {       std::this_thread::sleep_for(std::chrono::milliseconds(1000)); });std::shared_future&lt;void&gt; f2 = f1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
            <tag> std::future </tag>
            
            <tag> std::async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLVM-Obfuscator代码混淆</title>
      <link href="/2023/06/21/llvm-obfuscator-dai-ma-hun-yao/"/>
      <url>/2023/06/21/llvm-obfuscator-dai-ma-hun-yao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>LLVM-Obfuscator只能用于混淆代码逻辑.</p></blockquote><h1 id="1-安装VS-Clang组件"><a href="#1-安装VS-Clang组件" class="headerlink" title="1. 安装VS Clang组件"></a>1. 安装VS Clang组件</h1><p><img src="https://static.1key.run/blog/img/LLVM-Obfuscator-1.png"></p><h1 id="2-编译LLVM-Obfuscator"><a href="#2-编译LLVM-Obfuscator" class="headerlink" title="2. 编译LLVM-Obfuscator"></a>2. 编译LLVM-Obfuscator</h1><p>使用heroims的Fork版本：</p><p><a href="https://github.com/heroims/obfuscator">heroims/obfuscator</a></p><h2 id="2-1-Clone最新13-x分支"><a href="#2-1-Clone最新13-x分支" class="headerlink" title="2.1 Clone最新13.x分支"></a>2.1 Clone最新13.x分支</h2><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">git clone -b llvm-13.x https://github.com/obfuscator-llvm/obfuscator.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-2-安装mingw"><a href="#2-2-安装mingw" class="headerlink" title="2.2 安装mingw"></a>2.2 安装mingw</h2><p>从<a href="https://github.com/niXman/mingw-builds-binaries/releases">https://github.com/niXman/mingw-builds-binaries/releases</a> 下载32位和64位MingW:</p><ul><li>i686-12.2.0-release-posix-dwarf-msvcrt-rt_v10-rev2.7z</li><li>x86_64-12.2.0-release-posix-seh-msvcrt-rt_v10-rev2.7z</li></ul><p>分别解压到不同的目录。</p><h2 id="2-3-编译64位LLVM-Obfuscator"><a href="#2-3-编译64位LLVM-Obfuscator" class="headerlink" title="2.3 编译64位LLVM-Obfuscator"></a>2.3 编译64位LLVM-Obfuscator</h2><p>打开CMD，将64位MingW的bin目录添加到PATH环境变量：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">SET PATH=%PATH%;C:\mingw64\x86_64-12.2.0-release-posix-seh-msvcrt-rt_v10-rev2\bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在命令行进入LLVM-Obfuscator所在目录，开始编译：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">mkdir build64cd build64cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS="clang" -DLLVM_CREATE_XCODE_TOOLCHAIN=ON -DLLVM_ENABLE_NEW_PASS_MANAGER=OFF -G "MinGW Makefiles" ../llvmmingw32-make.exe -j8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-编译32位LLVM-Obfuscator"><a href="#2-4-编译32位LLVM-Obfuscator" class="headerlink" title="2.4 编译32位LLVM-Obfuscator"></a>2.4 编译32位LLVM-Obfuscator</h2><p>重新打开CMD，将32位MingW的bin目录添加到PATH环境变量：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">SET PATH=%PATH%;C:\mingw32\i686-12.2.0-release-posix-dwarf-msvcrt-rt_v10-rev2\bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在命令行进入LLVM-Obfuscator所在目录，开始编译：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">mkdir build32cd build32cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS="clang" -DLLVM_CREATE_XCODE_TOOLCHAIN=ON -DLLVM_ENABLE_NEW_PASS_MANAGER=OFF -G "MinGW Makefiles" ../llvmmingw32-make.exe -j8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-用编译输出覆盖到VS-Clang"><a href="#3-用编译输出覆盖到VS-Clang" class="headerlink" title="3. 用编译输出覆盖到VS Clang"></a>3. 用编译输出覆盖到VS Clang</h1><p>Visual Studio的Clang位于<code>C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\Llvm</code>目录，分别将编译的32位和64位<code>bin</code>目录中的文件覆盖到VS Clang的<code>bin</code>目录中。</p><p>覆盖之前，备份目录</p><h1 id="4-设置环境变量"><a href="#4-设置环境变量" class="headerlink" title="4. 设置环境变量"></a>4. 设置环境变量</h1><p>在编译完之后，将32位和64位MingW的<code>bin</code>目录路径都添加到PATH环境变量中。因为VS编译时会启动clang.exe，而clang.exe需要依赖MingW。</p><h1 id="5-VS工程配置"><a href="#5-VS工程配置" class="headerlink" title="5. VS工程配置"></a>5. VS工程配置</h1><p><img src="https://static.1key.run/blog/img/LLVM-Obfuscator-2.png"></p><p><img src="https://static.1key.run/blog/img/LLVM-Obfuscator-3.png"></p><p>命令行其他选项如下：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">-D__CUDACC__ -D_ALLOW_COMPILER_AND_STL_VERSION_MISMATCH -mllvm -bcf -mllvm -bcf_prob=73 -mllvm -bcf_loop=1 -mllvm -sub -mllvm -sub_loop=5 -mllvm -fla -mllvm -split_num=5 -mllvm -aesSeed=DEADBEEFDEADCODEDEADBEEFDEADCODE <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="6-混淆配置参数"><a href="#6-混淆配置参数" class="headerlink" title="6. 混淆配置参数"></a>6. 混淆配置参数</h1><h3 id="开启控制流扁平化"><a href="#开启控制流扁平化" class="headerlink" title="开启控制流扁平化"></a>开启控制流扁平化</h3><p><code>-mllvm -fla</code> 开启控制流扁平化</p><p><code>-mllvm -split</code> 激活基本块划分。一起使用时能提高打平能力。</p><p><code>-mllvm -split_num=3</code> 如果激活控制流打平，对每一个基本块应用三次控制流打平。默认使用1次。</p><h3 id="开启指令替换"><a href="#开启指令替换" class="headerlink" title="开启指令替换"></a>开启指令替换</h3><p><code>-mllvm -sub</code> 开启指令替换</p><p><code>-mllvm -sub_loop=3</code> 如果激活了指令替换，使用这个选项在一个函数中应用3次指令替换。默认应用1次。</p><h3 id="开启虚假控制流"><a href="#开启虚假控制流" class="headerlink" title="开启虚假控制流"></a>开启虚假控制流</h3><p><code>-mllvm -bcf</code> 开启虚假控制流。</p><p>  <code>bcf</code>可以配合下面参数使用：</p><p>  <code>-mllvm -bcf_loop=3</code> 设置函数混淆次数为3次 不加此选项默认为1次。</p><p>  <code>-mllvm -bcf_prob=40</code> 设置代码块被混淆的概率是40%，默认30%</p><h1 id="7-CMakeList中配置混淆参数"><a href="#7-CMakeList中配置混淆参数" class="headerlink" title="7. CMakeList中配置混淆参数"></a>7. CMakeList中配置混淆参数</h1><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT"> #debug and release all enableset(CMAKE_CXX_FLAGS "-mllvm -fla -mllvm -sub -mllvm -sobf  ")#so体积优化#SET(CMAKE_CXX_FLAGS_DEBUG "$ENV{CXXFLAGS}   -O0 -Wall -g2 -ggdb")#SET(CMAKE_CXX_FLAGS_RELEASE "$ENV{CXXFLAGS}  -Os -Wall -s")#设置llvm debug模式混淆编译SET(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -mllvm -fla")SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -mllvm -fla")#设置llvm release模式混淆编译SET(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -mllvm -fla -mllvm -sub -mllvm -bcf")SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -mllvm -fla -mllvm -sub -mllvm -bcf")#set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -s -O3 -Wall -fvisibility=hidden  -mllvm -fla")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码混淆 </tag>
            
            <tag> LLVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译器基础概念</title>
      <link href="/2023/06/21/bian-yi-qi-ji-chu-gai-nian/"/>
      <url>/2023/06/21/bian-yi-qi-ji-chu-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、C-代码编译流程"><a href="#一、C-代码编译流程" class="headerlink" title="一、C++代码编译流程"></a>一、C++代码编译流程</h2><p>以下面C++代码为例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;stdio.h&gt;​int main(){    printf("Hello World");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译成二进制文件需要经过如下4个过程：</p><ul><li><strong>预编译</strong>：将hello.c和stdio.h预编译为hello.i</li><li><strong>编译</strong>：将hello.i编译为hello.s</li><li><strong>汇编</strong>：将hello.s翻译为机器指令hello.o（.o目标文件）</li><li><strong>链接</strong>：链接各种需要的库和其他目标文件（该hello程序不需要）得到可执行文件hello.out（相当于windows的.exe）。</li></ul><h2 id="二、编译器架构"><a href="#二、编译器架构" class="headerlink" title="二、编译器架构"></a>二、编译器架构</h2><p>编译器通常分为三个部分：</p><ul><li>前端（FrontEnd）</li><li>优化器（Optimizer）</li><li>后端（BackEnd）</li></ul><p>在编译过程中，前端主要负责词法和语法分析，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。</p><h3 id="2-1-GCC"><a href="#2-1-GCC" class="headerlink" title="2.1 GCC"></a>2.1 GCC</h3><p>GCC(GNU Compiler Collection，GNU编译器集合)是一个完整的编译器，包含FrontEnd、Optimizer和BackEnd。</p><h3 id="2-2-LLVM架构"><a href="#2-2-LLVM架构" class="headerlink" title="2.2 LLVM架构"></a>2.2 LLVM架构</h3><p><code>Clang</code>是LLVM编译器架构的前端，可以用来编译 C，C++，ObjectiveC 等语言；</p><p><code>LLVM</code>是该架构的优化器和后端；</p><p>二者统称为LLVM架构。</p><p><img src="https://static.1key.run/blog/img/bianyiiqijichugailian-1.png"></p><h2 id="三、编译版本选择"><a href="#三、编译版本选择" class="headerlink" title="三、编译版本选择"></a>三、编译版本选择</h2><h3 id="3-1-x86、x86-64、AMD64"><a href="#3-1-x86、x86-64、AMD64" class="headerlink" title="3.1 x86、x86-64、AMD64"></a>3.1 x86、x86-64、AMD64</h3><p>x86是指Intel的开发的一种32位指令集，从386时代开始，一直沿用至今，所有Intel早期的cpu，以及amd早期的cpu都支持这种指令集。</p><p>AMD领先Intel制造出兼容x86的商用CPU，AMD称之为AMD64，且得到用户的认同。</p><p>Intel选择设计了一种不兼容x86的全新64位指令集，称之为IA-64。由于是全新设计的CPU，没有编译器、不支持Windows，后来不得不在时机落后的情况下也开始支持AMD64指令集。因此换了个名字叫x86_64，表示x86指令集的64位扩展。</p><p>x86_64、x64、AMD64基本上是一个东西，我们现在用的intel/amd的桌面级CPU基本上都是x86_64。</p><h3 id="3-2-i386"><a href="#3-2-i386" class="headerlink" title="3.2 i386"></a>3.2 i386</h3><p>i386 即 Intel 80386。 其实i386通常被用来作为对Intel（英特尔）32位微处理器的统称。</p><p>但是目前更多的时候，我们公认i386为32位系统，其实就是x86。</p><h3 id="3-3-i686"><a href="#3-3-i686" class="headerlink" title="3.3 i686"></a>3.3 i686</h3><p>i686 仍然属于 i386 体系，不过相对于386 CPU的特性作了指令优化。</p><h3 id="3-4-MSVC编译器版本"><a href="#3-4-MSVC编译器版本" class="headerlink" title="3.4 MSVC编译器版本"></a>3.4 MSVC编译器版本</h3><ul><li>x86：编译器为x86版本，输出文件为x86。</li><li>amd64_x86：编译器为amd64版本，输出文件为x86。</li><li>amd64：编译器为amd64版本，输出文件为amd64。</li><li>x86_amd64：编译器为x86版本，输出文件为amd64。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLVM </tag>
            
            <tag> 编译器 </tag>
            
            <tag> GCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《网络协议》专栏</title>
      <link href="/2023/06/21/wang-luo-xie-yi-zhuan-lan/"/>
      <url>/2023/06/21/wang-luo-xie-yi-zhuan-lan/</url>
      
        <content type="html"><![CDATA[<p>本栏目系统性的介绍了常用的网络协议（如ARP, IP, TCP, UDP, HTTP等），并深入剖析协议的原理。让读者不仅可以知其然，而且可以知其所以然。同时也覆盖面试中的一些常见问题。</p><p>文章列表：</p><ul><li><a href="/2023/06/20/wang-luo-xie-yi-1-ji-chu-gai-nian/" title="网络协议(1)--基础概念">网络协议(1)--基础概念</a></li><li><a href="/2023/06/20/wang-luo-xie-yi-2-arp-he-rarp-xie-yi/" title="网络协议(2)--ARP和RARP协议">网络协议(2)--ARP和RARP协议</a></li><li><a href="/2023/06/20/wang-luo-xie-yi-3-ip-xie-yi/" title="网络协议(3)--IP协议">网络协议(3)--IP协议</a></li><li><a href="/2023/06/21/wang-luo-xie-yi-4-icmp-xie-yi/" title="网络协议(4)--ICMP协议">网络协议(4)--ICMP协议</a></li><li><a href="/2023/06/21/wang-luo-xie-yi-5-udp-xie-yi/" title="网络协议(5)--UDP协议">网络协议(5)--UDP协议</a></li><li><a href="/2023/06/21/wang-luo-xie-yi-6-tcp-xie-yi/" title="网络协议(6)--TCP协议">网络协议(6)--TCP协议</a></li><li><a href="/2023/06/21/wang-luo-xie-yi-7-http-yu-https-xie-yi/" title="网络协议(7)--HTTP与HTTPS协议">网络协议(7)--HTTP与HTTPS协议</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP </tag>
            
            <tag> ICMP </tag>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
            <tag> HTTP(s) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(7)--HTTP与HTTPS协议</title>
      <link href="/2023/06/21/wang-luo-xie-yi-7-http-yu-https-xie-yi/"/>
      <url>/2023/06/21/wang-luo-xie-yi-7-http-yu-https-xie-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一、HTTP协议介绍"><a href="#一、HTTP协议介绍" class="headerlink" title="一、HTTP协议介绍"></a>一、HTTP协议介绍</h1><h2 id="1-1-什么是HTTP"><a href="#1-1-什么是HTTP" class="headerlink" title="1.1 什么是HTTP"></a>1.1 什么是HTTP</h2><p>HTTP是<code>Hyper Text Transfer Protocol</code>（超文本传输协议）的缩写。HTTP协议位于TCP/IP协议栈的应用层。</p><p>HTTP是一个客户端和服务器端请求和应答的标准，主要用于从万维网（即<code>WWW</code>，全称 <code>World Wide Web</code>）服务器传输超文本到本地浏览器之间的请求数据和响应数据的协议。客户端通过使用网页浏览器或者其它的工具发起一个HTTP请求到服务器上指定端口（默认端口为<code>80</code>），服务器在收到请求之后，返回响应内容（文本、图片等）。</p><p>HTTP协议是基于TCP协议来进行数据传输的。</p><h2 id="1-2-HTTP的版本"><a href="#1-2-HTTP的版本" class="headerlink" title="1.2 HTTP的版本"></a>1.2 HTTP的版本</h2><p>HTTP协议已经演化出了很多版本，它们中的大部分都是向下兼容的。客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。现在大多使用的都是<code>1.1</code>版本。</p><ul><li><p><strong>1.0版本：</strong> HTTP 协议非常老的标准，为了提高系统的效率，HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。正式因为这种特性造成了一些性能上的缺陷。</p></li><li><p><strong>1.1版本：</strong> 克服了HTTP 1.0的缺陷，HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。同时还增加更多的请求头和响应头来改进和扩充HTTP 1.0的功能（如POST请求头字段等）。</p></li><li><p><strong>2.0版本：</strong> 2015年5月作为互联网标准正式发布。主要新增如下特性：多路复用，二进制分帧，首部压缩，服务端推送。</p></li></ul><h1 id="二、HTTP消息请求"><a href="#二、HTTP消息请求" class="headerlink" title="二、HTTP消息请求"></a>二、HTTP消息请求</h1><h2 id="2-1-URI、URL、URN"><a href="#2-1-URI、URL、URN" class="headerlink" title="2.1 URI、URL、URN"></a>2.1 URI、URL、URN</h2><p>通过HTTP或者HTTPS协议请求的资源由统一资源标识符（<code>Uniform Resource Identifiers</code>，<code>URI</code>）来标识。我们常用的是URL，那么URI, URL, URN之前有什么区别和联系了？</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">URI = Uniform Resource Identifier 统一资源标识符URL = Uniform Resource Locator    统一资源定位符URN = Universal Resource Name     统一资源名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>三者关系如下图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-http-1.png"></p><p><code>URI</code>用来唯一标识符来标识一个资源，是一个通用的概念，<code>URI</code>由<code>URL</code>和<code>URN</code>两个子集组成。</p><p><code>URL</code>通过描述资源的位置来标识资源。</p><p><code>URN</code>通过资源的名字来标识资源，与其所处的位置无关，这样即使资源的位置发生变动，其<code>URN</code>也不会变化。</p><p>HTTP规范将更通用的概念URI作为其资源标识符，但是实际上，HTTP应用程序处理的只是URI的URL子集.</p><h2 id="2-2-消息请求格式"><a href="#2-2-消息请求格式" class="headerlink" title="2.2 消息请求格式"></a>2.2 消息请求格式</h2><p><img src="https://static.1key.run/blog/img/wangluoxieyi-http-2.png"></p><h2 id="2-3-HTTP常见的请求方法"><a href="#2-3-HTTP常见的请求方法" class="headerlink" title="2.3 HTTP常见的请求方法"></a>2.3 HTTP常见的请求方法</h2><p>HTTP消息请求的第一个字段就是“请求方法”，HTTP 1.1 中定义的几种常见的请求方法如下（<strong>只列出了常用的</strong>）：</p><ul><li>GET<br>向服务器获取数据。使用GET请求方法时，消息Body中没有“请求数据”（见上面消息格式的图）部分，所以将需要提交到服务器的数据放在URL中，因此能够提交到服务器的数据会受到URL长度的限制。<br><img src="https://static.1key.run/blog/img/wangluoxieyi-http-3.png"></li></ul><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT"> 各个浏览器对URL长度的限制如下（这些限制值可能随着浏览器的版本的更新而发生改变，仅供参考）：1. IE浏览器（Microsoft Internet Explorer） 对URL长度限制是2083（2K+53），超过这个限制，则自动截断（若是form提交则提交按钮不起作用）。2. FirefoxFirefox（火狐浏览器）对URL长度限制是65536字符，但实际上有效的URL最大长度不少于100,000个字符。3. Chromechrome对URL长度限制是8182个字符。4. SafariSafari对URL长度限制是80000字符。5. OperaOpera浏览器对URL长度限制是190000 字符。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>POST<br>向服务器提交数据（例如提交表单或者上传文件）。提交的数据包含在Body中。<br><img src="https://static.1key.run/blog/img/wangluoxieyi-http-4.png"></li></ul><h1 id="三、HTTP消息响应"><a href="#三、HTTP消息响应" class="headerlink" title="三、HTTP消息响应"></a>三、HTTP消息响应</h1><h2 id="3-1-消息响应格式"><a href="#3-1-消息响应格式" class="headerlink" title="3.1 消息响应格式"></a>3.1 消息响应格式</h2><p><img src="https://static.1key.run/blog/img/wangluoxieyi-http-5.png"></p><p><img src="https://static.1key.run/blog/img/wangluoxieyi-http-6.png"></p><h2 id="3-2-HTTP状态码"><a href="#3-2-HTTP状态码" class="headerlink" title="3.2 HTTP状态码"></a>3.2 HTTP状态码</h2><p>状态代码由三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">1xx消息—— 请求已被服务器接收，继续处理2xx成功 —— 请求已成功被服务器接收、理解、并接受3xx重定向 —— 需要后续操作才能完成这一请求4xx请求错误 —— 请求含有词法错误或者无法被执行5xx服务器错误 —— 服务器在处理某个正确请求时发生错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常见的状态码有：</p><pre class="line-numbers language-TXT" data-language="TXT"><code class="language-TXT">200 OK                        //客户端请求成功400 Bad Request               //客户端请求有语法错误，不能被服务器所理解401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden                 //服务器收到请求，但是拒绝提供服务404 Not Found                 //请求资源不存在，比如：输入了错误的URL500 Internal Server Error     //服务器发生不可预期的错误503 Server Unavailable        //由于超载或系统维护，服务器暂时的无法处理客户端的请求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关于HTTP状态码的完整定义见：<a href="https://tools.ietf.org/html/rfc2616#page-39">https://tools.ietf.org/html/rfc2616#page-39</a></p></blockquote><h1 id="四、HTTPS之密码学基础"><a href="#四、HTTPS之密码学基础" class="headerlink" title="四、HTTPS之密码学基础"></a>四、HTTPS之密码学基础</h1><h2 id="4-1-对称加密算法"><a href="#4-1-对称加密算法" class="headerlink" title="4.1 对称加密算法"></a>4.1 对称加密算法</h2><p>对称加密算法（英文：<code>Symmetric-key algorithm</code>）是指密码学中的一类加密算法，又称为：私钥加密、共享密钥加密。这类算法在加密和解密时使用相同的<strong>密钥</strong>（或者这2个密钥可以通过简单的规则相互推算）。<br>“对称加密算法”比“非对称加密算法”速度更快，但对称加密算法的主要缺点在于要求加密和解密的双方获取相同的密钥，这样只要密钥被泄漏，则密文将不再安全。</p><p><img src="https://static.1key.run/blog/img/wangluoxieyi-http-7.png"></p><p>常见的对称加密算法有：</p><ul><li>DES: <code>Data Encryption Standard</code>, 数据加密标准，速度较快，适用于加密大量数据的场合。</li><li>3DES: <code>Triple DES</code>, 是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。</li><li>AES: <code>Advanced Encryption Standard</code>, 高级加密标准，是下一代的加密算法标准，速度快，安全级别高。</li><li>Blowfish: 一个64位分组及可变密钥长度的对称密钥分组密码算法，可用来加密64比特长度的字符串。</li><li>IDEA: 在DES算法的基础上发展出来的，密钥为128位。</li><li>RC5</li><li>RC6</li></ul><h2 id="4-2-非对称加密算法"><a href="#4-2-非对称加密算法" class="headerlink" title="4.2 非对称加密算法"></a>4.2 非对称加密算法</h2><p>“非对称加密算法”又称为“公开密钥加密”（英语：<code>public-key cryptography</code>）。也一种密码学算法类型，在这类加密算法中，需要一个“密钥对”，即“私钥”和“公钥”。这两个密钥是数学相关，用某个密钥对的“私钥”加密的信息，只能用该密钥对的“公钥”才能解密。同样，用“公钥”加密的信息，也只能用该密钥对的“私钥”才能解密。</p><p>“私钥”一般都是自己保留，不透露给他人；而“公钥”可以公开给他人。</p><p>“非对称加密算法”比“对称加密算法”安全性更高，不用担心加密密钥的泄漏，因为“公钥”是公开的，不存在泄漏。但“私钥”还是要保存妥当，不能泄露给他人，因为我们不需要在网络上传输“私钥”，所以“私钥”泄露的可能性会小很多。</p><p>但是“非对称加密算法”比“对称加密算法”的运算速度慢很多，一般在数据量比较少的时候采用“非对称加密算法”。</p><p><img src="https://static.1key.run/blog/img/wangluoxieyi-http-8.jpg"></p><p>如上图，因为李四的“公钥”是公开的，所以张三要给李四发送信息，可以使用李四的“公钥”来加密信息。李四收到密文信息之后就可以使用自己的“私钥”来解密信息。因为其他人没有李四的“私钥”，所以就算密文信息被他人截获也无法解密。</p><p>常见的非对称加密算法有：</p><ul><li>RSA: 由RSA公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的。</li><li>DSA: <code>Digital Signature Algorithm</code>, 数字签名算法，是一种标准的 DSS（数字签名标准）。</li><li>ECC: <code>Elliptic Curves Cryptography</code>, 椭圆曲线密码编码学。</li></ul><blockquote><p>非对称算法虽然安全，但运算速度很慢，而对称算法的速度虽快，但在管理和传输密钥方面会存在安全隐患。在实际的操作过程中，我们通常采用的方式是：采用“非对称加密算法”管理“对称加密算法”的密钥，然后用“对称加密算法”加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。</p></blockquote><p><strong>使用OpenSSL生成RSA公私钥对</strong></p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">// 生成1024位的私钥openssl genrsa -out d:\rsa_private.pem 1024// 生成私钥对应的公钥openssl rsa -in d:\rsa_private.pem -pubout -out d:\ca_public.pem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>git客户端安装文件中的提供的<code>ssh-keygen.exe</code>工具也可以用来生产非对称加密的公私钥对。</p><h2 id="4-3-散列函数"><a href="#4-3-散列函数" class="headerlink" title="4.3 散列函数"></a>4.3 散列函数</h2><p>散列函数（英文：<code>Hash Function</code>）是将任意长度的的输入转化为定长输出的算法。编程中对散列函数使用非常普遍，如<code>MD5</code>,但并不是所有的散列函数都适用于密码学。密码学的散列函数必须同时具有如下几个额外的特性：</p><ul><li>单向性：给定一个散列值，无法反向找到或者构造出生成它的消息。</li><li>抗碰撞性：给定一个消息和它的散列值，无法找到具有相同散列值的不同的消息。</li></ul><p>散列函数最常用的场合是以紧凑的方式来唯一表示大量数据，如“数字签名”中用到散列函数生成摘要信息等。</p><p>常见的散列函数：</p><ul><li><code>MD5：</code>1991年对MD4的改进版本，该算法不可逆。2004年王小云等人证明了完全碰撞，在理论上说明MD5可以被完全攻破，2005年，Lenstra等人证明了现实中的碰撞，展示了两张完全不同的证书却拥有同样的MD5散列值。所以，目前<code>MD5</code>已经不安全了。</li><li><code> SHA-1：</code>SHA-1在许多安全协议中广为使用，包括TLS和SSL、PGP、SSH、S/MIME和IPsec，曾被视为是MD5的后继者，但因为在理论在已经证明SHA1可以被破解，但限制于计算机的计算能力所以SHA-1被破解还是很困难，所以SHA-1的安全性如今被密码学家严重质疑。</li><li><code>SHA-256：</code>SHA-224、SHA-256、SHA-384、SHA-512一起并称为SHA-2，至今尚找出对SHA-2有效的破解方法。</li></ul><h1 id="五、数字签名与数字证书"><a href="#五、数字签名与数字证书" class="headerlink" title="五、数字签名与数字证书"></a>五、数字签名与数字证书</h1><h2 id="5-1-数字签名"><a href="#5-1-数字签名" class="headerlink" title="5.1 数字签名"></a>5.1 数字签名</h2><p>数字签名（英文：<code>Digital Signature</code>）类似于我们写在纸上的手写签名，它的诞生主要是为了解决如下问题：</p><ol><li>证明该文件（或信息）是由你发送的。</li><li>证明该文件（或信息）没有被他人篡改过。</li></ol><p>其实，我们生活中手写签名的纸质合同也是通过各种形式达到上面2个效果（如：合同一式多份，每份合同都有双方签名等）。</p><p>数字签名利用了“非对称加密算法”，签名和验证签名的过程如下图（图中的“认证”部分不是数字签名必须的，在“数字证书”部分会介绍）：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-http-9.jpg"></p><p>假设“李四”要发送一份数据给“张三”：<br>发送者“李四”对数据生成摘要信息（<code>摘要明文A</code>），然后使用<code>“李四”的“私钥”</code>加密摘要信息；接收者“张三”收到加密的摘要信息之后：</p><ol><li><p>使用<code>“李四”的“公钥”</code>对加密的摘要信息进行解密。若能解密则证明签名是由“李四”所签，这是因为只有<code>“李四”的“私钥”</code>加密的数据才能由<code>“李四”的“公钥”</code>解密，而又只有“李四”才有<code>“李四”的“私钥”</code>。</p></li><li><p>并将数据使用相同的摘要算法自己也生成一份摘要信息（<code>摘要明文B</code>），然后比较A和B。若两者相等，则证明了该数据内容没有被他人篡改过。</p></li></ol><p>通过上面的过程我们可以知道：</p><ol><li>数字签名具有合法性的前提条件是用于加密散列值的<code>“私钥”</code>没有被泄露。</li><li>数字签名不负责数据的加密，若要防止数据被他人窥视，则还要结合其他手段，如使用接收者的“公钥”对数据进行加密等。</li></ol><blockquote><p>如何获取签名者的公钥？如何保证获得的公钥就是签名者的，而不是他人的？基于这些问题，数字签名需要结合后面介绍的数字证书来使用（也就是上图中的“认证”文件）。</p></blockquote><h2 id="5-2-数字证书"><a href="#5-2-数字证书" class="headerlink" title="5.2 数字证书"></a>5.2 数字证书</h2><p>有了上面的公开密钥算法（也就是“非对称加密算法”）之后，我们就可以通过他人的公开密钥（公钥）与其安全通信了，但是还有一些悬而未决的问题：</p><ul><li>如何获取那些从未谋面的人的公钥？</li><li>如何存储和吊销这些公钥？</li><li>如何确保获取的公钥就是那个人的？</li></ul><p>公钥基础设施（<code>public key infrastructure</code>, 简称<code>KPI</code>）就是为了解决这个问题而建立的。<code>PKI</code>的目标就是为了实现不同成员在不见面的情况下进行安全通信的，我们当前采用的PKI模型是基于可信的第三方机构，也就是“证书颁发机构”（<code>certification authority</code>，简称<code>CA</code>）签发的证书。证书中存储了使用“证书颁发机构”的私钥加密之后的申请者的公钥信息。</p><h2 id="5-2-1-数字证书的申请"><a href="#5-2-1-数字证书的申请" class="headerlink" title="5.2.1 数字证书的申请"></a>5.2.1 数字证书的申请</h2><p>数字证书需要向“证书颁发机构”提交申请，并通过审核之后才能颁发。因为数字证书中存储的是申请者的公钥，所以如果申请者的私钥丢失或泄漏，就需要向“证书颁发机构”申请注销该证书。</p><p><code>Web服务器</code>向<code>CA</code>申请证书的流程大致如图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-http-10.jpg"></p><p>“证书”中主要包含了经过<code>“证书颁发机构”的私钥</code>加密过后的<code>申请者的“公钥”</code>、<code>“证书有效期”</code>、<code>“申请者信息（如域名等）”</code>。更详细的信息，可以参考《HTTPS权威指南》第3.3.1章节。</p><h2 id="5-2-2-数字证书的验证"><a href="#5-2-2-数字证书的验证" class="headerlink" title="5.2.2 数字证书的验证"></a>5.2.2 数字证书的验证</h2><p>以“Chrome浏览器”为例：<br>浏览器会内置各大著名的“证书颁发机构”的<code>“公钥”</code>，当收到Web服务器返回的<code>“服务器证书”</code>后，Chrome会尝试使用内置的该“证书颁发机构”的<code>“公钥”</code>来解密该证书，如果能解密则说明该证书是“证书颁发机构”颁发的，且没有被篡改过的。然后通过解密所得的“域名”、“证书有效期”来校验该证书是否为该网站所有，是否过期等。</p><blockquote><p><strong>本文介绍的只是“数字证书”申请和验证的基本的流程，实际流程比这个复杂很多，关于“数字证书”的信息介绍可以参考《HTTPS权威指南》</strong></p></blockquote><h1 id="六、HTTPS"><a href="#六、HTTPS" class="headerlink" title="六、HTTPS"></a>六、HTTPS</h1><p>在HTTP请求过程中，客户端与服务端之前没有进行身份确认，而且传输的数据都没有加密处理，所以很容易被劫持和篡改。</p><p>基于HTTP协议的这些弊端，后面就出现了<code>HTTPS</code>（<strong>严格的说，HTTPS并不是一个协议，所以前面文章都没有使用“HTTPS协议”</strong>），HTTPS是基于<code>SSL/TSL</code>协议的，说白了就是<code>HTTP+SSL/TSL</code>，可以把HTTPS大致理解为<code>“HTTP Over SSL”</code>或者<code>“HTTP Over TSL”</code>。</p><p>HTTP, SSL/TSL, HTTPS的关系如下图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-http-11.jpg"></p><h2 id="6-1-SSL-x2F-TSL协议"><a href="#6-1-SSL-x2F-TSL协议" class="headerlink" title="6.1 SSL/TSL协议"></a>6.1 SSL/TSL协议</h2><h3 id="6-1-1-SSL"><a href="#6-1-1-SSL" class="headerlink" title="6.1.1 SSL"></a>6.1.1 SSL</h3><p>SSL（英文：<code>Secure Sockets Layer</code>的缩写）中文叫“安全套接层”。最开始由NetScape公司研发，用以保障互联网上数据传输的安全，利用数据加密技术确保数据在网络上之传输过程中不会被截取及窃听。<br>SSL协议在TCP/IP协议栈中位于<code>传输层</code>和<code>应用层</code>之间。以<code>HTTPS</code>为例，SSL协议就位于TCP和HTTP之间：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-http-12.gif"></p><h3 id="6-1-2-TLS"><a href="#6-1-2-TLS" class="headerlink" title="6.1.2 TLS"></a>6.1.2 TLS</h3><p>TLS（英文：<code>Transport Layer Security</code>的缩写）中文叫“传输层安全协议”，<code>TLS 1.0</code>是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在<code>SSL 3.0协议</code>规范之上，是<code>SSL 3.0</code>的后续版本，可以理解为SSL 3.1，它定义在<a href="https://tools.ietf.org/html/rfc5246">RFC5246</a>中。</p><p>因为TLS是基于SSL 3.0的，所以也可以认为TLS是SSL的加强版。</p><p><strong>我们一般将二者并称为<code>SSL/TSL协议</code>，因为这二者可以视为同一个产品的不同阶段。</strong></p><h2 id="6-2-SSL-x2F-TSL协议的握手过程"><a href="#6-2-SSL-x2F-TSL协议的握手过程" class="headerlink" title="6.2 SSL/TSL协议的握手过程"></a>6.2 SSL/TSL协议的握手过程</h2><blockquote><p>在了解SSL/TSL协议的握手过程之前，需要先阅读关于HTTPS的前几篇文章，对相关预备知识有所了解。</p></blockquote><p><img src="https://static.1key.run/blog/img/wangluoxieyi-http-13.jpg"></p><p>参考上面的流程图，握手过程可以分为4个步骤：</p><p>1).  客户端发送Client Hello请求到服务端，包含如下内容：</p><ul><li>SSL或TSL协议的版本</li><li>客户端生成的随机串<code>Client random</code>；</li><li>客户端支持的加密算法列表，用于客户端和服务端加密算法的协商；</li><li>客户端支持的HASH算法；</li></ul><p>2). 服务端发送Sever Hello响应到客户端，包含如下内容：</p><ul><li>服务端生成的随机串<code>Server random</code>（第3步会用到）；</li><li>由“CA证书机构”颁发的证书的<code>Public key</code>部分（<code>Public key</code>和<code>Private Key</code>为一对，用于非对称加密和解密）；</li><li>会话ID</li><li>协商的加密算法（对称加密和非对称加密）和HASH算法。</li></ul><p>3). 客户端发送Client Key到服务端，包含如下内容或步骤：</p><ul><li>检查服务端返回的“证书”的有效性，如果无效则在浏览器上显示警告。</li><li>客户端使用前2步生成的<code>Client random</code>和<code>Server random</code>作为随机因子，生成另外一个随机串<code>Premaster</code>。</li><li>使用<code>Public key</code>（第2步服务端返回）非对称加密的随机串<code>Premaster</code>。</li></ul><p>4). 服务端通知客户端握手结束，包含如下内容：</p><ul><li>通过解密出来的<code>Premaster</code>生成的本次会话的<code>Session key</code>。</li><li>前面所有握手内容的HASH值，供客户端校验。</li></ul><blockquote><p>参考：<br><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a><br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> HTTPS </tag>
            
            <tag> TLS/SSL </tag>
            
            <tag> 数字证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(6)--TCP协议</title>
      <link href="/2023/06/21/wang-luo-xie-yi-6-tcp-xie-yi/"/>
      <url>/2023/06/21/wang-luo-xie-yi-6-tcp-xie-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一、TCP特性"><a href="#一、TCP特性" class="headerlink" title="一、TCP特性"></a>一、TCP特性</h1><p>尽管TCP和UDP都是用IP协议作为网络层，但TCP却提供和UDP完全不同的网络服务。TCP是<code>面向连接的</code>、<code>稳定可靠</code>的<code>字节流</code>服务。TCP首部的很多字段都是为了实现这2大特性而设计的。</p><p>在一个TCP连接中，仅有两方能进行彼此通信。所以说广播和多播不适用于TCP协议。</p><p>为了通过IP数据报实现可靠性传输，需要考虑很多事情，如数据的破坏、丢包、重复以及分片顺序混乱等问题。TCP通过检验和、序列号、确认序列号、重发控制、连接管理以及窗口控制等机制来实现可靠性传输。</p><h1 id="二、TCP协议首部"><a href="#二、TCP协议首部" class="headerlink" title="二、TCP协议首部"></a>二、TCP协议首部</h1><p>摘自《TCP/IP详解卷1》中的关于TCP首部定义的图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-1.jpg"></p><p><strong>TCP协议的实现较UDP协议复杂太多，它的首部的各个字段的用法也比UDP首部字段复杂多，这里先对TCP首部字段的功能做个大概的介绍。</strong></p><ul><li>16位源端口号：表示发送端端口号。传输层使用端口号来标识发送端和接收端的应用程序，而网络层是通过IP地址来标识主机，这样使用“IP地址+端口”就可以精确定位到某一台主机上的某一应用程序。</li><li>16位目的端口号：表示接收端端口号。</li><li>32位序列号：序列号用来标识从TCP发送端已经发送的字节数。达到最大值$2^{32}-1$之后，再从0开始。</li><li>32位确认序列号：确认序列号用来标识TCP接收端期望接收的下一个序列号（反过来想也就是，TCP接收端已经接受到的字节数为<code>确认序列号减去1</code>）。<strong>只有<code>ACK标志位</code>为1时，该字段才有效。</strong>只要TCP连接建立，这个字段会一直起作用，也就是说只要TCP连接建立，<code>ACK标志位</code>会一直为1。</li><li>4位首部长度：和IP首部一样，是以<code>4个字节(32 bit)</code>为单位的，所以TCP首部最大长度也是<code>15*4=60</code>字节。若没有“选项”字段，长度固定为20字节。</li><li>6位标志位：他们中的多个可以同时被设置为1。<pre class="line-numbers language-none"><code class="language-none">URG 标记后面的"16位紧急指针"是否有效。ACK 标记前面的"32位确认序号"是否有效。PSH 接收方应该尽快的将这个报文交给上层的网络层。RST 重建连接。SYN 标记这个TCP段是用来同步初始序号（ISN）的。FIN 标记发送端已经完成了发送任务。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>16位窗口大小：窗口大小为字节数，用于TCP的流量控制，这个值是接收端期望接受的字节数。</li><li>16位校验和：和UDP类似，校验和覆盖首部和数据部分。</li><li>16位紧急指针：只有前面提到的<code>URG</code>标记位为1时，这个字段才有效。</li><li>选项：添加一些附加数据。和UDP不同，TCP的“选项”字段使用的比较多。</li></ul><h1 id="三、三次握手与四次挥手"><a href="#三、三次握手与四次挥手" class="headerlink" title="三、三次握手与四次挥手"></a>三、三次握手与四次挥手</h1><h2 id="3-1-完整的TCP会话流程图"><a href="#3-1-完整的TCP会话流程图" class="headerlink" title="3.1 完整的TCP会话流程图"></a>3.1 完整的TCP会话流程图</h2><p>本文通过真实的网络示例来讲解TCP的三次握手和四次挥手。读者可以先<a href="https://static.1key.run/misc/tcp.pcapng">下载</a>作者写本文时使用的网络包示例，然后使用wireshark打开（当然也可以使用wireshark随便抓取一个网络包），选中编号为<code>No.9</code>的包，右键选择“追踪流” –&gt; “TCP流”：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-2.jpg"></p><p><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-3.jpg"></p><p>上图是使用wireshark抓取的一个Http接口请求的过程（不含DNS解析等步骤），包含了TCP连接建立、Http请求、Http响应、TCP连接断开。现在以这个示例为基础，来画出该Http接口请求中涉及的整个TCP会话的流程（也是本文最重要的图）：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-4.png"></p><blockquote><ul><li>箭头上方标出了该TCP包<code>SYN、ACK、FIN、PSH</code>等标志位的设置情况（大家可能注意到，除了第一个箭头上没有<code>ACK</code>之外，其他的箭头上都有<code>ACK</code>，这是因为<code>ACK</code>标记位只是用于标记TCP首部的<code>32位确认序列号</code>是否有效。在此之后的<code>32位确认序列号</code>一直有效，所以也就一直有<code>ACK</code>标记位。）；箭头下发标出了该TCP包的序号和确认序号。</li><li>seq_num：表示32位的序号，紧跟其后括号[]中的是相对序号。</li><li>ack_num：表示32位的确认序号，紧跟其后括号[]中的是相对确认序号。</li><li>payload_len：表示本次TCP携带的数据大小（字节）。</li><li>在三次握手和四次挥手的部分，旁边的红色粗体字表示当前端的TCP状态。<strong>在这个示例中是服务端执行主动关闭。</strong></li></ul></blockquote><h2 id="3-2-Wireshark的相对序号"><a href="#3-2-Wireshark的相对序号" class="headerlink" title="3.2 Wireshark的相对序号"></a>3.2 Wireshark的相对序号</h2><p><code>相对序号</code>是Wireshark引出的概念，TCP协议中没有这个概念。Wireshark使用相对数值来显示序号和确认序号，这个相对值是相对于初始序号（ISN）而言的。因为人类更加习惯跟踪更小数值，所以Wireshark默认用相对数值来展示。如果需要查看真实的序号，可以在wireshark中选中该网络包，在最下方的数据窗口查看，如：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-5.jpg"></p><h2 id="3-3-Wireshark的TCP流量图"><a href="#3-3-Wireshark的TCP流量图" class="headerlink" title="3.3 Wireshark的TCP流量图"></a>3.3 Wireshark的TCP流量图</h2><p>我们也可以使用Wireshark自带的统计功能来查看整个TCP会话的过程。通过菜单“统计” –&gt; “流量图”打开流量图窗口，在“显示”选项选择“显示的分组”，“流类型”选项选择“TCP流”，如图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-6.jpg"></p><h1 id="四、TIME-WAIT及MSL"><a href="#四、TIME-WAIT及MSL" class="headerlink" title="四、TIME_WAIT及MSL"></a>四、TIME_WAIT及MSL</h1><h2 id="4-1-TIME-WAIT状态为何存在？"><a href="#4-1-TIME-WAIT状态为何存在？" class="headerlink" title="4.1 TIME_WAIT状态为何存在？"></a>4.1 TIME_WAIT状态为何存在？</h2><p>这里我们不使用“客户端”、“服务端”来表示TCP连接的2端，转而使用“主动断开连接端”、“被动断开连接端”来表示TCP通讯的2端。因为执行主动断开连接的端可能是服务端也可能是客户端（虽然我们大多数情况下遇到的是客户端执行主动断开）。</p><p>在“主动断开连接端”收到了“被动断开连接端”发来的<code>LAST_ACK</code>之后，会给“被动断开连接端”回复一个<code>ACK</code>确认消息。但这个时候为了确保“被动断开连接端”有足够的时间能够收到该消息，“主动断开连接端”不能马上关闭socket，需要等待一定的时间来确保“被动断开连接端”可以收到<code>ACK</code>确认消息。“主动断开连接端”在等待的这个时间段内的状态我们称之为<code>TIME_WAIT</code>状态。</p><p>归纳为一句话就是：<strong>TIME_WAIT状态就是“主动断开的一方”在发送完最后一次ACK后进入的等待状态。</strong></p><h2 id="4-2-等待时间"><a href="#4-2-等待时间" class="headerlink" title="4.2 等待时间"></a>4.2 等待时间</h2><p>那么<code>TIME_WAIT</code>状态需要持续多久了，也就是“主动断开连接端”在发送完最后一个ACK之后需要等待多久了？<br><a href="http://www.52im.net/topic-tcpipvol1.html">《TCP/IP详解 卷1：协议》</a>中提到：默认TIME_WAIT的超时时间是2倍的MSL。MSL是<code>Maximum Segment Lifetime</code>的缩写，表示报文的最大生存时间，这个时间和系统的TCP实现有关，每个系统是不一样的。</p><h3 id="4-2-1-windows系统MSL"><a href="#4-2-1-windows系统MSL" class="headerlink" title="4.2.1 windows系统MSL"></a>4.2.1 windows系统MSL</h3><p>注册表<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters</code>下的<code>TcpTimedWaitDelay</code>键（如果没有可以新建一个）就对应了<code>2*MSL</code>（2倍的MSL）的值。<br><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-7.jpg"></p><h3 id="4-2-2-Linux系统MSL"><a href="#4-2-2-Linux系统MSL" class="headerlink" title="4.2.2 Linux系统MSL"></a>4.2.2 Linux系统MSL</h3><p>以CentOS为例（<strong>摘自网络，仅供参考</strong>）：</p><ul><li><p>查看默认的MSL值（60s）：</p><pre class="line-numbers language-none"><code class="language-none">cat /proc/sys/net/ipv4/tcp_fin_timeout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改默认为120：</p><pre class="line-numbers language-none"><code class="language-none">echo 120 &gt; /proc/sys/net/ipv4/tcp_fin_timeout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改完成后，重新加载配置文件：</p><pre class="line-numbers language-none"><code class="language-none">sysctl -p /etc/sysctl.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看是否已经生效：</p><pre class="line-numbers language-none"><code class="language-none">sysctl -a | grep fin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="4-3-SO-REUSEADDR"><a href="#4-3-SO-REUSEADDR" class="headerlink" title="4.3 SO_REUSEADDR"></a>4.3 SO_REUSEADDR</h2><ul><li><p>如果进程中的某个TCP连接处于<code>TIME_WAIT</code>等待状态，因为这个等待时间比较长，在这期间该连接使用的端口将一直被占用。</p></li><li><p>如果一个服务端进程（绑定了某个端口）退出（正常退出或异常退出）后，立即启动一个新的该进程，可能由于Windows系统对端口的释放不及时，导致这个端口还没有被释放，不能被再次绑定，从而导致新进程绑定端口失败。</p></li></ul><p>那么遇到上面的问题如何解决了？<br>我们在网络编程中经常设置的<code>SO_REUSEADDR</code>选项就可以解决这个问题，</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int flag = 1;setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast&lt;const char*&gt;(&amp;flag), sizeof(flag));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong><code>SO_REUSEADDR</code>提供如下四个功能：</strong></p><ul><li><p>SO_REUSEADDR允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在。这通常是重启监听服务器时出现，若不设置此选项，则<code>bind</code>时将出错。</p></li><li><p>SO_REUSEADDR允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可。对于TCP，我们根本不可能启动捆绑相同IP地址和相同端口号的多个服务器。</p></li><li><p>SO_REUSEADDR允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地IP地址即可。这一般不用于TCP服务器。</p></li><li><p>SO_REUSEADDR允许完全重复的捆绑：当一个IP地址和端口绑定到某个套接口上时，还允许此IP地址和端口捆绑到另一个套接口上。一般来说，这个特性仅在支持多播的系统上才有，而且只对UDP套接口而言（TCP不支持多播）。</p></li></ul><p>其中第一个功能就可以用来解决该问题。</p><h1 id="五、为什么要进行3次握手？"><a href="#五、为什么要进行3次握手？" class="headerlink" title="五、为什么要进行3次握手？"></a>五、为什么要进行3次握手？</h1><p>前面的文章介绍了TCP的三次握手，那么TCP的握手为什么是3次了？</p><p><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-8.png"></p><p>本文从3个角度来解释为什么要进行3次握手？</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>TCP的握手的目的是让通信双方都确定双方能够正常发送和接收信息。</p><p>第一步，服务端收到客户端发送的SYN，服务端能够确定如下信息：“客户端的发送功能正常，服务端自己的接受功能正常”。但客户端还什么都不能确定。<br>第二步，客户端收到服务端回复的SYN+ACK，截至目前，客户端能够确定如下信息：“客户端自己的发送/接收功能都正常，服务端的接收和发送功能都正常”；服务端还是只能确定自己的接受功能正常，还不知道自己的发送功能是否正常，客户端的接受功能是否正常。</p><p>大家可以看到，到第二步完成，客户端和服务端能够确认的信息分别如下：</p><pre class="line-numbers language-none"><code class="language-none">客户端能够确定：  客户端-发送 正常  客户端-接收 正常  服务端-发送 正常  服务端-接收 正常服务端能够确定：  客户端-发送 正常  客户端-接收 ？  服务端-发送 ？  服务端-接收 正常<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面表可以看到，第二步完成之后，服务端还能不能确定“服务端的发送功能”和“客户端的接收功能”是否正常。所以需要第三步。</p><p>第三步，服务端收到客户端回复的ACK，服务端能够确定如下信息：客户端的发送功能正常，服务端的接收功能正常。</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>我们可以假设“客户端”和“服务端”是2个人，模拟这2个人打招呼的形式来理解为什么需要3次握手。</p><pre class="line-numbers language-none"><code class="language-none">客户端：hi，服务端，你能听到我说话吗？服务端：hi，客户端，我能听到你说的话，你能听到我说的话吗？客户端：嗯，服务端，我也能听到你说的话。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>对照文章开始处TCP握手图的前2步，现在我们假设TCP只有2次握手：</p><p>服务端在收到客户端的<code>SYN</code>并且回复<code>SYN+AKC</code>之后，就认为连接已经建立完成了，并为之分配相应的资源。<br>但客户机却因为网络延迟等问题一直没收到服务端回复的<code>SYN+ACK</code>，这样客户端就认为连接没有建立成功，糟糕的是，客户端会因为连接没有成功而不停的重试，这样每次服务端都会认为连接建立成功并分配资源。</p><p>如果按照上面描述的那样，客户端一直没有收到服务端回复的<code>SYN+ACK</code>，且一直这样尝试建立连接，就会造成服务端资源极大的浪费，加重服务端的负担。</p><h1 id="六、为什么要进行4次挥手？"><a href="#六、为什么要进行4次挥手？" class="headerlink" title="六、为什么要进行4次挥手？"></a>六、为什么要进行4次挥手？</h1><p><img src="https://static.1key.run/blog/img/wangluoxieyi-tcp-9.png"></p><p>对比上面的图，我们不难发现：4次挥手相比3次握手多了一次，主要是因为握手的<code>ACK和SYN</code>是合并在一条发送的，而挥手的<code>ACK和FIN</code>是分开发送的，所以挥手比握手多了一次。</p><p><strong>现在我们分析为什么TCP挥手的<code>ACK和FIN</code>（分别对应图中的第2,3条线）要分开发送？</strong></p><p><code>“被动断开方”</code>之所以叫称之为“被动”是因为TCP连接的断开并不是它想的，也不是它主动触发的，是对面的<code>“主动断开方”</code>想要断开的，也许这个时候<code>“被动断开方”</code>还正想发送点数据给<code>“主动断开方”</code>了。</p><p>为了让<code>“被动断开方”</code>有机会将想要发送的数据发送完，主动断开方在发送完<code>FIN</code>并收到了<code>ACK</code>确认信息进入<code>FIN_WAIT_2</code>状态后，只关闭了发送功能了，但仍然保留接收功能。这样<code>“被动断开方”</code>就有机会将没有发送完的数据发送完成，发送完成之后，<code>“被动断开方”</code>也发送一个<code>FIN</code>，相当于告诉<code>“主动断开方”</code>：“我的数据已经发完了呀，以后不会再发数据了，你可以安心的把接收功能关闭了，另外我自己也要关闭了呀”。</p><blockquote><p>《TCP/IP详解 卷1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 三次握手 </tag>
            
            <tag> 四次挥手 </tag>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(5)--UDP协议</title>
      <link href="/2023/06/21/wang-luo-xie-yi-5-udp-xie-yi/"/>
      <url>/2023/06/21/wang-luo-xie-yi-5-udp-xie-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、什么是UDP协议？"><a href="#一、什么是UDP协议？" class="headerlink" title="一、什么是UDP协议？"></a>一、什么是UDP协议？</h2><p>UDP是User Datagram Protocol的简称，中文名是用户数据报协议，是OSI参考模型中的传输层协议，它是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。<br>UDP的正式规范是<a href="https://www.ietf.org/rfc/rfc768.txt">IETF RFC768</a>。UDP在IP报文的协议号是17。</p><blockquote><p>ISO七层模型：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-udp-1.jpg"></p></blockquote><h2 id="二、UDP报头"><a href="#二、UDP报头" class="headerlink" title="二、UDP报头"></a>二、UDP报头</h2><p>UDP报头的结构如图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-udp-2.jpg"></p><p>UDP报头由4个部分组成，其中两个是可选的（粉红背景标出部分）：</p><ul><li><p>各16bit的<code>来源端口</code>和<code>目的端口</code>用来标记发送和接受的应用进程。因为UDP不需要应答，所以来源端口是可选的，如果来源端口不用，那么置为零。</p></li><li><p>在目的端口后面是长度固定的以字节为单位的报文长度域，用来指定UDP数据报包括数据部分的长度，长度最小值为8byte。</p></li><li><p>首部剩下地16bit是用来对首部和数据部分一起做<code>校验和</code>（Checksum）的，这部分是可选的，但在实际应用中一般都使用这一功能。</p></li><li><p>UDP和TCP的<code>校验和</code>都覆盖到了他们的首部和数据，而之前介绍的IP首部的<code>校验和</code>只覆盖了IP首部。</p></li></ul><h2 id="三、TCP和UDP区别"><a href="#三、TCP和UDP区别" class="headerlink" title="三、TCP和UDP区别"></a>三、TCP和UDP区别</h2><table><thead><tr><th>特征点</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接</td><td>面向非连接</td></tr><tr><td>传输可靠性</td><td>可靠</td><td>会丢包，不可靠</td></tr><tr><td>应用场景</td><td>传输数据量大</td><td>传输量小</td></tr><tr><td>速度</td><td>慢</td><td>快</td></tr></tbody></table><p>TCP(传输控制协议)提供的是面向连接、可靠的字节流服务。当客户端和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。<br>UDP(用户数据报协议)是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。</p><p>由于UDP缺乏拥塞控制（congestion control），需要基于网络的机制来减少因失控和高速UDP流量负荷而导致的拥塞崩溃效应。换句话说，因为UDP发送者不能够检测拥塞，所以像使用包队列和丢弃技术的路由器这样的网络基本设备往往就成为降低UDP过大通信量的有效工具。数据报拥塞控制协议（DCCP）设计成通过在诸如流媒体类型的高速率UDP流中，增加主机拥塞控制，来减小这个潜在的问题。</p><h2 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景"></a>四、应用场景</h2><p>由于缺乏可靠性且属于非连接导向协议，UDP的应用一般必须允许一定量的丢包、出错和复制粘贴。但有些应用，比如TFTP，需要可靠性保证，则必须在应用层增加根本的可靠机制。但是绝大多数UDP应用都不需要可靠机制，甚至可能因为引入可靠机制而降低性能。流媒体、即时多媒体游戏和IP电话（VoIP）就是典型的UDP应用。如果某个应用需要很高的可靠性，那么可以用传输控制协议（即TCP协议）来代替UDP。</p><p>使用UDP协议的应用有：域名系统（DNS）、简单网络管理协议（SNMP）、动态主机配置协议（DHCP）、路由信息协议（RIP）等等。</p><p>因为UDP不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失几个数据包，也不会对接收结果产生太大影响。</p><h2 id="五、单播、多播、广播、组播"><a href="#五、单播、多播、广播、组播" class="headerlink" title="五、单播、多播、广播、组播"></a>五、单播、多播、广播、组播</h2><p>假设A(all简写)代表所有的机器，M(multiple简写)代表A中的多个机器，G(group简写)代表一组机器，1代表一台机器，那么：</p><pre class="line-numbers language-none"><code class="language-none">1 -&gt; 1 就是单播；1 -&gt; M 就是多播；1 -&gt; A 就是广播；1 -&gt; G 就是组播；当M=A时，多播就是广播；当M=G时，多播就是组播；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多播包括组播和广播，组播、广播都是多播的一种表现形式。</p><h3 id="5-1-单播"><a href="#5-1-单播" class="headerlink" title="5.1 单播"></a>5.1 单播</h3><p>单播是主机之间“一对一”的通讯模式。发送方需要指定一个接收方的IP和端口，只有这个接收方会收到数据报。不会对子网内的其他机器产生影响。<br>在单播模式下，服务器针对每个客户机都要发送数据流，<code>服务器流量=客户机数量×客户机流量</code>，在客户机数量大、每个客户机流量大的应用（如流媒体）中，服务器将不堪重负。</p><h4 id="5-1-1-单播发送端"><a href="#5-1-1-单播发送端" class="headerlink" title="5.1.1 单播发送端"></a>5.1.1 单播发送端</h4><p>因为UDP不是面向连接的，且不可靠的，所以发送端在调用<code>sendto</code>之后，就算<code>sendto</code>返回成功，也不代表接收端一定收到了数据，可能接收端压根都没启动，也是有可能的。不能根据<code>sendto</code>的返回值来确保接收端一定收到了数据。如果需要数据传输的可靠性得到保证，可以使用TCP或者通过业务逻辑来保证。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;WinSock2.h&gt;#pragma comment(lib, "Ws2_32.lib")void SendLogic() {WSADATA wsaData;WORD wVersionRequested = MAKEWORD(1, 0);WSAStartup(wVersionRequested, &amp;wsaData);SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0);if (socket == INVALID_SOCKET) {printf("WSASocket failed, error=%d\n", WSAGetLastError());return;}sockaddr_in addr;addr.sin_family = AF_INET;addr.sin_port = htons(6000);  // 接收端端口addr.sin_addr.s_addr = inet_addr("127.0.0.1"); // 接收端IPchar buf[100] = { "hello" };int err = sendto(socket, buf, strlen(buf), 0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr));if (err == SOCKET_ERROR) {printf("sendto failed, error=%d\n", WSAGetLastError());return;}printf("[SEND] %s OK\n", buf);WSACleanup();}int main(){SendLogic();getchar();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-1-2-单播接收端"><a href="#5-1-2-单播接收端" class="headerlink" title="5.1.2 单播接收端"></a>5.1.2 单播接收端</h4><p>因为UDP不是面向连接的，所以接收端不用listen，也不用accept，只需要绑定到指定的端口和地址即可。<br><code>recvfrom</code>是同步的，会阻塞住等待数据的到来。如果要使用异步方式，可以使用<code>WSARecvFrom</code>结合ICOP的方式来实现。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;WinSock2.h&gt;#pragma comment(lib, "Ws2_32.lib")void RecvLogic() {WSADATA wsaData;WORD wVersionRequested = MAKEWORD(1, 0);WSAStartup(wVersionRequested, &amp;wsaData);SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0);if (socket == INVALID_SOCKET) {printf("WSASocket failed, error=%d\n", WSAGetLastError());return;}sockaddr_in addr;addr.sin_family = AF_INET;addr.sin_port = htons(6000);  // 端口addr.sin_addr.s_addr = INADDR_ANY;  // 任意IP地址int err = bind(socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr));if (err == SOCKET_ERROR) {printf("bind failed, error=%d\n", WSAGetLastError());return;}while (true) { // TODO：未考虑退出的情况char buf[100] = { 0 };int fromlen = sizeof(addr);err = recvfrom(socket, buf, 100, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;addr), &amp;fromlen);if (err == SOCKET_ERROR) {printf("recvfrom failed, error=%d\n", WSAGetLastError());return;}printf("[RECV] %s\n", buf);}WSACleanup();}int main(){RecvLogic();getchar();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-广播"><a href="#5-2-广播" class="headerlink" title="5.2 广播"></a>5.2 广播</h3><p>广播是主机之间“一对所有”的通讯模式。子网的一台主机作为发送发广播一条信息，该子网中的所有主机都可以接收到该信息（不管你是否需要该信息）。<br>在广播模式下，由于服务器不用向每个客户机单独发送数据，所以服务器流量负载极低。<br>无法在广域网上进行广播，而且广播消息不会被路由转发，所以只能在一个子网中进行广播。因为如果路由器转发了广播信息，那么势必会引起网络瘫痪。这也是为什么IP协议的设计者故意没有定义互联网范围的广播机制。</p><p>主机发送广播消息时，需要指定目的IP地址为<code>255.255.255.255</code>和接受者的端口号。</p><p>UDP的广播和单播的不同在于发送端（接收端的实现和单播方式没有区别）的实现上：</p><ol><li>发送端将套接字配置为发送广播消息，使用<code>setsockopt</code>函数。</li><li>发送地址更改为受限的广播地址<code>255.255.255.255</code>。</li></ol><blockquote><p>需要说明的是广播地址不仅仅只有<code>255.255.255.255</code>一个。广播地址分为受限的广播、指向网络的广播、指向子网的广播、指向所有子网的网广播。<code>255.255.255.255</code>只是受限的广播地址。</p></blockquote><h4 id="5-2-1-广播发送端"><a href="#5-2-1-广播发送端" class="headerlink" title="5.2.1 广播发送端"></a>5.2.1 广播发送端</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;WinSock2.h&gt;#pragma comment(lib, "Ws2_32.lib")void SendLogic() {WSADATA wsaData;WORD wVersionRequested = MAKEWORD(1, 0);WSAStartup(wVersionRequested, &amp;wsaData);SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0);if (socket == INVALID_SOCKET) {printf("WSASocket failed, error=%d\n", WSAGetLastError());return;}// 将套接字配置为发送广播消息int broadcast = 1;int err = setsockopt(socket, SOL_SOCKET, SO_BROADCAST, reinterpret_cast&lt;const char*&gt;(&amp;broadcast), sizeof(int));if (err == SOCKET_ERROR) {printf("setsockopt failed, error=%d\n", WSAGetLastError());return;}sockaddr_in addr;addr.sin_family = AF_INET;addr.sin_port = htons(6000);addr.sin_addr.s_addr = INADDR_BROADCAST; // 也可以换成inet_addr("255.255.255.255")char buf[100] = { "hello" };err = sendto(socket, buf, strlen(buf), 0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr));if (err == SOCKET_ERROR) {printf("sendto failed, error=%d\n", WSAGetLastError());return;}printf("[BROADCAST] %s OK\n", buf);WSACleanup();}int main(){SendLogic();getchar();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-2-2-广播接收端-和单播一样"><a href="#5-2-2-广播接收端-和单播一样" class="headerlink" title="5.2.2 广播接收端(和单播一样)"></a>5.2.2 广播接收端(和单播一样)</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;WinSock2.h&gt;#pragma comment(lib, "Ws2_32.lib")void RecvLogic() {WSADATA wsaData;WORD wVersionRequested = MAKEWORD(1, 0);WSAStartup(wVersionRequested, &amp;wsaData);SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0);if (socket == INVALID_SOCKET) {printf("WSASocket failed, error=%d\n", WSAGetLastError());return;}sockaddr_in addr;addr.sin_family = AF_INET;addr.sin_port = htons(6000);addr.sin_addr.s_addr = INADDR_ANY;int err = bind(socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr));if (err == SOCKET_ERROR) {printf("bind failed, error=%d\n", WSAGetLastError());return;}while (true) {char buf[100] = { 0 };int fromlen = sizeof(addr);err = recvfrom(socket, buf, 100, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;addr), &amp;fromlen);if (err == SOCKET_ERROR) {printf("recvfrom failed, error=%d\n", WSAGetLastError());return;}printf("[RECV] %s\n", buf);}WSACleanup();}int main(){RecvLogic();getchar();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-组播"><a href="#5-3-组播" class="headerlink" title="5.3 组播"></a>5.3 组播</h3><p>组播是主机之间“一对多”的通讯模式。一台主机加入一个组播IP后，之后向该组播IP发送的数据报都会发送到该主机。<br>专门为组播划出了一个地址范围，在IPv4中为D类地址，范围是<code>224.0.0.0 ~ 239.255.255.255</code>，并将D类地址划分为局部链接组播地址、预留组播地址、管理权限组播地址如下：<br>局部链接地址：<code>224.0.0.0～224.0.0.255</code>，用于局域网，路由器不转发属于此范围的IP包。</p><p>预留组播地址：<code>224.0.1.0～238.255.255.255</code>，用于全球范围或网络协议。</p><p>管理权限地址：<code>239.0.0.0～239.255.255.255</code>，组织内部使用，用于限制组播范围。</p><p>组播就是将数据发送到一组主机。接收端如果要接收消息，则需要加入到该分组，分组是用IP来标识的。<br>从<a href="/2023/06/20/wang-luo-xie-yi-3-ip-xie-yi/" title="网络协议(3)--IP协议">网络协议(3)--IP协议</a>可以知道，适用于分组的IP有<code>224.0.0.0 ~ 239.255.255.255</code>。<br>同样，发送端就需要将数据发送到该分组IP。</p><h4 id="5-3-1-组播发送端"><a href="#5-3-1-组播发送端" class="headerlink" title="5.3.1 组播发送端"></a>5.3.1 组播发送端</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;WinSock2.h&gt;#pragma comment(lib, "Ws2_32.lib")void SendLogic() {WSADATA wsaData;WORD wVersionRequested = MAKEWORD(1, 0);WSAStartup(wVersionRequested, &amp;wsaData);SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0);if (socket == INVALID_SOCKET) {printf("WSASocket failed, error=%d\n", WSAGetLastError());return;}// 将套接字配置为发送广播消息int broadcast = 1;int err = setsockopt(socket, SOL_SOCKET, SO_BROADCAST, reinterpret_cast&lt;const char*&gt;(&amp;broadcast), sizeof(int));if (err == SOCKET_ERROR) {printf("setsockopt failed, error=%d\n", WSAGetLastError());return;}sockaddr_in addr;addr.sin_family = AF_INET;addr.sin_port = htons(6000);addr.sin_addr.s_addr = inet_addr("225.0.0.37"); // 向指定广播组发送消息char buf[100] = { "hello" };err = sendto(socket, buf, strlen(buf), 0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr));if (err == SOCKET_ERROR) {printf("sendto failed, error=%d\n", WSAGetLastError());return;}printf("[BROADCAST] %s OK\n", buf);WSACleanup();}int main(){SendLogic();getchar();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-2-组播接收端"><a href="#5-3-2-组播接收端" class="headerlink" title="5.3.2 组播接收端"></a>5.3.2 组播接收端</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;WinSock2.h&gt;#include &lt;Ws2ipdef.h&gt;#pragma comment(lib, "Ws2_32.lib")void RecvLogic() {WSADATA wsaData;WORD wVersionRequested = MAKEWORD(1, 0);WSAStartup(wVersionRequested, &amp;wsaData);SOCKET socket = ::WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, nullptr, 0, 0);if (socket == INVALID_SOCKET) {printf("WSASocket failed, error=%d\n", WSAGetLastError());return;}sockaddr_in addr;addr.sin_family = AF_INET;addr.sin_port = htons(6000);addr.sin_addr.s_addr = htonl(INADDR_ANY);int err = bind(socket, reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr), sizeof(addr));if (err == SOCKET_ERROR) {printf("bind failed, error=%d\n", WSAGetLastError());return;}// 将SOCKET加入广播组//struct ip_mreq mreq; // 引入头文件&lt;Ws2ipdef.h&gt;mreq.imr_multiaddr.s_addr = inet_addr("225.0.0.37");  // 广播组地址mreq.imr_interface.s_addr = htonl(INADDR_ANY);// 注：使用IP_DROP_MEMBERSHIP可以离开广播组err = setsockopt(socket, IPPROTO_IP, IP_ADD_MEMBERSHIP, reinterpret_cast&lt;const char*&gt;(&amp;mreq), sizeof(ip_mreq));if (err == SOCKET_ERROR) {printf("setsockopt failed, error=%d\n", WSAGetLastError());return;}while (true) {char buf[100] = { 0 };int fromlen = sizeof(addr);err = recvfrom(socket, buf, 100, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;addr), &amp;fromlen);if (err == SOCKET_ERROR) {printf("recvfrom failed, error=%d\n", WSAGetLastError());return;}printf("[RECV] %s\n", buf);}WSACleanup();}int main(){RecvLogic();getchar();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>《TCP/IP详解 卷1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UDP </tag>
            
            <tag> 单播 </tag>
            
            <tag> 多播 </tag>
            
            <tag> 广播 </tag>
            
            <tag> 组播 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(4)--ICMP协议</title>
      <link href="/2023/06/21/wang-luo-xie-yi-4-icmp-xie-yi/"/>
      <url>/2023/06/21/wang-luo-xie-yi-4-icmp-xie-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><p>互联网控制消息协议（英文：<code>Internet Control Message Protocol</code>，ICMP）是互联网协议族的核心协议之一。定义在RFC 792文档中。<br>ICMP的消息大致可以分为两类：一类是差错报文，即通知出错原因的错误消息（如<code>traceroute</code>），另一类是查询报文，即用于诊断的查询消息（如<code>ping</code>）。<br>使用ICMP协议的典型应用有<code>ping</code>和<code>traceroute</code>（windows上叫<code>tracert</code>）。</p><p><strong>ICMP是在IP数据报的内部被传输的，紧跟着IP报文的首部（如果IP首部有可选部分，则紧跟着可选部分）</strong>：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-icmp-1.jpg"><br><strong>图上的IP首部20字节是在IP报文首部不含可选部分的情况下，若IP首部含可选部分，则大于20字节。</strong></p><h1 id="一、-ICMP报文格式"><a href="#一、-ICMP报文格式" class="headerlink" title="一、 ICMP报文格式"></a>一、 ICMP报文格式</h1><p><img src="https://static.1key.run/blog/img/wangluoxieyi-icmp-2.jpg"><br><strong>所有ICMP报文的前4个字节都是一样的，但剩下的其他字节则根据报文类型的不同而不同。</strong></p><ul><li><p><code>8位类型字段</code>和<code>8位代码字段</code>共同决定一种ICMP报文的类型。<br><img src="https://static.1key.run/blog/img/wangluoxieyi-icmp-3.jpg"></p></li><li><p>校验和的计算方法和IP首部校验和的计算方式相同，但ICMP校验和覆盖整个ICMP报文。</p><blockquote><p>IP首部校验和的计算方式和原理参考：<a href="/2023/06/20/wang-luo-xie-yi-3-ip-xie-yi/" title="网络协议(3)--IP协议">网络协议(3)--IP协议</a><br>UDP和TCP的校验和同样也都覆盖到了他们的首部和数据。</p></blockquote></li></ul><blockquote><p>《TCP/IP详解 卷1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p></blockquote><h1 id="二、实际应用"><a href="#二、实际应用" class="headerlink" title="二、实际应用"></a>二、实际应用</h1><h2 id="2-1-Ping"><a href="#2-1-Ping" class="headerlink" title="2.1 Ping"></a>2.1 Ping</h2><h3 id="2-1-1-Ping程序原理"><a href="#2-1-1-Ping程序原理" class="headerlink" title="2.1.1 Ping程序原理"></a>2.1.1 Ping程序原理</h3><p>大多数系统都已经在内核中内置了ping服务器的功能，所以不需要单独的其他进程来接收主机的ping请求。</p><p>windows系统下，输入<code>ping /?</code>命令查看ping的用法如下：</p><pre class="line-numbers language-none"><code class="language-none">用法: ping [-t] [-a] [-n count] [-l size] [-f] [-i TTL] [-v TOS]           [-r count] [-s count] [[-j host-list] | [-k host-list]]           [-w timeout] [-R] [-S srcaddr] [-4] [-6] target_name选项:    -t             Ping 指定的主机，直到停止。                   若要查看统计信息并继续操作 - 请键入 Control-Break；                   若要停止 - 请键入 Control-C。    -a             将地址解析成主机名。    -n count       要发送的回显请求数。    -l size        发送缓冲区大小。    -f             在数据包中设置“不分段”标志(仅适用于 IPv4)。    -i TTL         生存时间。    -v TOS         服务类型(仅适用于 IPv4。该设置已不赞成使用，且                   对 IP 标头中的服务字段类型没有任何影响)。    -r count       记录计数跃点的路由(仅适用于 IPv4)。    -s count       计数跃点的时间戳(仅适用于 IPv4)。    -j host-list   与主机列表一起的松散源路由(仅适用于 IPv4)。    -k host-list   与主机列表一起的严格源路由(仅适用于 IPv4)。    -w timeout     等待每次回复的超时时间(毫秒)。    -R             同样使用路由标头测试反向路由(仅适用于 IPv6)。    -S srcaddr     要使用的源地址。    -4             强制使用 IPv4。    -6             强制使用 IPv6。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>-r</code>参数用于记录跃点路由，类似tracert的功能，但他们的实现方式不一样，ping是通过在IP头部“选项”字段记录经过的每个路由的IP来实现记录路由功能的，这种实现有个限制，就是IP首部“选项”字段的最大字节数为40字节，所以最多只能记录10个IP。</p><p>ping功能通过ICMP的回显请求和回显应答来实现，也就是说ping是基于ICMP协议实现的。</p><p>ICMP回显请求和回显应答的报文格式如下：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-icmp-4.jpg"></p><ul><li>标识符：在实现中，一般将该字段设置为当前进程ID。这样即使在同一台主机上同时运行了多个ping程序实例， ping程序也可以识别出返回的信息属于哪个进程。</li><li>序号：序号一般从0开始（没有强制性，从任何数字开始都可以），每发送一次新的回显请求就加1。因为ICMP是在IP数据报内部被传输的，而IP协议又是不可靠、无连接的，所以ping程序打印出返回的每个分组的序列号，方便我们查看是否有分组丢失、失序或重复。 </li><li>选项：在“选项”字段中，我们一般放入发送时间戳，这样在收到回应的时候可以用来计算本次ping的耗时。我们经常会指定ping包的大小，所以也会在“选项”字段中填充一些废数据来让包达到一定大小，在下面的<code>FillPingPacket</code>函数就有这样的实现。</li></ul><h3 id="2-1-2-C-代码实现"><a href="#2-1-2-C-代码实现" class="headerlink" title="2.1.2 C++代码实现"></a>2.1.2 C++代码实现</h3><h4 id="定义ICMP、ping首部"><a href="#定义ICMP、ping首部" class="headerlink" title="定义ICMP、ping首部"></a>定义ICMP、ping首部</h4><p><code>networkprotocolheader.h</code>头文件中定义了IP协议、ICMP协议等协议的首部结构体。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma pack(1)#define __u8 unsigned char#define __u16 unsigned short#define __u32 unsigned longstruct icmp_common_hdr {__u8 type;__u8 code;__u16 check;/*Other content start here. */};struct ping_header {icmp_common_hdr common_hdr;__u16 id;__u16 seq;__u32 timestamp;};#pragma pack()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="程序执行参数"><a href="#程序执行参数" class="headerlink" title="程序执行参数"></a>程序执行参数</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">DECLARE_bool(h); // 帮助DECLARE_bool(t); // ping指定的主机直到停止DECLARE_int(w);  // 等待每次回复的超时时间(毫秒)DECLARE_int(s);  // 发送ping包超时时间(毫秒)DECLARE_int(l);  // 发送缓冲区大小DECLARE_int(i);  // TTLDEFINE_bool(h, false, "帮助");DEFINE_bool(t, false, "ping指定的主机直到停止");DEFINE_int(w, 3000, "等待每次回复的超时时间(毫秒)");DEFINE_int(s, 3000, "发送ping包超时时间(毫秒)");DEFINE_int(l, 32, "发送缓冲区大小");DEFINE_int(i, 128, "TTL");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ping程序的执行参数的定义和解析由webrtc的<code>"rtc_base/flags.h"</code>支持。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>代码中的某些功能，如参数解析、断言、时间戳等基于webrtc的<code>rtc_base</code>实现，这些功能也可以很方便的自己实现。</p><p>另外，使用原始套接字需要管理员权限，如果需要绕开管理员权限，可以使用windows提供的<code>IcmpSendEcho</code>系列函数。</p><p><strong>在发送ping请求的时候，我们只封装了一个ICMP报文，并没有自己手动添加IP头，封装IP报文。因为内核会自动添加IP头，如果想自己添加IP头，可以调用<code>setsockopt</code>设置<code>IP_HDRINCL</code>选项，告诉内核由我们自己来封装IP头。</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;WinSock2.h&gt;#include &lt;ws2spi.h&gt;#include &lt;ws2tcpip.h&gt;#include "rtc_base/networkprotocolheader.h"#include "rtc_base/checks.h"#include "rtc_base/flags.h"#include "rtc_base/timeutils.h"DECLARE_bool(h); // 帮助DECLARE_bool(t); // ping指定的主机直到停止DECLARE_int(w);  // 等待每次回复的超时时间(毫秒)DECLARE_int(s);  // 发送ping包超时时间(毫秒)DECLARE_int(l);  // 发送缓冲区大小DECLARE_int(i);  // TTLDEFINE_bool(h, false, "帮助");DEFINE_bool(t, false, "ping指定的主机直到停止");DEFINE_int(w, 3000, "等待每次回复的超时时间(毫秒)");DEFINE_int(s, 3000, "发送ping包超时时间(毫秒)");DEFINE_int(l, 32, "发送数据大小");DEFINE_int(i, 128, "TTL");void FillPingPacket(__u8* icmp_packet, __u16 seq, __u16 icmp_packet_size) {RTC_DCHECK(icmp_packet);ping_hdr* pping_hdr = reinterpret_cast&lt;ping_hdr*&gt;(icmp_packet);pping_hdr-&gt;common_hdr.type = 8;pping_hdr-&gt;common_hdr.code = 0;pping_hdr-&gt;id = (__u16)GetCurrentProcessId();pping_hdr-&gt;seq = seq;__u32 now = rtc::Time32();memcpy((icmp_packet + sizeof(ping_hdr)), &amp;now, sizeof(__u32));// fill some junk in the buffer.int junk_data_size = FLAG_l - sizeof(__u32); // timestampint junk_offset = icmp_packet_size - junk_data_size;if(junk_data_size &gt; 0)memset((icmp_packet + junk_offset), 'E', junk_data_size);pping_hdr-&gt;common_hdr.check = 0;pping_hdr-&gt;common_hdr.check = rtc::GetCheckSum(reinterpret_cast&lt;__u16*&gt;(icmp_packet), icmp_packet_size);}void DecodeIPPacket(__u8* ip_packet, __u16 packet_size) {iphdr* ip_hdr = reinterpret_cast&lt;iphdr*&gt;(ip_packet);__u32 now = rtc::Time32();__u16 ip_hdr_len = ip_hdr-&gt;ihl * 4; // bytesping_hdr *pping_hdr = reinterpret_cast&lt;ping_hdr*&gt;(ip_packet + ip_hdr_len);if (pping_hdr-&gt;common_hdr.type != 0 || pping_hdr-&gt;common_hdr.code != 0) {printf("non-echo response, type=%d, code=%d\n", pping_hdr-&gt;common_hdr.type, pping_hdr-&gt;common_hdr.code);return;}if (pping_hdr-&gt;id != (__u16)GetCurrentProcessId()) {printf("other process ping response packet, pid=%d\n", GetCurrentProcessId());return;}__u32 timestamp = 0;memcpy(&amp;timestamp, reinterpret_cast&lt;__u32*&gt;((__u8*)pping_hdr + sizeof(ping_hdr)), sizeof(__u32));in_addr from;from.s_addr = ip_hdr-&gt;saddr;printf("%d bytes from %s, time &lt; %d ms, icmp_seq = %d, TTL = %d \n", packet_size - ip_hdr_len - sizeof(ping_hdr),inet_ntoa(from),now - timestamp,pping_hdr-&gt;seq,ip_hdr-&gt;ttl);}int main(int argc, char**argv){rtc::FlagList::SetFlagsFromCommandLine(&amp;argc, argv, true);if (FLAG_h) {rtc::FlagList::Print(NULL, false);return 1;}char *hostname = argv[argc - 1];if (!hostname || strlen(hostname) == 0) {printf("Invalid host name\n");return 1;}if (FLAG_l &lt;= 4) {return 1;}WSADATA wsaData;WORD wVersionRequested = MAKEWORD(2, 2);WSAStartup(wVersionRequested, &amp;wsaData);sockaddr_in from;int from_len = sizeof(sockaddr_in);sockaddr_in dest;memset(&amp;dest, 0, sizeof(sockaddr_in));dest.sin_family = AF_INET;dest.sin_addr.s_addr = inet_addr(hostname);// resolve host nameif (dest.sin_addr.s_addr == INADDR_NONE) {unsigned long begin_time = rtc::Time32();struct addrinfo* result = nullptr;struct addrinfo hints = { 0 };hints.ai_family = AF_UNSPEC;hints.ai_flags = AI_ADDRCONFIG;int ret = getaddrinfo(hostname, nullptr, &amp;hints, &amp;result);if (ret != 0) {printf("Resolve host name failed, error code = %d\n", ret);return 1;}unsigned long end_time = rtc::Time32();struct addrinfo* cursor = result;printf("------------------------------\n");printf("Resolve [time &lt; %d ms]: \n", end_time - begin_time);bool flag = false;for (; cursor; cursor = cursor-&gt;ai_next) {sockaddr_in *paddr_in = reinterpret_cast&lt;sockaddr_in *&gt;(cursor-&gt;ai_addr);printf("%s\n", inet_ntoa(paddr_in-&gt;sin_addr));if (!flag) {dest.sin_addr = paddr_in-&gt;sin_addr;flag = true;}}freeaddrinfo(result);printf("-------------------------------\n");}printf("Ping %s [TTL %d]: \n", inet_ntoa(dest.sin_addr), FLAG_i);// socket函数需要管理员权限// 需要绕开管理员权限，可以使用IcmpSendEcho系列函数//SOCKET s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);if (s == INVALID_SOCKET) {printf("create socket failed, error code = %d\n", WSAGetLastError());WSACleanup();return 1;}int err = setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_s), sizeof(FLAG_s));RTC_DCHECK(err != SOCKET_ERROR);if (err == SOCKET_ERROR) {printf("setsockopt for SO_SNDTIMEO failed, error code = %d\n", WSAGetLastError());closesocket(s);WSACleanup();return 1;}err = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_w), sizeof(FLAG_w));RTC_DCHECK(err != SOCKET_ERROR);if (err == SOCKET_ERROR) {printf("setsockopt for SO_RCVTIMEO failed, error code = %d\n", WSAGetLastError());closesocket(s);WSACleanup();return 1;}err = setsockopt(s, IPPROTO_IP, IP_TTL, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_i), sizeof(FLAG_i));RTC_DCHECK(err != SOCKET_ERROR);if (err == SOCKET_ERROR) {printf("setsockopt for IP_TTL failed, error code = %d\n", WSAGetLastError());closesocket(s);WSACleanup();return 1;}// ping requestint icmp_packet_size = sizeof(ping_hdr)+ FLAG_l; // data__u8 *icmp_packet = new __u8[icmp_packet_size];RTC_DCHECK(icmp_packet);// ping response__u16 ip_packet_size = icmp_packet_size + 20; // 20 bytes ip header, no option.__u8 *ip_packet = new __u8[ip_packet_size];RTC_DCHECK(ip_packet);if (!icmp_packet || !ip_packet) {closesocket(s);WSACleanup();return 1;}__u16 i = 0;while (true) {if (i == 0xFFFF)i = 0;i++;if (!FLAG_t) {if(i &gt; 4)break;}FillPingPacket(icmp_packet, i, icmp_packet_size);int sent = sendto(s, reinterpret_cast&lt;const char*&gt;(icmp_packet), icmp_packet_size,0, reinterpret_cast&lt;const sockaddr*&gt;(&amp;dest), sizeof(sockaddr));if (sent == SOCKET_ERROR) {int gle = WSAGetLastError();if (gle == WSAETIMEDOUT) {printf("request timeout\n");continue;}else {printf("ping %s failed, error code = %d\n", inet_ntoa(dest.sin_addr), gle);break;}}if (sent &lt; FLAG_l) {printf("warning, sent %d bytes\n", sent);}int bread = recvfrom(s, reinterpret_cast&lt;char*&gt;(ip_packet),ip_packet_size, 0, reinterpret_cast&lt;sockaddr*&gt;(&amp;from), &amp;from_len);if (bread == SOCKET_ERROR) {int gle = WSAGetLastError();if (gle == WSAETIMEDOUT) {printf("receive timeout\n");continue;}else {printf("ping %s failed, error code = %d\n", inet_ntoa(dest.sin_addr), gle);break;}}if (bread &lt; ip_packet_size) {printf("too few bytes from %s\n", inet_ntoa(from.sin_addr));continue;}DecodeIPPacket(reinterpret_cast&lt;__u8*&gt;(ip_packet), ip_packet_size);Sleep(1000);}delete [] icmp_packet;delete [] ip_packet;if (s != INVALID_SOCKET) {closesocket(s);}WSACleanup();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h4><p><img src="https://static.1key.run/blog/img/wangluoxieyi-icmp-5.jpg"></p><h2 id="2-2-Tracert"><a href="#2-2-Tracert" class="headerlink" title="2.2 Tracert"></a>2.2 Tracert</h2><p>Tracert是windows系统提供的一个工具，使用该程序可以让我们看到IP数据报从一台主机到另一台主机所经过的路由器。Linux系统也提供了类似的工具，叫traceroute，功能和Tracert一样。</p><h3 id="2-2-1-Tracert原理"><a href="#2-2-1-Tracert原理" class="headerlink" title="2.2.1 Tracert原理"></a>2.2.1 Tracert原理</h3><p>在介绍Tracert的原理之前，需要先弄清楚IP首部TTL字段的含义，IP报文每经过一个路由器，路由器都会将该IP报文首部的TTL字段减1，<br>当路由器收到一份IP数据报的TTL是0或1时，路由器此时不会转发该数据报，而会丢弃该数据报，并且给IP数据报首部中的源地址发送一份ICMP超时报文。</p><blockquote><p>IP首部的定义见：<a href="/2023/06/20/wang-luo-xie-yi-3-ip-xie-yi/" title="网络协议(3)--IP协议">网络协议(3)--IP协议</a></p></blockquote><p>Tracert利用了路由器会丢弃TTL为1或0的数据报且返回ICMP超时报文的特性，来实现侦测路由的功能。Tracert程序先发送TTL值为1的IP数据报，处理这份数据报的第一个路由器将TTL减1，丢弃该数据报并返回ICMP超时报文，这样程序就得到了第一个路由器的地址，以此方式，递增IP数据报TTL的值，直到数据报最终到达目标主机。</p><p><strong>那么怎么判断数据报到达了最终的目标主机呢？</strong><br>我们不能单纯的通过未收到路由器返回的ICMP差错报文的方式来判断数据报到达目的地了，因为有可能我们由于接收ICMP差错报文超时等原因导致我们收不到ICMP差错报文（这也是为什么我们后面会介绍每一个TTL跃点会发送3次或多次请求的原因）。windows平台的tracert与linux平台的traceroute的实现原理稍有不同，判断数据报到达目标主机的方式也有不同。<br>tracert是通过发送ping包，因为windows系统内核都实现了ping功能，所以如果目的主机收到了ping请求就会回复相应的ping包，tracert就是通过这种方式来判断数据报是否到达了目标主机。而traceroute是通过发送UDP包（UDP端口选择一个不可能使用的UDP端口，比如大于30000的端口），因为目的主机没有监听该端口，所以不会响应接收到的该UDP请求，因此当UDP包到达时，目标主机会返回“端口不可达”的错误，traceroute就是通过该错误来判断UDP包到达了目的主机。</p><p>从实现方式来看，traceroute通过UDP的方式来实现更加稳定可靠，因为大多数主机的防火墙会组织ICMP报文，而不会阻止UDP报文。</p><p>下图使用wireshark抓取的<code>tracert 192.168.3.76</code>命令的数据包，从图中可以看到tracert是通过发送ping包来实现的，以及每个ping包的TTL递增过程：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-icmp-6.jpg"></p><h3 id="2-2-2-ICMP差错报文格式"><a href="#2-2-2-ICMP差错报文格式" class="headerlink" title="2.2.2 ICMP差错报文格式"></a>2.2.2 ICMP差错报文格式</h3><p>路由器在丢弃TTL为0或1的数据报时，会发送一个一份ICMP差错报文，该ICMP的差错报文的type为11, code为0.</p><p>type为11的报文格式如下（code有0和1两种，格式一样）：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-icmp-7.jpg"></p><h3 id="2-2-3-实现"><a href="#2-2-3-实现" class="headerlink" title="2.2.3 实现"></a>2.2.3 实现</h3><p>该示例和之前的Ping程序的示例有所不同，该示例设置了<code>IP_HDRINCL</code>选项来自己构造IP头部。</p><p>程序的启动参数使用webrtc的<code>"rtc_base/flags.h"</code>实现。</p><p>代码中的其他某些功能，如断言、时间戳等基于webrtc的<code>rtc_base</code>实现，这些功能也可以很方便的自己实现。 </p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;WinSock2.h&gt;#include &lt;ws2spi.h&gt;#include &lt;ws2tcpip.h&gt;#include &lt;strsafe.h&gt;#include &lt;algorithm&gt;#include "rtc_base/networkprotocolheader.h"#include "rtc_base/checks.h"#include "rtc_base/flags.h"#include "rtc_base/timeutils.h"DECLARE_bool(h); // 帮助DECLARE_int(m);  // 最大跃点数DECLARE_int(w);  // 等待每次回复的超时时间(毫秒)DECLARE_int(s);  // 发送ICMP包超时时间(毫秒)DECLARE_int(n);  // 每个跃点发送的请求数DEFINE_bool(h, false, "帮助");DEFINE_int(m, 30, "最大跃点数");DEFINE_int(w, 3000, "等待每次回复的超时时间(毫秒)");DEFINE_int(s, 3000, "发送ICMP包超时时间(毫秒)");DEFINE_int(n, 3, "每个跃点发送的请求数");const int kPingDataSize = 36;__u32 kLocalIP = 0;__u32 GetLocalIPv4Address() {return inet_addr("192.168.42.26");char hostname[MAX_PATH] = { 0 };gethostname(hostname, MAX_PATH);struct hostent FAR* lpHostEnt = gethostbyname(hostname);if (lpHostEnt == NULL) {return htonl(0x7f000001); //127.0.0.1}LPSTR lpAddr = lpHostEnt-&gt;h_addr_list[0];struct in_addr addr;memcpy(&amp;addr, lpAddr, 4);return addr.s_addr;}std::string IPv4ToString(__u32 ip) {in_addr addr;addr.s_addr = ip;char *p= inet_ntoa(addr);if (p)return p;return "";}std::string GetPrintString(const char* fmt, ...) {char buf[100];va_list arglist;va_start(arglist, fmt);StringCchVPrintfA(buf, 100, fmt, arglist);va_end(arglist);return buf;}bool print_ip(__u32* ips, int count, __u32 dest_ip) {bool has_ip = false;bool trace_end = false;for (int i = 0; i &lt; count; i++) {if (ips[i] != 0) {printf("  %s", IPv4ToString(ips[i]).c_str());has_ip = true;trace_end = (ips[i] == dest_ip);}}if (!has_ip)printf("  timeout");printf("\n");if (trace_end)printf("Trace Complete\n");return trace_end;}void FillRequestIPPacket(__u8* ip_packet, __u16 ip_packet_size, __u16 seq, __u8 ttl, __u32 dest_addr) {RTC_DCHECK(ip_packet);iphdr* p_iphdr = reinterpret_cast&lt;iphdr*&gt;(ip_packet);memset(p_iphdr, 0, sizeof(iphdr));p_iphdr-&gt;version = 4;p_iphdr-&gt;ihl = sizeof(iphdr)/4; // no optionp_iphdr-&gt;tos = 0;p_iphdr-&gt;frag_off = 0;p_iphdr-&gt;id = (__u16)rtc::Time32();p_iphdr-&gt;ttl = ttl;p_iphdr-&gt;protocol = IPPROTO_ICMP;p_iphdr-&gt;tot_len = ip_packet_size;p_iphdr-&gt;daddr = dest_addr;p_iphdr-&gt;saddr = kLocalIP;p_iphdr-&gt;check = rtc::GetCheckSum(reinterpret_cast&lt;__u16*&gt;(p_iphdr), p_iphdr-&gt;ihl*4);ping_hdr* p_ping_hdr = reinterpret_cast&lt;ping_hdr*&gt;(ip_packet + p_iphdr-&gt;ihl*4);p_ping_hdr-&gt;common_hdr.type = 8;p_ping_hdr-&gt;common_hdr.code = 0;p_ping_hdr-&gt;id = (__u16)GetCurrentProcessId();p_ping_hdr-&gt;seq = seq;// fill some junk in the buffer.if (kPingDataSize &gt; 0)memset((void*)((__u8*)p_ping_hdr+sizeof(ping_hdr)), 'E', kPingDataSize);p_ping_hdr-&gt;common_hdr.check = 0;p_ping_hdr-&gt;common_hdr.check = rtc::GetCheckSum(reinterpret_cast&lt;__u16*&gt;(p_ping_hdr), ip_packet_size - p_iphdr-&gt;ihl*4);}// return source ip addressbool DecodeIPPacket(const __u8* ip_packet, __u16 ip_packet_size, __u32 send_time, __u32* src_addr) {const iphdr* ip_hdr = reinterpret_cast&lt;const iphdr*&gt;(ip_packet);__u32 use_time = rtc::Time32() - send_time;__u16 ip_hdr_len = ip_hdr-&gt;ihl * 4; // bytesconst icmp_common_hdr *icmp_hdr = reinterpret_cast&lt;const icmp_common_hdr*&gt;(ip_packet + ip_hdr_len);if (icmp_hdr-&gt;type == 0 &amp;&amp; icmp_hdr-&gt;code == 0) { // 回显应答const ping_hdr *p_ping_hdr = reinterpret_cast&lt;const ping_hdr*&gt;(icmp_hdr);if (p_ping_hdr-&gt;id != (__u16)GetCurrentProcessId()) {printf("other process ping response packet, pid=%d\n", GetCurrentProcessId());return false;}printf("%-10s", GetPrintString("&lt;%d ms", use_time == 0 ? 1 : use_time).c_str());*src_addr = ip_hdr-&gt;saddr;return true;}else if (icmp_hdr-&gt;type == 11 &amp;&amp; icmp_hdr-&gt;code == 0) { // cause by ttl == 0printf("%-10s", GetPrintString("&lt;%d ms", use_time == 0 ? 1 : use_time).c_str());*src_addr = ip_hdr-&gt;saddr;return true;}else {printf("unexpected response, type=%d, code=%d\n", icmp_hdr-&gt;type, icmp_hdr-&gt;code);return false;}}#define SAFE_RELEASE \if (req_ip_packet) { \delete[] req_ip_packet; \req_ip_packet = NULL;\}\if (rsp_ip_packet) { \delete[] rsp_ip_packet; \rsp_ip_packet = NULL;\}\if (s != INVALID_SOCKET) {\closesocket(s);\s = INVALID_SOCKET;\}\WSACleanup();int main(int argc, char**argv) {rtc::FlagList::SetFlagsFromCommandLine(&amp;argc, argv, true);if (FLAG_h) {rtc::FlagList::Print(NULL, false);return 1;}char *hostname = argv[argc - 1];if (!hostname || strlen(hostname) == 0) {printf("Invalid host name\n");return 1;}printf("Trace %s\n", hostname);WSADATA wsaData;WORD wVersionRequested = MAKEWORD(2, 2);WSAStartup(wVersionRequested, &amp;wsaData);sockaddr_in from;int from_len = sizeof(sockaddr_in);kLocalIP = GetLocalIPv4Address();sockaddr_in dest;memset(&amp;dest, 0, sizeof(sockaddr_in));dest.sin_family = AF_INET;dest.sin_addr.s_addr = inet_addr(hostname);// resolve host nameif (dest.sin_addr.s_addr == INADDR_NONE) {unsigned long begin_time = rtc::Time32();struct addrinfo* result = nullptr;struct addrinfo hints = { 0 };hints.ai_family = AF_UNSPEC;hints.ai_flags = AI_ADDRCONFIG;int ret = getaddrinfo(hostname, nullptr, &amp;hints, &amp;result);if (ret != 0) {printf("Resolve host name failed, error code = %d\n", ret);return 1;}unsigned long end_time = rtc::Time32();struct addrinfo* cursor = result;printf("------------------------------\n");printf("Resolve [time &lt; %d ms]: \n", end_time - begin_time);bool flag = false;for (; cursor; cursor = cursor-&gt;ai_next) {sockaddr_in *paddr_in = reinterpret_cast&lt;sockaddr_in *&gt;(cursor-&gt;ai_addr);printf("%s\n", inet_ntoa(paddr_in-&gt;sin_addr));if (!flag) {dest.sin_addr = paddr_in-&gt;sin_addr;flag = true;}}freeaddrinfo(result);printf("-------------------------------\n");}printf("Tracing %s [%d max hops]: \n", inet_ntoa(dest.sin_addr), FLAG_m);SOCKET s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);if (s == INVALID_SOCKET) {printf("create socket failed, error code = %d\n", WSAGetLastError());WSACleanup();return 1;}int err = setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_s), sizeof(FLAG_s));RTC_DCHECK(err != SOCKET_ERROR);if (err == SOCKET_ERROR) {printf("setsockopt for SO_SNDTIMEO failed, error code = %d\n", WSAGetLastError());closesocket(s);WSACleanup();return 1;}err = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, reinterpret_cast&lt;const char*&gt;(&amp;FLAG_w), sizeof(FLAG_w));RTC_DCHECK(err != SOCKET_ERROR);if (err == SOCKET_ERROR) {printf("setsockopt for SO_RCVTIMEO failed, error code = %d\n", WSAGetLastError());closesocket(s);WSACleanup();return 1;}int opt = 1;err = setsockopt(s, IPPROTO_IP, IP_HDRINCL, reinterpret_cast&lt;const char*&gt;(&amp;opt), sizeof(opt));RTC_DCHECK(err != SOCKET_ERROR);if (err == SOCKET_ERROR) {printf("setsockopt for IP_HDRINCL failed, error code = %d\n", WSAGetLastError());closesocket(s);WSACleanup();return 1;}// ip packet for ping request.__u16 req_ip_packet_size = sizeof(iphdr) + sizeof(ping_hdr) + kPingDataSize;__u8 *req_ip_packet = new __u8[req_ip_packet_size];memset(req_ip_packet, 0, req_ip_packet_size);// ip packet for icmp response or ping echo.__u16 rsp_ip_packet_size = // ICMP差错报文的大小sizeof(iphdr)+ sizeof(icmp_common_hdr)  // ICMP(type=11,code=0或1)差错报文+ 4 // unused+ sizeof(iphdr) + 8;//取ping包大小和ICMP差错报文大小的最大值，保证无论返回哪种报文缓冲区都够用，//也可以直接分配一个足够大的缓冲区，如1024//rsp_ip_packet_size = std::max(rsp_ip_packet_size, req_ip_packet_size);__u8 *rsp_ip_packet = new __u8[rsp_ip_packet_size];memset(rsp_ip_packet, 0, rsp_ip_packet_size);RTC_DCHECK(rsp_ip_packet);int ttl = 1;int seq = 0;__u32 *ips = new __u32[FLAG_n];for(int hop = 1; hop &lt;= FLAG_m; hop++) {printf(" %-4d", hop);for (int i = 0; i &lt; FLAG_n; i++) {ips[i] = 0;seq++;FillRequestIPPacket(req_ip_packet, req_ip_packet_size, seq, ttl, dest.sin_addr.s_addr);__u32 send_time = rtc::Time32();int sent = sendto(s,reinterpret_cast&lt;const char*&gt;(req_ip_packet),req_ip_packet_size,0,reinterpret_cast&lt;const sockaddr*&gt;(&amp;dest),sizeof(sockaddr));if (sent == SOCKET_ERROR) {printf("%-10s", "*");if (i == FLAG_n - 1)if (print_ip(ips, FLAG_n, dest.sin_addr.s_addr)) {SAFE_RELEASE;return 0;}continue;}int bread = recvfrom(s,reinterpret_cast&lt;char*&gt;(rsp_ip_packet),rsp_ip_packet_size,0,reinterpret_cast&lt;sockaddr*&gt;(&amp;from),&amp;from_len);if (bread == SOCKET_ERROR) {int gle = WSAGetLastError();printf("%-10s", "*");if (i == FLAG_n - 1)if (print_ip(ips, FLAG_n, dest.sin_addr.s_addr)) {SAFE_RELEASE;return 0;}continue;}__u32 dest_ip = 0;DecodeIPPacket(reinterpret_cast&lt;const __u8*&gt;(rsp_ip_packet), rsp_ip_packet_size, send_time, &amp;dest_ip);ips[i] = dest_ip;if (i == FLAG_n - 1)if (print_ip(ips, FLAG_n, dest.sin_addr.s_addr)) {SAFE_RELEASE;return 0;}}ttl++;}SAFE_RELEASE;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-4-运行效果："><a href="#2-2-4-运行效果：" class="headerlink" title="2.2.4 运行效果："></a>2.2.4 运行效果：</h3><p><img src="https://static.1key.run/blog/img/wangluoxieyi-icmp-8.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICMP </tag>
            
            <tag> Ping </tag>
            
            <tag> Tracert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《拨开字符编码的迷雾》专栏</title>
      <link href="/2023/06/21/bo-kai-zi-fu-bian-ma-de-mi-wu-zhuan-lan/"/>
      <url>/2023/06/21/bo-kai-zi-fu-bian-ma-de-mi-wu-zhuan-lan/</url>
      
        <content type="html"><![CDATA[<p>本专栏从字符编码的基础概念开始，一步步理清在开发过程中遇到的各种编码问题，从此告别编码、乱码的烦恼。</p><p>文章列表：</p><ul><li><a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-1-zi-fu-bian-ma-gai-shu/" title="拨开字符编码的迷雾(1)--字符编码概述">拨开字符编码的迷雾(1)--字符编码概述</a></li><li><a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-2-bian-yi-qi-chu-li-wen-jian-bian-ma/" title="拨开字符编码的迷雾(2)--编译器处理文件编码">拨开字符编码的迷雾(2)--编译器处理文件编码</a></li><li><a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-3-zi-fu-bian-ma-zhuan-huan/" title="拨开字符编码的迷雾(3)--字符编码转换">拨开字符编码的迷雾(3)--字符编码转换</a></li><li><a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-4-mysql-zi-fu-bian-ma/" title="拨开字符编码的迷雾(4)--MySQL字符编码">拨开字符编码的迷雾(4)--MySQL字符编码</a></li><li><a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-5-qt-zi-fu-bian-ma/" title="拨开字符编码的迷雾(5)--Qt字符编码">拨开字符编码的迷雾(5)--Qt字符编码</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(3)--IP协议</title>
      <link href="/2023/06/20/wang-luo-xie-yi-3-ip-xie-yi/"/>
      <url>/2023/06/20/wang-luo-xie-yi-3-ip-xie-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><p>IP协议是TCP/IP协议族中最核心的协议。所有的TCP、UDP、ICMP、IGMP数据都以IP数据报的格式传输。</p><p>IP协议是不可靠、无连接的：</p><ul><li><p><code>不可靠</code>表示IP协议不能保证IP数据报能成功的到达目的地。IP仅提供传输服务，任何可靠性的要求都必须由上层来提供（如TCP）。如果传输过程发生错误，IP协议简单的丢弃该数据报，然后发送ICMP消息给发送端。</p></li><li><p><code>无连接</code>表示IP协议不维护任何关于后续数据报的状态信息，每个数据报都是相互独立的。这也说明，IP数据报可能不是按照发送顺序被接收到的，很有可能后发送的数据被先收到。</p></li></ul><h2 id="一、IP首部"><a href="#一、IP首部" class="headerlink" title="一、IP首部"></a>一、IP首部</h2><p>IP数据报的格式如图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-ip-1.jpg"></p><ul><li><p>4位版本：标识目前采用的IP协议的版本号。IPv4为0100, IPv6为0110</p></li><li><p>4位首部长度：用于标识首部的长度，单位为<strong>4字节</strong>，所以首部的最大长度为<code>15*4字节=60字节</code>。</p></li><li><p>8位服务类型：包括3bit的优先权字段（已被忽略），4bit的TOS字段，1bit的始终为0的未使用位。</p></li><li><p>16位总长度(字节数)：整个IP数据报的长度。数据报中<code>数据内容的长度=总长度 - 首部长度</code></p></li><li><p>16位标识：唯一地标识主机发送的每一份数据报。IP数据报的最大长度可达65535字节，但大多数链路层都会对它进行分片。由于TCP本身会把用户数据分成若干片，因此这个字段一般来说不会影响到TCP。</p></li><li><p>3位标志：用于IP数据报分片。该字段第1bit不使用，第2bit是DF(<code>Don't Fragment</code>)位，DF位设为1时表明IP不对该数据包分片。第3bit是MF(<code>More Fragments</code>)位，当对数据包分片时，除了最后一片外，其他每个组成数据报的片都要把此位设为1。</p></li><li><p>13位偏移：用于IP数据报分片。单位为8字节。表示该片相对于原始数据报开始处的位置，能表示的最大偏移为$2^{13}$*8=65536字节。</p></li></ul><blockquote><p>另外，数据报被分片之后，每个片的总长度要更改为该片的长度值。IP层分片是透明的，但是即使只丢失一片数据也要重传整个数据报，因为IP层本身没有超时重传的机制。</p></blockquote><ul><li><p>8位生存时间(TTL)：设置数据报可以经过的最多路由器数量，每经过一个路由器，该值就减去1。当该值为0时，数据报就被丢弃。通常初始值为32或64.</p></li><li><p>8位协议：表示上层传输层所用的协议类型。1表示ICMP协议，2表示IGMP协议，6表示TCP协议，17表示UDP协议。</p></li><li><p>16位首部校验和：用于对IP首部的正确性进行校验，但不包括数据部分，这点不同于TCP和UDP的首部校验和。</p></li><li><p>32位源IP地址：发送端的32bit的IP地址。</p></li><li><p>32位目的IP地址：接收端的32bit的IP地址。</p></li><li><p>选项：可变长度的可选信息。如果首部不含“选项字段”，则IP首部长度为20字节。</p></li></ul><h2 id="二、IP首部校验和"><a href="#二、IP首部校验和" class="headerlink" title="二、IP首部校验和"></a>二、IP首部校验和</h2><ul><li>发送端对IP数据报的校验和的计算步骤：</li></ul><ol><li>把IP数据报的校验和字段置为0；</li><li>把首部看成以16位为单位的数字组成，依次进行二进制反码求和；</li><li>把求和得到的结果取反。</li><li>将第2、3步得到的2个字节数据存入首部校验和。</li></ol><ul><li>接收端对IP数据报的校验和的校验步骤：</li></ul><ol><li>把首部看成以16位为单位的数字组成，依次进行二进制反码求和；</li><li>把求和得到的结果取反码。</li><li>如果结果为0，则表示检验和校验通过，IP报文没有被修改过。</li></ol><h2 id="三、使用代码计算校验和"><a href="#三、使用代码计算校验和" class="headerlink" title="三、使用代码计算校验和"></a>三、使用代码计算校验和</h2><p>通过wireshark抓取一帧数据报，如图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-ip-2.jpg"></p><p>以该数据报的IP首部为基础，使用C++代码来验证IP首部校验和的计算步骤和校验步骤：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;assert.h&gt;// GetChecksum函数用于实现上面所说的计算步骤中的第2步、第3步：// 把首部看成以16位（2字节）为单位的数字组成，依次进行二进制反码求和，// 但实际的算法实现上需要考虑取和溢出时的改进计算方法（见函数内部注释）//unsigned short GetChecksum(unsigned short* ip_header, int size) {assert(sizeof(unsigned short) == 2);// 为什么使用unsigned long（4字节）？// 因为虽然首部校验和只占16位（2个字节），但执行“以16位（2字节）为单位的二进制反码数据”求和操作得到的checksum可能会超过16位（2字节），// 所以这里用4个字节的unsigned long来接收相加得到的结果，后面再进行处理。//unsigned long checksum = 0;while (size &gt; 1) {checksum += *ip_header; // 因为都是正数，所以反码与原码相同；故直接相加求和ip_header++; // ip_header为unsigned short类型的指针每次按2个字节相加size -= 2;}// 执行到这：checksum = 0x2850c// IP首部如果不包含“选项”字段，则为20字节，偶数；如果包含了“选项”，则字节数就可能为奇数了，// 这里针对字节数为奇数的情况进行处理。// 注：示例main函数中构造的ip_header不含有“选项”//if (size == 1) {checksum += *(unsigned char*)ip_header;}// 因为上面相加之后的结果大于2个字节，所以执行额外的处理步骤：// checksum &gt;&gt; 16 右移16位// 即除以2的16次方（0xffff），就是去除右边的2个字节，如：0x2850c &gt;&gt; 16 = 0x2//// checksum &amp; 0xffff 位运算，得到后2个字节// 如：0x2850c &amp; 0xffff = 0x850c//// checksum = 0x2 + 0x850c = 0x850e//checksum = (checksum &gt;&gt; 16) + (checksum &amp; 0xffff);// 假如还大于2个字节，再次将多余的字节和checksum相加。checksum += (checksum &gt;&gt; 16);// 求和得到的结果的取反return (unsigned short)(~checksum);}int main(){// 将上面wirkshark抓的数据包的IP头部，使用char数组，按字节构造出来//unsigned char ip_header[20] = {0x45, // 4位版本+4位首部长度0x00, // 8位服务类型（TOS）0x00, 0x1c,  // 16位总长度（字节数）0x50, 0xaa,  // 16位标识0x00, 0x00,  // 3位标志+13位片偏移0xff, // 8位生存时间（TTL）0x01, // 8位协议0xf1, 0x7a, // 16位首部校验和0xc0, 0xa8, 0x2e, 0x55, // 32位源IP地址0xee, 0x73, 0x9c, 0x4a  // 32位目的IP地址};// 第1步：把IP数据包的校验和字段置为0；//ip_header[10] = 0x00;ip_header[11] = 0x00;// 第2、3步计算校验和//unsigned short checksum = GetChecksum((unsigned short*)ip_header, sizeof(ip_header));printf("%02hhx %02hhx\n", *(char*)(&amp;checksum), *((char*)(&amp;checksum) + 1));// 第4步：将第2、3步得到的2个字节数据存入首部校验和//ip_header[10] = *(char*)(&amp;checksum);ip_header[11] = *((char*)(&amp;checksum) + 1);// 模拟接收到IP包之后，对IP首部的校验和进行校验//unsigned short checksum_check = GetChecksum((unsigned short*)ip_header, sizeof(ip_header));if (checksum_check == 0) {printf("checksum check successful!\n");}else {printf("checksum check failed!\n");}    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、IP校验和的设计原理"><a href="#四、IP校验和的设计原理" class="headerlink" title="四、IP校验和的设计原理"></a>四、IP校验和的设计原理</h2><p>我们将IP首部进行简化来讲解IP校验和的设计原理，假设IP首部只有6个字节，第5,6字节存放校验和：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-ip-3.jpg"></p><p>计算校验和时第5,6字节置为0，校验和等于：A+B+0，然后取反，即：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-ip-4.jpg"></p><p>接收端收到之后校验步骤为：求校验和（不同的是：校验和位不置0），若此时求得校验和为0，则校验通过。即：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-ip-5.jpg"></p><h2 id="五、IP地址相关操作"><a href="#五、IP地址相关操作" class="headerlink" title="五、IP地址相关操作"></a>五、IP地址相关操作</h2><p>本节介绍在网络编程中涉及到的与IP地址相关的操作</p><h3 id="struct-in-addr"><a href="#struct-in-addr" class="headerlink" title="struct in_addr"></a>struct in_addr</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// sizeof(in_addr) == sizeof(ULONG) == 4//typedef struct in_addr {        union {                struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b;                struct { USHORT s_w1,s_w2; } S_un_w;                ULONG S_addr;   // 4个字节，按网络字节序列存储                // 可以使用inet_addr函数将IP格式字符串转为网络字节序列的整数。        } S_un;// 定义的一些宏，方便访问结构体成员#define s_addr  S_un.S_addr /* can be used for most tcp &amp; ip code */#define s_host  S_un.S_un_b.s_b2    // host on imp#define s_net   S_un.S_un_b.s_b1    // network#define s_imp   S_un.S_un_w.s_w2    // imp#define s_impno S_un.S_un_b.s_b4    // imp ##define s_lh    S_un.S_un_b.s_b3    // logical host} IN_ADDR, *PIN_ADDR, FAR *LPIN_ADDR;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="struct-sockaddr-in"><a href="#struct-sockaddr-in" class="headerlink" title="struct sockaddr_in"></a>struct sockaddr_in</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// sizeof(sockaddr_in) == 16struct sockaddr_in {        short   sin_family;        u_short sin_port;        struct  in_addr sin_addr;        char    sin_zero[8];};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="struct-sockaddr"><a href="#struct-sockaddr" class="headerlink" title="struct sockaddr"></a>struct sockaddr</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// sizeof(sockaddr) == 16//struct sockaddr {        u_short sa_family;              /* address family */        char    sa_data[14];            /* up to 14 bytes of direct address */};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-转换函数"><a href="#5-1-转换函数" class="headerlink" title="5.1 转换函数"></a>5.1 转换函数</h3><blockquote><p>webrtc中的<code>IPAddress</code>类和<code>SocketAddress</code>类，对网络地址的操作进行了很好的封装，值得参考。</p></blockquote><h4 id="5-1-1-IP字符串-gt-整数"><a href="#5-1-1-IP字符串-gt-整数" class="headerlink" title="5.1.1 IP字符串 -> 整数"></a>5.1.1 IP字符串 -&gt; 整数</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unsigned long inet_addr(  _In_ const char *cp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将类似<code>127.0.0.1</code>这样的IP字符串转换为网络字节序列的整数</p><h4 id="5-1-2-整数-gt-IP字符串"><a href="#5-1-2-整数-gt-IP字符串" class="headerlink" title="5.1.2 整数 -> IP字符串"></a>5.1.2 整数 -&gt; IP字符串</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char* FAR inet_ntoa(  _In_ struct   in_addr in);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将in_addr（也可以理解为网络字节序列整数）转换为IP字符串。</p><h3 id="5-2-字节序列转换"><a href="#5-2-字节序列转换" class="headerlink" title="5.2 字节序列转换"></a>5.2 字节序列转换</h3><pre class="line-numbers language-none"><code class="language-none">htonshtonlntohsntohlhtonllntohll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对整数（short、long、longlong）进行网络字节序列和主机字节序列间的转换操作。<br>以htons为例：<br><code>h</code>是host的首字母，表示主机字节序列；<br><code>n</code>是network的首字母，表示网络字节序列；<br><code>s</code>代表short；<br>所以htons的功能是，将short从主机字节序列转为网络字节序列。</p><blockquote><p>字节序列可以参考：<a href="http://blog.csdn.net/china_jeffery/article/details/78401731">http://blog.csdn.net/china_jeffery/article/details/78401731</a></p></blockquote><h3 id="5-3-获取本机IP地址"><a href="#5-3-获取本机IP地址" class="headerlink" title="5.3 获取本机IP地址"></a>5.3 获取本机IP地址</h3><h4 id="5-3-1-使用gethostbyname"><a href="#5-3-1-使用gethostbyname" class="headerlink" title="5.3.1 使用gethostbyname"></a>5.3.1 使用gethostbyname</h4><p>这种方式有一个弊端：只能获取一个网卡的IP地址。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unsigned long GetLocalIPv4Address() {char hostname[MAX_PATH] = { 0 };gethostname(hostname, MAX_PATH);struct hostent FAR* lpHostEnt = gethostbyname(hostname);if (lpHostEnt == NULL) {return htonl(0x7f000001); //127.0.0.1}LPSTR lpAddr = lpHostEnt-&gt;h_addr_list[0];struct in_addr addr;memcpy(&amp;addr, lpAddr, 4);return addr.s_addr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-2-使用GetAdaptersInfo"><a href="#5-3-2-使用GetAdaptersInfo" class="headerlink" title="5.3.2 使用GetAdaptersInfo"></a>5.3.2 使用GetAdaptersInfo</h4><p>该方式可以获取本机多块网卡的信息（不限于IP地址）。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;windows.h&gt;#include &lt;Iphlpapi.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#pragma comment(lib,"Iphlpapi.lib")bool GetLocalAddress(std::vector&lt;std::string&gt; &amp;ip_list) {PIP_ADAPTER_INFO pIpAdapterInfo = new IP_ADAPTER_INFO();unsigned long stSize = sizeof(IP_ADAPTER_INFO);int nRet = GetAdaptersInfo(pIpAdapterInfo, &amp;stSize);if (ERROR_BUFFER_OVERFLOW == nRet) {delete pIpAdapterInfo;pIpAdapterInfo = (PIP_ADAPTER_INFO)new BYTE[stSize];nRet = GetAdaptersInfo(pIpAdapterInfo, &amp;stSize);}if (ERROR_SUCCESS != nRet) {if (pIpAdapterInfo) {delete pIpAdapterInfo;}return false;}while (pIpAdapterInfo) {IP_ADDR_STRING *pIpAddrString = &amp;(pIpAdapterInfo-&gt;IpAddressList);switch (pIpAdapterInfo-&gt;Type) {case MIB_IF_TYPE_OTHER:case MIB_IF_TYPE_ETHERNET:case MIB_IF_TYPE_TOKENRING:case MIB_IF_TYPE_FDDI:case MIB_IF_TYPE_PPP:case MIB_IF_TYPE_LOOPBACK:case MIB_IF_TYPE_SLIP: {std::string address = pIpAddrString-&gt;IpAddress.String;if ("0.0.0.0" == address)break;ip_list.push_back(address);break;}default:break;}pIpAdapterInfo = pIpAdapterInfo-&gt;Next;}if (pIpAdapterInfo) {delete pIpAdapterInfo;}return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>《TCP/IP详解 卷1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP </tag>
            
            <tag> 校验和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(2)--ARP和RARP协议</title>
      <link href="/2023/06/20/wang-luo-xie-yi-2-arp-he-rarp-xie-yi/"/>
      <url>/2023/06/20/wang-luo-xie-yi-2-arp-he-rarp-xie-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一、ARP协议"><a href="#一、ARP协议" class="headerlink" title="一、ARP协议"></a>一、ARP协议</h1><h2 id="1-1-ARP协议介绍"><a href="#1-1-ARP协议介绍" class="headerlink" title="1.1 ARP协议介绍"></a>1.1 ARP协议介绍</h2><p><code>ARP</code>(<code>Address Resolution Protocol</code>)地址解析协议，位于TCP/IP协议栈中的链路层。当局域网内主机间（或者是主机与网关间）需要通信时，通过使用<code>ARP协议</code>获取<code>目标IP地址</code>对应的<code>硬件MAC地址</code>，然后主机间通过该<code>硬件MAC地址</code>完成数据包发送和接收。<br>具体过程如下：</p><ol><li>本地主机在局域网中<code>广播</code>ARP请求，ARP请求数据帧中包含目的主机的IP地址。意思是“如果你是这个IP地址的拥有者，请回答你的硬件MAC地址”。</li><li>目的主机的ARP层解析这份<code>广播</code>报文，识别出是询问其硬件地址。于是发送（<code>单播</code>）ARP应答包，里面包含IP地址及其对应的硬件地址。</li><li>本地主机收到ARP应答后，知道了目的地址的硬件地址，之后的数据报就可以传送了。</li></ol><p><img src="https://static.1key.run/blog/img/wangluoxieyi-arp-1.jpg"></p><h2 id="1-2-ARP缓存"><a href="#1-2-ARP缓存" class="headerlink" title="1.2 ARP缓存"></a>1.2 ARP缓存</h2><p>如果像上面说的那样，每次发包之前都要发送ARP请求硬件地址会不会太慢，但是实际上ARP的运行是非常高效的。那是因为每一个主机上都有一个ARP高速缓存，我们可以通过命令<code>arp -a</code>获取本机ARP高速缓存的所有内容：</p><pre class="line-numbers language-none"><code class="language-none">λ arp -a接口: 192.168.42.26 --- 0xb  Internet 地址         物理地址              类型  192.168.1.1           00-00-00-00-00-ff     静态  192.168.40.1          f8-75-88-c2-df-c1     动态  192.168.40.74         c8-5b-76-86-c6-06     动态  192.168.40.245        38-d5-47-e1-8a-2f     动态  192.168.42.131        60-a4-4c-65-9f-68     动态  224.14.51.28          01-00-5e-0e-33-1c     静态  224.19.133.150        01-00-5e-13-85-96     静态  224.49.6.212          01-00-5e-31-06-d4     静态  224.50.134.225        01-00-5e-32-86-e1     静态  224.68.111.100        01-00-5e-44-6f-64     静态  224.80.154.130        01-00-5e-50-9a-82     静态  224.88.174.75         01-00-5e-58-ae-4b     静态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过命令<code>arp -d</code>清除arp缓存内容。</p><h2 id="1-3-ARP缓存生存周期"><a href="#1-3-ARP缓存生存周期" class="headerlink" title="1.3 ARP缓存生存周期"></a>1.3 ARP缓存生存周期</h2><p>在默认情况下，Windows Server 2003家族和Windows XP中，ARP缓存中的表项仅存储2分钟。如果一个ARP缓存表项在2分钟内被用到，则其期限再延长2分钟，直到最大生命期限10分钟为止。超过10分钟的最大期限后，ARP缓存表项将被移出，并且通过另外一个ARP请求来获得新的对应关系。</p><p>ARP缓存表项的存放时间可以通过改变<code>ArpCacheLife</code>和<code>ArpCacheMinReferencedLife</code>的注册表值来重新设置。</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Tcpip/Parameters键值：ArpCacheLife，设置未被使用的ARP缓存表项可以被保持的时间，类型为Dword，单位为秒，默认值为120。ArpCacheMinReferencedLife，设置被重复使用的表项可以在ARP缓存中存放的时间，类型为Dword，单位为秒，默认值为600。ArpCacheMinReferencedLife和ArpCacheLife的值的使用方法如下：如果ArpCacheLife &gt;= ArpCacheMinReferencedLife，则被使用和未被使用的ARP缓存表项可存储的时间都是ArpCacheLife。如果ArpCacheLife &lt; ArpCacheMinReferencedLife，则未被使用的ARP缓存表项在ArpCacheLife秒的时间后就过期了，被使用的表项的生存期为ArpCacheMinReferencedLife秒。注意：这些键值默认是不存在的，如果你想修改，必须自行创建；修改后重启计算机后生效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-ARP帧格式"><a href="#1-3-ARP帧格式" class="headerlink" title="1.3 ARP帧格式"></a>1.3 ARP帧格式</h2><p><img src="https://static.1key.run/blog/img/wangluoxieyi-arp-2.jpg"></p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">以太网目的地址：目的主机的硬件地址。目的地址全为1的特殊地址是广播地址。以太网源地址：源主机的硬件地址。帧类型：对于ARP协议，该字段为0x0806。对于RARP协议，该字段为0x8035。硬件类型：表示硬件地址的类型。值为1时表示以太网地址。ARP协议不仅仅应用于以太网协议，还可以支持别的链路层协议。协议类型：表示要映射的协议地址类型。值为0x0800时表示IP协议。硬件地址长度：与硬件类型对应的硬件地址的长度，以字节为单位。如果是以太网，则是6字节（MAC长度）。协议地址长度：与协议类型对应的协议地址长度，以字节为单位。如果是IP协议，则是4字节（IP地址长度）。操作类型（op）：四种操作类型。ARP请求（1），ARP应答（2），RARP请求（3），RARP应答（4）。发送端硬件地址：如果是以太网，则是源主机以太网地址，此处和以太网头中的源地址对应。发送端协议地址：如果是IP协议，则表示源主机的IP地址。目的端硬件地址：如果是以太网，则是目的以太网地址，和以太网头中的目的地址对应。目的端协议地址：如果是IP协议，则表示源主机要请求硬件地址的IP地址。对应ARP请求包来说，目的端的硬件地址字段无须填充，其他字段都需要填充。对于ARP回复包来说，所有字段都需要填充。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4-ARP欺骗"><a href="#1-4-ARP欺骗" class="headerlink" title="1.4 ARP欺骗"></a>1.4 ARP欺骗</h2><p>ARP欺骗一般目的是通过某种方式把自己伪装成网关，从而欺骗目标机器，使本应发送到真实网关的数据包发送到欺骗者的机器。</p><p>现有如下网络：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-arp-3.jpg"></p><h4 id="1-4-1-如何伪装成网关？"><a href="#1-4-1-如何伪装成网关？" class="headerlink" title="1.4.1 如何伪装成网关？"></a>1.4.1 如何伪装成网关？</h4><p>我们以主机A请求<code>www.csdn.net</code>网站为例，涉及到ARP的主要流程如下：</p><ol><li><p>主机A通过浏览器打开<code>www.csdn.net</code>（假设通过DNS得到的IP是<code>47.95.163.175</code>），然后组装需要发送http请求包。</p></li><li><p>主机A准备根据默认路由（网关）将数据包发送给<code>192.168.0.1</code>, 但是最开始的时候主机A不知道 <code>192.168.0.1</code> 的MAC地址, 所以主机A广播一条ARP请求, 询问 <code>192.168.0.1</code> 的 MAC地址。</p></li><li><p>路由器（网关）收到该 ARP 请求, 发现自己是 192.168.0.1 于是向主机 A 回复一条 ARP应答包, 告诉主机 A 192.168.0.1 的 MAC 地址是 xxxGW.</p></li><li><p>主机 A 收到该ARP响应包, 并向该响应包中的 MAC 地址发送一个Http请求包。</p></li><li><p>路由器（网关）收到该 Http请求包, 发现目标 IP 是公网 IP, 便将该包放送到公网, 公网返回Http应答包给路由器（网关）。</p></li><li><p>路由器（网关）准备将Http响应包发送给<code>192.168.0.100</code>, 但是同第2步, 路由器最开始的时候也不知道 <code>192.168.0.100</code> 的MAC地址是多少, 所以路由器会广播一条ARP请求, 询问 192.168.0.100 的MAC地址是多少。</p></li><li><p>主机A收到ARP请求, 发现自己是<code>192.168.0.100</code>, 于是向路由器回复一个ARP应答包, 告诉路由器<code>192.168.0.100</code> 的 MAC地址是 xxxA.</p></li><li><p>路由器（网关）收到ARP应答包, 并使用该APR应答包中的MAC地址将第5步收到Http响应包发送出去。</p></li></ol><p>试想，如果现在主机B做了如下2件事情会有什么后果：</p><ol><li>主机B不停的向主机A发送ARP应答包, 告诉路由器（网关）192.168.0.1 的MAC地址是 xxxB, 会发生什么?</li><li>主机B不停的向路由器（网关）发送 ARP应答包, 告诉主机A 192.168.0.100的MAC是 xxxB, 会发生什么?</li></ol><p>如果主机B做了上面说的两件事的, 那么主机A访问网络的所有数据都会先经过主机 B, 并且从网关发送到主机A的数据也都会经过B, 至此, 整个ARP欺骗完成。</p><p>但是，如果欺骗者机器不对这些数据包作处理，当被欺骗数据包到达后就会被本机丢弃（因为自己到底不是网关，还不知道如何处理这类数据包），这当然是不允许的。这时开启IP转发功能可以解决该问题，IP转发负责把该类数据包再转发给真正的网关处理，开启IP转发的方法：</p><pre class="line-numbers language-none"><code class="language-none">sysctl net.ipv4.ip_forward=1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-4-2-arpspoof使用"><a href="#1-4-2-arpspoof使用" class="headerlink" title="1.4.2 arpspoof使用"></a>1.4.2 arpspoof使用</h4><p>在Ubuntu或Kali等系统上有<code>arpspoof</code>工具可以轻松实现ARP欺骗的整个流程。</p><pre class="line-numbers language-none"><code class="language-none">arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host参数：-i 指定用攻击机的哪个网络接口，可以使用ifconfig命令查看攻击机接口列表。-c own|host|both-t 指定arp攻击的目标。如果不指定，则目标为该局域网内的所有机器。可以指定多个目标，如：arpspoof -i etho -t 192.168.32.100 -t 192.168.32.101-r host 希望拦截攻击机和哪个host之间的通信，一般都是网关。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、RARP协议"><a href="#二、RARP协议" class="headerlink" title="二、RARP协议"></a>二、RARP协议</h1><p>RARP协议（Reverse Address Resolution Protocol），反向地址转换协议，也叫逆地址解析协议，主要被那些没有磁盘驱动器的系统使用，如无盘工作站等。</p><p>具有本地磁盘的系统引导时，一般是从磁盘中的配置文件读取IP地址。但是无盘机，如无盘工作站，则需要采用其他方法获取ip地址。<br>网络上的每个系统都具有唯一的硬件地址，它是由网络接口生产厂家配置的。无盘系统的RARP实现过程是从网卡上读取唯一的硬件地址，然后发送RARP请求到RARP服务器，请求该主机在无盘系统的IP地址。</p><p><img src="https://static.1key.run/blog/img/wangluoxieyi-arp-4.jpg"></p><blockquote><p>文章参考：<a href="https://segmentfault.com/a/1190000009562333">https://segmentfault.com/a/1190000009562333</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARP </tag>
            
            <tag> RARP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(1)--基础概念</title>
      <link href="/2023/06/20/wang-luo-xie-yi-1-ji-chu-gai-nian/"/>
      <url>/2023/06/20/wang-luo-xie-yi-1-ji-chu-gai-nian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一、TCP-x2F-IP协议栈"><a href="#一、TCP-x2F-IP协议栈" class="headerlink" title="一、TCP/IP协议栈"></a>一、TCP/IP协议栈</h1><p><img src="https://static.1key.run/blog/img/wangluoxieyi-jichugailian-1.jpg"></p><h1 id="二、IP地址、子网掩码、网关"><a href="#二、IP地址、子网掩码、网关" class="headerlink" title="二、IP地址、子网掩码、网关"></a>二、IP地址、子网掩码、网关</h1><h2 id="2-1-IP地址及分类"><a href="#2-1-IP地址及分类" class="headerlink" title="2.1 IP地址及分类"></a>2.1 IP地址及分类</h2><p>IP地址相当于互联网上的门牌号, 计算机在启动的时候可以从磁盘（无盘系统例外）上读取该主机的IP配置。IP地址由4个字节（也就是32位）的二进制码组成，包含了<code>网络号( net-id )</code>和<code>主机号( host-id )</code>。但现实中，我们经常还需要再继续划分<code>“子网”</code>，这时就需要借用主机号的一部分充任子网号，这样IP地址也就可以看成由<code>标准网络号、子网号、主机号</code>3部分组成的了，即<code>IP地址=标准网络号+子网号+主机号</code>。</p><blockquote><p>网络号、子网号、主机号三者间的关系，形象的描述如下：假设你的住址IP是<code>武汉市文治街16号</code>，那么，<br>IP地址 = 武汉市文治街16号<br>网络号 = 武汉市<br>子网号 = 文治街<br>主机号 = 16号</p></blockquote><table><thead><tr><th>IP地址种类</th><th>二进制组成(前缀位+网络位+主机位)</th><th>IP范围</th><th>网络数</th><th>主机数/网络</th></tr></thead><tbody><tr><td>A类地址</td><td><code>0</code>+7位网络号+24位主机号</td><td>1.0.0.0 - 127.255.255.255</td><td>$2^7-2$</td><td>$2^{24}-2$</td></tr><tr><td>B类地址</td><td><code>10</code>+14位网络号+16位主机号</td><td>128.0.0.0 - 191.255.255.255</td><td>$2^{14}-1$</td><td>$2^{16}-2$</td></tr><tr><td>C类地址</td><td><code>110</code>+21位网络号+8位主机号</td><td>192.0.0.0 - 223.255.255.255</td><td>$2^{21}-1$</td><td>$2^8-2$</td></tr><tr><td>D类地址</td><td><code>1110</code>+多播地址(用于多播)</td><td>224.0.0.0 - 239.255.255.255</td><td>-</td><td>-</td></tr><tr><td>E类地址</td><td><code>1111</code>+保留位(不开放, 保留使用)</td><td>240.0.0.0-249.255.255.255</td><td>-</td><td>-</td></tr></tbody></table><p>从表中可以看出，A类IP的第1位（二进制位）必须是0，所以A类IP的第一个整数的范围是<code>0000 0000 ~ 01111 11111</code>，转换为十进制就是<code>0 ~ 127</code>，以此类推。</p><h3 id="关于网络数的解释"><a href="#关于网络数的解释" class="headerlink" title="关于网络数的解释"></a>关于网络数的解释</h3><p>网络数就是一种网络的子网数, 比如A类地址, 可以分为多少个子网。看表格可以推出网络数的计算公式为: $2^{网络号位数}$。<br>规定网络地址全为<code>0</code>的IP地址是保留地址，意思是“本网络”。</p><ul><li>在A类地址中，实际上 <code>0.0.0.0</code> 是不指派的，而可以指派的最小网络是 <code>1.0.0.0</code>；网络地址为 <code>127</code> 的A类IP地址保留作为本地软件环回测试本主机的进程之间的通信(比如常用的 <code>127.0.0.1</code>，<strong>但实际上网络地址为<code>127</code>的都可以用作本地环回地址</strong>)。所以A类地址网络数为 $2^7-2$。</li><li>在B类地址中，实际上 <code>128.0.0.0</code> 是不指派的，而可以指派的最小网络是 `128.1.0.0，所以B类地址网络数是 $2^{14} - 1$。</li><li>在C类地址中，实际上 <code>192.0.0.0</code> 是不指派的，而可以指派的最小网络是 192.0.1.0，所以C类地址网络数是 $2^{21}-1$。</li></ul><h3 id="关于主机数的解释"><a href="#关于主机数的解释" class="headerlink" title="关于主机数的解释"></a>关于主机数的解释</h3><p>主机数就是一个子网里面可以容纳多少台主机。看表格可以推出主机数的计算公式为: <code>2^主机号位数-2</code>。主机号全为0表示该网络，而主机号全为1表示广播地址，所以要排除掉这两个。比如A类地址 <code>1.0.0.0</code> 表示主机所在的网段的网络地址, <code>1.255.255.255</code> 为该网段的广播地址。</p><h2 id="2-2-私有IP地址"><a href="#2-2-私有IP地址" class="headerlink" title="2.2 私有IP地址"></a>2.2 私有IP地址</h2><p>经常可以看到<code>192.168.1.101</code>这类的IP地址, 这些是私有IP地址, 专用地址, 也就是局域网内使用的的IP地址。<br>公网IP地址是需要向有关部门申请备案的，私有IP地址不用申请, 但是仅限内网使用, 也节约公网IP。</p><table><thead><tr><th>IP地址种类</th><th>私有IP范围</th></tr></thead><tbody><tr><td>A类地址</td><td>10.0.0.0 - 10.255.255.255</td></tr><tr><td>B类地址</td><td>172.16.0.0 - 172.31.255.255</td></tr><tr><td>C类地址</td><td>192.168.0.0 - 192.168.255.255</td></tr></tbody></table><p>路由器看到专用地址就不转发，所以说专用地址作为目的地址是不可能在因特网上传送的。专用IP地址也可叫做可重用地址。那好，问题来了，如果配置了这些专用地址的主机想和因特网上的主机通信，怎么办呢？NAT(network address translation: 网络地址转换)在这种情况下就应运而生了。NAT就是将这种地址转换成有效的外部全球IP地址，使得整个专用网只需要一个全球IP地址就可以与因特网联通。</p><h2 id="2-3-子网掩码"><a href="#2-3-子网掩码" class="headerlink" title="2.3 子网掩码"></a>2.3 子网掩码</h2><p><code>IP地址=标准网络号+子网号+主机号</code>。从IP分类可以很容易确定“标准网络号”，<code>32bit</code>的IP地址除去前面的“标准网络号”之后，剩下的就是“子网号”和“主机号”，那么怎么确定“子网号”和“主机号”了？ 这就需要借助<code>“子网掩码”</code>了。子网掩码也是一个32bit(<code>xxx.xxx.xxx.xxx</code>)的值，其中值为1的bit留给“标准网络号”和“子网号”，为0的bit留给“主机号”。我们可以将子网掩码和IP地址进行二进制<code>“与运算”</code>，通过得到的结果来确定“子网号”。</p><p>以C类IP地址为例，对于规范的C类IP地址来说，规范子网掩码为<code>255.255.255.0</code>，即用32比特IP地址的前24比特标识网络号，后8比特标识主机号。因而，每个C类网络下共可容纳254台主机($2^8-2$)。 如今，我们先思索借用2比特的主机号来充任子网络号的情形。</p><p>C类网络地址<code>210.31.233.0</code>，我们借用2bit的主机号来充当子网号，子网的数目为$2^2-2$(子网号无法全为0或1，所以减2).</p><p><img src="https://static.1key.run/blog/img/wangluoxieyi-jichugailian-2.jpg"></p><p>为了借用原来8位主机号中的前2位充任子网络号，采用了新的非规范子网掩255.255.255.192。<br>采用了新的子网掩码后，借用的2位子网号可以用来标识两个子网：01子网和10子网(子网号无法全为0或1，因而00、11子网无法用)。 </p><p><strong>对于上图的01子网来说</strong>，其网络号的点分十进制的方式为：<code>210.31.233.64</code>，该子网的最小IP地址为：<code>210.31.233.65</code>，最大IP地址为：<code>210.31.233.126</code>（主机号全为1位广播地址），共可容纳62台主机。对该子网的直接广播地址为：<code>210.31.233.127</code>（主机号全为1）。</p><blockquote><p>经常见到像<code>192.168.1.0/24</code>这样的写法，它的意思是网络号为<code>192.168.1.0</code>；子网掩码为24位，即<code>111111111 111111111 111111111 00000000</code>，转为点分十进制就为<code>255.255.255.0</code>，没有借用主机号来充当子网号，可以拥有的主机数为$2^8$-2.</p></blockquote><h2 id="2-3-网关的作用"><a href="#2-3-网关的作用" class="headerlink" title="2.3 网关的作用"></a>2.3 网关的作用</h2><p>你的住址IP是<code>武汉市洪山区文治街16号</code>，你的父母只允许你和文治街的小朋友（同一个子网）一起玩耍，如果你想要去和别的街道（别的子网）的小朋友玩耍，你就需要经过你的父母的同意，由你的父母带你过去，这时候你的父母就充当了<strong>网关</strong>的角色，没有你的父母，你就不能和其他街道（其他子网）的小朋友玩耍。</p><h1 id="三、包的封装与解封装"><a href="#三、包的封装与解封装" class="headerlink" title="三、包的封装与解封装"></a>三、包的封装与解封装</h1><blockquote><p>封装英文：Encapsulation<br>解封装英文：Demultiplexing</p></blockquote><p>当应用程序使用网络传送数据时，数据按照协议栈从上到下的顺序，逐次通过每一层。其中每一层对收到的数据都要增加一些首部信息（有时还增加尾部信息）。最终生成一串比特流通过以太网来传输，我们称这串比特流叫帧。<br>如图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-jichugailian-3.jpg"></p><p><strong>当数据报到达链路层时</strong>，链路层也要对IP数据包封装进行包装。链路层也要对IP数据包封装的方式主要有<code>以太网IP数据包封装</code>（RFC894）、<code>IEEE 802 IP数据报封装</code>（RFC1042）两种，最常使用的封装格式是以太网IP数据包封装（RFC894）。下图显示了这两种不同形式的封装格式：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-jichugailian-4.jpg"><br>从图中可以看到<code>以太网封装</code>限制了数据帧的最大长度为1500字节，这个限制叫做MTU，最大传输单元（详见第四节）。</p><p>接收端收到帧之后，按照和上面相反的顺序（协议栈从下到上）来解包，依次解析每一层加入的头部（或尾部），最终将原始数据传给最上层应用程序。<br>如图：<br><img src="https://static.1key.run/blog/img/wangluoxieyi-jichugailian-5.jpg"></p><p>因为传输层的TCP、UDP、ICMP等都有可能向网络层IP协议传送数据，这样在IP协议层解包的时候，需要知道这个包对应的上层协议是哪一个，因此IP协议必须在生成的IP首部加入某种标识，以表明数据的上一层的具体协议。为此，IP在首部中存入了一个长度为8bit的数值，称作协议域。常见的IP协议号有：<br>1表示ICMP协议，2表示IGMP协议，6表示TCP协议，17表示UDP协议。</p><blockquote><p>完整的IP协议号见：<a href="https://zh.wikipedia.org/wiki/IP%E5%8D%8F%E8%AE%AE%E5%8F%B7%E5%88%97%E8%A1%A8">IP协议号列表</a></p></blockquote><h1 id="四、MTU"><a href="#四、MTU" class="headerlink" title="四、MTU"></a>四、MTU</h1><p>前面第三节提到了以太网封装限制了数据帧的长度为1500字节，这个限制是在链路层封装IP数据报时作的。如果IP层的数据报比链路层的这个MTU值大，那么IP层就需要分片（英文：fragmentation），把数据报分成若干片，保证每一片的大小都小于MTU值。</p><h3 id="windows系统修改MTU值"><a href="#windows系统修改MTU值" class="headerlink" title="windows系统修改MTU值"></a>windows系统修改MTU值</h3><ul><li><p>查询当前MTU值</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">netsh interface ipv4 show subinterfaces<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://static.1key.run/blog/img/wangluoxieyi-jichugailian-6.jpg"></p></li><li><p>修改MTU值</p><pre class="line-numbers language-none"><code class="language-none">netsh interface ipv4 set subinterface "本地连接" mtu=1480 store=persistent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><blockquote><p>文章参考：<br><a href="https://m.vipcn.com/a/360973/">https://m.vipcn.com/a/360973/</a><br><a href="https://ahaochan.github.io/posts/IP_address,_subnet_mask,_gateway_Introduction.html">https://ahaochan.github.io/posts/IP_address,_subnet_mask,_gateway_Introduction.html</a><br><a href="https://www.zhihu.com/question/20717354">https://www.zhihu.com/question/20717354</a></p></blockquote><p>《TCP/IP详解 卷1：协议》在线阅读地址：<a href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP地址 </tag>
            
            <tag> 子网掩码 </tag>
            
            <tag> 网关 </tag>
            
            <tag> MTU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解C/C++运行时库</title>
      <link href="/2023/06/20/li-jie-c-c-yun-xing-shi-ku/"/>
      <url>/2023/06/20/li-jie-c-c-yun-xing-shi-ku/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、什么是运行时库"><a href="#一、什么是运行时库" class="headerlink" title="一、什么是运行时库"></a>一、什么是运行时库</h2><p>运行时库（Runtime library）通俗的说就是我们的程序运行的时候所依赖的库文件，在Windows平台这些库由微软提供，并且是以2种形式提供：<code>静态库(lib)</code>、<code>动态库(lib+dll)</code>。每个库还都提供<code>debug</code>、<code>release</code> 2个版本。</p><p>C/C++运行时库从形式上来讲和我们自己开发的静态库、动态库没什么两样，只是它们由微软开发和维护，并提供了一些常用的功能支持（如<code>malloc</code>,<code> free</code>, <code>printf</code>等等），如果我们的程序需要使用这些功能（事实上，只要是C/C++程序就一定会用到运行时库提供的功能），就要链接C/C++运行时库。我们可以自主选择是链接“静态库”还是“动态库”，是链接“debug版本”的还是“release版本”的。</p><h2 id="二、如何链接运行时库"><a href="#二、如何链接运行时库" class="headerlink" title="二、如何链接运行时库"></a>二、如何链接运行时库</h2><p>大家可能注意到我们在平时开发中从来没有显式的来链接这些库，这是为什么了？<br>因为我们的编译器为我们提供了便利，我们只需要向编译器指定特定的编译选项（如<code>MT、MD、MTd、MDd</code>），编译器就会自动链接对应的库。</p><p>同时，编译器会根据<code>MT</code>和<code>MD</code>来定义相应的预处理宏：<code>MT</code> 对应 <code>_MT宏</code>，<code>MD</code>对应<code>_MD宏</code>。</p><p>例如，我们通过<code>Visual Studio</code>开发C/C++程序时，在工程属性中配置“运行库”为<code>MT、MD、MTd、MDd</code>中的一个：<br><img src="https://static.1key.run/blog/img/windows-hxbc-ljynsk-1.jpg"><br>就相当于间接的向编译器指定编译选项和定义相应的宏。</p><h2 id="三、不同版本和形态的运行时库"><a href="#三、不同版本和形态的运行时库" class="headerlink" title="三、不同版本和形态的运行时库"></a>三、不同版本和形态的运行时库</h2><h3 id="3-1-运行时库对应的文件"><a href="#3-1-运行时库对应的文件" class="headerlink" title="3.1 运行时库对应的文件"></a>3.1 运行时库对应的文件</h3><p>下表列出各种编译选项的含义以及对应的库文件：</p><table><thead><tr><th>类型</th><th>全称</th><th>含义</th><th>对应的库文件</th><th>备注</th></tr></thead><tbody><tr><td>ML</td><td>Single-Threaded</td><td>Release版的单线程静态库</td><td><code>libc.lib</code></td><td>从VS2005起被废弃</td></tr><tr><td>MLd</td><td>Single-Threaded Debug</td><td>Debug版的单线程静态库</td><td><code>libcd.lib</code></td><td>从VS2005起被废弃</td></tr><tr><td>MT</td><td>Multi-threaded</td><td>Release版的多线程静态库</td><td><code>libcmt.lib</code></td><td></td></tr><tr><td>MTd</td><td>Multi-threaded Debug</td><td>Debug版的多线程静态库</td><td><code>libcmtd.lib</code></td><td></td></tr><tr><td>MD</td><td>Multi-threaded DLL</td><td>Release版的多线程动态库</td><td><code>msvcrt.lib + msvcrxxx.dll</code> <code>msvcprt.lib+msvcpxxx.dll</code></td><td></td></tr><tr><td>MDd</td><td>Multi-threaded DLL Debug</td><td>Debug版的多线程动态库</td><td><code>msvcrtd.lib + msvcrxxxd.dll</code> <code>msvcprtd.lib + msvcpxxxd.dll</code></td><td></td></tr></tbody></table><p>如果计算机上安装了多个版本的VC++运行环境（或者多个版本的Visual Studio），则相同名称的lib或dll就会存在多份。如<code>msvcrt.lib</code>文件：<br><img src="https://static.1key.run/blog/img/windows-hxbc-ljynsk-2.jpg"></p><h3 id="3-2-运行时库文件命名规则"><a href="#3-2-运行时库文件命名规则" class="headerlink" title="3.2 运行时库文件命名规则"></a>3.2 运行时库文件命名规则</h3><p><code>msvcr100d.dll</code>为例：</p><pre class="line-numbers language-none"><code class="language-none">ms = Microsoftv = Visualc = C Programr = Run-time100 = Versiond = Debug   (不带d即为release版本)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>msvcp100d.dll</code>为例：</p><pre class="line-numbers language-none"><code class="language-none">ms = Microsoftv = Visualcp = C Plus Plus 即C++100 = Versiond = Debug   (不带d即为release版本)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、运行时库使用注意事项"><a href="#四、运行时库使用注意事项" class="headerlink" title="四、运行时库使用注意事项"></a>四、运行时库使用注意事项</h2><ul><li>不要混合使用运行时库的<code>静态库版</code>和<code>动态库版</code>。</li><li>不要混合使用运行时库的<code>debug版</code>和<code>release版</code>。</li><li>不要混合使用Visual Studio 2013 及更早版本的运行时库，但在 Visual Studio 2015 及更高版本中提供的运行时库可以保证二进制兼容。</li></ul><h2 id="五、Visual-Studio-版本之间的-C-二进制兼容性（摘自MSDN）"><a href="#五、Visual-Studio-版本之间的-C-二进制兼容性（摘自MSDN）" class="headerlink" title="五、Visual Studio 版本之间的 C++ 二进制兼容性（摘自MSDN）"></a>五、Visual Studio 版本之间的 C++ 二进制兼容性（摘自MSDN）</h2><p>Visual Studio 2013 及更早版本中的 Microsoft C++ (MSVC) 编译器工具集不保证主版本间的二进制兼容性。 无法链接由这些工具集的不同版本生成的对象文件、静态库、动态库和可执行文件。 ABI、对象格式和运行时库不兼容。</p><p>我们在 Visual Studio 2015 及更高版本中改变了此行为。 由其中任一版本的编译器编译的运行时库和应用具有二进制兼容性。 这反映在 C++ 工具集主版本号中，对于自 Visual Studio 2015 以来的所有版本，<strong>该版本号都以 14 开头</strong>。 （对于 Visual Studio 2015、2017、2019 和 2022，工具集版本分别为 v140、v141、v142 和 v143）。** 假设你具有 Visual Studio 2015 生成的第三方库。 你仍可在 Visual Studio 2017、2019 或 2022 生成的应用程序中使用它们。 无需使用匹配工具集重新编译**。 最新版本的 Microsoft Visual C++ 可再发行程序包（可再发行程序包）适用于所有版本。</p><h3 id="对二进制兼容性的限制"><a href="#对二进制兼容性的限制" class="headerlink" title="对二进制兼容性的限制"></a>对二进制兼容性的限制</h3><p>v140、v141、v142 和 v143 工具集与次要版本号更新之间的二进制兼容性方面存在三个重要限制：</p><ul><li>你可以混合使用由 v140、v141、v142 和 v143 工具集的不同版本生成的二进制文件。 但是，<strong>必须使用至少与应用中最新二进制文件同样新的工具集进行链接</strong>。 下面是一个示例：可以将使用任何 2017 工具集（v141，版本 15.0 到 15.9）编译的应用链接到使用 Visual Studio 2019 版本 16.2 (v142) 编译的静态库。 只是必须使用版本 16.2 或更高版本工具集链接它们。 只要使用 16.4 或更高版本工具集，便可以将版本 16.2 库链接到版本 16.4 应用。</li><li>应用使用的可再发行程序包具有类似的二进制兼容性限制。 混合使用由工具集的不同受支持版本生成的二进制文件时，可再发行程序包版本必须至少与任何应用组件使用的最新工具集一样新。</li><li>使用<a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/gl-whole-program-optimization?view=msvc-170">/GL</a><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/gl-whole-program-optimization?view=msvc-170">（全程序优化）</a>编译器开关编译或是使用 <a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/ltcg-link-time-code-generation?view=msvc-170">/LTCG</a><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/ltcg-link-time-code-generation?view=msvc-170">（链接时间代码生成）</a>链接的静态库或对象文件不在各个版本间二进制兼容（包括次要版本更新）。使用 <code>/GL</code> 和 <code>/LTCG</code> 编译的所有对象文件和库必须将完全相同的工具集用于编译和最终链接。 例如，使用 Visual Studio 2019 版本 16.7 工具集中的 <code>/GL</code>生成的代码无法链接到使用 Visual Studio 2019 版本 16.8 工具集中的 <code>/GL</code>生成的代码。 编译器会发出<a href="https://learn.microsoft.com/zh-cn/cpp/error-messages/compiler-errors-1/fatal-error-c1047?view=msvc-170">错误 C1047</a>。</li></ul><h3 id="从-Visual-Studio-2015-及更高版本升级-Microsoft-Visual-C-可再发行程序包"><a href="#从-Visual-Studio-2015-及更高版本升级-Microsoft-Visual-C-可再发行程序包" class="headerlink" title="从 Visual Studio 2015 及更高版本升级 Microsoft Visual C++ 可再发行程序包"></a>从 Visual Studio 2015 及更高版本升级 Microsoft Visual C++ 可再发行程序包</h3><p>对于 Visual Studio 2015、2017、2019 和 2022，我们使 Microsoft Visual C++ 可再发行程序包主版本号保持相同。 这意味着一次只能安装可再发行程序包的一个实例。 较新版本会覆盖已安装的任何较旧版本。 例如，一个应用可能会从 Visual Studio 2015 安装可再发行程序包。 随后另一个应用从 Visual Studio 2022 安装可再发行程序包。 2022 版本会覆盖较旧版本，但由于它们具有二进制兼容性，早期应用仍可正常工作。 我们确保最新版本的可再发行程序包具有所有最新的功能、安全更新和 bug 修补程序。 这便是为什么我们始终建议升级到最新可用版本。</p><p>同样，已安装了较新版本时，无法安装较旧的可再发行程序包。 如果尝试，则安装程序会报告错误。 如果在已具有 2022 版本的计算机上安装 2017 或 2019 可再发行程序，则会看到如下所示的错误：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">0x80070666 - Another version of this product is already installed. Installation of this version cannot continue. To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此错误是设计使然。 建议保持安装最新版本。 请确保安装程序可以在无提示的情况下从此错误中恢复。</p>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运行时库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(7)--使用std::string跨MT模块传参</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-7-shi-yong-std-string-kua-mt-mo-kuai-chuan-can/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-7-shi-yong-std-string-kua-mt-mo-kuai-chuan-can/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><p>前面的<a href="/2023/06/20/windows-nei-cun-ti-xi-6-kua-mo-kuai-nei-cun-fen-pei-shi-fang/" title="Windows内存体系(6)--跨模块内存分配释放">Windows内存体系(6)--跨模块内存分配释放</a>文章解释了跨MT模块分配的内存相互释放为什么会崩溃的问题。</p><h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>这篇文章主要介绍我们在实际开发中经常遇到的一个问题：针对MT模块定义接口函数时，接口参数使用<code>std::string</code>类型，在程序运行时遇到<code>"Debug Assertioni Failed"</code>错误的问题。<br><img src="https://static.1key.run/blog/img/windows-nctx-stdstring-mt-1.jpg"></p><p>上面的错误提示是<code>debug_heap.cpp</code>文件中的一个调试断言（<code>release模式</code>下调用的是<code>heap.cpp</code>中的分配函数），用于判断指针是否指向堆分配的内存块的第一块。在release模式下不会弹出这样的断言错误，程序可能会直接崩溃（崩溃相对来说还比较好排查），或者出现其他不可预料的、难以排查的错误。</p><h2 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h2><p>现有<code>DLLUser.exe</code>调用<code>DLL.dll</code>中的<code>TestFun</code>函数，代码量非常小：</p><h4 id="DLL-dll中TestFun函数定义："><a href="#DLL-dll中TestFun函数定义：" class="headerlink" title="DLL.dll中TestFun函数定义："></a><code>DLL.dll</code>中<code>TestFun</code>函数定义：</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">DLL_API void TestFun( std::string str){return;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="DLLUser-exe中调用TestFun函数："><a href="#DLLUser-exe中调用TestFun函数：" class="headerlink" title="DLLUser.exe中调用TestFun函数："></a><code>DLLUser.exe</code>中调用<code>TestFun</code>函数：</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int _tmain(int argc, _TCHAR* argv[]){std::string str = "test";TestFun(str);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码运行之后程序就会弹出错误断言。原因是<code>std::string</code>在进行<code>值传参</code>的过程中会执行一次深拷贝，即：在堆上分配内存块，拷贝“test”到内存块中，然后将临时形参<code>std::string</code>对象传递到dll中，dll中的<code>TestFun</code>函数在作用域结束后对临时形参进行释放时就出现了错误，因为尝试在<code>dll的crt堆</code>中释放由在<code>exe的crt堆</code>中分配的内存块。</p><p><img src="https://static.1key.run/blog/img/windows-nctx-stdstring-mt-2.jpg"></p><h2 id="三、自定义std-allocator解决崩溃"><a href="#三、自定义std-allocator解决崩溃" class="headerlink" title="三、自定义std::allocator解决崩溃"></a>三、自定义<code>std::allocator</code>解决崩溃</h2><p>通过上面问题的分析，加上前面几篇文章对Windows内存体系的介绍，我们不难想出解决方案，其中一种方案就是让<code>std::string</code>统一在进程的默认堆上分配内存块，而不是在各个模块的<code>crt堆</code>上分配。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;windows.h&gt;#include &lt;string&gt;#include &lt;vector&gt;template &lt;typename T&gt;class vm_allocator : public std::allocator&lt;T&gt; {public:typedef size_t size_type;typedef T* pointer;typedef const T* const_pointer;template&lt;typename _Tp1&gt;struct rebind {typedef vm_allocator&lt;_Tp1&gt; other;};pointer allocate(size_type n, const void *hint = 0) {UNREFERENCED_PARAMETER(hint);void* pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, n * sizeof(T));return (pointer)pBuffer;}void deallocate(pointer p, size_type n) {UNREFERENCED_PARAMETER(n);if (p) {HeapFree(GetProcessHeap(), 0, p);}}vm_allocator() throw() : std::allocator&lt;T&gt;() {}vm_allocator(const vm_allocator &amp;a) throw() : std::allocator&lt;T&gt;(a) {}template &lt;class U&gt;vm_allocator(const vm_allocator&lt;U&gt; &amp;a) throw() : std::allocator&lt;T&gt;(a) {}~vm_allocator() throw() {}};typedef std::basic_string&lt;char, std::char_traits&lt;char&gt;, vm_allocator&lt;char&gt; &gt; mystring;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码使用自定义的内存分配器<code>vm_allocator&lt;char&gt;</code>定义了<code>mystring</code>类，我们只需要将<code>TestFun</code>函数接口中的<code>std::string</code>修改为<code>mystring</code>即可解决崩溃问题。</p>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MT </tag>
            
            <tag> DLL </tag>
            
            <tag> std::string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(6)--跨模块内存分配释放</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-6-kua-mo-kuai-nei-cun-fen-pei-shi-fang/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-6-kua-mo-kuai-nei-cun-fen-pei-shi-fang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><p> <code>《Windows核心编程 第五版》第19章 DLL基础（511页）</code>中给出了一个建议：“当一个MT版本的模块如果提供一个内存分配函数的时候，它必须同时提供另一个用来释放内存的函数。”。说得更加直白一点就是，“对于MT的模块，不要跨模块进行内存释放。”。但是核心编程这本书上面没有具体分析原因，本文就来分析具体的原因。</p><h2 id="一、为什么不同堆分配的内存块不能相互释放？"><a href="#一、为什么不同堆分配的内存块不能相互释放？" class="headerlink" title="一、为什么不同堆分配的内存块不能相互释放？"></a>一、为什么不同堆分配的内存块不能相互释放？</h2><p>Windows的<code>堆管理器</code>对每个进程都维护了多个<code>“堆”</code>，我们从每个<code>“堆”</code>中分配处理的内存块的地址都不一样。所以我们不能将从“堆A”中分配出来的内存块拿到“堆B”中，让“堆B”来释放，这样就会导致程序异常。</p><p><img src="https://static.1key.run/blog/img/windows-nctx-kmkncsf-1.png"></p><p>如上图，通过<code>malloc</code>函数从“堆A”中分配100字节内存块，内存块地址为<code>0x123456</code>；从“堆B”中分配100字节内存块，内存块地址为<code>0x345678</code>.<br>如果将<code>0x123456</code>这个地址拿到“堆B”中去释放，势必会导致异常，因为“堆B”中没有这地址。</p><p>那么我们是不是可以使用<code>HeapFree</code>函数来释放<code>hHeap</code>参数指定的“堆”中的任何内存块了。答案是：不能。<br>回忆前面介绍的<code>HeapFree</code>函数，</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">BOOL HeapFree(  HANDLE hHeap,  DWORD dwFlags,  LPVOID lpMem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数只要求传入了内存块的起始地址指针，但没有要求传入需要释放的内存块的<code>大小</code>，那么该函数是如何知道起始地址指针指向的内存块的大小了？ </p><p>我们可以简单的理解为，<code>HeapAlloc</code>函数每次分配内存块的时候都会额外分配一点空间用于存储一个结构体，该结构体中存储了本次分配的内存块的大小等信息。大致如下图：<br><img src="https://static.1key.run/blog/img/windows-nctx-kmkncsf-2.jpg"></p><p>所以，<code>HeapFree</code>函数首先会通过<code>lpMem</code>指针计算出“结构体”的地址，然后从结构体中获取到分配的内存块的具体大小，最后执行释放操作。</p><p>基于上面的原因，我们不能在<code>HeapFree</code>函数的<code>lpMem</code>参数中传入随意的地址，因为该地址处可能没有存储用于存放内存块信息的结构体，所以释放操作就会失败。<code>free</code>函数也一样，因为<code>free</code>函数内部也是调用的<code>HeapFree</code>函数。</p><h2 id="二、为什么MT模块内存不能相互释放，而MD的却可以？"><a href="#二、为什么MT模块内存不能相互释放，而MD的却可以？" class="headerlink" title="二、为什么MT模块内存不能相互释放，而MD的却可以？"></a>二、为什么MT模块内存不能相互释放，而MD的却可以？</h2><h3 id="我们先分析为什么MT模块的内存间相互释放会崩溃。"><a href="#我们先分析为什么MT模块的内存间相互释放会崩溃。" class="headerlink" title="我们先分析为什么MT模块的内存间相互释放会崩溃。"></a>我们先分析为什么MT模块的内存间相互释放会崩溃。</h3><p>现在有2个模块（<code>A.dll</code>和<code>B.dll</code>）都是使用<code>MT</code>运行时库，即加载的静态库<code>libcmt.lib</code>（可以参考<a href="/2023/06/20/li-jie-c-c-yun-xing-shi-ku/" title="理解C/C++运行时库">理解C/C++运行时库</a>），在<code>A.dll</code>中使用<code>malloc</code>分配100字节的内存，<code>malloc</code>返回的内存地址为<code>0x123456</code>。然后将该地址传给<code>B.dll</code>，在<code>B.dll</code>中调用<code>free</code>函数来释放这个内存。如图：<br><img src="https://static.1key.run/blog/img/windows-nctx-kmkncsf-3.jpg"></p><p>从<a href="/2023/06/20/windows-nei-cun-ti-xi-5-dui/" title="Windows内存体系(5)--堆">Windows内存体系(5)--堆</a>我们知道，DLL在启动代码<code>_DllMainCRTStartup</code>中会建立一个“堆”（堆句柄存放在_crtheap变量中），所以A.dll和B.dll中都会有一个crt堆。</p><p>为了区分，我们将<code>A.dll</code>中的<code>crt堆</code>称作<code>_crtheap_A</code>，<code>B.dll</code>中的<code>crt堆</code>称作<code>_crtheap_B</code>。</p><p>从上面图可以看到，<code>A.dll</code>中<code>malloc</code>的内存拿到<code>B.dll</code>去中去<code>free</code>，就相当于从堆<code>_crtheap_A</code>中分配的内存拿到另一个堆<code>_crtheap_B</code>中的释放。第一节已经解释了为什么不能这样做了。</p><h3 id="现在我们分析为什么MD模块的内存间相互释放不会崩溃。"><a href="#现在我们分析为什么MD模块的内存间相互释放不会崩溃。" class="headerlink" title="现在我们分析为什么MD模块的内存间相互释放不会崩溃。"></a>现在我们分析为什么MD模块的内存间相互释放不会崩溃。</h3><p>还是2个模块（<code>A.dll</code>和<code>B.dll</code>），但是现在他们都是使用<code>MD</code>运行时库，即加载的动态库<code>msvcr100.dll</code>，程序的代码的过程和上面一样，还是在<code>A.dll</code>中使用<code>malloc</code>分配100字节的内存，<code>malloc</code>返回的内存地址为<code>0x123456</code>。然后将该地址传给<code>B.dll</code>，在<code>B.dll</code>中调用<code>free</code>函数来释放这个内存。但是这个时候程序却不会崩溃，通过下面的图我们基本可以明白原因了，如图：<br><img src="https://static.1key.run/blog/img/windows-nctx-kmkncsf-4.jpg"></p><p>因为A、B两个dll都是链接的·msvcr100.dll·，同一个dll在一个进程只会被加载一次，所以进程中只会有一个crt堆（<code>_crtheap</code>），<code>malloc</code>和<code>free</code>都是运行时库提供的函数，所以都会调到运行时库里面去，然后从运行时库里面的<code>_crtheap</code>分配和释放内存块。因为分配和释放都是在同一个堆上，所以不会崩溃。</p>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MT </tag>
            
            <tag> DLL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(5)--堆</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-5-dui/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-5-dui/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、为什么要使用堆-Heap-？"><a href="#一、为什么要使用堆-Heap-？" class="headerlink" title="一、为什么要使用堆 (Heap)？"></a>一、为什么要使用堆 (Heap)？</h2><p>应用程序虽然可以使用页面粒度的函数（如<code>VirualAlloc</code>）来分配一个最小为<code>4KB</code>或<code>8K</code>的内存块，但是很多时候我们并不需要分配这么大的内存块，我们可能只想分配1K，2K的内存块，那么这个时候无论从内存的使用率，还是从性能的角度来看，再分配这么大的一个内存区域显然不是最优的了。</p><p>为了满足这种需求，Windows提供了一个被称为<code>“堆管理器”</code>的组件，它负责管理大内存区域中的内存分配，这些大内存区域就是通过一些页面粒度的内存分配函数（如<code>VirualAlloc</code>）来预定（<code>reserve</code>）的。</p><p>堆管理器中的分配粒度相对比较小：<code>在32位系统上是8字节，在64位系统上是16字节</code>。</p><p>堆管理器已经被windows系统精心设计成：在这些很小的内存分配的情况下进行了内存使用率和性能两个方面的优化。</p><h2 id="二、进程的默认堆"><a href="#二、进程的默认堆" class="headerlink" title="二、进程的默认堆"></a>二、进程的默认堆</h2><p>每个进程至少有一个堆，那就是进程的<code>默认堆</code>。进程的<code>默认堆</code>是在进程启动的时候创建的，而且在进程的生命周期中永远不会被删除。</p><p><code>“默认堆”</code>的默认大小为<code>1MB</code>，但是可以通过<code>/HEAP</code>链接器编译器选项来指定一个更大的起始大小。这个大小值只是初始的保留内存大小，后期根据需要它可以自动扩充。</p><p>应用程序可以调用<code>GetProcessHeap</code>来获取进程的默认堆，也可以通过调用<code>HeapCreate</code>函数来创建额外的私有堆，当一个进程不在需要一个私有堆的时候，它可以调用<code>HeapDestory</code>来释放虚拟地址空间。</p><h2 id="三、crt堆"><a href="#三、crt堆" class="headerlink" title="三、crt堆"></a>三、crt堆</h2><p>C语言的<code>malloc,free</code>函数以及C++的<code>new,delete</code>都是从<code>堆</code>上分配和释放内存的。但是他们所使用的堆不是进程的<code>默认堆</code>，他们使用的是<code>私有堆</code>。可是我们在使用<code>malloc</code>函数之前并有进行任何私有堆的创建操作呀？ 因为<code>malloc</code>函数使用的这个私有堆不需要程序员来创建，而是在C或C++运行时库DLL的启动代码<code>_DllMainCRTStartup</code>中自动创建的。下面通过解析<code>malloc</code>函数的调用过程来说明这一点。</p><p><code>malloc</code>函数的定义在<code>malloc.c</code>文件中，调用流程如下：<br>（以<code>Microsoft Visual Studio 10.0</code>为例，<code>malloc.c</code>文件路径为<code>C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\crt\src</code>）</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">(1). void* __cdecl malloc(size_t const size)(2). void * __cdecl _malloc_base (size_t size)(3). void * __cdecl _heap_alloc (size_t size)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>_heap_alloc </code>的定义如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">__forceinline void * __cdecl _heap_alloc (size_t size){    if (_crtheap == 0) {        _FF_MSGBANNER();    /* write run-time error banner */        _NMSG_WRITE(_RT_CRT_NOTINIT);  /* write message */        __crtExitProcess(255);  /* normally _exit(255) */    }    return HeapAlloc(_crtheap, 0, size ? size : 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码中，我们可以看到分配内存块的时候使用的是<code>_crtheap</code>句柄标记的堆。那么<code>_crtheap</code>堆是何时创建的了？</p><p>我们从<code>heapinit.c</code>文件中的<code>_heap_init</code>函数可以看到<code>_crtheap</code>堆的创建过程：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">HANDLE _crtheap=NULL;/****_heap_init() - Initialize the heap**Purpose:*       Setup the initial C library heap.**       NOTES:*       (1) This routine should only be called once!*       (2) This routine must be called before any other heap requests.**Entry:*       &lt;void&gt;*Exit:*       Returns 1 if successful, 0 otherwise.**Exceptions:*       If heap cannot be initialized, the program will be terminated*       with a fatal runtime error.********************************************************************************/int __cdecl _heap_init (void){        ULONG HeapType = 2;        //  Initialize the "big-block" heap first.        if ( (_crtheap = HeapCreate(0, BYTES_PER_PAGE, 0)) == NULL )            return 0;#ifdef _WIN64        // Enable the Low Fragmentation Heap by default on Windows XP and        // Windows Server 2003.  It's the 8 byte overhead heap, and has        // generally better performance charateristics than standard heap,        // particularly for apps that perform lots of small allocations.        if (LOBYTE(GetVersion()) &lt; 6)        {            HeapSetInformation(_crtheap, HeapCompatibilityInformation,                               &amp;HeapType, sizeof(HeapType));        }#endif  /* _WIN64 */        return 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码，我们可以看到，创建的<code>私有堆</code>句柄存放在一个<code>全局的_crtheap变量</code>中，后面每次调用<code>malloc</code>函数都是从该堆分配内存块。</p><h2 id="四、Win32堆函数"><a href="#四、Win32堆函数" class="headerlink" title="四、Win32堆函数"></a>四、Win32堆函数</h2><p>我们最常用的Windows堆函数如下：</p><ul><li><code>HeapCreate</code>或<code>HeapDestory</code> — 创建或删除一个私有堆</li><li><code>HeapAlloc</code> — 分配一个堆内存块</li><li><code>HeapFree</code> — 释放一个原先由<code>HeapAlloc</code>分配的内存块</li><li><code>HeapReAlloc</code> — 增长或缩减一个已分配的内存块的大小</li><li><code>HeapLock</code>或<code>HeapUnLock</code> — 控制堆操作的内存访问</li><li><code>HeapWalk</code> — 列举一个堆内部的内存项和区域。</li></ul><h2 id="五、Windows内存管理API分层结构"><a href="#五、Windows内存管理API分层结构" class="headerlink" title="五、Windows内存管理API分层结构"></a>五、Windows内存管理API分层结构</h2><p><img src="https://static.1key.run/blog/img/windows-nctx-dui-1.gif"></p><p>从上图可以看到，虚拟内存机制（<code>Virtual Memory</code>）是windows内存体系的基础，无论你是使用<code>堆</code>，还是使用<code>内存映射文件</code>，它们的底层都是基于虚拟内存来实现的。</p><p>从上往下，每一层的API在内部会依次调用下一层的API。下图中列举了每层API中经常使用的函数：</p><ul><li><strong>CRT Memory Functions：</strong><code>malloc, free, new, delete</code></li><li><strong>Local, Global Memory API: ** <code>LocalAlloc, GlobalAlloc</code> （</strong>这2个函数现在不建议使用，注意是为了兼容以前的老代码才保留下来的**）</li><li><strong>Heap Memory API：</strong><code>HeapCreate, HeapAlloc, HeapDestory</code></li><li><strong>Virtual Memory API：</strong><code>VirtualAlloc, VirtualFree</code></li><li><strong>Memory Mapped File API：</strong><code>CreateFileMapping, MapViewOfFile, MapViewOfFileEx, UnMapViewOfFile</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> Heap </tag>
            
            <tag> 内存管理API分层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(4)--内存对齐</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-4-nei-cun-dui-qi/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-4-nei-cun-dui-qi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、内存为什么要对齐"><a href="#一、内存为什么要对齐" class="headerlink" title="一、内存为什么要对齐"></a>一、内存为什么要对齐</h2><p>虽然所有的变量都是保存在特定地址的内存中，但最好还是按照内存对齐的要求来存储。这主要出于两个方面的原因考虑： </p><ol><li>平台原因：<br>不是所有的硬件平台(特别是嵌入式系统中使用的低端处理器)都能访问任意地址上的任意数据，某些硬件平台只能访问对齐的地址，否则会出现硬件异常。 </li><li>性能原因：<br>如果数据存放在未对齐的内存空间中，则处理器访问变量时需要进行两次内存访问才能完整读取该变量的值，而对齐的内存访问仅需一次访问。</li></ol><h2 id="二、内存对齐的规则"><a href="#二、内存对齐的规则" class="headerlink" title="二、内存对齐的规则"></a>二、内存对齐的规则</h2><ol><li><p>对于结构（或联合）的各个成员，第一个成员位于偏移为0，以后每个数据成员的偏移量必须是<code>#pragma pack指定的数值和结构体(或联合)中最大数据成员长度 这2个数值中较小的一个</code>的倍数。<br>使用伪代码表示： <code>min(#pragma pack, 结构最大数据成员长度) * N</code></p></li><li><p>在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐也按照<code>#pragma pack指定的数值和结构(或联合)最大数据成员长度这2个数值中较小的一个</code>进行。</p></li></ol><blockquote><p>如果没有使用<code>#pragma pack</code>指令来显式的指定内存对齐的字节数，则按照默认字节数来对齐，各个平台的默认对齐规则如下：<code>32位CPU默认按照4字节对齐；64位CPU默认按照8字节对齐。</code></p></blockquote><h2 id="三、-pragma-pack命令"><a href="#三、-pragma-pack命令" class="headerlink" title="三、#pragma pack命令"></a>三、#pragma pack命令</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma pack(n) // 使用自定义n字节对齐  n可以为1，2，4，8，16#pragma pack()  // 使用缺省字节对齐#pragma pack(show) // 在编译输出窗口以警告的形式显示出当前的内存以几个字节对齐<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="四、结构体内存对齐示例"><a href="#四、结构体内存对齐示例" class="headerlink" title="四、结构体内存对齐示例"></a>四、结构体内存对齐示例</h2><p>在64位系统上编译下面的测试程序，已知在64位系统上各类型占用字节数如下：</p><pre class="line-numbers language-none"><code class="language-none">char     1字节short    2字节int      4字节long     4字节double   8字节long long 8字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma pack(8)struct A {char s[5];short c;int a;};int main(){int i = sizeof(A);printf("%d", i);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照第二节所讲的内存对齐规则，分析如下：<br>因为结构体中最大的数据成员长度为int（即4字节），而且<code>#pragma pack(8)</code>指令指定按照8字节对齐，所以<code>min(4,8) = 4</code>，故我们可以知道结构体A按照4字节对齐。</p><p>下图是结构体A按照4字节对齐的内存布局（需要注意的是“内存不是填充在s5后面，而是填充在c后面”）：<br><img src="https://static.1key.run/blog/img/windows-nctx-ncdq-1.jpg"></p><p>从图我们很容易知道<code>sizeof(A) = 12</code>.</p>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存对齐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(3)--内存映射文件</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-3-nei-cun-ying-she-wen-jian/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-3-nei-cun-ying-she-wen-jian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一、为什么需要内存映射"><a href="#一、为什么需要内存映射" class="headerlink" title="一、为什么需要内存映射"></a>一、为什么需要内存映射</h1><p><code>“内存映射文件”</code>可以将硬盘上的文件映射到<code>虚拟地址空间</code>，这样就不需要将所有东西都放入到页交换文件中，比如系统有许多程序同时运行时，如果将这些程序文件都加载到页交换文件中，<code>页交换文件</code>将会变得非常大。事实上，Windows也并没有将硬盘上的程序文件复制到<code>页交换文件</code>中，因为这样不仅会让<code>页交换文件</code>将会变得非常大，也会浪费很多时间，特别是可执行程序非常大的时候。</p><p>当用户要求执行一个应用程序时，系统会打开该应用程序的<code>.exe</code>文件，并计算出应用程序的代码和数据的大小，然后系统会在进程的虚拟地址空间预定一块地址空间，并注明与该区域相关联的物理存储器就是<code>.exe</code>文件本身。</p><p>当把一个位于硬盘上的文件（可以是<code>.exe</code>，<code>.dll</code>也可以是普通文件）映像用作地址空间区域对应的物理存储器时，我们称这个文件映像为<code>“内存映射文件”</code>。</p><p>现在我们可以对<a href="/2023/06/20/windows-nei-cun-ti-xi-2-xu-ni-nei-cun/" title="Windows内存体系(2)--虚拟内存">Windows内存体系(2)--虚拟内存</a>第2节的图进行完善了，加入“内存映射文件”部分：<br><img src="https://static.1key.run/blog/img/windows-nctx-ncys-1.png"></p><h1 id="二、内存映射文件技术介绍"><a href="#二、内存映射文件技术介绍" class="headerlink" title="二、内存映射文件技术介绍"></a>二、内存映射文件技术介绍</h1><p>常用的有Win32 API的<code>CreateFile()</code>、<code>WriteFile()</code>、<code>ReadFile()</code>和MFC提供的<code>CFile</code>类都可以实现文件的读写操作。一般来说，以上这些函数可以满足大多数场合的要求，但是对于某些特殊应用领域所需要的动辄几十GB、几百GB、乃至几TB的海量存储，此时在以平常的文件处理方法进行处理显然是行不通的（效率低下，而且内存没那么大）。目前，对于这种大文件的操作一般是以内存映射文件的方式来加以处理的。</p><p>内存映射文件也是Windows的一种内存管理方法，提供了一个统一的内存管理特征，使应用程序可以通过内存指针对磁盘上的文件进行访问。通过文件映射将磁盘文件内容（全部或者部分）与进程虚拟地址空间的某个区域建立映射关联，可以直接对被映射的文件进行访问，而不必执行文件I/O操作也无需对文件内容进行缓冲处理。内存文件映射的这种特性是非常适合于用来管理大尺寸文件的。</p><h1 id="三、大文件读写实例"><a href="#三、大文件读写实例" class="headerlink" title="三、大文件读写实例"></a>三、大文件读写实例</h1><p>通过C++调用系统API实现文件映射的步骤大致如下：<br><img src="https://static.1key.run/blog/img/windows-nctx-ncys-2.jpg"></p><p>本示例首先在<code>D:\</code>生成一个大小为1GB的<code>BigFile.data</code>文件，然后使用内存映射技术将该文件内全部填充字符A，随后读取其中的<code>第20000~20100字节</code>，并将这些字节修改为字符B，然后再次读取已验证是否修改成功。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;windows.h&gt;void Test() {HANDLE file_ = CreateFile(TEXT("D:\\BigFile.data"), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL,NULL);if (file_ == INVALID_HANDLE_VALUE) {printf("CreateFile failed, GLE:%d\n", GetLastError());return;}LARGE_INTEGER filesize;filesize.QuadPart = 1024 * 1024 * 1024; // 1GBHANDLE mapping_ = CreateFileMapping(file_, NULL, PAGE_READWRITE, filesize.HighPart, filesize.LowPart, NULL);if (mapping_ == NULL) {printf("CreateFileMapping failed, GLE:%d\n", GetLastError());return;}LARGE_INTEGER offset;offset.QuadPart = 0;LPVOID mapping_addr = MapViewOfFile(mapping_, FILE_MAP_WRITE | FILE_MAP_READ, offset.HighPart, offset.LowPart, 0);if (mapping_addr == NULL) {printf("MapViewOfFile failed, GLE:%d\n", GetLastError());return;}// 向文件中填充1GB的字符'A'//char buf[1024];for (int i = 0; i &lt; 1024; i++) {buf[i] = 'A';}// 每次填充1024字节，填充1024*1024次for (long l = 0; l &lt; 1024 * 1024; l++) {memcpy((LPVOID)((long)mapping_addr + l * 1024), buf, 1024);}// 填充完毕// 读取第20000~20100字节，共100字节//char read_content[101] = { 0 };memcpy(read_content, (LPVOID)((long)mapping_addr + 20000), 100);printf("%s\n", read_content);// 将第20000~20100字节，共100字节全部修改为字符'B'//char write_content[100];for (int i = 0; i &lt; 100; i++) {write_content[i] = 'B';}memcpy((LPVOID)((long)mapping_addr + 20000), write_content, 100);// 再次读取第20000~20100字节，共100字节，验证修改是成功//memcpy(read_content, (LPVOID)((long)mapping_addr + 20000), 100);printf("%s\n", read_content);UnmapViewOfFile(mapping_addr);CloseHandle(mapping_);CloseHandle(file_);return;}int main(){Test();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存映射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(2)--虚拟内存</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-2-xu-ni-nei-cun/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-2-xu-ni-nei-cun/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、页交换文件"><a href="#一、页交换文件" class="headerlink" title="一、页交换文件"></a>一、页交换文件</h2><p><code>虚拟地址空间</code>只是操作系统为进程“虚拟”出来的一块地址区域，并不代表任何实际的空间。而<code>“页交换文件”</code>却对应了实际的空间，这个空间一般是磁盘上名为<code>“pagefile.sys”</code>的文件。</p><p><code>“页交换文件”</code>的大小和位置可以在系统设置（<code>系统属性 -&gt; 高级 -&gt; 性能 -&gt; 设置 -&gt; 高级</code>  ）中进行设置：<br><img src="https://static.1key.run/blog/img/windows-nctx-xnnc-1.jpg"></p><p>从微软的官方文档来看，<code>“虚拟内存”</code>等于<code>“物理内存”+“分页文件”</code>总和。可以把<code>“虚拟内存”</code>理解为Windows的一种内存管理机制。</p><h2 id="二、虚拟地址空间、页交换文件、物理内存"><a href="#二、虚拟地址空间、页交换文件、物理内存" class="headerlink" title="二、虚拟地址空间、页交换文件、物理内存"></a>二、虚拟地址空间、页交换文件、物理内存</h2><p>虚拟地址空间、页交换文件、物理内存三者的关系如下图：<br><img src="https://static.1key.run/blog/img/windows-nctx-xnnc-2.jpg"></p><p>《Windows核心编程》第13章关于“物理存储器和页交换文件”章节中讲到了“页交换文件、物理存储器之间的数据交换过程”，流程如下：</p><p><img src="https://static.1key.run/blog/img/windows-nctx-xnnc-3.jpg"></p><p>应用程序从进程的虚拟地址空间<code>预定并调拨</code>了一块地址区域时，起初这块区域只是从“页交换文件”中调拨的，这样作有个好处就是：因为还不确定何时才会使用这块区域，如果立即从物理内存调拨，会将占用很多的物理内存。<br>当程序读写该地址区域时，此时就会出现上面图上的页交换文件和物理内存之间的数据交换过程。</p><h2 id="三、将页面锁定在物理内存"><a href="#三、将页面锁定在物理内存" class="headerlink" title="三、将页面锁定在物理内存"></a>三、将页面锁定在物理内存</h2><p>从上面的几节我们知道，当物理内存中没有闲置页面时，系统会将内存中的某些页面的数据写入到交换文件中，从而将该物理内存区域释放出来供后面的程序使用。 </p><p>我们可以通过调用<code>VirtualLock</code>方法，将页面锁定在物理内存中，从而防止虚拟内存管理机制将页面交换至页面文件，而引起不必要的硬盘和物理内存之间的低效页面交换。</p><p>也可以通过调用<code>VirtualUnlock</code>方法解锁页面，允许系统对页面进行交换操作。</p><p>需要注意的是，锁定页面时系统会根据当前可用实际物理内存情况，以及进程工作集配额判定当前最大可锁定的页面的实际数量，超过此数量会引起一个错误。我们可以调用<code>SetProcessWorkingSetSize</code>可以改变一个进程工作集大小的配额，从而可以锁定更多的物理页面。</p><h2 id="四、虚拟内存使用实例"><a href="#四、虚拟内存使用实例" class="headerlink" title="四、虚拟内存使用实例"></a>四、虚拟内存使用实例</h2><p>虚拟内存方面的API属于页面粒度API，通过这些API分配的内存的最小粒度是<code>64KB</code>。这些API分配（调拨）的内存区域最初都是位于<code>“页交换文件”</code>上面，当程序对该区域的某些“页面”（<strong>对虚拟内存的管理以页面为单位进行的</strong>）进行读写时，才会将这些页面交换到物理内存上面。</p><p>从<a href="/2023/06/20/windows-nei-cun-ti-xi-1-xu-ni-di-zhi-kong-jian/" title="Windows内存体系(1)--虚拟地址空间">Windows内存体系(1)--虚拟地址空间</a>中我们知道虚拟地址空间要经过<code>预定</code>和<code>调拨</code>2个步骤之后才能使用，这2个步骤都可以通过<code>VirtualAlloc</code>函数实现：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LPVOID VirtualAlloc(  LPVOID lpAddress,   DWORD dwSize,   DWORD flAllocationType,   DWORD flProtect ); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当预定或者调拨的空间我们不在需要时，我们需要调用<code>VirtualFree</code>来释放该地址空间：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">BOOL VirtualFree(  LPVOID lpAddress,   DWORD dwSize,   DWORD dwFreeType ); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是的示例演示了在预定、调拨、使用等操作前后，进程的各项内存的占用情况：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;windows.h&gt;int main(){SIZE_T size = 1 &lt;&lt; 30; // 1GB// 预定1GB的空间char *pVirtualAddress = (char *)VirtualAlloc(NULL, size, MEM_RESERVE, PAGE_READWRITE);if (pVirtualAddress == NULL) {printf("Reserve 1GB failed.\n");return 1;}// 验证分配粒度是不是64KBint n = (long)pVirtualAddress % (64*1024);if (n == 0) {printf("分配粒度为64K\n");}printf("已经预定1GB\n");getchar(); // 暂停if (VirtualAlloc(pVirtualAddress, size, MEM_COMMIT, PAGE_READWRITE) == NULL) {printf("Commit 1GB failed.\n");return 1;}printf("已经调拨1GB\n");getchar(); // 暂停// 页面大小为4K，访问2560个页面，即2560*4K = 10MB// for (int i = 0; i &lt; 2560; i++) {char * p = pVirtualAddress + i * (4 * 1024);*p = 'A'; // 只访问每个页面的第一个字节}printf("已经使用前10MB\n");getchar(); // 暂停    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在程序运行各个阶段进程的内存情况如下图：（“内存专用工作集”表示占用的物理内存的大小，“提交大小”表示调拨的页交换文件的大小）</p><p><img src="https://static.1key.run/blog/img/windows-nctx-xnnc-4.png"></p>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 页交换文件 </tag>
            
            <tag> 虚拟内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内存体系(1)--虚拟地址空间</title>
      <link href="/2023/06/20/windows-nei-cun-ti-xi-1-xu-ni-di-zhi-kong-jian/"/>
      <url>/2023/06/20/windows-nei-cun-ti-xi-1-xu-ni-di-zhi-kong-jian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h2 id="一、实模式下内存分配机制"><a href="#一、实模式下内存分配机制" class="headerlink" title="一、实模式下内存分配机制"></a>一、实模式下内存分配机制</h2><p>在8086或者80186以前，程序运行时，操作系统会把程序全都装入内存，程序都是直接运行在物理内存上的。也就是说程序中访问的内存地址都是实际的物理内存地址。当计算机同时运行多个程序时，必须保证这些程序用到的内存总量要小于计算机实际物理内存的大小。</p><p>例如某台计算机总的内存大小是<code>128M</code> ，现在同时运行两个程序 A和B ，A需占用内存<code>10M</code> ， B需占用内存<code>110M</code> 。计算机在给程序分配内存时会采取这样的方法：先将内存中的前<code>10M</code>分配给程序 A ，接着再从内存中剩余的<code>118M</code>中划分出 <code>110M</code>分配给程序B 。这种分配方法虽然可以保证程序A和程序B都能运行，但是这种简单的内存分配策略会导致很多问题：</p><ul><li><p>问题 1 ：进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意但有bug的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。这种情况对用户来说是无法容忍的，因为用户希望使用计算机的时候，其中一个任务失败了，不能影响其它的任务。</p></li><li><p>问题 2 ：内存使用效率低。在 A 和 B 都运行的情况下，如果用户又运行了程序 C ，而程序 C 需要 20M 大小的内存才能运行，而此时系统只剩下 8M 的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序 C 使用，然后再将程序 C 的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。</p></li><li><p>问题 3 ：程序运行的地址不确定。当内存中的剩余空间可以满足程序 C 的要求后，操作系统会在剩余空间中随机分配一段连续的 20M 大小的空间给程序 C 使用，因为是随机分配的，所以程序运行的地址是不确定的。</p></li></ul><hr><h2 id="二、虚拟地址空间介绍"><a href="#二、虚拟地址空间介绍" class="headerlink" title="二、虚拟地址空间介绍"></a>二、虚拟地址空间介绍</h2><p>操作系统让每个进程都有自己的虚拟地址空间（<code>Virtual Address Space</code>，简称<code>VAS</code>）。以32位进程为例，每个进程都有<code>0x00000000 ~ 0xFFFFFFFF</code>(4GB)的虚拟地址空间，所以每个进程都可能分配到<code>0x123456</code>地址的内存，但这个地址不能在进程间相互访问。 </p><p>因为这些都是“虚拟”的地址空间，这些“地址”都不能直接使用，CPU在寻址的时候虽然是按照虚拟地址来寻址的，但是还要通过<code>MMU</code>(内存管理单元)来将虚拟地址转换为物理存储器（如内存等）上的物理地址：</p><p><img src="https://static.1key.run/blog/img/windows-nctx-1.jpg"></p><p>从图上可以看出，进程A和B虽然都有地址<code>0x123456</code>，但它们分别对应的物理地址不一样。</p><hr><p>##三、虚拟地址空间分区<br>进程的虚拟地址空间虽然很大，但是它被划分成了很多分区，供Ring3层应用程序使用的用户模式分区并不大（一半不到），如图：<br><img src="https://static.1key.run/blog/img/windows-nctx-2.jpg"></p><h3 id="3-1-空指针赋值分区"><a href="#3-1-空指针赋值分区" class="headerlink" title="3.1 空指针赋值分区"></a>3.1 空指针赋值分区</h3><p>这一分区的进程地址空间的范围为：[<code>0x00000000</code>, <code>0x0000FFFF</code>]，总大小为<code>64K</code>，保留该分区的目的是为了帮助应用程序员捕获对空指针的赋值。如<code>malloc</code>分配内存失败，就会返回<code>NULL</code>。</p><p>如果进程中的线程试图访问该分区内的内存地址，就会引发访问违规。</p><h3 id="3-2-用户模式分区"><a href="#3-2-用户模式分区" class="headerlink" title="3.2 用户模式分区"></a>3.2 用户模式分区</h3><p>在Windows中，所有的exe和动态链接库都载入到这一区域。系统同时会把该进程可以访问的所有内存映射文件（后面会介绍）映射到这一分区。</p><p>进程无法通过指针来读取、写入、访问其他进程的这一分区，因此一个应用程序破坏另一个应用程序的可能性就非常小了，从而使整个系统更加坚固。</p><h3 id="3-3-内核模式分区"><a href="#3-3-内核模式分区" class="headerlink" title="3.3 内核模式分区"></a>3.3 内核模式分区</h3><p>内核模式分区是操作系统代码的驻地。与线程调度、内存管理、文件系统支持、网络支持以及设备驱动程序相关的代码都会载入到这一分区。该分区内的代码和数据被完全的保护起来了，如果一个应用程序试图读取或写入位于这一分区的内存地址，会引发访问违规。</p><p>驻留在这一分区内的代码为所有进程共有。</p><h2 id="四、虚拟地址空间的使用"><a href="#四、虚拟地址空间的使用" class="headerlink" title="四、虚拟地址空间的使用"></a>四、虚拟地址空间的使用</h2><p>虚拟地址空间的使用涉及到3个概念：<code>页面大小</code>、<code>分配粒度</code>、<code>预定和调拨</code>。</p><h3 id="4-1-页面大小"><a href="#4-1-页面大小" class="headerlink" title="4.1 页面大小"></a>4.1 页面大小</h3><p>虚拟地址空间被分成以<code>“页面”</code>为单位，因为硬件内存管理单元是以<code>页面</code>为粒度将虚拟地址转译成物理地址的。<code>页面</code>的大小根据不同的CPU不而有所不同。x86和x64系统使用的<code>页面</code>大小都是<code>4KB</code>，而IA-64系统使用的<code>页面</code>大小是<code>8KB</code>。</p><blockquote><p>IA-64操作系统只能在INTEL安腾系列处理器及AMD部分服务器处理器运行，所以主流市场并不常见</p></blockquote><p>当<strong>应用程序</strong>在虚拟地址空间分配空间时，系统需要确保分配区域的大小正好是系统<code>页面</code>大小的整数倍。</p><h3 id="4-2-分配粒度"><a href="#4-2-分配粒度" class="headerlink" title="4.2 分配粒度"></a>4.2 分配粒度</h3><p>当<strong>应用程序</strong>在从虚拟地址空间分配空间时，系统会确保所有分配区域的起始地址都是<code>分配粒度</code>的整数倍。<code>分配粒度</code>的会根据不同的CPU平台而有所不同，但目前所有的CPU平台的分配粒度都是使用<code>64KB</code>。也就是说，<code>分配的起始地址 = 64 * N</code>。</p><p>通过Windows的<code>GetSystemInfo</code>函数也可以获得此分配粒度值。</p><blockquote><p>上面所说的<code>分配粒度</code>和<code>页面大小</code>的限制，只是针对于<code>“应用程序”</code>，系统内核自己不存在这样的限制。</p></blockquote><h3 id="4-3-预定和调拨"><a href="#4-3-预定和调拨" class="headerlink" title="4.3 预定和调拨"></a>4.3 预定和调拨</h3><p>虚拟地址空间的使用分为2个步骤：</p><ol><li><p>预定（reserve）：告诉系统我们要从虚拟地址空间<code>预定</code>哪一块区域，系统为我们保留这一块区域。预定的局域的起始地址和大小遵循上面介绍的<code>分配粒度</code>和<code>页面大小</code>的要求。因为预定的只是虚拟地址空间，不占用任何其他物理存储器，所以没有形成实质的开销。</p></li><li><p>调拨（commit）：预定的区域还不能使用，我们还需要为<code>预定</code>的区域从<code>页交换文件</code>中<code>调拨</code>存储器，<code>调拨</code>之后我们才能使用该区域。<br>至于为什么要从<code>页交换文件</code>中调拨存储器？ <code>页交换文件</code>如何与物理内存之间交互？在下一篇文章<a href="/2023/06/20/windows-nei-cun-ti-xi-2-xu-ni-nei-cun/" title="Windows内存体系(2)--虚拟内存">Windows内存体系(2)--虚拟内存</a>中会详细介绍。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Windows内存体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实模式 </tag>
            
            <tag> 虚拟地址 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(5)--Qt字符编码</title>
      <link href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-5-qt-zi-fu-bian-ma/"/>
      <url>/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-5-qt-zi-fu-bian-ma/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><p>我们以<code>“测试字符串-보고싶다-Test String.”</code>这个字符串来进行讲解，它包含了英文、中文和韩文。<br>因为我使用Qt的方式是<code>Visual Studio + Qt库</code>的形式，所以本文以<code>Visual Studio</code>的<code>MSVC编译器</code>为例来进行讲解。</p><p>QString中使用QChar来存储每一个字符，QChar是short类型，占2个字节，默认是按Unicode编码存储的。</p><p>首先，为了保证写到代码文件中的测试字符串能被MSVC编译器理解，我们需要将源文件保存为<code>Utf8-带签名</code>的格式。具体参考：<a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-2-bian-yi-qi-chu-li-wen-jian-bian-ma/" title="拨开字符编码的迷雾(2)--编译器处理文件编码">拨开字符编码的迷雾(2)--编译器处理文件编码</a></p><p><strong>QString中存储的字符串的编码格式就是“编译器执行字符集编码格式”。</strong> 这一句话很关键。</p><p>在MSVC中我们可以使用<code>#pragma execution_character_set("utf-8")</code>来指定该源文件的执行字符集编码格式为UTF8格式，这样QString中存储的字符串格式就是utf8编码了。</p><p>下面是完整的测试用例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Demo01::qStringUseCase() {/*该源文件使用Utf8-BOM格式保存.源字符集为UTF8-BOM.可执行字符集为UTF8：#pragma execution_character_set("utf-8") 定义在stdafx.h.*/#define TEST_STR_A "测试字符串-보고싶다-Test String."#define TEST_STR_W L"测试字符串-보고싶다-Test String."{// 因为可执行字符集是utf8，所以使用OutputDebugStringA需要转换成ANSIOutputDebugStringA(Utf8ToAnsi(TEST_STR_A).c_str());}{ui.lblLanguage-&gt;setText(TEST_STR_A);}// char* --&gt; QString{QString qstr = TEST_STR_A;qInfo() &lt;&lt; qstr;}// QString --&gt; char*或std::string{QString qstr = TEST_STR_A;std::string str = qstr.toStdString(); // 不能直接使用qstr.toStdString().c_str()来获取，必须先将qstr.toStdString()存入std::string中const char* pStr = str.c_str();QString qstr2 = QString::fromUtf8(pStr);Q_ASSERT(qstr == qstr2);}// QString --&gt; wchar_t*或std::wstring{QString qstr = TEST_STR_A;std::wstring str = qstr.toStdWString();const wchar_t * pStr = str.c_str();QString qstr2 = QString::fromWCharArray(pStr);Q_ASSERT(qstr == qstr2);}// std::string --&gt; QString{std::string str = TEST_STR_A;  // std::string中存储的是UTF-8编码的字符串，因为可执行字符集为UTF8QString qstr = QString::fromStdString(str);}// std::wstring --&gt; QString{std::wstring str = TEST_STR_W;  // std::wstring中存储的是UTF-8编码的字符串，因为可执行字符集为UTF8QString qstr = QString::fromStdWString(str);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="关于QString-toLocal8Bit"><a href="#关于QString-toLocal8Bit" class="headerlink" title="关于QString::toLocal8Bit"></a>关于QString::toLocal8Bit</h1><p>QString有一个名为<code>toLocal8Bit</code>，网上很多介绍如何解决乱码的文章都会提到这个函数。关于这个函数官方的介绍如下：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Returns the local 8-bit representation of the string as a QByteArray. The returned byte array is undefined if the string contains characters not supported by the local 8-bit encoding.QTextCodec::codecForLocale() is used to perform the conversion from Unicode. If the locale encoding could not be determined, this function does the same as toLatin1().If this string contains any characters that cannot be encoded in the locale, the returned byte array is undefined. Those characters may be suppressed or replaced by another.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单来说，我们可以理解这个函数将字符串转换为的ANSI编码的字符串，通过<a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-1-zi-fu-bian-ma-gai-shu/" title="拨开字符编码的迷雾(1)--字符编码概述">拨开字符编码的迷雾(1)--字符编码概述</a>介绍，我们应该知道<code>ANSI</code>是和具体的代码页相关联的（在Windows中文环境下默认是代码页936）。Qt不是根据系统代码页来做判断的，而是通过<code>QTextCodec</code>来做判断的，所以文档中会提到这个函数需要结合<code>QTextCodec::codecForLocale()</code>来使用，<code>toLocal8Bit</code>根据对应的<code>QTextCodec</code>来做相应的转换。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以要想在使用Qt时，不遇到中文乱码问题，只需要在预编译头文件中加入：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma execution_character_set("utf-8") <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于部分韩文、日文等其他国家的字符不在Visual Studio默认的中文GB2312编码中，所以如果遇到Visual Studio提示“此文件的某些Unicode字符未能保存到当前代码页中”时，这时选择”<code>Utf8-带签名</code>“格式来保存即可。</p><p>综上所述，源文件保存为<code>Utf8-带签名</code>，且设置<code>#pragma execution_character_set("utf-8") </code>就可以解决所有乱码。</p>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(4)--MySQL字符编码</title>
      <link href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-4-mysql-zi-fu-bian-ma/"/>
      <url>/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-4-mysql-zi-fu-bian-ma/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一-MySQL字符集和校对规则"><a href="#一-MySQL字符集和校对规则" class="headerlink" title="一. MySQL字符集和校对规则"></a>一. MySQL字符集和校对规则</h1><p>MySQL的字符集是用来定义MySQL存储字符串的方式，校对规则（有的软件叫排序规则）则是用来定义了比较字符串的方式。字符集和校对规则是一对多的关系。每种字符集都有一个默认校对规则。</p><p><strong>查看数据库支持的字符集:</strong>  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 方法1：</span><span class="token keyword">SHOW</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span><span class="token punctuation">;</span><span class="token comment"># 方法2：</span><span class="token keyword">USE</span> information_schema<span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> CHARACTER_SETS<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看数据库支持的校对规则：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 方法1：</span><span class="token keyword">SHOW</span> COLLATION<span class="token punctuation">;</span><span class="token comment"># 方法2：</span><span class="token keyword">USE</span> information_schema<span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> collations<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二-MySQL各个级别字符集"><a href="#二-MySQL各个级别字符集" class="headerlink" title="二. MySQL各个级别字符集"></a>二. MySQL各个级别字符集</h1><p>MySQL可以对如下字符集进行设置：</p><ul><li>服务器级字符集（CHARACTER_SET_SERVER）</li><li>数据库级字符集（CHARACTER_SET_DATABASE）</li><li>表级字符集</li><li>字段级字符集</li><li>连接字符集（CHARACTER_SET_CONNECTION），客户端连接数据库所用的字符集。</li><li>结果字符集（CHARACTER_SET_RESULTS），存储查询结果（含错误信息）所用的字符集。</li><li>客户端字符集（CHARACTER_SET_CLIENT），客户端发送给MySQL服务器的查询语句字符集。</li><li>系统字符集（CHARACTER_SET_SYSTEM），用于存储我们新建的或自带的数据库的表、列的名称，默认是UTF-8</li></ul><p><code>服务器级、数据库级、表级、字段级</code> 这4个字符集设置影响到数据库中存储数据的编码。 这4个级别的字符集继承关系为：<code>服务器级 --&gt; 数据库级 --&gt; 表级 --&gt; 字段级</code>, 从左到右，一级继承一级，和C++、Java中的类的继承类似，如果某一级未显式的指定字符集，那么将继承上一级的字符集设置。</p><h2 id="2-1-服务器级别字符集设置"><a href="#2-1-服务器级别字符集设置" class="headerlink" title="2.1 服务器级别字符集设置"></a>2.1 服务器级别字符集设置</h2><p>服务器级别的字符集可以从下面几个地方指定，从上到下优先级依次增加：</p><ul><li>编译MySQL时指定的字符集</li><li>my.cnf配置文件设置character-set-server</li><li>mysqld服务启动命令行中指定字符集</li></ul><p>影响数据存储的字符集之间的关系：<br><img src="https://static.1key.run/blog/img/mysql-zfbm-1.jpg"></p><p><strong>查看当前数据库的字符集设置：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 方法1：</span><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'%character%'</span><span class="token punctuation">;</span><span class="token comment"># 方法2：</span><span class="token keyword">USE</span> information_schema<span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> GLOBAL_VARIABLES <span class="token keyword">WHERE</span> VARIABLE_NAME <span class="token operator">LIKE</span> <span class="token string">'%character%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-utf8与utf8mb4区别"><a href="#3-utf8与utf8mb4区别" class="headerlink" title="3. utf8与utf8mb4区别"></a>3. utf8与utf8mb4区别</h1><p>UTF-8是多字节编码方案，采用1~4个字节来存储一个字符，但在MySQL设计之初，一个字符最多采用3个字节的就可以存储，所以Mysql的设计者将MySQL中的UTF-8字符集（UTF-8其实不是字符集，是字符编码方案，但在MySQL中一直这么叫）设计成了最大长度只能为3. 如图：<br><img src="https://static.1key.run/blog/img/mysql-zfbm-2.jpg"></p><p>但随着Unicode字符集的扩张，出现了需要4个字节才能存储的字符，如果这时仍然使用utf-8（指mysql中的3字节utf-8）来存储这些字符就会出现错误，<br>如执行<code>INSERT INTO member(memberName)VALUES('𤭢')</code>报错如下：</p><pre class="line-numbers language-none"><code class="language-none">Warning Code : 1366Incorrect string value: '\xF0\xA4\xAD\xA2' for column 'memberName' at row 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>于是MySQL后来新增了utf8mb4字符集，最大长度为4，兼容之前的utf8，但为了之前的数据库不报错，仍然保留了之前的utf8字符集。 所以MySQL中的UTF-8字符集是伪UTF-8，现在需要使用utf8mb4。</p><h1 id="4-完全避免字符乱码"><a href="#4-完全避免字符乱码" class="headerlink" title="4. 完全避免字符乱码"></a>4. 完全避免字符乱码</h1><p>要完全避免字符乱码，最简单也是最好的方法就是将各个字符集保持一致，可以都设置为utf8mb4。Mysql数据存储涉及到的4个字符集的设置可以使用第2节的方法进行设置，客户端字符集、连接字符集，结果字符集关系到数据显示的正确性，可以使用如下语句统一设置为utf8mb4，但这个设置只针对当前连接有效：</p><pre class="line-numbers language-none"><code class="language-none">set names utf8mb4;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编程开发中，一般使用MySQL API进行数据连接、查询等操作，可以使用<code>mysql_set_character_set</code>对每个连接进行设置，这个API会将客户端字符集、连接字符集，结果字符集都设置为指定字符集，代码大致如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MYSQL* pMysql = NULL;mysql_real_connect(pMysql, szHost, szUser, szPwd, szDatabase, iPort, NULL, CLIENT_MULTI_STATEMENTS);mysql_set_character_set(pMysql, "utf8mb4");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(3)--字符编码转换</title>
      <link href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-3-zi-fu-bian-ma-zhuan-huan/"/>
      <url>/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-3-zi-fu-bian-ma-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="1-Windows-API介绍"><a href="#1-Windows-API介绍" class="headerlink" title="1. Windows API介绍"></a>1. Windows API介绍</h1><p>本文介绍使用Windows API进行字符编码的转换，涉及<code>WideCharToMultiByte</code>和<code>MultiByteToWideChar</code>2个API，<br>API接口名中的<code>MultiByte</code>对应着多字节编码，如ASCII、UTF-8等都是多字节编码，而<code>WideChar</code>字面意思是宽字符，在windows内部宽字符特指UTF-16编码。 </p><p>原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">WideCharToMultiByte</span><span class="token punctuation">(</span>  UINT CodePage<span class="token punctuation">,</span>   DWORD dwFlags<span class="token punctuation">,</span>   LPCWSTR lpWideCharStr<span class="token punctuation">,</span>   <span class="token keyword">int</span> cchWideChar<span class="token punctuation">,</span>   LPSTR lpMultiByteStr<span class="token punctuation">,</span>   <span class="token keyword">int</span> cbMultiByte<span class="token punctuation">,</span>   LPCSTR lpDefaultChar<span class="token punctuation">,</span>   LPBOOL lpUsedDefaultChar <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">MultiByteToWideChar</span><span class="token punctuation">(</span>  UINT CodePage<span class="token punctuation">,</span>   DWORD dwFlags<span class="token punctuation">,</span>   LPCSTR lpMultiByteStr<span class="token punctuation">,</span>   <span class="token keyword">int</span> cbMultiByte<span class="token punctuation">,</span>   LPWSTR lpWideCharStr<span class="token punctuation">,</span>   <span class="token keyword">int</span> cchWideChar <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-API封装"><a href="#2-API封装" class="headerlink" title="2. API封装"></a>2. API封装</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::string UnicodeToANSI(const std::wstring &amp;str, UINT iCodePage = CP_ACP) {std::string strRes;int iSize = ::WideCharToMultiByte(iCodePage, 0, str.c_str(), -1, NULL, 0, NULL, NULL);if (iSize == 0)return strRes;char *szBuf = new (std::nothrow) char[iSize];if (!szBuf)return strRes;memset(szBuf, 0, iSize);::WideCharToMultiByte(iCodePage, 0, str.c_str(), -1, szBuf, iSize, NULL, NULL);strRes = szBuf;delete[] szBuf;return strRes;}std::wstring ANSIToUnicode(const std::string &amp;str, UINT iCodePage = CP_ACP) {std::wstring strRes;int iSize = ::MultiByteToWideChar(iCodePage, 0, str.c_str(), -1, NULL, 0);if (iSize == 0)return strRes;wchar_t *szBuf = new (std::nothrow) wchar_t[iSize];if (!szBuf)return strRes;memset(szBuf, 0, iSize * sizeof(wchar_t));::MultiByteToWideChar(iCodePage, 0, str.c_str(), -1, szBuf, iSize);strRes = szBuf;delete[] szBuf;return strRes;}std::string UnicodeToUTF8(const std::wstring &amp;str) {std::string strRes;int iSize = ::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, NULL, 0, NULL, NULL);if (iSize == 0)return strRes;char *szBuf = new (std::nothrow) char[iSize];if (!szBuf)return strRes;memset(szBuf, 0, iSize);::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, szBuf, iSize, NULL, NULL);strRes = szBuf;delete[] szBuf;return strRes;}std::string UnicodeToUTF8BOM(const std::wstring &amp;str) {std::string strRes;int iSize = ::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, NULL, 0, NULL, NULL);if (iSize == 0)return strRes;unsigned char *szBuf = new (std::nothrow) unsigned char[iSize + 3];if (!szBuf)return strRes;memset(szBuf, 0, iSize + 3);if (::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, (LPSTR)(szBuf + 3), iSize, NULL, NULL) &gt; 0) {szBuf[0] = 0xEF;szBuf[1] = 0xBB;szBuf[2] = 0xBF;}strRes = (char*)szBuf;delete[] szBuf;return strRes;}std::wstring UTF8ToUnicode(const std::string &amp;str) {std::wstring strRes;int iSize = ::MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0);if (iSize == 0)return strRes;wchar_t *szBuf = new (std::nothrow) wchar_t[iSize];if (!szBuf)return strRes;memset(szBuf, 0, iSize * sizeof(wchar_t));::MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, szBuf, iSize);strRes = szBuf;delete[] szBuf;return strRes;}std::string ANSIToUTF8(const std::string &amp;str, UINT iCodePage = CP_ACP) {return UnicodeToUTF8(ANSIToUnicode(str, iCodePage));}std::string ANSIToUTF8BOM(const std::string &amp;str, UINT iCodePage = CP_ACP) {return UnicodeToUTF8BOM(ANSIToUnicode(str, iCodePage));}std::string UTF8ToANSI(const std::string &amp;str, UINT iCodePage = CP_ACP) {return UnicodeToANSI(UTF8ToUnicode(str), iCodePage);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于只支持简体中文（部分韩文、日文）的系统，<code>iCodePage</code>可以使用CP_ACP，这时API会使用系统当前的代码页（简体中文系统为CP936，即GBK字符集）来进行编码转换。 但遇到如下情况就需要手动指定代码页：</p><ol><li>需要转换的字符串中的文字是系统当前代码页不支持的。如字符串中含有中文，而当前系统代码页确是英文的；</li><li>GBK字符集中只包含了一部分韩文和日文，部分韩文和日文的转换可以正常转换，若遇到不能转换的情况也需要将指定iCodePage为特定的支持韩文或日文的代码页了，特别是中文和韩文、日文等混合的情况下。如韩文“탉”不包含在GBK中，若这时仍然使用CP_ACP就会得到错误的转换结果<code>?</code>，十六进制<code>3F</code>。但GB18030（代码页为54936）支持“탉”，可以手动指定iCodePage为54936。</li></ol><blockquote><p>如果代码中含有GBK不支持的字符，如“탉”、“𤭢”（念suì）等，Visual Studio会弹出如下提示：<br><img src="https://static.1key.run/blog/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA1MTI5ODIz"><br>选择“以其他编码保存”，选择“Unicode（UTF-8带签名）- 代码页65001”保存。<br>虽然“简体中文（GB18030) - 代码页54936”也支持这些字符，但不能选择该选项进行保存，具体原因在<a href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-2-bian-yi-qi-chu-li-wen-jian-bian-ma/" title="拨开字符编码的迷雾(2)--编译器处理文件编码">拨开字符编码的迷雾(2)--编译器处理文件编码</a>中有详细的介绍。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(2)--编译器处理文件编码</title>
      <link href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-2-bian-yi-qi-chu-li-wen-jian-bian-ma/"/>
      <url>/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-2-bian-yi-qi-chu-li-wen-jian-bian-ma/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><h1 id="一-Visual-Studio字符集"><a href="#一-Visual-Studio字符集" class="headerlink" title="一. Visual Studio字符集"></a>一. Visual Studio字符集</h1><p>使用Visual Studio创建的C++工程可以在工程属性<code>配置属性--&gt;常规</code>中配置字符集：<code>使用Unicode字符集</code>（默认）、<code>使用多字节字符集</code>。<br>如图：<br><img src="https://static.1key.run/blog/img/byqrhclzfbm-1.jpg"></p><p>但<strong>这个设置项不会对编译器处理字符编码产生直接的影响</strong>（注意这里的“直接”二字，第3节会说到），只会在工程属性<code>配置属性--&gt;C/C++--&gt;预处理器</code>加入相应的宏：</p><pre class="line-numbers language-none"><code class="language-none">使用Unicode字符集 --&gt; _UNICODE和UNICODE宏使用多字节字符集   --&gt; _MBCS宏<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这几个宏一般用来判断是使用char还是wchar_t，在系统API中使用比较多，如MessegeBox通过是否定义了UNICODE宏来决定是使用LPCSTR还是LPCWSTR（LPCSTR即const char*, LPCWSTR即const wchar_t*）：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">UNICODE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MessageBox</span>  <span class="token expression">MessageBoxW</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MessageBox</span>  <span class="token expression">MessageBoxA</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// !UNICODE</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二-char和wchar-t"><a href="#二-char和wchar-t" class="headerlink" title="二. char和wchar_t"></a>二. char和wchar_t</h1><p>上面提到了，定义API时通过判断UNICODE宏是否定义来决定是使用char还是wchar_t，那么char和wchar_t有什么不同了？</p><p>char和wchar_t是标准C/C++字符类型，并不是windows特有的。 char固定占1个字节，wchar_t固定占2个字节，从内存的角度来看，char、wchar_t和其他数据类型一样，只是代表一段内存块，用来存储固定长度的二进制0或1。 在编程时，我们一般习惯于将字符串储到char或wchar_t定义的内存空间中，将整形存储在int定义的内存空间中。</p><p>所以，用char还是wchar_t来存储字符，只是内存分配和数据存储上面的事情，<strong>它们本身也是与字符编码无直接关系的</strong>（ 同样注意这里的“直接”二字，第3节会说到）。</p><h1 id="三-编译器如何处理硬编码字符"><a href="#三-编译器如何处理硬编码字符" class="headerlink" title="三. 编译器如何处理硬编码字符"></a>三. 编译器如何处理硬编码字符</h1><p>VC++编译器编译源代码的步骤中，涉及编码处理的步骤主要有2个：<br>第1步：预处理<br>1.1) 读取源文件，判断源文件采用的字符编码类型。(<strong>这一步不会改变文件内容</strong>)</p><pre class="line-numbers language-none"><code class="language-none">编译器判断源文件编码类型的步骤为：1. 若文件开始处有BOM(EF BB BF)，则判定为UTF-8编码；2. 若没有BOM，则试图从文件的前8个字节来判断文件是否像UTF-16编码，如果像，则就判断为UTF-16编码。3. 如果既没BOM，也不是UTF-16编码，则使用系统当前的代码页（简体中文操作系统为CP936）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>1.2) 将源文件内容转成<code>源字符集</code>(Source Character Set)，默认为UTF-8编码。</p><p>第2步：链接<br>2.1) 将1.2中得到的UTF-8转为<code>执行字符集</code>(Execution Character Set)：</p><ul><li>对于宽字符串（即C/C++中以<code>L</code>标记的串，如<code>L"abc"</code>, <code>L'中'</code>），<code>执行字符集</code>为UTF-16编码。</li><li>对于窄字符串（和宽字符串对应，即不以<code>L</code>标记的串），<code>执行字符集</code>为系统当前的代码页。</li></ul><p><img src="https://static.1key.run/blog/img/byqrhclzfbm-2.jpg"></p><p>现在我们就可以说清楚Visual Studio字符集设置、char、wchar_t是如何<em><strong>间接</strong></em>影响到编译器对字符编码的处理了：</p><pre class="line-numbers language-none"><code class="language-none">Visual Studio字符集设置      |决定声明哪一个宏（UNICODE还是_MBCS宏）      |宏又决定了API参数使用char还是wchar_t      |编译器在进行【执行字符集】编码时对char和wchar_采用不同的处理方式，从而对字符编码产生了影响。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在Visual Studio 2010（含）之后，支持使用<code># pragma execution_character_set</code>来设置执行字符集。</p></blockquote><h1 id="四-实例分析"><a href="#四-实例分析" class="headerlink" title="四. 实例分析"></a>四. 实例分析</h1><ul><li>已知汉字“中”的各种编码如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">GBK        D6 D0Unicode    2D 4EUTF-8      E4 B8 AD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>函数<code>DumpCharacterCode</code>用于按字节打印内存中的数据：</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void DumpCharacterCode(const char* pChar, int iSize) {for(int i = 0; i &lt; iSize; i++) {char a = *pChar++;printf("%02X ", a &amp; 0xff);}printf("\n");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>设置系统代码页的方法：<br>“控制面板”  –&gt; “区域和语言” –&gt; “管理” –&gt; “非Unicode程序的语言” –&gt; “更改系统区域设置”</p></li><li><p>Visual Studio保存文件到指定编码方法：<br>“文件” –&gt; “高级保存选项”</p></li></ul><h2 id="4-1-测试编译器处理窄字符编码"><a href="#4-1-测试编译器处理窄字符编码" class="headerlink" title="4.1 测试编译器处理窄字符编码"></a>4.1 测试编译器处理窄字符编码</h2><p>测试代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int _tmain(int argc, _TCHAR* argv[]){char buf[100] = {"中"};   // charDumpCharacterCode(buf, 2);  // 也可以打印4个字节return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对不同的系统代码页和源文件编码，打印出的汉字“中”的编码分别为：</p><table><thead><tr><th>测试用例</th><th>系统代码页</th><th>保存源文件编码</th><th>编译器判断文件采用的编码</th><th>源字符集(Source Character Set)</th><th>执行字符集(Execution Character Set)</th><th>打印输出</th></tr></thead><tbody><tr><td>用例1</td><td>简体中文 CP936</td><td>简体中文 CP936</td><td>简体中文 CP936</td><td>UTF-8</td><td>简体中文 CP936</td><td>D6 D0</td></tr><tr><td>用例2</td><td>简体中文 CP936</td><td>UTF-8 BOM</td><td>UTF-8 BOM</td><td>UTF-8</td><td>简体中文 CP936</td><td>D6 D0</td></tr><tr><td>用例3</td><td>简体中文 CP936</td><td>UTF-8</td><td>简体中文 CP936</td><td>UTF-8</td><td>简体中文 CP936</td><td>编译错误(C2146)</td></tr><tr><td>用例4</td><td>西欧 CP1252</td><td>简体中文 CP936</td><td>西欧 CP1252</td><td>UTF-8</td><td>西欧 CP1252</td><td>D6 D0</td></tr><tr><td>用例5</td><td>西欧 CP1252</td><td>UTF-8 BOM</td><td>UTF-8 BOM</td><td>UTF-8</td><td>西欧 CP1252</td><td>3F 00</td></tr></tbody></table><p>表格中列4~6依次对应编译处理源文件的几个步骤。<br><code>3F</code>对应的ASCII字符为<code>?</code>，编译器遇到不能识别的字符时，就会用<code>?</code>来替代。 出现<code>?</code>的情况会伴随着编译警告<code>C4566</code>。<br>上面出现了1次<code>3F</code>（用例5），导致乱码的原因是<code>UTF-8 --&gt; 西欧 CP1252</code>. <code>西欧 CP1252</code>也就是ASCII的扩展，不支持汉字，所以用<code>3F</code>替代。</p><h4 id="用例3为什么会编译错误？"><a href="#用例3为什么会编译错误？" class="headerlink" title="用例3为什么会编译错误？"></a>用例3为什么会编译错误？</h4><p>微软的编译器只能识别带BOM的UTF-8，用例3的UTF-8没带BOM，编译器会判定源文件编码为系统当前代码页CP936。“中”的UTF-8编码为<code>E4 B8 AD</code>，列5执行从CP936到UTF-8转换之后变成了<code>E6 B6 93 3F</code>，列6再要将<code>E6 B6 93 3F</code>转换为CP936肯定是转换不回去的，相当于 UTF-8（1） –&gt; UTF-8 （2），再将UTF-8（2）转换回CP936，这时肯定得到的字符不是原来的字符了。</p><h4 id="用例4为什么输出的D6-D0，而不是3F？"><a href="#用例4为什么输出的D6-D0，而不是3F？" class="headerlink" title="用例4为什么输出的D6 D0，而不是3F？"></a>用例4为什么输出的<code>D6 D0</code>，而不是<code>3F</code>？</h4><p>对着用例4的各个顺序来看，源文件通过CP936保存着，但编译器通过CP1252来读取的，CP1252就是ASCII扩展，单字节的，虽然此时显示为乱码，但各字节仍然是D6 D0；然后将读取到的文件内容从CP1252转成UTF-8编码，转码后为C3 96 C3 90；然后再将UTF-8编码转回为CP1251，转码就又变成了D6 D0。 但这个<code>D6 D0</code>在CP1252中是无法显示的，如果我们在用例4加入<code>MessageBoxA(NULL, "中", "test", MB_OK);</code> 会发现弹出的对话框中显示仍然是乱码。<br>可以使用下面的代码进行测试：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int _tmain(int argc, _TCHAR* argv[]){char buf[3] = { 0 };    // 模拟CP936编码的“中”buf[0] = 0xD6;buf[1] = 0xD0;std::string strUTF8 = ANSIToUTF8(buf, 1252);char *p = (char*)strUTF8.c_str();  // 通过visual studio查看指针p处内存为： C3 96 C3 90std::string str = UTF8ToANSI(strUTF8, 1252);p = (char*)str.c_str();   // 通过visual studio查看指针p处内存为： D6 D0return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-测试编译器处理宽字符编码"><a href="#4-2-测试编译器处理宽字符编码" class="headerlink" title="4.2 测试编译器处理宽字符编码"></a>4.2 测试编译器处理宽字符编码</h2><p>测试代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int _tmain(int argc, _TCHAR* argv[]){wchar_t buf[100] = {L"中"};   // wchar_tDumpCharacterCode((char*)buf, 4); // 打印4个字节return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样，针对不同的系统代码页和源文件编码，打印出的汉字“中”的编码分别为：</p><table><thead><tr><th>测试用例</th><th>系统代码页</th><th>保存源文件编码</th><th>编译器判断文件采用的编码</th><th>源字符集(Source Character Set)</th><th>执行字符集(Execution Character Set)</th><th>打印输出</th></tr></thead><tbody><tr><td>用例1</td><td>简体中文 CP936</td><td>简体中文 CP936</td><td>简体中文 CP936</td><td>UTF-8</td><td>UTF-16</td><td>2D 4E 00 00</td></tr><tr><td>用例2</td><td>简体中文 CP936</td><td>UTF-8 BOM</td><td>UTF-8 BOM</td><td>UTF-8</td><td>UTF-16</td><td>2D 4E 00 00</td></tr><tr><td>用例3</td><td>简体中文 CP936</td><td>UTF-8</td><td>简体中文 CP936</td><td>UTF-8</td><td>UTF-16</td><td>编译错误(C2146)</td></tr><tr><td>用例4</td><td>西欧 CP1252</td><td>简体中文 CP936</td><td>西欧 CP1252</td><td>UTF-8</td><td>UTF-16</td><td>D6 00 D0 00 <strong>大小端</strong></td></tr><tr><td>用例5</td><td>西欧 CP1252</td><td>UTF-8 BOM</td><td>UTF-8 BOM</td><td>UTF-8</td><td>UTF-16</td><td>2D 4E 00 00</td></tr></tbody></table><h1 id="五-彻底避免硬编码字符乱码"><a href="#五-彻底避免硬编码字符乱码" class="headerlink" title="五. 彻底避免硬编码字符乱码"></a>五. 彻底避免硬编码字符乱码</h1><p>通过第3节的说明，很容易知道，要开发支持多语言，在任意语言（系统代码页）的windows环境下都正常编译，且运行起来没有乱码的程序，需要遵循如下原则：</p><ol><li>代码文件采用UTF-8 with BOM编码。</li><li>Visual Studio字符集设置为Unicode字符集。</li><li>使用wchar_t。</li></ol><p>做到上面3步，你的代码被别人从github上clone下来编译，不会因为你代码中含有中文等字符，产生类似<code>error C2015</code>这样的编译错误，更不会产生乱码。</p><blockquote><p>本文介绍的方法只用来解决硬编码字符乱码的问题，至于数据传输中的乱码，需要统一字符编码来解决。</p></blockquote><blockquote><p>参考: <a href="https://blogs.msdn.microsoft.com/vcblog/2016/02/22/new-options-for-managing-character-sets-in-the-microsoft-cc-compiler">https://blogs.msdn.microsoft.com/vcblog/2016/02/22/new-options-for-managing-character-sets-in-the-microsoft-cc-compiler</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拨开字符编码的迷雾(1)--字符编码概述</title>
      <link href="/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-1-zi-fu-bian-ma-gai-shu/"/>
      <url>/2023/06/20/bo-kai-zi-fu-bian-ma-de-mi-wu-1-zi-fu-bian-ma-gai-shu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章图片带有“CSDN”水印的说明：<br>由于该文章和图片最初发表在我的<a href="https://blog.csdn.net/china_jeffery">CSDN博客</a>中，因此图片被CSDN自动添加了水印。</p></blockquote><hr><blockquote><p>为什么这样的字符串<code>{"data":"颸颸"}</code>，JSON库（如<code>jsoncpp</code>）会解析失败？<br>为什么界面上韩文显示乱码？<br>ASCII和ANSI有什么区别？<br>相信不少人在字符编码上面摔过跟头，这篇文章针对开发中需要了解的字符编码知识进行了简要的讲解，希望能够对大家有所帮助。</p></blockquote><h1 id="1-ASCII及其扩展"><a href="#1-ASCII及其扩展" class="headerlink" title="1. ASCII及其扩展"></a>1. ASCII及其扩展</h1><h2 id="1-1-什么是ASCII字符集"><a href="#1-1-什么是ASCII字符集" class="headerlink" title="1.1 什么是ASCII字符集"></a>1.1 什么是ASCII字符集</h2><p>字符集就是一系列用于显示的字符的集合。ASCII字符集由美国国家标准协会（American National Standard Institute)于1968年制定一个字符映射集合。</p><p>ASCII使用7位二进制位来表示一个字符，总共可以表示128个字符（即<code>2^7</code>，二进制<code>000 0000 ～ 111 1111</code> 十进制<code>0～127</code>）。</p><p>ASCII字符集中每个数字对应一个唯一的字符，如下表：<br><img src="https://static.1key.run/blog/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA0OTUyMDA5"></p><p>因为其对应关系非常简单，不需要特殊的编码规则，所以严格来讲ASCII不能算字符编码，因为它没有规定编码规则。我们只是习惯将ASCII字符集称之为ASCII码、ASCII编码。</p><h2 id="1-2-ASCII的扩展"><a href="#1-2-ASCII的扩展" class="headerlink" title="1.2 ASCII的扩展"></a>1.2 ASCII的扩展</h2><h3 id="1-2-1-最高位扩展-ISO-x2F-IEC-8859"><a href="#1-2-1-最高位扩展-ISO-x2F-IEC-8859" class="headerlink" title="1.2.1 最高位扩展 - ISO/IEC 8859"></a>1.2.1 最高位扩展 - ISO/IEC 8859</h3><p>ASCII字符集是美国人发明的，这些字符完全是为其量身定制的。但随着计算机技术的发展和普及，传到了欧洲（如法国、德国）各国。由于欧洲很多国家中使用的字符除了ASCII表中的128个字符之外，还有一些各国特有的字符，于是欧洲人民发现ASCII字符集表达不了他们所要表达的东西呀。怎么办了？他们发现ASCII只使用了一个字节（8位）之中的低7位，于是欧洲各国开始各显神通，打起了那1个最高位（第0位）的主意，将最高位利用了起来，这样又多了128个字符，从而满足了欧洲人民的需要。</p><p>但因为每个国家的需求不一样，各国都设计了不同的方案。为了结束这种混乱的局面，国际标准化组织(ISO)及国际电工委员会(IEC)联合制定了<strong>一系列8位字符集</strong>的标准，统称为ISO 8859（全称ISO/IEC 8859）。注意，这是一系列字符集的统称。如ISO/IEC 8859-1（也就是常听到的Latin-1）支持西欧语言，ISO/IEC 8859-4（Latin-4）支持北欧语言等。</p><p>完整列表如下（摘自百度百科）：<br>ISO/IEC 8859-1 (Latin-1) - 西欧语言<br>ISO/IEC 8859-2 (Latin-2) - 中欧语言<br>ISO/IEC 8859-3 (Latin-3) - 南欧语言，世界语也可用此字符集显示。<br>ISO/IEC 8859-4 (Latin-4) - 北欧语言<br>ISO/IEC 8859-5 (Cyrillic) - 斯拉夫语言<br>ISO/IEC 8859-6 (Arabic) - 阿拉伯语<br>ISO/IEC 8859-7 (Greek) - 希腊语<br>ISO/IEC 8859-8 (Hebrew) - 希伯来语(视觉顺序)<br>ISO 8859-8-I - 希伯来语(逻辑顺序)<br>ISO/IEC 8859-9 (Latin-5 或 Turkish) - 它把Latin-1的冰岛语字母换走，加入土耳其语字母。<br>ISO/IEC 8859-10 (Latin-6 或 Nordic) - 北日耳曼语支，用来代替Latin-4。<br>ISO/IEC 8859-11 (Thai) - 泰语，从泰国的 TIS620 标准字集演化而来。<br>ISO/IEC 8859-13 (Latin-7 或 Baltic Rim) - 波罗的语族<br>ISO/IEC 8859-14 (Latin-8 或 Celtic) - 凯尔特语族<br>ISO/IEC 8859-15 (Latin-9) - 西欧语言，加入Latin-1欠缺的芬兰语字母和大写法语重音字母，以及欧元符号。<br>ISO/IEC 8859-16 (Latin-10) - 东南欧语言。主要供罗马尼亚语使用，并加入欧元符号。</p><blockquote><p>我们在数据库中常见到的Latin-1、2、5、7其实就是上面提到的针对特定语言的ASCII扩展字符集。<br><img src="https://static.1key.run/blog/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA1MDA0NTIy"></p></blockquote><h3 id="1-2-2-多字节扩展-GB系列"><a href="#1-2-2-多字节扩展-GB系列" class="headerlink" title="1.2.2 多字节扩展 - GB系列"></a>1.2.2 多字节扩展 - GB系列</h3><p>前面讲到了，欧洲各国有效利用闲置的最高位，对ASCII字符集进行了扩展。可是欧洲人民没有想到的是（当然他们也不用想这么多），在大洋彼岸有着一个拥有五千年历史的伟大民族，她拥有着成千上万的汉字，1个字节显然不够表达如此深厚的文化底蕴。</p><p>于是当计算机引入到中国之初，国家技术监督局就设计了GB系列编码方案（GB=guo biao)。<br><strong>GB编码方案使用2个字节来表达一个汉字。同时为了兼容ASCII编码，规定各个字节的最高位（首位）必须为1，从而避免了和最高位为0的ASCII字符集的冲突。</strong></p><p>GB系列字符集经历下面的几个发展过程：</p><table><thead><tr><th>编码名称</th><th>发布时间</th><th>字节数</th><th>汉字范围</th></tr></thead><tbody><tr><td>GB2312</td><td>1980年</td><td>变字节（ASCII 1字节，汉字2个字节）</td><td>6763个汉字</td></tr><tr><td>GB13000</td><td>1993年第一版</td><td>变字节（ASCII 1字节，汉字2个字节）</td><td>20902个汉字</td></tr><tr><td>GBK</td><td>Windows95中</td><td>2个字节</td><td>21886个汉字和图形符号（含GB2312，BIG5中所有字符）</td></tr><tr><td>GB18030</td><td>2000年第一版</td><td>变字节（ASCII 1字节，汉字2个或4个字节）</td><td>27484个汉字</td></tr></tbody></table><p>每一次迭代，支持的字符数量都会增加，而且每一次迭代都会保留之前版本支持的编码，所以做到了向上兼容。</p><h3 id="1-2-3-全角与半角"><a href="#1-2-3-全角与半角" class="headerlink" title="1.2.3  全角与半角"></a>1.2.3  全角与半角</h3><p>因为汉字在显示器上的显示宽度要比英文字符的宽度要宽一倍，在一起排版显示时不太美观。所以GB编码不仅仅加入了汉字字符，而且包括了ASCII字符集中本来就有的数字、标点符号、字母等字符。这些被编入GB编码的数字、标点、字母在显示器上的显示宽度比ASCII字符集中的宽度宽一倍，所以前者称为全角字符，后者称为半角字符。</p><h1 id="2-ANSI"><a href="#2-ANSI" class="headerlink" title="2. ANSI"></a>2. ANSI</h1><h2 id="2-1-ANSI与代码页"><a href="#2-1-ANSI与代码页" class="headerlink" title="2.1 ANSI与代码页"></a>2.1 ANSI与代码页</h2><p>前面说到了世界各国针对ASCII的扩展方案（如欧洲的ISO/IEC 8859，中国的GB系列等），这些ASCII扩展编码方案的特点是：他们都兼容ASCII编码，但他们彼此之间是不兼容的。微软将这些编码方案统称为ANSI编码。故ANSI并不是特指某一种编码方案，只有知道了在哪个国家，哪个语言环境下，才知道它具体表示哪个编码方案。</p><p>在windows操作系统上，默认使用ANSI来保存文件。那么操作系统是如何知道ANSI到底应该表示哪种编码了，是GBK，还是ASCII，或者还是EUC-KR了？ windows通过一个叫”Code Page”（翻译为中文就叫代码页）的东西来判断系统的默认编码。<br>简体中文操作系统默认的代码页是936，它表示ANSI使用的是GBK编码。<br>GB18030编码对应的windows代码页为CP54936。</p><p>可以使用命令<code>chcp</code>来查看系统默认的代码页.</p><p>汉字“𤭢”（念suì）只包含在GB18030中，GB2312、GB13000、GBK中均不包含。默认情况下，在Visual Studio中输入该汉字，visual studio会使用CP936（即GBK）来保存代码文件，但如果在代码文件中输入该汉字，visual studio弹出如下提示要求用户选择代码页：<br><img src="https://static.1key.run/blog/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA1MTI5ODIz"><br><img src="https://static.1key.run/blog/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MjA1MTM4NTUx"></p><h2 id="2-2-更改默认代码页"><a href="#2-2-更改默认代码页" class="headerlink" title="2.2 更改默认代码页"></a>2.2 更改默认代码页</h2><h3 id="2-2-1-chcp命令"><a href="#2-2-1-chcp命令" class="headerlink" title="2.2.1 chcp命令"></a>2.2.1 chcp命令</h3><p>可以使用<code>chcp</code>命令来更改默认代码页，如<code>chcp 437</code>将默认代码页更改为437（美国）。</p><h3 id="2-2-2-控制面板"><a href="#2-2-2-控制面板" class="headerlink" title="2.2.2 控制面板"></a>2.2.2 控制面板</h3><p>在“控制面板”–&gt;“区域和语言”–&gt; “更改系统区域设置”中更改系统默认的代码页为“中文（简体，中国）”。</p><h3 id="2-2-3-代码修改"><a href="#2-2-3-代码修改" class="headerlink" title="2.2.3 代码修改"></a>2.2.3 代码修改</h3><p>也可以通过代码更改默认的代码页：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">setlocale</span><span class="token punctuation">(</span>   <span class="token keyword">int</span> category<span class="token punctuation">,</span>   <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>locale <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-Unicode"><a href="#3-Unicode" class="headerlink" title="3. Unicode"></a>3. Unicode</h1><h2 id="3-1-Unicode产生背景"><a href="#3-1-Unicode产生背景" class="headerlink" title="3.1 Unicode产生背景"></a>3.1 Unicode产生背景</h2><p>各个国家使用不同的编码规则，虽然他们都是兼容ASCII的，但它们相互却是不兼容的。</p><p>试想法国人Jack写了一封名为”love_you.txt”的信，传给了他的德国朋友Rose，Rose想要在windows系统上打开这个文件，她需要知道德国使用的字符编码是Latin-1，然后还要确保她的计算机上安装了该编码，才能顺利的打开这个文件。<br>如果上面这些还能忍受，那么随着网络的发展，你从互联网上获取的文件，你很有可能不知道它来自哪个国家，使用的哪种编码。这也就是Email刚诞生时常常出现乱码的原因，发信人和收信人使用的编码可能是不一样的。</p><p>于是<code>The Unicode Standard</code>（统一码标准）横空出世，它由The Unicode Consortium于1991年发布，我们习惯称它为Unicode字符集。 </p><p>Unicode字符集和ASCII字符集一样，也只是一个字符集合，标记着字符和数字之间的映射关系，它不包含任何编码规则和方案。和ASCII不一样的是，Unicode字符集支持的字符数量是没有限制的（具体可以参考Unicode规范）。</p><blockquote><p>我们通常认为的Unicode字符固定占用2个字节的观点是错误的。如“𤭢”（念suì）Unicode码为<code>D852 DF62</code>。 </p></blockquote><p>那么Unicode字符是怎样被编码成内存中的字节的了？它是通过UTF(Unicode Transformation Formats)实现的，比较常见得有UTF-8，UTF-16。</p><blockquote><p>在windows系统上汉字默认使用CP936（即GBK编码），占2个字节。而大多数Unicode字符的Unicode码值也占2个字节，所以大多数人误以为汉字字符串在内存中的值就是Unicode值，这是错误的。<br>可以从 <a href="http://tool.chinaz.com/tools/unicode.aspx" title="站长工具">站长工具-Unicode</a> 查询汉字的Unicode码值。</p></blockquote><h2 id="3-3-字符集与字符编码的区别"><a href="#3-3-字符集与字符编码的区别" class="headerlink" title="3.3 字符集与字符编码的区别"></a>3.3 字符集与字符编码的区别</h2><p>从ASCII、GB2312、GBK、GB18030、Big5（繁体中文）、Latin-1等采用的方案来看，它们都只是定义了单个字符与二进制数据的映射关系，一个字符在一个方案中只会存在一种表示方式，所以我们说GB2312是字符集还是字符编码方式都无所谓了。但是Unicode不一样，Unicode作为一个字符集可以采用多种编码方式，如UTF-8, UTF-16, UTF-32等。<strong>所以自Unicode出现之后，字符集与字符编码需要明确区分开来。</strong></p><h2 id="3-4-UTF-16编码的缺点"><a href="#3-4-UTF-16编码的缺点" class="headerlink" title="3.4 UTF-16编码的缺点"></a>3.4 UTF-16编码的缺点</h2><p>UTF-16编码方式规定用两个或四个字节来表示所有的字符。对于ASCII字符保持不变，只是将原来的7位扩展到了16位，其高9位永远是0。如字符’A’：</p><pre class="line-numbers language-none"><code class="language-none">ASCII: 100 0001UTF-16: 0000 0000 0100 0001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到对于ASCII字符，UTF-16的存储空间扩大了一倍，UTF-16并不是完全兼容ASCII字符集。这对于那些ASCII字符集已经满足需求的西方国家来说完全是没必要的，而且ASCII字符经过UTF-16编码之后高字节始终是0，导致很多C语言函数（如<code>strcpy</code>,<code>strlen</code>)会将此字节视为字符串的结束符<code>'\0'</code>，从而出现错误的计算结果。<br>而且，UTF-16还存在大小端的问题，“𤭢”（念suì）Unicode码在大端系统上为<code>D852 DF62</code>，小端系统上为<code>52D8 62DF</code>。<br>因此，UTF-16一开始推出的时候就遭到很多西方国家的抵制，影响了Unicode的推行。于是后来又设计了UTF-8编码方式，才解决了这些问题。</p><h2 id="3-5-Unicode字符集常用编码方式：UTF-8"><a href="#3-5-Unicode字符集常用编码方式：UTF-8" class="headerlink" title="3.5. Unicode字符集常用编码方式：UTF-8"></a>3.5. Unicode字符集常用编码方式：UTF-8</h2><h3 id="3-5-1-UTF-8概述"><a href="#3-5-1-UTF-8概述" class="headerlink" title="3.5.1 UTF-8概述"></a>3.5.1 UTF-8概述</h3><p>UTF-8是互联网上使用最广泛的Unicode字符集编码方式。UTF-8编码的最小单位由8位（1个字节）组成，UTF-8使用一个至四个字节来表示Unicode字符。另外，UTF-8是完美兼容ASCII字符集的，这一点可以通过下面的UTF-8的编码规则得到证明。</p><h3 id="3-5-2-UTF-8编码规则"><a href="#3-5-2-UTF-8编码规则" class="headerlink" title="3.5.2 UTF-8编码规则"></a>3.5.2 UTF-8编码规则</h3><p>UTF-8编码规则很简单：<br>（1）对于ASCII（单字节字符）字符，采用和ASCII相同的编码方式，即只使用一个字节表示，且该字节第一位为0.<br>（2）对于多字节（2~4字节）字符，假设字节数为n（1 &lt; n &lt;= 4），第一个字节：前n位都设为1，第n+1位设为0；后面的n-1个字节的前两位一律设为10。所有字节中的没有提及的其他二进制位，全部为这个符号的unicode码。 </p><table><thead><tr><th>Unicode符号范围(十六进制)</th><th>UTF-8编码方式(二进制)</th></tr></thead><tbody><tr><td>单字节:00000000-0000 007F</td><td>0xxxxxxx</td></tr><tr><td>双字节:00000080-0000 07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>三字节:00000800-0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>四字节:0001 0000-0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><h3 id="3-5-2-UTF-8-BOM"><a href="#3-5-2-UTF-8-BOM" class="headerlink" title="3.5.2 UTF-8 BOM"></a>3.5.2 UTF-8 BOM</h3><p>BOM（byte order mark）从字面意义来看是标记字节顺序的。最早出现的原因是因为UTF-16和UTF-32编码采用2个或4个字节表示一个字符，面临大小端的问题。为了区分是使用的大端(Big Endian，简称BE)还是小端(Little Endian，简称LE)，采用了在串的前面加入指定的字节加以区分，UTF-16大端加入<code>FE FF</code>，小端加入<code>FF FE</code>. 比如， 字符串“ABC”的UTF-16编码为 <code>00 41 00 42 00 43</code>，对应的各种的字节序列如下：</p><table><thead><tr><th>序列</th><th>数据</th></tr></thead><tbody><tr><td>UTF-16BE(withoutBOM)</td><td>00 41 00 42 00 43</td></tr><tr><td>UTF-16LE(withoutBOM)</td><td>41 00 42 00 43 00</td></tr><tr><td>UTF-16BE(with BOM)</td><td>FE FF 00 41 00 42 00 43</td></tr><tr><td>UTF-16LE(with BOM)</td><td>FF FE 41 00 42 00 43 00</td></tr></tbody></table><p>因为UTF-8和ASCII都是单字节序列，二者不好区分，微软采用在UTF-8编码的字符串前也加入BOM（3个字节<code>EF BB BF</code>）来标记UTF-8编码的串。UTF-8 BOM这一规范大多在windows下被使用，在其他平台下用的很少使用，如：Linux全部采用UTF-8编码，不存在要区分的情况；HTTP协议中可以包含<code>Content-Type:text/html; charset=utf-8</code>这样的说明，也不需要区分。</p>]]></content>
      
      
      <categories>
          
          <category> 拨开字符编码的迷雾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
